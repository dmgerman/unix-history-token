begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Nathan Whitehorn  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<libgeom.h>
end_include

begin_include
include|#
directive|include
file|<dialog.h>
end_include

begin_include
include|#
directive|include
file|<dlg_keys.h>
end_include

begin_include
include|#
directive|include
file|"partedit.h"
end_include

begin_define
define|#
directive|define
name|GPART_FLAGS
value|"x"
end_define

begin_comment
comment|/* Do not commit changes by default */
end_comment

begin_function
specifier|static
name|void
name|gpart_show_error
parameter_list|(
specifier|const
name|char
modifier|*
name|title
parameter_list|,
specifier|const
name|char
modifier|*
name|explanation
parameter_list|,
specifier|const
name|char
modifier|*
name|errstr
parameter_list|)
block|{
name|char
modifier|*
name|errmsg
decl_stmt|;
name|char
name|message
index|[
literal|512
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|explanation
operator|==
name|NULL
condition|)
name|explanation
operator|=
literal|""
expr_stmt|;
name|error
operator|=
name|strtol
argument_list|(
name|errstr
argument_list|,
operator|&
name|errmsg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
operator|!=
name|errstr
condition|)
block|{
while|while
condition|(
name|errmsg
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|errmsg
operator|++
expr_stmt|;
if|if
condition|(
name|errmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%s%s. %s"
argument_list|,
name|explanation
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%s%s"
argument_list|,
name|explanation
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"%s%s"
argument_list|,
name|explanation
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
block|}
name|dialog_msgbox
argument_list|(
name|title
argument_list|,
name|message
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|scheme_supports_labels
parameter_list|(
specifier|const
name|char
modifier|*
name|scheme
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|scheme
argument_list|,
literal|"APM"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|scheme
argument_list|,
literal|"GPT"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|scheme
argument_list|,
literal|"PC98"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|newfs_command
parameter_list|(
specifier|const
name|char
modifier|*
name|fstype
parameter_list|,
name|char
modifier|*
name|command
parameter_list|,
name|int
name|use_default
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fstype
argument_list|,
literal|"freebsd-ufs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|DIALOG_LISTITEM
name|items
index|[]
init|=
block|{
block|{
literal|"UFS1"
block|,
literal|"UFS Version 1"
block|,
literal|"Use version 1 of the UFS file system instead "
literal|"of version 2 (not recommended)"
block|,
literal|0
block|}
block|,
block|{
literal|"SU"
block|,
literal|"Softupdates"
block|,
literal|"Enable softupdates (default)"
block|,
literal|1
block|}
block|,
block|{
literal|"SUJ"
block|,
literal|"Softupdates journaling"
block|,
literal|"Enable file system journaling (default - "
literal|"turn off for SSDs)"
block|,
literal|1
block|}
block|,
block|{
literal|"TRIM"
block|,
literal|"Enable SSD TRIM support"
block|,
literal|"Enable TRIM support, useful on solid-state drives"
block|,
literal|0
block|}
block|, 		}
decl_stmt|;
if|if
condition|(
operator|!
name|use_default
condition|)
block|{
name|int
name|choice
decl_stmt|;
name|choice
operator|=
name|dlg_checklist
argument_list|(
literal|"UFS Options"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|items
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|items
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|items
argument_list|,
name|NULL
argument_list|,
name|FLAG_CHECK
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|choice
operator|==
literal|1
condition|)
comment|/* Cancel */
return|return;
block|}
name|strcpy
argument_list|(
name|command
argument_list|,
literal|"newfs "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|items
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|items
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|items
index|[
name|i
index|]
operator|.
name|state
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"UFS1"
argument_list|)
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|"-O1 "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"SU"
argument_list|)
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|"-U "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"SUJ"
argument_list|)
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|"-j "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"TRIM"
argument_list|)
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|"-t "
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fstype
argument_list|,
literal|"fat32"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|fstype
argument_list|,
literal|"efi"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|DIALOG_LISTITEM
name|items
index|[]
init|=
block|{
block|{
literal|"FAT32"
block|,
literal|"FAT Type 32"
block|,
literal|"Create a FAT32 filesystem (default)"
block|,
literal|1
block|}
block|,
block|{
literal|"FAT16"
block|,
literal|"FAT Type 16"
block|,
literal|"Create a FAT16 filesystem"
block|,
literal|0
block|}
block|,
block|{
literal|"FAT12"
block|,
literal|"FAT Type 12"
block|,
literal|"Create a FAT12 filesystem"
block|,
literal|0
block|}
block|, 		}
decl_stmt|;
if|if
condition|(
operator|!
name|use_default
condition|)
block|{
name|int
name|choice
decl_stmt|;
name|choice
operator|=
name|dlg_checklist
argument_list|(
literal|"FAT Options"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|items
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|items
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|items
argument_list|,
name|NULL
argument_list|,
name|FLAG_RADIO
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|choice
operator|==
literal|1
condition|)
comment|/* Cancel */
return|return;
block|}
name|strcpy
argument_list|(
name|command
argument_list|,
literal|"newfs_msdos "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|items
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|items
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|items
index|[
name|i
index|]
operator|.
name|state
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"FAT32"
argument_list|)
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|"-F 32 "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"FAT16"
argument_list|)
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|"-F 16 "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"SUJ"
argument_list|)
operator|==
literal|0
condition|)
name|strcat
argument_list|(
name|command
argument_list|,
literal|"-F 12 "
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|use_default
condition|)
name|dialog_msgbox
argument_list|(
literal|"Error"
argument_list|,
literal|"No configurable options exist "
literal|"for this filesystem."
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|command
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|gpart_partition
parameter_list|(
specifier|const
name|char
modifier|*
name|lg_name
parameter_list|,
specifier|const
name|char
modifier|*
name|scheme
parameter_list|)
block|{
name|int
name|cancel
decl_stmt|,
name|choice
decl_stmt|;
name|struct
name|gctl_req
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|DIALOG_LISTITEM
name|items
index|[]
init|=
block|{
block|{
literal|"APM"
block|,
literal|"Apple Partition Map"
block|,
literal|"Bootable on PowerPC Apple Hardware"
block|,
literal|0
block|}
block|,
block|{
literal|"BSD"
block|,
literal|"BSD Labels"
block|,
literal|"Bootable on most x86 systems"
block|,
literal|0
block|}
block|,
block|{
literal|"GPT"
block|,
literal|"GUID Partition Table"
block|,
literal|"Bootable on most x86 systems"
block|,
literal|0
block|}
block|,
block|{
literal|"MBR"
block|,
literal|"DOS Partitions"
block|,
literal|"Bootable on most x86 systems"
block|,
literal|0
block|}
block|,
block|{
literal|"PC98"
block|,
literal|"NEC PC9801 Partition Table"
block|,
literal|"Bootable on NEC PC9801 systems"
block|,
literal|0
block|}
block|,
block|{
literal|"VTOC8"
block|,
literal|"Sun VTOC8 Partition Table"
block|,
literal|"Bootable on Sun SPARC systems"
block|,
literal|0
block|}
block|, 	}
decl_stmt|;
name|schememenu
label|:
if|if
condition|(
name|scheme
operator|==
name|NULL
condition|)
block|{
name|dialog_vars
operator|.
name|default_item
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|default_scheme
argument_list|()
argument_list|)
expr_stmt|;
name|cancel
operator|=
name|dlg_menu
argument_list|(
literal|"Partition Scheme"
argument_list|,
literal|"Select a partition scheme for this volume:"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|items
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|items
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|items
argument_list|,
operator|&
name|choice
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|default_item
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cancel
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|is_scheme_bootable
argument_list|(
name|items
index|[
name|choice
index|]
operator|.
name|name
argument_list|)
condition|)
block|{
name|char
name|message
index|[
literal|512
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"This partition scheme (%s) is not "
literal|"bootable on this platform. Are you sure you want "
literal|"to proceed?"
argument_list|,
name|items
index|[
name|choice
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|defaultno
operator|=
name|TRUE
expr_stmt|;
name|cancel
operator|=
name|dialog_yesno
argument_list|(
literal|"Warning"
argument_list|,
name|message
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|defaultno
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|cancel
condition|)
comment|/* cancel */
goto|goto
name|schememenu
goto|;
block|}
name|scheme
operator|=
name|items
index|[
name|choice
index|]
operator|.
name|name
expr_stmt|;
block|}
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"PART"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"arg0"
argument_list|,
operator|-
literal|1
argument_list|,
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"flags"
argument_list|,
operator|-
literal|1
argument_list|,
name|GPART_FLAGS
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"scheme"
argument_list|,
operator|-
literal|1
argument_list|,
name|scheme
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
operator|&&
name|errstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|gpart_show_error
argument_list|(
literal|"Error"
argument_list|,
name|NULL
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|scheme
operator|=
name|NULL
expr_stmt|;
goto|goto
name|schememenu
goto|;
block|}
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootcode_path
argument_list|(
name|scheme
argument_list|)
operator|!=
name|NULL
condition|)
name|get_part_metadata
argument_list|(
name|lg_name
argument_list|,
literal|1
argument_list|)
operator|->
name|bootcode
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gpart_activate
parameter_list|(
name|struct
name|gprovider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|gconfig
modifier|*
name|gc
decl_stmt|;
name|struct
name|gctl_req
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|,
modifier|*
name|scheme
decl_stmt|;
specifier|const
name|char
modifier|*
name|attribute
init|=
name|NULL
decl_stmt|;
name|intmax_t
name|idx
decl_stmt|;
comment|/* 	 * Some partition schemes need this partition to be marked 'active' 	 * for it to be bootable. 	 */
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&pp->lg_geom->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"scheme"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scheme
operator|=
name|gc
operator|->
name|lg_val
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|scheme
argument_list|,
literal|"MBR"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|scheme
argument_list|,
literal|"EBR"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|scheme
argument_list|,
literal|"PC98"
argument_list|)
operator|==
literal|0
condition|)
name|attribute
operator|=
literal|"active"
expr_stmt|;
else|else
return|return;
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&pp->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"index"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|idx
operator|=
name|atoi
argument_list|(
name|gc
operator|->
name|lg_val
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"PART"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"arg0"
argument_list|,
operator|-
literal|1
argument_list|,
name|pp
operator|->
name|lg_geom
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"set"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"attrib"
argument_list|,
operator|-
literal|1
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"index"
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
operator|&&
name|errstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|gpart_show_error
argument_list|(
literal|"Error"
argument_list|,
literal|"Error marking partition active:"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gpart_bootcode
parameter_list|(
name|struct
name|ggeom
modifier|*
name|gp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|bootcode
decl_stmt|;
name|struct
name|gconfig
modifier|*
name|gc
decl_stmt|;
name|struct
name|gctl_req
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|,
modifier|*
name|scheme
decl_stmt|;
name|uint8_t
modifier|*
name|boot
decl_stmt|;
name|size_t
name|bootsize
decl_stmt|,
name|bytes
decl_stmt|;
name|int
name|bootfd
decl_stmt|;
comment|/* 	 * Write default bootcode to the newly partitioned disk, if that 	 * applies on this platform. 	 */
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&gp->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"scheme"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scheme
operator|=
name|gc
operator|->
name|lg_val
expr_stmt|;
break|break;
block|}
block|}
name|bootcode
operator|=
name|bootcode_path
argument_list|(
name|scheme
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootcode
operator|==
name|NULL
condition|)
return|return;
name|bootfd
operator|=
name|open
argument_list|(
name|bootcode
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootfd
operator|<=
literal|0
condition|)
block|{
name|dialog_msgbox
argument_list|(
literal|"Bootcode Error"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|bootsize
operator|=
name|lseek
argument_list|(
name|bootfd
argument_list|,
literal|0
argument_list|,
name|SEEK_END
argument_list|)
expr_stmt|;
name|boot
operator|=
name|malloc
argument_list|(
name|bootsize
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|bootfd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bytes
operator|<
name|bootsize
condition|)
name|bytes
operator|+=
name|read
argument_list|(
name|bootfd
argument_list|,
name|boot
operator|+
name|bytes
argument_list|,
name|bootsize
operator|-
name|bytes
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bootfd
argument_list|)
expr_stmt|;
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"PART"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"arg0"
argument_list|,
operator|-
literal|1
argument_list|,
name|gp
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"bootcode"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"bootcode"
argument_list|,
name|bootsize
argument_list|,
name|boot
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
operator|&&
name|errstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|gpart_show_error
argument_list|(
literal|"Bootcode Error"
argument_list|,
name|NULL
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|boot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gpart_partcode
parameter_list|(
name|struct
name|gprovider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|gconfig
modifier|*
name|gc
decl_stmt|;
specifier|const
name|char
modifier|*
name|scheme
decl_stmt|;
specifier|const
name|char
modifier|*
name|indexstr
decl_stmt|;
name|char
name|message
index|[
literal|255
index|]
decl_stmt|,
name|command
index|[
literal|255
index|]
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&pp->lg_geom->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"scheme"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scheme
operator|=
name|gc
operator|->
name|lg_val
expr_stmt|;
break|break;
block|}
block|}
comment|/* Make sure this partition scheme needs partcode on this platform */
if|if
condition|(
name|partcode_path
argument_list|(
name|scheme
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&pp->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"index"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|indexstr
operator|=
name|gc
operator|->
name|lg_val
expr_stmt|;
break|break;
block|}
block|}
comment|/* Shell out to gpart for partcode for now */
name|sprintf
argument_list|(
name|command
argument_list|,
literal|"gpart bootcode -p %s -i %s %s"
argument_list|,
name|partcode_path
argument_list|(
name|scheme
argument_list|)
argument_list|,
name|indexstr
argument_list|,
name|pp
operator|->
name|lg_geom
operator|->
name|lg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|command
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Error installing partcode on partition %s"
argument_list|,
name|pp
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|dialog_msgbox
argument_list|(
literal|"Error"
argument_list|,
name|message
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gpart_destroy
parameter_list|(
name|struct
name|ggeom
modifier|*
name|lg_geom
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|gprovider
modifier|*
name|pp
decl_stmt|;
name|struct
name|gctl_req
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
comment|/* Begin with the hosing: delete all partitions */
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|&lg_geom->lg_provider
argument_list|,
argument|lg_provider
argument_list|)
name|gpart_delete
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* Now destroy the geom itself */
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"PART"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"arg0"
argument_list|,
operator|-
literal|1
argument_list|,
name|lg_geom
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"flags"
argument_list|,
operator|-
literal|1
argument_list|,
name|GPART_FLAGS
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"destroy"
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
operator|&&
name|errstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|gpart_show_error
argument_list|(
literal|"Error"
argument_list|,
name|NULL
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* If asked, commit the change */
if|if
condition|(
name|force
condition|)
block|{
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"PART"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"arg0"
argument_list|,
operator|-
literal|1
argument_list|,
name|lg_geom
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"commit"
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
operator|&&
name|errstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|gpart_show_error
argument_list|(
literal|"Error"
argument_list|,
name|NULL
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
comment|/* And any metadata associated with the partition scheme itself */
name|delete_part_metadata
argument_list|(
name|lg_geom
operator|->
name|lg_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gpart_edit
parameter_list|(
name|struct
name|gprovider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|r
decl_stmt|;
name|struct
name|gconfig
modifier|*
name|gc
decl_stmt|;
name|struct
name|gconsumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|ggeom
modifier|*
name|geom
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|,
modifier|*
name|oldtype
decl_stmt|,
modifier|*
name|scheme
decl_stmt|;
name|struct
name|partition_metadata
modifier|*
name|md
decl_stmt|;
name|char
name|sizestr
index|[
literal|32
index|]
decl_stmt|;
name|char
name|newfs
index|[
literal|64
index|]
decl_stmt|;
name|intmax_t
name|idx
decl_stmt|;
name|int
name|hadlabel
decl_stmt|,
name|choice
decl_stmt|,
name|junk
decl_stmt|,
name|nitems
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|DIALOG_FORMITEM
name|items
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|"Type:"
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|""
block|,
literal|11
block|,
literal|0
block|,
literal|12
block|,
literal|15
block|,
literal|0
block|,
name|FALSE
block|,
literal|"Filesystem type (e.g. freebsd-ufs, freebsd-swap)"
block|,
name|FALSE
block|}
block|,
block|{
literal|0
block|,
literal|"Size:"
block|,
literal|5
block|,
literal|1
block|,
literal|0
block|,
name|FALSE
block|,
literal|""
block|,
literal|11
block|,
literal|1
block|,
literal|12
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|"Partition size. Append K, M, G for kilobytes, "
literal|"megabytes or gigabytes."
block|,
name|FALSE
block|}
block|,
block|{
literal|0
block|,
literal|"Mountpoint:"
block|,
literal|11
block|,
literal|2
block|,
literal|0
block|,
name|FALSE
block|,
literal|""
block|,
literal|11
block|,
literal|2
block|,
literal|12
block|,
literal|15
block|,
literal|0
block|,
name|FALSE
block|,
literal|"Path at which to mount this partition (leave blank "
literal|"for swap, set to / for root filesystem)"
block|,
name|FALSE
block|}
block|,
block|{
literal|0
block|,
literal|"Label:"
block|,
literal|7
block|,
literal|3
block|,
literal|0
block|,
name|FALSE
block|,
literal|""
block|,
literal|11
block|,
literal|3
block|,
literal|12
block|,
literal|15
block|,
literal|0
block|,
name|FALSE
block|,
literal|"Partition name. Not all partition schemes support this."
block|,
name|FALSE
block|}
block|, 	}
decl_stmt|;
comment|/* 	 * Find the PART geom we are manipulating. This may be a consumer of 	 * this provider, or its parent. Check the consumer case first. 	 */
name|geom
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|&pp->lg_consumers
argument_list|,
argument|lg_consumers
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|cp
operator|->
name|lg_geom
operator|->
name|lg_class
operator|->
name|lg_name
argument_list|,
literal|"PART"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|message
index|[
literal|512
index|]
decl_stmt|;
comment|/* 			 * The PART object is a consumer, so the user wants to 			 * edit the partition table. gpart doesn't really 			 * support this, so we have to hose the whole table 			 * first. 			 */
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Changing the partition scheme on "
literal|"this disk (%s) requires deleting all existing "
literal|"partitions on this drive. This will PERMANENTLY "
literal|"ERASE any data stored here. Are you sure you want "
literal|"to proceed?"
argument_list|,
name|cp
operator|->
name|lg_geom
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|defaultno
operator|=
name|TRUE
expr_stmt|;
name|choice
operator|=
name|dialog_yesno
argument_list|(
literal|"Warning"
argument_list|,
name|message
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|defaultno
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|choice
operator|==
literal|1
condition|)
comment|/* cancel */
return|return;
comment|/* Destroy the geom and all sub-partitions */
name|gpart_destroy
argument_list|(
name|cp
operator|->
name|lg_geom
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now re-partition and return */
name|gpart_partition
argument_list|(
name|cp
operator|->
name|lg_geom
operator|->
name|lg_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|geom
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pp
operator|->
name|lg_geom
operator|->
name|lg_class
operator|->
name|lg_name
argument_list|,
literal|"PART"
argument_list|)
operator|==
literal|0
condition|)
name|geom
operator|=
name|pp
operator|->
name|lg_geom
expr_stmt|;
if|if
condition|(
name|geom
operator|==
name|NULL
condition|)
block|{
comment|/* Disk not partitioned, so partition it */
name|gpart_partition
argument_list|(
name|pp
operator|->
name|lg_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&geom->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"scheme"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scheme
operator|=
name|gc
operator|->
name|lg_val
expr_stmt|;
break|break;
block|}
block|}
name|nitems
operator|=
name|scheme_supports_labels
argument_list|(
name|scheme
argument_list|)
condition|?
literal|4
else|:
literal|3
expr_stmt|;
comment|/* Edit editable parameters of a partition */
name|hadlabel
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&pp->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|oldtype
operator|=
name|gc
operator|->
name|lg_val
expr_stmt|;
name|items
index|[
literal|0
index|]
operator|.
name|text
operator|=
name|gc
operator|->
name|lg_val
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"label"
argument_list|)
operator|==
literal|0
operator|&&
name|gc
operator|->
name|lg_val
operator|!=
name|NULL
condition|)
block|{
name|hadlabel
operator|=
literal|1
expr_stmt|;
name|items
index|[
literal|3
index|]
operator|.
name|text
operator|=
name|gc
operator|->
name|lg_val
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"index"
argument_list|)
operator|==
literal|0
condition|)
name|idx
operator|=
name|atoi
argument_list|(
name|gc
operator|->
name|lg_val
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|md
argument_list|,
argument|&part_metadata
argument_list|,
argument|metadata
argument_list|)
block|{
if|if
condition|(
name|md
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|md
operator|->
name|name
argument_list|,
name|pp
operator|->
name|lg_name
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|md
operator|->
name|fstab
operator|!=
name|NULL
condition|)
name|items
index|[
literal|2
index|]
operator|.
name|text
operator|=
name|md
operator|->
name|fstab
operator|->
name|fs_file
expr_stmt|;
break|break;
block|}
block|}
name|humanize_number
argument_list|(
name|sizestr
argument_list|,
literal|7
argument_list|,
name|pp
operator|->
name|lg_mediasize
argument_list|,
literal|"B"
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_NOSPACE
operator||
name|HN_DECIMAL
argument_list|)
expr_stmt|;
name|items
index|[
literal|1
index|]
operator|.
name|text
operator|=
name|sizestr
expr_stmt|;
name|editpart
label|:
name|choice
operator|=
name|dlg_form
argument_list|(
literal|"Edit Partition"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|nitems
argument_list|,
name|items
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
if|if
condition|(
name|choice
condition|)
comment|/* Cancel pressed */
return|return;
comment|/* Check if the label has a / in it */
if|if
condition|(
name|strchr
argument_list|(
name|items
index|[
literal|3
index|]
operator|.
name|text
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|dialog_msgbox
argument_list|(
literal|"Error"
argument_list|,
literal|"Label contains a /, which is not an "
literal|"allowed character."
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|editpart
goto|;
block|}
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"PART"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"arg0"
argument_list|,
operator|-
literal|1
argument_list|,
name|geom
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"flags"
argument_list|,
operator|-
literal|1
argument_list|,
name|GPART_FLAGS
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"modify"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"index"
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|hadlabel
operator|||
name|items
index|[
literal|3
index|]
operator|.
name|text
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"label"
argument_list|,
operator|-
literal|1
argument_list|,
name|items
index|[
literal|3
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"type"
argument_list|,
operator|-
literal|1
argument_list|,
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
operator|&&
name|errstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|gpart_show_error
argument_list|(
literal|"Error"
argument_list|,
name|NULL
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
goto|goto
name|editpart
goto|;
block|}
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|newfs_command
argument_list|(
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|,
name|newfs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_default_part_metadata
argument_list|(
name|pp
operator|->
name|lg_name
argument_list|,
name|scheme
argument_list|,
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|,
name|items
index|[
literal|2
index|]
operator|.
name|text
argument_list|,
operator|(
name|strcmp
argument_list|(
name|oldtype
argument_list|,
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
operator|!=
literal|0
operator|)
condition|?
name|newfs
else|:
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|items
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|items
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|items
index|[
name|i
index|]
operator|.
name|text_free
condition|)
name|free
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_default_part_metadata
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|scheme
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|mountpoint
parameter_list|,
specifier|const
name|char
modifier|*
name|newfs
parameter_list|)
block|{
name|struct
name|partition_metadata
modifier|*
name|md
decl_stmt|;
comment|/* Set part metadata */
name|md
operator|=
name|get_part_metadata
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfs
condition|)
block|{
if|if
condition|(
name|md
operator|->
name|newfs
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|md
operator|->
name|newfs
argument_list|)
expr_stmt|;
name|md
operator|->
name|newfs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|newfs
operator|!=
name|NULL
operator|&&
name|newfs
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|md
operator|->
name|newfs
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|newfs
argument_list|)
operator|+
name|strlen
argument_list|(
literal|" /dev/"
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|md
operator|->
name|newfs
argument_list|,
literal|"%s /dev/%s"
argument_list|,
name|newfs
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"freebsd-swap"
argument_list|)
operator|==
literal|0
condition|)
name|mountpoint
operator|=
literal|"none"
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"freebsd-boot"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|->
name|bootcode
operator|=
literal|1
expr_stmt|;
comment|/* VTOC8 needs partcode in UFS partitions */
if|if
condition|(
name|strcmp
argument_list|(
name|scheme
argument_list|,
literal|"VTOC8"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"freebsd-ufs"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|->
name|bootcode
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mountpoint
operator|==
name|NULL
operator|||
name|mountpoint
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|md
operator|->
name|fstab
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_spec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_vfstype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_mntops
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|md
operator|->
name|fstab
argument_list|)
expr_stmt|;
name|md
operator|->
name|fstab
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|md
operator|->
name|fstab
operator|==
name|NULL
condition|)
block|{
name|md
operator|->
name|fstab
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fstab
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_spec
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_vfstype
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_mntops
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_type
argument_list|)
expr_stmt|;
block|}
name|md
operator|->
name|fstab
operator|->
name|fs_spec
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_spec
argument_list|,
literal|"/dev/%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|md
operator|->
name|fstab
operator|->
name|fs_file
operator|=
name|strdup
argument_list|(
name|mountpoint
argument_list|)
expr_stmt|;
comment|/* Get VFS from text after freebsd-, if possible */
if|if
condition|(
name|strncmp
argument_list|(
literal|"freebsd-"
argument_list|,
name|type
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|->
name|fstab
operator|->
name|fs_vfstype
operator|=
name|strdup
argument_list|(
operator|&
name|type
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"fat32"
argument_list|,
name|type
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"efi"
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|->
name|fstab
operator|->
name|fs_vfstype
operator|=
name|strdup
argument_list|(
literal|"msdosfs"
argument_list|)
expr_stmt|;
else|else
name|md
operator|->
name|fstab
operator|->
name|fs_vfstype
operator|=
name|strdup
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Guess */
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"freebsd-swap"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|->
name|fstab
operator|->
name|fs_type
operator|=
name|strdup
argument_list|(
name|FSTAB_SW
argument_list|)
expr_stmt|;
name|md
operator|->
name|fstab
operator|->
name|fs_freq
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|fstab
operator|->
name|fs_passno
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|fstab
operator|->
name|fs_type
operator|=
name|strdup
argument_list|(
name|FSTAB_RW
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|md
operator|->
name|fstab
operator|->
name|fs_freq
operator|=
literal|1
expr_stmt|;
name|md
operator|->
name|fstab
operator|->
name|fs_passno
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|fstab
operator|->
name|fs_freq
operator|=
literal|2
expr_stmt|;
name|md
operator|->
name|fstab
operator|->
name|fs_passno
operator|=
literal|2
expr_stmt|;
block|}
block|}
name|md
operator|->
name|fstab
operator|->
name|fs_mntops
operator|=
name|strdup
argument_list|(
name|md
operator|->
name|fstab
operator|->
name|fs_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|part_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|xa
parameter_list|,
specifier|const
name|void
modifier|*
name|xb
parameter_list|)
block|{
name|struct
name|gprovider
modifier|*
modifier|*
name|a
init|=
operator|(
expr|struct
name|gprovider
operator|*
operator|*
operator|)
name|xa
decl_stmt|;
name|struct
name|gprovider
modifier|*
modifier|*
name|b
init|=
operator|(
expr|struct
name|gprovider
operator|*
operator|*
operator|)
name|xb
decl_stmt|;
name|intmax_t
name|astart
decl_stmt|,
name|bstart
decl_stmt|;
name|struct
name|gconfig
modifier|*
name|gc
decl_stmt|;
name|astart
operator|=
name|bstart
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&(*a)->lg_config
argument_list|,
argument|lg_config
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"start"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|astart
operator|=
name|strtoimax
argument_list|(
name|gc
operator|->
name|lg_val
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&(*b)->lg_config
argument_list|,
argument|lg_config
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"start"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bstart
operator|=
name|strtoimax
argument_list|(
name|gc
operator|->
name|lg_val
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|astart
operator|<
name|bstart
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|astart
operator|>
name|bstart
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intmax_t
name|gpart_max_free
parameter_list|(
name|struct
name|ggeom
modifier|*
name|geom
parameter_list|,
name|intmax_t
modifier|*
name|npartstart
parameter_list|)
block|{
name|struct
name|gconfig
modifier|*
name|gc
decl_stmt|;
name|struct
name|gprovider
modifier|*
name|pp
decl_stmt|,
modifier|*
modifier|*
name|providers
decl_stmt|;
name|intmax_t
name|lastend
decl_stmt|;
name|intmax_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|intmax_t
name|maxsize
decl_stmt|,
name|maxstart
decl_stmt|;
name|intmax_t
name|partstart
decl_stmt|,
name|partend
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nparts
decl_stmt|;
comment|/* Now get the maximum free size and free start */
name|start
operator|=
name|end
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&geom->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"first"
argument_list|)
operator|==
literal|0
condition|)
name|start
operator|=
name|strtoimax
argument_list|(
name|gc
operator|->
name|lg_val
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"last"
argument_list|)
operator|==
literal|0
condition|)
name|end
operator|=
name|strtoimax
argument_list|(
name|gc
operator|->
name|lg_val
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|nparts
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|&geom->lg_provider
argument_list|,
argument|lg_provider
argument_list|)
name|nparts
operator|++
expr_stmt|;
name|providers
operator|=
name|calloc
argument_list|(
name|nparts
argument_list|,
sizeof|sizeof
argument_list|(
name|providers
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|&geom->lg_provider
argument_list|,
argument|lg_provider
argument_list|)
name|providers
index|[
name|i
operator|++
index|]
operator|=
name|pp
expr_stmt|;
name|qsort
argument_list|(
name|providers
argument_list|,
name|nparts
argument_list|,
sizeof|sizeof
argument_list|(
name|providers
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|part_compare
argument_list|)
expr_stmt|;
name|lastend
operator|=
name|start
operator|-
literal|1
expr_stmt|;
name|maxsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nparts
condition|;
name|i
operator|++
control|)
block|{
name|pp
operator|=
name|providers
index|[
name|i
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&pp->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"start"
argument_list|)
operator|==
literal|0
condition|)
name|partstart
operator|=
name|strtoimax
argument_list|(
name|gc
operator|->
name|lg_val
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"end"
argument_list|)
operator|==
literal|0
condition|)
name|partend
operator|=
name|strtoimax
argument_list|(
name|gc
operator|->
name|lg_val
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|partstart
operator|-
name|lastend
operator|>
name|maxsize
condition|)
block|{
name|maxsize
operator|=
name|partstart
operator|-
name|lastend
operator|-
literal|1
expr_stmt|;
name|maxstart
operator|=
name|lastend
operator|+
literal|1
expr_stmt|;
block|}
name|lastend
operator|=
name|partend
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|-
name|lastend
operator|>
name|maxsize
condition|)
block|{
name|maxsize
operator|=
name|end
operator|-
name|lastend
operator|-
literal|1
expr_stmt|;
name|maxstart
operator|=
name|lastend
operator|+
literal|1
expr_stmt|;
block|}
name|pp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|geom
operator|->
name|lg_consumer
argument_list|)
operator|->
name|lg_provider
expr_stmt|;
comment|/* Compute beginning of new partition and maximum available space */
if|if
condition|(
name|pp
operator|->
name|lg_stripesize
operator|>
literal|0
operator|&&
operator|(
name|maxstart
operator|*
name|pp
operator|->
name|lg_sectorsize
operator|%
name|pp
operator|->
name|lg_stripesize
operator|)
operator|!=
literal|0
condition|)
block|{
name|intmax_t
name|offset
init|=
operator|(
name|pp
operator|->
name|lg_stripesize
operator|-
operator|(
operator|(
name|maxstart
operator|*
name|pp
operator|->
name|lg_sectorsize
operator|)
operator|%
name|pp
operator|->
name|lg_stripesize
operator|)
operator|)
operator|/
name|pp
operator|->
name|lg_sectorsize
decl_stmt|;
name|maxstart
operator|+=
name|offset
expr_stmt|;
name|maxsize
operator|-=
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|npartstart
operator|!=
name|NULL
condition|)
operator|*
name|npartstart
operator|=
name|maxstart
expr_stmt|;
return|return
operator|(
name|maxsize
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gpart_create
parameter_list|(
name|struct
name|gprovider
modifier|*
name|pp
parameter_list|,
name|char
modifier|*
name|default_type
parameter_list|,
name|char
modifier|*
name|default_size
parameter_list|,
name|char
modifier|*
name|default_mountpoint
parameter_list|,
name|char
modifier|*
modifier|*
name|partname
parameter_list|,
name|int
name|interactive
parameter_list|)
block|{
name|struct
name|gctl_req
modifier|*
name|r
decl_stmt|;
name|struct
name|gconfig
modifier|*
name|gc
decl_stmt|;
name|struct
name|gconsumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|ggeom
modifier|*
name|geom
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|,
modifier|*
name|scheme
decl_stmt|;
name|char
name|sizestr
index|[
literal|32
index|]
decl_stmt|,
name|startstr
index|[
literal|32
index|]
decl_stmt|,
name|output
index|[
literal|64
index|]
decl_stmt|;
name|char
name|newfs
index|[
literal|64
index|]
decl_stmt|,
name|options_fstype
index|[
literal|64
index|]
decl_stmt|;
name|intmax_t
name|maxsize
decl_stmt|,
name|size
decl_stmt|,
name|sector
decl_stmt|,
name|firstfree
decl_stmt|,
name|stripe
decl_stmt|;
name|uint64_t
name|bytes
decl_stmt|;
name|int
name|nitems
decl_stmt|,
name|choice
decl_stmt|,
name|junk
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|DIALOG_FORMITEM
name|items
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|"Type:"
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
name|FALSE
block|,
literal|"freebsd-ufs"
block|,
literal|11
block|,
literal|0
block|,
literal|12
block|,
literal|15
block|,
literal|0
block|,
name|FALSE
block|,
literal|"Filesystem type (e.g. freebsd-ufs, freebsd-swap)"
block|,
name|FALSE
block|}
block|,
block|{
literal|0
block|,
literal|"Size:"
block|,
literal|5
block|,
literal|1
block|,
literal|0
block|,
name|FALSE
block|,
literal|""
block|,
literal|11
block|,
literal|1
block|,
literal|12
block|,
literal|15
block|,
literal|0
block|,
name|FALSE
block|,
literal|"Partition size. Append K, M, G for kilobytes, "
literal|"megabytes or gigabytes."
block|,
name|FALSE
block|}
block|,
block|{
literal|0
block|,
literal|"Mountpoint:"
block|,
literal|11
block|,
literal|2
block|,
literal|0
block|,
name|FALSE
block|,
literal|""
block|,
literal|11
block|,
literal|2
block|,
literal|12
block|,
literal|15
block|,
literal|0
block|,
name|FALSE
block|,
literal|"Path at which to mount partition (blank for "
literal|"swap, / for root filesystem)"
block|,
name|FALSE
block|}
block|,
block|{
literal|0
block|,
literal|"Label:"
block|,
literal|7
block|,
literal|3
block|,
literal|0
block|,
name|FALSE
block|,
literal|""
block|,
literal|11
block|,
literal|3
block|,
literal|12
block|,
literal|15
block|,
literal|0
block|,
name|FALSE
block|,
literal|"Partition name. Not all partition schemes support this."
block|,
name|FALSE
block|}
block|, 	}
decl_stmt|;
if|if
condition|(
name|partname
operator|!=
name|NULL
condition|)
operator|*
name|partname
operator|=
name|NULL
expr_stmt|;
comment|/* Record sector and stripe sizes */
name|sector
operator|=
name|pp
operator|->
name|lg_sectorsize
expr_stmt|;
name|stripe
operator|=
name|pp
operator|->
name|lg_stripesize
expr_stmt|;
comment|/* 	 * Find the PART geom we are manipulating. This may be a consumer of 	 * this provider, or its parent. Check the consumer case first. 	 */
name|geom
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|&pp->lg_consumers
argument_list|,
argument|lg_consumers
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|cp
operator|->
name|lg_geom
operator|->
name|lg_class
operator|->
name|lg_name
argument_list|,
literal|"PART"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|geom
operator|=
name|cp
operator|->
name|lg_geom
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|geom
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pp
operator|->
name|lg_geom
operator|->
name|lg_class
operator|->
name|lg_name
argument_list|,
literal|"PART"
argument_list|)
operator|==
literal|0
condition|)
name|geom
operator|=
name|pp
operator|->
name|lg_geom
expr_stmt|;
comment|/* Now get the partition scheme */
name|scheme
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|geom
operator|!=
name|NULL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&geom->lg_config
argument_list|,
argument|lg_config
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"scheme"
argument_list|)
operator|==
literal|0
condition|)
name|scheme
operator|=
name|gc
operator|->
name|lg_val
expr_stmt|;
block|}
if|if
condition|(
name|geom
operator|==
name|NULL
operator|||
name|scheme
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|scheme
argument_list|,
literal|"(none)"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gpart_partition
argument_list|(
name|pp
operator|->
name|lg_name
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|dialog_msgbox
argument_list|(
literal|""
argument_list|,
literal|"The partition table has been successfully created."
literal|" Please press Create again to create partitions."
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we still don't have a geom, either the user has 	 * canceled partitioning or there has been an error which has already 	 * been displayed, so bail. 	 */
if|if
condition|(
name|geom
operator|==
name|NULL
condition|)
return|return;
name|maxsize
operator|=
name|size
operator|=
name|gpart_max_free
argument_list|(
name|geom
argument_list|,
operator|&
name|firstfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
name|dialog_msgbox
argument_list|(
literal|"Error"
argument_list|,
literal|"No free space left on device."
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|humanize_number
argument_list|(
name|sizestr
argument_list|,
literal|7
argument_list|,
name|size
operator|*
name|sector
argument_list|,
literal|"B"
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_NOSPACE
operator||
name|HN_DECIMAL
argument_list|)
expr_stmt|;
name|items
index|[
literal|1
index|]
operator|.
name|text
operator|=
name|sizestr
expr_stmt|;
comment|/* Special-case the MBR default type for nested partitions */
if|if
condition|(
name|strcmp
argument_list|(
name|scheme
argument_list|,
literal|"MBR"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|scheme
argument_list|,
literal|"PC98"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|items
index|[
literal|0
index|]
operator|.
name|text
operator|=
literal|"freebsd"
expr_stmt|;
name|items
index|[
literal|0
index|]
operator|.
name|help
operator|=
literal|"Filesystem type (e.g. freebsd, fat32)"
expr_stmt|;
block|}
name|nitems
operator|=
name|scheme_supports_labels
argument_list|(
name|scheme
argument_list|)
condition|?
literal|4
else|:
literal|3
expr_stmt|;
if|if
condition|(
name|default_type
operator|!=
name|NULL
condition|)
name|items
index|[
literal|0
index|]
operator|.
name|text
operator|=
name|default_type
expr_stmt|;
if|if
condition|(
name|default_size
operator|!=
name|NULL
condition|)
name|items
index|[
literal|1
index|]
operator|.
name|text
operator|=
name|default_size
expr_stmt|;
if|if
condition|(
name|default_mountpoint
operator|!=
name|NULL
condition|)
name|items
index|[
literal|2
index|]
operator|.
name|text
operator|=
name|default_mountpoint
expr_stmt|;
comment|/* Default options */
name|strncpy
argument_list|(
name|options_fstype
argument_list|,
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|options_fstype
argument_list|)
argument_list|)
expr_stmt|;
name|newfs_command
argument_list|(
name|options_fstype
argument_list|,
name|newfs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|addpartform
label|:
if|if
condition|(
name|interactive
condition|)
block|{
name|dialog_vars
operator|.
name|extra_label
operator|=
literal|"Options"
expr_stmt|;
name|dialog_vars
operator|.
name|extra_button
operator|=
name|TRUE
expr_stmt|;
name|choice
operator|=
name|dlg_form
argument_list|(
literal|"Add Partition"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|nitems
argument_list|,
name|items
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|extra_button
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|choice
condition|)
block|{
case|case
literal|0
case|:
comment|/* OK */
break|break;
case|case
literal|1
case|:
comment|/* Cancel */
return|return;
case|case
literal|3
case|:
comment|/* Options */
name|strncpy
argument_list|(
name|options_fstype
argument_list|,
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|options_fstype
argument_list|)
argument_list|)
expr_stmt|;
name|newfs_command
argument_list|(
name|options_fstype
argument_list|,
name|newfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|addpartform
goto|;
block|}
block|}
comment|/* 	 * If the user changed the fs type after specifying options, undo 	 * their choices in favor of the new filesystem's defaults. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|options_fstype
argument_list|,
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|options_fstype
argument_list|,
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|,
sizeof|sizeof
argument_list|(
name|options_fstype
argument_list|)
argument_list|)
expr_stmt|;
name|newfs_command
argument_list|(
name|options_fstype
argument_list|,
name|newfs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|maxsize
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|items
index|[
literal|1
index|]
operator|.
name|text
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|expand_number
argument_list|(
name|items
index|[
literal|1
index|]
operator|.
name|text
argument_list|,
operator|&
name|bytes
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
name|error
index|[
literal|512
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|error
argument_list|,
literal|"Invalid size: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dialog_msgbox
argument_list|(
literal|"Error"
argument_list|,
name|error
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|addpartform
goto|;
block|}
name|size
operator|=
name|MIN
argument_list|(
call|(
name|intmax_t
call|)
argument_list|(
name|bytes
operator|/
name|sector
argument_list|)
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
block|}
comment|/* Check if the label has a / in it */
if|if
condition|(
name|strchr
argument_list|(
name|items
index|[
literal|3
index|]
operator|.
name|text
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|dialog_msgbox
argument_list|(
literal|"Error"
argument_list|,
literal|"Label contains a /, which is not an "
literal|"allowed character."
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
goto|goto
name|addpartform
goto|;
block|}
comment|/* Warn if no mountpoint set */
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|,
literal|"freebsd-ufs"
argument_list|)
operator|==
literal|0
operator|&&
name|items
index|[
literal|2
index|]
operator|.
name|text
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|dialog_vars
operator|.
name|defaultno
operator|=
name|TRUE
expr_stmt|;
name|choice
operator|=
name|dialog_yesno
argument_list|(
literal|"Warning"
argument_list|,
literal|"This partition does not have a valid mountpoint "
literal|"(for the partition from which you intend to boot the "
literal|"operating system, the mountpoint should be /). Are you "
literal|"sure you want to continue?"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|defaultno
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|choice
operator|==
literal|1
condition|)
comment|/* cancel */
goto|goto
name|addpartform
goto|;
block|}
comment|/* If this is the root partition, check that this scheme is bootable */
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
literal|2
index|]
operator|.
name|text
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_scheme_bootable
argument_list|(
name|scheme
argument_list|)
condition|)
block|{
name|char
name|message
index|[
literal|512
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"This partition scheme (%s) is not bootable "
literal|"on this platform. Are you sure you want to proceed?"
argument_list|,
name|scheme
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|defaultno
operator|=
name|TRUE
expr_stmt|;
name|choice
operator|=
name|dialog_yesno
argument_list|(
literal|"Warning"
argument_list|,
name|message
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|defaultno
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|choice
operator|==
literal|1
condition|)
comment|/* cancel */
goto|goto
name|addpartform
goto|;
block|}
comment|/* 	 * If this is the root partition, and we need a boot partition, ask 	 * the user to add one. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
literal|2
index|]
operator|.
name|text
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
operator|&&
name|bootpart_size
argument_list|(
name|scheme
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|interactive
condition|)
name|choice
operator|=
name|dialog_yesno
argument_list|(
literal|"Boot Partition"
argument_list|,
literal|"This partition scheme requires a boot partition "
literal|"for the disk to be bootable. Would you like to "
literal|"make one now?"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|choice
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|choice
operator|==
literal|0
condition|)
block|{
comment|/* yes */
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"PART"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"arg0"
argument_list|,
operator|-
literal|1
argument_list|,
name|geom
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"flags"
argument_list|,
operator|-
literal|1
argument_list|,
name|GPART_FLAGS
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"add"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"type"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"freebsd-boot"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sizestr
argument_list|,
sizeof|sizeof
argument_list|(
name|sizestr
argument_list|)
argument_list|,
literal|"%jd"
argument_list|,
name|bootpart_size
argument_list|(
name|scheme
argument_list|)
operator|/
name|sector
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"size"
argument_list|,
operator|-
literal|1
argument_list|,
name|sizestr
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|startstr
argument_list|,
sizeof|sizeof
argument_list|(
name|startstr
argument_list|)
argument_list|,
literal|"%jd"
argument_list|,
name|firstfree
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"start"
argument_list|,
operator|-
literal|1
argument_list|,
name|startstr
argument_list|)
expr_stmt|;
name|gctl_rw_param
argument_list|(
name|r
argument_list|,
literal|"output"
argument_list|,
sizeof|sizeof
argument_list|(
name|output
argument_list|)
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
operator|&&
name|errstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|gpart_show_error
argument_list|(
literal|"Error"
argument_list|,
name|NULL
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|get_part_metadata
argument_list|(
name|strtok
argument_list|(
name|output
argument_list|,
literal|" "
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|->
name|bootcode
operator|=
literal|1
expr_stmt|;
comment|/* Now adjust the part we are really adding forward */
name|firstfree
operator|+=
name|bootpart_size
argument_list|(
name|scheme
argument_list|)
operator|/
name|sector
expr_stmt|;
name|size
operator|-=
operator|(
name|bootpart_size
argument_list|(
name|scheme
argument_list|)
operator|+
name|stripe
operator|)
operator|/
name|sector
expr_stmt|;
if|if
condition|(
name|stripe
operator|>
literal|0
operator|&&
operator|(
name|firstfree
operator|*
name|sector
operator|%
name|stripe
operator|)
operator|!=
literal|0
condition|)
name|firstfree
operator|+=
operator|(
name|stripe
operator|-
operator|(
operator|(
name|firstfree
operator|*
name|sector
operator|)
operator|%
name|stripe
operator|)
operator|)
operator|/
name|sector
expr_stmt|;
block|}
block|}
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"PART"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"arg0"
argument_list|,
operator|-
literal|1
argument_list|,
name|geom
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"flags"
argument_list|,
operator|-
literal|1
argument_list|,
name|GPART_FLAGS
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"add"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"type"
argument_list|,
operator|-
literal|1
argument_list|,
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|sizestr
argument_list|,
sizeof|sizeof
argument_list|(
name|sizestr
argument_list|)
argument_list|,
literal|"%jd"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"size"
argument_list|,
operator|-
literal|1
argument_list|,
name|sizestr
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|startstr
argument_list|,
sizeof|sizeof
argument_list|(
name|startstr
argument_list|)
argument_list|,
literal|"%jd"
argument_list|,
name|firstfree
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"start"
argument_list|,
operator|-
literal|1
argument_list|,
name|startstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|items
index|[
literal|3
index|]
operator|.
name|text
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"label"
argument_list|,
operator|-
literal|1
argument_list|,
name|items
index|[
literal|3
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|gctl_rw_param
argument_list|(
name|r
argument_list|,
literal|"output"
argument_list|,
sizeof|sizeof
argument_list|(
name|output
argument_list|)
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
operator|&&
name|errstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|gpart_show_error
argument_list|(
literal|"Error"
argument_list|,
name|NULL
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
goto|goto
name|addpartform
goto|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|,
literal|"freebsd-boot"
argument_list|)
operator|==
literal|0
condition|)
name|get_part_metadata
argument_list|(
name|strtok
argument_list|(
name|output
argument_list|,
literal|" "
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|->
name|bootcode
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|,
literal|"freebsd"
argument_list|)
operator|==
literal|0
condition|)
name|gpart_partition
argument_list|(
name|strtok
argument_list|(
name|output
argument_list|,
literal|" "
argument_list|)
argument_list|,
literal|"BSD"
argument_list|)
expr_stmt|;
else|else
name|set_default_part_metadata
argument_list|(
name|strtok
argument_list|(
name|output
argument_list|,
literal|" "
argument_list|)
argument_list|,
name|scheme
argument_list|,
name|items
index|[
literal|0
index|]
operator|.
name|text
argument_list|,
name|items
index|[
literal|2
index|]
operator|.
name|text
argument_list|,
name|newfs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|items
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|items
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|items
index|[
name|i
index|]
operator|.
name|text_free
condition|)
name|free
argument_list|(
name|items
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|partname
operator|!=
name|NULL
condition|)
operator|*
name|partname
operator|=
name|strdup
argument_list|(
name|strtok
argument_list|(
name|output
argument_list|,
literal|" "
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gpart_delete
parameter_list|(
name|struct
name|gprovider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|gconfig
modifier|*
name|gc
decl_stmt|;
name|struct
name|ggeom
modifier|*
name|geom
decl_stmt|;
name|struct
name|gconsumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|gctl_req
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|intmax_t
name|idx
decl_stmt|;
name|int
name|choice
decl_stmt|,
name|is_partition
decl_stmt|;
comment|/* Is it a partition? */
name|is_partition
operator|=
operator|(
name|strcmp
argument_list|(
name|pp
operator|->
name|lg_geom
operator|->
name|lg_class
operator|->
name|lg_name
argument_list|,
literal|"PART"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* Find out if this is the root of a gpart geom */
name|geom
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|&pp->lg_consumers
argument_list|,
argument|lg_consumers
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|cp
operator|->
name|lg_geom
operator|->
name|lg_class
operator|->
name|lg_name
argument_list|,
literal|"PART"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|geom
operator|=
name|cp
operator|->
name|lg_geom
expr_stmt|;
break|break;
block|}
comment|/* Destroy all consumers */
if|if
condition|(
name|geom
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|is_partition
condition|)
block|{
name|char
name|message
index|[
literal|512
index|]
decl_stmt|;
comment|/* 			 * We have to actually really delete the sub-partition 			 * tree so that the consumers will go away and the 			 * partition can be deleted. Warn the user. 			 */
name|sprintf
argument_list|(
name|message
argument_list|,
literal|"Deleting this partition (%s) "
literal|"requires deleting all existing sub-partitions. "
literal|"This will PERMANENTLY ERASE any data stored here "
literal|"and CANNOT BE REVERTED. Are you sure you want to "
literal|"proceed?"
argument_list|,
name|cp
operator|->
name|lg_geom
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|defaultno
operator|=
name|TRUE
expr_stmt|;
name|choice
operator|=
name|dialog_yesno
argument_list|(
literal|"Warning"
argument_list|,
name|message
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dialog_vars
operator|.
name|defaultno
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|choice
operator|==
literal|1
condition|)
comment|/* cancel */
return|return;
block|}
name|gpart_destroy
argument_list|(
name|geom
argument_list|,
name|is_partition
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this is not a partition, see if that is a problem, complain if 	 * necessary, and return always, since we need not do anything further, 	 * error or no. 	 */
if|if
condition|(
operator|!
name|is_partition
condition|)
block|{
if|if
condition|(
name|geom
operator|==
name|NULL
condition|)
name|dialog_msgbox
argument_list|(
literal|"Error"
argument_list|,
literal|"Only partitions can be deleted."
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
name|pp
operator|->
name|lg_geom
operator|->
name|lg_class
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"arg0"
argument_list|,
operator|-
literal|1
argument_list|,
name|pp
operator|->
name|lg_geom
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"flags"
argument_list|,
operator|-
literal|1
argument_list|,
name|GPART_FLAGS
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"delete"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&pp->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"index"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|idx
operator|=
name|atoi
argument_list|(
name|gc
operator|->
name|lg_val
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"index"
argument_list|,
sizeof|sizeof
argument_list|(
name|idx
argument_list|)
argument_list|,
operator|&
name|idx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
operator|&&
name|errstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|gpart_show_error
argument_list|(
literal|"Error"
argument_list|,
name|NULL
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|delete_part_metadata
argument_list|(
name|pp
operator|->
name|lg_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gpart_revert_all
parameter_list|(
name|struct
name|gmesh
modifier|*
name|mesh
parameter_list|)
block|{
name|struct
name|gclass
modifier|*
name|classp
decl_stmt|;
name|struct
name|gconfig
modifier|*
name|gc
decl_stmt|;
name|struct
name|ggeom
modifier|*
name|gp
decl_stmt|;
name|struct
name|gctl_req
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|modified
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|classp
argument_list|,
argument|&mesh->lg_class
argument_list|,
argument|lg_class
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|classp
operator|->
name|lg_name
argument_list|,
literal|"PART"
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|classp
operator|->
name|lg_name
argument_list|,
literal|"PART"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dialog_msgbox
argument_list|(
literal|"Error"
argument_list|,
literal|"gpart not found!"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&classp->lg_geom
argument_list|,
argument|lg_geom
argument_list|)
block|{
name|modified
operator|=
literal|"true"
expr_stmt|;
comment|/* XXX: If we don't know (kernel too old), 				    * assume there are modifications. */
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&gp->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"modified"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|modified
operator|=
name|gc
operator|->
name|lg_val
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|modified
argument_list|,
literal|"false"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"PART"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"arg0"
argument_list|,
operator|-
literal|1
argument_list|,
name|gp
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"undo"
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
operator|&&
name|errstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|gpart_show_error
argument_list|(
literal|"Error"
argument_list|,
name|NULL
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gpart_commit
parameter_list|(
name|struct
name|gmesh
modifier|*
name|mesh
parameter_list|)
block|{
name|struct
name|partition_metadata
modifier|*
name|md
decl_stmt|;
name|struct
name|gclass
modifier|*
name|classp
decl_stmt|;
name|struct
name|ggeom
modifier|*
name|gp
decl_stmt|;
name|struct
name|gconfig
modifier|*
name|gc
decl_stmt|;
name|struct
name|gconsumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|gprovider
modifier|*
name|pp
decl_stmt|;
name|struct
name|gctl_req
modifier|*
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|modified
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|classp
argument_list|,
argument|&mesh->lg_class
argument_list|,
argument|lg_class
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|classp
operator|->
name|lg_name
argument_list|,
literal|"PART"
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|classp
operator|->
name|lg_name
argument_list|,
literal|"PART"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dialog_msgbox
argument_list|(
literal|"Error"
argument_list|,
literal|"gpart not found!"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&classp->lg_geom
argument_list|,
argument|lg_geom
argument_list|)
block|{
name|modified
operator|=
literal|"true"
expr_stmt|;
comment|/* XXX: If we don't know (kernel too old), 				    * assume there are modifications. */
name|LIST_FOREACH
argument_list|(
argument|gc
argument_list|,
argument|&gp->lg_config
argument_list|,
argument|lg_config
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gc
operator|->
name|lg_name
argument_list|,
literal|"modified"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|modified
operator|=
name|gc
operator|->
name|lg_val
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|modified
argument_list|,
literal|"false"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Add bootcode if necessary, before the commit */
name|md
operator|=
name|get_part_metadata
argument_list|(
name|gp
operator|->
name|lg_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|!=
name|NULL
operator|&&
name|md
operator|->
name|bootcode
condition|)
name|gpart_bootcode
argument_list|(
name|gp
argument_list|)
expr_stmt|;
comment|/* Now install partcode on its partitions, if necessary */
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|&gp->lg_provider
argument_list|,
argument|lg_provider
argument_list|)
block|{
name|md
operator|=
name|get_part_metadata
argument_list|(
name|pp
operator|->
name|lg_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
operator|||
operator|!
name|md
operator|->
name|bootcode
condition|)
continue|continue;
comment|/* Mark this partition active if that's required */
name|gpart_activate
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* Check if the partition has sub-partitions */
name|LIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|&pp->lg_consumers
argument_list|,
argument|lg_consumers
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|cp
operator|->
name|lg_geom
operator|->
name|lg_class
operator|->
name|lg_name
argument_list|,
literal|"PART"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
comment|/* No sub-partitions */
name|gpart_partcode
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|gctl_get_handle
argument_list|()
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"class"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"PART"
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"arg0"
argument_list|,
operator|-
literal|1
argument_list|,
name|gp
operator|->
name|lg_name
argument_list|)
expr_stmt|;
name|gctl_ro_param
argument_list|(
name|r
argument_list|,
literal|"verb"
argument_list|,
operator|-
literal|1
argument_list|,
literal|"commit"
argument_list|)
expr_stmt|;
name|errstr
operator|=
name|gctl_issue
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
operator|&&
name|errstr
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|gpart_show_error
argument_list|(
literal|"Error"
argument_list|,
name|NULL
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|gctl_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

