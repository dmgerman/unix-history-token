begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*----------------------------------------------------------------------   key.c:   Main routines for the key(8) tool for manually managing            cryptographic keys and security associations inside the            Key Engine of the operating system.  	   Future Enhancements should support: 	        multiple sensitivity levels 		OSPFv2 keys 		RIPv2 keys 		Triple DES for ESP 		DES+MD5 for ESP              Copyright 1995 by Bao Phan, Randall Atkinson,& Dan McDonald,            All Rights Reserved.  All Rights have been assigned to the            US Naval Research Laboratory.  The NRL Copyright Notice and            License govern distribution and use of this software. ----------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------- #       @(#)COPYRIGHT   1.1a (NRL) 17 August 1995   COPYRIGHT NOTICE   All of the documentation and software included in this software distribution from the US Naval Research Laboratory (NRL) are copyrighted by their respective developers.   This software and documentation were developed at NRL by various people.  Those developers have each copyrighted the portions that they developed at NRL and have assigned All Rights for those portions to NRL.  Outside the USA, NRL also has copyright on the software developed at NRL. The affected files all contain specific copyright notices and those notices must be retained in any derived work.   NRL LICENSE   NRL grants permission for redistribution and use in source and binary forms, with or without modification, of the software and documentation created at NRL provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution. 3. All advertising materials mentioning features or use of this software    must display the following acknowledgement:           This product includes software developed at the Information         Technology Division, US Naval Research Laboratory.   4. Neither the name of the NRL nor the names of its contributors    may be used to endorse or promote products derived from this software    without specific prior written permission.   THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   The views and conclusions contained in the software and documentation are those of the authors and should not be interpreted as representing official policies, either expressed or implied, of the US Naval Research Laboratory (NRL).  ----------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  *	$ANA: keyadmin.c,v 1.2 1996/06/13 19:42:40 wollman Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/in6.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* INET6 */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<netinet6/in6_types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netsec/ipsec.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netkey/key.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/support.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INET6
end_ifndef

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|hostname2addr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|gethostbyname(a)
end_define

begin_define
define|#
directive|define
name|addr2hostname
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|,
name|d
parameter_list|)
value|gethostbyaddr((a), (b), (c))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|parse7
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|parse4
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|docmd
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KEYCMD_ARG_MAX
value|10
end_define

begin_define
define|#
directive|define
name|KEYCMD_LOAD
value|1
end_define

begin_define
define|#
directive|define
name|KEYCMD_SAVE
value|2
end_define

begin_define
define|#
directive|define
name|KEYCMD_ADD
value|3
end_define

begin_define
define|#
directive|define
name|KEYCMD_DEL
value|4
end_define

begin_define
define|#
directive|define
name|KEYCMD_FLUSH
value|5
end_define

begin_define
define|#
directive|define
name|KEYCMD_GET
value|6
end_define

begin_define
define|#
directive|define
name|KEYCMD_DUMP
value|7
end_define

begin_define
define|#
directive|define
name|KEYCMD_HELP
value|8
end_define

begin_define
define|#
directive|define
name|KEYCMD_EXIT
value|9
end_define

begin_define
define|#
directive|define
name|KEYCMD_SHELL
value|10
end_define

begin_struct
struct|struct
name|nametonum
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|char
name|parse7usage
index|[]
init|=
literal|"<type><spi><src><dst><transform><key> [iv]"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|parse4usage
index|[]
init|=
literal|"<type><spi><src><dst>"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|keycmd
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
argument_list|(
argument|*parse
argument_list|)
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
expr_stmt|;
name|char
modifier|*
name|usage
decl_stmt|;
name|char
modifier|*
name|help
decl_stmt|;
block|}
name|keycmds
index|[]
init|=
block|{
block|{
literal|"add"
block|,
name|KEYCMD_ADD
block|,
name|parse7
block|,
name|parse7usage
block|,
literal|"Adds a specific key entry to the kernel key table."
block|}
block|,
block|{
literal|"del"
block|,
name|KEYCMD_DEL
block|,
name|parse4
block|,
name|parse4usage
block|,
literal|"Removes a specific key entry from the kernel key table."
block|}
block|,
block|{
literal|"get"
block|,
name|KEYCMD_GET
block|,
name|parse4
block|,
name|parse4usage
block|,
literal|"Retrieves a key entry from the kernel key table."
block|}
block|,
block|{
literal|"dump"
block|,
name|KEYCMD_DUMP
block|,
name|NULL
block|,
literal|" "
block|,
literal|"Retrieves all key entries from the kernel key table."
block|}
block|,
block|{
literal|"load"
block|,
name|KEYCMD_LOAD
block|,
name|NULL
block|,
literal|"{<filename> | - }"
block|,
literal|"Loads keys from a file or stdin into the kernel key table."
block|}
block|,
block|{
literal|"save"
block|,
name|KEYCMD_SAVE
block|,
name|NULL
block|,
literal|"{<filename> | - }"
block|,
literal|"Saves keys from the kernel key table to a file or stdout."
block|}
block|,
block|{
literal|"help"
block|,
name|KEYCMD_HELP
block|,
name|NULL
block|,
literal|"[command]"
block|,
literal|"Provides limited on-line help. Read the man page for more."
block|}
block|,
block|{
literal|"flush"
block|,
name|KEYCMD_FLUSH
block|,
name|NULL
block|,
name|NULL
block|,
literal|"Clears the kernel key table."
block|}
block|,
block|{
literal|"!"
block|,
name|KEYCMD_SHELL
block|,
name|NULL
block|,
literal|"[command]"
block|,
literal|"Executes a subshell."
block|}
block|,
block|{
literal|"exit"
block|,
name|KEYCMD_EXIT
block|,
name|NULL
block|,
name|NULL
block|,
literal|"Exits the program."
block|}
block|,
block|{
literal|"quit"
block|,
name|KEYCMD_EXIT
block|,
name|NULL
block|,
name|NULL
block|,
literal|"Exits the program."
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* flags: index into algorithmtabs */
end_comment

begin_decl_stmt
name|struct
name|nametonum
name|keytypes
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|IPSEC
block|{
literal|"ah"
block|,
name|KEY_TYPE_AH
block|,
literal|0
block|}
block|,
block|{
literal|"esp"
block|,
name|KEY_TYPE_ESP
block|,
literal|1
block|}
block|,
endif|#
directive|endif
block|{
literal|"rsvp"
block|,
name|KEY_TYPE_RSVP
block|,
literal|2
block|}
block|,
block|{
literal|"ospf"
block|,
name|KEY_TYPE_OSPF
block|,
literal|3
block|}
block|,
block|{
literal|"rip"
block|,
name|KEY_TYPE_RIPV2
block|,
literal|4
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|IPSEC_ALGTYPE_AUTH_MD5
end_ifndef

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|IPSEC_ALGTYPE_AUTH_MD5
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* flags: true = iv req. */
end_comment

begin_decl_stmt
name|struct
name|nametonum
name|authalgorithms
index|[]
init|=
block|{
block|{
literal|"md5"
block|,
name|IPSEC_ALGTYPE_AUTH_MD5
block|,
literal|0
block|}
block|,
ifdef|#
directive|ifdef
name|DEBUG
comment|/* These provide no security but are useful for debugging the      kernel's ESP and Key Engine and PF_KEY routines */
block|{
literal|"dummy"
block|,
name|IPSEC_ALGTYPE_AUTH_DUMMY
block|,
literal|0
block|}
block|,
block|{
literal|"cksum"
block|,
name|IPSEC_ALGTYPE_AUTH_CKSUM
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|IPSEC_ALGTYPE_ESP_DES_CBC
end_ifndef

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|IPSEC_ALGTYPE_ESP_DES_CBC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* flags: true = iv req. */
end_comment

begin_decl_stmt
name|struct
name|nametonum
name|encralgorithms
index|[]
init|=
block|{
block|{
literal|"des-cbc"
block|,
name|IPSEC_ALGTYPE_ESP_DES_CBC
block|,
literal|1
block|}
block|,
ifdef|#
directive|ifdef
name|DEBUG
comment|/* These provide no security but are useful for debugging the      kernel's ESP and Key Engine and PF_KEY routines */
block|{
literal|"dummy"
block|,
name|IPSEC_ALGTYPE_ESP_DUMMY
block|,
literal|0
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These numbers should be defined in a header file somewhere  * and shared with the consuming programs, once someone has  * actually written the support in those programs (rspvd,  * gated, and routed).  Probably<protocols/*>...?  */
end_comment

begin_define
define|#
directive|define
name|RSVP_AUTHTYPE_MD5
value|1
end_define

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|struct
name|nametonum
name|rsvpalgorithms
index|[]
init|=
block|{
block|{
literal|"md5"
block|,
name|RSVP_AUTHTYPE_MD5
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OSPF_AUTHTYPE_MD5
value|1
end_define

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|struct
name|nametonum
name|ospfalgorithms
index|[]
init|=
block|{
block|{
literal|"md5"
block|,
name|OSPF_AUTHTYPE_MD5
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RIPV2_AUTHTYPE_MD5
value|1
end_define

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|struct
name|nametonum
name|ripalgorithms
index|[]
init|=
block|{
block|{
literal|"md5"
block|,
name|RIPV2_AUTHTYPE_MD5
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NB:  It is the ordering here that determines the values for the    flags specified above that are used to index into algorithmtabs[] */
end_comment

begin_decl_stmt
name|struct
name|nametonum
modifier|*
name|algorithmtabs
index|[]
init|=
block|{
name|authalgorithms
block|,
name|encralgorithms
block|,
name|rsvpalgorithms
block|,
name|ospfalgorithms
block|,
name|ripalgorithms
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|buffer
index|[
literal|1024
index|]
init|=
literal|"\0"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MAXRCVBUFSIZE
value|8 * 1024
end_define

begin_decl_stmt
name|char
name|key_message
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|key_msghdr
argument_list|)
operator|+
name|MAX_SOCKADDR_SZ
operator|*
literal|3
operator|+
name|MAX_KEY_SZ
operator|+
name|MAX_IV_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|key_messageptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|keysock
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|keygetseqno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|keydumpseqno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pid_t
name|mypid
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------   help:   Print appropriate help message on stdout.  ----------------------------------------------------------------------*/
end_comment

begin_macro
name|help
argument_list|(
argument|cmdname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmdname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cmdname
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keycmds
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|keycmds
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|cmdname
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|keycmds
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown command: %s\n"
argument_list|,
name|cmdname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"%s%s%s\n"
argument_list|,
name|keycmds
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|keycmds
index|[
name|i
index|]
operator|.
name|usage
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|keycmds
index|[
name|i
index|]
operator|.
name|usage
condition|?
name|keycmds
index|[
name|i
index|]
operator|.
name|usage
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|keycmds
index|[
name|i
index|]
operator|.
name|help
condition|)
name|puts
argument_list|(
name|keycmds
index|[
name|i
index|]
operator|.
name|help
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keycmds
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t%s%s%s\n"
argument_list|,
name|keycmds
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|keycmds
index|[
name|i
index|]
operator|.
name|usage
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|keycmds
index|[
name|i
index|]
operator|.
name|usage
condition|?
name|keycmds
index|[
name|i
index|]
operator|.
name|usage
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------   usage:  print suitable usage message on stdout.  ----------------------------------------------------------------------*/
end_comment

begin_macro
name|usage
argument_list|(
argument|myname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|myname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s<command><args>\n"
argument_list|,
name|myname
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"where<command> is one of:\n"
argument_list|)
expr_stmt|;
name|help
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------   parsekey:  parse argument into a binary key and also record              the length of the resulting key. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|parsekey
parameter_list|(
name|key
parameter_list|,
name|keylen
parameter_list|,
name|arg
parameter_list|)
name|u_int8_t
modifier|*
name|key
decl_stmt|;
name|u_int8_t
modifier|*
name|keylen
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
name|u_int8_t
name|thisbyte
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
literal|1
operator|)
operator|&&
operator|(
name|arg
index|[
literal|0
index|]
operator|==
literal|'0'
operator|)
condition|)
block|{
operator|*
name|keylen
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|i
operator|%
literal|2
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid number \"%s\"\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|j
operator|=
literal|1
expr_stmt|;
name|k
operator|=
name|l
operator|=
name|thisbyte
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|arg
index|[
name|k
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|arg
index|[
name|k
index|]
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|arg
index|[
name|k
index|]
operator|<=
literal|'9'
operator|)
condition|)
name|thisbyte
operator||=
name|arg
index|[
name|k
index|]
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|arg
index|[
name|k
index|]
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|arg
index|[
name|k
index|]
operator|<=
literal|'f'
operator|)
condition|)
name|thisbyte
operator||=
name|arg
index|[
name|k
index|]
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|arg
index|[
name|k
index|]
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|arg
index|[
name|k
index|]
operator|<=
literal|'F'
operator|)
condition|)
name|thisbyte
operator||=
name|arg
index|[
name|k
index|]
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Invalid hex number \"%s\"\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|j
operator|%
literal|2
operator|)
condition|)
name|key
index|[
name|l
operator|++
index|]
operator|=
name|thisbyte
expr_stmt|;
name|thisbyte
operator|=
operator|(
name|thisbyte
operator|<<
literal|4
operator|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
operator|*
name|keylen
operator|=
name|l
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   parsenametonum:   converts command-line name into index number.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|parsenametonum
parameter_list|(
name|tab
parameter_list|,
name|arg
parameter_list|)
name|struct
name|nametonum
modifier|*
name|tab
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tab
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|tab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|arg
argument_list|)
condition|)
return|return
name|i
return|;
if|if
condition|(
operator|!
name|tab
index|[
name|i
index|]
operator|.
name|name
condition|)
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   parsesockaddr:  Convert hostname arg into an appropriate sockaddr.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|parsesockaddr
parameter_list|(
name|sockaddr
parameter_list|,
name|arg
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|sockaddr
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hostent
decl_stmt|;
name|struct
name|in_addr
name|in_addr
decl_stmt|,
modifier|*
name|in_addrp
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|in_addr6
name|in_addr6
decl_stmt|,
modifier|*
name|in_addr6p
decl_stmt|;
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|hostent
operator|=
name|hostname2addr
argument_list|(
name|arg
argument_list|,
name|AF_INET
argument_list|,
literal|0
argument_list|)
condition|)
if|if
condition|(
operator|(
name|hostent
operator|->
name|h_addrtype
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|hostent
operator|->
name|h_length
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|)
condition|)
block|{
name|in_addrp
operator|=
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hostent
operator|->
name|h_addr_list
index|[
literal|0
index|]
operator|)
expr_stmt|;
goto|goto
name|fillin4
goto|;
block|}
if|if
condition|(
name|ascii2addr
argument_list|(
name|AF_INET
argument_list|,
name|arg
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|in_addr
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
block|{
name|in_addrp
operator|=
operator|&
name|in_addr
expr_stmt|;
goto|goto
name|fillin4
goto|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|hostent
operator|=
name|hostname2addr
argument_list|(
name|arg
argument_list|,
name|AF_INET6
argument_list|)
condition|)
if|if
condition|(
operator|(
name|hostent
operator|->
name|h_addrtype
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|hostent
operator|->
name|h_length
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr6
argument_list|)
operator|)
condition|)
block|{
name|in_addr6p
operator|=
operator|(
operator|(
expr|struct
name|in_addr6
operator|*
operator|)
name|hostent
operator|->
name|h_addr_list
index|[
literal|0
index|]
operator|)
expr_stmt|;
goto|goto
name|fillin6
goto|;
block|}
if|if
condition|(
name|ascii2addr
argument_list|(
name|AF_INET6
argument_list|,
name|arg
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|in_addr6
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr6
argument_list|)
condition|)
block|{
name|in_addr6p
operator|=
operator|&
name|in_addr6
expr_stmt|;
goto|goto
name|fillin6
goto|;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown host \"%s\"\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|fillin4
label|:
name|bzero
argument_list|(
name|sockaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sockaddr
operator|)
operator|->
name|sin_addr
operator|=
operator|*
name|in_addrp
expr_stmt|;
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|INET6
name|fillin6
label|:
name|bzero
argument_list|(
name|sockaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sockaddr
operator|->
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sockaddr
operator|)
operator|->
name|sin6_addr
operator|=
operator|*
name|in_addr6p
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* INET6 */
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   dummyfromaddr:  Creates a zeroed sockaddr of family af.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|dummyfromaddr
parameter_list|(
name|sa
parameter_list|,
name|af
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|af
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|size
operator|=
operator|(
name|af
operator|==
name|AF_INET6
operator|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
block|)
function|;
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* INET6 */
end_comment

begin_expr_stmt
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_expr_stmt
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sa
argument_list|,
name|size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sa
operator|->
name|sa_family
operator|=
name|af
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sa
operator|->
name|sa_len
operator|=
name|size
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*   * Macros to ensure word alignment.  */
end_comment

begin_define
define|#
directive|define
name|ROUNDUP
parameter_list|(
name|a
parameter_list|)
define|\
value|((a)> 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
end_define

begin_define
define|#
directive|define
name|ADVANCE
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
define|\
value|{ x += ROUNDUP(n); }
end_define

begin_comment
comment|/*----------------------------------------------------------------------   parse4:  parse keytype, spi, src addr, and dest addr from argv (command line)            and stick in structure pointed to by key_messageptr. ----------------------------------------------------------------------*/
end_comment

begin_macro
unit|int
name|parse4
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|parsenametonum
argument_list|(
name|keytypes
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|i
return|;
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|type
operator|=
name|keytypes
index|[
name|i
index|]
operator|.
name|num
expr_stmt|;
comment|/* Should we zero check? */
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|spi
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsesockaddr
argument_list|(
name|key_message
operator|+
name|key_messageptr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|ADVANCE
argument_list|(
name|key_messageptr
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|key_message
operator|+
name|key_messageptr
operator|)
operator|)
operator|->
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsesockaddr
argument_list|(
name|key_message
operator|+
name|key_messageptr
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|ADVANCE
argument_list|(
name|key_messageptr
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|key_message
operator|+
name|key_messageptr
operator|)
operator|)
operator|->
name|sa_len
argument_list|)
expr_stmt|;
comment|/*    *  We need to put a dummy from address since the kernel expects    *  this to be in the message.    */
ifdef|#
directive|ifdef
name|INET6
name|dummyfromaddr
argument_list|(
name|key_message
operator|+
name|key_messageptr
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* INET6 */
name|dummyfromaddr
argument_list|(
name|key_message
operator|+
name|key_messageptr
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|ADVANCE
argument_list|(
name|key_messageptr
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|key_message
operator|+
name|key_messageptr
operator|)
operator|)
operator|->
name|sa_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*----------------------------------------------------------------------   parse7:  parse keytype, spi, src addr, dest addr, alg type, key, and iv            from argv (command line)            and stick in structure pointed to by key_messageptr. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|parse7
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|6
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|parsenametonum
argument_list|(
name|keytypes
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|i
return|;
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|type
operator|=
name|keytypes
index|[
name|i
index|]
operator|.
name|num
expr_stmt|;
comment|/* Should we zero check? */
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|spi
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsesockaddr
argument_list|(
name|key_message
operator|+
name|key_messageptr
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|ADVANCE
argument_list|(
name|key_messageptr
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|key_message
operator|+
name|key_messageptr
operator|)
operator|)
operator|->
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|parsesockaddr
argument_list|(
name|key_message
operator|+
name|key_messageptr
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|ADVANCE
argument_list|(
name|key_messageptr
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|key_message
operator|+
name|key_messageptr
operator|)
operator|)
operator|->
name|sa_len
argument_list|)
expr_stmt|;
comment|/*    *  We need to put a dummy from address since the kernel expects    *  this to be in the message.    */
ifdef|#
directive|ifdef
name|INET6
name|dummyfromaddr
argument_list|(
name|key_message
operator|+
name|key_messageptr
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* INET6 */
name|dummyfromaddr
argument_list|(
name|key_message
operator|+
name|key_messageptr
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|ADVANCE
argument_list|(
name|key_messageptr
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|key_message
operator|+
name|key_messageptr
operator|)
operator|)
operator|->
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|parsenametonum
argument_list|(
name|algorithmtabs
index|[
name|keytypes
index|[
name|i
index|]
operator|.
name|flags
index|]
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|j
return|;
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|algorithm
operator|=
name|algorithmtabs
index|[
name|keytypes
index|[
name|i
index|]
operator|.
name|flags
index|]
index|[
name|j
index|]
operator|.
name|num
expr_stmt|;
if|if
condition|(
operator|(
name|argc
operator|<
literal|7
operator|)
operator|&&
name|algorithmtabs
index|[
name|keytypes
index|[
name|i
index|]
operator|.
name|flags
index|]
index|[
name|j
index|]
operator|.
name|flags
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|parsekey
argument_list|(
name|key_message
operator|+
name|key_messageptr
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|keylen
operator|)
argument_list|,
name|argv
index|[
literal|5
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|ADVANCE
argument_list|(
name|key_messageptr
argument_list|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>=
literal|7
condition|)
block|{
if|if
condition|(
name|parsekey
argument_list|(
name|key_message
operator|+
name|key_messageptr
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|ivlen
operator|)
argument_list|,
name|argv
index|[
literal|6
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
name|ADVANCE
argument_list|(
name|key_messageptr
argument_list|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|ivlen
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   parsecmdline:  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|parsecmdline
parameter_list|(
name|buffer
parameter_list|,
name|argv
parameter_list|,
name|argc
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
modifier|*
name|argc
decl_stmt|;
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|iargc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|head
decl_stmt|;
name|head
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
name|buffer
index|[
name|i
index|]
operator|&&
operator|(
name|iargc
operator|<
name|KEYCMD_ARG_MAX
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'#'
operator|)
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|head
condition|)
name|argv
index|[
name|iargc
operator|++
index|]
operator|=
name|head
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|buffer
index|[
name|i
index|]
operator|==
literal|' '
operator|)
operator|||
operator|(
name|buffer
index|[
name|i
index|]
operator|==
literal|'\t'
operator|)
condition|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|head
condition|)
name|argv
index|[
name|iargc
operator|++
index|]
operator|=
name|head
expr_stmt|;
name|head
operator|=
operator|&
operator|(
name|buffer
index|[
operator|++
name|i
index|]
operator|)
expr_stmt|;
block|}
else|else
name|i
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|argv
index|[
name|iargc
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|argc
operator|=
name|iargc
expr_stmt|;
return|return
name|iargc
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   load:   load keys from file filename into Key Engine.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|load
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|FILE
modifier|*
name|fh
decl_stmt|;
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|buf
decl_stmt|,
modifier|*
name|largv
index|[
name|KEYCMD_ARG_MAX
index|]
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|largc
decl_stmt|,
name|left
decl_stmt|,
name|line
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fh
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
name|fh
operator|=
name|stdin
expr_stmt|;
name|largv
index|[
literal|0
index|]
operator|=
literal|"add"
expr_stmt|;
name|buf
operator|=
name|buffer
expr_stmt|;
name|left
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|left
argument_list|,
name|fh
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|=
name|strchr
argument_list|(
name|buffer
argument_list|,
literal|'\\'
argument_list|)
condition|)
block|{
name|left
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
operator|)
operator|-
operator|(
operator|--
name|c
operator|-
name|buffer
operator|)
expr_stmt|;
name|buf
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|parsecmdline
argument_list|(
name|buffer
argument_list|,
operator|&
operator|(
name|largv
index|[
literal|1
index|]
operator|)
argument_list|,
operator|&
name|largc
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|i
return|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
if|if
condition|(
name|i
operator|=
name|docmd
argument_list|(
operator|++
name|largc
argument_list|,
name|largv
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Parse error on line %d of %s.\n"
argument_list|,
name|line
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|i
return|;
block|}
block|}
name|buf
operator|=
name|buffer
expr_stmt|;
name|left
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   parsedata:  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|parsedata
parameter_list|(
name|km
parameter_list|,
name|kip
parameter_list|)
name|struct
name|key_msghdr
modifier|*
name|km
decl_stmt|;
name|struct
name|key_msgdata
modifier|*
name|kip
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpmax
decl_stmt|;
if|if
condition|(
operator|!
name|km
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|km
operator|->
name|key_msglen
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|km
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cpmax
operator|=
operator|(
name|caddr_t
operator|)
name|km
operator|+
name|km
operator|->
name|key_msglen
expr_stmt|;
define|#
directive|define
name|NEXTDATA
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
define|\
value|{ x += ROUNDUP(n); if (cp>= cpmax) { fprintf(stderr, "key: kernel returned a truncated message!\n"); return(-1); } }
comment|/* Grab src addr */
name|kip
operator|->
name|src
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|kip
operator|->
name|src
operator|->
name|sa_len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|NEXTDATA
argument_list|(
name|cp
argument_list|,
name|kip
operator|->
name|src
operator|->
name|sa_len
argument_list|)
expr_stmt|;
comment|/* Grab dest addr */
name|kip
operator|->
name|dst
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|kip
operator|->
name|dst
operator|->
name|sa_len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|NEXTDATA
argument_list|(
name|cp
argument_list|,
name|kip
operator|->
name|dst
operator|->
name|sa_len
argument_list|)
expr_stmt|;
comment|/* Grab from addr */
name|kip
operator|->
name|from
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|kip
operator|->
name|from
operator|->
name|sa_len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|NEXTDATA
argument_list|(
name|cp
argument_list|,
name|kip
operator|->
name|from
operator|->
name|sa_len
argument_list|)
expr_stmt|;
comment|/* Grab key */
if|if
condition|(
name|kip
operator|->
name|keylen
operator|=
name|km
operator|->
name|keylen
condition|)
block|{
name|kip
operator|->
name|key
operator|=
name|cp
expr_stmt|;
name|NEXTDATA
argument_list|(
name|cp
argument_list|,
name|km
operator|->
name|keylen
argument_list|)
expr_stmt|;
block|}
comment|/* Grab iv */
if|if
condition|(
name|kip
operator|->
name|ivlen
operator|=
name|km
operator|->
name|ivlen
condition|)
name|kip
operator|->
name|iv
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
name|kip
operator|->
name|ivlen
expr_stmt|;
name|printf
argument_list|(
literal|"key: parsedata: difference=%d\n"
argument_list|,
name|cp
operator|-
name|cpmax
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   printkeyiv:  ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|printkeyiv
parameter_list|(
name|fp
parameter_list|,
name|cp
parameter_list|,
name|len
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|u_int8_t
operator|)
operator|*
operator|(
name|cp
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   printsockaddr:  ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|printsockaddr
parameter_list|(
name|fp
parameter_list|,
name|sa
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|addrp
decl_stmt|;
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr6
argument_list|)
expr_stmt|;
name|addrp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_addr
operator|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* INET6 */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|addrp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
operator|(
name|hp
operator|=
name|addr2hostname
argument_list|(
name|addrp
argument_list|,
name|len
argument_list|,
name|sa
operator|->
name|sa_family
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|addr2ascii
argument_list|(
name|sa
operator|->
name|sa_family
argument_list|,
name|addrp
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   parsenumtoname:  ----------------------------------------------------------------------*/
end_comment

begin_function
name|char
modifier|*
name|parsenumtoname
parameter_list|(
name|tab
parameter_list|,
name|num
parameter_list|)
name|struct
name|nametonum
modifier|*
name|tab
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tab
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|num
operator|==
name|tab
index|[
name|i
index|]
operator|.
name|num
condition|)
return|return
operator|(
name|tab
index|[
name|i
index|]
operator|.
name|name
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   parsenumtoflag:  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|parsenumtoflag
parameter_list|(
name|tab
parameter_list|,
name|num
parameter_list|)
name|struct
name|nametonum
modifier|*
name|tab
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tab
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|num
operator|==
name|tab
index|[
name|i
index|]
operator|.
name|num
condition|)
return|return
operator|(
name|tab
index|[
name|i
index|]
operator|.
name|flags
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   printkeymsg:  ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|printkeymsg
parameter_list|(
name|kmp
parameter_list|,
name|kdp
parameter_list|)
name|struct
name|key_msghdr
modifier|*
name|kmp
decl_stmt|;
name|struct
name|key_msgdata
modifier|*
name|kdp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|printf
argument_list|(
literal|"type=%d(%s) "
argument_list|,
name|kmp
operator|->
name|type
argument_list|,
name|parsenumtoname
argument_list|(
name|keytypes
argument_list|,
name|kmp
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"spi=%u "
argument_list|,
name|kmp
operator|->
name|spi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"alogrithm=%u(%s) "
argument_list|,
name|kmp
operator|->
name|algorithm
argument_list|,
name|parsenumtoname
argument_list|(
name|algorithmtabs
index|[
name|parsenumtoflag
argument_list|(
name|keytypes
argument_list|,
name|kmp
operator|->
name|type
argument_list|)
index|]
argument_list|,
name|kmp
operator|->
name|algorithm
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"state=0x%x "
argument_list|,
name|kmp
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmp
operator|->
name|state
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|kmp
operator|->
name|state
operator|&
name|K_USED
condition|)
name|printf
argument_list|(
literal|"USED "
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmp
operator|->
name|state
operator|&
name|K_UNIQUE
condition|)
name|printf
argument_list|(
literal|"UNIQUE "
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmp
operator|->
name|state
operator|&
name|K_LARVAL
condition|)
name|printf
argument_list|(
literal|"LARVAL "
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmp
operator|->
name|state
operator|&
name|K_ZOMBIE
condition|)
name|printf
argument_list|(
literal|"ZOMBIE "
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmp
operator|->
name|state
operator|&
name|K_DEAD
condition|)
name|printf
argument_list|(
literal|"DEAD "
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmp
operator|->
name|state
operator|&
name|K_INBOUND
condition|)
name|printf
argument_list|(
literal|"INBOUND "
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmp
operator|->
name|state
operator|&
name|K_OUTBOUND
condition|)
name|printf
argument_list|(
literal|"OUTBOUND"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sensitivity_label=%d "
argument_list|,
name|kmp
operator|->
name|label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lifetype=%d "
argument_list|,
name|kmp
operator|->
name|lifetype
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lifetime1=%d "
argument_list|,
name|kmp
operator|->
name|lifetime1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lifetime2=%d\n"
argument_list|,
name|kmp
operator|->
name|lifetime2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"key (len=%d):\t"
argument_list|,
name|kdp
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|printkeyiv
argument_list|(
name|stdout
argument_list|,
name|kdp
operator|->
name|key
argument_list|,
name|kdp
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"iv (len=%d):\t"
argument_list|,
name|kdp
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|printkeyiv
argument_list|(
name|stdout
argument_list|,
name|kdp
operator|->
name|iv
argument_list|,
name|kdp
operator|->
name|ivlen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src:\t"
argument_list|)
expr_stmt|;
name|printsockaddr
argument_list|(
name|stdout
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|kdp
operator|->
name|src
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst:\t"
argument_list|)
expr_stmt|;
name|printsockaddr
argument_list|(
name|stdout
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|kdp
operator|->
name|dst
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*  printf("from:\t");   printsockaddr(stdout, (struct sockaddr *)kdp->from); */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------   docmd:  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|docmd
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|seqno
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|argv
index|[
literal|0
index|]
operator|||
operator|!
name|argc
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
condition|)
return|return
operator|-
literal|1
return|;
name|bzero
argument_list|(
operator|&
name|key_message
argument_list|,
sizeof|sizeof
argument_list|(
name|key_message
argument_list|)
argument_list|)
expr_stmt|;
name|key_messageptr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|key_msghdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|keycmds
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|keycmds
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|keycmds
index|[
name|i
index|]
operator|.
name|name
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|keycmds
index|[
name|i
index|]
operator|.
name|parse
condition|)
if|if
condition|(
name|j
operator|=
name|keycmds
index|[
name|i
index|]
operator|.
name|parse
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
operator|&
operator|(
name|argv
index|[
literal|1
index|]
operator|)
argument_list|)
condition|)
return|return
name|j
return|;
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msglen
operator|=
name|key_messageptr
expr_stmt|;
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msgvers
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_seq
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|keycmds
index|[
name|i
index|]
operator|.
name|num
condition|)
block|{
case|case
name|KEYCMD_ADD
case|:
ifndef|#
directive|ifndef
name|NOSANITYCHK
comment|/*      * For now, we do sanity check of security association       * information here until we find a better place.      */
block|{
name|struct
name|key_msghdr
modifier|*
name|kmp
init|=
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
decl_stmt|;
if|if
condition|(
operator|(
name|kmp
operator|->
name|type
operator|==
name|KEY_TYPE_AH
operator|||
name|kmp
operator|->
name|type
operator|==
name|KEY_TYPE_ESP
operator|)
operator|&&
operator|(
name|kmp
operator|->
name|spi
operator|<
literal|256
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"add: spi must be greater than 255\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|kmp
operator|->
name|type
operator|==
name|KEY_TYPE_ESP
operator|&&
operator|(
name|kmp
operator|->
name|algorithm
operator|==
name|IPSEC_ALGTYPE_ESP_DES_CBC
ifdef|#
directive|ifdef
name|IPSEC_ALGTYPE_ESP_3DES
operator|||
name|kmp
operator|->
name|algorithm
operator|==
name|IPSEC_ALGTYPE_ESP_3DES
endif|#
directive|endif
operator|)
condition|)
block|{
if|if
condition|(
name|kmp
operator|->
name|keylen
operator|!=
literal|8
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"add: key must be 8 bytes\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|kmp
operator|->
name|ivlen
operator|!=
literal|4
operator|&&
name|kmp
operator|->
name|ivlen
operator|!=
literal|8
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"add: iv must be 4 or 8 bytes\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|kmp
operator|->
name|type
operator|==
name|KEY_TYPE_AH
operator|&&
name|kmp
operator|->
name|algorithm
operator|==
name|IPSEC_ALGTYPE_AUTH_MD5
operator|&&
name|kmp
operator|->
name|keylen
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"add: no key specified\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
endif|#
directive|endif
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msgtype
operator|=
name|KEY_ADD
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|keysock
argument_list|,
name|key_message
argument_list|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msglen
argument_list|)
operator|!=
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msglen
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"add: security association already exists\n"
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
literal|"add"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|read
argument_list|(
name|keysock
argument_list|,
name|key_message
argument_list|,
sizeof|sizeof
argument_list|(
name|key_message
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|KEYCMD_DEL
case|:
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msgtype
operator|=
name|KEY_DELETE
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|keysock
argument_list|,
name|key_message
argument_list|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msglen
argument_list|)
operator|!=
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msglen
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ESRCH
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"delete: Security association not found\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|perror
argument_list|(
literal|"delete"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|read
argument_list|(
name|keysock
argument_list|,
name|key_message
argument_list|,
sizeof|sizeof
argument_list|(
name|key_message
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|KEYCMD_GET
case|:
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msgtype
operator|=
name|KEY_GET
expr_stmt|;
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_seq
operator|=
name|seqno
operator|=
name|keygetseqno
operator|++
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|keysock
argument_list|,
name|key_message
argument_list|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msglen
argument_list|)
operator|!=
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msglen
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ESRCH
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"get: Security association not found\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|perror
argument_list|(
literal|"get"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* endif ESRCH */
block|}
comment|/* endif write() */
block|{
name|int
name|len
decl_stmt|;
name|struct
name|key_msgdata
name|keymsgdata
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|key_msghdr
argument_list|)
operator|+
name|MAX_SOCKADDR_SZ
operator|*
literal|3
operator|+
name|MAX_KEY_SZ
operator|+
name|MAX_IV_SZ
expr_stmt|;
name|readmesg
label|:
if|if
condition|(
name|read
argument_list|(
name|keysock
argument_list|,
name|key_message
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
operator|)
operator|->
name|key_pid
operator|==
name|mypid
operator|)
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
operator|)
operator|->
name|key_msgtype
operator|==
name|KEY_GET
operator|)
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
operator|)
operator|->
name|key_seq
operator|==
name|seqno
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
goto|goto
name|readmesg
goto|;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
operator|)
operator|->
name|key_errno
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error:  kernel reporting errno=%d\n"
argument_list|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
operator|)
operator|->
name|key_errno
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|parsedata
argument_list|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
argument_list|,
operator|&
name|keymsgdata
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"get: can't parse reply\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printkeymsg
argument_list|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
argument_list|,
operator|&
name|keymsgdata
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|KEYCMD_FLUSH
case|:
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msgtype
operator|=
name|KEY_FLUSH
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|keysock
argument_list|,
name|key_message
argument_list|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msglen
argument_list|)
operator|!=
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msglen
condition|)
block|{
name|perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|read
argument_list|(
name|keysock
argument_list|,
name|key_message
argument_list|,
sizeof|sizeof
argument_list|(
name|key_message
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|KEYCMD_HELP
case|:
return|return
name|help
argument_list|(
operator|(
name|argc
operator|>
literal|1
operator|)
condition|?
name|argv
index|[
literal|1
index|]
else|:
name|NULL
argument_list|)
return|;
case|case
name|KEYCMD_SHELL
case|:
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|,
modifier|*
name|ap
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ep
operator|=
name|buffer
operator|+
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|ap
operator|=
name|buffer
init|;
operator|(
name|i
operator|<
name|argc
operator|)
operator|&&
operator|(
name|ap
operator|<
name|ep
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
operator|(
name|ap
operator|++
operator|)
operator|=
operator|*
operator|(
name|c
operator|++
operator|)
operator|)
operator|&&
operator|(
name|ap
operator|<
name|ep
operator|)
condition|)
empty_stmt|;
operator|*
operator|(
name|ap
operator|-
literal|1
operator|)
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
operator|(
name|ap
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
name|system
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|c
init|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
name|c
operator|=
literal|"/bin/sh"
expr_stmt|;
name|system
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|KEYCMD_EXIT
case|:
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
name|KEYCMD_LOAD
case|:
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
return|return
literal|1
return|;
return|return
name|load
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
return|;
case|case
name|KEYCMD_SAVE
case|:
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
name|fp
operator|=
name|stdout
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|O_CREAT
operator||
name|O_RDWR
operator||
name|O_EXCL
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
case|case
name|KEYCMD_DUMP
case|:
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msgtype
operator|=
name|KEY_DUMP
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|keysock
argument_list|,
name|key_message
argument_list|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msglen
argument_list|)
operator|!=
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
name|key_message
operator|)
operator|->
name|key_msglen
condition|)
block|{
name|perror
argument_list|(
literal|"write"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|{
name|struct
name|key_msgdata
name|keymsgdata
decl_stmt|;
name|readmesg2
label|:
if|if
condition|(
name|read
argument_list|(
name|keysock
argument_list|,
name|key_message
argument_list|,
sizeof|sizeof
argument_list|(
name|key_message
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"read"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
operator|)
operator|->
name|key_pid
operator|==
name|mypid
operator|)
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
operator|)
operator|->
name|key_msgtype
operator|==
name|KEY_DUMP
operator|)
operator|)
condition|)
goto|goto
name|readmesg2
goto|;
comment|/*        *  Kernel is done sending secassoc if key_seq == 0        */
if|if
condition|(
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
operator|)
operator|->
name|key_seq
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|keycmds
index|[
name|i
index|]
operator|.
name|num
operator|==
name|KEYCMD_SAVE
operator|)
operator|&&
operator|(
name|fp
operator|!=
name|stdout
operator|)
condition|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|parsedata
argument_list|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
argument_list|,
operator|&
name|keymsgdata
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"get: can't parse reply\n"
argument_list|)
expr_stmt|;
goto|goto
name|readmesg2
goto|;
block|}
if|if
condition|(
name|keycmds
index|[
name|i
index|]
operator|.
name|num
operator|==
name|KEYCMD_SAVE
condition|)
block|{
name|char
modifier|*
name|keytype
decl_stmt|,
modifier|*
name|algorithm
decl_stmt|;
name|keytype
operator|=
name|parsenumtoname
argument_list|(
name|keytypes
argument_list|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
operator|)
operator|->
name|type
argument_list|)
expr_stmt|;
name|algorithm
operator|=
name|parsenumtoname
argument_list|(
name|algorithmtabs
index|[
name|parsenumtoflag
argument_list|(
name|keytypes
argument_list|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
argument_list|)
operator|&
name|key_message
block|)
operator|->
name|type
block|)
block|]
operator|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
operator|)
operator|->
name|algorithm
block|)
empty_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %u "
argument_list|,
name|keytype
argument_list|,
operator|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
operator|)
operator|->
name|spi
argument_list|)
expr_stmt|;
name|printsockaddr
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|keymsgdata
operator|.
name|src
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|printsockaddr
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|keymsgdata
operator|.
name|dst
operator|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s "
argument_list|,
name|algorithm
argument_list|)
expr_stmt|;
name|printkeyiv
argument_list|(
name|fp
argument_list|,
name|keymsgdata
operator|.
name|key
argument_list|,
name|keymsgdata
operator|.
name|keylen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|printkeyiv
argument_list|(
name|fp
argument_list|,
name|keymsgdata
operator|.
name|iv
argument_list|,
name|keymsgdata
operator|.
name|ivlen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|else
name|printkeymsg
argument_list|(
operator|(
expr|struct
name|key_msghdr
operator|*
operator|)
operator|&
name|key_message
argument_list|,
operator|&
name|keymsgdata
argument_list|)
expr_stmt|;
end_else

begin_goto
goto|goto
name|readmesg2
goto|;
end_goto

begin_expr_stmt
unit|}     return
operator|(
literal|0
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   return
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*----------------------------------------------------------------------   main:  ----------------------------------------------------------------------*/
end_comment

begin_function
unit|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_long
name|rcvsize
decl_stmt|;
if|if
condition|(
name|getuid
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"This program is intended for the superuser only.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|keysock
operator|=
name|socket
argument_list|(
name|PF_KEY
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|rcvsize
operator|=
name|MAXRCVBUFSIZE
init|;
name|rcvsize
condition|;
name|rcvsize
operator|-=
literal|1024
control|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|keysock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|rcvsize
argument_list|,
sizeof|sizeof
argument_list|(
name|rcvsize
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
break|break;
block|}
name|mypid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|mypid
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"getpid"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
comment|/*      * Attempt to do a single command, based on command line arguments.      */
if|if
condition|(
name|strcasecmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"add"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Cannot add keys from the command line.  RTFM for why.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|=
name|docmd
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
operator|&
operator|(
name|argv
index|[
literal|1
index|]
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|keycmds
index|[
name|j
index|]
operator|.
name|name
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|keycmds
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|keycmds
index|[
name|j
index|]
operator|.
name|name
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s%s%s\n"
argument_list|,
name|keycmds
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|keycmds
index|[
name|j
index|]
operator|.
name|usage
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|keycmds
index|[
name|j
index|]
operator|.
name|usage
condition|?
name|keycmds
index|[
name|j
index|]
operator|.
name|usage
else|:
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|iargv
index|[
name|KEYCMD_ARG_MAX
index|]
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|int
name|iargc
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"key> "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/*        * get command line, and parse into an argc/argv form.        */
if|if
condition|(
operator|(
name|i
operator|=
name|parsecmdline
argument_list|(
name|buffer
argument_list|,
name|iargv
argument_list|,
operator|&
name|iargc
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
continue|continue;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/*        * given argc/argv, process argument as if it came from the command        * line.        */
if|if
condition|(
name|i
operator|=
name|docmd
argument_list|(
name|iargc
argument_list|,
name|iargv
argument_list|)
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|keycmds
index|[
name|j
index|]
operator|.
name|name
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|keycmds
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|iargv
index|[
literal|0
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|keycmds
index|[
name|j
index|]
operator|.
name|name
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s%s%s\n"
argument_list|,
name|keycmds
index|[
name|j
index|]
operator|.
name|name
argument_list|,
name|keycmds
index|[
name|j
index|]
operator|.
name|usage
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|keycmds
index|[
name|j
index|]
operator|.
name|usage
condition|?
name|keycmds
index|[
name|j
index|]
operator|.
name|usage
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
condition|)
name|perror
argument_list|(
literal|"System error"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unrecognized command; "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Type 'help' if you need help\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_comment
comment|/* EOF */
end_comment

end_unit

