begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1992-1994,2001 by Joerg Wunsch, Dresden  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * FreeBSD:  * format a floppy disk  *  * Added FD_GTYPE ioctl, verifying, proportional indicators.  * Serge Vakulenko, vak@zebub.msk.su  * Sat Dec 18 17:45:47 MSK 1993  *  * Final adaptation, change format/verify logic, add separate  * format gap/interleave values  * Andrew A. Chernov, ache@astral.msk.su  * Thu Jan 27 00:47:24 MSK 1994  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_fd.h>
end_include

begin_function
specifier|static
name|void
name|format_track
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|cyl
parameter_list|,
name|int
name|secs
parameter_list|,
name|int
name|head
parameter_list|,
name|int
name|rate
parameter_list|,
name|int
name|gaplen
parameter_list|,
name|int
name|secsize
parameter_list|,
name|int
name|fill
parameter_list|,
name|int
name|interleave
parameter_list|)
block|{
name|struct
name|fd_formb
name|f
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|il
index|[
name|FD_MAX_NSEC
operator|+
literal|1
index|]
decl_stmt|;
name|memset
argument_list|(
name|il
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|il
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|secs
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|il
index|[
operator|(
name|j
operator|%
name|secs
operator|)
operator|+
literal|1
index|]
condition|)
name|j
operator|++
expr_stmt|;
name|il
index|[
operator|(
name|j
operator|%
name|secs
operator|)
operator|+
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|j
operator|+=
name|interleave
expr_stmt|;
block|}
name|f
operator|.
name|format_version
operator|=
name|FD_FORMAT_VERSION
expr_stmt|;
name|f
operator|.
name|head
operator|=
name|head
expr_stmt|;
name|f
operator|.
name|cyl
operator|=
name|cyl
expr_stmt|;
name|f
operator|.
name|transfer_rate
operator|=
name|rate
expr_stmt|;
name|f
operator|.
name|fd_formb_secshift
operator|=
name|secsize
expr_stmt|;
name|f
operator|.
name|fd_formb_nsecs
operator|=
name|secs
expr_stmt|;
name|f
operator|.
name|fd_formb_gaplen
operator|=
name|gaplen
expr_stmt|;
name|f
operator|.
name|fd_formb_fillbyte
operator|=
name|fill
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|secs
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|.
name|fd_formb_cylno
argument_list|(
name|i
argument_list|)
operator|=
name|cyl
expr_stmt|;
name|f
operator|.
name|fd_formb_headno
argument_list|(
name|i
argument_list|)
operator|=
name|head
expr_stmt|;
name|f
operator|.
name|fd_formb_secno
argument_list|(
name|i
argument_list|)
operator|=
name|il
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|f
operator|.
name|fd_formb_secsize
argument_list|(
name|i
argument_list|)
operator|=
name|secsize
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_FORM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|f
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl(FD_FORM)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|verify_track
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|track
parameter_list|,
name|int
name|tracksize
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|bufsz
init|=
literal|0
decl_stmt|;
name|int
name|fdopts
init|=
operator|-
literal|1
decl_stmt|,
name|ofdopts
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_GOPTS
argument_list|,
operator|&
name|fdopts
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"warning: ioctl(FD_GOPTS)"
argument_list|)
expr_stmt|;
else|else
block|{
name|ofdopts
operator|=
name|fdopts
expr_stmt|;
name|fdopts
operator||=
name|FDOPT_NORETRY
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_SOPTS
argument_list|,
operator|&
name|fdopts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufsz
operator|<
name|tracksize
condition|)
block|{
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|bufsz
operator|=
name|tracksize
expr_stmt|;
name|buf
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buf
condition|)
name|buf
operator|=
name|malloc
argument_list|(
name|bufsz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|long
operator|)
name|track
operator|*
name|tracksize
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* try twice reading it, without using the normal retrier */
elseif|else
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|tracksize
argument_list|)
operator|!=
name|tracksize
operator|&&
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|tracksize
argument_list|)
operator|!=
name|tracksize
condition|)
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fdopts
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_SOPTS
argument_list|,
operator|&
name|ofdopts
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|makename
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|)
block|{
specifier|static
name|char
name|namebuff
index|[
literal|20
index|]
decl_stmt|;
comment|/* big enough for "/dev/fd0a"... */
name|memset
argument_list|(
name|namebuff
argument_list|,
literal|0
argument_list|,
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'\0'
condition|)
comment|/* ??? */
return|return
name|arg
return|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'/'
condition|)
comment|/* do not convert absolute pathnames */
return|return
name|arg
return|;
name|strcpy
argument_list|(
name|namebuff
argument_list|,
name|_PATH_DEV
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|namebuff
argument_list|,
name|arg
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|namebuff
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
return|return
name|namebuff
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n"
argument_list|,
literal|"usage: fdformat [-y] [-q] [-n | -v] [-f #] [-c #] [-s #] [-h #]"
argument_list|,
literal|"                [-r #] [-g #] [-i #] [-S #] [-F #] [-t #] devname"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|yes
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|reply
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|reply
index|[
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|p
operator|=
name|reply
init|;
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|;
operator|++
name|p
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'y'
operator|||
operator|*
name|p
operator|==
literal|'Y'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'n'
operator|||
operator|*
name|p
operator|==
literal|'N'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|printf
argument_list|(
literal|"Answer `yes' or `no': "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Some definitions imported from /sys/isa/ic/nec765.h for convenience.  */
end_comment

begin_comment
comment|/* Status register ST0 */
end_comment

begin_define
define|#
directive|define
name|NE7_ST0_IC
value|0xc0
end_define

begin_comment
comment|/* interrupt completion code */
end_comment

begin_define
define|#
directive|define
name|NE7_ST0_IC_AT
value|0x40
end_define

begin_comment
comment|/* abnormal termination, check error stat */
end_comment

begin_define
define|#
directive|define
name|NE7_ST0_IC_RC
value|0xc0
end_define

begin_comment
comment|/* terminated due to ready changed, n/a */
end_comment

begin_comment
comment|/* Status register ST1 */
end_comment

begin_define
define|#
directive|define
name|NE7_ST1_EN
value|0x80
end_define

begin_comment
comment|/* end of cylinder, access past last record */
end_comment

begin_define
define|#
directive|define
name|NE7_ST1_DE
value|0x20
end_define

begin_comment
comment|/* data error, CRC fail in ID or data */
end_comment

begin_define
define|#
directive|define
name|NE7_ST1_ND
value|0x04
end_define

begin_comment
comment|/* no data, sector not found or CRC in ID f. */
end_comment

begin_define
define|#
directive|define
name|NE7_ST1_MA
value|0x01
end_define

begin_comment
comment|/* missing address mark (in ID or data field)*/
end_comment

begin_comment
comment|/* Status register ST2 */
end_comment

begin_define
define|#
directive|define
name|NE7_ST2_DD
value|0x20
end_define

begin_comment
comment|/* data error in data field, CRC fail */
end_comment

begin_define
define|#
directive|define
name|NE7_ST2_WC
value|0x10
end_define

begin_comment
comment|/* wrong cylinder, ID field mismatches cmd */
end_comment

begin_define
define|#
directive|define
name|NE7_ST2_MD
value|0x01
end_define

begin_comment
comment|/* missing address mark in data field */
end_comment

begin_comment
comment|/*  * Decode the FDC status pointed to by `fdcsp', and print a textual  * translation to stderr.  */
end_comment

begin_function
specifier|static
name|void
name|printstatus
parameter_list|(
name|struct
name|fdc_status
modifier|*
name|fdcsp
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|100
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fdcsp
operator|->
name|status
index|[
literal|0
index|]
operator|&
name|NE7_ST0_IC_RC
operator|)
operator|!=
name|NE7_ST0_IC_AT
condition|)
block|{
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"unexcpted interrupt code %#x"
argument_list|,
name|fdcsp
operator|->
name|status
index|[
literal|0
index|]
operator|&
name|NE7_ST0_IC_RC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|msgbuf
argument_list|,
literal|"unexpected error code in ST1/ST2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdcsp
operator|->
name|status
index|[
literal|1
index|]
operator|&
name|NE7_ST1_EN
condition|)
name|strcpy
argument_list|(
name|msgbuf
argument_list|,
literal|"end of cylinder (wrong format)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fdcsp
operator|->
name|status
index|[
literal|1
index|]
operator|&
name|NE7_ST1_DE
condition|)
block|{
if|if
condition|(
name|fdcsp
operator|->
name|status
index|[
literal|2
index|]
operator|&
name|NE7_ST2_DD
condition|)
name|strcpy
argument_list|(
name|msgbuf
argument_list|,
literal|"CRC error in data field"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|msgbuf
argument_list|,
literal|"CRC error in ID field"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fdcsp
operator|->
name|status
index|[
literal|1
index|]
operator|&
name|NE7_ST1_MA
condition|)
block|{
if|if
condition|(
name|fdcsp
operator|->
name|status
index|[
literal|2
index|]
operator|&
name|NE7_ST2_MD
condition|)
name|strcpy
argument_list|(
name|msgbuf
argument_list|,
literal|"no address mark in data field"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|msgbuf
argument_list|,
literal|"no address mark in ID field"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fdcsp
operator|->
name|status
index|[
literal|2
index|]
operator|&
name|NE7_ST2_WC
condition|)
name|strcpy
argument_list|(
name|msgbuf
argument_list|,
literal|"wrong cylinder (format mismatch)"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fdcsp
operator|->
name|status
index|[
literal|1
index|]
operator|&
name|NE7_ST1_ND
condition|)
name|strcpy
argument_list|(
name|msgbuf
argument_list|,
literal|"no data (sector not found)"
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
name|msgbuf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|format
init|=
operator|-
literal|1
decl_stmt|,
name|cyls
init|=
operator|-
literal|1
decl_stmt|,
name|secs
init|=
operator|-
literal|1
decl_stmt|,
name|heads
init|=
operator|-
literal|1
decl_stmt|,
name|intleave
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|rate
init|=
operator|-
literal|1
decl_stmt|,
name|gaplen
init|=
operator|-
literal|1
decl_stmt|,
name|secsize
init|=
operator|-
literal|1
decl_stmt|,
name|steps
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|fill
init|=
literal|0xf6
decl_stmt|,
name|quiet
init|=
literal|0
decl_stmt|,
name|verify
init|=
literal|1
decl_stmt|,
name|verify_only
init|=
literal|0
decl_stmt|,
name|confirm
init|=
literal|0
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|,
name|track
decl_stmt|,
name|error
decl_stmt|,
name|tracks_per_dot
decl_stmt|,
name|bytes_per_track
decl_stmt|,
name|errs
decl_stmt|;
name|int
name|fdopts
decl_stmt|;
specifier|const
name|char
modifier|*
name|devname
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
name|struct
name|fd_type
name|fdt
decl_stmt|;
define|#
directive|define
name|MAXPRINTERRS
value|10
name|struct
name|fdc_status
name|fdcs
index|[
name|MAXPRINTERRS
index|]
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"f:c:s:h:r:g:S:F:t:i:qyvn"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'f'
case|:
comment|/* format in kilobytes */
name|format
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* # of cyls */
name|cyls
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* # of secs per track */
name|secs
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* # of heads */
name|heads
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* transfer rate, kilobyte/sec */
name|rate
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* length of GAP3 to format with */
name|gaplen
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* sector size shift factor (1<< S)*128 */
name|secsize
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* fill byte, C-like notation allowed */
name|fill
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* steps per track */
name|steps
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* interleave factor */
name|intleave
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|confirm
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|verify
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verify
operator|=
literal|1
expr_stmt|;
name|verify_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
operator|-
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
default|default:
name|errx
argument_list|(
literal|2
argument_list|,
literal|"bad floppy size: %dK"
argument_list|,
name|format
argument_list|)
expr_stmt|;
case|case
operator|-
literal|1
case|:
name|suffix
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|360
case|:
name|suffix
operator|=
literal|".360"
expr_stmt|;
break|break;
case|case
literal|640
case|:
name|suffix
operator|=
literal|".640"
expr_stmt|;
break|break;
case|case
literal|720
case|:
name|suffix
operator|=
literal|".720"
expr_stmt|;
break|break;
case|case
literal|800
case|:
name|suffix
operator|=
literal|".800"
expr_stmt|;
break|break;
case|case
literal|820
case|:
name|suffix
operator|=
literal|".820"
expr_stmt|;
break|break;
case|case
literal|1200
case|:
name|suffix
operator|=
literal|".1200"
expr_stmt|;
break|break;
case|case
literal|1232
case|:
name|suffix
operator|=
literal|".1232"
expr_stmt|;
break|break;
case|case
literal|1440
case|:
name|suffix
operator|=
literal|".1440"
expr_stmt|;
break|break;
case|case
literal|1480
case|:
name|suffix
operator|=
literal|".1480"
expr_stmt|;
break|break;
case|case
literal|1720
case|:
name|suffix
operator|=
literal|".1720"
expr_stmt|;
break|break;
block|}
name|devname
operator|=
name|makename
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|devname
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_GTYPE
argument_list|,
operator|&
name|fdt
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"not a floppy disk: %s"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|fdopts
operator|=
name|FDOPT_NOERRLOG
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_SOPTS
argument_list|,
operator|&
name|fdopts
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl(FD_SOPTS, FDOPT_NOERRLOG)"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rate
condition|)
block|{
case|case
operator|-
literal|1
case|:
break|break;
case|case
literal|250
case|:
name|fdt
operator|.
name|trans
operator|=
name|FDC_250KBPS
expr_stmt|;
break|break;
case|case
literal|300
case|:
name|fdt
operator|.
name|trans
operator|=
name|FDC_300KBPS
expr_stmt|;
break|break;
case|case
literal|500
case|:
name|fdt
operator|.
name|trans
operator|=
name|FDC_500KBPS
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|2
argument_list|,
literal|"invalid transfer rate: %d"
argument_list|,
name|rate
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cyls
operator|>=
literal|0
condition|)
name|fdt
operator|.
name|tracks
operator|=
name|cyls
expr_stmt|;
if|if
condition|(
name|secs
operator|>=
literal|0
condition|)
name|fdt
operator|.
name|sectrac
operator|=
name|secs
expr_stmt|;
if|if
condition|(
name|fdt
operator|.
name|sectrac
operator|>
name|FD_MAX_NSEC
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"too many sectors per track, max value is %d"
argument_list|,
name|FD_MAX_NSEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|heads
operator|>=
literal|0
condition|)
name|fdt
operator|.
name|heads
operator|=
name|heads
expr_stmt|;
if|if
condition|(
name|gaplen
operator|>=
literal|0
condition|)
name|fdt
operator|.
name|f_gap
operator|=
name|gaplen
expr_stmt|;
if|if
condition|(
name|secsize
operator|>=
literal|0
condition|)
name|fdt
operator|.
name|secsize
operator|=
name|secsize
expr_stmt|;
if|if
condition|(
name|steps
operator|>=
literal|0
condition|)
name|fdt
operator|.
name|steptrac
operator|=
name|steps
expr_stmt|;
if|if
condition|(
name|intleave
operator|>=
literal|0
condition|)
name|fdt
operator|.
name|f_inter
operator|=
name|intleave
expr_stmt|;
name|bytes_per_track
operator|=
name|fdt
operator|.
name|sectrac
operator|*
operator|(
literal|1
operator|<<
name|fdt
operator|.
name|secsize
operator|)
operator|*
literal|128
expr_stmt|;
comment|/* XXX  20/40 = 0.5 */
name|tracks_per_dot
operator|=
operator|(
name|fdt
operator|.
name|tracks
operator|*
name|fdt
operator|.
name|heads
operator|+
literal|20
operator|)
operator|/
literal|40
expr_stmt|;
if|if
condition|(
name|verify_only
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Verify %dK floppy `%s'.\n"
argument_list|,
name|fdt
operator|.
name|tracks
operator|*
name|fdt
operator|.
name|heads
operator|*
name|bytes_per_track
operator|/
literal|1024
argument_list|,
name|devname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|!
name|confirm
condition|)
block|{
name|printf
argument_list|(
literal|"Format %dK floppy `%s'? (y/n): "
argument_list|,
name|fdt
operator|.
name|tracks
operator|*
name|fdt
operator|.
name|heads
operator|*
name|bytes_per_track
operator|/
literal|1024
argument_list|,
name|devname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"Not confirmed.\n"
argument_list|)
expr_stmt|;
return|return
literal|3
return|;
block|}
block|}
comment|/* 	 * Formatting. 	 */
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Processing "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|fdt
operator|.
name|tracks
operator|*
name|fdt
operator|.
name|heads
operator|)
operator|/
name|tracks_per_dot
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\rProcessing "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|errs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|track
operator|=
literal|0
init|;
name|track
operator|<
name|fdt
operator|.
name|tracks
operator|*
name|fdt
operator|.
name|heads
condition|;
name|track
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|verify_only
condition|)
block|{
name|format_track
argument_list|(
name|fd
argument_list|,
name|track
operator|/
name|fdt
operator|.
name|heads
argument_list|,
name|fdt
operator|.
name|sectrac
argument_list|,
name|track
operator|%
name|fdt
operator|.
name|heads
argument_list|,
name|fdt
operator|.
name|trans
argument_list|,
name|fdt
operator|.
name|f_gap
argument_list|,
name|fdt
operator|.
name|secsize
argument_list|,
name|fill
argument_list|,
name|fdt
operator|.
name|f_inter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|!
operator|(
operator|(
name|track
operator|+
literal|1
operator|)
operator|%
name|tracks_per_dot
operator|)
condition|)
block|{
name|putchar
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verify
condition|)
block|{
if|if
condition|(
name|verify_track
argument_list|(
name|fd
argument_list|,
name|track
argument_list|,
name|bytes_per_track
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|errs
operator|<
name|MAXPRINTERRS
operator|&&
name|errno
operator|==
name|EIO
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_GSTAT
argument_list|,
name|fdcs
operator|+
name|errs
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"floppy IO error, but no FDC status"
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|!
operator|(
operator|(
name|track
operator|+
literal|1
operator|)
operator|%
name|tracks_per_dot
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|verify_only
condition|)
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|putchar
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|" done.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|&&
name|errs
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Errors encountered:\nCyl Head Sect   Error\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|errs
operator|&&
name|i
operator|<
name|MAXPRINTERRS
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %2d   %2d   %2d   "
argument_list|,
name|fdcs
index|[
name|i
index|]
operator|.
name|status
index|[
literal|3
index|]
argument_list|,
name|fdcs
index|[
name|i
index|]
operator|.
name|status
index|[
literal|4
index|]
argument_list|,
name|fdcs
index|[
name|i
index|]
operator|.
name|status
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printstatus
argument_list|(
name|fdcs
operator|+
name|i
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errs
operator|>=
name|MAXPRINTERRS
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Further errors not printed.)\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|errs
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Local Variables:  *  c-indent-level:               8  *  c-continued-statement-offset: 8  *  c-continued-brace-offset:     0  *  c-brace-offset:              -8  *  c-brace-imaginary-offset:     0  *  c-argdecl-indent:             8  *  c-label-offset:              -8  *  c++-hanging-braces:           1  *  c++-access-specifier-offset: -8  *  c++-empty-arglist-indent:     8  *  c++-friend-offset:            0  * End:  */
end_comment

end_unit

