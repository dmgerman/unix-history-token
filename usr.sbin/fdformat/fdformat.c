begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1992-1994,2001 by Joerg Wunsch, Dresden  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/fdcio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"fdutil.h"
end_include

begin_function
specifier|static
name|void
name|format_track
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|cyl
parameter_list|,
name|int
name|secs
parameter_list|,
name|int
name|head
parameter_list|,
name|int
name|rate
parameter_list|,
name|int
name|gaplen
parameter_list|,
name|int
name|secsize
parameter_list|,
name|int
name|fill
parameter_list|,
name|int
name|interleave
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|fd_formb
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|il
index|[
name|FD_MAX_NSEC
operator|+
literal|1
index|]
decl_stmt|;
name|memset
argument_list|(
name|il
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|il
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
literal|1
operator|+
name|offset
init|;
name|i
operator|<=
name|secs
operator|+
name|offset
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|il
index|[
operator|(
name|j
operator|%
name|secs
operator|)
operator|+
literal|1
index|]
condition|)
name|j
operator|++
expr_stmt|;
name|il
index|[
operator|(
name|j
operator|%
name|secs
operator|)
operator|+
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|j
operator|+=
name|interleave
expr_stmt|;
block|}
name|f
operator|.
name|format_version
operator|=
name|FD_FORMAT_VERSION
expr_stmt|;
name|f
operator|.
name|head
operator|=
name|head
expr_stmt|;
name|f
operator|.
name|cyl
operator|=
name|cyl
expr_stmt|;
name|f
operator|.
name|transfer_rate
operator|=
name|rate
expr_stmt|;
name|f
operator|.
name|fd_formb_secshift
operator|=
name|secsize
expr_stmt|;
name|f
operator|.
name|fd_formb_nsecs
operator|=
name|secs
expr_stmt|;
name|f
operator|.
name|fd_formb_gaplen
operator|=
name|gaplen
expr_stmt|;
name|f
operator|.
name|fd_formb_fillbyte
operator|=
name|fill
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|secs
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|.
name|fd_formb_cylno
argument_list|(
name|i
argument_list|)
operator|=
name|cyl
expr_stmt|;
name|f
operator|.
name|fd_formb_headno
argument_list|(
name|i
argument_list|)
operator|=
name|head
expr_stmt|;
name|f
operator|.
name|fd_formb_secno
argument_list|(
name|i
argument_list|)
operator|=
name|il
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|f
operator|.
name|fd_formb_secsize
argument_list|(
name|i
argument_list|)
operator|=
name|secsize
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_FORM
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|f
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ioctl(FD_FORM)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|verify_track
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|track
parameter_list|,
name|int
name|tracksize
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
specifier|static
name|int
name|bufsz
decl_stmt|;
name|int
name|fdopts
init|=
operator|-
literal|1
decl_stmt|,
name|ofdopts
decl_stmt|,
name|rv
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_GOPTS
argument_list|,
operator|&
name|fdopts
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"warning: ioctl(FD_GOPTS)"
argument_list|)
expr_stmt|;
else|else
block|{
name|ofdopts
operator|=
name|fdopts
expr_stmt|;
name|fdopts
operator||=
name|FDOPT_NORETRY
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_SOPTS
argument_list|,
operator|&
name|fdopts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bufsz
operator|<
name|tracksize
condition|)
name|buf
operator|=
name|realloc
argument_list|(
name|buf
argument_list|,
name|bufsz
operator|=
name|tracksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|long
operator|)
name|track
operator|*
name|tracksize
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* try twice reading it, without using the normal retrier */
elseif|else
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|tracksize
argument_list|)
operator|!=
name|tracksize
operator|&&
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|tracksize
argument_list|)
operator|!=
name|tracksize
condition|)
name|rv
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fdopts
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_SOPTS
argument_list|,
operator|&
name|ofdopts
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"usage: fdformat [-F fill] [-f fmt] [-s fmtstr] [-nqvy] device"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|yes
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|reply
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|reply
index|[
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|reply
argument_list|,
sizeof|sizeof
argument_list|(
name|reply
argument_list|)
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|p
operator|=
name|reply
init|;
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|;
operator|++
name|p
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|'y'
operator|||
operator|*
name|p
operator|==
literal|'Y'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'n'
operator|||
operator|*
name|p
operator|==
literal|'N'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|printf
argument_list|(
literal|"Answer `yes' or `no': "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|enum
name|fd_drivetype
name|type
decl_stmt|;
name|struct
name|fd_type
name|fdt
decl_stmt|,
name|newft
decl_stmt|,
modifier|*
name|fdtp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
define|#
directive|define
name|MAXPRINTERRS
value|10
name|struct
name|fdc_status
name|fdcs
index|[
name|MAXPRINTERRS
index|]
decl_stmt|;
name|int
name|format
decl_stmt|,
name|fill
decl_stmt|,
name|quiet
decl_stmt|,
name|verify
decl_stmt|,
name|verify_only
decl_stmt|,
name|confirm
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|c
decl_stmt|,
name|i
decl_stmt|,
name|track
decl_stmt|,
name|error
decl_stmt|,
name|tracks_per_dot
decl_stmt|,
name|bytes_per_track
decl_stmt|,
name|errs
decl_stmt|;
name|int
name|fdopts
decl_stmt|,
name|flags
decl_stmt|;
name|char
modifier|*
name|fmtstring
decl_stmt|,
modifier|*
name|device
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|descr
decl_stmt|;
name|format
operator|=
name|quiet
operator|=
name|verify_only
operator|=
name|confirm
operator|=
literal|0
expr_stmt|;
name|verify
operator|=
literal|1
expr_stmt|;
name|fill
operator|=
literal|0xf6
expr_stmt|;
name|fmtstring
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"F:f:nqs:vy"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'F'
case|:
comment|/* fill byte */
if|if
condition|(
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|fill
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad argument %s to -F option; must be numeric\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
comment|/* format in kilobytes */
if|if
condition|(
name|getnum
argument_list|(
name|optarg
argument_list|,
operator|&
name|format
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad argument %s to -f option; must be numeric\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* don't verify */
name|verify
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
comment|/* quiet */
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* format string with detailed options */
name|fmtstring
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* verify only */
name|verify
operator|=
literal|1
expr_stmt|;
name|verify_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
comment|/* confirm */
name|confirm
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
operator|-
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* try prepending _PATH_DEV */
name|device
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|_PATH_DEV
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|device
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|device
argument_list|,
name|_PATH_DEV
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|device
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|device
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|device
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
comment|/* let it fail below */
block|}
block|}
else|else
block|{
name|device
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDWR
operator||
name|O_NONBLOCK
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"open(%s)"
argument_list|,
name|device
argument_list|)
expr_stmt|;
comment|/* 	 * Device initialization. 	 * 	 * First, get the device type descriptor.  This tells us about 	 * the media geometry data we need to format a medium.  It also 	 * lets us know quickly whether the device name actually points 	 * to a floppy disk drive. 	 * 	 * Then, obtain any drive options.  We're mainly interested to 	 * see whether we're currently working on a device with media 	 * density autoselection (FDOPT_AUTOSEL).  Then, we add the 	 * device option to tell the kernel not to log media errors, 	 * since we can handle them ourselves.  If the device does 	 * media density autoselection, we then need to set the device 	 * type appropriately, since by opening with O_NONBLOCK we 	 * told the driver to bypass media autoselection (otherwise we 	 * wouldn't stand a chance to format an unformatted or damaged 	 * medium).  We do not attempt to set the media type on any 	 * other devices since this is a privileged operation.  For the 	 * same reason, specifying -f and -s options is only possible 	 * for autoselecting devices. 	 * 	 * Finally, we are ready to turn off O_NONBLOCK, and start to 	 * actually format something. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_GTYPE
argument_list|,
operator|&
name|fdt
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
name|EX_OSERR
argument_list|,
literal|"not a floppy disk: %s"
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_GDTYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ioctl(FD_GDTYPE)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_GOPTS
argument_list|,
operator|&
name|fdopts
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ioctl(FD_GOPTS)"
argument_list|)
expr_stmt|;
name|fdopts
operator||=
name|FDOPT_NOERRLOG
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_SOPTS
argument_list|,
operator|&
name|fdopts
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ioctl(FD_SOPTS, FDOPT_NOERRLOG)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|getname
argument_list|(
name|type
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|descr
argument_list|)
expr_stmt|;
name|fdtp
operator|=
name|get_fmt
argument_list|(
name|format
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdtp
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"unknown format %d KB for drive type %s"
argument_list|,
name|format
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fdt
operator|=
operator|*
name|fdtp
expr_stmt|;
block|}
if|if
condition|(
name|fmtstring
condition|)
block|{
name|parse_fmt
argument_list|(
name|fmtstring
argument_list|,
name|type
argument_list|,
name|fdt
argument_list|,
operator|&
name|newft
argument_list|)
expr_stmt|;
name|fdt
operator|=
name|newft
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_STYPE
argument_list|,
operator|&
name|fdt
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ioctl(FD_STYPE)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"fcntl(F_GETFL)"
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"fcntl(F_SETFL)"
argument_list|)
expr_stmt|;
name|bytes_per_track
operator|=
name|fdt
operator|.
name|sectrac
operator|*
operator|(
literal|128
operator|<<
name|fdt
operator|.
name|secsize
operator|)
expr_stmt|;
comment|/* XXX  20/40 = 0.5 */
name|tracks_per_dot
operator|=
operator|(
name|fdt
operator|.
name|tracks
operator|*
name|fdt
operator|.
name|heads
operator|+
literal|20
operator|)
operator|/
literal|40
expr_stmt|;
if|if
condition|(
name|verify_only
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"Verify %dK floppy `%s'.\n"
argument_list|,
name|fdt
operator|.
name|tracks
operator|*
name|fdt
operator|.
name|heads
operator|*
name|bytes_per_track
operator|/
literal|1024
argument_list|,
name|device
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|!
name|confirm
condition|)
block|{
name|printf
argument_list|(
literal|"Format %dK floppy `%s'? (y/n): "
argument_list|,
name|fdt
operator|.
name|tracks
operator|*
name|fdt
operator|.
name|heads
operator|*
name|bytes_per_track
operator|/
literal|1024
argument_list|,
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yes
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"Not confirmed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EX_UNAVAILABLE
operator|)
return|;
block|}
block|}
comment|/* 	 * Formatting. 	 */
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|printf
argument_list|(
literal|"Processing "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|fdt
operator|.
name|tracks
operator|*
name|fdt
operator|.
name|heads
operator|)
operator|/
name|tracks_per_dot
condition|;
name|i
operator|++
control|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\rProcessing "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|errs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|track
operator|=
literal|0
init|;
name|track
operator|<
name|fdt
operator|.
name|tracks
operator|*
name|fdt
operator|.
name|heads
condition|;
name|track
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|verify_only
condition|)
block|{
name|format_track
argument_list|(
name|fd
argument_list|,
name|track
operator|/
name|fdt
operator|.
name|heads
argument_list|,
name|fdt
operator|.
name|sectrac
argument_list|,
name|track
operator|%
name|fdt
operator|.
name|heads
argument_list|,
name|fdt
operator|.
name|trans
argument_list|,
name|fdt
operator|.
name|f_gap
argument_list|,
name|fdt
operator|.
name|secsize
argument_list|,
name|fill
argument_list|,
name|fdt
operator|.
name|f_inter
argument_list|,
name|track
operator|%
name|fdt
operator|.
name|heads
condition|?
name|fdt
operator|.
name|offset_side2
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|!
operator|(
operator|(
name|track
operator|+
literal|1
operator|)
operator|%
name|tracks_per_dot
operator|)
condition|)
block|{
name|putchar
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verify
condition|)
block|{
if|if
condition|(
name|verify_track
argument_list|(
name|fd
argument_list|,
name|track
argument_list|,
name|bytes_per_track
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|errs
operator|<
name|MAXPRINTERRS
operator|&&
name|errno
operator|==
name|EIO
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FD_GSTAT
argument_list|,
name|fdcs
operator|+
name|errs
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_IOERR
argument_list|,
literal|"floppy IO error, but no FDC status"
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|!
operator|(
operator|(
name|track
operator|+
literal|1
operator|)
operator|%
name|tracks_per_dot
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|verify_only
condition|)
name|putchar
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|putchar
argument_list|(
literal|'E'
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|putchar
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|" done.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
operator|&&
name|errs
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Errors encountered:\nCyl Head Sect   Error\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|errs
operator|&&
name|i
operator|<
name|MAXPRINTERRS
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %2d   %2d   %2d   "
argument_list|,
name|fdcs
index|[
name|i
index|]
operator|.
name|status
index|[
literal|3
index|]
argument_list|,
name|fdcs
index|[
name|i
index|]
operator|.
name|status
index|[
literal|4
index|]
argument_list|,
name|fdcs
index|[
name|i
index|]
operator|.
name|status
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printstatus
argument_list|(
name|fdcs
operator|+
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errs
operator|>=
name|MAXPRINTERRS
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(Further errors not printed.)\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|errs
operator|!=
literal|0
return|;
block|}
end_function

end_unit

