begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2005 Colin Percival  * All rights reserved  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted providing that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|env_HTTP_PROXY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|env_HTTP_PROXY_AUTH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|env_HTTP_USER_AGENT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|proxyport
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|proxyauth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|timo
init|=
block|{
literal|15
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: phttpget server [file ...]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Base64 encode a string; the string returned, if non-NULL, is  * allocated using malloc() and must be freed by the caller.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|b64enc
parameter_list|(
specifier|const
name|char
modifier|*
name|ptext
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|base64
index|[]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
literal|"abcdefghijklmnopqrstuvwxyz"
literal|"0123456789+/"
decl_stmt|;
specifier|const
name|char
modifier|*
name|pt
decl_stmt|;
name|char
modifier|*
name|ctext
decl_stmt|,
modifier|*
name|pc
decl_stmt|;
name|size_t
name|ptlen
decl_stmt|,
name|ctlen
decl_stmt|;
name|uint32_t
name|t
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
comment|/* 	 * Encoded length is 4 characters per 3-byte block or partial 	 * block of plaintext, plus one byte for the terminating NUL 	 */
name|ptlen
operator|=
name|strlen
argument_list|(
name|ptext
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptlen
operator|>
operator|(
operator|(
name|SIZE_MAX
operator|-
literal|1
operator|)
operator|/
literal|4
operator|)
operator|*
literal|3
operator|-
literal|2
condition|)
return|return
name|NULL
return|;
comment|/* Possible integer overflow */
name|ctlen
operator|=
literal|4
operator|*
operator|(
operator|(
name|ptlen
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ctext
operator|=
name|malloc
argument_list|(
name|ctlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ctext
index|[
name|ctlen
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Scan through ptext, reading up to 3 bytes from ptext and 	 * writing 4 bytes to ctext, until we run out of input. 	 */
for|for
control|(
name|pt
operator|=
name|ptext
operator|,
name|pc
operator|=
name|ctext
init|;
name|ptlen
condition|;
name|ptlen
operator|-=
literal|3
operator|,
name|pc
operator|+=
literal|4
control|)
block|{
comment|/* Read 3 bytes */
for|for
control|(
name|t
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|t
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|ptlen
condition|)
name|t
operator|+=
operator|*
name|pt
operator|++
expr_stmt|;
block|}
comment|/* Write 4 bytes */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|<=
name|ptlen
operator|+
literal|1
condition|)
name|pc
index|[
name|j
index|]
operator|=
name|base64
index|[
operator|(
name|t
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
else|else
name|pc
index|[
name|j
index|]
operator|=
literal|'='
expr_stmt|;
name|t
operator|<<=
literal|6
expr_stmt|;
block|}
comment|/* If we're done, exit the loop */
if|if
condition|(
name|ptlen
operator|<=
literal|3
condition|)
break|break;
block|}
return|return
operator|(
name|ctext
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|readenv
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|proxy_auth_userpass
decl_stmt|,
modifier|*
name|proxy_auth_userpass64
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|proxy_auth_user
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|proxy_auth_pass
init|=
name|NULL
decl_stmt|;
name|env_HTTP_PROXY
operator|=
name|getenv
argument_list|(
literal|"HTTP_PROXY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_HTTP_PROXY
operator|==
name|NULL
condition|)
name|env_HTTP_PROXY
operator|=
name|getenv
argument_list|(
literal|"http_proxy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_HTTP_PROXY
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|env_HTTP_PROXY
argument_list|,
literal|"http://"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|env_HTTP_PROXY
operator|+=
literal|7
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|env_HTTP_PROXY
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|env_HTTP_PROXY
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|proxyport
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|proxyport
operator|=
literal|"3128"
expr_stmt|;
block|}
name|env_HTTP_PROXY_AUTH
operator|=
name|getenv
argument_list|(
literal|"HTTP_PROXY_AUTH"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|env_HTTP_PROXY
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|env_HTTP_PROXY_AUTH
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strncasecmp
argument_list|(
name|env_HTTP_PROXY_AUTH
argument_list|,
literal|"basic:"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Ignore authentication scheme */
operator|(
name|void
operator|)
name|strsep
argument_list|(
operator|&
name|env_HTTP_PROXY_AUTH
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/* Ignore realm */
operator|(
name|void
operator|)
name|strsep
argument_list|(
operator|&
name|env_HTTP_PROXY_AUTH
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/* Obtain username and password */
name|proxy_auth_user
operator|=
name|strsep
argument_list|(
operator|&
name|env_HTTP_PROXY_AUTH
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|proxy_auth_pass
operator|=
name|env_HTTP_PROXY_AUTH
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|proxy_auth_user
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|proxy_auth_pass
operator|!=
name|NULL
operator|)
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|proxy_auth_userpass
argument_list|,
literal|"%s:%s"
argument_list|,
name|proxy_auth_user
argument_list|,
name|proxy_auth_pass
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxy_auth_userpass
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|proxy_auth_userpass64
operator|=
name|b64enc
argument_list|(
name|proxy_auth_userpass
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxy_auth_userpass64
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|asprintf
argument_list|(
operator|&
name|proxyauth
argument_list|,
literal|"Proxy-Authorization: Basic %s\r\n"
argument_list|,
name|proxy_auth_userpass64
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxyauth
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|proxy_auth_userpass
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|proxy_auth_userpass64
argument_list|)
expr_stmt|;
block|}
else|else
name|proxyauth
operator|=
name|NULL
expr_stmt|;
name|env_HTTP_USER_AGENT
operator|=
name|getenv
argument_list|(
literal|"HTTP_USER_AGENT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env_HTTP_USER_AGENT
operator|==
name|NULL
condition|)
name|env_HTTP_USER_AGENT
operator|=
literal|"phttpget/0.1"
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|makerequest
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|server
parameter_list|,
name|int
name|connclose
parameter_list|)
block|{
name|int
name|buflen
decl_stmt|;
name|buflen
operator|=
name|asprintf
argument_list|(
name|buf
argument_list|,
literal|"GET %s%s/%s HTTP/1.1\r\n"
literal|"Host: %s\r\n"
literal|"User-Agent: %s\r\n"
literal|"%s"
literal|"%s"
literal|"\r\n"
argument_list|,
name|env_HTTP_PROXY
condition|?
literal|"http://"
else|:
literal|""
argument_list|,
name|env_HTTP_PROXY
condition|?
name|server
else|:
literal|""
argument_list|,
name|path
argument_list|,
name|server
argument_list|,
name|env_HTTP_USER_AGENT
argument_list|,
name|proxyauth
condition|?
name|proxyauth
else|:
literal|""
argument_list|,
name|connclose
condition|?
literal|"Connection: Close\r\n"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
return|return
operator|(
name|buflen
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|readln
parameter_list|(
name|int
name|sd
parameter_list|,
name|char
modifier|*
name|resbuf
parameter_list|,
name|int
modifier|*
name|resbuflen
parameter_list|,
name|int
modifier|*
name|resbufpos
parameter_list|)
block|{
name|ssize_t
name|len
decl_stmt|;
while|while
condition|(
name|strnstr
argument_list|(
name|resbuf
operator|+
operator|*
name|resbufpos
argument_list|,
literal|"\r\n"
argument_list|,
operator|*
name|resbuflen
operator|-
operator|*
name|resbufpos
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Move buffered data to the start of the buffer */
if|if
condition|(
operator|*
name|resbufpos
operator|!=
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|resbuf
argument_list|,
name|resbuf
operator|+
operator|*
name|resbufpos
argument_list|,
operator|*
name|resbuflen
operator|-
operator|*
name|resbufpos
argument_list|)
expr_stmt|;
operator|*
name|resbuflen
operator|-=
operator|*
name|resbufpos
expr_stmt|;
operator|*
name|resbufpos
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If the buffer is full, complain */
if|if
condition|(
operator|*
name|resbuflen
operator|==
name|BUFSIZ
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Read more data into the buffer */
name|len
operator|=
name|recv
argument_list|(
name|sd
argument_list|,
name|resbuf
operator|+
operator|*
name|resbuflen
argument_list|,
name|BUFSIZ
operator|-
operator|*
name|resbuflen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EINTR
operator|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|len
operator|!=
operator|-
literal|1
condition|)
operator|*
name|resbuflen
operator|+=
name|len
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copybytes
parameter_list|(
name|int
name|sd
parameter_list|,
name|int
name|fd
parameter_list|,
name|off_t
name|copylen
parameter_list|,
name|char
modifier|*
name|resbuf
parameter_list|,
name|int
modifier|*
name|resbuflen
parameter_list|,
name|int
modifier|*
name|resbufpos
parameter_list|)
block|{
name|ssize_t
name|len
decl_stmt|;
while|while
condition|(
name|copylen
condition|)
block|{
comment|/* Write data from resbuf to fd */
name|len
operator|=
operator|*
name|resbuflen
operator|-
operator|*
name|resbufpos
expr_stmt|;
if|if
condition|(
name|copylen
operator|<
name|len
condition|)
name|len
operator|=
name|copylen
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|len
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|resbuf
operator|+
operator|*
name|resbufpos
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
operator|*
name|resbufpos
operator|+=
name|len
expr_stmt|;
name|copylen
operator|-=
name|len
expr_stmt|;
continue|continue;
block|}
comment|/* Read more data into buffer */
name|len
operator|=
name|recv
argument_list|(
name|sd
argument_list|,
name|resbuf
argument_list|,
name|BUFSIZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
operator|-
literal|2
return|;
block|}
else|else
block|{
operator|*
name|resbuflen
operator|=
name|len
expr_stmt|;
operator|*
name|resbufpos
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|;
comment|/* Hints to getaddrinfo */
name|struct
name|addrinfo
modifier|*
name|res
decl_stmt|;
comment|/* Pointer to server address being used */
name|struct
name|addrinfo
modifier|*
name|res0
decl_stmt|;
comment|/* Pointer to server addresses */
name|char
modifier|*
name|resbuf
init|=
name|NULL
decl_stmt|;
comment|/* Response buffer */
name|int
name|resbufpos
init|=
literal|0
decl_stmt|;
comment|/* Response buffer position */
name|int
name|resbuflen
init|=
literal|0
decl_stmt|;
comment|/* Response buffer length */
name|char
modifier|*
name|eolp
decl_stmt|;
comment|/* Pointer to "\r\n" within resbuf */
name|char
modifier|*
name|hln
decl_stmt|;
comment|/* Pointer within header line */
name|char
modifier|*
name|servername
decl_stmt|;
comment|/* Name of server */
name|char
modifier|*
name|fname
init|=
name|NULL
decl_stmt|;
comment|/* Name of downloaded file */
name|char
modifier|*
name|reqbuf
init|=
name|NULL
decl_stmt|;
comment|/* Request buffer */
name|int
name|reqbufpos
init|=
literal|0
decl_stmt|;
comment|/* Request buffer position */
name|int
name|reqbuflen
init|=
literal|0
decl_stmt|;
comment|/* Request buffer length */
name|ssize_t
name|len
decl_stmt|;
comment|/* Length sent or received */
name|int
name|nreq
init|=
literal|0
decl_stmt|;
comment|/* Number of next request to send */
name|int
name|nres
init|=
literal|0
decl_stmt|;
comment|/* Number of next reply to receive */
name|int
name|pipelined
init|=
literal|0
decl_stmt|;
comment|/* != 0 if connection in pipelined mode. */
name|int
name|sd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Socket descriptor */
name|int
name|sdflags
init|=
literal|0
decl_stmt|;
comment|/* Flags on the socket sd */
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Descriptor for download target file */
name|int
name|error
decl_stmt|;
comment|/* Error code */
name|int
name|statuscode
decl_stmt|;
comment|/* HTTP Status code */
name|off_t
name|contentlength
decl_stmt|;
comment|/* Value from Content-Length header */
name|int
name|chunked
decl_stmt|;
comment|/* != if transfer-encoding is chunked */
name|off_t
name|clen
decl_stmt|;
comment|/* Chunk length */
name|int
name|firstreq
init|=
literal|0
decl_stmt|;
comment|/* # of first request for this connection */
comment|/* Check that the arguments are sensible */
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* Read important environment variables */
name|readenv
argument_list|()
expr_stmt|;
comment|/* Get server name and adjust arg[cv] to point at file names */
name|servername
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
comment|/* Allocate response buffer */
name|resbuf
operator|=
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|resbuf
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
comment|/* Look up server */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|env_HTTP_PROXY
condition|?
name|env_HTTP_PROXY
else|:
name|servername
argument_list|,
name|env_HTTP_PROXY
condition|?
name|proxyport
else|:
literal|"http"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"host = %s, port = %s: %s"
argument_list|,
name|env_HTTP_PROXY
condition|?
name|env_HTTP_PROXY
else|:
name|servername
argument_list|,
name|env_HTTP_PROXY
condition|?
name|proxyport
else|:
literal|"http"
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|res0
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"could not look up %s"
argument_list|,
name|servername
argument_list|)
expr_stmt|;
name|res
operator|=
name|res0
expr_stmt|;
comment|/* Do the fetching */
while|while
condition|(
name|nres
operator|<
name|argc
condition|)
block|{
comment|/* Make sure we have a connected socket */
for|for
control|(
init|;
name|sd
operator|==
operator|-
literal|1
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
comment|/* No addresses left to try :-( */
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Could not connect to %s"
argument_list|,
name|servername
argument_list|)
expr_stmt|;
comment|/* Create a socket... */
name|sd
operator|=
name|socket
argument_list|(
name|res
operator|->
name|ai_family
argument_list|,
name|res
operator|->
name|ai_socktype
argument_list|,
name|res
operator|->
name|ai_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
operator|-
literal|1
condition|)
continue|continue;
comment|/* ... set 15-second timeouts ... */
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDTIMEO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|timo
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|timo
argument_list|)
argument_list|)
expr_stmt|;
name|setsockopt
argument_list|(
name|sd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVTIMEO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|timo
argument_list|,
operator|(
name|socklen_t
operator|)
sizeof|sizeof
argument_list|(
name|timo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... and connect to the server. */
if|if
condition|(
name|connect
argument_list|(
name|sd
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|sd
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|firstreq
operator|=
name|nres
expr_stmt|;
block|}
comment|/* 		 * If in pipelined HTTP mode, put socket into non-blocking 		 * mode, since we're probably going to want to try to send 		 * several HTTP requests. 		 */
if|if
condition|(
name|pipelined
condition|)
block|{
name|sdflags
operator|=
name|fcntl
argument_list|(
name|sd
argument_list|,
name|F_GETFL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|sd
argument_list|,
name|F_SETFL
argument_list|,
name|sdflags
operator||
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fcntl"
argument_list|)
expr_stmt|;
block|}
comment|/* Construct requests and/or send them without blocking */
while|while
condition|(
operator|(
name|nreq
operator|<
name|argc
operator|)
operator|&&
operator|(
operator|(
name|reqbuf
operator|==
name|NULL
operator|)
operator|||
name|pipelined
operator|)
condition|)
block|{
comment|/* If not in the middle of a request, make one */
if|if
condition|(
name|reqbuf
operator|==
name|NULL
condition|)
block|{
name|reqbuflen
operator|=
name|makerequest
argument_list|(
operator|&
name|reqbuf
argument_list|,
name|argv
index|[
name|nreq
index|]
argument_list|,
name|servername
argument_list|,
operator|(
name|nreq
operator|==
name|argc
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|reqbufpos
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If in pipelined mode, try to send the request */
if|if
condition|(
name|pipelined
condition|)
block|{
while|while
condition|(
name|reqbufpos
operator|<
name|reqbuflen
condition|)
block|{
name|len
operator|=
name|send
argument_list|(
name|sd
argument_list|,
name|reqbuf
operator|+
name|reqbufpos
argument_list|,
name|reqbuflen
operator|-
name|reqbufpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
break|break;
name|reqbufpos
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|reqbufpos
operator|<
name|reqbuflen
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
goto|goto
name|conndied
goto|;
break|break;
block|}
else|else
block|{
name|free
argument_list|(
name|reqbuf
argument_list|)
expr_stmt|;
name|reqbuf
operator|=
name|NULL
expr_stmt|;
name|nreq
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Put connection back into blocking mode */
if|if
condition|(
name|pipelined
condition|)
block|{
if|if
condition|(
name|fcntl
argument_list|(
name|sd
argument_list|,
name|F_SETFL
argument_list|,
name|sdflags
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fcntl"
argument_list|)
expr_stmt|;
block|}
comment|/* Do we need to blocking-send a request? */
if|if
condition|(
name|nres
operator|==
name|nreq
condition|)
block|{
while|while
condition|(
name|reqbufpos
operator|<
name|reqbuflen
condition|)
block|{
name|len
operator|=
name|send
argument_list|(
name|sd
argument_list|,
name|reqbuf
operator|+
name|reqbufpos
argument_list|,
name|reqbuflen
operator|-
name|reqbufpos
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
goto|goto
name|conndied
goto|;
name|reqbufpos
operator|+=
name|len
expr_stmt|;
block|}
name|free
argument_list|(
name|reqbuf
argument_list|)
expr_stmt|;
name|reqbuf
operator|=
name|NULL
expr_stmt|;
name|nreq
operator|++
expr_stmt|;
block|}
comment|/* Scan through the response processing headers. */
name|statuscode
operator|=
literal|0
expr_stmt|;
name|contentlength
operator|=
operator|-
literal|1
expr_stmt|;
name|chunked
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Get a header line */
name|error
operator|=
name|readln
argument_list|(
name|sd
argument_list|,
name|resbuf
argument_list|,
operator|&
name|resbuflen
argument_list|,
operator|&
name|resbufpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|conndied
goto|;
name|hln
operator|=
name|resbuf
operator|+
name|resbufpos
expr_stmt|;
name|eolp
operator|=
name|strnstr
argument_list|(
name|hln
argument_list|,
literal|"\r\n"
argument_list|,
name|resbuflen
operator|-
name|resbufpos
argument_list|)
expr_stmt|;
name|resbufpos
operator|=
operator|(
name|eolp
operator|-
name|resbuf
operator|)
operator|+
literal|2
expr_stmt|;
operator|*
name|eolp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Make sure it doesn't contain a NUL character */
if|if
condition|(
name|strchr
argument_list|(
name|hln
argument_list|,
literal|'\0'
argument_list|)
operator|!=
name|eolp
condition|)
goto|goto
name|conndied
goto|;
if|if
condition|(
name|statuscode
operator|==
literal|0
condition|)
block|{
comment|/* The first line MUST be HTTP/1.x xxx ... */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|hln
argument_list|,
literal|"HTTP/1."
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|!
name|isdigit
argument_list|(
name|hln
index|[
literal|7
index|]
argument_list|)
condition|)
goto|goto
name|conndied
goto|;
comment|/* 				 * If the minor version number isn't zero, 				 * then we can assume that pipelining our 				 * requests is OK -- as long as we don't 				 * see a "Connection: close" line later 				 * and we either have a Content-Length or 				 * Transfer-Encoding: chunked header to 				 * tell us the length. 				 */
if|if
condition|(
name|hln
index|[
literal|7
index|]
operator|!=
literal|'0'
condition|)
name|pipelined
operator|=
literal|1
expr_stmt|;
comment|/* Skip over the minor version number */
name|hln
operator|=
name|strchr
argument_list|(
name|hln
operator|+
literal|7
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|hln
operator|==
name|NULL
condition|)
goto|goto
name|conndied
goto|;
else|else
name|hln
operator|++
expr_stmt|;
comment|/* Read the status code */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|hln
argument_list|)
condition|)
block|{
name|statuscode
operator|=
name|statuscode
operator|*
literal|10
operator|+
operator|*
name|hln
operator|-
literal|'0'
expr_stmt|;
name|hln
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|statuscode
operator|<
literal|100
operator|||
name|statuscode
operator|>
literal|599
condition|)
goto|goto
name|conndied
goto|;
comment|/* Ignore the rest of the line */
continue|continue;
block|}
comment|/* Check for "Connection: close" header */
if|if
condition|(
name|strncmp
argument_list|(
name|hln
argument_list|,
literal|"Connection:"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hln
operator|+=
literal|11
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|hln
argument_list|,
literal|"close"
argument_list|)
operator|!=
name|NULL
condition|)
name|pipelined
operator|=
literal|0
expr_stmt|;
comment|/* Next header... */
continue|continue;
block|}
comment|/* Check for "Content-Length:" header */
if|if
condition|(
name|strncmp
argument_list|(
name|hln
argument_list|,
literal|"Content-Length:"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hln
operator|+=
literal|15
expr_stmt|;
name|contentlength
operator|=
literal|0
expr_stmt|;
comment|/* Find the start of the length */
while|while
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|hln
argument_list|)
operator|&&
operator|(
operator|*
name|hln
operator|!=
literal|'\0'
operator|)
condition|)
name|hln
operator|++
expr_stmt|;
comment|/* Compute the length */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|hln
argument_list|)
condition|)
block|{
if|if
condition|(
name|contentlength
operator|>=
name|OFF_MAX
operator|/
literal|10
condition|)
block|{
comment|/* Nasty people... */
goto|goto
name|conndied
goto|;
block|}
name|contentlength
operator|=
name|contentlength
operator|*
literal|10
operator|+
operator|*
name|hln
operator|-
literal|'0'
expr_stmt|;
name|hln
operator|++
expr_stmt|;
block|}
comment|/* Next header... */
continue|continue;
block|}
comment|/* Check for "Transfer-Encoding: chunked" header */
if|if
condition|(
name|strncmp
argument_list|(
name|hln
argument_list|,
literal|"Transfer-Encoding:"
argument_list|,
literal|18
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hln
operator|+=
literal|18
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|hln
argument_list|,
literal|"chunked"
argument_list|)
operator|!=
name|NULL
condition|)
name|chunked
operator|=
literal|1
expr_stmt|;
comment|/* Next header... */
continue|continue;
block|}
comment|/* We blithely ignore any other header lines */
comment|/* No more header lines */
if|if
condition|(
name|strlen
argument_list|(
name|hln
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If the status code was 1xx, then there will 				 * be a real header later.  Servers may emit 				 * 1xx header blocks at will, but since we 				 * don't expect one, we should just ignore it. 				 */
if|if
condition|(
literal|100
operator|<=
name|statuscode
operator|&&
name|statuscode
operator|<=
literal|199
condition|)
block|{
name|statuscode
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* End of header; message body follows */
break|break;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* No message body for 204 or 304 */
if|if
condition|(
name|statuscode
operator|==
literal|204
operator|||
name|statuscode
operator|==
literal|304
condition|)
block|{
name|nres
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * There should be a message body coming, but we only want 		 * to send it to a file if the status code is 200 		 */
if|if
condition|(
name|statuscode
operator|==
literal|200
condition|)
block|{
comment|/* Generate a file name for the download */
name|fname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
name|nres
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
name|fname
operator|=
name|argv
index|[
name|nres
index|]
expr_stmt|;
else|else
name|fname
operator|++
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Cannot obtain file name from %s\n"
argument_list|,
name|argv
index|[
name|nres
index|]
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"open(%s)"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* Read the message and send data to fd if appropriate */
if|if
condition|(
name|chunked
condition|)
block|{
comment|/* Handle a chunked-encoded entity */
comment|/* Read chunks */
do|do
block|{
name|error
operator|=
name|readln
argument_list|(
name|sd
argument_list|,
name|resbuf
argument_list|,
operator|&
name|resbuflen
argument_list|,
operator|&
name|resbufpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|conndied
goto|;
name|hln
operator|=
name|resbuf
operator|+
name|resbufpos
expr_stmt|;
name|eolp
operator|=
name|strstr
argument_list|(
name|hln
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|resbufpos
operator|=
operator|(
name|eolp
operator|-
name|resbuf
operator|)
operator|+
literal|2
expr_stmt|;
name|clen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isxdigit
argument_list|(
operator|*
name|hln
argument_list|)
condition|)
block|{
if|if
condition|(
name|clen
operator|>=
name|OFF_MAX
operator|/
literal|16
condition|)
block|{
comment|/* Nasty people... */
goto|goto
name|conndied
goto|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|hln
argument_list|)
condition|)
name|clen
operator|=
name|clen
operator|*
literal|16
operator|+
operator|*
name|hln
operator|-
literal|'0'
expr_stmt|;
else|else
name|clen
operator|=
name|clen
operator|*
literal|16
operator|+
literal|10
operator|+
name|tolower
argument_list|(
operator|*
name|hln
argument_list|)
operator|-
literal|'a'
expr_stmt|;
name|hln
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|copybytes
argument_list|(
name|sd
argument_list|,
name|fd
argument_list|,
name|clen
argument_list|,
name|resbuf
argument_list|,
operator|&
name|resbuflen
argument_list|,
operator|&
name|resbufpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|conndied
goto|;
block|}
block|}
do|while
condition|(
name|clen
operator|!=
literal|0
condition|)
do|;
comment|/* Read trailer and final CRLF */
do|do
block|{
name|error
operator|=
name|readln
argument_list|(
name|sd
argument_list|,
name|resbuf
argument_list|,
operator|&
name|resbuflen
argument_list|,
operator|&
name|resbufpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|conndied
goto|;
name|hln
operator|=
name|resbuf
operator|+
name|resbufpos
expr_stmt|;
name|eolp
operator|=
name|strstr
argument_list|(
name|hln
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
name|resbufpos
operator|=
operator|(
name|eolp
operator|-
name|resbuf
operator|)
operator|+
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|hln
operator|!=
name|eolp
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|contentlength
operator|!=
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|copybytes
argument_list|(
name|sd
argument_list|,
name|fd
argument_list|,
name|contentlength
argument_list|,
name|resbuf
argument_list|,
operator|&
name|resbuflen
argument_list|,
operator|&
name|resbufpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|conndied
goto|;
block|}
else|else
block|{
comment|/* 			 * Not chunked, and no content length header. 			 * Read everything until the server closes the 			 * socket. 			 */
name|error
operator|=
name|copybytes
argument_list|(
name|sd
argument_list|,
name|fd
argument_list|,
name|OFF_MAX
argument_list|,
name|resbuf
argument_list|,
operator|&
name|resbuflen
argument_list|,
operator|&
name|resbufpos
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
goto|goto
name|conndied
goto|;
name|pipelined
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"http://%s/%s: %d "
argument_list|,
name|servername
argument_list|,
name|argv
index|[
name|nres
index|]
argument_list|,
name|statuscode
argument_list|)
expr_stmt|;
if|if
condition|(
name|statuscode
operator|==
literal|200
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"OK\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|statuscode
operator|<
literal|300
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Successful (ignored)\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|statuscode
operator|<
literal|400
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Redirection (ignored)\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error (ignored)\n"
argument_list|)
expr_stmt|;
comment|/* We've finished this file! */
name|nres
operator|++
expr_stmt|;
comment|/* 		 * If necessary, clean up this connection so that we 		 * can start a new one. 		 */
if|if
condition|(
name|pipelined
operator|==
literal|0
condition|)
goto|goto
name|cleanupconn
goto|;
continue|continue;
name|conndied
label|:
comment|/* 		 * Something went wrong -- our connection died, the server 		 * sent us garbage, etc.  If this happened on the first 		 * request we sent over this connection, give up.  Otherwise, 		 * close this connection, open a new one, and reissue the 		 * request. 		 */
if|if
condition|(
name|nres
operator|==
name|firstreq
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Connection failure"
argument_list|)
expr_stmt|;
name|cleanupconn
label|:
comment|/* 		 * Clean up our connection and keep on going 		 */
name|shutdown
argument_list|(
name|sd
argument_list|,
name|SHUT_RDWR
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
name|sd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|reqbuf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|reqbuf
argument_list|)
expr_stmt|;
name|reqbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|nreq
operator|=
name|nres
expr_stmt|;
name|res
operator|=
name|res0
expr_stmt|;
name|pipelined
operator|=
literal|0
expr_stmt|;
name|resbufpos
operator|=
name|resbuflen
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|free
argument_list|(
name|resbuf
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|res0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

