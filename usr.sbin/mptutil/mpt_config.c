begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (c) 2008 Yahoo!, Inc.  * All rights reserved.  * Written by: John Baldwin<jhb@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"mptutil.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|dump_config
parameter_list|(
name|CONFIG_PAGE_RAID_VOL_0
modifier|*
name|vol
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|long
name|dehumanize
parameter_list|(
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|vtp
decl_stmt|;
name|long
name|iv
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|iv
operator|=
name|strtoq
argument_list|(
name|value
argument_list|,
operator|&
name|vtp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtp
operator|==
name|value
operator|||
operator|(
name|vtp
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|vtp
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|vtp
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'t'
case|:
case|case
literal|'T'
case|:
name|iv
operator|*=
literal|1024
expr_stmt|;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|iv
operator|*=
literal|1024
expr_stmt|;
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|iv
operator|*=
literal|1024
expr_stmt|;
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
name|iv
operator|*=
literal|1024
expr_stmt|;
case|case
literal|'\0'
case|:
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|iv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock the volume by opening its /dev device read/write.  This will  * only work if nothing else has it opened (including mounts).  We  * leak the fd on purpose since this application is not long-running.  */
end_comment

begin_function
name|int
name|mpt_lock_volume
parameter_list|(
name|U8
name|VolumeBus
parameter_list|,
name|U8
name|VolumeID
parameter_list|)
block|{
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|mpt_query_disk
name|qd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|vfd
decl_stmt|;
name|error
operator|=
name|mpt_query_disk
argument_list|(
name|VolumeBus
argument_list|,
name|VolumeID
argument_list|,
operator|&
name|qd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
comment|/* 		 * This means there isn't a CAM device associated with 		 * the volume, and thus it is already implicitly 		 * locked, so just return. 		 */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
condition|)
block|{
name|warnc
argument_list|(
name|error
argument_list|,
literal|"Unable to lookup volume device name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|qd
operator|.
name|devname
argument_list|)
expr_stmt|;
name|vfd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfd
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Unable to lock volume %s"
argument_list|,
name|qd
operator|.
name|devname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_lock_physdisk
parameter_list|(
name|struct
name|mpt_standalone_disk
modifier|*
name|disk
parameter_list|)
block|{
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|dfd
decl_stmt|,
name|error
decl_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|_PATH_DEV
argument_list|,
name|disk
operator|->
name|devname
argument_list|)
expr_stmt|;
name|dfd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfd
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Unable to lock disk %s"
argument_list|,
name|disk
operator|->
name|devname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_lookup_standalone_disk
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|mpt_standalone_disk
modifier|*
name|disks
parameter_list|,
name|int
name|ndisks
parameter_list|,
name|int
modifier|*
name|index
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|long
name|bus
decl_stmt|,
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for a raw<bus>:<id> string. */
name|bus
operator|=
name|strtol
argument_list|(
name|name
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|':'
condition|)
block|{
name|id
operator|=
name|strtol
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|bus
operator|<
literal|0
operator|||
name|bus
operator|>
literal|0xff
operator|||
name|id
operator|<
literal|0
operator|||
name|id
operator|>
literal|0xff
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndisks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|disks
index|[
name|i
index|]
operator|.
name|bus
operator|==
operator|(
name|U8
operator|)
name|bus
operator|&&
name|disks
index|[
name|i
index|]
operator|.
name|target
operator|==
operator|(
name|U8
operator|)
name|id
condition|)
block|{
operator|*
name|index
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'d'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'a'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndisks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|disks
index|[
name|i
index|]
operator|.
name|devname
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|index
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark a standalone disk as being a physical disk.  */
end_comment

begin_function
specifier|static
name|int
name|mpt_create_physdisk
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|mpt_standalone_disk
modifier|*
name|disk
parameter_list|,
name|U8
modifier|*
name|PhysDiskNum
parameter_list|)
block|{
name|CONFIG_PAGE_HEADER
name|header
decl_stmt|;
name|CONFIG_PAGE_RAID_PHYS_DISK_0
modifier|*
name|config_page
decl_stmt|;
name|int
name|error
decl_stmt|;
name|U32
name|ActionData
decl_stmt|;
name|error
operator|=
name|mpt_read_config_page_header
argument_list|(
name|fd
argument_list|,
name|MPI_CONFIG_PAGETYPE_RAID_PHYSDISK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|header
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|header
operator|.
name|PageVersion
operator|>
name|MPI_RAIDPHYSDISKPAGE0_PAGEVERSION
condition|)
block|{
name|warnx
argument_list|(
literal|"Unsupported RAID physdisk page 0 version %d"
argument_list|,
name|header
operator|.
name|PageVersion
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|config_page
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|CONFIG_PAGE_RAID_PHYS_DISK_0
argument_list|)
argument_list|)
expr_stmt|;
name|config_page
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI_CONFIG_PAGETYPE_RAID_PHYSDISK
expr_stmt|;
name|config_page
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|config_page
operator|->
name|Header
operator|.
name|PageLength
operator|=
sizeof|sizeof
argument_list|(
name|CONFIG_PAGE_RAID_PHYS_DISK_0
argument_list|)
operator|/
literal|4
expr_stmt|;
name|config_page
operator|->
name|PhysDiskIOC
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|config_page
operator|->
name|PhysDiskBus
operator|=
name|disk
operator|->
name|bus
expr_stmt|;
name|config_page
operator|->
name|PhysDiskID
operator|=
name|disk
operator|->
name|target
expr_stmt|;
comment|/* XXX: Enclosure info for PhysDiskSettings? */
name|error
operator|=
name|mpt_raid_action
argument_list|(
name|fd
argument_list|,
name|MPI_RAID_ACTION_CREATE_PHYSDISK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|config_page
argument_list|,
sizeof|sizeof
argument_list|(
name|CONFIG_PAGE_RAID_PHYS_DISK_0
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ActionData
argument_list|,
sizeof|sizeof
argument_list|(
name|ActionData
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|PhysDiskNum
operator|=
name|ActionData
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpt_delete_physdisk
parameter_list|(
name|int
name|fd
parameter_list|,
name|U8
name|PhysDiskNum
parameter_list|)
block|{
return|return
operator|(
name|mpt_raid_action
argument_list|(
name|fd
argument_list|,
name|MPI_RAID_ACTION_DELETE_PHYSDISK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PhysDiskNum
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MPT's firmware does not have a clear command.  Instead, we  * implement it by deleting each array and disk by hand.  */
end_comment

begin_function
specifier|static
name|int
name|clear_config
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|CONFIG_PAGE_IOC_2
modifier|*
name|ioc2
decl_stmt|;
name|CONFIG_PAGE_IOC_2_RAID_VOL
modifier|*
name|vol
decl_stmt|;
name|CONFIG_PAGE_IOC_3
modifier|*
name|ioc3
decl_stmt|;
name|IOC_3_PHYS_DISK
modifier|*
name|disk
decl_stmt|;
name|CONFIG_PAGE_IOC_5
modifier|*
name|ioc5
decl_stmt|;
name|IOC_5_HOT_SPARE
modifier|*
name|spare
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|error
decl_stmt|,
name|fd
decl_stmt|,
name|i
decl_stmt|;
name|fd
operator|=
name|mpt_open
argument_list|(
name|mpt_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"mpt_open"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ioc2
operator|=
name|mpt_read_ioc_page
argument_list|(
name|fd
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to fetch volume list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Lock all the volumes first. */
name|vol
operator|=
name|ioc2
operator|->
name|RaidVolume
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioc2
operator|->
name|NumActiveVolumes
condition|;
name|vol
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mpt_lock_volume
argument_list|(
name|vol
operator|->
name|VolumeBus
argument_list|,
name|vol
operator|->
name|VolumeID
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Volume %s is busy and cannot be deleted"
argument_list|,
name|mpt_volume_name
argument_list|(
name|vol
operator|->
name|VolumeBus
argument_list|,
name|vol
operator|->
name|VolumeID
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
name|printf
argument_list|(
literal|"Are you sure you wish to clear the configuration on mpt%u? [y/N] "
argument_list|,
name|mpt_unit
argument_list|)
expr_stmt|;
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'y'
operator|&&
name|ch
operator|!=
literal|'Y'
condition|)
block|{
name|printf
argument_list|(
literal|"\nAborting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Delete all the volumes. */
name|vol
operator|=
name|ioc2
operator|->
name|RaidVolume
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioc2
operator|->
name|NumActiveVolumes
condition|;
name|vol
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|error
operator|=
name|mpt_raid_action
argument_list|(
name|fd
argument_list|,
name|MPI_RAID_ACTION_DELETE_VOLUME
argument_list|,
name|vol
operator|->
name|VolumeBus
argument_list|,
name|vol
operator|->
name|VolumeID
argument_list|,
literal|0
argument_list|,
name|MPI_RAID_ACTION_ADATA_DEL_PHYS_DISKS
operator||
name|MPI_RAID_ACTION_ADATA_ZERO_LBA0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|warnc
argument_list|(
name|error
argument_list|,
literal|"Failed to delete volume %s"
argument_list|,
name|mpt_volume_name
argument_list|(
name|vol
operator|->
name|VolumeBus
argument_list|,
name|vol
operator|->
name|VolumeID
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ioc2
argument_list|)
expr_stmt|;
comment|/* Delete all the spares. */
name|ioc5
operator|=
name|mpt_read_ioc_page
argument_list|(
name|fd
argument_list|,
literal|5
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc5
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"Failed to fetch spare list"
argument_list|)
expr_stmt|;
else|else
block|{
name|spare
operator|=
name|ioc5
operator|->
name|HotSpare
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioc5
operator|->
name|NumHotSpares
condition|;
name|spare
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|mpt_delete_physdisk
argument_list|(
name|fd
argument_list|,
name|spare
operator|->
name|PhysDiskNum
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"Failed to delete physical disk %d"
argument_list|,
name|spare
operator|->
name|PhysDiskNum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioc5
argument_list|)
expr_stmt|;
block|}
comment|/* Delete any RAID physdisks that may be left. */
name|ioc3
operator|=
name|mpt_read_ioc_page
argument_list|(
name|fd
argument_list|,
literal|3
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc3
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"Failed to fetch drive list"
argument_list|)
expr_stmt|;
else|else
block|{
name|disk
operator|=
name|ioc3
operator|->
name|PhysDisk
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioc3
operator|->
name|NumPhysDisks
condition|;
name|disk
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|mpt_delete_physdisk
argument_list|(
name|fd
argument_list|,
name|disk
operator|->
name|PhysDiskNum
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"Failed to delete physical disk %d"
argument_list|,
name|disk
operator|->
name|PhysDiskNum
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ioc3
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"mpt%d: Configuration cleared\n"
argument_list|,
name|mpt_unit
argument_list|)
expr_stmt|;
name|mpt_rescan_bus
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MPT_COMMAND
argument_list|(
name|top
argument_list|,
name|clear
argument_list|,
name|clear_config
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|RT_RAID0
value|0
end_define

begin_define
define|#
directive|define
name|RT_RAID1
value|1
end_define

begin_define
define|#
directive|define
name|RT_RAID1E
value|2
end_define

begin_struct
specifier|static
struct|struct
name|raid_type_entry
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|raid_type
decl_stmt|;
block|}
name|raid_type_table
index|[]
init|=
block|{
block|{
literal|"raid0"
block|,
name|RT_RAID0
block|}
block|,
block|{
literal|"raid-0"
block|,
name|RT_RAID0
block|}
block|,
block|{
literal|"raid1"
block|,
name|RT_RAID1
block|}
block|,
block|{
literal|"raid-1"
block|,
name|RT_RAID1
block|}
block|,
block|{
literal|"mirror"
block|,
name|RT_RAID1
block|}
block|,
block|{
literal|"raid1e"
block|,
name|RT_RAID1E
block|}
block|,
block|{
literal|"raid-1e"
block|,
name|RT_RAID1E
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_struct
struct|struct
name|config_id_state
block|{
name|struct
name|mpt_standalone_disk
modifier|*
name|sdisks
decl_stmt|;
name|struct
name|mpt_drive_list
modifier|*
name|list
decl_stmt|;
name|CONFIG_PAGE_IOC_2
modifier|*
name|ioc2
decl_stmt|;
name|U8
name|target_id
decl_stmt|;
name|int
name|nsdisks
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|drive_info
block|{
name|CONFIG_PAGE_RAID_PHYS_DISK_0
modifier|*
name|info
decl_stmt|;
name|struct
name|mpt_standalone_disk
modifier|*
name|sdisk
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|volume_info
block|{
name|int
name|drive_count
decl_stmt|;
name|struct
name|drive_info
modifier|*
name|drives
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Parse a comma-separated list of drives for a volume. */
end_comment

begin_function
specifier|static
name|int
name|parse_volume
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|raid_type
parameter_list|,
name|struct
name|config_id_state
modifier|*
name|state
parameter_list|,
name|char
modifier|*
name|volume_str
parameter_list|,
name|struct
name|volume_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|drive_info
modifier|*
name|dinfo
decl_stmt|;
name|U8
name|PhysDiskNum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|cp
operator|=
name|volume_str
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|cp
operator|!=
name|NULL
condition|;
name|count
operator|++
control|)
block|{
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|','
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid drive list '%s'"
argument_list|,
name|volume_str
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
block|}
comment|/* Validate the number of drives for this volume. */
switch|switch
condition|(
name|raid_type
condition|)
block|{
case|case
name|RT_RAID0
case|:
if|if
condition|(
name|count
operator|<
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"RAID0 requires at least 2 drives in each "
literal|"array"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|RT_RAID1
case|:
if|if
condition|(
name|count
operator|!=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"RAID1 requires exactly 2 drives in each "
literal|"array"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|RT_RAID1E
case|:
if|if
condition|(
name|count
operator|<
literal|3
condition|)
block|{
name|warnx
argument_list|(
literal|"RAID1E requires at least 3 drives in each "
literal|"array"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
block|}
comment|/* Validate each drive. */
name|info
operator|->
name|drives
operator|=
name|calloc
argument_list|(
name|count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drive_info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|drive_count
operator|=
name|count
expr_stmt|;
for|for
control|(
name|dinfo
operator|=
name|info
operator|->
name|drives
init|;
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|volume_str
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|dinfo
operator|++
control|)
block|{
comment|/* If this drive is already a RAID phys just fetch the info. */
name|error
operator|=
name|mpt_lookup_drive
argument_list|(
name|state
operator|->
name|list
argument_list|,
name|cp
argument_list|,
operator|&
name|PhysDiskNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dinfo
operator|->
name|info
operator|=
name|mpt_pd_info
argument_list|(
name|fd
argument_list|,
name|PhysDiskNum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
continue|continue;
block|}
comment|/* See if it is a standalone disk. */
if|if
condition|(
name|mpt_lookup_standalone_disk
argument_list|(
name|cp
argument_list|,
name|state
operator|->
name|sdisks
argument_list|,
name|state
operator|->
name|nsdisks
argument_list|,
operator|&
name|i
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Unable to lookup drive %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dinfo
operator|->
name|sdisk
operator|=
operator|&
name|state
operator|->
name|sdisks
index|[
name|i
index|]
expr_stmt|;
comment|/* Lock the disk, we will create phys disk pages later. */
if|if
condition|(
name|mpt_lock_physdisk
argument_list|(
name|dinfo
operator|->
name|sdisk
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add RAID physdisk pages for any standalone disks that a volume is  * going to use.  */
end_comment

begin_function
specifier|static
name|int
name|add_drives
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|volume_info
modifier|*
name|info
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|struct
name|drive_info
modifier|*
name|dinfo
decl_stmt|;
name|U8
name|PhysDiskNum
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dinfo
operator|=
name|info
operator|->
name|drives
init|;
name|i
operator|<
name|info
operator|->
name|drive_count
condition|;
name|i
operator|++
operator|,
name|dinfo
operator|++
control|)
block|{
if|if
condition|(
name|dinfo
operator|->
name|info
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mpt_create_physdisk
argument_list|(
name|fd
argument_list|,
name|dinfo
operator|->
name|sdisk
argument_list|,
operator|&
name|PhysDiskNum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to create physical disk page for %s"
argument_list|,
name|dinfo
operator|->
name|sdisk
operator|->
name|devname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Added drive %s with PhysDiskNum %u\n"
argument_list|,
name|dinfo
operator|->
name|sdisk
operator|->
name|devname
argument_list|,
name|PhysDiskNum
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|info
operator|=
name|mpt_pd_info
argument_list|(
name|fd
argument_list|,
name|PhysDiskNum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the next free target ID assuming that 'target_id' is the last  * one used.  'target_id' should be 0xff for the initial test.  */
end_comment

begin_function
specifier|static
name|U8
name|find_next_volume
parameter_list|(
name|struct
name|config_id_state
modifier|*
name|state
parameter_list|)
block|{
name|CONFIG_PAGE_IOC_2_RAID_VOL
modifier|*
name|vol
decl_stmt|;
name|int
name|i
decl_stmt|;
name|restart
label|:
comment|/* Assume the current one is used. */
name|state
operator|->
name|target_id
operator|++
expr_stmt|;
comment|/* Search drives first. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|nsdisks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|state
operator|->
name|sdisks
index|[
name|i
index|]
operator|.
name|target
operator|==
name|state
operator|->
name|target_id
condition|)
goto|goto
name|restart
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|list
operator|->
name|ndrives
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|state
operator|->
name|list
operator|->
name|drives
index|[
name|i
index|]
operator|->
name|PhysDiskID
operator|==
name|state
operator|->
name|target_id
condition|)
goto|goto
name|restart
goto|;
comment|/* Search volumes second. */
name|vol
operator|=
name|state
operator|->
name|ioc2
operator|->
name|RaidVolume
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|state
operator|->
name|ioc2
operator|->
name|NumActiveVolumes
condition|;
name|vol
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|vol
operator|->
name|VolumeID
operator|==
name|state
operator|->
name|target_id
condition|)
goto|goto
name|restart
goto|;
return|return
operator|(
name|state
operator|->
name|target_id
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a volume and populate it with drives. */
end_comment

begin_function
specifier|static
name|CONFIG_PAGE_RAID_VOL_0
modifier|*
name|build_volume
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|volume_info
modifier|*
name|info
parameter_list|,
name|int
name|raid_type
parameter_list|,
name|long
name|stripe_size
parameter_list|,
name|struct
name|config_id_state
modifier|*
name|state
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|CONFIG_PAGE_HEADER
name|header
decl_stmt|;
name|CONFIG_PAGE_RAID_VOL_0
modifier|*
name|vol
decl_stmt|;
name|RAID_VOL0_PHYS_DISK
modifier|*
name|rdisk
decl_stmt|;
name|struct
name|drive_info
modifier|*
name|dinfo
decl_stmt|;
name|U32
name|MinLBA
decl_stmt|;
name|uint64_t
name|MaxLBA
decl_stmt|;
name|size_t
name|page_size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|mpt_read_config_page_header
argument_list|(
name|fd
argument_list|,
name|MPI_CONFIG_PAGETYPE_RAID_VOLUME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|header
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|header
operator|.
name|PageVersion
operator|>
name|MPI_RAIDVOLPAGE0_PAGEVERSION
condition|)
block|{
name|warnx
argument_list|(
literal|"Unsupported RAID volume page 0 version %d"
argument_list|,
name|header
operator|.
name|PageVersion
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EOPNOTSUPP
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|page_size
operator|=
sizeof|sizeof
argument_list|(
name|CONFIG_PAGE_RAID_VOL_0
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|RAID_VOL0_PHYS_DISK
argument_list|)
operator|*
operator|(
name|info
operator|->
name|drive_count
operator|-
literal|1
operator|)
expr_stmt|;
name|vol
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Header */
name|vol
operator|->
name|Header
operator|.
name|PageType
operator|=
name|MPI_CONFIG_PAGETYPE_RAID_VOLUME
expr_stmt|;
name|vol
operator|->
name|Header
operator|.
name|PageNumber
operator|=
literal|0
expr_stmt|;
name|vol
operator|->
name|Header
operator|.
name|PageLength
operator|=
name|page_size
operator|/
literal|4
expr_stmt|;
comment|/* Properties */
name|vol
operator|->
name|VolumeID
operator|=
name|find_next_volume
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|vol
operator|->
name|VolumeBus
operator|=
literal|0
expr_stmt|;
name|vol
operator|->
name|VolumeIOC
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|vol
operator|->
name|VolumeStatus
operator|.
name|Flags
operator|=
name|MPI_RAIDVOL0_STATUS_FLAG_ENABLED
expr_stmt|;
name|vol
operator|->
name|VolumeStatus
operator|.
name|State
operator|=
name|MPI_RAIDVOL0_STATUS_STATE_OPTIMAL
expr_stmt|;
name|vol
operator|->
name|VolumeSettings
operator|.
name|Settings
operator|=
name|MPI_RAIDVOL0_SETTING_USE_DEFAULTS
expr_stmt|;
name|vol
operator|->
name|VolumeSettings
operator|.
name|HotSparePool
operator|=
name|MPI_RAID_HOT_SPARE_POOL_0
expr_stmt|;
name|vol
operator|->
name|NumPhysDisks
operator|=
name|info
operator|->
name|drive_count
expr_stmt|;
comment|/* Find the smallest drive. */
name|MinLBA
operator|=
name|info
operator|->
name|drives
index|[
literal|0
index|]
operator|.
name|info
operator|->
name|MaxLBA
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|info
operator|->
name|drive_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|info
operator|->
name|drives
index|[
name|i
index|]
operator|.
name|info
operator|->
name|MaxLBA
operator|<
name|MinLBA
condition|)
name|MinLBA
operator|=
name|info
operator|->
name|drives
index|[
name|i
index|]
operator|.
name|info
operator|->
name|MaxLBA
expr_stmt|;
comment|/* 	 * Now chop off 512MB at the end to leave room for the 	 * metadata.  The controller might only use 64MB, but we just 	 * chop off the max to be simple. 	 */
name|MinLBA
operator|-=
operator|(
literal|512
operator|*
literal|1024
operator|*
literal|1024
operator|)
operator|/
literal|512
expr_stmt|;
switch|switch
condition|(
name|raid_type
condition|)
block|{
case|case
name|RT_RAID0
case|:
name|vol
operator|->
name|VolumeType
operator|=
name|MPI_RAID_VOL_TYPE_IS
expr_stmt|;
name|vol
operator|->
name|StripeSize
operator|=
name|stripe_size
operator|/
literal|512
expr_stmt|;
name|MaxLBA
operator|=
name|MinLBA
operator|*
name|info
operator|->
name|drive_count
expr_stmt|;
break|break;
case|case
name|RT_RAID1
case|:
name|vol
operator|->
name|VolumeType
operator|=
name|MPI_RAID_VOL_TYPE_IM
expr_stmt|;
name|MaxLBA
operator|=
name|MinLBA
operator|*
operator|(
name|info
operator|->
name|drive_count
operator|/
literal|2
operator|)
expr_stmt|;
break|break;
case|case
name|RT_RAID1E
case|:
name|vol
operator|->
name|VolumeType
operator|=
name|MPI_RAID_VOL_TYPE_IME
expr_stmt|;
name|vol
operator|->
name|StripeSize
operator|=
name|stripe_size
operator|/
literal|512
expr_stmt|;
name|MaxLBA
operator|=
name|MinLBA
operator|*
name|info
operator|->
name|drive_count
operator|/
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* Pacify gcc. */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * If the controller doesn't support 64-bit addressing and the 	 * new volume is larger than 2^32 blocks, warn the user and 	 * truncate the volume. 	 */
if|if
condition|(
name|MaxLBA
operator|>>
literal|32
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|state
operator|->
name|ioc2
operator|->
name|CapabilitiesFlags
operator|&
name|MPI_IOCPAGE2_CAP_FLAGS_RAID_64_BIT_ADDRESSING
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Controller does not support volumes> 2TB, truncating volume."
argument_list|)
expr_stmt|;
name|MaxLBA
operator|=
literal|0xffffffff
expr_stmt|;
block|}
name|vol
operator|->
name|MaxLBA
operator|=
name|MaxLBA
expr_stmt|;
name|vol
operator|->
name|MaxLBAHigh
operator|=
name|MaxLBA
operator|>>
literal|32
expr_stmt|;
comment|/* Populate drives. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dinfo
operator|=
name|info
operator|->
name|drives
operator|,
name|rdisk
operator|=
name|vol
operator|->
name|PhysDisk
init|;
name|i
operator|<
name|info
operator|->
name|drive_count
condition|;
name|i
operator|++
operator|,
name|dinfo
operator|++
operator|,
name|rdisk
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Adding drive %u (%u:%u) to volume %u:%u\n"
argument_list|,
name|dinfo
operator|->
name|info
operator|->
name|PhysDiskNum
argument_list|,
name|dinfo
operator|->
name|info
operator|->
name|PhysDiskBus
argument_list|,
name|dinfo
operator|->
name|info
operator|->
name|PhysDiskID
argument_list|,
name|vol
operator|->
name|VolumeBus
argument_list|,
name|vol
operator|->
name|VolumeID
argument_list|)
expr_stmt|;
if|if
condition|(
name|raid_type
operator|==
name|RT_RAID1
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|rdisk
operator|->
name|PhysDiskMap
operator|=
name|MPI_RAIDVOL0_PHYSDISK_PRIMARY
expr_stmt|;
else|else
name|rdisk
operator|->
name|PhysDiskMap
operator|=
name|MPI_RAIDVOL0_PHYSDISK_SECONDARY
expr_stmt|;
block|}
else|else
name|rdisk
operator|->
name|PhysDiskMap
operator|=
name|i
expr_stmt|;
name|rdisk
operator|->
name|PhysDiskNum
operator|=
name|dinfo
operator|->
name|info
operator|->
name|PhysDiskNum
expr_stmt|;
block|}
return|return
operator|(
name|vol
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_volume
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|CONFIG_PAGE_RAID_VOL_0
modifier|*
name|vol
decl_stmt|;
name|struct
name|config_id_state
name|state
decl_stmt|;
name|struct
name|volume_info
modifier|*
name|info
decl_stmt|;
name|long
name|stripe_size
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|error
decl_stmt|,
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|quick
decl_stmt|,
name|raid_type
decl_stmt|,
name|verbose
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|dump
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ac
operator|<
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"create: volume type required"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fd
operator|=
name|mpt_open
argument_list|(
name|mpt_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"mpt_open"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Lookup the RAID type first. */
name|raid_type
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|raid_type_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|raid_type_table
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|raid_type
operator|=
name|raid_type_table
index|[
name|i
index|]
operator|.
name|raid_type
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|raid_type
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"Unknown or unsupported volume type %s"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Parse any options. */
name|optind
operator|=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dump
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|quick
operator|=
literal|0
expr_stmt|;
name|verbose
operator|=
literal|0
expr_stmt|;
name|stripe_size
operator|=
literal|64
operator|*
literal|1024
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"dqs:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'d'
case|:
name|dump
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'q'
case|:
name|quick
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|stripe_size
operator|=
name|dehumanize
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stripe_size
operator|<
literal|512
operator|)
operator|||
operator|(
operator|!
name|powerof2
argument_list|(
name|stripe_size
argument_list|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid stripe size %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
comment|/* Fetch existing config data. */
name|state
operator|.
name|ioc2
operator|=
name|mpt_read_ioc_page
argument_list|(
name|fd
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|ioc2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to read volume list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|state
operator|.
name|list
operator|=
name|mpt_pd_list
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|error
operator|=
name|mpt_fetch_disks
argument_list|(
name|fd
argument_list|,
operator|&
name|state
operator|.
name|nsdisks
argument_list|,
operator|&
name|state
operator|.
name|sdisks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|warn
argument_list|(
literal|"Failed to fetch standalone disk list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|state
operator|.
name|target_id
operator|=
literal|0xff
expr_stmt|;
comment|/* Parse the drive list. */
if|if
condition|(
name|ac
operator|!=
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"Exactly one drive list is required"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|info
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|error
operator|=
name|parse_volume
argument_list|(
name|fd
argument_list|,
name|raid_type
argument_list|,
operator|&
name|state
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Create RAID physdisk pages for standalone disks. */
name|error
operator|=
name|add_drives
argument_list|(
name|fd
argument_list|,
name|info
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Build the volume. */
name|vol
operator|=
name|build_volume
argument_list|(
name|fd
argument_list|,
name|info
argument_list|,
name|raid_type
argument_list|,
name|stripe_size
argument_list|,
operator|&
name|state
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dump
condition|)
block|{
name|dump_config
argument_list|(
name|vol
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
endif|#
directive|endif
comment|/* Send the new volume to the controller. */
name|error
operator|=
name|mpt_raid_action
argument_list|(
name|fd
argument_list|,
name|MPI_RAID_ACTION_CREATE_VOLUME
argument_list|,
name|vol
operator|->
name|VolumeBus
argument_list|,
name|vol
operator|->
name|VolumeID
argument_list|,
literal|0
argument_list|,
name|quick
condition|?
name|MPI_RAID_ACTION_ADATA_DO_NOT_SYNC
else|:
literal|0
argument_list|,
name|vol
argument_list|,
name|vol
operator|->
name|Header
operator|.
name|PageLength
operator|*
literal|4
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to add volume"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|skip
label|:
endif|#
directive|endif
name|mpt_rescan_bus
argument_list|(
name|vol
operator|->
name|VolumeBus
argument_list|,
name|vol
operator|->
name|VolumeID
argument_list|)
expr_stmt|;
comment|/* Clean up. */
name|free
argument_list|(
name|vol
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|sdisks
argument_list|)
expr_stmt|;
name|mpt_free_pd_list
argument_list|(
name|state
operator|.
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|.
name|ioc2
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MPT_COMMAND
argument_list|(
name|top
argument_list|,
name|create
argument_list|,
name|create_volume
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|delete_volume
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|U8
name|VolumeBus
decl_stmt|,
name|VolumeID
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"delete: volume required"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fd
operator|=
name|mpt_open
argument_list|(
name|mpt_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"mpt_open"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|mpt_lookup_volume
argument_list|(
name|fd
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
operator|&
name|VolumeBus
argument_list|,
operator|&
name|VolumeID
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|warnc
argument_list|(
name|error
argument_list|,
literal|"Invalid volume %s"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|mpt_lock_volume
argument_list|(
name|VolumeBus
argument_list|,
name|VolumeID
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|error
operator|=
name|mpt_raid_action
argument_list|(
name|fd
argument_list|,
name|MPI_RAID_ACTION_DELETE_VOLUME
argument_list|,
name|VolumeBus
argument_list|,
name|VolumeID
argument_list|,
literal|0
argument_list|,
name|MPI_RAID_ACTION_ADATA_DEL_PHYS_DISKS
operator||
name|MPI_RAID_ACTION_ADATA_ZERO_LBA0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|warnc
argument_list|(
name|error
argument_list|,
literal|"Failed to delete volume"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mpt_rescan_bus
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MPT_COMMAND
argument_list|(
name|top
argument_list|,
name|delete
argument_list|,
name|delete_volume
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|find_volume_spare_pool
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|pool
parameter_list|)
block|{
name|CONFIG_PAGE_RAID_VOL_0
modifier|*
name|info
decl_stmt|;
name|CONFIG_PAGE_IOC_2
modifier|*
name|ioc2
decl_stmt|;
name|CONFIG_PAGE_IOC_2_RAID_VOL
modifier|*
name|vol
decl_stmt|;
name|U8
name|VolumeBus
decl_stmt|,
name|VolumeID
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|new_pool
decl_stmt|,
name|pool_count
index|[
literal|7
index|]
decl_stmt|;
name|error
operator|=
name|mpt_lookup_volume
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
operator|&
name|VolumeBus
argument_list|,
operator|&
name|VolumeID
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|warnc
argument_list|(
name|error
argument_list|,
literal|"Invalid volume %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|info
operator|=
name|mpt_vol_info
argument_list|(
name|fd
argument_list|,
name|VolumeBus
argument_list|,
name|VolumeID
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* 	 * Check for an existing pool other than pool 0 (used for 	 * global spares). 	 */
if|if
condition|(
operator|(
name|info
operator|->
name|VolumeSettings
operator|.
name|HotSparePool
operator|&
operator|~
name|MPI_RAID_HOT_SPARE_POOL_0
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|pool
operator|=
literal|1
operator|<<
operator|(
name|ffs
argument_list|(
name|info
operator|->
name|VolumeSettings
operator|.
name|HotSparePool
operator|&
operator|~
name|MPI_RAID_HOT_SPARE_POOL_0
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
comment|/* 	 * Try to find a free pool.  First, figure out which pools are 	 * in use. 	 */
name|ioc2
operator|=
name|mpt_read_ioc_page
argument_list|(
name|fd
argument_list|,
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioc2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to fetch volume list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bzero
argument_list|(
name|pool_count
argument_list|,
sizeof|sizeof
argument_list|(
name|pool_count
argument_list|)
argument_list|)
expr_stmt|;
name|vol
operator|=
name|ioc2
operator|->
name|RaidVolume
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ioc2
operator|->
name|NumActiveVolumes
condition|;
name|vol
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|info
operator|=
name|mpt_vol_info
argument_list|(
name|fd
argument_list|,
name|vol
operator|->
name|VolumeBus
argument_list|,
name|vol
operator|->
name|VolumeID
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|7
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|info
operator|->
name|VolumeSettings
operator|.
name|HotSparePool
operator|&
operator|(
literal|1
operator|<<
operator|(
name|j
operator|+
literal|1
operator|)
operator|)
condition|)
name|pool_count
index|[
name|j
index|]
operator|++
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ioc2
argument_list|)
expr_stmt|;
comment|/* Find the pool with the lowest use count. */
name|new_pool
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pool_count
index|[
name|i
index|]
operator|<
name|pool_count
index|[
name|new_pool
index|]
condition|)
name|new_pool
operator|=
name|i
expr_stmt|;
name|new_pool
operator|++
expr_stmt|;
comment|/* Add this pool to the volume. */
name|info
operator|=
name|mpt_vol_info
argument_list|(
name|fd
argument_list|,
name|VolumeBus
argument_list|,
name|VolumeID
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|info
operator|->
name|VolumeSettings
operator|.
name|HotSparePool
operator||=
operator|(
literal|1
operator|<<
name|new_pool
operator|)
expr_stmt|;
name|error
operator|=
name|mpt_raid_action
argument_list|(
name|fd
argument_list|,
name|MPI_RAID_ACTION_CHANGE_VOLUME_SETTINGS
argument_list|,
name|VolumeBus
argument_list|,
name|VolumeID
argument_list|,
literal|0
argument_list|,
operator|*
operator|(
name|U32
operator|*
operator|)
operator|&
name|info
operator|->
name|VolumeSettings
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|warnx
argument_list|(
literal|"Failed to add spare pool %d to %s"
argument_list|,
name|new_pool
argument_list|,
name|mpt_volume_name
argument_list|(
name|VolumeBus
argument_list|,
name|VolumeID
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
operator|*
name|pool
operator|=
operator|(
literal|1
operator|<<
name|new_pool
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_spare
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|CONFIG_PAGE_RAID_PHYS_DISK_0
modifier|*
name|info
decl_stmt|;
name|struct
name|mpt_standalone_disk
modifier|*
name|sdisks
decl_stmt|;
name|struct
name|mpt_drive_list
modifier|*
name|list
decl_stmt|;
name|U8
name|PhysDiskNum
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|nsdisks
decl_stmt|,
name|pool
decl_stmt|;
if|if
condition|(
name|ac
operator|<
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"add spare: drive required"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ac
operator|>
literal|3
condition|)
block|{
name|warnx
argument_list|(
literal|"add spare: extra arguments"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fd
operator|=
name|mpt_open
argument_list|(
name|mpt_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"mpt_open"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|ac
operator|==
literal|3
condition|)
block|{
name|error
operator|=
name|find_volume_spare_pool
argument_list|(
name|fd
argument_list|,
name|av
index|[
literal|2
index|]
argument_list|,
operator|&
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
name|pool
operator|=
name|MPI_RAID_HOT_SPARE_POOL_0
expr_stmt|;
name|list
operator|=
name|mpt_pd_list
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|error
operator|=
name|mpt_lookup_drive
argument_list|(
name|list
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
operator|&
name|PhysDiskNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|mpt_fetch_disks
argument_list|(
name|fd
argument_list|,
operator|&
name|nsdisks
argument_list|,
operator|&
name|sdisks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Failed to fetch standalone disk list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|mpt_lookup_standalone_disk
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
name|sdisks
argument_list|,
name|nsdisks
argument_list|,
operator|&
name|i
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Unable to lookup drive %s"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|mpt_lock_physdisk
argument_list|(
operator|&
name|sdisks
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|mpt_create_physdisk
argument_list|(
name|fd
argument_list|,
operator|&
name|sdisks
index|[
name|i
index|]
argument_list|,
operator|&
name|PhysDiskNum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to create physical disk page"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|free
argument_list|(
name|sdisks
argument_list|)
expr_stmt|;
block|}
name|mpt_free_pd_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|info
operator|=
name|mpt_pd_info
argument_list|(
name|fd
argument_list|,
name|PhysDiskNum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to fetch drive info"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|info
operator|->
name|PhysDiskSettings
operator|.
name|HotSparePool
operator|=
name|pool
expr_stmt|;
name|error
operator|=
name|mpt_raid_action
argument_list|(
name|fd
argument_list|,
name|MPI_RAID_ACTION_CHANGE_PHYSDISK_SETTINGS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PhysDiskNum
argument_list|,
operator|*
operator|(
name|U32
operator|*
operator|)
operator|&
name|info
operator|->
name|PhysDiskSettings
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|warnc
argument_list|(
name|error
argument_list|,
literal|"Failed to assign spare"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MPT_COMMAND
argument_list|(
name|top
argument_list|,
name|add
argument_list|,
name|add_spare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|remove_spare
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|CONFIG_PAGE_RAID_PHYS_DISK_0
modifier|*
name|info
decl_stmt|;
name|struct
name|mpt_drive_list
modifier|*
name|list
decl_stmt|;
name|U8
name|PhysDiskNum
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"remove spare: drive required"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fd
operator|=
name|mpt_open
argument_list|(
name|mpt_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"mpt_open"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|list
operator|=
name|mpt_pd_list
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|error
operator|=
name|mpt_lookup_drive
argument_list|(
name|list
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
operator|&
name|PhysDiskNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|warn
argument_list|(
literal|"Failed to find drive %s"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mpt_free_pd_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|info
operator|=
name|mpt_pd_info
argument_list|(
name|fd
argument_list|,
name|PhysDiskNum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to fetch drive info"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|info
operator|->
name|PhysDiskSettings
operator|.
name|HotSparePool
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Drive %u is not a hot spare"
argument_list|,
name|PhysDiskNum
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|mpt_delete_physdisk
argument_list|(
name|fd
argument_list|,
name|PhysDiskNum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to delete physical disk page"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mpt_rescan_bus
argument_list|(
name|info
operator|->
name|PhysDiskBus
argument_list|,
name|info
operator|->
name|PhysDiskID
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MPT_COMMAND
argument_list|(
name|top
argument_list|,
name|remove
argument_list|,
name|remove_spare
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_expr_stmt
name|MPT_TABLE
argument_list|(
name|top
argument_list|,
name|pd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|pd_create
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|mpt_standalone_disk
modifier|*
name|disks
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|ndisks
decl_stmt|;
name|U8
name|PhysDiskNum
decl_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"pd create: drive required"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fd
operator|=
name|mpt_open
argument_list|(
name|mpt_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"mpt_open"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|mpt_fetch_disks
argument_list|(
name|fd
argument_list|,
operator|&
name|ndisks
argument_list|,
operator|&
name|disks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Failed to fetch standalone disk list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|mpt_lookup_standalone_disk
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
name|disks
argument_list|,
name|ndisks
argument_list|,
operator|&
name|i
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Unable to lookup drive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|mpt_lock_physdisk
argument_list|(
operator|&
name|disks
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|mpt_create_physdisk
argument_list|(
name|fd
argument_list|,
operator|&
name|disks
index|[
name|i
index|]
argument_list|,
operator|&
name|PhysDiskNum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to create physical disk page"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|free
argument_list|(
name|disks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Added drive %s with PhysDiskNum %u\n"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|PhysDiskNum
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MPT_COMMAND
argument_list|(
name|pd
argument_list|,
name|create
argument_list|,
name|pd_create
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|pd_delete
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|CONFIG_PAGE_RAID_PHYS_DISK_0
modifier|*
name|info
decl_stmt|;
name|struct
name|mpt_drive_list
modifier|*
name|list
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|;
name|U8
name|PhysDiskNum
decl_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"pd delete: drive required"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fd
operator|=
name|mpt_open
argument_list|(
name|mpt_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"mpt_open"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|list
operator|=
name|mpt_pd_list
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
name|errno
operator|)
return|;
if|if
condition|(
name|mpt_lookup_drive
argument_list|(
name|list
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
operator|&
name|PhysDiskNum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to find drive %s"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mpt_free_pd_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|info
operator|=
name|mpt_pd_info
argument_list|(
name|fd
argument_list|,
name|PhysDiskNum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to fetch drive info"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|mpt_delete_physdisk
argument_list|(
name|fd
argument_list|,
name|PhysDiskNum
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to delete physical disk page"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mpt_rescan_bus
argument_list|(
name|info
operator|->
name|PhysDiskBus
argument_list|,
name|info
operator|->
name|PhysDiskID
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MPT_COMMAND
argument_list|(
name|pd
argument_list|,
name|delete
argument_list|,
name|pd_delete
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Display raw data about a volume config. */
end_comment

begin_function
specifier|static
name|void
name|dump_config
parameter_list|(
name|CONFIG_PAGE_RAID_VOL_0
modifier|*
name|vol
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"Volume Configuration (Debug):\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Page Header: Type 0x%02x Number 0x%02x Length 0x%02x(%u) Version 0x%02x\n"
argument_list|,
name|vol
operator|->
name|Header
operator|.
name|PageType
argument_list|,
name|vol
operator|->
name|Header
operator|.
name|PageNumber
argument_list|,
name|vol
operator|->
name|Header
operator|.
name|PageLength
argument_list|,
name|vol
operator|->
name|Header
operator|.
name|PageLength
operator|*
literal|4
argument_list|,
name|vol
operator|->
name|Header
operator|.
name|PageVersion
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     Address: %d:%d IOC %d\n"
argument_list|,
name|vol
operator|->
name|VolumeBus
argument_list|,
name|vol
operator|->
name|VolumeID
argument_list|,
name|vol
operator|->
name|VolumeIOC
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        Type: %d (%s)\n"
argument_list|,
name|vol
operator|->
name|VolumeType
argument_list|,
name|mpt_raid_level
argument_list|(
name|vol
operator|->
name|VolumeType
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Status: %s (Flags 0x%02x)\n"
argument_list|,
name|mpt_volstate
argument_list|(
name|vol
operator|->
name|VolumeStatus
operator|.
name|State
argument_list|)
argument_list|,
name|vol
operator|->
name|VolumeStatus
operator|.
name|Flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    Settings: 0x%04x (Spare Pools 0x%02x)\n"
argument_list|,
name|vol
operator|->
name|VolumeSettings
operator|.
name|Settings
argument_list|,
name|vol
operator|->
name|VolumeSettings
operator|.
name|HotSparePool
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      MaxLBA: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|vol
operator|->
name|MaxLBAHigh
operator|<<
literal|32
operator||
name|vol
operator|->
name|MaxLBA
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Stripe Size: %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|vol
operator|->
name|StripeSize
operator|*
literal|512
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d Disks:\n"
argument_list|,
name|vol
operator|->
name|NumPhysDisks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|NumPhysDisks
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"    Disk %d: Num 0x%02x Map 0x%02x\n"
argument_list|,
name|i
argument_list|,
name|vol
operator|->
name|PhysDisk
index|[
name|i
index|]
operator|.
name|PhysDiskNum
argument_list|,
name|vol
operator|->
name|PhysDisk
index|[
name|i
index|]
operator|.
name|PhysDiskMap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_config
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|CONFIG_PAGE_RAID_VOL_0
modifier|*
name|vol
decl_stmt|;
name|U8
name|VolumeBus
decl_stmt|,
name|VolumeID
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
name|ac
operator|!=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"debug: volume required"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|fd
operator|=
name|mpt_open
argument_list|(
name|mpt_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"mpt_open"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|mpt_lookup_volume
argument_list|(
name|fd
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
operator|&
name|VolumeBus
argument_list|,
operator|&
name|VolumeID
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|warnc
argument_list|(
name|error
argument_list|,
literal|"Invalid volume: %s"
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vol
operator|=
name|mpt_vol_info
argument_list|(
name|fd
argument_list|,
name|VolumeBus
argument_list|,
name|VolumeID
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"Failed to get volume info"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dump_config
argument_list|(
name|vol
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vol
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MPT_COMMAND
argument_list|(
name|top
argument_list|,
name|debug
argument_list|,
name|debug_config
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

