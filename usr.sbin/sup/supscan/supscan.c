begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software_Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * supscan -- SUP Scan File Builder  *  * Usage: supscan [ -v ] collection [ basedir ]  *	  supscan [ -v ] -f dirfile  *	  supscan [ -v ] -s  *	-f	"file" -- use dirfile instead of system coll.dir  *	-s	"system" -- perform scan for system supfile  *	-v	"verbose" -- print messages as you go  *	collection	-- name of the desired collection if not -s  *	basedir		-- name of the base directory, if not  *			   the default or recorded in coll.dir  *	dirfile		-- name of replacement for system coll.dir.  *  **********************************************************************  * HISTORY  * $Log: supscan.c,v $  * Revision 1.1.1.1  1993/08/21  00:46:35  jkh  * Current sup with compression support.  *  * Revision 1.1.1.1  1993/05/21  14:52:19  cgd  * initial import of CMU's SUP to NetBSD  *  * Revision 1.14  92/08/11  12:08:30  mrt  * 	Picked up Brad's deliniting and variable argument changes  * 	[92/08/10            mrt]  *   * Revision 1.13  92/02/08  18:04:44  dlc  * 	Once again revised localhost().  Do not use gethostbyname() at  * 	all, but assume that the host names in the coll.host file are at  * 	least a prefix of the fully qualified name.  Modcoll (and related  * 	scripts) will maintain this fact.  * 	[92/02/08            dlc]  *   * Revision 1.12  91/08/17  23:35:31  dlc  * 	Changes to localhost() function:  * 		- Use host name in kernel for local host name; assume it is  * 		  fully qualified.  * 		- If gethostbyname() of host to see if we are the repository  * 		  fails, with TRY_AGAIN or NO_RECOVERY, then use the "host"  * 		  parameter.  Print a diagnostic in this case.  * 	[91/08/17            dlc]  *   * Revision 1.11  90/04/04  10:53:01  dlc  * 	Changed localhost to retry getting the local host name 4 times with  * 	30 second sleep intervals before aborting; after 4 tries, things are  * 	probably too messed up for the supscan to do anything useful  * 	[90/04/04            dlc]  *   * Revision 1.10  89/08/03  19:49:33  mja  * 	Updated to use v*printf() in place of _doprnt().  * 	[89/04/19            mja]  *   * Revision 1.9  89/06/18  14:41:37  gm0w  * 	Fixed up some notify messages of errors to use "SUP:" prefix.  * 	[89/06/18            gm0w]  *   * 13-May-88  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Changed goaway to longjmp back to top-level to scan next  *	collection. [V7.6]  *  * 19-Feb-88  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added -f<filename> switch to scan all (or part) of the  *	collections in a file of collection/base-directory pairs.  *	[V7.5]  *  * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Removed nameserver support (which means to use a new  *	datafile).  *  * 09-Sep-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Use case-insensitive hostname comparison.  *  * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code for "release" support. [V6.4]  *  * 05-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Changed collection setup errors to be non-fatal. [V5.3]  *  * 29-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Moved most of the scanning code to scan.c. [V4.2]  *  * 02-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added "-s" option.  *  * 22-Sep-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Merged 4.1 and 4.2 versions together.  *  * 04-Jun-85  Steven Shafer (sas) at Carnegie-Mellon University  *	Created for 4.2 BSD.  *  **********************************************************************  */
end_comment

begin_include
include|#
directive|include
file|<libc.h>
end_include

begin_include
include|#
directive|include
file|<c.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"sup.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_comment
comment|/*VARARGS1*/
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|quit
parameter_list|(
name|status
parameter_list|)
block|{}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_define
define|#
directive|define
name|PGMVERSION
value|6
end_define

begin_comment
comment|/*******************************************  ***    D A T A   S T R U C T U R E S    ***  *******************************************/
end_comment

begin_struct
struct|struct
name|collstruct
block|{
comment|/* one per collection to be upgraded */
name|char
modifier|*
name|Cname
decl_stmt|;
comment|/* collection name */
name|char
modifier|*
name|Cbase
decl_stmt|;
comment|/* local base directory */
name|char
modifier|*
name|Cprefix
decl_stmt|;
comment|/* local collection pathname prefix */
name|struct
name|collstruct
modifier|*
name|Cnext
decl_stmt|;
comment|/* next collection */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|collstruct
name|COLLECTION
typedef|;
end_typedef

begin_comment
comment|/*********************************************  ***    G L O B A L   V A R I A B L E S    ***  *********************************************/
end_comment

begin_decl_stmt
name|int
name|trace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -v flag */
end_comment

begin_decl_stmt
name|COLLECTION
modifier|*
name|firstC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* collection list pointer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|collname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* collection name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|basedir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base directory name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* collection pathname prefix */
end_comment

begin_decl_stmt
name|long
name|lasttime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time of last upgrade */
end_comment

begin_decl_stmt
name|long
name|scantime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time of this scan */
end_comment

begin_decl_stmt
name|int
name|newonly
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new files only */
end_comment

begin_decl_stmt
name|jmp_buf
name|sjbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* jump location for errors */
end_comment

begin_decl_stmt
name|TREELIST
modifier|*
name|listTL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all files specified by<coll>.list */
end_comment

begin_decl_stmt
name|TREE
modifier|*
name|listT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* final list of files in collection */
end_comment

begin_decl_stmt
name|TREE
modifier|*
name|refuseT
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of all files specified by<coll>.list */
end_comment

begin_function_decl
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*************************************  ***    M A I N   R O U T I N E    ***  *************************************/
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|COLLECTION
modifier|*
name|c
decl_stmt|;
name|init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* process arguments */
for|for
control|(
name|c
operator|=
name|firstC
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|Cnext
control|)
block|{
name|collname
operator|=
name|c
operator|->
name|Cname
expr_stmt|;
name|basedir
operator|=
name|c
operator|->
name|Cbase
expr_stmt|;
name|prefix
operator|=
name|c
operator|->
name|Cprefix
expr_stmt|;
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
name|scantime
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SUP Scan for %s starting at %s"
argument_list|,
name|collname
argument_list|,
name|ctime
argument_list|(
operator|&
name|scantime
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
condition|)
block|{
name|makescanlists
argument_list|()
expr_stmt|;
comment|/* record names in scan files */
name|scantime
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SUP Scan for %s completed at %s"
argument_list|,
name|collname
argument_list|,
name|ctime
argument_list|(
operator|&
name|scantime
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"SUP: Scan for %s aborted at %s"
argument_list|,
name|collname
argument_list|,
name|ctime
argument_list|(
operator|&
name|scantime
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|=
name|firstC
condition|)
block|{
name|firstC
operator|=
name|firstC
operator|->
name|Cnext
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|Cname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|c
operator|->
name|Cbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|Cprefix
condition|)
name|free
argument_list|(
name|c
operator|->
name|Cprefix
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************  ***    I N I T I A L I Z A T I O N    ***  *****************************************/
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: supscan [ -v ] collection [ basedir ]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       supscan [ -v ] -f dirfile\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"       supscan [ -v ] -s\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|init
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
name|fbuf
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|COLLECTION
modifier|*
modifier|*
name|c
decl_stmt|,
modifier|*
name|getcoll
argument_list|()
decl_stmt|;
name|int
name|fflag
decl_stmt|,
name|sflag
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|trace
operator|=
name|FALSE
expr_stmt|;
name|fflag
operator|=
name|FALSE
expr_stmt|;
name|sflag
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'f'
case|:
name|fflag
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
operator|--
name|argc
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|filename
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|trace
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sflag
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"supscan: Invalid flag %s ignored\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
operator|--
name|argc
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fflag
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fbuf
argument_list|,
name|FILEDIRS
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
name|filename
operator|=
name|fbuf
expr_stmt|;
block|}
if|if
condition|(
name|sflag
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|firstC
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
operator|&
name|firstC
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEHOSTS
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"supscan: Unable to open %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|collname
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t="
argument_list|)
expr_stmt|;
name|p
operator|=
name|skipover
argument_list|(
name|p
argument_list|,
literal|" \t="
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|localhost
argument_list|(
name|p
argument_list|)
condition|)
continue|continue;
operator|*
name|c
operator|=
name|getcoll
argument_list|(
name|filename
argument_list|,
name|salloc
argument_list|(
name|collname
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c
condition|)
name|c
operator|=
operator|&
operator|(
operator|(
operator|*
name|c
operator|)
operator|->
name|Cnext
operator|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
operator|&&
name|fflag
condition|)
block|{
name|firstC
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
operator|&
name|firstC
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"supscan: Unable to open %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t="
argument_list|)
expr_stmt|;
name|p
operator|=
name|skipover
argument_list|(
name|p
argument_list|,
literal|" \t="
argument_list|)
expr_stmt|;
operator|*
name|c
operator|=
name|getcoll
argument_list|(
name|filename
argument_list|,
name|salloc
argument_list|(
name|q
argument_list|)
argument_list|,
name|salloc
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|c
condition|)
name|c
operator|=
operator|&
operator|(
operator|(
operator|*
name|c
operator|)
operator|->
name|Cnext
operator|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
operator|||
name|argc
operator|>
literal|3
condition|)
name|usage
argument_list|()
expr_stmt|;
name|firstC
operator|=
name|getcoll
argument_list|(
name|filename
argument_list|,
name|salloc
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|argc
operator|>
literal|2
condition|?
name|salloc
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|COLLECTION
modifier|*
name|getcoll
parameter_list|(
name|filename
parameter_list|,
name|collname
parameter_list|,
name|basedir
parameter_list|)
specifier|register
name|char
modifier|*
name|filename
decl_stmt|,
decl|*
name|collname
decl_stmt|,
modifier|*
name|basedir
decl_stmt|;
end_function

begin_block
block|{
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|COLLECTION
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|basedir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t="
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
name|collname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|skipover
argument_list|(
name|p
argument_list|,
literal|" \t="
argument_list|)
expr_stmt|;
name|basedir
operator|=
name|salloc
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basedir
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEBASEDEFAULT
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|basedir
operator|=
name|salloc
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chdir
argument_list|(
name|basedir
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"supscan:  Can't chdir to base directory %s for %s\n"
argument_list|,
name|basedir
argument_list|,
name|collname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|prefix
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEPREFIX
argument_list|,
name|collname
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
condition|)
block|{
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|prefix
operator|=
name|salloc
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|prefix
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"supscan: can't chdir to %s from base directory %s for %s\n"
argument_list|,
name|prefix
argument_list|,
name|basedir
argument_list|,
name|collname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
operator|(
name|COLLECTION
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COLLECTION
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"supscan: can't malloc collection structure\n"
argument_list|)
expr_stmt|;
name|c
operator|->
name|Cname
operator|=
name|collname
expr_stmt|;
name|c
operator|->
name|Cbase
operator|=
name|basedir
expr_stmt|;
name|c
operator|->
name|Cprefix
operator|=
name|prefix
expr_stmt|;
name|c
operator|->
name|Cnext
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_macro
name|goaway
argument_list|(
argument|char *fmt
argument_list|,
argument|...
argument_list|)
end_macro

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*VARARGS*/
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|goaway
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
if|#
directive|if
operator|!
name|__STDC__
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|localhost
parameter_list|(
name|host
parameter_list|)
specifier|register
name|char
modifier|*
name|host
decl_stmt|;
block|{
specifier|static
name|char
name|myhost
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
specifier|static
name|int
name|myhostlen
decl_stmt|;
specifier|register
name|int
name|hostlen
decl_stmt|;
if|if
condition|(
operator|*
name|myhost
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * We assume that the host name in the kernel is the 		 * fully qualified form. 		 */
if|if
condition|(
name|gethostname
argument_list|(
name|myhost
argument_list|,
sizeof|sizeof
argument_list|(
name|myhost
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|quit
argument_list|(
literal|1
argument_list|,
literal|"supscan: can't get kernel host name\n"
argument_list|)
expr_stmt|;
block|}
name|myhostlen
operator|=
name|strlen
argument_list|(
name|myhost
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Here, we assume that the 'host' parameter from the 	 * coll.host file is at least a prefix of the fully qualified 	 * host name of some machine.  This will be true when modcoll(8) 	 * (and related scripts) maintain the relevant files, but if 	 * a person makes a manual change, problems could result.  In 	 * particular, if a nicname, such as "Y" for "GANDALF.CS.CMU.EDU" 	 * is present in the coll.host file, things will not work as 	 * expected. 	 */
name|hostlen
operator|=
name|strlen
argument_list|(
name|host
argument_list|)
expr_stmt|;
return|return
operator|(
name|strncasecmp
argument_list|(
name|myhost
argument_list|,
name|host
argument_list|,
name|hostlen
operator|<
name|myhostlen
condition|?
name|hostlen
else|:
name|myhostlen
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

end_unit

