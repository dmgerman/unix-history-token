begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software_Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  * /*  * supfilesrv -- SUP File Server  *  * Usage:  supfilesrv [-l] [-P] [-N]  *	-l	"live" -- don't fork daemon  *	-P	"debug ports" -- use debugging network ports  *	-N	"debug network" -- print debugging messages for network i/o  *  **********************************************************************  * HISTORY  * 13-Sep-92  Mary Thompson (mrt) at Carnegie-Mellon University  *	Changed name of sup program in xpatch from /usr/cs/bin/sup to  *	/usr/bin/sup for exported version of sup.  *  * 7-July-93  Nate Williams at Montana State University  *	Modified SUP to use gzip based compression when sending files  *	across the network to save BandWidth  *  * $Log: supfilesrv.c,v $  * Revision 1.4  1994/08/11  02:46:26  rich  * Added extensions written by David Dawes.  From the man page:  *  * The -u flag, or the noupdate supfile option prevent updates from  * occurring for regular files where the modification time and mode  * hasn't changed.  *  * Now, how do we feed these patches back to CMU for consideration?  *  * Revision 1.3  1994/06/20  06:04:13  rgrimes  * Humm.. they did a lot of #if __STDC__ but failed to properly prototype  * the code.  Also fixed one bad argument to a wait3 call.  *  * It won't compile -Wall, but atleast it compiles standard without warnings  * now.  *  * Revision 1.2  1994/05/25  17:58:40  nate  * From Gene Stark  *  * system() returns non-zero status for errors, so check for non-zero  * status instead of< 0 which causes gzip/gunzip failures not to be noticed.  *  * Revision 1.1.1.1  1993/08/21  00:46:34  jkh  * Current sup with compression support.  *  * Revision 1.3  1993/06/05  21:32:17  cgd  * use daemon() to put supfilesrv into daemon mode...  *  * Revision 1.2  1993/05/24  17:57:31  brezak  * Remove netcrypt.c. Remove unneeded files. Cleanup make.  *  * Revision 1.20  92/09/09  22:05:00  mrt  * 	Added Brad's change to make sendfile take a va_list.  * 	Added support in login to accept an non-encrypted login  * 	message if no user or password is being sent. This supports  * 	a non-crypting version of sup. Also fixed to skip leading  * 	white space from crypts in host files.  * 	[92/09/01            mrt]  *   * Revision 1.19  92/08/11  12:07:59  mrt  * 		Made maxchildren a patchable variable, which can be set by the  * 		command line switch -C or else defaults to the MAXCHILDREN  * 		defined in sup.h. Added most of Brad's STUMP changes.  * 	Increased PGMVERSION to 12 to reflect substantial changes.  * 	[92/07/28            mrt]  *   * Revision 1.18  90/12/25  15:15:39  ern  * 	Yet another rewrite of the logging code. Make up the text we will write  * 	   and then get in, write it and get out.  * 	Also set error on write-to-full-disk if the logging is for recording  * 	   server is busy.  * 	[90/12/25  15:15:15  ern]  *   * Revision 1.17  90/05/07  09:31:13  dlc  * 	Sigh, some more fixes to the new "crypt" file handling code.  First,  * 	just because the "crypt" file is in a local file system does not mean  * 	it can be trusted.  We have to check for hard links to root owned  * 	files whose contents could be interpretted as a crypt key.  For  * 	checking this fact, the new routine stat_info_ok() was added.  This  * 	routine also makes other sanity checks, such as owner only permission,  * 	the file is a regular file, etc.  Also, even if the uid/gid of th  * 	"crypt" file is not going to be used, still use its contents in order  * 	to cause fewer surprises to people supping out of a shared file system  * 	such as AFS.  * 	[90/05/07            dlc]  *   * Revision 1.16  90/04/29  04:21:08  dlc  * 	Fixed logic bug in docrypt() which would not get the stat information  * 	from the crypt file if the crypt key had already been set from a  * 	"host" file.  * 	[90/04/29            dlc]  *   * Revision 1.15  90/04/18  19:51:27  dlc  * 	Added the new routines local_file(), link_nofollow() for use in  * 	dectecting whether a file is located in a local file system.  These  * 	routines probably should have been in another module, but only  * 	supfilesrv needs to do the check and none of its other modules seemed  * 	appropriate.  Note, the implementation should be changed once we have  * 	direct kernel support, for example the fstatfs(2) system call, for  * 	detecting the type of file system a file resides.  Also, I changed  * 	the routines which read the crosspatch crypt file or collection crypt  * 	file to save the uid and gid from the stat information obtained via  * 	the local_file() call (when the file is local) at the same time the  * 	crypt key is read.  This change disallows non-local files for the  * 	crypt key to plug a security hole involving the usage of the uid/gid  * 	of the crypt file to define who the the file server should run as.  If  * 	the saved uid/gid are both valid, then the server will set its uid/gid  * 	to these values.  * 	[90/04/18            dlc]  *   * Revision 1.14  89/08/23  14:56:15  gm0w  * 	Changed msgf routines to msg routines.  * 	[89/08/23            gm0w]  *   * Revision 1.13  89/08/03  19:57:33  mja  * 	Remove setaid() call.  *   * Revision 1.12  89/08/03  19:49:24  mja  * 	Updated to use v*printf() in place of _doprnt().  * 	[89/04/19            mja]  *   * 11-Sep-88  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to record release name in logfile.  *  * 18-Mar-88  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added host=<hostfile> support to releases file. [V7.12]  *  * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added crosspatch support.  Created docrypt() routine for crypt  *	test message.  *  * 09-Sep-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Removed common information logging code, the quiet switch, and  *	moved samehost() check to after device/inode check.  *  * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code for "release" support. [V5.11]  *  * 26-May-87  Doug Philips (dwp) at Carnegie-Mellon University  *	Added code to record final status of client in logfile. [V5.10]  *  * 22-May-87  Chriss Stephens (chriss) at Carnegie Mellon University  *	Mergered divergent CS and ECE versions. [V5.9a]  *  * 20-May-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Removed support for version 3 of SUP protocol.  Added changes  *	to make lint happy.  Added calls to new logging routines. [V5.9]  *  * 31-Mar-87  Dan Nydick (dan) at Carnegie-Mellon University  *	Fixed so no password check is done when crypts are used.  *  * 25-Nov-86  Rudy Nedved (ern) at Carnegie-Mellon University  *	Set F_APPEND fcntl in logging to increase the chance  *	that the log entry from this incarnation of the file  *	server will not be lost by another incarnation. [V5.8]  *  * 20-Oct-86  Dan Nydick (dan) at Carnegie-Mellon University  *	Changed not to call okmumbles when not compiled with CMUCS.  *  * 04-Aug-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to increment scmdebug as more -N flags are  *	added. [V5.7]  *  * 25-May-86  Jonathan J. Chew (jjc) at Carnegie-Mellon University  *	Renamed local variable in main program from "sigmask" to  *	"signalmask" to avoid name conflict with 4.3BSD identifier.  *	Conditionally compile in calls to CMU routines, "setaid" and  *	"logaccess". [V5.6]  *  * 21-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Changed supfilesrv to use the crypt file owner and group for  *	access purposes, rather than the directory containing the crypt  *	file. [V5.5]  *  * 07-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to keep logfiles in repository collection directory.  *	Added code for locking collections. [V5.4]  *  * 05-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to support new FSETUPBUSY return.  Now accepts all  *	connections and tells any clients after the 8th that the  *	fileserver is busy.  New clients will retry again later. [V5.3]  *  * 29-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Major rewrite for protocol version 4. [V4.2]  *  * 12-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Fixed close of crypt file to use file pointer as argument  *	instead of string pointer.  *  * 24-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Allow "!hostname" lines and comments in collection "host" file.  *  * 13-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Don't use access() on symbolic links since they may not point to  *	an existing file.  *  * 22-Oct-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to restrict file server availability to when it has  *	less than or equal to eight children.  *  * 22-Sep-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Merged 4.1 and 4.2 versions together.  *  * 04-Jun-85  Steven Shafer (sas) at Carnegie-Mellon University  *	Created for 4.2 BSD.  *  **********************************************************************  */
end_comment

begin_include
include|#
directive|include
file|<libc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AFS
end_ifdef

begin_include
include|#
directive|include
file|<afs/param.h>
end_include

begin_undef
undef|#
directive|undef
name|MAXNAMLEN
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<c.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_if
if|#
directive|if
name|MACH
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CMUCS
end_if

begin_include
include|#
directive|include
file|<acc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttyloc.h>
end_include

begin_include
include|#
directive|include
file|<access.h>
end_include

begin_include
include|#
directive|include
file|<sys/viceioctl.h>
end_include

begin_else
else|#
directive|else
else|CMUCS
end_else

begin_define
define|#
directive|define
name|ACCESS_CODE_OK
value|0
end_define

begin_define
define|#
directive|define
name|ACCESS_CODE_BADPASSWORD
value|(-2)
end_define

begin_endif
endif|#
directive|endif
endif|CMUCS
end_endif

begin_include
include|#
directive|include
file|"sup.h"
end_include

begin_define
define|#
directive|define
name|MSGFILE
end_define

begin_include
include|#
directive|include
file|"supmsg.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_comment
comment|/*VARARGS1*/
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|quit
parameter_list|(
name|status
parameter_list|)
block|{}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|uid_t
name|getuid
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|maxchildren
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These are used to save the stat information from the crosspatch crypt  * file or collection crypt file at the time it is opened for the crypt  * key and it is verified to be a local file.  */
end_comment

begin_decl_stmt
name|int
name|runas_uid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|runas_gid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PGMVERSION
value|13
end_define

begin_comment
comment|/*************************  ***    M A C R O S    ***  *************************/
end_comment

begin_define
define|#
directive|define
name|HASHBITS
value|8
end_define

begin_define
define|#
directive|define
name|HASHSIZE
value|(1<<HASHBITS)
end_define

begin_define
define|#
directive|define
name|HASHMASK
value|(HASHSIZE-1)
end_define

begin_define
define|#
directive|define
name|HASHFUNC
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)&HASHMASK)
end_define

begin_comment
comment|/*******************************************  ***    D A T A   S T R U C T U R E S    ***  *******************************************/
end_comment

begin_struct
struct|struct
name|hashstruct
block|{
comment|/* hash table for number lists */
name|int
name|Hnum1
decl_stmt|;
comment|/* numeric keys */
name|int
name|Hnum2
decl_stmt|;
name|char
modifier|*
name|Hname
decl_stmt|;
comment|/* string value */
name|TREE
modifier|*
name|Htree
decl_stmt|;
comment|/* TREE value */
name|struct
name|hashstruct
modifier|*
name|Hnext
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|hashstruct
name|HASH
typedef|;
end_typedef

begin_comment
comment|/*********************************************  ***    G L O B A L   V A R I A B L E S    ***  *********************************************/
end_comment

begin_decl_stmt
name|char
name|program
index|[]
init|=
literal|"supfilesrv"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program name for SCM messages */
end_comment

begin_decl_stmt
name|int
name|progpid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and process id */
end_comment

begin_decl_stmt
name|jmp_buf
name|sjbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* jump location for network errors */
end_comment

begin_decl_stmt
name|TREELIST
modifier|*
name|listTL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of trees to upgrade */
end_comment

begin_decl_stmt
name|int
name|live
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -l flag */
end_comment

begin_decl_stmt
name|int
name|dbgportsq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -P flag */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|scmdebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -N flag */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|netfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|clienthost
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host name of client */
end_comment

begin_decl_stmt
name|int
name|nchildren
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of children that exist */
end_comment

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* collection pathname prefix */
end_comment

begin_decl_stmt
name|char
modifier|*
name|release
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* collection release name */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cryptkey
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* encryption key if non-null */
end_comment

begin_decl_stmt
name|int
name|lockfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* descriptor of lock file */
end_comment

begin_comment
comment|/* global variables for scan functions */
end_comment

begin_decl_stmt
name|int
name|trace
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* directory scan trace */
end_comment

begin_decl_stmt
name|int
name|cancompress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Can we compress files */
end_comment

begin_decl_stmt
name|int
name|docompress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do we compress files */
end_comment

begin_decl_stmt
name|HASH
modifier|*
name|uidH
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for uid and gid lookup */
end_comment

begin_decl_stmt
name|HASH
modifier|*
name|gidH
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HASH
modifier|*
name|inodeH
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for inode lookup for linked file check */
end_comment

begin_function_decl
name|char
modifier|*
name|fmttime
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* time format routine */
end_comment

begin_comment
comment|/*  * PROTOTYPES  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|void
name|goaway
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LOG_PID_PATHNAME
end_ifdef

begin_function
specifier|static
name|void
name|log_pid
parameter_list|(
name|pathname
parameter_list|)
name|char
modifier|*
name|pathname
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|logerr
argument_list|(
literal|"Unable to create pid to file %s"
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*************************************  ***    M A I N   R O U T I N E    ***  *************************************/
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|pid
decl_stmt|,
name|signalmask
decl_stmt|;
name|struct
name|sigvec
name|chldvec
decl_stmt|,
name|ignvec
decl_stmt|,
name|oldvec
decl_stmt|;
name|void
name|chldsig
parameter_list|()
function_decl|;
name|long
name|tloc
decl_stmt|;
comment|/* initialize global variables */
name|pgmversion
operator|=
name|PGMVERSION
expr_stmt|;
comment|/* export version number */
name|server
operator|=
name|TRUE
expr_stmt|;
comment|/* export that we're not a server */
name|collname
operator|=
name|NULL
expr_stmt|;
comment|/* no current collection yet */
name|maxchildren
operator|=
name|MAXCHILDREN
expr_stmt|;
comment|/* defined in sup.h */
name|init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* process arguments */
ifdef|#
directive|ifdef
name|HAS_DAEMON
if|if
condition|(
operator|!
name|live
condition|)
comment|/* if not debugging, turn into daemon */
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOG_PID_PATHNAME
name|log_pid
argument_list|(
name|LOG_PID_PATHNAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|logopen
argument_list|(
literal|"supfile"
argument_list|)
expr_stmt|;
name|tloc
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|loginfo
argument_list|(
literal|"SUP File Server Version %d.%d (%s) starting at %s"
argument_list|,
name|PROTOVERSION
argument_list|,
name|PGMVERSION
argument_list|,
name|scmversion
argument_list|,
name|fmttime
argument_list|(
name|tloc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|live
condition|)
block|{
name|x
operator|=
name|service
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"Can't connect to network"
argument_list|)
expr_stmt|;
name|answer
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|serviceend
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|ignvec
operator|.
name|sv_handler
operator|=
name|SIG_IGN
expr_stmt|;
name|ignvec
operator|.
name|sv_onstack
operator|=
literal|0
expr_stmt|;
name|ignvec
operator|.
name|sv_mask
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|ignvec
argument_list|,
operator|&
name|oldvec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|ignvec
argument_list|,
operator|&
name|oldvec
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|ignvec
argument_list|,
operator|&
name|oldvec
argument_list|)
expr_stmt|;
name|chldvec
operator|.
name|sv_handler
operator|=
name|chldsig
expr_stmt|;
name|chldvec
operator|.
name|sv_mask
operator|=
literal|0
expr_stmt|;
name|chldvec
operator|.
name|sv_onstack
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|chldvec
argument_list|,
operator|&
name|oldvec
argument_list|)
expr_stmt|;
name|nchildren
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|service
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
block|{
name|logerr
argument_list|(
literal|"Error in establishing network connection"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|servicekill
argument_list|()
expr_stmt|;
continue|continue;
block|}
name|signalmask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* server process */
operator|(
name|void
operator|)
name|serviceprep
argument_list|()
expr_stmt|;
name|answer
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|serviceend
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|servicekill
argument_list|()
expr_stmt|;
comment|/* parent */
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
name|nchildren
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|signalmask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Child status signal handler  */
end_comment

begin_function
name|void
name|chldsig
parameter_list|()
block|{
name|int
name|w
decl_stmt|;
while|while
condition|(
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
name|WNOHANG
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
literal|0
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nchildren
condition|)
name|nchildren
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************  ***    I N I T I A L I Z A T I O N    ***  *****************************************/
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Usage: supfilesrv [ -l | -P | -N | -C<max children> | -H<host><user><cryptfile><supargs> ]\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|init
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
name|char
modifier|*
name|clienthost
decl_stmt|,
modifier|*
name|clientuser
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|int
name|maxsleep
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|live
operator|=
name|FALSE
expr_stmt|;
name|dbgportsq
operator|=
name|FALSE
expr_stmt|;
name|scmdebug
operator|=
literal|0
expr_stmt|;
name|clienthost
operator|=
name|NULL
expr_stmt|;
name|clientuser
operator|=
name|NULL
expr_stmt|;
name|maxsleep
operator|=
literal|5
expr_stmt|;
if|if
condition|(
operator|--
name|argc
operator|<
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
name|argv
operator|++
expr_stmt|;
while|while
condition|(
name|clienthost
operator|==
name|NULL
operator|&&
name|argc
operator|>
literal|0
operator|&&
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'l'
case|:
name|live
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|dbgportsq
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|scmdebug
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
operator|--
name|argc
operator|<
literal|1
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Missing arg to -C\n"
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|maxchildren
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
operator|--
name|argc
operator|<
literal|3
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Missing args to -H\n"
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|clienthost
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|clientuser
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|cryptkey
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|argc
operator|-=
literal|2
expr_stmt|;
name|argv
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown flag %s ignored\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
operator|--
name|argc
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|clienthost
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
name|x
operator|=
name|servicesetup
argument_list|(
name|dbgportsq
condition|?
name|DEBUGFPORT
else|:
name|FILEPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Error in network setup"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
name|uidH
index|[
name|i
index|]
operator|=
name|gidH
index|[
name|i
index|]
operator|=
name|inodeH
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|server
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|cryptkey
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Unable to open cryptfile %s\n"
argument_list|,
name|cryptkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"No cryptkey found in %s\n"
argument_list|,
name|cryptkey
argument_list|)
expr_stmt|;
name|cryptkey
operator|=
name|salloc
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|x
operator|=
name|request
argument_list|(
name|dbgportsq
condition|?
name|DEBUGFPORT
else|:
name|FILEPORT
argument_list|,
name|clienthost
argument_list|,
operator|&
name|maxsleep
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Unable to connect to host %s\n"
argument_list|,
name|clienthost
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgsignon
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Error sending signon request to fileserver\n"
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgsignonack
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Error reading signon reply from fileserver\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SUP Fileserver %d.%d (%s) %d on %s\n"
argument_list|,
name|protver
argument_list|,
name|pgmver
argument_list|,
name|scmver
argument_list|,
name|fspid
argument_list|,
name|remotehost
argument_list|()
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scmver
argument_list|)
expr_stmt|;
name|scmver
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|protver
operator|<
literal|7
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Remote fileserver does not implement reverse sup\n"
argument_list|)
expr_stmt|;
name|xpatch
operator|=
name|TRUE
expr_stmt|;
name|xuser
operator|=
name|clientuser
expr_stmt|;
name|x
operator|=
name|msgsetup
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Error sending setup request to fileserver\n"
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Error reading setup reply from fileserver\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|setupack
condition|)
block|{
case|case
name|FSETUPOK
case|:
break|break;
case|case
name|FSETUPSAME
case|:
name|quit
argument_list|(
literal|1
argument_list|,
literal|"User %s not found on remote client\n"
argument_list|,
name|xuser
argument_list|)
expr_stmt|;
case|case
name|FSETUPHOST
case|:
name|quit
argument_list|(
literal|1
argument_list|,
literal|"This host has no permission to reverse sup\n"
argument_list|)
expr_stmt|;
default|default:
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Unrecognized file server setup status %d\n"
argument_list|,
name|setupack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netcrypt
argument_list|(
name|cryptkey
argument_list|)
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Running non-crypting fileserver\n"
argument_list|)
expr_stmt|;
name|crypttest
operator|=
name|CRYPTTEST
expr_stmt|;
name|x
operator|=
name|msgcrypt
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Error sending encryption test request\n"
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgcryptok
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMEOF
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Data encryption test failed\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Error reading encryption test reply\n"
argument_list|)
expr_stmt|;
name|logcrypt
operator|=
name|CRYPTTEST
expr_stmt|;
name|loguser
operator|=
name|NULL
expr_stmt|;
name|logpswd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|netcrypt
argument_list|(
name|PSWDCRYPT
argument_list|)
operator|!=
name|SCMOK
condition|)
comment|/* encrypt password data */
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Running non-crypting fileserver\n"
argument_list|)
expr_stmt|;
name|x
operator|=
name|msglogin
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* turn off encryption */
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Error sending login request to file server\n"
argument_list|)
expr_stmt|;
name|x
operator|=
name|msglogack
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Error reading login reply from file server\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logack
operator|==
name|FLOGNG
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"%s\nImproper login to %s account\n"
argument_list|,
name|logerror
argument_list|,
name|xuser
argument_list|)
expr_stmt|;
name|xargc
operator|=
name|argc
expr_stmt|;
name|xargv
operator|=
name|argv
expr_stmt|;
name|x
operator|=
name|msgxpatch
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|quit
argument_list|(
literal|1
argument_list|,
literal|"Error sending crosspatch request\n"
argument_list|)
expr_stmt|;
name|crosspatch
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*****************************************  ***    A N S W E R   R E Q U E S T    ***  *****************************************/
end_comment

begin_macro
name|answer
argument_list|()
end_macro

begin_block
block|{
name|long
name|starttime
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
name|progpid
operator|=
name|fspid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|collname
operator|=
name|NULL
expr_stmt|;
name|basedir
operator|=
name|NULL
expr_stmt|;
name|prefix
operator|=
name|NULL
expr_stmt|;
name|release
operator|=
name|NULL
expr_stmt|;
name|goawayreason
operator|=
name|NULL
expr_stmt|;
name|donereason
operator|=
name|NULL
expr_stmt|;
name|lockfd
operator|=
operator|-
literal|1
expr_stmt|;
name|starttime
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
condition|)
block|{
name|signon
argument_list|()
expr_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|docrypt
argument_list|()
expr_stmt|;
name|login
argument_list|()
expr_stmt|;
if|if
condition|(
name|xpatch
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|x
operator|=
name|msgxpatch
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|xargv
index|[
literal|0
index|]
operator|=
literal|"sup"
expr_stmt|;
name|xargv
index|[
literal|1
index|]
operator|=
literal|"-X"
expr_stmt|;
name|xargv
index|[
name|xargc
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|netfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|netfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|netfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|fd
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
while|while
condition|(
operator|--
name|fd
operator|>
literal|2
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|xargv
index|[
literal|0
index|]
argument_list|,
name|xargv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|listfiles
argument_list|()
expr_stmt|;
name|sendfiles
argument_list|()
expr_stmt|;
block|}
name|finishup
argument_list|(
name|starttime
argument_list|)
expr_stmt|;
if|if
condition|(
name|collname
condition|)
name|free
argument_list|(
name|collname
argument_list|)
expr_stmt|;
if|if
condition|(
name|basedir
condition|)
name|free
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
name|free
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|release
condition|)
name|free
argument_list|(
name|release
argument_list|)
expr_stmt|;
if|if
condition|(
name|goawayreason
condition|)
block|{
if|if
condition|(
name|donereason
operator|==
name|goawayreason
condition|)
name|donereason
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|goawayreason
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|donereason
condition|)
name|free
argument_list|(
name|donereason
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockfd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|lockfd
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|endgrent
argument_list|()
expr_stmt|;
if|#
directive|if
name|CMUCS
name|endacent
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* CMUCS */
name|Hfree
argument_list|(
name|uidH
argument_list|)
expr_stmt|;
name|Hfree
argument_list|(
name|gidH
argument_list|)
expr_stmt|;
name|Hfree
argument_list|(
name|inodeH
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*****************************************  ***    S I G N   O N   C L I E N T    ***  *****************************************/
end_comment

begin_macro
name|signon
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|xpatch
operator|=
name|FALSE
expr_stmt|;
name|x
operator|=
name|msgsignon
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading signon request from client"
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgsignonack
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending signon reply to client"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scmver
argument_list|)
expr_stmt|;
name|scmver
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*****************************************************************  ***    E X C H A N G E   S E T U P   I N F O R M A T I O N    ***  *****************************************************************/
end_comment

begin_macro
name|setup
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
specifier|register
name|TREELIST
modifier|*
name|tl
decl_stmt|;
if|if
condition|(
name|protver
operator|>
literal|7
condition|)
block|{
name|cancompress
operator|=
name|TRUE
expr_stmt|;
block|}
name|x
operator|=
name|msgsetup
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading setup request from client"
argument_list|)
expr_stmt|;
if|if
condition|(
name|protver
operator|<
literal|4
condition|)
block|{
name|setupack
operator|=
name|FSETUPOLD
expr_stmt|;
operator|(
name|void
operator|)
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|protver
operator|>=
literal|6
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Sup client using obsolete version of protocol"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xpatch
condition|)
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|extern
name|int
name|link_nofollow
argument_list|()
decl_stmt|,
name|local_file
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|xuser
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|setupack
operator|=
name|FSETUPSAME
expr_stmt|;
operator|(
name|void
operator|)
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|protver
operator|>=
literal|6
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"User not found"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|free
argument_list|(
name|xuser
argument_list|)
expr_stmt|;
name|xuser
operator|=
name|salloc
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
comment|/* check crosspatch host access file */
name|cryptkey
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEXPATCH
argument_list|,
name|xuser
argument_list|)
expr_stmt|;
comment|/* Turn off link following */
if|if
condition|(
name|link_nofollow
argument_list|(
literal|1
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|hostok
init|=
name|FALSE
decl_stmt|;
comment|/* get stat info before open */
if|if
condition|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|stat
name|fsbuf
decl_stmt|;
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|matchhost
argument_list|(
name|q
argument_list|)
condition|)
continue|continue;
name|cryptkey
operator|=
name|salloc
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|hostok
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|local_file
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|fsbuf
argument_list|)
operator|>
literal|0
operator|&&
name|stat_info_ok
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|&
name|fsbuf
argument_list|)
condition|)
block|{
name|runas_uid
operator|=
name|sbuf
operator|.
name|st_uid
expr_stmt|;
name|runas_gid
operator|=
name|sbuf
operator|.
name|st_gid
expr_stmt|;
block|}
break|break;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* Restore link following */
if|if
condition|(
name|link_nofollow
argument_list|(
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|goaway
argument_list|(
literal|"Restore link following"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hostok
condition|)
block|{
name|setupack
operator|=
name|FSETUPHOST
expr_stmt|;
operator|(
name|void
operator|)
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|protver
operator|>=
literal|6
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Host not on access list"
argument_list|)
expr_stmt|;
block|}
block|}
name|setupack
operator|=
name|FSETUPOK
expr_stmt|;
name|x
operator|=
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending setup reply to client"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|release
operator|==
name|NULL
condition|)
name|release
operator|=
name|salloc
argument_list|(
name|DEFRELEASE
argument_list|)
expr_stmt|;
if|if
condition|(
name|basedir
operator|==
name|NULL
operator|||
operator|*
name|basedir
operator|==
literal|'\0'
condition|)
block|{
name|basedir
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEDIRS
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t="
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
name|collname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|basedir
operator|=
name|skipover
argument_list|(
name|p
argument_list|,
literal|" \t="
argument_list|)
expr_stmt|;
name|basedir
operator|=
name|salloc
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|basedir
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEBASEDEFAULT
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|basedir
operator|=
name|salloc
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chdir
argument_list|(
name|basedir
argument_list|)
operator|<
literal|0
condition|)
name|goaway
argument_list|(
literal|"Can't chdir to base directory %s"
argument_list|,
name|basedir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEPREFIX
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|prefix
operator|=
name|salloc
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|prefix
argument_list|)
operator|<
literal|0
condition|)
name|goaway
argument_list|(
literal|"Can't chdir to %s from base directory %s"
argument_list|,
name|prefix
argument_list|,
name|basedir
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|goaway
argument_list|(
literal|"Can't stat base/prefix directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchildren
operator|>=
name|maxchildren
condition|)
block|{
name|setupack
operator|=
name|FSETUPBUSY
expr_stmt|;
operator|(
name|void
operator|)
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|protver
operator|>=
literal|6
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Sup client told to try again later"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbuf
operator|.
name|st_dev
operator|==
name|basedev
operator|&&
name|sbuf
operator|.
name|st_ino
operator|==
name|baseino
operator|&&
name|samehost
argument_list|()
condition|)
block|{
name|setupack
operator|=
name|FSETUPSAME
expr_stmt|;
operator|(
name|void
operator|)
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|protver
operator|>=
literal|6
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Attempt to upgrade to same directory on same host"
argument_list|)
expr_stmt|;
block|}
comment|/* obtain release information */
if|if
condition|(
operator|!
name|getrelease
argument_list|(
name|release
argument_list|)
condition|)
block|{
name|setupack
operator|=
name|FSETUPRELEASE
expr_stmt|;
operator|(
name|void
operator|)
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|protver
operator|>=
literal|6
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Invalid release information"
argument_list|)
expr_stmt|;
block|}
comment|/* check host access file */
name|cryptkey
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|tl
operator|=
name|listTL
init|;
name|tl
operator|!=
name|NULL
condition|;
name|tl
operator|=
name|tl
operator|->
name|TLnext
control|)
block|{
name|char
modifier|*
name|h
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|tl
operator|->
name|TLhost
operator|)
operator|==
name|NULL
condition|)
name|h
operator|=
name|FILEHOSTDEF
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEHOST
argument_list|,
name|collname
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|int
name|hostok
init|=
name|FALSE
decl_stmt|;
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|int
name|not
decl_stmt|;
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|not
operator|=
operator|(
operator|*
name|q
operator|==
literal|'!'
operator|)
operator|)
operator|&&
operator|*
operator|++
name|q
operator|==
literal|'\0'
condition|)
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|hostok
operator|=
operator|(
name|not
operator|==
operator|(
name|matchhost
argument_list|(
name|q
argument_list|)
operator|==
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|hostok
condition|)
block|{
while|while
condition|(
operator|(
operator|*
name|p
operator|==
literal|' '
operator|)
operator|||
operator|(
operator|*
name|p
operator|==
literal|'\t'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|cryptkey
operator|=
name|salloc
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hostok
condition|)
block|{
name|setupack
operator|=
name|FSETUPHOST
expr_stmt|;
operator|(
name|void
operator|)
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|protver
operator|>=
literal|6
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Host not on access list for %s"
argument_list|,
name|collname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* try to lock collection */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILELOCK
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|x
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|flock
argument_list|(
name|x
argument_list|,
operator|(
name|LOCK_SH
operator||
name|LOCK_NB
operator|)
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
name|goaway
argument_list|(
literal|"Can't lock collection %s"
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|setupack
operator|=
name|FSETUPBUSY
expr_stmt|;
operator|(
name|void
operator|)
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|protver
operator|>=
literal|6
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Sup client told to wait for lock"
argument_list|)
expr_stmt|;
block|}
name|lockfd
operator|=
name|x
expr_stmt|;
block|}
name|setupack
operator|=
name|FSETUPOK
expr_stmt|;
name|x
operator|=
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending setup reply to client"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/** Test data encryption **/
end_comment

begin_macro
name|docrypt
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
specifier|extern
name|int
name|link_nofollow
argument_list|()
decl_stmt|,
name|local_file
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|xpatch
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILECRYPT
argument_list|,
name|collname
argument_list|)
expr_stmt|;
comment|/* Turn off link following */
if|if
condition|(
name|link_nofollow
argument_list|(
literal|1
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* get stat info before open */
if|if
condition|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|stat
name|fsbuf
decl_stmt|;
if|if
condition|(
name|cryptkey
operator|==
name|NULL
operator|&&
operator|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|cryptkey
operator|=
name|salloc
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_file
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|fsbuf
argument_list|)
operator|>
literal|0
operator|&&
name|stat_info_ok
argument_list|(
operator|&
name|sbuf
argument_list|,
operator|&
name|fsbuf
argument_list|)
condition|)
block|{
name|runas_uid
operator|=
name|sbuf
operator|.
name|st_uid
expr_stmt|;
name|runas_gid
operator|=
name|sbuf
operator|.
name|st_gid
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* Restore link following */
if|if
condition|(
name|link_nofollow
argument_list|(
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|goaway
argument_list|(
literal|"Restore link following"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|netcrypt
argument_list|(
name|cryptkey
argument_list|)
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Runing non-crypting supfilesrv"
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgcrypt
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading encryption test request from client"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|crypttest
argument_list|,
name|CRYPTTEST
argument_list|)
operator|!=
literal|0
condition|)
name|goaway
argument_list|(
literal|"Client not encrypting data properly"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|crypttest
argument_list|)
expr_stmt|;
name|crypttest
operator|=
name|NULL
expr_stmt|;
name|x
operator|=
name|msgcryptok
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending encryption test reply to client"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***************************************************************  ***    C O N N E C T   T O   P R O P E R   A C C O U N T    ***  ***************************************************************/
end_comment

begin_macro
name|login
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|changeuid
parameter_list|()
function_decl|;
specifier|register
name|int
name|x
decl_stmt|,
name|fileuid
decl_stmt|,
name|filegid
decl_stmt|;
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
name|PSWDCRYPT
argument_list|)
expr_stmt|;
comment|/* encrypt acct name and password */
name|x
operator|=
name|msglogin
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* turn off encryption */
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading login request from client"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logcrypt
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|logcrypt
argument_list|,
name|CRYPTTEST
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logack
operator|=
name|FLOGNG
expr_stmt|;
name|logerror
operator|=
literal|"Improper login encryption"
expr_stmt|;
operator|(
name|void
operator|)
name|msglogack
argument_list|()
expr_stmt|;
name|goaway
argument_list|(
literal|"Client not encrypting login information properly"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|logcrypt
argument_list|)
expr_stmt|;
name|logcrypt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|loguser
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cryptkey
condition|)
block|{
if|if
condition|(
name|runas_uid
operator|>=
literal|0
operator|&&
name|runas_gid
operator|>=
literal|0
condition|)
block|{
name|fileuid
operator|=
name|runas_uid
expr_stmt|;
name|filegid
operator|=
name|runas_gid
expr_stmt|;
name|loguser
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|loguser
operator|=
name|salloc
argument_list|(
name|DEFUSER
argument_list|)
expr_stmt|;
block|}
else|else
name|loguser
operator|=
name|salloc
argument_list|(
name|DEFUSER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|logerror
operator|=
name|changeuid
argument_list|(
name|loguser
argument_list|,
name|logpswd
argument_list|,
name|fileuid
argument_list|,
name|filegid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|logack
operator|=
name|FLOGNG
expr_stmt|;
operator|(
name|void
operator|)
name|msglogack
argument_list|()
expr_stmt|;
if|if
condition|(
name|protver
operator|>=
literal|6
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Client denied login access"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|loguser
condition|)
name|free
argument_list|(
name|loguser
argument_list|)
expr_stmt|;
if|if
condition|(
name|logpswd
condition|)
name|free
argument_list|(
name|logpswd
argument_list|)
expr_stmt|;
name|logack
operator|=
name|FLOGOK
expr_stmt|;
name|x
operator|=
name|msglogack
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending login reply to client"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xpatch
condition|)
comment|/* restore desired encryption */
if|if
condition|(
name|netcrypt
argument_list|(
name|cryptkey
argument_list|)
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Running non-crypting supfilesrv"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cryptkey
argument_list|)
expr_stmt|;
name|cryptkey
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*****************************************  ***    M A K E   N A M E   L I S T    ***  *****************************************/
end_comment

begin_macro
name|listfiles
argument_list|()
end_macro

begin_block
block|{
name|int
name|denyone
parameter_list|()
function_decl|;
specifier|register
name|int
name|x
decl_stmt|;
name|refuseT
operator|=
name|NULL
expr_stmt|;
name|x
operator|=
name|msgrefuse
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading refuse list from client"
argument_list|)
expr_stmt|;
name|getscanlists
argument_list|()
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|refuseT
argument_list|)
expr_stmt|;
name|x
operator|=
name|msglist
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending file list to client"
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|listT
argument_list|)
expr_stmt|;
name|listT
operator|=
name|NULL
expr_stmt|;
name|needT
operator|=
name|NULL
expr_stmt|;
name|x
operator|=
name|msgneed
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading needed files list from client"
argument_list|)
expr_stmt|;
name|denyT
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|needT
argument_list|,
name|denyone
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|needT
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgdeny
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending denied files list to client"
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|denyT
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|denyone
argument_list|(
name|t
argument_list|)
specifier|register
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|TREELIST
modifier|*
name|tl
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
init|=
name|t
operator|->
name|Tname
decl_stmt|;
specifier|register
name|int
name|update
init|=
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FUPDATE
operator|)
operator|!=
literal|0
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
specifier|register
name|TREE
modifier|*
name|tlink
decl_stmt|;
name|TREE
modifier|*
name|linkcheck
parameter_list|()
function_decl|;
name|char
name|slinkname
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
for|for
control|(
name|tl
operator|=
name|listTL
init|;
name|tl
operator|!=
name|NULL
condition|;
name|tl
operator|=
name|tl
operator|->
name|TLnext
control|)
if|if
condition|(
operator|(
name|t
operator|=
name|Tsearch
argument_list|(
name|tl
operator|->
name|TLtree
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|Tinsert
argument_list|(
operator|&
name|denyT
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|cdprefix
argument_list|(
name|tl
operator|->
name|TLprefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
name|x
operator|=
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Tinsert
argument_list|(
operator|&
name|denyT
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
switch|switch
condition|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFLNK
case|:
if|if
condition|(
operator|(
name|x
operator|=
name|readlink
argument_list|(
name|name
argument_list|,
name|slinkname
argument_list|,
name|STRINGLENGTH
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Tinsert
argument_list|(
operator|&
name|denyT
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|slinkname
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|Tinsert
argument_list|(
operator|&
name|t
operator|->
name|Tlink
argument_list|,
name|slinkname
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFREG
case|:
if|if
condition|(
name|sbuf
operator|.
name|st_nlink
operator|>
literal|1
operator|&&
operator|(
name|tlink
operator|=
name|linkcheck
argument_list|(
name|t
argument_list|,
operator|(
name|int
operator|)
name|sbuf
operator|.
name|st_dev
argument_list|,
operator|(
name|int
operator|)
name|sbuf
operator|.
name|st_ino
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|Tinsert
argument_list|(
operator|&
name|tlink
operator|->
name|Tlink
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
name|update
condition|)
name|t
operator|->
name|Tflags
operator||=
name|FUPDATE
expr_stmt|;
case|case
name|S_IFDIR
case|:
name|t
operator|->
name|Tuid
operator|=
name|sbuf
operator|.
name|st_uid
expr_stmt|;
name|t
operator|->
name|Tgid
operator|=
name|sbuf
operator|.
name|st_gid
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|Tinsert
argument_list|(
operator|&
name|denyT
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|t
operator|->
name|Tflags
operator||=
name|FNEEDED
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*********************************  ***    S E N D   F I L E S    ***  *********************************/
end_comment

begin_macro
name|sendfiles
argument_list|()
end_macro

begin_block
block|{
name|int
name|sendone
argument_list|()
decl_stmt|,
name|senddir
argument_list|()
decl_stmt|,
name|sendfile
argument_list|()
decl_stmt|;
specifier|register
name|TREELIST
modifier|*
name|tl
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
comment|/* Does the protocol support compression */
if|if
condition|(
name|cancompress
condition|)
block|{
comment|/* Check for compression on sending files */
name|x
operator|=
name|msgcompress
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending compression check to server"
argument_list|)
expr_stmt|;
block|}
comment|/* send all files */
for|for
control|(
name|tl
operator|=
name|listTL
init|;
name|tl
operator|!=
name|NULL
condition|;
name|tl
operator|=
name|tl
operator|->
name|TLnext
control|)
block|{
name|cdprefix
argument_list|(
name|tl
operator|->
name|TLprefix
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|tl
operator|->
name|TLtree
argument_list|,
name|sendone
argument_list|)
expr_stmt|;
block|}
comment|/* send directories in reverse order */
for|for
control|(
name|tl
operator|=
name|listTL
init|;
name|tl
operator|!=
name|NULL
condition|;
name|tl
operator|=
name|tl
operator|->
name|TLnext
control|)
block|{
name|cdprefix
argument_list|(
name|tl
operator|->
name|TLprefix
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Trprocess
argument_list|(
name|tl
operator|->
name|TLtree
argument_list|,
name|senddir
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|msgsend
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading receive file request from client"
argument_list|)
expr_stmt|;
name|upgradeT
operator|=
name|NULL
expr_stmt|;
name|x
operator|=
name|msgrecv
argument_list|(
name|sendfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending file to client"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|sendone
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TREE
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|fd
decl_stmt|;
specifier|register
name|int
name|fdtmp
decl_stmt|;
name|char
name|sys_com
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
name|temp_file
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|char
modifier|*
name|uconvert
argument_list|()
decl_stmt|,
modifier|*
name|gconvert
argument_list|()
decl_stmt|;
name|int
name|sendfile
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNEEDED
operator|)
operator|==
literal|0
condition|)
comment|/* only send needed files */
return|return
operator|(
name|SCMOK
operator|)
return|;
if|if
condition|(
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
comment|/* send no directories this pass */
return|return
operator|(
name|SCMOK
operator|)
return|;
name|x
operator|=
name|msgsend
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading receive file request from client"
argument_list|)
expr_stmt|;
name|upgradeT
operator|=
name|t
expr_stmt|;
comment|/* upgrade file pointer */
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no open file */
if|if
condition|(
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
block|{
if|if
condition|(
operator|!
name|listonly
operator|&&
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FUPDATE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|docompress
condition|)
block|{
name|tmpnam
argument_list|(
name|temp_file
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sys_com
argument_list|,
literal|"gzip -c< %s> %s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|,
name|temp_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|sys_com
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Just in case */
name|unlink
argument_list|(
name|temp_file
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"We died trying to compress"
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tmode
operator|=
literal|0
expr_stmt|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|temp_file
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|fd
operator|=
name|open
argument_list|(
name|t
operator|->
name|Tname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|t
operator|->
name|Tmode
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|Tmode
condition|)
block|{
name|t
operator|->
name|Tuser
operator|=
name|salloc
argument_list|(
name|uconvert
argument_list|(
name|t
operator|->
name|Tuid
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tgroup
operator|=
name|salloc
argument_list|(
name|gconvert
argument_list|(
name|t
operator|->
name|Tgid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|x
operator|=
name|msgrecv
argument_list|(
name|sendfile
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|docompress
condition|)
name|unlink
argument_list|(
name|temp_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending file to client"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_macro
name|senddir
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TREE
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|char
modifier|*
name|uconvert
argument_list|()
decl_stmt|,
modifier|*
name|gconvert
argument_list|()
decl_stmt|;
name|int
name|sendfile
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNEEDED
operator|)
operator|==
literal|0
condition|)
comment|/* only send needed files */
return|return
operator|(
name|SCMOK
operator|)
return|;
if|if
condition|(
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
comment|/* send only directories this pass */
return|return
operator|(
name|SCMOK
operator|)
return|;
name|x
operator|=
name|msgsend
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading receive file request from client"
argument_list|)
expr_stmt|;
name|upgradeT
operator|=
name|t
expr_stmt|;
comment|/* upgrade file pointer */
name|t
operator|->
name|Tuser
operator|=
name|salloc
argument_list|(
name|uconvert
argument_list|(
name|t
operator|->
name|Tuid
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tgroup
operator|=
name|salloc
argument_list|(
name|gconvert
argument_list|(
name|t
operator|->
name|Tgid
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgrecv
argument_list|(
name|sendfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending file to client"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|sendfile
argument_list|(
name|t
argument_list|,
name|ap
argument_list|)
specifier|register
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|va_list
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|fd
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
operator|||
name|listonly
operator|||
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FUPDATE
operator|)
condition|)
return|return
operator|(
name|SCMOK
operator|)
return|;
name|x
operator|=
name|writefile
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending file to client"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*****************************************  ***    E N D   C O N N E C T I O N    ***  *****************************************/
end_comment

begin_macro
name|finishup
argument_list|(
argument|starttime
argument_list|)
end_macro

begin_decl_stmt
name|long
name|starttime
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
init|=
name|SCMOK
decl_stmt|;
name|char
name|tmpbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|lognam
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|int
name|logfd
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|long
name|finishtime
decl_stmt|;
name|char
modifier|*
name|releasename
decl_stmt|;
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|protver
operator|<
literal|6
condition|)
block|{
if|if
condition|(
name|goawayreason
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|goawayreason
argument_list|)
expr_stmt|;
name|goawayreason
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|x
operator|=
name|msggoaway
argument_list|()
expr_stmt|;
name|doneack
operator|=
name|FDONESUCCESS
expr_stmt|;
name|donereason
operator|=
name|salloc
argument_list|(
literal|"Unknown"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|goawayreason
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|x
operator|=
name|msgdone
argument_list|()
expr_stmt|;
else|else
block|{
name|doneack
operator|=
name|FDONEGOAWAY
expr_stmt|;
name|donereason
operator|=
name|goawayreason
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|==
name|SCMEOF
operator|||
name|x
operator|==
name|SCMERR
condition|)
block|{
name|doneack
operator|=
name|FDONEUSRERROR
expr_stmt|;
name|donereason
operator|=
name|salloc
argument_list|(
literal|"Premature EOF on network"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
block|{
name|doneack
operator|=
name|FDONESRVERROR
expr_stmt|;
name|donereason
operator|=
name|salloc
argument_list|(
literal|"Unknown SCM code"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doneack
operator|==
name|FDONEDONTLOG
condition|)
return|return;
if|if
condition|(
name|donereason
operator|==
name|NULL
condition|)
name|donereason
operator|=
name|salloc
argument_list|(
literal|"No reason"
argument_list|)
expr_stmt|;
if|if
condition|(
name|doneack
operator|==
name|FDONESRVERROR
operator|||
name|doneack
operator|==
name|FDONEUSRERROR
condition|)
name|logerr
argument_list|(
literal|"%s"
argument_list|,
name|donereason
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|doneack
operator|==
name|FDONEGOAWAY
condition|)
name|logerr
argument_list|(
literal|"GOAWAY: %s"
argument_list|,
name|donereason
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|doneack
operator|!=
name|FDONESUCCESS
condition|)
name|logerr
argument_list|(
literal|"Reason %d:  %s"
argument_list|,
name|doneack
argument_list|,
name|donereason
argument_list|)
expr_stmt|;
name|goawayreason
operator|=
name|donereason
expr_stmt|;
name|cdprefix
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lognam
argument_list|,
name|FILELOGFILE
argument_list|,
name|collname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|logfd
operator|=
name|open
argument_list|(
name|lognam
argument_list|,
name|O_APPEND
operator||
name|O_WRONLY
argument_list|,
literal|0644
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
comment|/* can not open file up...error */
name|finishtime
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmpbuf
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s "
argument_list|,
name|fmttime
argument_list|(
name|lasttime
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s "
argument_list|,
name|fmttime
argument_list|(
name|starttime
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s "
argument_list|,
name|fmttime
argument_list|(
name|finishtime
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|releasename
operator|=
name|release
operator|)
operator|==
name|NULL
condition|)
name|releasename
operator|=
literal|"UNKNOWN"
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s %s %d %s\n"
argument_list|,
name|remotehost
argument_list|()
argument_list|,
name|releasename
argument_list|,
name|FDONESUCCESS
operator|-
name|doneack
argument_list|,
name|donereason
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
name|MACH
comment|/* if we are busy dont get stuck updating the disk if full */
if|if
condition|(
name|setupack
operator|==
name|FSETUPBUSY
condition|)
block|{
name|long
name|l
init|=
name|FIOCNOSPC_ERROR
decl_stmt|;
name|ioctl
argument_list|(
name|logfd
argument_list|,
name|FIOCNOSPC
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MACH */
operator|(
name|void
operator|)
name|write
argument_list|(
name|logfd
argument_list|,
name|tmpbuf
argument_list|,
operator|(
name|p
operator|-
name|tmpbuf
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|logfd
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***************************************************  ***    H A S H   T A B L E   R O U T I N E S    ***  ***************************************************/
end_comment

begin_macro
name|Hfree
argument_list|(
argument|table
argument_list|)
end_macro

begin_decl_stmt
name|HASH
modifier|*
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|HASH
modifier|*
name|h
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HASHSIZE
condition|;
name|i
operator|++
control|)
while|while
condition|(
name|h
operator|=
name|table
index|[
name|i
index|]
condition|)
block|{
name|table
index|[
name|i
index|]
operator|=
name|h
operator|->
name|Hnext
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|Hname
condition|)
name|free
argument_list|(
name|h
operator|->
name|Hname
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|h
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|HASH
modifier|*
name|Hlookup
parameter_list|(
name|table
parameter_list|,
name|num1
parameter_list|,
name|num2
parameter_list|)
name|HASH
modifier|*
modifier|*
name|table
decl_stmt|;
name|int
name|num1
decl_stmt|,
name|num2
decl_stmt|;
block|{
specifier|register
name|HASH
modifier|*
name|h
decl_stmt|;
specifier|register
name|int
name|hno
decl_stmt|;
name|hno
operator|=
name|HASHFUNC
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|)
expr_stmt|;
for|for
control|(
name|h
operator|=
name|table
index|[
name|hno
index|]
init|;
name|h
operator|&&
operator|(
name|h
operator|->
name|Hnum1
operator|!=
name|num1
operator|||
name|h
operator|->
name|Hnum2
operator|!=
name|num2
operator|)
condition|;
name|h
operator|=
name|h
operator|->
name|Hnext
control|)
empty_stmt|;
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_macro
name|Hinsert
argument_list|(
argument|table
argument_list|,
argument|num1
argument_list|,
argument|num2
argument_list|,
argument|name
argument_list|,
argument|tree
argument_list|)
end_macro

begin_decl_stmt
name|HASH
modifier|*
modifier|*
name|table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num1
decl_stmt|,
name|num2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TREE
modifier|*
name|tree
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|HASH
modifier|*
name|h
decl_stmt|;
specifier|register
name|int
name|hno
decl_stmt|;
name|hno
operator|=
name|HASHFUNC
argument_list|(
name|num1
argument_list|,
name|num2
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
name|HASH
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|HASH
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|Hnum1
operator|=
name|num1
expr_stmt|;
name|h
operator|->
name|Hnum2
operator|=
name|num2
expr_stmt|;
name|h
operator|->
name|Hname
operator|=
name|name
expr_stmt|;
name|h
operator|->
name|Htree
operator|=
name|tree
expr_stmt|;
name|h
operator|->
name|Hnext
operator|=
name|table
index|[
name|hno
index|]
expr_stmt|;
name|table
index|[
name|hno
index|]
operator|=
name|h
expr_stmt|;
block|}
end_block

begin_comment
comment|/*********************************************  ***    U T I L I T Y   R O U T I N E S    ***  *********************************************/
end_comment

begin_function
name|TREE
modifier|*
name|linkcheck
parameter_list|(
name|t
parameter_list|,
name|d
parameter_list|,
name|i
parameter_list|)
name|TREE
modifier|*
name|t
decl_stmt|;
name|int
name|d
decl_stmt|,
name|i
decl_stmt|;
comment|/* inode # and device # */
block|{
specifier|register
name|HASH
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|Hlookup
argument_list|(
name|inodeH
argument_list|,
name|i
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
condition|)
return|return
operator|(
name|h
operator|->
name|Htree
operator|)
return|;
name|Hinsert
argument_list|(
name|inodeH
argument_list|,
name|i
argument_list|,
name|d
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|TREE
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|uconvert
parameter_list|(
name|uid
parameter_list|)
name|int
name|uid
decl_stmt|;
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|HASH
modifier|*
name|u
decl_stmt|;
name|u
operator|=
name|Hlookup
argument_list|(
name|uidH
argument_list|,
name|uid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
condition|)
return|return
operator|(
name|u
operator|->
name|Hname
operator|)
return|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
name|p
operator|=
name|salloc
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|Hinsert
argument_list|(
name|uidH
argument_list|,
name|uid
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
operator|(
name|TREE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|gconvert
parameter_list|(
name|gid
parameter_list|)
name|int
name|gid
decl_stmt|;
block|{
specifier|register
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|HASH
modifier|*
name|g
decl_stmt|;
name|g
operator|=
name|Hlookup
argument_list|(
name|gidH
argument_list|,
name|gid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
condition|)
return|return
operator|(
name|g
operator|->
name|Hname
operator|)
return|;
name|gr
operator|=
name|getgrgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|==
name|NULL
condition|)
return|return
operator|(
literal|""
operator|)
return|;
name|p
operator|=
name|salloc
argument_list|(
name|gr
operator|->
name|gr_name
argument_list|)
expr_stmt|;
name|Hinsert
argument_list|(
name|gidH
argument_list|,
name|gid
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
operator|(
name|TREE
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|changeuid
parameter_list|(
name|namep
parameter_list|,
name|passwordp
parameter_list|,
name|fileuid
parameter_list|,
name|filegid
parameter_list|)
name|char
modifier|*
name|namep
decl_stmt|,
decl|*
name|passwordp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|fileuid
decl_stmt|,
name|filegid
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|okpassword
parameter_list|()
function_decl|;
name|char
modifier|*
name|group
decl_stmt|,
modifier|*
name|account
decl_stmt|,
modifier|*
name|pswdp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
if|#
directive|if
name|CMUCS
name|struct
name|account
modifier|*
name|acc
decl_stmt|;
name|struct
name|ttyloc
name|tlc
decl_stmt|;
endif|#
directive|endif
comment|/* CMUCS */
specifier|register
name|int
name|status
init|=
name|ACCESS_CODE_OK
decl_stmt|;
name|char
name|nbuf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
specifier|static
name|char
name|errbuf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
if|#
directive|if
name|CMUCS
name|int
modifier|*
name|grps
decl_stmt|;
endif|#
directive|endif
comment|/* CMUCS */
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|namep
operator|==
name|NULL
condition|)
block|{
name|pwd
operator|=
name|getpwuid
argument_list|(
name|fileuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|errbuf
argument_list|,
literal|"Reason:  Unknown user id %d"
argument_list|,
name|fileuid
argument_list|)
expr_stmt|;
return|return
operator|(
name|errbuf
operator|)
return|;
block|}
name|grp
operator|=
name|getgrgid
argument_list|(
name|filegid
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
condition|)
name|group
operator|=
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
else|else
name|group
operator|=
name|NULL
expr_stmt|;
name|account
operator|=
name|NULL
expr_stmt|;
name|pswdp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|nbuf
argument_list|,
name|namep
argument_list|)
expr_stmt|;
name|account
operator|=
name|group
operator|=
name|index
argument_list|(
name|nbuf
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|!=
name|NULL
condition|)
block|{
operator|*
name|group
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|account
operator|=
name|index
argument_list|(
name|group
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|account
operator|!=
name|NULL
condition|)
block|{
operator|*
name|account
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|account
operator|==
literal|'\0'
condition|)
name|account
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|group
operator|==
literal|'\0'
condition|)
name|group
operator|=
name|NULL
expr_stmt|;
block|}
name|pwd
operator|=
name|getpwnam
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|errbuf
argument_list|,
literal|"Reason:  Unknown user %s"
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|errbuf
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|nbuf
argument_list|,
name|DEFUSER
argument_list|)
operator|==
literal|0
condition|)
name|pswdp
operator|=
name|NULL
expr_stmt|;
else|else
name|pswdp
operator|=
name|passwordp
condition|?
name|passwordp
else|:
literal|""
expr_stmt|;
ifdef|#
directive|ifdef
name|AFS
if|if
condition|(
name|strcmp
argument_list|(
name|nbuf
argument_list|,
name|DEFUSER
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|reason
decl_stmt|;
name|setpag
argument_list|()
expr_stmt|;
comment|/* set a pag */
if|if
condition|(
name|ka_UserAuthenticate
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
name|pswdp
argument_list|,
literal|1
argument_list|,
operator|&
name|reason
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|errbuf
argument_list|,
literal|"AFS authentication failed, %s"
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|logerr
argument_list|(
literal|"Attempt by %s; %s"
argument_list|,
name|nbuf
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|errbuf
operator|)
return|;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|getuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|getuid
argument_list|()
operator|==
name|pwd
operator|->
name|pw_uid
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|DEFUSER
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|logerr
argument_list|(
literal|"Fileserver not superuser"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|"Reason:  fileserver is not running privileged"
operator|)
return|;
block|}
if|#
directive|if
name|CMUCS
name|tlc
operator|.
name|tlc_hostid
operator|=
name|TLC_UNKHOST
expr_stmt|;
name|tlc
operator|.
name|tlc_ttyid
operator|=
name|TLC_UNKTTY
expr_stmt|;
if|if
condition|(
name|okaccess
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|ACCESS_TYPE_SU
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|tlc
argument_list|)
operator|!=
literal|1
condition|)
name|status
operator|=
name|ACCESS_CODE_DENIED
expr_stmt|;
else|else
block|{
name|grp
operator|=
name|NULL
expr_stmt|;
name|acc
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|oklogin
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|group
argument_list|,
operator|&
name|account
argument_list|,
name|pswdp
argument_list|,
operator|&
name|pwd
argument_list|,
operator|&
name|grp
argument_list|,
operator|&
name|acc
argument_list|,
operator|&
name|grps
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|ACCESS_CODE_OK
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|okpassword
argument_list|(
name|pswdp
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|pwd
operator|->
name|pw_gecos
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|status
operator|=
name|ACCESS_CODE_INSECUREPWD
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* CMUCS */
name|status
operator|=
name|ACCESS_CODE_OK
expr_stmt|;
if|if
condition|(
name|namep
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|DEFUSER
argument_list|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|crypt
argument_list|(
name|pswdp
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
argument_list|)
condition|)
name|status
operator|=
name|ACCESS_CODE_BADPASSWORD
expr_stmt|;
endif|#
directive|endif
comment|/* CMUCS */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|ACCESS_CODE_OK
case|:
break|break;
case|case
name|ACCESS_CODE_BADPASSWORD
case|:
name|p
operator|=
literal|"Reason:  Invalid password"
expr_stmt|;
break|break;
if|#
directive|if
name|CMUCS
case|case
name|ACCESS_CODE_INSECUREPWD
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|errbuf
argument_list|,
literal|"Reason:  %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|errbuf
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_DENIED
case|:
name|p
operator|=
literal|"Reason:  Access denied"
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_NOUSER
case|:
name|p
operator|=
name|errbuf
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_ACCEXPIRED
case|:
name|p
operator|=
literal|"Reason:  Account expired"
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_GRPEXPIRED
case|:
name|p
operator|=
literal|"Reason:  Group expired"
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_ACCNOTVALID
case|:
name|p
operator|=
literal|"Reason:  Invalid account"
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_MANYDEFACC
case|:
name|p
operator|=
literal|"Reason:  User has more than one default account"
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_NOACCFORGRP
case|:
name|p
operator|=
literal|"Reason:  No account for group"
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_NOGRPFORACC
case|:
name|p
operator|=
literal|"Reason:  No group for account"
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_NOGRPDEFACC
case|:
name|p
operator|=
literal|"Reason:  No group for default account"
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_NOTGRPMEMB
case|:
name|p
operator|=
literal|"Reason:  Not member of group"
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_NOTDEFMEMB
case|:
name|p
operator|=
literal|"Reason:  Not member of default group"
expr_stmt|;
break|break;
case|case
name|ACCESS_CODE_OOPS
case|:
name|p
operator|=
literal|"Reason:  Internal error"
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* CMUCS */
default|default:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
operator|=
name|errbuf
argument_list|,
literal|"Reason:  Status %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
name|status
operator|!=
name|ACCESS_CODE_OK
condition|)
block|{
name|logerr
argument_list|(
literal|"Login failure for %s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|logerr
argument_list|(
literal|"%s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
name|CMUCS
name|logaccess
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|ACCESS_TYPE_SUP
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|tlc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CMUCS */
return|return
operator|(
name|p
operator|)
return|;
block|}
if|#
directive|if
name|CMUCS
if|if
condition|(
name|setgroups
argument_list|(
name|grps
index|[
literal|0
index|]
argument_list|,
operator|&
name|grps
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
name|logerr
argument_list|(
literal|"setgroups: %%m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setgid
argument_list|(
operator|(
name|gid_t
operator|)
name|grp
operator|->
name|gr_gid
argument_list|)
operator|<
literal|0
condition|)
name|logerr
argument_list|(
literal|"setgid: %%m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
operator|(
name|uid_t
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|)
operator|<
literal|0
condition|)
name|logerr
argument_list|(
literal|"setuid: %%m"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* CMUCS */
if|if
condition|(
name|initgroups
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|"Error setting group list"
operator|)
return|;
if|if
condition|(
name|setgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
operator|<
literal|0
condition|)
name|logerr
argument_list|(
literal|"setgid: %%m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setuid
argument_list|(
name|pwd
operator|->
name|pw_uid
argument_list|)
operator|<
literal|0
condition|)
name|logerr
argument_list|(
literal|"setuid: %%m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CMUCS */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|void
name|goaway
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS*/
comment|/*ARGSUSED*/
function|goaway
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
if|#
directive|if
operator|!
name|__STDC__
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|goawayreason
operator|=
name|salloc
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|msggoaway
argument_list|()
expr_stmt|;
name|logerr
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|fmttime
parameter_list|(
name|time
parameter_list|)
name|long
name|time
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|ctime
argument_list|(
operator|&
name|time
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
operator|+
literal|4
argument_list|)
operator|-
literal|6
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
literal|4
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether the file referenced by the file descriptor 'handle' can  * be trusted, namely is it a file resident in the local file system.  *  * The main method of operation is to perform operations on the file  * descriptor so that an attempt to spoof the checks should fail, for  * example renamimg the file from underneath us and/or changing where the  * file lives from underneath us.  *  * returns: -1 for error, indicating that we can not tell  *	     0 for file is definately not local, or it is an RFS link  *	     1 for file is local and can be trusted  *  * Side effect: copies the stat information into the supplied buffer,  * regardless of the type of file system the file resides.  *  * Currently, the cases that we try to distinguish are RFS, AFS, NFS and  * UFS, where the latter is considered a trusted file.  We assume that the  * caller has disabled link following and will detect an attempt to access  * a file through an RFS link, except in the case the the last component is  * an RFS link.  With link following disabled, the last component itself is  * interpreted as a regular file if it is really an RFS link, so we  * disallow the RFS link identified by group "symlink" and mode "IEXEC by  * owner only". An AFS file is  * detected by trying the VIOCIGETCELL ioctl, which is one of the few AFS  * ioctls which operate on a file descriptor.  Note, this AFS ioctl is  * implemented in the cache manager, so the decision does not involve a  * query with the AFS file server.  An NFS file is detected by looking at  * the major device number and seeing if it matches the known values for  * MACH NSF/Sun OS 3.x or Sun OS 4.x.  *  * Having the fstatfs() system call would make this routine easier and  * more reliable.  *  * Note, in order to make the checks simpler, the file referenced by the  * file descriptor can not be a BSD style symlink.  Even with symlink  * following of the last path component disabled, the attempt to open a  * file which is a symlink will succeed, so we check for the BSD symlink  * file type here.  Also, the link following on/off and RFS file types  * are only relevant in a MACH environment.   */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/viceioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SYMLINK_GRP
value|64
end_define

begin_function
name|int
name|local_file
parameter_list|(
name|handle
parameter_list|,
name|sinfo
parameter_list|)
name|int
name|handle
decl_stmt|;
name|struct
name|stat
modifier|*
name|sinfo
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
ifdef|#
directive|ifdef
name|VIOCIGETCELL
comment|/* 	 * dummies for the AFS ioctl 	 */
name|struct
name|ViceIoctl
name|vdata
decl_stmt|;
name|char
name|cellname
index|[
literal|512
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* VIOCIGETCELL */
if|if
condition|(
name|fstat
argument_list|(
name|handle
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|sinfo
operator|!=
name|NULL
condition|)
operator|*
name|sinfo
operator|=
name|sb
expr_stmt|;
if|#
directive|if
name|CMUCS
comment|/* 	 * If the following test succeeds, then the file referenced by 	 * 'handle' is actually an RFS link, so we will not trust it. 	 * See<sys/inode.h>. 	 */
if|if
condition|(
name|sb
operator|.
name|st_gid
operator|==
name|SYMLINK_GRP
operator|&&
operator|(
name|sb
operator|.
name|st_mode
operator|&
operator|(
name|S_IFMT
operator||
name|S_IEXEC
operator||
operator|(
name|S_IEXEC
operator|>>
literal|3
operator|)
operator||
operator|(
name|S_IEXEC
operator|>>
literal|6
operator|)
operator|)
operator|)
operator|==
operator|(
name|S_IFREG
operator||
name|S_IEXEC
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* CMUCS */
comment|/* 	 * Do not trust BSD style symlinks either. 	 */
if|if
condition|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|VIOCIGETCELL
comment|/* 	 * This is the VIOCIGETCELL ioctl, which takes an fd, not 	 * a path name.  If it succeeds, then the file is in AFS. 	 * 	 * On failure, ENOTTY indicates that the file was not in 	 * AFS; all other errors are pessimistically assumed to be 	 * a temporary AFS error. 	 */
name|vdata
operator|.
name|in_size
operator|=
literal|0
expr_stmt|;
name|vdata
operator|.
name|out_size
operator|=
sizeof|sizeof
argument_list|(
name|cellname
argument_list|)
expr_stmt|;
name|vdata
operator|.
name|out
operator|=
name|cellname
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|handle
argument_list|,
name|VIOCIGETCELL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|vdata
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|errno
operator|!=
name|ENOTTY
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
comment|/* VIOCIGETCELL */
comment|/* 	 * Verify the file is not in NFS. 	 * 	 * Our current implementation and Sun OS 3.x use major device 	 * 255 for NFS files; Sun OS 4.x seems to use 130 (I have only 	 * determined this empirically -- DLC).  Without a fstatfs() 	 * system call, this will have to do for now. 	 */
if|if
condition|(
name|major
argument_list|(
name|sb
operator|.
name|st_dev
argument_list|)
operator|==
literal|255
operator|||
name|major
argument_list|(
name|sb
operator|.
name|st_dev
argument_list|)
operator|==
literal|130
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Companion routine for ensuring that a local file can be trusted.  Compare  * various pieces of the stat information to make sure that the file can be  * trusted.  Returns true for stat information which meets the criteria  * for being trustworthy.  The main paranoia is to prevent a hard link to  * a root owned file.  Since the link could be removed after the file is  * opened, a simply fstat() can not be relied upon.  The two stat buffers  * for comparison should come from a stat() on the file name and a following  * fstat() on the open file.  Some of the following checks are also an  * additional level of paranoia.  Also, this test will fail (correctly) if  * either or both of the stat structures have all fields zeroed; typically  * due to a stat() failure.  */
end_comment

begin_function
name|int
name|stat_info_ok
parameter_list|(
name|sb1
parameter_list|,
name|sb2
parameter_list|)
name|struct
name|stat
modifier|*
name|sb1
decl_stmt|,
decl|*
name|sb2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|sb1
operator|->
name|st_ino
operator|==
name|sb2
operator|->
name|st_ino
operator|&&
comment|/* Still the same file */
name|sb1
operator|->
name|st_dev
operator|==
name|sb2
operator|->
name|st_dev
operator|&&
comment|/* On the same device */
name|sb1
operator|->
name|st_mode
operator|==
name|sb2
operator|->
name|st_mode
operator|&&
comment|/* Perms (and type) same */
operator|(
name|sb1
operator|->
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|&&
comment|/* Only allow reg files */
operator|(
name|sb1
operator|->
name|st_mode
operator|&
literal|077
operator|)
operator|==
literal|0
operator|&&
comment|/* Owner only perms */
name|sb1
operator|->
name|st_nlink
operator|==
name|sb2
operator|->
name|st_nlink
operator|&&
comment|/* # hard links same... */
name|sb1
operator|->
name|st_nlink
operator|==
literal|1
operator|&&
comment|/* and only 1 */
name|sb1
operator|->
name|st_uid
operator|==
name|sb2
operator|->
name|st_uid
operator|&&
comment|/* owner and ... */
name|sb1
operator|->
name|st_gid
operator|==
name|sb2
operator|->
name|st_gid
operator|&&
comment|/* group unchanged */
name|sb1
operator|->
name|st_mtime
operator|==
name|sb2
operator|->
name|st_mtime
operator|&&
comment|/* Unmodified between stats */
name|sb1
operator|->
name|st_ctime
operator|==
name|sb2
operator|->
name|st_ctime
operator|)
return|;
comment|/* Inode unchanged.  Hopefully 						   a catch-all paranoid test */
block|}
end_block

begin_if
if|#
directive|if
name|MACH
end_if

begin_comment
comment|/*  * Twiddle symbolic/RFS link following on/off.  This is a no-op in a non  * CMUCS/MACH environment.  Also, the setmodes/getmodes interface is used  * mainly because it is simpler than using table(2) directly.  */
end_comment

begin_include
include|#
directive|include
file|<sys/table.h>
end_include

begin_function
name|int
name|link_nofollow
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
specifier|static
name|int
name|modes
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|modes
operator|==
operator|-
literal|1
operator|&&
operator|(
name|modes
operator|=
name|getmodes
argument_list|()
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|on
condition|)
return|return
operator|(
name|setmodes
argument_list|(
name|modes
operator||
name|UMODE_NOFOLLOW
argument_list|)
operator|)
return|;
return|return
operator|(
name|setmodes
argument_list|(
name|modes
argument_list|)
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MACH */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|link_nofollow
parameter_list|(
name|on
parameter_list|)
name|int
name|on
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MACH */
end_comment

end_unit

