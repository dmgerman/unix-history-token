begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software_Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * sup "meat" routines  **********************************************************************  * HISTORY  *  * 7-July-93  Nate Williams at Montana State University  *	Modified SUP to use gzip based compression when sending files  *	across the network to save BandWidth  *  * $Log: supcmeat.c,v $  * Revision 1.2  1995/12/26 05:03:05  peter  * Apply ports/net/sup/patches/patch-aa...  *  * Revision 1.1.1.1  1995/12/26 04:54:46  peter  * Import the unmodified version of the sup that we are using.  * The heritage of this version is not clear.  It appears to be NetBSD  * derived from some time ago.  *  * Revision 1.4  1994/08/11  02:46:23  rich  * Added extensions written by David Dawes.  From the man page:  *  * The -u flag, or the noupdate supfile option prevent updates from  * occurring for regular files where the modification time and mode  * hasn't changed.  *  * Now, how do we feed these patches back to CMU for consideration?  *  * Revision 1.3  1994/06/20  06:04:09  rgrimes  * Humm.. they did a lot of #if __STDC__ but failed to properly prototype  * the code.  Also fixed one bad argument to a wait3 call.  *  * It won't compile -Wall, but atleast it compiles standard without warnings  * now.  *  * Revision 1.2  1994/05/25  17:58:38  nate  * From Gene Stark  *  * system() returns non-zero status for errors, so check for non-zero  * status instead of< 0 which causes gzip/gunzip failures not to be noticed.  *  * Revision 1.1.1.1  1993/08/21  00:46:34  jkh  * Current sup with compression support.  *  * Revision 1.2  1993/05/24  18:57:50  brezak  * Use /var/tmp for NetBSD  *  * Revision 1.1.1.1  1993/05/21  14:52:18  cgd  * initial import of CMU's SUP to NetBSD  *  * Revision 1.16  92/09/09  22:04:51  mrt  * 	Really added bww's recvone changes this time.   * 	Added code to support non-crypting version of sup.  * 	[92/09/01            mrt]  *   * Revision 1.15  92/08/11  12:07:09  mrt  * 	Added support to add release to FILEWHEN name.  * 	Updated variable arguemnt list usage - bww  * 	Updated recvone() to take a va_list - bww  * 	Changed conditional for rpausing code from CMUCS to MACH  * 	[92/07/24            mrt]  *   * Revision 1.14  92/02/08  18:24:12  mja  * 	Only apply "keep" mode when local file is strictly newer  * 	otherwise allow update as before if necessary.  * 	[92/02/08  18:09:00  mja]  *   * 	Added support for -k (keep) option to needone().  Rewrote and  * 	commented other parts of needone().  * 	[92/01/17            vdelvecc]  *   * Revision 1.13  91/05/16  14:49:41  ern  * 	Add timestap to fileserver.  * 	Drop day of the week from 5 messages.  * 	[91/05/16  14:47:53  ern]  *   * Revision 1.12  89/08/23  14:55:44  gm0w  * 	Changed msgf routines to msg routines.  * 	[89/08/23            gm0w]  *   * Revision 1.11  89/08/03  19:49:10  mja  * 	Updated to use v*printf() in place of _doprnt().  * 	[89/04/19            mja]  *   * Revision 1.10  89/06/18  14:41:27  gm0w  * 	Fixed up some notify messages of errors to use "SUP:" prefix.  * 	[89/06/18            gm0w]  *   * Revision 1.9  89/06/10  15:12:17  gm0w  * 	Changed to always use rename to install targets.  This breaks hard  * 	links and recreates those known to sup, other links will be orphaned.  * 	[89/06/10            gm0w]  *   * Revision 1.8  89/05/24  15:04:23  gm0w  * 	Added code to check for EINVAL from FSPARAM ioctl for disk  * 	space check failures when the ioctl is not implemented.  * 	[89/05/24            gm0w]  *   * Revision 1.7  89/01/16  18:22:28  gm0w  * 	Changed needone() to check that mode of files match before  * 	setting update if times also match.  * 	[89/01/16            gm0w]  *   * 10-Feb-88  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added timeout to backoff.  *  * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added crosspatch support.  *  * 09-Sep-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to be less verbose when updating files that have  *	already been successfully upgraded.  *  * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code for "release" support.  *  * 26-May-87  Doug Philips (dwp) at Carnegie-Mellon University  *	Converted to end connection with more information.  *	Added done routine.  Modified goaway routine to free old  *	goawayreason.  *  * 26-May-87  Doug Philips (dwp) at Carnegie-Mellon University  *	Use computeBackoff from scm instead of doing it ourselves.  *  * 25-May-87  Doug Philips (dwp) at Carnegie-Mellon University  *	Split off from sup.c and reindented goaway calls.  *  **********************************************************************  */
end_comment

begin_include
include|#
directive|include
file|"supcdefs.h"
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|TREE
modifier|*
name|lastT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last filenames in collection */
end_comment

begin_decl_stmt
name|jmp_buf
name|sjbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* jump location for network errors */
end_comment

begin_decl_stmt
name|int
name|dontjump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag to void sjbuf */
end_comment

begin_decl_stmt
name|int
name|cancompress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Can we do compression? */
end_comment

begin_decl_stmt
name|int
name|docompress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do we do compression? */
end_comment

begin_decl_stmt
name|int
name|dounlinkbusy
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we try to unlink busy files?*/
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|renamelog
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where we log renamed files */
end_comment

begin_decl_stmt
specifier|extern
name|COLLECTION
modifier|*
name|thisC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* collection list pointer */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|rpauseflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't disable resource pausing */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|portdebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* network debugging ports */
end_comment

begin_comment
comment|/*************************************************  ***    U P G R A D E   C O L L E C T I O N    ***  *************************************************/
end_comment

begin_comment
comment|/* The next two routines define the fsm to support multiple fileservers  * per collection.  */
end_comment

begin_expr_stmt
name|getonehost
argument_list|(
name|t
argument_list|,
name|state
argument_list|)
specifier|register
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|state
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|t
operator|->
name|Tflags
operator|!=
operator|*
name|state
condition|)
return|return
operator|(
name|SCMOK
operator|)
return|;
if|if
condition|(
operator|*
name|state
operator|!=
literal|0
operator|&&
name|t
operator|->
name|Tmode
operator|==
name|SCMEOF
condition|)
block|{
name|t
operator|->
name|Tflags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|state
operator|==
literal|2
condition|)
name|t
operator|->
name|Tflags
operator|--
expr_stmt|;
else|else
name|t
operator|->
name|Tflags
operator|++
expr_stmt|;
name|thisC
operator|->
name|Chost
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|SCMEOF
operator|)
return|;
block|}
end_block

begin_function
name|TREE
modifier|*
name|getcollhost
parameter_list|(
name|tout
parameter_list|,
name|backoff
parameter_list|,
name|state
parameter_list|,
name|nhostsp
parameter_list|)
name|int
modifier|*
name|tout
decl_stmt|,
decl|*
name|backoff
decl_stmt|,
modifier|*
name|state
decl_stmt|,
modifier|*
name|nhostsp
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|int
name|laststate
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|nhosts
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|state
operator|!=
name|laststate
condition|)
block|{
operator|*
name|nhostsp
operator|=
name|nhosts
expr_stmt|;
name|laststate
operator|=
operator|*
name|state
expr_stmt|;
name|nhosts
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|Tprocess
argument_list|(
name|thisC
operator|->
name|Chtree
argument_list|,
name|getonehost
argument_list|,
operator|*
name|state
argument_list|)
operator|==
name|SCMEOF
condition|)
block|{
if|if
condition|(
operator|*
name|state
operator|!=
literal|0
operator|&&
name|nhosts
operator|==
literal|0
operator|&&
operator|!
name|dobackoff
argument_list|(
name|tout
argument_list|,
name|backoff
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|nhosts
operator|++
expr_stmt|;
return|return
operator|(
name|thisC
operator|->
name|Chost
operator|)
return|;
block|}
if|if
condition|(
name|nhosts
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|state
operator|==
literal|2
condition|)
operator|(
operator|*
name|state
operator|)
operator|--
expr_stmt|;
else|else
operator|(
operator|*
name|state
operator|)
operator|++
expr_stmt|;
return|return
operator|(
name|getcollhost
argument_list|(
name|tout
argument_list|,
name|backoff
argument_list|,
name|state
argument_list|,
name|nhostsp
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  Upgrade a collection from the file server on the appropriate  *  host machine.  */
end_comment

begin_macro
name|getcoll
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|TREE
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|tout
decl_stmt|,
name|backoff
decl_stmt|,
name|state
decl_stmt|,
name|nhosts
decl_stmt|;
name|collname
operator|=
name|thisC
operator|->
name|Cname
expr_stmt|;
name|tout
operator|=
name|thisC
operator|->
name|Ctimeout
expr_stmt|;
name|lastT
operator|=
name|NULL
expr_stmt|;
name|backoff
operator|=
literal|2
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
name|nhosts
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|t
operator|=
name|getcollhost
argument_list|(
operator|&
name|tout
argument_list|,
operator|&
name|backoff
argument_list|,
operator|&
name|state
argument_list|,
operator|&
name|nhosts
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|finishup
argument_list|(
name|SCMEOF
argument_list|)
expr_stmt|;
name|notify
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|->
name|Tmode
operator|=
name|SCMEOF
expr_stmt|;
name|dontjump
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
operator|&&
operator|!
name|signon
argument_list|(
name|t
argument_list|,
name|nhosts
argument_list|,
operator|&
name|tout
argument_list|)
operator|&&
operator|!
name|setup
argument_list|(
name|t
argument_list|)
condition|)
break|break;
operator|(
name|void
operator|)
name|requestend
argument_list|()
expr_stmt|;
block|}
name|dontjump
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|sjbuf
argument_list|)
condition|)
name|x
operator|=
name|SCMERR
expr_stmt|;
else|else
block|{
name|login
argument_list|()
expr_stmt|;
name|listfiles
argument_list|()
expr_stmt|;
name|recvfiles
argument_list|()
expr_stmt|;
name|x
operator|=
name|SCMOK
expr_stmt|;
block|}
if|if
condition|(
name|thisC
operator|->
name|Clockfd
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|thisC
operator|->
name|Clockfd
argument_list|)
expr_stmt|;
name|thisC
operator|->
name|Clockfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|finishup
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|notify
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***  Sign on to file server ***/
end_comment

begin_function
name|int
name|signon
parameter_list|(
name|t
parameter_list|,
name|nhosts
parameter_list|,
name|tout
parameter_list|)
specifier|register
name|TREE
modifier|*
name|t
decl_stmt|;
name|int
name|nhosts
decl_stmt|;
name|int
modifier|*
name|tout
decl_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|long
name|tloc
decl_stmt|;
if|if
condition|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLOCAL
operator|)
operator|==
literal|0
operator|&&
name|thishost
argument_list|(
name|thisC
operator|->
name|Chost
operator|->
name|Tname
argument_list|)
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP: Skipping local collection %s\n"
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tmode
operator|=
name|SCMEOF
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|nhosts
operator|==
literal|1
condition|)
name|timeout
operator|=
operator|*
name|tout
expr_stmt|;
else|else
name|timeout
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|request
argument_list|(
name|portdebug
condition|?
name|DEBUGFPORT
else|:
name|FILEPORT
argument_list|,
name|thisC
operator|->
name|Chost
operator|->
name|Tname
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhosts
operator|==
literal|1
condition|)
operator|*
name|tout
operator|=
name|timeout
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
block|{
if|if
condition|(
name|nhosts
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Can't connect to host %s\n"
argument_list|,
name|thisC
operator|->
name|Chost
operator|->
name|Tname
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tmode
operator|=
name|SCMEOF
expr_stmt|;
block|}
else|else
name|t
operator|->
name|Tmode
operator|=
name|SCMOK
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|xpatch
operator|=
name|FALSE
expr_stmt|;
name|x
operator|=
name|msgsignon
argument_list|()
expr_stmt|;
comment|/* signon to fileserver */
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending signon request to fileserver"
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgsignonack
argument_list|()
expr_stmt|;
comment|/* receive signon ack from fileserver */
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading signon reply from fileserver"
argument_list|)
expr_stmt|;
name|tloc
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|vnotify
argument_list|(
literal|"SUP Fileserver %d.%d (%s) %d on %s at %.8s\n"
argument_list|,
name|protver
argument_list|,
name|pgmver
argument_list|,
name|scmver
argument_list|,
name|fspid
argument_list|,
name|remotehost
argument_list|()
argument_list|,
name|ctime
argument_list|(
operator|&
name|tloc
argument_list|)
operator|+
literal|11
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scmver
argument_list|)
expr_stmt|;
name|scmver
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|protver
operator|<
literal|4
condition|)
block|{
name|dontjump
operator|=
name|TRUE
expr_stmt|;
name|goaway
argument_list|(
literal|"Fileserver sup protocol version is obsolete."
argument_list|)
expr_stmt|;
name|notify
argument_list|(
literal|"SUP: This version of sup can only communicate with a fileserver using at least\n"
argument_list|)
expr_stmt|;
name|notify
argument_list|(
literal|"SUP: version 4 of the sup network protocol.  You should either run a newer\n"
argument_list|)
expr_stmt|;
name|notify
argument_list|(
literal|"SUP: version of the sup fileserver or find an older version of sup.\n"
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tmode
operator|=
name|SCMEOF
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* If protocol is> 7 then try compression */
if|if
condition|(
name|protver
operator|>
literal|7
condition|)
block|{
name|cancompress
operator|=
name|TRUE
expr_stmt|;
name|vnotify
argument_list|(
literal|"SUP Fileserver supports compression.\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/***  Tell file server what to connect to ***/
end_comment

begin_expr_stmt
name|setup
argument_list|(
name|t
argument_list|)
specifier|register
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|char
name|relsufix
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|x
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|thisC
operator|->
name|Cbase
argument_list|)
operator|<
literal|0
condition|)
name|goaway
argument_list|(
literal|"Can't change to base directory %s"
argument_list|,
name|thisC
operator|->
name|Cbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"sup"
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|mkdir
argument_list|(
literal|"sup"
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"sup"
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
name|goaway
argument_list|(
literal|"Can't create directory %s/sup"
argument_list|,
name|thisC
operator|->
name|Cbase
argument_list|)
expr_stmt|;
name|vnotify
argument_list|(
literal|"SUP Created directory %s/sup\n"
argument_list|,
name|thisC
operator|->
name|Cbase
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thisC
operator|->
name|Cprefix
operator|&&
name|chdir
argument_list|(
name|thisC
operator|->
name|Cprefix
argument_list|)
operator|<
literal|0
condition|)
name|goaway
argument_list|(
literal|"Can't change to %s from base directory %s"
argument_list|,
name|thisC
operator|->
name|Cprefix
argument_list|,
name|thisC
operator|->
name|Cbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
name|goaway
argument_list|(
literal|"Can't stat %s directory %s"
argument_list|,
name|thisC
operator|->
name|Cprefix
condition|?
literal|"prefix"
else|:
literal|"base"
argument_list|,
name|thisC
operator|->
name|Cprefix
condition|?
name|thisC
operator|->
name|Cprefix
else|:
name|thisC
operator|->
name|Cbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Cprefix
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|thisC
operator|->
name|Cbase
argument_list|)
expr_stmt|;
comment|/* read time of last upgrade from when file */
if|if
condition|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFURELSUF
operator|)
operator|&&
name|thisC
operator|->
name|Crelease
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|relsufix
argument_list|,
literal|".%s"
argument_list|,
name|thisC
operator|->
name|Crelease
argument_list|)
expr_stmt|;
else|else
name|relsufix
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEWHEN
argument_list|,
name|collname
argument_list|,
name|relsufix
argument_list|)
expr_stmt|;
name|f
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lasttime
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
name|lasttime
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|lasttime
operator|=
literal|0
expr_stmt|;
comment|/* setup for msgsetup */
name|basedir
operator|=
name|thisC
operator|->
name|Chbase
expr_stmt|;
name|basedev
operator|=
name|sbuf
operator|.
name|st_dev
expr_stmt|;
name|baseino
operator|=
name|sbuf
operator|.
name|st_ino
expr_stmt|;
name|listonly
operator|=
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
operator|)
expr_stmt|;
name|newonly
operator|=
operator|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
operator|(
name|CFALL
operator||
name|CFDELETE
operator||
name|CFOLD
operator|)
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|release
operator|=
name|thisC
operator|->
name|Crelease
expr_stmt|;
name|x
operator|=
name|msgsetup
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending setup request to file server"
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgsetupack
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading setup reply from file server"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setupack
operator|==
name|FSETUPOK
condition|)
block|{
comment|/* Test encryption */
if|if
condition|(
name|netcrypt
argument_list|(
name|thisC
operator|->
name|Ccrypt
argument_list|)
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Running non-crypting sup"
argument_list|)
expr_stmt|;
name|crypttest
operator|=
name|CRYPTTEST
expr_stmt|;
name|x
operator|=
name|msgcrypt
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending encryption test request"
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgcryptok
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMEOF
condition|)
name|goaway
argument_list|(
literal|"Data encryption test failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading encryption test reply"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
switch|switch
condition|(
name|setupack
condition|)
block|{
case|case
name|FSETUPSAME
case|:
name|notify
argument_list|(
literal|"SUP: Attempt to upgrade from same host to same directory\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|FDONESRVERROR
argument_list|,
literal|"Overwrite error"
argument_list|)
expr_stmt|;
case|case
name|FSETUPHOST
case|:
name|notify
argument_list|(
literal|"SUP: This host has no permission to access %s\n"
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|FDONESRVERROR
argument_list|,
literal|"Permission denied"
argument_list|)
expr_stmt|;
case|case
name|FSETUPOLD
case|:
name|notify
argument_list|(
literal|"SUP: This version of SUP is too old for the fileserver\n"
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|FDONESRVERROR
argument_list|,
literal|"Obsolete client"
argument_list|)
expr_stmt|;
case|case
name|FSETUPRELEASE
case|:
name|notify
argument_list|(
literal|"SUP: Invalid release %s for collection %s\n"
argument_list|,
name|release
operator|==
name|NULL
condition|?
name|DEFRELEASE
else|:
name|release
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|FDONESRVERROR
argument_list|,
literal|"Invalid release"
argument_list|)
expr_stmt|;
case|case
name|FSETUPBUSY
case|:
name|vnotify
argument_list|(
literal|"SUP Fileserver is currently busy\n"
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tmode
operator|=
name|SCMOK
expr_stmt|;
name|doneack
operator|=
name|FDONESRVERROR
expr_stmt|;
name|donereason
operator|=
literal|"Fileserver is busy"
expr_stmt|;
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|msgdone
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
default|default:
name|goaway
argument_list|(
literal|"Unrecognized file server setup status %d"
argument_list|,
name|setupack
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/***  Tell file server what account to use ***/
end_comment

begin_function
name|int
name|login
parameter_list|()
block|{
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
specifier|register
name|int
name|f
decl_stmt|,
name|x
decl_stmt|;
comment|/* lock collection if desired */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILELOCK
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|f
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|flock
argument_list|(
name|f
argument_list|,
operator|(
name|LOCK_EX
operator||
name|LOCK_NB
operator|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
name|goaway
argument_list|(
literal|"Can't lock collection %s"
argument_list|,
name|collname
argument_list|)
expr_stmt|;
if|if
condition|(
name|flock
argument_list|(
name|f
argument_list|,
operator|(
name|LOCK_SH
operator||
name|LOCK_NB
operator|)
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|goaway
argument_list|(
literal|"Collection %s is locked by another sup"
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Can't lock collection %s"
argument_list|,
name|collname
argument_list|)
expr_stmt|;
block|}
name|vnotify
argument_list|(
literal|"SUP Waiting for exclusive access lock\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flock
argument_list|(
name|f
argument_list|,
name|LOCK_EX
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Can't lock collection %s"
argument_list|,
name|collname
argument_list|)
expr_stmt|;
block|}
block|}
name|thisC
operator|->
name|Clockfd
operator|=
name|f
expr_stmt|;
name|vnotify
argument_list|(
literal|"SUP Locked collection %s for exclusive access\n"
argument_list|,
name|collname
argument_list|)
expr_stmt|;
block|}
name|logcrypt
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|loguser
operator|=
name|thisC
operator|->
name|Clogin
expr_stmt|;
name|logpswd
operator|=
name|thisC
operator|->
name|Cpswd
expr_stmt|;
ifndef|#
directive|ifndef
name|CRYPTING
comment|/* Define CRYPTING for backwards compatibility with old supfileservers */
if|if
condition|(
name|thisC
operator|->
name|Clogin
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
comment|/* othewise we only encrypt if there is a login id */
endif|#
directive|endif
comment|/* CRYPTING */
block|{
name|logcrypt
operator|=
name|CRYPTTEST
expr_stmt|;
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
name|PSWDCRYPT
argument_list|)
expr_stmt|;
comment|/* encrypt password data */
block|}
name|x
operator|=
name|msglogin
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|CRYPTING
if|if
condition|(
name|thisC
operator|->
name|Clogin
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* turn off encryption */
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending login request to file server"
argument_list|)
expr_stmt|;
name|x
operator|=
name|msglogack
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading login reply from file server"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logack
operator|==
name|FLOGNG
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: %s\n"
argument_list|,
name|logerror
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|logerror
argument_list|)
expr_stmt|;
name|logerror
operator|=
name|NULL
expr_stmt|;
name|notify
argument_list|(
literal|"SUP: Improper login to %s account"
argument_list|,
name|thisC
operator|->
name|Clogin
condition|?
name|thisC
operator|->
name|Clogin
else|:
literal|"default"
argument_list|)
expr_stmt|;
name|done
argument_list|(
name|FDONESRVERROR
argument_list|,
literal|"Improper login"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netcrypt
argument_list|(
name|thisC
operator|->
name|Ccrypt
argument_list|)
operator|!=
name|SCMOK
condition|)
comment|/* restore encryption */
name|goaway
argument_list|(
literal|"Running non-crypting sup"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  send list of files that we are not interested in.  receive list of  *  files that are on the repository that could be upgraded.  Find the  *  ones that we need.  Receive the list of files that the server could  *  not access.  Delete any files that have been upgraded in the past  *  which are no longer on the repository.  */
end_comment

begin_function
name|int
name|listfiles
parameter_list|()
block|{
name|int
name|needone
argument_list|()
decl_stmt|,
name|denyone
argument_list|()
decl_stmt|,
name|deleteone
argument_list|()
decl_stmt|;
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|char
name|relsufix
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|TREE
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
if|if
condition|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFURELSUF
operator|)
operator|&&
name|release
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|relsufix
argument_list|,
literal|".%s"
argument_list|,
name|release
argument_list|)
expr_stmt|;
else|else
name|relsufix
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILELAST
argument_list|,
name|collname
argument_list|,
name|relsufix
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|r
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
condition|)
operator|*
name|r
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|t
operator|=
name|Tinsert
argument_list|(
operator|&
name|lastT
argument_list|,
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|&&
name|r
condition|)
block|{
name|t
operator|->
name|Tnewname
operator|=
name|salloc
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tflags
operator|=
name|FRENAME
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|refuseT
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEREFUSE
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|Tinsert
argument_list|(
operator|&
name|refuseT
argument_list|,
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
name|vnotify
argument_list|(
literal|"SUP Requesting changes since %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|lasttime
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgrefuse
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending refuse list to file server"
argument_list|)
expr_stmt|;
name|listT
operator|=
name|NULL
expr_stmt|;
name|x
operator|=
name|msglist
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading file list from file server"
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Cprefix
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|thisC
operator|->
name|Cprefix
argument_list|)
expr_stmt|;
name|needT
operator|=
name|NULL
expr_stmt|;
name|renameT
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|listT
argument_list|,
name|needone
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|listT
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgneed
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending needed files list to file server"
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|needT
argument_list|)
expr_stmt|;
name|denyT
operator|=
name|NULL
expr_stmt|;
name|x
operator|=
name|msgdeny
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error reading denied files list from file server"
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFVERBOSE
condition|)
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|denyT
argument_list|,
name|denyone
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|denyT
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
operator|(
name|CFALL
operator||
name|CFDELETE
operator||
name|CFOLD
operator|)
condition|)
operator|(
name|void
operator|)
name|Trprocess
argument_list|(
name|lastT
argument_list|,
name|deleteone
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|refuseT
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|renameT
argument_list|)
expr_stmt|;
name|renameT
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|needone
argument_list|(
name|t
argument_list|)
specifier|register
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|TREE
modifier|*
name|newt
decl_stmt|;
specifier|register
name|int
name|exists
decl_stmt|,
name|fetch
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|newt
operator|=
name|Tinsert
argument_list|(
operator|&
name|lastT
argument_list|,
name|t
operator|->
name|Tname
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|newt
operator|->
name|Tflags
operator||=
name|FUPDATE
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FRENAME
condition|)
block|{
name|newt
operator|->
name|Tflags
operator||=
name|FRENAME
expr_stmt|;
name|newt
operator|->
name|Tnewname
operator|=
name|salloc
argument_list|(
name|t
operator|->
name|Tnewname
argument_list|)
expr_stmt|;
name|name
operator|=
name|t
operator|->
name|Tnewname
expr_stmt|;
name|Tinsert
argument_list|(
operator|&
name|renameT
argument_list|,
name|t
operator|->
name|Tnewname
argument_list|)
expr_stmt|;
block|}
else|else
name|name
operator|=
name|t
operator|->
name|Tname
expr_stmt|;
name|fetch
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFALL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNEW
operator|)
operator|==
literal|0
operator|&&
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFOLD
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|SCMOK
operator|)
return|;
if|if
condition|(
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
name|exists
operator|=
operator|(
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
else|else
name|exists
operator|=
operator|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* This is moderately complicated: 		   If the file is the wrong type or doesn't exist, we need to 		   fetch the whole file.  If the file is a special file, we 		   rely solely on the server:  if the file changed, we do an 		   update; otherwise nothing. If the file is a normal file, 		   we check timestamps.  If we are in "keep" mode, we fetch if 		   the file on the server is newer, and do nothing otherwise. 		   Otherwise, we fetch if the timestamp is wrong; if the file 		   changed on the server but the timestamp is right, we do an 		   update.  (Update refers to updating stat information, i.e. 		   timestamp, owner, mode bits, etc.) */
if|if
condition|(
name|exists
operator|&&
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
condition|)
if|if
condition|(
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FNEW
condition|)
name|fetch
operator|=
name|FALSE
expr_stmt|;
else|else
return|return
operator|(
name|SCMOK
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFKEEP
operator|)
operator|&&
name|sbuf
operator|.
name|st_mtime
operator|>
name|t
operator|->
name|Tmtime
condition|)
return|return
operator|(
name|SCMOK
operator|)
return|;
elseif|else
if|if
condition|(
name|sbuf
operator|.
name|st_mtime
operator|==
name|t
operator|->
name|Tmtime
condition|)
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FNEW
condition|)
name|fetch
operator|=
name|FALSE
expr_stmt|;
else|else
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
comment|/* If we get this far, we're either doing an update or a full fetch. */
name|newt
operator|=
name|Tinsert
argument_list|(
operator|&
name|needT
argument_list|,
name|t
operator|->
name|Tname
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fetch
operator|&&
name|t
operator|->
name|Tmode
operator|==
name|sbuf
operator|.
name|st_mode
operator|&&
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|&&
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFNOUPDATE
operator|)
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP update avoided for %s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|fetch
operator|&&
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
name|newt
operator|->
name|Tflags
operator||=
name|FUPDATE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|denyone
argument_list|(
name|t
argument_list|)
specifier|register
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|notify
argument_list|(
literal|"SUP: Access denied to %s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_macro
name|deleteone
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TREE
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
init|=
name|t
operator|->
name|Tflags
operator|&
name|FRENAME
condition|?
name|t
operator|->
name|Tnewname
else|:
name|t
operator|->
name|Tname
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FUPDATE
condition|)
comment|/* in current upgrade list */
return|return
operator|(
name|SCMOK
operator|)
return|;
if|if
condition|(
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
comment|/* doesn't exist */
return|return
operator|(
name|SCMOK
operator|)
return|;
if|if
condition|(
name|Tlookup
argument_list|(
name|renameT
argument_list|,
name|name
argument_list|)
condition|)
comment|/* it is a file we're going to replace 	        return (SCMOK);          * by renaming another target. 		                         */
comment|/* is it a symbolic link ? */
if|if
condition|(
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
block|{
if|if
condition|(
name|Tlookup
argument_list|(
name|refuseT
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would not delete symbolic link %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would delete symbolic link %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFDELETE
operator|)
operator|==
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP Please delete symbolic link %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tflags
operator||=
name|FUPDATE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|x
operator|=
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Unable to delete symbolic link %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tflags
operator||=
name|FUPDATE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|vnotify
argument_list|(
literal|"SUP Deleted symbolic link %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
comment|/* is it a directory ? */
if|if
condition|(
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
if|if
condition|(
name|Tlookup
argument_list|(
name|refuseT
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would not delete directory %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would delete directory %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFDELETE
operator|)
operator|==
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP Please delete directory %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tflags
operator||=
name|FUPDATE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|rmdir
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Unable to delete directory %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tflags
operator||=
name|FUPDATE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|vnotify
argument_list|(
literal|"SUP Deleted directory %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
comment|/* it is a file */
if|if
condition|(
name|Tlookup
argument_list|(
name|refuseT
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would not delete file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would delete file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFDELETE
operator|)
operator|==
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP Please delete file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tflags
operator||=
name|FUPDATE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|x
operator|=
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Unable to delete file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tflags
operator||=
name|FUPDATE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|vnotify
argument_list|(
literal|"SUP Deleted file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_comment
comment|/***************************************  ***    R E C E I V E   F I L E S    ***  ***************************************/
end_comment

begin_comment
comment|/* Note for these routines, return code SCMOK generally means  * NETWORK communication is OK; it does not mean that the current  * file was correctly received and stored.  If a file gets messed  * up, too bad, just print a message and go on to the next one;  * but if the network gets messed up, the whole sup program loses  * badly and best just stop the program as soon as possible.  */
end_comment

begin_macro
name|recvfiles
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|recvone
parameter_list|()
function_decl|;
name|int
name|recvmore
decl_stmt|;
comment|/* Does the protocol support compression */
if|if
condition|(
name|cancompress
condition|)
block|{
comment|/* Check for compression on sending files */
name|docompress
operator|=
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFCOMPRESS
operator|)
expr_stmt|;
name|x
operator|=
name|msgcompress
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending compression check to server"
argument_list|)
expr_stmt|;
if|if
condition|(
name|docompress
condition|)
name|vnotify
argument_list|(
literal|"SUP Using compressed file transfer\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Should we attempt to unlink files that are busy? */
name|dounlinkbusy
operator|=
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFUNLINKBUSY
operator|)
expr_stmt|;
if|if
condition|(
name|dounlinkbusy
condition|)
name|vnotify
argument_list|(
literal|"SUP Will attempt to unlink busy files\n"
argument_list|)
expr_stmt|;
name|recvmore
operator|=
name|TRUE
expr_stmt|;
name|upgradeT
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|x
operator|=
name|msgsend
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error sending receive file request to file server"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tinsert
argument_list|(
operator|&
name|upgradeT
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|x
operator|=
name|msgrecv
argument_list|(
name|recvone
argument_list|,
operator|&
name|recvmore
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Error receiving file from file server"
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|upgradeT
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|recvmore
condition|)
do|;
if|if
condition|(
name|renamelog
condition|)
name|fclose
argument_list|(
name|renamelog
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* prepare the target, if necessary */
end_comment

begin_macro
name|prepare
argument_list|(
argument|name
argument_list|,
argument|mode
argument_list|,
argument|newp
argument_list|,
argument|statp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|,
modifier|*
name|newp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|stat
modifier|*
name|statp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|S_IFLNK
condition|)
operator|*
name|newp
operator|=
operator|(
name|lstat
argument_list|(
name|name
argument_list|,
name|statp
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
else|else
operator|*
name|newp
operator|=
operator|(
name|stat
argument_list|(
name|name
argument_list|,
name|statp
argument_list|)
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|newp
condition|)
block|{
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|establishdir
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|mode
operator|==
operator|(
name|statp
operator|->
name|st_mode
operator|&
name|S_IFMT
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
operator|*
name|newp
operator|=
name|TRUE
expr_stmt|;
switch|switch
condition|(
name|statp
operator|->
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFDIR
case|:
name|type
operator|=
literal|"directory"
expr_stmt|;
break|break;
case|case
name|S_IFLNK
case|:
name|type
operator|=
literal|"symbolic link"
expr_stmt|;
break|break;
case|case
name|S_IFREG
case|:
name|type
operator|=
literal|"regular file"
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"unknown file"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would remove %s %s\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|statp
operator|->
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
if|if
condition|(
name|rmdir
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
name|runp
argument_list|(
literal|"rm"
argument_list|,
literal|"rm"
argument_list|,
literal|"-rf"
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
name|statp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Removed %s %s\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|notify
argument_list|(
literal|"SUP: Couldn't remove %s %s\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|recvone
argument_list|(
name|t
argument_list|,
name|ap
argument_list|)
specifier|register
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|va_list
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|new
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|int
name|linkone
argument_list|()
decl_stmt|,
name|execone
argument_list|()
decl_stmt|;
name|int
modifier|*
name|recvmore
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* check for end of file list */
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
operator|*
name|recvmore
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
comment|/* check for failed access at fileserver */
if|if
condition|(
name|t
operator|->
name|Tmode
operator|==
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: File server unable to transfer file %s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
name|thisC
operator|->
name|Cnogood
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|name
operator|=
name|t
operator|->
name|Tflags
operator|&
name|FRENAME
condition|?
name|t
operator|->
name|Tnewname
else|:
name|t
operator|->
name|Tname
expr_stmt|;
if|if
condition|(
name|prepare
argument_list|(
name|name
argument_list|,
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
argument_list|,
operator|&
name|new
argument_list|,
operator|&
name|sbuf
argument_list|)
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Can't prepare path for %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
block|{
name|x
operator|=
name|readskip
argument_list|()
expr_stmt|;
comment|/* skip over file */
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Can't skip file transfer"
argument_list|)
expr_stmt|;
block|}
name|thisC
operator|->
name|Cnogood
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
comment|/* make file mode specific changes */
switch|switch
condition|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFDIR
case|:
name|x
operator|=
name|recvdir
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFLNK
case|:
name|x
operator|=
name|recvsym
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFREG
case|:
name|x
operator|=
name|recvreg
argument_list|(
name|t
argument_list|,
name|new
argument_list|,
operator|&
name|sbuf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|goaway
argument_list|(
literal|"Unknown file type %o\n"
argument_list|,
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
condition|)
block|{
name|thisC
operator|->
name|Cnogood
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
condition|)
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|t
operator|->
name|Tlink
argument_list|,
name|linkone
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|t
operator|->
name|Texec
argument_list|,
name|execone
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_function
name|int
name|recvdir
parameter_list|(
name|t
parameter_list|,
name|new
parameter_list|,
name|statp
parameter_list|)
comment|/* receive directory from network */
specifier|register
name|TREE
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|new
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|statp
decl_stmt|;
block|{
name|struct
name|timeval
name|tbuf
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|t
operator|->
name|Tflags
operator|&
name|FRENAME
condition|?
name|t
operator|->
name|Tnewname
else|:
name|t
operator|->
name|Tname
decl_stmt|;
if|if
condition|(
name|new
condition|)
block|{
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would create directory %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|name
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
name|statp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Can't create directory %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNOACCT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* convert user and group names to local ids */
name|ugconvert
argument_list|(
name|t
operator|->
name|Tuser
argument_list|,
name|t
operator|->
name|Tgroup
argument_list|,
operator|&
name|t
operator|->
name|Tuid
argument_list|,
operator|&
name|t
operator|->
name|Tgid
argument_list|,
operator|&
name|t
operator|->
name|Tmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|new
operator|&&
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNEW
operator|)
operator|==
literal|0
operator|&&
name|statp
operator|->
name|st_mtime
operator|==
name|t
operator|->
name|Tmtime
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FNOACCT
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|statp
operator|->
name|st_uid
operator|==
name|t
operator|->
name|Tuid
operator|&&
name|statp
operator|->
name|st_gid
operator|==
name|t
operator|->
name|Tgid
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would update directory %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNOACCT
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|chown
argument_list|(
name|name
argument_list|,
name|t
operator|->
name|Tuid
argument_list|,
name|t
operator|->
name|Tgid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|name
argument_list|,
name|t
operator|->
name|Tmode
operator|&
name|S_IMODE
argument_list|)
expr_stmt|;
block|}
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|t
operator|->
name|Tmtime
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|utimes
argument_list|(
name|name
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|vnotify
argument_list|(
literal|"SUP %s directory %s\n"
argument_list|,
name|new
condition|?
literal|"Created"
else|:
literal|"Updated"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|recvsym
parameter_list|(
name|t
parameter_list|,
name|new
parameter_list|,
name|statp
parameter_list|)
comment|/* receive symbolic link */
specifier|register
name|TREE
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|new
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|statp
decl_stmt|;
block|{
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|linkname
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|t
operator|->
name|Tflags
operator|&
name|FRENAME
condition|?
name|t
operator|->
name|Tnewname
else|:
name|t
operator|->
name|Tname
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|Tlink
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Missing linkname for symbolic link %s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|linkname
operator|=
name|t
operator|->
name|Tlink
operator|->
name|Tname
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|&&
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNEW
operator|)
operator|==
literal|0
operator|&&
operator|(
name|n
operator|=
name|readlink
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
operator|(
name|n
operator|==
name|strlen
argument_list|(
name|linkname
argument_list|)
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|linkname
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would %s symbolic link %s to %s\n"
argument_list|,
name|new
condition|?
literal|"create"
else|:
literal|"update"
argument_list|,
name|name
argument_list|,
name|linkname
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|new
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|linkname
argument_list|,
name|name
argument_list|)
operator|<
literal|0
operator|||
name|lstat
argument_list|(
name|name
argument_list|,
name|statp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Unable to create symbolic link %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|vnotify
argument_list|(
literal|"SUP Created symbolic link %s to %s\n"
argument_list|,
name|name
argument_list|,
name|linkname
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|recvreg
parameter_list|(
name|t
parameter_list|,
name|new
parameter_list|,
name|statp
parameter_list|)
comment|/* receive file from network */
specifier|register
name|TREE
modifier|*
name|t
decl_stmt|;
specifier|register
name|int
name|new
decl_stmt|;
specifier|register
name|struct
name|stat
modifier|*
name|statp
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fin
decl_stmt|,
modifier|*
name|fout
decl_stmt|;
name|char
name|dirpart
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
name|filepart
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|char
name|filename
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|struct
name|timeval
name|tbuf
index|[
literal|2
index|]
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|t
operator|->
name|Tflags
operator|&
name|FRENAME
condition|?
name|t
operator|->
name|Tnewname
else|:
name|t
operator|->
name|Tname
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FUPDATE
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNOACCT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* convert user and group names to local ids */
name|ugconvert
argument_list|(
name|t
operator|->
name|Tuser
argument_list|,
name|t
operator|->
name|Tgroup
argument_list|,
operator|&
name|t
operator|->
name|Tuid
argument_list|,
operator|&
name|t
operator|->
name|Tgid
argument_list|,
operator|&
name|t
operator|->
name|Tmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|new
operator|&&
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNEW
operator|)
operator|==
literal|0
operator|&&
name|statp
operator|->
name|st_mtime
operator|==
name|t
operator|->
name|Tmtime
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FNOACCT
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|statp
operator|->
name|st_uid
operator|==
name|t
operator|->
name|Tuid
operator|&&
name|statp
operator|->
name|st_gid
operator|==
name|t
operator|->
name|Tgid
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would update file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|vnotify
argument_list|(
literal|"SUP Updating file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNOACCT
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|chown
argument_list|(
name|name
argument_list|,
name|t
operator|->
name|Tuid
argument_list|,
name|t
operator|->
name|Tgid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|name
argument_list|,
name|t
operator|->
name|Tmode
operator|&
name|S_IMODE
argument_list|)
expr_stmt|;
block|}
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|t
operator|->
name|Tmtime
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|utimes
argument_list|(
name|name
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
if|if
condition|(
name|new
condition|)
name|p
operator|=
literal|"create"
expr_stmt|;
elseif|else
if|if
condition|(
name|statp
operator|->
name|st_mtime
operator|<
name|t
operator|->
name|Tmtime
condition|)
name|p
operator|=
literal|"receive new"
expr_stmt|;
elseif|else
if|if
condition|(
name|statp
operator|->
name|st_mtime
operator|>
name|t
operator|->
name|Tmtime
condition|)
name|p
operator|=
literal|"receive old"
expr_stmt|;
else|else
name|p
operator|=
literal|"receive"
expr_stmt|;
name|vnotify
argument_list|(
literal|"SUP Would %s file %s\n"
argument_list|,
name|p
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|vnotify
argument_list|(
literal|"SUP Receiving file %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|&&
operator|(
name|t
operator|->
name|Tmode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFREG
operator|&&
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FBACKUP
operator|)
operator|&&
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFBACKUP
operator|)
condition|)
block|{
name|fin
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* create backup */
if|if
condition|(
name|fin
operator|==
name|NULL
condition|)
block|{
name|x
operator|=
name|readskip
argument_list|()
expr_stmt|;
comment|/* skip over file */
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Can't skip file transfer"
argument_list|)
expr_stmt|;
name|notify
argument_list|(
literal|"SUP: Can't open %s to create backup\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* mark upgrade as nogood */
block|}
name|path
argument_list|(
name|name
argument_list|,
name|dirpart
argument_list|,
name|filepart
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|filename
argument_list|,
name|FILEBACKUP
argument_list|,
name|dirpart
argument_list|,
name|filepart
argument_list|)
expr_stmt|;
name|fout
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fout
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEBKDIR
argument_list|,
name|dirpart
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mkdir
argument_list|(
name|buf
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
name|fout
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fout
operator|==
name|NULL
condition|)
block|{
name|x
operator|=
name|readskip
argument_list|()
expr_stmt|;
comment|/* skip over file */
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Can't skip file transfer"
argument_list|)
expr_stmt|;
name|notify
argument_list|(
literal|"SUP: Can't create %s for backup\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|ffilecopy
argument_list|(
name|fin
argument_list|,
name|fout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fout
argument_list|)
expr_stmt|;
name|vnotify
argument_list|(
literal|"SUP Backup of %s created\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|copyfile
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNOACCT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* convert user and group names to local ids */
name|ugconvert
argument_list|(
name|t
operator|->
name|Tuser
argument_list|,
name|t
operator|->
name|Tgroup
argument_list|,
operator|&
name|t
operator|->
name|Tuid
argument_list|,
operator|&
name|t
operator|->
name|Tgid
argument_list|,
operator|&
name|t
operator|->
name|Tmode
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|name
argument_list|,
name|t
operator|->
name|Tuid
argument_list|,
name|t
operator|->
name|Tgid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|name
argument_list|,
name|t
operator|->
name|Tmode
operator|&
name|S_IMODE
argument_list|)
expr_stmt|;
block|}
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|t
operator|->
name|Tmtime
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|utimes
argument_list|(
name|name
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|linkone
argument_list|(
name|t
argument_list|,
name|fname
argument_list|)
comment|/* link to file already received */
specifier|register
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|fbuf
decl_stmt|,
name|sbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|name
init|=
name|t
operator|->
name|Tname
decl_stmt|;
name|int
name|new
decl_stmt|,
name|x
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
operator|*
name|fname
argument_list|,
operator|&
name|fbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* source file */
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would link %s to %s\n"
argument_list|,
name|name
argument_list|,
operator|*
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|notify
argument_list|(
literal|"SUP: Can't link %s to missing file %s\n"
argument_list|,
name|name
argument_list|,
operator|*
name|fname
argument_list|)
expr_stmt|;
name|thisC
operator|->
name|Cnogood
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
name|prepare
argument_list|(
name|name
argument_list|,
name|S_IFREG
argument_list|,
operator|&
name|new
argument_list|,
operator|&
name|sbuf
argument_list|)
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Can't prepare path for link %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|thisC
operator|->
name|Cnogood
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|new
operator|&&
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNEW
operator|)
operator|==
literal|0
operator|&&
name|fbuf
operator|.
name|st_dev
operator|==
name|sbuf
operator|.
name|st_dev
operator|&&
name|fbuf
operator|.
name|st_ino
operator|==
name|sbuf
operator|.
name|st_ino
condition|)
return|return
operator|(
name|SCMOK
operator|)
return|;
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would link %s to %s\n"
argument_list|,
name|name
argument_list|,
operator|*
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|link
argument_list|(
operator|*
name|fname
argument_list|,
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|type
operator|=
literal|"symbolic "
expr_stmt|;
name|x
operator|=
name|symlink
argument_list|(
operator|*
name|fname
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Unable to create %slink %s\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|vnotify
argument_list|(
literal|"SUP Created %slink %s to %s\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
operator|*
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|execone
argument_list|(
name|t
argument_list|,
name|name
argument_list|)
comment|/* execute command for file */
specifier|register
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|struct
name|timeval
name|tbuf
index|[
literal|2
index|]
decl_stmt|;
name|union
name|wait
name|w
decl_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP Would execute %s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFEXECUTE
operator|)
operator|==
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP Please execute %s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|vnotify
argument_list|(
literal|"SUP Executing %s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
operator|*
name|name
argument_list|,
operator|&
name|sbuf
argument_list|)
condition|)
block|{
name|notify
argument_list|(
literal|"SUP Unable to stat file %s\n"
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
name|sbuf
operator|.
name|st_ino
operator|=
literal|0
expr_stmt|;
block|}
name|w
operator|.
name|w_status
operator|=
name|system
argument_list|(
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFEXITED
argument_list|(
name|w
argument_list|)
operator|&&
name|w
operator|.
name|w_retcode
operator|!=
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Execute command returned failure status %#o\n"
argument_list|,
name|w
operator|.
name|w_retcode
argument_list|)
expr_stmt|;
name|thisC
operator|->
name|Cnogood
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Execute command killed by signal %d\n"
argument_list|,
name|w
operator|.
name|w_termsig
argument_list|)
expr_stmt|;
name|thisC
operator|->
name|Cnogood
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Execute command stopped by signal %d\n"
argument_list|,
name|w
operator|.
name|w_stopsig
argument_list|)
expr_stmt|;
name|thisC
operator|->
name|Cnogood
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sbuf
operator|.
name|st_ino
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFLNK
condition|)
block|{
operator|(
name|void
operator|)
name|chown
argument_list|(
operator|*
name|name
argument_list|,
name|sbuf
operator|.
name|st_uid
argument_list|,
name|sbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
operator|*
name|name
argument_list|,
operator|(
name|sbuf
operator|.
name|st_mode
operator|)
operator|&
literal|0x1ff
argument_list|)
expr_stmt|;
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|sbuf
operator|.
name|st_mtime
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|utimes
argument_list|(
operator|*
name|name
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_function
name|int
name|copyfile
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|)
name|char
modifier|*
name|to
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
comment|/* 0 if reading from network */
block|{
specifier|register
name|int
name|fromf
decl_stmt|,
name|tof
decl_stmt|,
name|istemp
decl_stmt|,
name|x
decl_stmt|;
name|char
name|dpart
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
name|fpart
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|char
name|tname
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|char
name|sys_com
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|int
name|retried
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|thispid
init|=
literal|0
decl_stmt|;
comment|/* process id # */
if|if
condition|(
name|from
condition|)
block|{
comment|/* reading file */
name|fromf
operator|=
name|open
argument_list|(
name|from
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromf
operator|<
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Can't open %s to copy to %s: %s\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
else|else
comment|/* reading network */
name|fromf
operator|=
operator|-
literal|1
expr_stmt|;
name|istemp
operator|=
name|TRUE
expr_stmt|;
comment|/* try to create temp file */
name|lockout
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* block interrupts */
if|if
condition|(
name|thispid
operator|==
literal|0
condition|)
name|thispid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* Now try hard to find a temp file name.  Try VERY hard. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* try destination directory */
name|path
argument_list|(
name|to
argument_list|,
name|dpart
argument_list|,
name|fpart
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"%s/#%d.sup"
argument_list|,
name|dpart
argument_list|,
name|thispid
argument_list|)
expr_stmt|;
name|tof
operator|=
name|open
argument_list|(
name|tname
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator|)
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|tof
operator|>=
literal|0
condition|)
break|break;
comment|/* try sup directory */
if|if
condition|(
name|thisC
operator|->
name|Cprefix
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|thisC
operator|->
name|Cbase
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"sup/#%d.sup"
argument_list|,
name|thispid
argument_list|)
expr_stmt|;
name|tof
operator|=
name|open
argument_list|(
name|tname
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator|)
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|tof
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|thisC
operator|->
name|Cprefix
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|thisC
operator|->
name|Cprefix
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* try base directory */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"#%d.sup"
argument_list|,
name|thispid
argument_list|)
expr_stmt|;
name|tof
operator|=
name|open
argument_list|(
name|tname
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator|)
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Cprefix
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|thisC
operator|->
name|Cprefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|tof
operator|>=
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|VAR_TMP
comment|/* try /var/tmp */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"/var/tmp/#%d.sup"
argument_list|,
name|thispid
argument_list|)
expr_stmt|;
name|tof
operator|=
name|open
argument_list|(
name|tname
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator|)
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|tof
operator|>=
literal|0
condition|)
break|break;
else|#
directive|else
comment|/* try /usr/tmp */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"/usr/tmp/#%d.sup"
argument_list|,
name|thispid
argument_list|)
expr_stmt|;
name|tof
operator|=
name|open
argument_list|(
name|tname
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator|)
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|tof
operator|>=
literal|0
condition|)
break|break;
endif|#
directive|endif
comment|/* try /tmp */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"/tmp/#%d.sup"
argument_list|,
name|thispid
argument_list|)
expr_stmt|;
name|tof
operator|=
name|open
argument_list|(
name|tname
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator|)
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|tof
operator|>=
literal|0
condition|)
break|break;
name|istemp
operator|=
name|FALSE
expr_stmt|;
comment|/* give up: try to create output file */
if|if
condition|(
operator|!
name|docompress
condition|)
name|tof
operator|=
name|open
argument_list|(
name|to
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator|)
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|tof
operator|>=
literal|0
condition|)
break|break;
comment|/* no luck */
name|notify
argument_list|(
literal|"SUP: Can't create %s or temp file for it\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromf
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fromf
argument_list|)
expr_stmt|;
else|else
block|{
name|x
operator|=
name|readskip
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Can't skip file transfer"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|fromf
operator|>=
literal|0
condition|)
block|{
comment|/* read file */
name|x
operator|=
name|filecopy
argument_list|(
name|fromf
argument_list|,
name|tof
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fromf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|tof
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Error in copying %s to %s\n"
argument_list|,
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|istemp
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* read network */
if|#
directive|if
name|MACH
if|if
condition|(
operator|!
name|rpauseflag
condition|)
block|{
name|int
name|fsize
decl_stmt|;
name|struct
name|fsparam
name|fsp
decl_stmt|;
name|x
operator|=
name|prereadcount
argument_list|(
operator|&
name|fsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
block|{
if|if
condition|(
name|istemp
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|x
operator|=
name|readskip
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Can't skip file transfer"
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Error in server space check"
argument_list|)
expr_stmt|;
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"Error in server space check"
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tof
argument_list|,
name|FIOCFSPARAM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fsp
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINVAL
condition|)
block|{
if|if
condition|(
name|istemp
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|x
operator|=
name|readskip
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Can't skip file transfer"
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Error in disk space check"
argument_list|)
expr_stmt|;
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"Error in disk space check"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
block|{
name|fsize
operator|=
operator|(
name|fsize
operator|+
literal|1023
operator|)
operator|/
literal|1024
expr_stmt|;
name|x
operator|=
name|fsp
operator|.
name|fsp_size
operator|*
name|MAX
argument_list|(
name|fsp
operator|.
name|fsp_minfree
argument_list|,
literal|1
argument_list|)
operator|/
literal|100
expr_stmt|;
name|fsp
operator|.
name|fsp_free
operator|-=
name|x
expr_stmt|;
if|if
condition|(
name|fsize
operator|>
name|MAX
argument_list|(
name|fsp
operator|.
name|fsp_free
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|istemp
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|x
operator|=
name|readskip
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
name|goaway
argument_list|(
literal|"Can't skip file transfer"
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"No disk space for file %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"No disk space for file %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* MACH */
name|x
operator|=
name|readfile
argument_list|(
name|tof
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|tof
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
block|{
if|if
condition|(
name|istemp
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|goaway
argument_list|(
literal|"Error in receiving %s\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|istemp
condition|)
block|{
comment|/* no temp file used */
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* uncompress it first */
name|retry
label|:
if|if
condition|(
name|docompress
condition|)
block|{
comment|/* make sure file permissions don't cause a problem */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sys_com
argument_list|,
literal|"gunzip< %s> %s\n"
argument_list|,
name|tname
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* Uncompress it onto the destination */
if|if
condition|(
name|system
argument_list|(
name|sys_com
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Error in uncompressing file %s\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* move to destination */
if|if
condition|(
name|rename
argument_list|(
name|tname
argument_list|,
name|to
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|fromf
operator|=
name|open
argument_list|(
name|tname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromf
operator|<
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Error in moving temp file to %s: %s\n"
argument_list|,
name|to
argument_list|,
name|errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|tof
operator|=
name|open
argument_list|(
name|to
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator|)
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|tof
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fromf
argument_list|)
expr_stmt|;
comment|/* Here we can tell if it is ETXTBSY and try this loop 		   again */
if|if
condition|(
name|dounlinkbusy
operator|&&
name|errno
operator|==
name|ETXTBSY
operator|&&
operator|!
name|retried
condition|)
block|{
comment|/* Try to unlink the destination */
if|if
condition|(
name|unlink
argument_list|(
name|to
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP: Removed busy file %s\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|retried
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/*  		      * Some OSs (ie. HP-UX), return ETXTBUSY on unlinking 		      * a busy file.  We try to rename it instead and log 		      * the filename so it can be removed later. 		      */
elseif|else
if|if
condition|(
name|errno
operator|==
name|ETXTBSY
condition|)
block|{
name|char
name|mname
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|mname
argument_list|,
literal|"%s.sup.#%d.moved"
argument_list|,
name|to
argument_list|,
name|thispid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|to
argument_list|,
name|mname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vnotify
argument_list|(
literal|"SUP: Moved busy file %s to %s\n"
argument_list|,
name|to
argument_list|,
name|mname
argument_list|)
expr_stmt|;
if|if
condition|(
name|renamelog
operator|==
name|NULL
condition|)
block|{
name|renamelog
operator|=
name|fopen
argument_list|(
name|thisC
operator|->
name|Crenamelog
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|renamelog
operator|==
name|NULL
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Cannot open rename log file %s: "
literal|"%s\n"
argument_list|,
name|thisC
operator|->
name|Crenamelog
argument_list|,
name|errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|renamelog
argument_list|,
literal|"%s\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|renamelog
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf
argument_list|(
name|renamelog
argument_list|,
literal|"%s\n"
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|renamelog
argument_list|)
expr_stmt|;
block|}
name|retried
operator|=
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
block|}
name|notify
argument_list|(
literal|"SUP: Can't create %s from temp file: %s\n"
argument_list|,
name|to
argument_list|,
name|errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|x
operator|=
name|filecopy
argument_list|(
name|fromf
argument_list|,
name|tof
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fromf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|tof
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|lockout
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Error in storing data in %s\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/***  Finish connection with file server ***/
end_comment

begin_macro
name|finishup
argument_list|(
argument|x
argument_list|)
end_macro

begin_decl_stmt
name|int
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|tname
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
name|fname
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|char
name|relsufix
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|char
name|collrelname
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|long
name|tloc
decl_stmt|;
name|FILE
modifier|*
name|finishfile
decl_stmt|;
comment|/* record of all filenames */
name|int
name|f
decl_stmt|,
name|finishone
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFURELSUF
operator|)
operator|&&
name|release
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|relsufix
argument_list|,
literal|".%s"
argument_list|,
name|release
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|collrelname
argument_list|,
literal|"%s-%s"
argument_list|,
name|collname
argument_list|,
name|release
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|relsufix
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|collrelname
argument_list|,
name|collname
argument_list|)
expr_stmt|;
block|}
name|dontjump
operator|=
name|TRUE
expr_stmt|;
comment|/* once here, no more longjmp */
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|protver
operator|<
literal|6
condition|)
block|{
comment|/* done with server */
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|goaway
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|requestend
argument_list|()
expr_stmt|;
block|}
name|tloc
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Upgrade of %s aborted at %s"
argument_list|,
name|collrelname
argument_list|,
name|ctime
argument_list|(
operator|&
name|tloc
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|lastT
argument_list|)
expr_stmt|;
if|if
condition|(
name|protver
operator|<
literal|6
condition|)
return|return;
comment|/* if we've not been blown off, make sure he is! */
if|if
condition|(
name|x
operator|!=
name|SCMEOF
condition|)
name|goaway
argument_list|(
literal|"Aborted"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|requestend
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|thisC
operator|->
name|Cnogood
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Upgrade of %s completed with errors at %s"
argument_list|,
name|collrelname
argument_list|,
name|ctime
argument_list|(
operator|&
name|tloc
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|notify
argument_list|(
literal|"SUP: Upgrade time will not be updated\n"
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|lastT
argument_list|)
expr_stmt|;
if|if
condition|(
name|protver
operator|<
literal|6
condition|)
return|return;
name|done
argument_list|(
name|FDONEUSRERROR
argument_list|,
literal|"Completed with errors"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|requestend
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|thisC
operator|->
name|Cprefix
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|thisC
operator|->
name|Cbase
argument_list|)
expr_stmt|;
name|vnotify
argument_list|(
literal|"SUP Upgrade of %s completed at %s"
argument_list|,
name|collrelname
argument_list|,
name|ctime
argument_list|(
operator|&
name|tloc
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFLIST
condition|)
block|{
name|Tfree
argument_list|(
operator|&
name|lastT
argument_list|)
expr_stmt|;
if|if
condition|(
name|protver
operator|<
literal|6
condition|)
return|return;
name|done
argument_list|(
name|FDONEDONTLOG
argument_list|,
literal|"List only"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|requestend
argument_list|()
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
name|FILEWHEN
argument_list|,
name|collname
argument_list|,
name|relsufix
argument_list|)
expr_stmt|;
if|if
condition|(
name|establishdir
argument_list|(
name|fname
argument_list|)
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Can't create directory for upgrade timestamp\n"
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|lastT
argument_list|)
expr_stmt|;
if|if
condition|(
name|protver
operator|<
literal|6
condition|)
return|return;
name|done
argument_list|(
name|FDONEUSRERROR
argument_list|,
literal|"Couldn't timestamp"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|requestend
argument_list|()
expr_stmt|;
return|return;
block|}
name|f
operator|=
name|open
argument_list|(
name|fname
argument_list|,
operator|(
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
operator|)
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Can't record current time in %s: %s\n"
argument_list|,
name|fname
argument_list|,
name|errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|lastT
argument_list|)
expr_stmt|;
if|if
condition|(
name|protver
operator|<
literal|6
condition|)
return|return;
name|done
argument_list|(
name|FDONEUSRERROR
argument_list|,
literal|"Couldn't timestamp"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|requestend
argument_list|()
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|write
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|scantime
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|protver
operator|>=
literal|6
condition|)
block|{
comment|/* At this point we have let the server go */
comment|/* "I'm sorry, we've had to let you go" */
name|done
argument_list|(
name|FDONESUCCESS
argument_list|,
literal|"Success"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|requestend
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
name|FILELASTTEMP
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|finishfile
operator|=
name|fopen
argument_list|(
name|tname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|finishfile
operator|==
name|NULL
condition|)
block|{
name|notify
argument_list|(
literal|"SUP: Can't record list of all files in %s\n"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|lastT
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|lastT
argument_list|,
name|finishone
argument_list|,
name|finishfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|finishfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
name|FILELAST
argument_list|,
name|collname
argument_list|,
name|relsufix
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tname
argument_list|,
name|fname
argument_list|)
operator|<
literal|0
condition|)
name|notify
argument_list|(
literal|"SUP: Can't change %s to %s\n"
argument_list|,
name|tname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|lastT
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|finishone
argument_list|(
argument|t
argument_list|,
argument|finishfile
argument_list|)
end_macro

begin_decl_stmt
name|TREE
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
modifier|*
name|finishfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|(
name|thisC
operator|->
name|Cflags
operator|&
name|CFDELETE
operator|)
operator|==
literal|0
operator|||
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FUPDATE
operator|)
condition|)
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FRENAME
condition|)
name|fprintf
argument_list|(
operator|*
name|finishfile
argument_list|,
literal|"%s %s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|,
name|t
operator|->
name|Tnewname
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
operator|*
name|finishfile
argument_list|,
literal|"%s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|void
name|done
parameter_list|(
name|int
name|value
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS*/
comment|/*ARGSUSED*/
function|done
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
if|#
directive|if
operator|!
name|__STDC__
name|int
name|value
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|value
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fmt
condition|)
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|protver
operator|<
literal|6
condition|)
block|{
if|if
condition|(
name|goawayreason
condition|)
name|free
argument_list|(
name|goawayreason
argument_list|)
expr_stmt|;
name|goawayreason
operator|=
operator|(
name|fmt
operator|)
condition|?
name|salloc
argument_list|(
name|buf
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|msggoaway
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|doneack
operator|=
name|value
expr_stmt|;
name|donereason
operator|=
operator|(
name|fmt
operator|)
condition|?
name|buf
else|:
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|msgdone
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dontjump
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|void
name|goaway
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS*/
comment|/*ARGSUSED*/
function|goaway
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
if|#
directive|if
operator|!
name|__STDC__
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fmt
condition|)
block|{
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|goawayreason
operator|=
name|buf
expr_stmt|;
block|}
else|else
name|goawayreason
operator|=
name|NULL
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|msggoaway
argument_list|()
expr_stmt|;
if|if
condition|(
name|fmt
condition|)
if|if
condition|(
name|thisC
condition|)
name|notify
argument_list|(
literal|"SUP: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"SUP: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dontjump
condition|)
name|longjmp
argument_list|(
name|sjbuf
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

