begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software_Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	sup -- Software Upgrade Protocol client process  *  *	Usage:  sup [ flags ] [ supfile ] [ collection ... ]  *  *	The only required argument to sup is the name of a supfile.  It  *	must either be given explicitly on the command line, or the -s  *	flag must be specified.  If the -s flag is given, the system  *	supfile will be used and a supfile command argument should not be  *	specified.  The list of collections is optional and if specified  *	will be the only collections upgraded.  The following flags affect  *	all collections specified.  *  *	-s	"system upgrade" flag  *			As described above.  *  *	-t	"upgrade time" flag  *			When this flag is given, Sup will print the time  *			that each collection was last upgraded, rather than  *			performing actual upgrades.  *  *	-R	"resource pause" flag  *			Sup will not disable resource pausing and will not  *			make filesystem space checks.  *  *	-N	"debug network" flag  *			Sup will trace messages sent and received that  *			implement the Sup network protocol.  *  *	-P	"debug ports" flag  *	    		Sup will use a set of non-privileged network  *			ports reserved for debugging purposes.  *  *	-X	"crosspatch" flag  *	    		Sup is being run remotely with a crosspatch.  *			Need to be carefull as we may be running as root  *			instead of collection owner.  *  *	The remaining flags affect all collections unless an explicit list  *	of collections are given with the flags.  Multiple flags may be  *	specified together that affect the same collections.  For the sake  *	of convience, any flags that always affect all collections can be  *	specified with flags that affect only some collections.  For  *	example, "sup -sde=coll1,coll2" would perform a system upgrade,  *	and the first two collections would allow both file deletions and  *	command executions.  Note that this is not the same command as  *	"sup -sde=coll1 coll2", which would perform a system upgrade of  *	just the coll2 collection and would ignore the flags given for the  *	coll1 collection.  *  *	-a	"all files" flag  *			All files in the collection will be copied from  *			the repository, regardless of their status on the  *			current machine.  Because of this, it is a very  *			expensive operation and should only be done for  *			small collections if data corruption is suspected  *			and been confirmed.  In most cases, the -o flag  *			should be sufficient.  *  *	-b	"backup files" flag  *			If the -b flag if given, or the "backup" supfile  *			option is specified, the contents of regular files  *			on the local system will be saved before they are  *			overwritten with new data.  The data will be saved  *			in a subdirectory called "BACKUP" in the directory  *			containing the original version of the file, in a  *			file with the same non-directory part of the file  *			name.  The files to backup are specified by the  *			list file on the repository.  *  *	-B	"don't backup files" flag  *			The -B flag overrides and disables the -b flag and  *			the "backup" supfile option.  *  *	-d	"delete files" flag  *			Files that are no longer in the collection on the  *			repository will be deleted if present on the local  *			machine.  This may also be specified in a supfile  *			with the "delete" option.  *  *	-D	"don't delete files" flag  *			The -D flag overrides and disables the -d flag and  *			the "delete" supfile option.  *  *	-e	"execute files" flag  *			Sup will execute commands sent from the repository  *			that should be run when a file is upgraded.  If  *			the -e flag is omitted, Sup will print a message  *			that specifies the command to execute.  This may  *			also be specified in a supfile with the "execute"  *			option.  *  *	-E	"don't execute files" flag  *			The -E flag overrides and disables the -e flag and  *			the "execute" supfile option.  *  *	-f	"file listing" flag  *			A "list-only" upgrade will be performed.  Messages  *			will be printed that indicate what would happen if  *			an actual upgrade were done.  *  *	-k	"keep newer files" flag  *			The -k flag, or "keep" supfile option, will cause  *			Sup to check to see whether there is a newer file on  *			the local disk before updating files.  Only files  *			which are newer on the repository will be updated.  *  *	-K	"don't keep newer files" flag  *			The -K flag overrides and disables the -k flag and  *			the "keep" supfile option.  *  *	-l	"local upgrade" flag  *			Normally, Sup will not upgrade a collection if the  *			repository is on the same machine.  This allows  *			users to run upgrades on all machines without  *			having to make special checks for the repository  *			machine.  If the -l flag is specified, collections  *			will be upgraded even if the repository is local.  *  *	-m	"mail" flag  *			Normally, Sup used standard output for messages.  *			If the -m flag if given, Sup will send mail to the  *			user running Sup, or a user specified with the  *			"notify" supfile option, that contains messages  *			printed by Sup.  *  *	-o	"old files" flag  *			Sup will normally only upgrade files that have  *			changed on the repository since the last time an  *			upgrade was performed.  The -o flag, or the "old"  *			supfile option, will cause Sup to check all files  *			in the collection for changes instead of just the  *			new ones.  *  *	-O	"not old files" flag  *			The -O flag overrides and disables the -o flag and  *			the "old" supfile option.  *  *	-v	"verbose" flag  *			Normally, Sup will only print messages if there  *			are problems.  This flag causes Sup to also print  *			messages during normal progress showing what Sup  *			is doing.  *  **********************************************************************  * HISTORY  *  * 7-July-93  Nate Williams at Montana State University  *	Modified SUP to use gzip based compression when sending files  *	across the network to save BandWidth  *  * $Log: supcmain.c,v $  * Revision 1.2  1994/08/11  02:46:22  rich  * Added extensions written by David Dawes.  From the man page:  *  * The -u flag, or the noupdate supfile option prevent updates from  * occurring for regular files where the modification time and mode  * hasn't changed.  *  * Now, how do we feed these patches back to CMU for consideration?  *  * Revision 1.1.1.1  1993/08/21  00:46:34  jkh  * Current sup with compression support.  *  * Revision 1.2  1993/05/24  17:57:28  brezak  * Remove netcrypt.c. Remove unneeded files. Cleanup make.  *  * Revision 1.1.1.1  1993/05/21  14:52:18  cgd  * initial import of CMU's SUP to NetBSD  *  * Revision 1.6  92/08/11  12:06:59  mrt  * 	Merged in Brad's changes. Made resource pausing code conditional  * 	on MACH, rather than CMUCS. Fixed some calls to sprintf to  * 	return void.  * 	[92/08/09            mrt]  *   * Revision 1.5  92/02/08  19:01:18  mja  * 	Correct oldsigsys type when ANSI C.  * 	[92/02/08  18:59:47  mja]  *   * Revision 1.4  92/02/08  18:24:01  mja  * 	Added -k and -K switches.  * 	[92/01/17            vdelvecc]  *   * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added crosspatch support (is currently ignored).  *  * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code for "release" support.  *  * 25-May-87  Doug Philips (dwp) at Carnegie-Mellon University  *	Split into several files.  This is the main program and  *	command line processing and old history log. [V5.21]  *  * 21-May-87  Chriss Stephens (chriss) at Carnegie Mellon University  *	Merged divergent CS and ECE versions. ifdeffed out the resource  *	pausing code - only compiled in if CMUCS defined. [V5.21a]  *  * 20-May-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Removed support for version 3 of SUP protocol.  Added changes  *	to make lint happy.  Added calls to new logging routines. [V5.20]  *  * 01-Apr-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added -R switch to reenable resource pausing, which is currently  *	disabled by default.  Added code to check for free disk space  *	available on the target filesystem so that sup shouldn't run the  *	system out of disk space as frequently. [V5.19]  *  * 19-Sep-86  Mike Accetta (mja) at Carnegie-Mellon University  *	Changed default supfile name for system collections when -t  *	is specified to use FILESUPTDEFAULT; added missing new-line  *	in retry message. [V5.18]  *  * 21-Jun-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Missed a caller to a routine which had an extra argument added  *	to it last edit. [V5.17]  *  * 07-Jun-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Changed getcoll() so that fatal errors are checked immediately  *	instead of after sleeping for a little while.  Changed all  *	rm -rf commands to rmdir since the Mach folks keep deleting  *	their root and /usr directory trees.  Reversed the order of  *	delete commands to that directories will possibly empty so  *	that the rmdir's work. [V5.16]  *  * 30-May-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Changed temporary file names to #n.sup format. [V5.15]  *  * 19-Feb-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Moved PGMVERSION to supvers.c module. [V5.14]  *  * 06-Feb-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added check for file type before unlink when receiving a  *	symbolic link.  Now runs "rm -rf" if the file type is a  *	directory. [V5.13]  *  * 03-Feb-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Fixed small bug in signon that didn't retry connections if an  *	error occured on the first attempt to connect. [V5.12]  *  * 26-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	New command interface.  Added -bBDEO flags and "delete",  *	"execute" and "old" supfile options.  Changed -d to work  *	correctly without implying -o. [V5.11]  *  * 21-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Fix incorrect check for supfile changing.  Flush output buffers  *	before restart. [V5.10]  *  * 17-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Add call to requestend() after connection errors are retried to  *	free file descriptors. [V5.9]  *  * 15-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Fix SERIOUS merge error from previous edit.  Added notify  *	when execute command fails. [V5.8]  *  * 11-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Changed ugconvert to clear setuid/setgid bits if it doesn't use  *	the user and group specified by the remote system.  Changed  *	execute code to invalidate collection if execute command returns  *	with a non-zero exit status.  Added support for execv() of  *	original arguments of supfile is upgraded sucessfully.  Changed  *	copyfile to always use a temp file if possible. [V5.7]  *  * 04-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added support for fileserver busy messages and new nameserver  *	protocol to support multiple repositories per collection.  *	Added code to lock collections with lock files. [V5.6]  *  * 29-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Major rewrite for protocol version 4. [V4.5]  *  * 12-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Changed to check for DIFFERENT mtime (again). [V3.4]  *  * 08-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Replaced [ug]convert routines with ugconvert routine so that an  *	appropriate group will be used if the default user is used.  *	Changed switch parsing to allow multiple switches to be specified  *	at the same time. [V3.3]  *  * 04-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added test to request a new copy of an old file that already  *	exists if the mtime is different. [V3.2]  *  * 24-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added -l switch to enable upgrades from local repositories.  *  * 03-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Minor change in order -t prints so that columns line up.  *  * 22-Oct-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to implement retry flag and pass this on to request().  *  * 22-Sep-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Merged 4.1 and 4.2 versions together.  *  * 04-Jun-85  Steven Shafer (sas) at Carnegie-Mellon University  *	Created for 4.2 BSD.  *  **********************************************************************  */
end_comment

begin_define
define|#
directive|define
name|MSGFILE
end_define

begin_include
include|#
directive|include
file|"supcdefs.h"
end_include

begin_if
if|#
directive|if
name|MACH
end_if

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_rpause
end_ifndef

begin_define
define|#
directive|define
name|SYS_rpause
value|(-5)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*********************************************  ***    G L O B A L   V A R I A B L E S    ***  *********************************************/
end_comment

begin_decl_stmt
name|char
name|program
index|[]
init|=
literal|"SUP"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program name for SCM messages */
end_comment

begin_decl_stmt
name|int
name|progpid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and process id */
end_comment

begin_decl_stmt
name|COLLECTION
modifier|*
name|firstC
decl_stmt|,
modifier|*
name|thisC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* collection list pointer */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|dontjump
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* disable longjmp */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|scmdebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SCM debugging flag */
end_comment

begin_decl_stmt
name|int
name|sysflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system upgrade flag */
end_comment

begin_decl_stmt
name|int
name|timeflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print times flag */
end_comment

begin_if
if|#
directive|if
name|MACH
end_if

begin_decl_stmt
name|int
name|rpauseflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't disable resource pausing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MACH */
end_comment

begin_decl_stmt
name|int
name|xpatchflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* crosspatched with remote system */
end_comment

begin_decl_stmt
name|int
name|portdebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* network debugging ports */
end_comment

begin_comment
comment|/*************************************  ***    M A I N   R O U T I N E    ***  *************************************/
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|init
parameter_list|()
function_decl|;
name|char
modifier|*
name|progname
decl_stmt|,
modifier|*
name|supfname
decl_stmt|;
name|int
name|restart
decl_stmt|,
name|sfdev
decl_stmt|,
name|sfino
decl_stmt|,
name|sfmtime
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|struct
name|sigvec
name|ignvec
decl_stmt|,
name|oldvec
decl_stmt|;
comment|/* initialize global variables */
name|pgmversion
operator|=
name|PGMVERSION
expr_stmt|;
comment|/* export version number */
name|server
operator|=
name|FALSE
expr_stmt|;
comment|/* export that we're not a server */
name|collname
operator|=
name|NULL
expr_stmt|;
comment|/* no current collection yet */
name|dontjump
operator|=
name|TRUE
expr_stmt|;
comment|/* clear setjmp buffer */
name|progname
operator|=
name|salloc
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|supfname
operator|=
name|init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|restart
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't make restart checks */
if|if
condition|(
operator|*
name|progname
operator|==
literal|'/'
operator|&&
operator|*
name|supfname
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|supfname
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
name|logerr
argument_list|(
literal|"Can't stat supfile %s"
argument_list|,
name|supfname
argument_list|)
expr_stmt|;
else|else
block|{
name|sfdev
operator|=
name|sbuf
operator|.
name|st_dev
expr_stmt|;
name|sfino
operator|=
name|sbuf
operator|.
name|st_ino
expr_stmt|;
name|sfmtime
operator|=
name|sbuf
operator|.
name|st_mtime
expr_stmt|;
name|restart
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|timeflag
condition|)
block|{
for|for
control|(
name|thisC
operator|=
name|firstC
init|;
name|thisC
condition|;
name|thisC
operator|=
name|thisC
operator|->
name|Cnext
control|)
name|prtime
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* ignore network pipe signals */
name|ignvec
operator|.
name|sv_handler
operator|=
name|SIG_IGN
expr_stmt|;
name|ignvec
operator|.
name|sv_onstack
operator|=
literal|0
expr_stmt|;
name|ignvec
operator|.
name|sv_mask
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGPIPE
argument_list|,
operator|&
name|ignvec
argument_list|,
operator|&
name|oldvec
argument_list|)
expr_stmt|;
name|getnams
argument_list|()
expr_stmt|;
comment|/* find unknown repositories */
for|for
control|(
name|thisC
operator|=
name|firstC
init|;
name|thisC
condition|;
name|thisC
operator|=
name|thisC
operator|->
name|Cnext
control|)
block|{
name|getcoll
argument_list|()
expr_stmt|;
comment|/* upgrade each collection */
if|if
condition|(
name|restart
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|supfname
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
name|logerr
argument_list|(
literal|"Can't stat supfile %s"
argument_list|,
name|supfname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sfmtime
operator|!=
name|sbuf
operator|.
name|st_mtime
operator|||
name|sfino
operator|!=
name|sbuf
operator|.
name|st_ino
operator|||
name|sfdev
operator|!=
name|sbuf
operator|.
name|st_dev
condition|)
block|{
name|restart
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|endpwent
argument_list|()
expr_stmt|;
comment|/* close /etc/passwd */
operator|(
name|void
operator|)
name|endgrent
argument_list|()
expr_stmt|;
comment|/* close /etc/group */
if|if
condition|(
name|restart
operator|==
literal|1
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|loginfo
argument_list|(
literal|"SUP Restarting %s with new supfile %s"
argument_list|,
name|progname
argument_list|,
name|supfname
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
name|getdtablesize
argument_list|()
init|;
name|fd
operator|>
literal|3
condition|;
name|fd
operator|--
control|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|progname
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"Restart failed"
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|thisC
operator|=
name|firstC
condition|)
block|{
name|firstC
operator|=
name|firstC
operator|->
name|Cnext
expr_stmt|;
name|free
argument_list|(
name|thisC
operator|->
name|Cname
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|thisC
operator|->
name|Chtree
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thisC
operator|->
name|Cbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Chbase
condition|)
name|free
argument_list|(
name|thisC
operator|->
name|Chbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Cprefix
condition|)
name|free
argument_list|(
name|thisC
operator|->
name|Cprefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Crelease
condition|)
name|free
argument_list|(
name|thisC
operator|->
name|Crelease
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Cnotify
condition|)
name|free
argument_list|(
name|thisC
operator|->
name|Cnotify
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Clogin
condition|)
name|free
argument_list|(
name|thisC
operator|->
name|Clogin
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Cpswd
condition|)
name|free
argument_list|(
name|thisC
operator|->
name|Cpswd
argument_list|)
expr_stmt|;
if|if
condition|(
name|thisC
operator|->
name|Ccrypt
condition|)
name|free
argument_list|(
name|thisC
operator|->
name|Ccrypt
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|thisC
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************  ***    I N I T I A L I Z A T I O N    ***  *****************************************/
end_comment

begin_comment
comment|/* Set up collection list from supfile.  Check all fields except  * hostname to be sure they make sense.  */
end_comment

begin_define
define|#
directive|define
name|Toflags
value|Tflags
end_define

begin_define
define|#
directive|define
name|Taflags
value|Tmode
end_define

begin_define
define|#
directive|define
name|Twant
value|Tuid
end_define

begin_define
define|#
directive|define
name|Tcount
value|Tgid
end_define

begin_macro
name|doswitch
argument_list|(
argument|argp
argument_list|,
argument|collTp
argument_list|,
argument|oflagsp
argument_list|,
argument|aflagsp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|argp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|TREE
modifier|*
modifier|*
name|collTp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|oflagsp
decl_stmt|,
modifier|*
name|aflagsp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|TREE
modifier|*
name|t
decl_stmt|;
specifier|register
name|char
modifier|*
name|coll
decl_stmt|;
specifier|register
name|int
name|oflags
decl_stmt|,
name|aflags
decl_stmt|;
name|oflags
operator|=
name|aflags
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|argp
condition|)
block|{
default|default:
name|logerr
argument_list|(
literal|"Invalid flag '%c' ignored"
argument_list|,
operator|*
name|argp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
case|case
literal|'='
case|:
if|if
condition|(
operator|*
name|argp
operator|++
operator|==
literal|'\0'
operator|||
operator|*
name|argp
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|oflagsp
operator||=
name|oflags
expr_stmt|;
operator|*
name|oflagsp
operator|&=
operator|~
name|aflags
expr_stmt|;
operator|*
name|aflagsp
operator||=
name|aflags
expr_stmt|;
operator|*
name|aflagsp
operator|&=
operator|~
name|oflags
expr_stmt|;
return|return;
block|}
do|do
block|{
name|coll
operator|=
name|nxtarg
argument_list|(
operator|&
name|argp
argument_list|,
literal|", \t"
argument_list|)
expr_stmt|;
name|t
operator|=
name|Tinsert
argument_list|(
name|collTp
argument_list|,
name|coll
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|t
operator|->
name|Toflags
operator||=
name|oflags
expr_stmt|;
name|t
operator|->
name|Toflags
operator|&=
operator|~
name|aflags
expr_stmt|;
name|t
operator|->
name|Taflags
operator||=
name|aflags
expr_stmt|;
name|t
operator|->
name|Taflags
operator|&=
operator|~
name|oflags
expr_stmt|;
name|argp
operator|=
name|skipover
argument_list|(
name|argp
argument_list|,
literal|", \t"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|argp
condition|)
do|;
return|return;
case|case
literal|'N'
case|:
name|scmdebug
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|portdebug
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
if|#
directive|if
name|MACH
name|rpauseflag
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* MACH */
break|break;
case|case
literal|'X'
case|:
name|xpatchflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sysflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|timeflag
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|oflags
operator||=
name|CFALL
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|oflags
operator||=
name|CFBACKUP
expr_stmt|;
name|aflags
operator|&=
operator|~
name|CFBACKUP
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|oflags
operator|&=
operator|~
name|CFBACKUP
expr_stmt|;
name|aflags
operator||=
name|CFBACKUP
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|oflags
operator||=
name|CFDELETE
expr_stmt|;
name|aflags
operator|&=
operator|~
name|CFDELETE
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|oflags
operator|&=
operator|~
name|CFDELETE
expr_stmt|;
name|aflags
operator||=
name|CFDELETE
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|oflags
operator||=
name|CFEXECUTE
expr_stmt|;
name|aflags
operator|&=
operator|~
name|CFEXECUTE
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|oflags
operator|&=
operator|~
name|CFEXECUTE
expr_stmt|;
name|aflags
operator||=
name|CFEXECUTE
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|oflags
operator||=
name|CFLIST
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|oflags
operator||=
name|CFKEEP
expr_stmt|;
name|aflags
operator|&=
operator|~
name|CFKEEP
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|oflags
operator|&=
operator|~
name|CFKEEP
expr_stmt|;
name|aflags
operator||=
name|CFKEEP
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|oflags
operator||=
name|CFLOCAL
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|oflags
operator||=
name|CFMAIL
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|oflags
operator||=
name|CFOLD
expr_stmt|;
name|aflags
operator|&=
operator|~
name|CFOLD
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|oflags
operator|&=
operator|~
name|CFOLD
expr_stmt|;
name|aflags
operator||=
name|CFOLD
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|oflags
operator||=
name|CFNOUPDATE
expr_stmt|;
name|aflags
operator|&=
operator|~
name|CFNOUPDATE
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|oflags
operator|&=
operator|~
name|CFNOUPDATE
expr_stmt|;
name|aflags
operator||=
name|CFNOUPDATE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|oflags
operator||=
name|CFVERBOSE
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|oflags
operator||=
name|CFCOMPRESS
expr_stmt|;
name|aflags
operator|&=
operator|~
name|CFCOMPRESS
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|oflags
operator|&=
operator|~
name|CFCOMPRESS
expr_stmt|;
name|aflags
operator||=
name|CFCOMPRESS
expr_stmt|;
break|break;
block|}
name|argp
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_function
name|char
modifier|*
name|init
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|username
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|supfname
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
specifier|register
name|COLLECTION
modifier|*
name|c
decl_stmt|,
modifier|*
name|lastC
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|bogus
decl_stmt|;
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|register
name|TREE
modifier|*
name|t
decl_stmt|;
name|TREE
modifier|*
name|collT
decl_stmt|;
comment|/* collections we are interested in */
name|long
name|timenow
decl_stmt|;
comment|/* startup time */
name|int
name|checkcoll
parameter_list|()
function_decl|;
name|int
name|oflags
decl_stmt|,
name|aflags
decl_stmt|;
name|int
name|cwant
decl_stmt|;
ifdef|#
directive|ifdef
name|MACH
ifdef|#
directive|ifdef
name|__STDC__
name|void
function_decl|(
modifier|*
name|oldsigsys
function_decl|)
parameter_list|()
function_decl|;
else|#
directive|else
name|int
function_decl|(
modifier|*
name|oldsigsys
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* MACH */
name|char
modifier|*
name|fmttime
parameter_list|()
function_decl|;
name|sysflag
operator|=
name|FALSE
expr_stmt|;
comment|/* not system upgrade */
name|timeflag
operator|=
name|FALSE
expr_stmt|;
comment|/* don't print times */
if|#
directive|if
name|MACH
name|rpauseflag
operator|=
name|FALSE
expr_stmt|;
comment|/* don't disable resource pausing */
endif|#
directive|endif
comment|/* MACH */
name|xpatchflag
operator|=
name|FALSE
expr_stmt|;
comment|/* not normally crosspatched */
name|scmdebug
operator|=
literal|0
expr_stmt|;
comment|/* level zero, no SCM debugging */
name|portdebug
operator|=
name|FALSE
expr_stmt|;
comment|/* no debugging ports */
name|collT
operator|=
name|NULL
expr_stmt|;
name|oflags
operator|=
name|aflags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|doswitch
argument_list|(
operator|&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
argument_list|,
operator|&
name|collT
argument_list|,
operator|&
name|oflags
argument_list|,
operator|&
name|aflags
argument_list|)
expr_stmt|;
operator|--
name|argc
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
operator|!
name|sysflag
condition|)
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"Need either -s or supfile"
argument_list|)
expr_stmt|;
if|#
directive|if
name|MACH
name|oldsigsys
operator|=
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpauseflag
operator|!=
name|TRUE
condition|)
if|if
condition|(
name|syscall
argument_list|(
name|SYS_rpause
argument_list|,
name|ENOSPC
argument_list|,
name|RPAUSE_ALL
argument_list|,
name|RPAUSE_DISABLE
argument_list|)
operator|<
literal|0
condition|)
name|rpauseflag
operator|=
name|TRUE
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|oldsigsys
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH */
if|if
condition|(
name|sysflag
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|supfname
operator|=
name|buf
argument_list|,
name|timeflag
condition|?
name|FILESUPTDEFAULT
else|:
name|FILESUPDEFAULT
argument_list|,
name|DEFDIR
argument_list|)
expr_stmt|;
else|else
block|{
name|supfname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|supfname
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|supfname
operator|=
literal|""
expr_stmt|;
operator|--
name|argc
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
name|cwant
operator|=
name|argc
operator|>
literal|1
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|t
operator|=
name|Tinsert
argument_list|(
operator|&
name|collT
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|t
operator|->
name|Twant
operator|=
name|TRUE
expr_stmt|;
operator|--
name|argc
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|getlogin
argument_list|()
operator|)
operator|||
operator|(
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
operator|(
name|int
operator|)
name|getuid
argument_list|()
argument_list|)
operator|)
operator|&&
operator|(
name|p
operator|=
name|pw
operator|->
name|pw_name
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|username
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
operator|*
name|username
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|supfname
condition|)
block|{
name|f
operator|=
name|fopen
argument_list|(
name|supfname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"Can't open supfile %s"
argument_list|,
name|supfname
argument_list|)
expr_stmt|;
block|}
else|else
name|f
operator|=
name|stdin
expr_stmt|;
name|firstC
operator|=
name|NULL
expr_stmt|;
name|lastC
operator|=
name|NULL
expr_stmt|;
name|bogus
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|arg
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|'\0'
condition|)
block|{
name|logerr
argument_list|(
literal|"Missing collection name in supfile"
argument_list|)
expr_stmt|;
name|bogus
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cwant
condition|)
block|{
specifier|register
name|TREE
modifier|*
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|Tsearch
argument_list|(
name|collT
argument_list|,
name|arg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|t
operator|->
name|Tcount
operator|++
expr_stmt|;
block|}
name|c
operator|=
operator|(
name|COLLECTION
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COLLECTION
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstC
operator|==
name|NULL
condition|)
name|firstC
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|lastC
operator|!=
name|NULL
condition|)
name|lastC
operator|->
name|Cnext
operator|=
name|c
expr_stmt|;
name|lastC
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|parsecoll
argument_list|(
name|c
argument_list|,
name|arg
argument_list|,
name|p
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bogus
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
name|c
operator|->
name|Cflags
operator||=
name|oflags
expr_stmt|;
name|c
operator|->
name|Cflags
operator|&=
operator|~
name|aflags
expr_stmt|;
if|if
condition|(
name|t
operator|=
name|Tsearch
argument_list|(
name|collT
argument_list|,
name|c
operator|->
name|Cname
argument_list|)
condition|)
block|{
name|c
operator|->
name|Cflags
operator||=
name|t
operator|->
name|Toflags
expr_stmt|;
name|c
operator|->
name|Cflags
operator|&=
operator|~
name|t
operator|->
name|Taflags
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|->
name|Cflags
operator|&
name|CFMAIL
operator|)
operator|&&
name|c
operator|->
name|Cnotify
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|username
operator|==
literal|'\0'
condition|)
name|logerr
argument_list|(
literal|"User unknown, notification disabled"
argument_list|)
expr_stmt|;
else|else
name|c
operator|->
name|Cnotify
operator|=
name|salloc
argument_list|(
name|username
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|Cbase
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILEBASEDEFAULT
argument_list|,
name|c
operator|->
name|Cname
argument_list|)
expr_stmt|;
name|c
operator|->
name|Cbase
operator|=
name|salloc
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bogus
condition|)
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"Aborted due to supfile errors"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|stdin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwant
condition|)
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|collT
argument_list|,
name|checkcoll
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|collT
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstC
operator|==
name|NULL
condition|)
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"No collections to upgrade"
argument_list|)
expr_stmt|;
name|timenow
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|supfname
operator|==
literal|'\0'
condition|)
name|p
operator|=
literal|"standard input"
expr_stmt|;
elseif|else
if|if
condition|(
name|sysflag
condition|)
name|p
operator|=
literal|"system software"
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|p
operator|=
name|buf
argument_list|,
literal|"file %s"
argument_list|,
name|supfname
argument_list|)
expr_stmt|;
name|loginfo
argument_list|(
literal|"SUP %d.%d (%s) for %s at %s"
argument_list|,
name|PROTOVERSION
argument_list|,
name|PGMVERSION
argument_list|,
name|scmversion
argument_list|,
name|p
argument_list|,
name|fmttime
argument_list|(
name|timenow
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|salloc
argument_list|(
name|supfname
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|checkcoll
argument_list|(
name|t
argument_list|)
specifier|register
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|Twant
condition|)
return|return
operator|(
name|SCMOK
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|Tcount
operator|==
literal|0
condition|)
name|logerr
argument_list|(
literal|"Collection %s not found"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|Tcount
operator|>
literal|1
condition|)
name|logerr
argument_list|(
literal|"Collection %s found more than once"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

end_unit

