begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software_Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * SUP Communication Module for 4.3 BSD  *  * SUP COMMUNICATION MODULE SPECIFICATIONS:  *  * IN THIS MODULE:  *  * OUTPUT TO NETWORK  *  *   MESSAGE START/END  *	writemsg (msg)		start message  *	  int msg;			message type  *	writemend ()		end message and flush data to network  *  *   MESSAGE DATA  *	writeint (i)		write int  *	  int i;			integer to write  *	writestring (p)		write string  *	  char *p;			string pointer  *	writefile (f)		write open file  *	  int f;			open file descriptor  *  *   COMPLETE MESSAGE (start, one data block, end)  *	writemnull (msg)	write message with no data  *	  int msg;			message type  *	writemint (msg,i)	write int message  *	  int msg;			message type  *	  int i;			integer to write  *	writemstr (msg,p)	write string message  *	  int msg;			message type  *	  char *p;			string pointer  *  * INPUT FROM NETWORK  *   MESSAGE START/END  *	readflush ()		flush any unread data (close)  *	readmsg (msg)		read specified message type  *	  int msg;			message type  *	readmend ()		read message end  *  *   MESSAGE DATA  *	readskip ()		skip over one input data block  *	readint (i)		read int  *	  int *i;			pointer to integer  *	readstring (p)		read string  *	  char **p;			pointer to string pointer  *	readfile (f)		read into open file  *	  int f;			open file descriptor  *  *   COMPLETE MESSAGE (start, one data block, end)  *	readmnull (msg)		read message with no data  *	  int msg;			message type  *	readmint (msg,i)	read int message  *	  int msg;			message type  *	  int *i;			pointer to integer  *	readmstr (msg,p)	read string message  *	  int msg;			message type  *	  char **p;			pointer to string pointer  *  * RETURN CODES  *	All routines normally return SCMOK.  SCMERR may be returned  *	by any routine on abnormal (usually fatal) errors.  An  *	unexpected MSGGOAWAY will result in SCMEOF being returned.  *  * COMMUNICATION PROTOCOL  *	Messages always alternate, with the first message after  *	connecting being sent by the client process.  *  *	At the end of the conversation, the client process will  *	send a message to the server telling it to go away.  Then,  *	both processes will close the network connection.  *  *	Any time a process receives a message it does not expect,  *	the "readmsg" routine will send a MSGGOAWAY message and  *	return SCMEOF.  *	  *	Each message has this format:  *	    ----------    ------------    ------------         ----------  *	    |msg type|    |count|data|    |count|data|   ...   |ENDCOUNT|  *	    ----------    ------------    ------------         ----------  *	size:  int	    int  var.	    int  var.	   	  int  *  *	All ints are assumed to be 32-bit quantities.  A message  *	with no data simply has a message type followed by ENDCOUNT.  *  **********************************************************************  * HISTORY  * $Log: scmio.c,v $  * Revision 1.1.1.1  1993/08/21  00:46:33  jkh  * Current sup with compression support.  *  * Revision 1.2  1993/05/24  17:57:26  brezak  * Remove netcrypt.c. Remove unneeded files. Cleanup make.  *  * Revision 1.1.1.1  1993/05/21  14:52:17  cgd  * initial import of CMU's SUP to NetBSD  *  * Revision 1.7  92/09/09  22:04:41  mrt  * 	Removed the data encryption routines from here to netcrypt.c  * 	[92/09/09            mrt]  *   * Revision 1.6  92/08/11  12:05:57  mrt  * 	Brad's changes: Delinted,Added forward declarations of   * 	static functions. Added copyright.  * 	[92/07/24            mrt]  *   * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added crosspatch support.  *  * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Found error in debuging code for readint().  *  * 01-Apr-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to readdata to "push" data back into the data buffer.  *	Added prereadcount() to return the message count size after  *	reading it and then pushing it back into the buffer.  Clear  *	any encryption when a GOAWAY message is detected before reading  *	the reason string. [V5.19]  *  * 02-Oct-86  Rudy Nedved (ern) at Carnegie-Mellon University  *	Put a timeout on reading from the network.  *  * 25-May-86  Jonathan J. Chew (jjc) at Carnegie-Mellon University  *	Renamed "howmany" parameter to routines "encode" and "decode" from  *	to "count" to avoid conflict with 4.3BSD macro.  *  * 15-Feb-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added readflush() to flush any unread data from the input  *	buffer.  Called by requestend() in scm.c module.  *  * 19-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added register variables to decode() for speedup.  Added I/O  *	buffering to reduce the number or read/write system calls.  *	Removed readmfil/writemfil routines which were not used and were  *	not compatable with the other similarly defined routines anyway.  *  * 19-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Created from scm.c I/O and crypt routines.  *  **********************************************************************  */
end_comment

begin_include
include|#
directive|include
file|<libc.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|"sup.h"
end_include

begin_include
include|#
directive|include
file|"supmsg.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************  ***    M A C R O S    ***  *************************/
end_comment

begin_comment
comment|/* end of message */
end_comment

begin_define
define|#
directive|define
name|ENDCOUNT
value|(-1)
end_define

begin_comment
comment|/* end of message marker */
end_comment

begin_define
define|#
directive|define
name|NULLCOUNT
value|(-2)
end_define

begin_comment
comment|/* used for sending NULL pointer */
end_comment

begin_define
define|#
directive|define
name|RETRIES
value|15
end_define

begin_comment
comment|/* # of times to retry io */
end_comment

begin_define
define|#
directive|define
name|FILEXFER
value|2048
end_define

begin_comment
comment|/* block transfer size */
end_comment

begin_define
define|#
directive|define
name|XFERSIZE
parameter_list|(
name|count
parameter_list|)
value|((count> FILEXFER) ? FILEXFER : count)
end_define

begin_comment
comment|/*********************************************  ***    G L O B A L   V A R I A B L E S    ***  *********************************************/
end_comment

begin_function_decl
specifier|extern
name|int
name|scmerr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* error printing routine */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|netfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* network file descriptor */
end_comment

begin_decl_stmt
name|int
name|scmdebug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scm debug flag */
end_comment

begin_decl_stmt
name|int
name|cryptflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether to encrypt/decrypt data */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cryptbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for data encryption/decryption */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|goawayreason
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reason for goaway message */
end_comment

begin_struct
struct|struct
name|buf
block|{
name|char
name|b_data
index|[
name|FILEXFER
index|]
decl_stmt|;
comment|/* buffered data */
name|char
modifier|*
name|b_ptr
decl_stmt|;
comment|/* pointer to end of buffer */
name|int
name|b_cnt
decl_stmt|;
comment|/* number of bytes in buffer */
block|}
name|buffers
index|[
literal|2
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bufptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer pointer */
end_comment

begin_comment
comment|/***********************************************  ***    O U T P U T   T O   N E T W O R K    ***  ***********************************************/
end_comment

begin_expr_stmt
specifier|static
name|writedata
argument_list|(
argument|count
argument_list|,
argument|data
argument_list|)
comment|/* write raw data to network */
name|int
name|count
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|tries
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|bufptr
condition|)
block|{
if|if
condition|(
name|bufptr
operator|->
name|b_cnt
operator|+
name|count
operator|<=
name|FILEXFER
condition|)
block|{
name|bcopy
argument_list|(
name|data
argument_list|,
name|bufptr
operator|->
name|b_ptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|bufptr
operator|->
name|b_cnt
operator|+=
name|count
expr_stmt|;
name|bufptr
operator|->
name|b_ptr
operator|+=
name|count
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|bp
operator|=
operator|(
name|bufptr
operator|==
name|buffers
operator|)
condition|?
operator|&
name|buffers
index|[
literal|1
index|]
else|:
name|buffers
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_cnt
operator|=
name|count
expr_stmt|;
name|bp
operator|->
name|b_ptr
operator|=
name|bp
operator|->
name|b_data
operator|+
name|count
expr_stmt|;
name|data
operator|=
name|bufptr
operator|->
name|b_data
expr_stmt|;
name|count
operator|=
name|bufptr
operator|->
name|b_cnt
expr_stmt|;
name|bufptr
operator|->
name|b_cnt
operator|=
literal|0
expr_stmt|;
name|bufptr
operator|->
name|b_ptr
operator|=
name|bufptr
operator|->
name|b_data
expr_stmt|;
name|bufptr
operator|=
name|bp
expr_stmt|;
block|}
name|tries
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|write
argument_list|(
name|netfile
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
condition|)
break|break;
if|if
condition|(
operator|++
name|tries
operator|>
name|RETRIES
condition|)
break|break;
if|if
condition|(
name|scmdebug
operator|>
literal|0
condition|)
name|logerr
argument_list|(
literal|"SCM Retrying failed network write"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPIPE
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Network write timed out"
argument_list|)
operator|)
return|;
if|if
condition|(
name|errno
condition|)
return|return
operator|(
name|scmerr
argument_list|(
name|errno
argument_list|,
literal|"Write error on network"
argument_list|)
operator|)
return|;
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Write retries failed"
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|!=
name|count
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Write error on network returned %d on write of %d"
argument_list|,
name|x
argument_list|,
name|count
argument_list|)
operator|)
return|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|writeblock
argument_list|(
argument|count
argument_list|,
argument|data
argument_list|)
comment|/* write data block */
name|int
name|count
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|y
init|=
name|byteswap
argument_list|(
name|count
argument_list|)
decl_stmt|;
name|x
operator|=
name|writedata
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|writedata
argument_list|(
name|count
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_macro
name|writemsg
argument_list|(
argument|msg
argument_list|)
end_macro

begin_comment
comment|/* write start of message */
end_comment

begin_decl_stmt
name|int
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|scmdebug
operator|>
literal|1
condition|)
name|loginfo
argument_list|(
literal|"SCM Writing message %d"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufptr
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Buffering already enabled"
argument_list|)
operator|)
return|;
name|bufptr
operator|=
name|buffers
expr_stmt|;
name|bufptr
operator|->
name|b_ptr
operator|=
name|bufptr
operator|->
name|b_data
expr_stmt|;
name|bufptr
operator|->
name|b_cnt
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|byteswap
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|writedata
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|x
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|writemend
argument_list|()
end_macro

begin_comment
comment|/* write end of message */
end_comment

begin_block
block|{
specifier|register
name|int
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|x
decl_stmt|;
name|x
operator|=
name|byteswap
argument_list|(
name|ENDCOUNT
argument_list|)
expr_stmt|;
name|x
operator|=
name|writedata
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|bufptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Buffering already disabled"
argument_list|)
operator|)
return|;
if|if
condition|(
name|bufptr
operator|->
name|b_cnt
operator|==
literal|0
condition|)
block|{
name|bufptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
name|data
operator|=
name|bufptr
operator|->
name|b_data
expr_stmt|;
name|count
operator|=
name|bufptr
operator|->
name|b_cnt
expr_stmt|;
name|bufptr
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|writedata
argument_list|(
name|count
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|writeint
argument_list|(
argument|i
argument_list|)
end_macro

begin_comment
comment|/* write int as data block */
end_comment

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|scmdebug
operator|>
literal|2
condition|)
name|loginfo
argument_list|(
literal|"SCM Writing integer %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|x
operator|=
name|byteswap
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|writeblock
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|x
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|writestring
argument_list|(
argument|p
argument_list|)
end_macro

begin_comment
comment|/* write string as data block */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|,
name|x
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|int
name|y
init|=
name|byteswap
argument_list|(
name|NULLCOUNT
argument_list|)
decl_stmt|;
if|if
condition|(
name|scmdebug
operator|>
literal|2
condition|)
name|loginfo
argument_list|(
literal|"SCM Writing string NULL"
argument_list|)
expr_stmt|;
return|return
operator|(
name|writedata
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|y
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|scmdebug
operator|>
literal|2
condition|)
name|loginfo
argument_list|(
literal|"SCM Writing string %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cryptflag
condition|)
block|{
name|x
operator|=
name|getcryptbuf
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|encode
argument_list|(
name|p
argument_list|,
name|cryptbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|=
name|cryptbuf
expr_stmt|;
block|}
return|return
operator|(
name|writeblock
argument_list|(
name|len
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|writefile
argument_list|(
argument|f
argument_list|)
end_macro

begin_comment
comment|/* write open file as a data block */
end_comment

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|FILEXFER
index|]
decl_stmt|;
specifier|register
name|int
name|number
decl_stmt|,
name|sum
decl_stmt|,
name|filesize
decl_stmt|,
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|f
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
name|errno
argument_list|,
literal|"Can't access open file for message"
argument_list|)
operator|)
return|;
name|filesize
operator|=
name|statbuf
operator|.
name|st_size
expr_stmt|;
name|y
operator|=
name|byteswap
argument_list|(
name|filesize
argument_list|)
expr_stmt|;
name|x
operator|=
name|writedata
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|cryptflag
condition|)
name|x
operator|=
name|getcryptbuf
argument_list|(
name|FILEXFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
block|{
name|sum
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|number
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|buf
argument_list|,
name|FILEXFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cryptflag
condition|)
block|{
name|encode
argument_list|(
name|buf
argument_list|,
name|cryptbuf
argument_list|,
name|number
argument_list|)
expr_stmt|;
name|x
operator|=
name|writedata
argument_list|(
name|number
argument_list|,
name|cryptbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|writedata
argument_list|(
name|number
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|sum
operator|+=
name|number
expr_stmt|;
block|}
block|}
do|while
condition|(
name|x
operator|==
name|SCMOK
operator|&&
name|number
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|sum
operator|!=
name|filesize
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"File size error on output message"
argument_list|)
operator|)
return|;
if|if
condition|(
name|number
operator|<
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
name|errno
argument_list|,
literal|"Read error on file output message"
argument_list|)
operator|)
return|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_macro
name|writemnull
argument_list|(
argument|msg
argument_list|)
end_macro

begin_comment
comment|/* write message with no data */
end_comment

begin_decl_stmt
name|int
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|x
operator|=
name|writemsg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|writemend
argument_list|()
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_macro
name|writemint
argument_list|(
argument|msg
argument_list|,
argument|i
argument_list|)
end_macro

begin_comment
comment|/* write message of one int */
end_comment

begin_decl_stmt
name|int
name|msg
decl_stmt|,
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|x
operator|=
name|writemsg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|writeint
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|writemend
argument_list|()
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_macro
name|writemstr
argument_list|(
argument|msg
argument_list|,
argument|p
argument_list|)
end_macro

begin_comment
comment|/* write message of one string */
end_comment

begin_decl_stmt
name|int
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|x
operator|=
name|writemsg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|writestring
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|writemend
argument_list|()
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_comment
comment|/*************************************************  ***    I N P U T   F R O M   N E T W O R K    ***  *************************************************/
end_comment

begin_expr_stmt
specifier|static
name|readdata
argument_list|(
argument|count
argument_list|,
argument|data
argument_list|)
comment|/* read raw data from network */
name|int
name|count
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|m
decl_stmt|,
name|x
decl_stmt|;
name|int
name|tries
decl_stmt|;
specifier|static
name|int
name|bufcnt
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
name|bufptr
decl_stmt|;
specifier|static
name|char
name|buffer
index|[
name|FILEXFER
index|]
decl_stmt|;
specifier|static
name|int
name|imask
decl_stmt|;
specifier|static
name|struct
name|timeval
name|timout
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bufptr
operator|+
name|count
operator|<
name|buffer
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"No space in buffer %d"
argument_list|,
name|count
argument_list|)
operator|)
return|;
name|bufptr
operator|+=
name|count
expr_stmt|;
name|bufcnt
operator|-=
name|count
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|bufptr
argument_list|,
operator|-
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|data
operator|==
name|NULL
condition|)
block|{
name|bufcnt
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|<=
name|bufcnt
condition|)
block|{
name|bcopy
argument_list|(
name|bufptr
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|bufptr
operator|+=
name|count
expr_stmt|;
name|bufcnt
operator|-=
name|count
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
name|bufcnt
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|bufptr
argument_list|,
name|data
argument_list|,
name|bufcnt
argument_list|)
expr_stmt|;
name|data
operator|+=
name|bufcnt
expr_stmt|;
name|count
operator|-=
name|bufcnt
expr_stmt|;
block|}
name|bufptr
operator|=
name|buffer
expr_stmt|;
name|bufcnt
operator|=
literal|0
expr_stmt|;
name|timout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timout
operator|.
name|tv_sec
operator|=
literal|2
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
name|n
operator|=
name|FILEXFER
expr_stmt|;
name|m
operator|=
name|count
expr_stmt|;
while|while
condition|(
name|m
operator|>
literal|0
condition|)
block|{
name|tries
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|imask
operator|=
literal|1
operator|<<
name|netfile
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
literal|32
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
operator|&
name|imask
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|timout
argument_list|)
operator|<
literal|0
condition|)
name|imask
operator|=
literal|1
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|imask
condition|)
name|x
operator|=
name|read
argument_list|(
name|netfile
argument_list|,
name|p
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Timeout on network input"
argument_list|)
operator|)
return|;
if|if
condition|(
name|x
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Premature EOF on network input"
argument_list|)
operator|)
return|;
if|if
condition|(
name|errno
condition|)
break|break;
if|if
condition|(
operator|++
name|tries
operator|>
name|RETRIES
condition|)
break|break;
if|if
condition|(
name|scmdebug
operator|>
literal|0
condition|)
name|loginfo
argument_list|(
literal|"SCM Retrying failed network read"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
condition|)
return|return
operator|(
name|scmerr
argument_list|(
name|errno
argument_list|,
literal|"Read error on network"
argument_list|)
operator|)
return|;
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Read retries failed"
argument_list|)
operator|)
return|;
block|}
name|p
operator|+=
name|x
expr_stmt|;
name|n
operator|-=
name|x
expr_stmt|;
name|m
operator|-=
name|x
expr_stmt|;
name|bufcnt
operator|+=
name|x
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|bufptr
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|bufptr
operator|+=
name|count
expr_stmt|;
name|bufcnt
operator|-=
name|count
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|readcount
parameter_list|(
name|count
parameter_list|)
comment|/* read count of data block */
name|int
modifier|*
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|x
operator|=
name|readdata
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
operator|*
name|count
operator|=
name|byteswap
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_function

begin_function
name|int
name|prereadcount
parameter_list|(
name|count
parameter_list|)
comment|/* preread count of data block */
name|int
modifier|*
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|x
operator|=
name|readdata
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|x
operator|=
name|readdata
argument_list|(
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
operator|*
name|count
operator|=
name|byteswap
argument_list|(
name|y
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_function

begin_macro
name|readflush
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|readdata
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|readmsg
argument_list|(
argument|msg
argument_list|)
end_macro

begin_comment
comment|/* read header for expected message */
end_comment

begin_decl_stmt
name|int
name|msg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* if message is unexpected, send back SCMHUH */
end_comment

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|m
decl_stmt|;
if|if
condition|(
name|scmdebug
operator|>
literal|1
condition|)
name|loginfo
argument_list|(
literal|"SCM Reading message %d"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|x
operator|=
name|readdata
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|m
argument_list|)
expr_stmt|;
comment|/* msg type */
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|m
operator|=
name|byteswap
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|msg
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* check for MSGGOAWAY in case he noticed problems first */
if|if
condition|(
name|m
operator|!=
name|MSGGOAWAY
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Received unexpected message %d"
argument_list|,
name|m
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|netcrypt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|readstring
argument_list|(
operator|&
name|goawayreason
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|readmend
argument_list|()
expr_stmt|;
if|if
condition|(
name|goawayreason
operator|==
name|NULL
condition|)
return|return
operator|(
name|SCMEOF
operator|)
return|;
name|logerr
argument_list|(
literal|"SCM GOAWAY %s"
argument_list|,
name|goawayreason
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMEOF
operator|)
return|;
block|}
end_block

begin_macro
name|readmend
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|x
operator|=
name|readdata
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|y
argument_list|)
expr_stmt|;
name|y
operator|=
name|byteswap
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
operator|&&
name|y
operator|!=
name|ENDCOUNT
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Error reading end of message"
argument_list|)
operator|)
return|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_macro
name|readskip
argument_list|()
end_macro

begin_comment
comment|/* skip over one input block */
end_comment

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|buf
index|[
name|FILEXFER
index|]
decl_stmt|;
name|x
operator|=
name|readcount
argument_list|(
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Invalid message count %d"
argument_list|,
name|n
argument_list|)
operator|)
return|;
while|while
condition|(
name|x
operator|==
name|SCMOK
operator|&&
name|n
operator|>
literal|0
condition|)
block|{
name|x
operator|=
name|readdata
argument_list|(
name|XFERSIZE
argument_list|(
name|n
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|n
operator|-=
name|XFERSIZE
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_function
name|int
name|readint
parameter_list|(
name|buf
parameter_list|)
comment|/* read int data block */
name|int
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|x
operator|=
name|readcount
argument_list|(
operator|&
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Invalid message count %d"
argument_list|,
name|y
argument_list|)
operator|)
return|;
if|if
condition|(
name|y
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Size error for int message is %d"
argument_list|,
name|y
argument_list|)
operator|)
return|;
name|x
operator|=
name|readdata
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|y
argument_list|)
expr_stmt|;
operator|(
operator|*
name|buf
operator|)
operator|=
name|byteswap
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|scmdebug
operator|>
literal|2
condition|)
name|loginfo
argument_list|(
literal|"SCM Reading integer %d"
argument_list|,
operator|*
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|int
name|readstring
parameter_list|(
name|buf
parameter_list|)
comment|/* read string data block */
specifier|register
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|count
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|x
operator|=
name|readcount
argument_list|(
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|count
operator|==
name|NULLCOUNT
condition|)
block|{
if|if
condition|(
name|scmdebug
operator|>
literal|2
condition|)
name|loginfo
argument_list|(
literal|"SCM Reading string NULL"
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Invalid message count %d"
argument_list|,
name|count
argument_list|)
operator|)
return|;
if|if
condition|(
name|scmdebug
operator|>
literal|3
condition|)
name|loginfo
argument_list|(
literal|"SCM Reading string count %d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|count
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Can't malloc %d bytes for string"
argument_list|,
name|count
argument_list|)
operator|)
return|;
if|if
condition|(
name|cryptflag
condition|)
block|{
name|x
operator|=
name|getcryptbuf
argument_list|(
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|readdata
argument_list|(
name|count
argument_list|,
name|cryptbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|scmdebug
operator|>
literal|3
condition|)
name|printf
argument_list|(
literal|"SCM Reading encrypted string %s\n"
argument_list|,
name|cryptbuf
argument_list|)
expr_stmt|;
name|decode
argument_list|(
name|cryptbuf
argument_list|,
name|p
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|readdata
argument_list|(
name|count
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
block|}
name|p
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
comment|/* NULL at end of string */
operator|*
name|buf
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|scmdebug
operator|>
literal|2
condition|)
name|loginfo
argument_list|(
literal|"SCM Reading string %s"
argument_list|,
operator|*
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_function

begin_macro
name|readfile
argument_list|(
argument|f
argument_list|)
end_macro

begin_comment
comment|/* read data block into open file */
end_comment

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
name|buf
index|[
name|FILEXFER
index|]
decl_stmt|;
if|if
condition|(
name|cryptflag
condition|)
block|{
name|x
operator|=
name|getcryptbuf
argument_list|(
name|FILEXFER
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
block|}
name|x
operator|=
name|readcount
argument_list|(
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|SCMOK
condition|)
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
literal|"Invalid message count %d"
argument_list|,
name|count
argument_list|)
operator|)
return|;
while|while
condition|(
name|x
operator|==
name|SCMOK
operator|&&
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cryptflag
condition|)
block|{
name|x
operator|=
name|readdata
argument_list|(
name|XFERSIZE
argument_list|(
name|count
argument_list|)
argument_list|,
name|cryptbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|decode
argument_list|(
name|cryptbuf
argument_list|,
name|buf
argument_list|,
name|XFERSIZE
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|x
operator|=
name|readdata
argument_list|(
name|XFERSIZE
argument_list|(
name|count
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|f
argument_list|,
name|buf
argument_list|,
name|XFERSIZE
argument_list|(
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|-=
name|XFERSIZE
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_macro
name|readmnull
argument_list|(
argument|msg
argument_list|)
end_macro

begin_comment
comment|/* read null message */
end_comment

begin_decl_stmt
name|int
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|x
operator|=
name|readmsg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|readmend
argument_list|()
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_macro
name|readmint
argument_list|(
argument|msg
argument_list|,
argument|buf
argument_list|)
end_macro

begin_comment
comment|/* read int message */
end_comment

begin_decl_stmt
name|int
name|msg
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|x
operator|=
name|readmsg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|readint
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|readmend
argument_list|()
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_block

begin_function
name|int
name|readmstr
parameter_list|(
name|msg
parameter_list|,
name|buf
parameter_list|)
comment|/* read string message */
name|int
name|msg
decl_stmt|;
name|char
modifier|*
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|;
name|x
operator|=
name|readmsg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|readstring
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|SCMOK
condition|)
name|x
operator|=
name|readmend
argument_list|()
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_comment
comment|/**********************************  ***    C R O S S P A T C H     ***  **********************************/
end_comment

begin_macro
name|crosspatch
argument_list|()
end_macro

begin_block
block|{
name|fd_set
name|ibits
decl_stmt|,
name|obits
decl_stmt|,
name|xbits
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|ibits
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|obits
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|xbits
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
literal|0
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|netfile
argument_list|,
operator|&
name|ibits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|select
argument_list|(
literal|16
argument_list|,
operator|&
name|ibits
argument_list|,
operator|&
name|obits
argument_list|,
operator|&
name|xbits
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|NULL
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
continue|continue;
block|}
block|}
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|netfile
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
block|{
name|c
operator|=
name|read
argument_list|(
name|netfile
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|c
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
block|{
break|break;
block|}
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
literal|0
argument_list|,
operator|&
name|ibits
argument_list|)
condition|)
block|{
name|c
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EWOULDBLOCK
condition|)
name|c
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|write
argument_list|(
name|netfile
argument_list|,
name|buf
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

end_unit

