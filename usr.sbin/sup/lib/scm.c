begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software_Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * SUP Communication Module for 4.3 BSD  *  * SUP COMMUNICATION MODULE SPECIFICATIONS:  *  * IN THIS MODULE:  *  * CONNECTION ROUTINES  *  *   FOR SERVER  *	servicesetup (port)	establish TCP port connection  *	  char *port;			name of service  *	service ()		accept TCP port connection  *	servicekill ()		close TCP port in use by another process  *	serviceprep ()		close temp ports used to make connection  *	serviceend ()		close TCP port  *  *   FOR CLIENT  *	request (port,hostname,retry) establish TCP port connection  *	  char *port,*hostname;		  name of service and host  *	  int retry;			  true if retries should be used  *	requestend ()		close TCP port  *  * HOST NAME CHECKING  *	p = remotehost ()	remote host name (if known)  *	  char *p;  *	i = samehost ()		whether remote host is also this host  *	  int i;  *	i = matchhost (name)	whether remote host is same as name  *	  int i;  *	  char *name;  *  * RETURN CODES  *	All procedures return values as indicated above.  Other routines  *	normally return SCMOK on success, SCMERR on error.  *  * COMMUNICATION PROTOCOL  *  *	Described in scmio.c.  *  **********************************************************************  * HISTORY  *  2-Oct-92  Mary Thompson (mrt) at Carnegie-Mellon University  *	Added conditional declarations of INADDR_NONE and INADDR_LOOPBACK  *	since Tahoe version of<netinet/in.h> does not define them.  *  * $Log: scm.c,v $  * Revision 1.2  1995/12/26  05:02:49  peter  * Apply ports/net/sup/patches/patch-aa...  *  * Revision 1.1.1.1  1995/12/26 04:54:47  peter  * Import the unmodified version of the sup that we are using.  * The heritage of this version is not clear.  It appears to be NetBSD  * derived from some time ago.  *  * Revision 1.2  1994/06/20  06:04:04  rgrimes  * Humm.. they did a lot of #if __STDC__ but failed to properly prototype  * the code.  Also fixed one bad argument to a wait3 call.  *  * It won't compile -Wall, but atleast it compiles standard without warnings  * now.  *  * Revision 1.1.1.1  1993/08/21  00:46:33  jkh  * Current sup with compression support.  *  * Revision 1.1.1.1  1993/05/21  14:52:17  cgd  * initial import of CMU's SUP to NetBSD  *  * Revision 1.13  92/08/11  12:05:35  mrt  * 	Added changes from stump:  * 	  Allow for multiple interfaces, and for numeric addresses.  * 	  Changed to use builtin port for the "supfiledbg"  * 	    service when getservbyname() cannot find it.  * 	  Added forward static declatations, delinted.  * 	  Updated variable argument usage.  * 	[92/08/08            mrt]  *   * Revision 1.12  92/02/08  19:01:11  mja  * 	Add (struct sockaddr *) casts for HC 2.1.  * 	[92/02/08  18:59:09  mja]  *   * Revision 1.11  89/08/03  19:49:03  mja  * 	Updated to use v*printf() in place of _doprnt().  * 	[89/04/19            mja]  *   * 11-Feb-88  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Moved sleep into computeBackoff, renamed to dobackoff.  *  * 10-Feb-88  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added timeout to backoff.  *  * 27-Dec-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Removed nameserver support.  *  * 09-Sep-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Fixed to depend less upon having name of remote host.  *  * 25-May-87  Doug Philips (dwp) at Carnegie-Mellon Universtiy  *	Extracted backoff/sleeptime computation from "request" and  *	created "computeBackoff" so that I could use it in sup.c when  *	trying to get to nameservers as a group.  *  * 21-May-87  Chriss Stephens (chriss) at Carnegie Mellon University  *	Merged divergent CS and EE versions.  *  * 02-May-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added some bullet-proofing code around hostname calls.  *  * 31-Mar-87  Dan Nydick (dan) at Carnegie-Mellon University  *	Fixed for 4.3.  *  * 30-May-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to use known values for well-known ports if they are  *	not found in the host table.  *  * 19-Feb-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Changed setsockopt SO_REUSEADDR to be non-fatal.  Added fourth  *	parameter as described in 4.3 manual entry.  *  * 15-Feb-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added call of readflush() to requestend() routine.  *  * 29-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Major rewrite for protocol version 4.  All read/write and crypt  *	routines are now in scmio.c.  *  * 14-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added setsockopt SO_REUSEADDR call.  *  * 01-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Removed code to "gracefully" handle unexpected messages.  This  *	seems reasonable since it didn't work anyway, and should be  *	handled at a higher level anyway by adhering to protocol version  *	number conventions.  *  * 26-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Fixed scm.c to free space for remote host name when connection  *	is closed.  *  * 07-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Fixed 4.2 retry code to reload sin values before retry.  *  * 22-Oct-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to retry initial connection open request.  *  * 22-Sep-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Merged 4.1 and 4.2 versions together.  *  * 21-Sep-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Add close() calls after pipe() call.  *  * 12-Jun-85  Steven Shafer (sas) at Carnegie-Mellon University  *	Converted for 4.2 sockets; added serviceprep() routine.  *  * 04-Jun-85  Steven Shafer (sas) at Carnegie-Mellon University  *	Created for 4.2 BSD.  *  **********************************************************************  */
end_comment

begin_include
include|#
directive|include
file|<libc.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"sup.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|INADDR_NONE
end_ifndef

begin_define
define|#
directive|define
name|INADDR_NONE
value|0xffffffff
end_define

begin_comment
comment|/* -1 return */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INADDR_LOOPBACK
end_ifndef

begin_define
define|#
directive|define
name|INADDR_LOOPBACK
value|(u_long)0x7f000001
end_define

begin_comment
comment|/* 127.0.0.1 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|myhost
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|scmversion
index|[]
init|=
literal|"4.3 BSD"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PROTOTYPES  */
end_comment

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|scmerr
name|__P
argument_list|(
operator|(
name|int
operator|,
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*************************  ***    M A C R O S    ***  *************************/
end_comment

begin_comment
comment|/* networking parameters */
end_comment

begin_define
define|#
directive|define
name|NCONNECTS
value|5
end_define

begin_comment
comment|/*********************************************  ***    G L O B A L   V A R I A B L E S    ***  *********************************************/
end_comment

begin_decl_stmt
specifier|extern
name|char
name|program
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of program we are running */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|progpid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* process id to display */
end_comment

begin_decl_stmt
name|int
name|netfile
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* network file descriptor */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sock
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket used to make connection */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|in_addr
name|remoteaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* remote host address */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|remotename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* remote host name */
end_comment

begin_decl_stmt
specifier|static
name|int
name|swapmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* byte-swapping needed on server? */
end_comment

begin_comment
comment|/***************************************************  ***    C O N N E C T I O N   R O U T I N E S    ***  ***    F O R   S E R V E R                      ***  ***************************************************/
end_comment

begin_macro
name|servicesetup
argument_list|(
argument|server
argument_list|)
end_macro

begin_comment
comment|/* listen for clients */
end_comment

begin_decl_stmt
name|char
modifier|*
name|server
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|short
name|port
decl_stmt|;
name|int
name|one
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|myhost
argument_list|()
operator|==
name|NULL
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
name|stderr
argument_list|,
literal|"Local hostname not known"
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
name|server
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|server
argument_list|,
name|FILEPORT
argument_list|)
operator|==
literal|0
condition|)
name|port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|FILEPORTNUM
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|server
argument_list|,
name|DEBUGFPORT
argument_list|)
operator|==
literal|0
condition|)
name|port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|DEBUGFPORTNUM
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
name|stderr
argument_list|,
literal|"Can't find %s server description"
argument_list|,
name|server
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
name|stderr
argument_list|,
literal|"%s/tcp: unknown service: using port %d"
argument_list|,
name|server
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
name|endservent
argument_list|()
expr_stmt|;
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|<
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
name|errno
argument_list|,
name|stderr
argument_list|,
literal|"Can't create socket for connections"
argument_list|)
operator|)
return|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|one
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|scmerr
argument_list|(
name|errno
argument_list|,
name|stderr
argument_list|,
literal|"Can't set SO_REUSEADDR socket option"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|one
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|scmerr
argument_list|(
name|errno
argument_list|,
name|stderr
argument_list|,
literal|"Can't set SO_KEEPALIVE socket option"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
name|errno
argument_list|,
name|stderr
argument_list|,
literal|"Can't bind socket for connections"
argument_list|)
operator|)
return|;
if|if
condition|(
name|listen
argument_list|(
name|sock
argument_list|,
name|NCONNECTS
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
name|errno
argument_list|,
name|stderr
argument_list|,
literal|"Can't listen on socket"
argument_list|)
operator|)
return|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_macro
name|service
argument_list|()
end_macro

begin_block
block|{
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|int
name|x
decl_stmt|,
name|len
decl_stmt|;
name|remotename
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
do|do
block|{
name|netfile
operator|=
name|accept
argument_list|(
name|sock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|netfile
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|netfile
operator|<
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
name|errno
argument_list|,
name|stderr
argument_list|,
literal|"Can't accept connections"
argument_list|)
operator|)
return|;
name|remoteaddr
operator|=
name|from
operator|.
name|sin_addr
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|netfile
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|x
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
operator|(
name|scmerr
argument_list|(
name|errno
argument_list|,
name|stderr
argument_list|,
literal|"Can't transmit data on connection"
argument_list|)
operator|)
return|;
if|if
condition|(
name|x
operator|==
literal|0x01020304
condition|)
name|swapmode
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|0x04030201
condition|)
name|swapmode
operator|=
literal|1
expr_stmt|;
else|else
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
name|stderr
argument_list|,
literal|"Unexpected byteswap mode %x"
argument_list|,
name|x
argument_list|)
operator|)
return|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_macro
name|serviceprep
argument_list|()
end_macro

begin_comment
comment|/* kill temp socket in daemon */
end_comment

begin_block
block|{
if|if
condition|(
name|sock
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|sock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_macro
name|servicekill
argument_list|()
end_macro

begin_comment
comment|/* kill net file in daemon's parent */
end_comment

begin_block
block|{
if|if
condition|(
name|netfile
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|netfile
argument_list|)
expr_stmt|;
name|netfile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|remotename
condition|)
block|{
name|free
argument_list|(
name|remotename
argument_list|)
expr_stmt|;
name|remotename
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_macro
name|serviceend
argument_list|()
end_macro

begin_comment
comment|/* kill net file after use in daemon */
end_comment

begin_block
block|{
if|if
condition|(
name|netfile
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|netfile
argument_list|)
expr_stmt|;
name|netfile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|remotename
condition|)
block|{
name|free
argument_list|(
name|remotename
argument_list|)
expr_stmt|;
name|remotename
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_comment
comment|/***************************************************  ***    C O N N E C T I O N   R O U T I N E S    ***  ***    F O R   C L I E N T                      ***  ***************************************************/
end_comment

begin_macro
name|dobackoff
argument_list|(
argument|t
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|t
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|timeval
name|tt
decl_stmt|;
name|unsigned
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
operator|*
name|b
operator|*
literal|30
expr_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tt
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
operator|>=
literal|0
condition|)
name|s
operator|+=
operator|(
name|tt
operator|.
name|tv_usec
operator|>>
literal|8
operator|)
operator|%
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|b
operator|<
literal|32
condition|)
operator|*
name|b
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|s
operator|>
operator|*
name|t
condition|)
name|s
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|t
operator|-=
name|s
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
name|stdout
argument_list|,
literal|"Will retry in %d seconds"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|request
argument_list|(
argument|server
argument_list|,
argument|hostname
argument_list|,
argument|retry
argument_list|)
end_macro

begin_comment
comment|/* connect to server */
end_comment

begin_decl_stmt
name|char
modifier|*
name|server
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|retry
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|x
decl_stmt|,
name|backoff
decl_stmt|;
name|struct
name|hostent
modifier|*
name|h
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|,
name|tin
decl_stmt|;
name|short
name|port
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
name|server
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|server
argument_list|,
name|FILEPORT
argument_list|)
operator|==
literal|0
condition|)
name|port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|FILEPORTNUM
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|server
argument_list|,
name|DEBUGFPORT
argument_list|)
operator|==
literal|0
condition|)
name|port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|DEBUGFPORTNUM
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
name|stderr
argument_list|,
literal|"Can't find %s server description"
argument_list|,
name|server
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
name|stderr
argument_list|,
literal|"%s/tcp: unknown service: using port %d"
argument_list|,
name|server
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
operator|(
name|u_long
operator|)
name|INADDR_NONE
condition|)
block|{
if|if
condition|(
operator|(
name|h
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|scmerr
argument_list|(
operator|-
literal|1
argument_list|,
name|stderr
argument_list|,
literal|"Can't find host entry for %s"
argument_list|,
name|hostname
argument_list|)
operator|)
return|;
name|hostname
operator|=
name|h
operator|->
name|h_name
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|h
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|h
operator|->
name|h_length
argument_list|)
expr_stmt|;
block|}
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|backoff
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|netfile
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|netfile
operator|<
literal|0
condition|)
return|return
operator|(
name|scmerr
argument_list|(
name|errno
argument_list|,
name|stderr
argument_list|,
literal|"Can't create socket"
argument_list|)
operator|)
return|;
name|tin
operator|=
name|sin
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|netfile
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|tin
argument_list|,
sizeof|sizeof
argument_list|(
name|tin
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
break|break;
operator|(
name|void
operator|)
name|scmerr
argument_list|(
name|errno
argument_list|,
name|stderr
argument_list|,
literal|"Can't connect to server for %s"
argument_list|,
name|server
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|netfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dobackoff
argument_list|(
name|retry
argument_list|,
operator|&
name|backoff
argument_list|)
condition|)
return|return
operator|(
name|SCMERR
operator|)
return|;
block|}
name|remoteaddr
operator|=
name|sin
operator|.
name|sin_addr
expr_stmt|;
name|remotename
operator|=
name|salloc
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0x01020304
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|netfile
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|x
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|swapmode
operator|=
literal|0
expr_stmt|;
comment|/* swap only on server, not client */
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_macro
name|requestend
argument_list|()
end_macro

begin_comment
comment|/* end connection to server */
end_comment

begin_block
block|{
operator|(
name|void
operator|)
name|readflush
argument_list|()
expr_stmt|;
if|if
condition|(
name|netfile
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|netfile
argument_list|)
expr_stmt|;
name|netfile
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|remotename
condition|)
block|{
name|free
argument_list|(
name|remotename
argument_list|)
expr_stmt|;
name|remotename
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_comment
comment|/*************************************************  ***    H O S T   N A M E   C H E C K I N G    ***  *************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|myhost
parameter_list|()
comment|/* find my host name */
block|{
name|struct
name|hostent
modifier|*
name|h
decl_stmt|;
specifier|static
name|char
name|name
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|gethostname
argument_list|(
name|name
argument_list|,
name|MAXHOSTNAMELEN
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|h
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|h
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|remotehost
parameter_list|()
comment|/* remote host name (if known) */
block|{
specifier|register
name|struct
name|hostent
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|remotename
operator|==
name|NULL
condition|)
block|{
name|h
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|remoteaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|remoteaddr
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|remotename
operator|=
name|salloc
argument_list|(
name|h
condition|?
name|h
operator|->
name|h_name
else|:
name|inet_ntoa
argument_list|(
name|remoteaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remotename
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
block|}
return|return
operator|(
name|remotename
operator|)
return|;
block|}
end_function

begin_function
name|int
name|thishost
parameter_list|(
name|host
parameter_list|)
specifier|register
name|char
modifier|*
name|host
decl_stmt|;
block|{
specifier|register
name|struct
name|hostent
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|name
operator|=
name|myhost
argument_list|()
operator|)
operator|==
name|NULL
condition|)
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"Can't find my host entry"
argument_list|)
expr_stmt|;
name|h
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|h
operator|->
name|h_name
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|samehost
parameter_list|()
comment|/* is remote host same as local host? */
block|{
specifier|static
name|struct
name|in_addr
modifier|*
name|intp
decl_stmt|;
specifier|static
name|int
name|nint
init|=
literal|0
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|ifp
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|nint
operator|<=
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"Can't create socket for SIOCGIFCONF"
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"SIOCGIFCONF failed"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nint
operator|=
name|ifc
operator|.
name|ifc_len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|intp
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|nint
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|intp
operator|)
operator|==
literal|0
condition|)
name|logquit
argument_list|(
literal|1
argument_list|,
literal|"no space for interfaces"
argument_list|)
expr_stmt|;
for|for
control|(
name|ifr
operator|=
name|ifc
operator|.
name|ifc_req
operator|,
name|n
operator|=
name|nint
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
operator|,
name|ifr
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ifp
operator|++
operator|=
name|sin
operator|.
name|sin_addr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|remoteaddr
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|ifp
operator|=
name|intp
operator|,
name|n
operator|=
name|nint
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
operator|,
name|ifp
operator|++
control|)
if|if
condition|(
name|remoteaddr
operator|.
name|s_addr
operator|==
name|ifp
operator|->
name|s_addr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|matchhost
parameter_list|(
name|name
parameter_list|)
comment|/* is this name of remote host? */
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|h
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*"
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
operator|(
name|u_long
operator|)
name|INADDR_NONE
condition|)
return|return
operator|(
name|addr
operator|.
name|s_addr
operator|==
name|remoteaddr
operator|.
name|s_addr
operator|)
return|;
if|if
condition|(
operator|(
name|h
operator|=
name|gethostbyname
argument_list|(
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|h
operator|->
name|h_addrtype
operator|!=
name|AF_INET
operator|||
name|h
operator|->
name|h_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|ap
operator|=
name|h
operator|->
name|h_addr_list
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|remoteaddr
argument_list|,
operator|*
name|ap
argument_list|,
name|h
operator|->
name|h_length
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_decl_stmt
name|int
name|scmerr
argument_list|(
name|int
name|errno
argument_list|,
name|FILE
operator|*
name|filedes
argument_list|,
name|char
operator|*
name|fmt
argument_list|,
operator|...
argument_list|)
else|#
directive|else
comment|/*VARARGS*/
comment|/*ARGSUSED*/
name|int
name|scmerr
argument_list|(
name|va_alist
argument_list|)
name|va_dcl
endif|#
directive|endif
block|{
if|#
directive|if
operator|!
name|__STDC__
name|int
name|errno
decl_stmt|;
name|FILE
modifier|*
name|filedes
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
name|va_list
name|ap
decl_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|filedes
argument_list|)
expr_stmt|;
if|if
condition|(
name|progpid
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|filedes
argument_list|,
literal|"%s %d: "
argument_list|,
name|program
argument_list|,
name|progpid
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|filedes
argument_list|,
literal|"%s: "
argument_list|,
name|program
argument_list|)
expr_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|errno
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfprintf
argument_list|(
name|filedes
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|>=
literal|0
condition|)
name|fprintf
argument_list|(
name|filedes
argument_list|,
literal|": %s\n"
argument_list|,
name|errmsg
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|filedes
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|filedes
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMERR
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*******************************************************  ***    I N T E G E R   B Y T E - S W A P P I N G    ***  *******************************************************/
end_comment

begin_union
union|union
name|intchar
block|{
name|int
name|ui
decl_stmt|;
name|char
name|uc
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
block|}
union|;
end_union

begin_function
name|int
name|byteswap
parameter_list|(
name|in
parameter_list|)
name|int
name|in
decl_stmt|;
block|{
name|union
name|intchar
name|x
decl_stmt|,
name|y
decl_stmt|;
specifier|register
name|int
name|ix
decl_stmt|,
name|iy
decl_stmt|;
if|if
condition|(
name|swapmode
operator|==
literal|0
condition|)
return|return
operator|(
name|in
operator|)
return|;
name|x
operator|.
name|ui
operator|=
name|in
expr_stmt|;
name|iy
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|ix
operator|++
control|)
block|{
operator|--
name|iy
expr_stmt|;
name|y
operator|.
name|uc
index|[
name|iy
index|]
operator|=
name|x
operator|.
name|uc
index|[
name|ix
index|]
expr_stmt|;
block|}
return|return
operator|(
name|y
operator|.
name|ui
operator|)
return|;
block|}
end_function

end_unit

