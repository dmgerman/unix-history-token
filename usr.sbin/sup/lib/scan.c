begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software_Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  * scan.c - sup list file scanner  *  **********************************************************************  * HISTORY  * $Log: scan.c,v $  * Revision 1.3  1995/12/26 05:10:59  peter  * Apply ports/net/sup/patches/patch-ab  *  * Revision 1.2  1995/12/26 05:02:48  peter  * Apply ports/net/sup/patches/patch-aa...  *  * Revision 1.1.1.1  1995/12/26 04:54:47  peter  * Import the unmodified version of the sup that we are using.  * The heritage of this version is not clear.  It appears to be NetBSD  * derived from some time ago.  *  * Revision 1.1.1.1  1993/08/21  00:46:33  jkh  * Current sup with compression support.  *  * Revision 1.1.1.1  1993/05/21  14:52:17  cgd  * initial import of CMU's SUP to NetBSD  *  * Revision 1.8  92/08/11  12:04:28  mrt  * 	Brad's changes: delinted, added forward declarations of static  * 	functions.Added Copyright.  * 	[92/07/24            mrt]  *   * 18-Mar-88  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added host=<hostfile> support to releases file.  *  * 11-Mar-88  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added "rsymlink" recursive symbolic link quoting directive.  *  * 28-Jun-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code for "release" support.  *  * 26-May-87  Doug Philips (dwp) at Carnegie-Mellon University  *	Lets see if we'll be able to write the scan file BEFORE  *	we collect the data for it.  Include sys/file.h and use  *	new definitions for access check codes.  *  * 20-May-87  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added type casting information for lint.  *  * 21-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added check for newonly upgrade when lasttime is the same as  *	scantime.  This will save us the trouble of parsing the scanfile  *	when the client has successfully received everything in the  *	scanfile already.  *  * 16-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Clear Texec pointers in execT so that Tfree of execT will not  *	free command trees associated with files in listT.  *  * 06-Jan-86  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to omit scanned files from list if we want new files  *	only and they are old.  *  * 29-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Major rewrite for protocol version 4.  Added version numbers to  *	scan file.  Also added mode of file in addition to flags.  *	Execute commands are now immediately after file information.  *  * 13-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added comments to list file format.  *  * 08-Dec-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Added code to implement omitany.  Currently doesn't know about  *	{a,b,c} patterns.  *  * 07-Oct-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Created.  *  **********************************************************************  */
end_comment

begin_include
include|#
directive|include
file|<libc.h>
end_include

begin_include
include|#
directive|include
file|<c.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|"sup.h"
end_include

begin_comment
comment|/*************************  ***    M A C R O S    ***  *************************/
end_comment

begin_define
define|#
directive|define
name|SPECNUMBER
value|1000
end_define

begin_comment
comment|/* number of filenames produced by a single spec in the list file */
end_comment

begin_comment
comment|/*******************************************  ***    D A T A   S T R U C T U R E S    ***  *******************************************/
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
comment|/* release options */
name|ONEXT
block|,
name|OPREFIX
block|,
name|OLIST
block|,
name|OSCAN
block|,
name|OHOST
block|}
name|OPTION
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|options
index|[]
init|=
block|{
literal|"next"
block|,
literal|"prefix"
block|,
literal|"list"
block|,
literal|"scan"
block|,
literal|"host"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
comment|/*<collection>/list file lines */
name|LUPGRADE
block|,
name|LOMIT
block|,
name|LBACKUP
block|,
name|LEXECUTE
block|,
name|LINCLUDE
block|,
name|LNOACCT
block|,
name|LOMITANY
block|,
name|LALWAYS
block|,
name|LSYMLINK
block|,
name|LRSYMLINK
block|,
name|LRENAME
block|}
name|LISTTYPE
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ltname
index|[]
init|=
block|{
literal|"upgrade"
block|,
literal|"omit"
block|,
literal|"backup"
block|,
literal|"execute"
block|,
literal|"include"
block|,
literal|"noaccount"
block|,
literal|"omitany"
block|,
literal|"always"
block|,
literal|"symlink"
block|,
literal|"rsymlink"
block|,
literal|"rename"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FALWAYS
value|FUPDATE
end_define

begin_comment
comment|/* list file lines */
end_comment

begin_decl_stmt
specifier|static
name|TREE
modifier|*
name|upgT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* files to upgrade */
end_comment

begin_decl_stmt
specifier|static
name|TREE
modifier|*
name|flagsT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* special flags: BACKUP NOACCT */
end_comment

begin_decl_stmt
specifier|static
name|TREE
modifier|*
name|omitT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recursize file omition list */
end_comment

begin_decl_stmt
specifier|static
name|TREE
modifier|*
name|omanyT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-recursize file omition list */
end_comment

begin_decl_stmt
specifier|static
name|TREE
modifier|*
name|symT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbolic links to quote */
end_comment

begin_decl_stmt
specifier|static
name|TREE
modifier|*
name|rsymT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recursive symbolic links to quote */
end_comment

begin_decl_stmt
specifier|static
name|TREE
modifier|*
name|execT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* execute command list */
end_comment

begin_comment
comment|/*************************  ***    E X T E R N    ***  *************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|_argbreak
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
name|_argbreak
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* break character from nxtarg */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|TREELIST
modifier|*
name|listTL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of trees for scanning */
end_comment

begin_decl_stmt
specifier|extern
name|TREE
modifier|*
name|listT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* final list of files in collection */
end_comment

begin_decl_stmt
specifier|extern
name|TREE
modifier|*
name|refuseT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* files refused by client */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|collname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* collection name */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|basedir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base directory name */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* collection pathname prefix */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|lasttime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time of last upgrade */
end_comment

begin_decl_stmt
specifier|extern
name|long
name|scantime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time of this scan */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|trace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* trace directories */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|newonly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new files only */
end_comment

begin_function_decl
specifier|extern
name|long
name|time
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*************************************************  ***   STATIC   R O U T I N E S    ***  *************************************************/
end_comment

begin_expr_stmt
specifier|static
name|makescan
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|getscan
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|doscan
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|readlistfile
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|expTinsert
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|listone
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|listentry
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|listname
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|listdir
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|omitanyone
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|anyglob
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|getscanfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chkscanfile
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|makescanfile
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|recordone
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|recordexec
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*************************************************  ***    L I S T   S C A N   R O U T I N E S    ***  *************************************************/
end_comment

begin_expr_stmt
specifier|static
name|passdelim
argument_list|(
argument|ptr
argument_list|,
argument|delim
argument_list|)
comment|/* skip over delimiter */
name|char
operator|*
operator|*
name|ptr
operator|,
name|delim
expr_stmt|;
end_expr_stmt

begin_block
block|{
operator|*
name|ptr
operator|=
name|skipover
argument_list|(
operator|*
name|ptr
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_argbreak
operator|!=
name|delim
operator|&&
operator|*
operator|*
name|ptr
operator|==
name|delim
condition|)
block|{
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
operator|*
name|ptr
operator|=
name|skipover
argument_list|(
operator|*
name|ptr
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|parserelease
parameter_list|(
name|tlp
parameter_list|,
name|relname
parameter_list|,
name|args
parameter_list|)
name|TREELIST
modifier|*
modifier|*
name|tlp
decl_stmt|;
name|char
modifier|*
name|relname
decl_stmt|,
decl|*
name|args
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|TREELIST
modifier|*
name|tl
decl_stmt|;
specifier|register
name|char
modifier|*
name|arg
decl_stmt|;
specifier|register
name|OPTION
name|option
decl_stmt|;
name|int
name|opno
decl_stmt|;
name|char
modifier|*
name|nextrel
decl_stmt|;
name|tl
operator|=
operator|(
name|TREELIST
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|TREELIST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|tlp
operator|=
name|tl
operator|)
operator|==
name|NULL
condition|)
name|goaway
argument_list|(
literal|"Couldn't allocate TREELIST"
argument_list|)
expr_stmt|;
name|tl
operator|->
name|TLnext
operator|=
name|NULL
expr_stmt|;
name|tl
operator|->
name|TLname
operator|=
name|salloc
argument_list|(
name|relname
argument_list|)
expr_stmt|;
name|tl
operator|->
name|TLprefix
operator|=
name|NULL
expr_stmt|;
name|tl
operator|->
name|TLlist
operator|=
name|NULL
expr_stmt|;
name|tl
operator|->
name|TLscan
operator|=
name|NULL
expr_stmt|;
name|tl
operator|->
name|TLhost
operator|=
name|NULL
expr_stmt|;
name|nextrel
operator|=
name|NULL
expr_stmt|;
name|args
operator|=
name|skipover
argument_list|(
name|args
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|(
name|arg
operator|=
name|nxtarg
argument_list|(
operator|&
name|args
argument_list|,
literal|" \t="
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|opno
operator|=
literal|0
init|;
name|options
index|[
name|opno
index|]
operator|!=
name|NULL
condition|;
name|opno
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
name|options
index|[
name|opno
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|options
index|[
name|opno
index|]
operator|==
name|NULL
condition|)
name|goaway
argument_list|(
literal|"Invalid release option %s for release %s"
argument_list|,
name|arg
argument_list|,
name|relname
argument_list|)
expr_stmt|;
name|option
operator|=
operator|(
name|OPTION
operator|)
name|opno
expr_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|ONEXT
case|:
name|passdelim
argument_list|(
operator|&
name|args
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|arg
operator|=
name|nxtarg
argument_list|(
operator|&
name|args
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|nextrel
operator|=
name|salloc
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPREFIX
case|:
name|passdelim
argument_list|(
operator|&
name|args
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|arg
operator|=
name|nxtarg
argument_list|(
operator|&
name|args
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|tl
operator|->
name|TLprefix
operator|=
name|salloc
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OLIST
case|:
name|passdelim
argument_list|(
operator|&
name|args
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|arg
operator|=
name|nxtarg
argument_list|(
operator|&
name|args
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|tl
operator|->
name|TLlist
operator|=
name|salloc
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OSCAN
case|:
name|passdelim
argument_list|(
operator|&
name|args
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|arg
operator|=
name|nxtarg
argument_list|(
operator|&
name|args
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|tl
operator|->
name|TLscan
operator|=
name|salloc
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OHOST
case|:
name|passdelim
argument_list|(
operator|&
name|args
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|arg
operator|=
name|nxtarg
argument_list|(
operator|&
name|args
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|tl
operator|->
name|TLhost
operator|=
name|salloc
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|nextrel
operator|)
return|;
block|}
end_block

begin_macro
name|getrelease
argument_list|(
argument|release
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|release
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TREELIST
modifier|*
name|tl
decl_stmt|;
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|rewound
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|release
operator|==
name|NULL
condition|)
name|release
operator|=
name|salloc
argument_list|(
name|DEFRELEASE
argument_list|)
expr_stmt|;
name|listTL
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILERELEASES
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
name|rewound
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rewound
condition|)
break|break;
name|rewind
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|rewound
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
name|release
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|release
operator|=
name|parserelease
argument_list|(
operator|&
name|tl
argument_list|,
name|release
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl
operator|->
name|TLprefix
operator|==
name|NULL
condition|)
name|tl
operator|->
name|TLprefix
operator|=
name|prefix
expr_stmt|;
elseif|else
if|if
condition|(
name|chdir
argument_list|(
name|tl
operator|->
name|TLprefix
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
else|else
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
name|tl
operator|->
name|TLnext
operator|=
name|listTL
expr_stmt|;
name|listTL
operator|=
name|tl
expr_stmt|;
if|if
condition|(
name|release
operator|==
name|NULL
condition|)
break|break;
name|rewound
operator|=
name|FALSE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|release
operator|==
name|NULL
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|release
argument_list|,
name|DEFRELEASE
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
operator|(
name|void
operator|)
name|parserelease
argument_list|(
operator|&
name|tl
argument_list|,
name|release
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|tl
operator|->
name|TLprefix
operator|=
name|prefix
expr_stmt|;
name|tl
operator|->
name|TLnext
operator|=
name|listTL
expr_stmt|;
name|listTL
operator|=
name|tl
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_macro
name|makescanlists
argument_list|(
argument|releases
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
modifier|*
name|releases
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|TREELIST
modifier|*
name|tl
decl_stmt|;
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|saveprefix
init|=
name|prefix
decl_stmt|;
name|char
modifier|*
modifier|*
name|rel_index
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILERELEASES
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parserelease
argument_list|(
operator|&
name|tl
argument_list|,
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prefix
operator|=
name|tl
operator|->
name|TLprefix
operator|)
operator|==
name|NULL
condition|)
name|prefix
operator|=
name|saveprefix
expr_stmt|;
if|if
condition|(
name|prefix
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|prefix
argument_list|)
operator|<
literal|0
condition|)
name|goaway
argument_list|(
literal|"Can't chdir to %s"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|releases
condition|)
block|{
name|rel_index
operator|=
name|releases
expr_stmt|;
while|while
condition|(
operator|*
name|rel_index
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|rel_index
argument_list|,
name|tl
operator|->
name|TLname
argument_list|)
condition|)
block|{
name|makescan
argument_list|(
name|tl
operator|->
name|TLlist
argument_list|,
name|tl
operator|->
name|TLscan
argument_list|)
expr_stmt|;
break|break;
block|}
name|rel_index
operator|++
expr_stmt|;
block|}
block|}
else|else
name|makescan
argument_list|(
name|tl
operator|->
name|TLlist
argument_list|,
name|tl
operator|->
name|TLscan
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tl
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|makescan
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|FILESCANDEF
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|scanone
argument_list|(
name|t
argument_list|)
specifier|register
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|TREE
modifier|*
name|newt
decl_stmt|;
if|if
condition|(
name|newonly
operator|&&
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FNEW
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|SCMOK
operator|)
return|;
name|newt
operator|=
name|Tinsert
argument_list|(
operator|&
name|listT
argument_list|,
name|t
operator|->
name|Tname
argument_list|,
name|t
operator|->
name|Tflags
operator|&
name|FRENAME
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|newt
operator|==
name|NULL
condition|)
return|return
operator|(
name|SCMOK
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|Tnewname
condition|)
name|newt
operator|->
name|Tnewname
operator|=
name|salloc
argument_list|(
name|t
operator|->
name|Tnewname
argument_list|)
expr_stmt|;
name|newt
operator|->
name|Tmode
operator|=
name|t
operator|->
name|Tmode
expr_stmt|;
name|newt
operator|->
name|Tflags
operator|=
name|t
operator|->
name|Tflags
expr_stmt|;
name|newt
operator|->
name|Tmtime
operator|=
name|t
operator|->
name|Tmtime
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_macro
name|getscanlists
argument_list|()
end_macro

begin_block
block|{
name|TREELIST
modifier|*
name|tl
decl_stmt|,
modifier|*
name|stl
decl_stmt|;
name|stl
operator|=
name|listTL
expr_stmt|;
name|listTL
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|tl
operator|=
name|stl
operator|)
operator|!=
name|NULL
condition|)
block|{
name|prefix
operator|=
name|tl
operator|->
name|TLprefix
expr_stmt|;
name|getscan
argument_list|(
name|tl
operator|->
name|TLlist
argument_list|,
name|tl
operator|->
name|TLscan
argument_list|)
expr_stmt|;
name|tl
operator|->
name|TLtree
operator|=
name|listT
expr_stmt|;
name|stl
operator|=
name|tl
operator|->
name|TLnext
expr_stmt|;
name|tl
operator|->
name|TLnext
operator|=
name|listTL
expr_stmt|;
name|listTL
operator|=
name|tl
expr_stmt|;
block|}
name|listT
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|tl
operator|=
name|listTL
init|;
name|tl
operator|!=
name|NULL
condition|;
name|tl
operator|=
name|tl
operator|->
name|TLnext
control|)
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|tl
operator|->
name|TLtree
argument_list|,
name|scanone
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|makescan
argument_list|(
argument|listfile
argument_list|,
argument|scanfile
argument_list|)
name|char
operator|*
name|listfile
operator|,
operator|*
name|scanfile
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|listT
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|chkscanfile
argument_list|(
name|scanfile
argument_list|)
condition|)
block|{
comment|/* can we can write a scan file? */
name|doscan
argument_list|(
name|listfile
argument_list|)
expr_stmt|;
comment|/* read list file and scan disk */
name|makescanfile
argument_list|(
name|scanfile
argument_list|)
expr_stmt|;
comment|/* record names in scan file */
name|Tfree
argument_list|(
operator|&
name|listT
argument_list|)
expr_stmt|;
comment|/* free file list tree */
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|getscan
argument_list|(
argument|listfile
argument_list|,
argument|scanfile
argument_list|)
name|char
operator|*
name|listfile
operator|,
operator|*
name|scanfile
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|listT
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|getscanfile
argument_list|(
name|scanfile
argument_list|)
condition|)
block|{
comment|/* check for pre-scanned file list */
name|scantime
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|doscan
argument_list|(
name|listfile
argument_list|)
expr_stmt|;
comment|/* read list file and scan disk */
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|doscan
argument_list|(
argument|listfile
argument_list|)
name|char
operator|*
name|listfile
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|int
name|listone
parameter_list|()
function_decl|;
name|upgT
operator|=
name|NULL
expr_stmt|;
name|flagsT
operator|=
name|NULL
expr_stmt|;
name|omitT
operator|=
name|NULL
expr_stmt|;
name|omanyT
operator|=
name|NULL
expr_stmt|;
name|execT
operator|=
name|NULL
expr_stmt|;
name|symT
operator|=
name|NULL
expr_stmt|;
name|rsymT
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|listfile
operator|==
name|NULL
condition|)
name|listfile
operator|=
name|FILELISTDEF
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILELIST
argument_list|,
name|collname
argument_list|,
name|listfile
argument_list|)
expr_stmt|;
name|readlistfile
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* get contents of list file */
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|upgT
argument_list|,
name|listone
argument_list|)
expr_stmt|;
comment|/* build list of files specified */
name|cdprefix
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|upgT
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|flagsT
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|omitT
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|omanyT
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|execT
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|symT
argument_list|)
expr_stmt|;
name|Tfree
argument_list|(
operator|&
name|rsymT
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|readlistfile
argument_list|(
argument|fname
argument_list|)
name|char
operator|*
name|fname
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|int
name|ltn
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|flags
decl_stmt|;
specifier|register
name|TREE
modifier|*
modifier|*
name|t
decl_stmt|;
specifier|register
name|LISTTYPE
name|lt
decl_stmt|;
name|char
modifier|*
name|speclist
index|[
name|SPECNUMBER
index|]
decl_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
name|goaway
argument_list|(
literal|"Can't read list file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|cdprefix
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|index
argument_list|(
literal|"#;:"
argument_list|,
operator|*
name|p
argument_list|)
condition|)
continue|continue;
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|'\0'
condition|)
continue|continue;
for|for
control|(
name|ltn
operator|=
literal|0
init|;
name|ltname
index|[
name|ltn
index|]
operator|&&
name|strcmp
argument_list|(
name|q
argument_list|,
name|ltname
index|[
name|ltn
index|]
argument_list|)
operator|!=
literal|0
condition|;
name|ltn
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|ltname
index|[
name|ltn
index|]
operator|==
name|NULL
condition|)
name|goaway
argument_list|(
literal|"Invalid list file keyword %s"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|lt
operator|=
operator|(
name|LISTTYPE
operator|)
name|ltn
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|lt
condition|)
block|{
case|case
name|LUPGRADE
case|:
name|t
operator|=
operator|&
name|upgT
expr_stmt|;
break|break;
case|case
name|LRENAME
case|:
name|t
operator|=
operator|&
name|flagsT
expr_stmt|;
name|flags
operator|=
name|FRENAME
expr_stmt|;
break|break;
case|case
name|LBACKUP
case|:
name|t
operator|=
operator|&
name|flagsT
expr_stmt|;
name|flags
operator|=
name|FBACKUP
expr_stmt|;
break|break;
case|case
name|LNOACCT
case|:
name|t
operator|=
operator|&
name|flagsT
expr_stmt|;
name|flags
operator|=
name|FNOACCT
expr_stmt|;
break|break;
case|case
name|LSYMLINK
case|:
name|t
operator|=
operator|&
name|symT
expr_stmt|;
break|break;
case|case
name|LRSYMLINK
case|:
name|t
operator|=
operator|&
name|rsymT
expr_stmt|;
break|break;
case|case
name|LOMIT
case|:
name|t
operator|=
operator|&
name|omitT
expr_stmt|;
break|break;
case|case
name|LOMITANY
case|:
name|t
operator|=
operator|&
name|omanyT
expr_stmt|;
break|break;
case|case
name|LALWAYS
case|:
name|t
operator|=
operator|&
name|upgT
expr_stmt|;
name|flags
operator|=
name|FALWAYS
expr_stmt|;
break|break;
case|case
name|LINCLUDE
case|:
while|while
condition|(
operator|*
operator|(
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
condition|)
block|{
name|cdprefix
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|=
name|expand
argument_list|(
name|q
argument_list|,
name|speclist
argument_list|,
name|SPECNUMBER
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|&&
name|i
operator|<
name|SPECNUMBER
condition|;
name|i
operator|++
control|)
block|{
name|readlistfile
argument_list|(
name|speclist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cdprefix
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|speclist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|cdprefix
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|LEXECUTE
case|:
name|r
operator|=
name|p
operator|=
name|q
operator|=
name|skipover
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
do|do
block|{
name|q
operator|=
name|p
operator|=
name|skipto
argument_list|(
name|p
argument_list|,
literal|" \t("
argument_list|)
expr_stmt|;
name|p
operator|=
name|skipover
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|!=
literal|'('
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'('
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|q
operator|==
literal|0
condition|)
name|_argbreak
operator|=
literal|')'
expr_stmt|;
else|else
name|expTinsert
argument_list|(
name|q
argument_list|,
operator|&
name|execT
argument_list|,
literal|0
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|_argbreak
operator|!=
literal|')'
condition|)
do|;
continue|continue;
block|}
comment|/* fall through */
default|default:
name|goaway
argument_list|(
literal|"Error in handling list file keyword %d"
argument_list|,
name|ltn
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
operator|(
name|q
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|lt
operator|==
name|LOMITANY
condition|)
operator|(
name|void
operator|)
name|Tinsert
argument_list|(
name|t
argument_list|,
name|q
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lt
operator|==
name|LRENAME
condition|)
if|if
condition|(
operator|*
operator|(
name|r
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
condition|)
block|{
name|expTinsert
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
name|flags
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* 					 * Omit the file it is being 					 * renamed to, to avoid confusion 					 */
name|expTinsert
argument_list|(
name|r
argument_list|,
operator|&
name|omitT
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Rename %s without destination "
literal|"file.  Skipping...\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
else|else
name|expTinsert
argument_list|(
name|q
argument_list|,
name|t
argument_list|,
name|flags
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|expTinsert
argument_list|(
argument|p
argument_list|,
argument|t
argument_list|,
argument|flags
argument_list|,
argument|exec
argument_list|,
argument|q
argument_list|)
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|TREE
modifier|*
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|exec
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|TREE
modifier|*
name|newt
decl_stmt|,
modifier|*
name|ts
decl_stmt|;
name|char
modifier|*
name|speclist
index|[
name|SPECNUMBER
index|]
decl_stmt|;
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|n
operator|=
name|expand
argument_list|(
name|p
argument_list|,
name|speclist
argument_list|,
name|SPECNUMBER
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|&&
name|i
operator|<
name|SPECNUMBER
condition|;
name|i
operator|++
control|)
block|{
name|newt
operator|=
name|Tinsert
argument_list|(
name|t
argument_list|,
name|speclist
index|[
name|i
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|newt
operator|->
name|Tflags
operator||=
name|flags
expr_stmt|;
if|if
condition|(
name|exec
condition|)
block|{
if|if
condition|(
operator|(
name|ts
operator|=
name|Tsearch
argument_list|(
name|flagsT
argument_list|,
name|speclist
index|[
name|i
index|]
argument_list|)
operator|)
operator|&&
name|ts
operator|->
name|Tflags
operator|&
name|FRENAME
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|exec
argument_list|,
name|ts
operator|->
name|Tnewname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|exec
argument_list|,
name|speclist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tinsert
argument_list|(
operator|&
name|newt
operator|->
name|Texec
argument_list|,
name|buf
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|q
condition|)
name|newt
operator|->
name|Tnewname
operator|=
name|salloc
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|speclist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|listone
argument_list|(
argument|t
argument_list|)
comment|/* expand and add one name from upgrade list */
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|listentry
argument_list|(
name|t
operator|->
name|Tname
argument_list|,
name|t
operator|->
name|Tname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|t
operator|->
name|Tflags
operator|&
name|FALWAYS
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|listentry
argument_list|(
name|name
argument_list|,
name|fullname
argument_list|,
name|updir
argument_list|,
name|always
argument_list|)
specifier|register
name|char
operator|*
name|name
operator|,
operator|*
name|fullname
operator|,
operator|*
name|updir
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|always
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|link
init|=
literal|0
decl_stmt|;
name|int
name|omitanyone
parameter_list|()
function_decl|;
if|if
condition|(
name|Tlookup
argument_list|(
name|refuseT
argument_list|,
name|fullname
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|always
condition|)
block|{
if|if
condition|(
name|Tsearch
argument_list|(
name|omitT
argument_list|,
name|fullname
argument_list|)
condition|)
return|return;
if|if
condition|(
name|Tprocess
argument_list|(
name|omanyT
argument_list|,
name|omitanyone
argument_list|,
name|fullname
argument_list|)
operator|!=
name|SCMOK
condition|)
return|return;
block|}
if|if
condition|(
name|lstat
argument_list|(
name|name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
block|{
if|if
condition|(
name|Tsearch
argument_list|(
name|symT
argument_list|,
name|fullname
argument_list|)
condition|)
block|{
name|listname
argument_list|(
name|fullname
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Tlookup
argument_list|(
name|rsymT
argument_list|,
name|fullname
argument_list|)
condition|)
block|{
name|listname
argument_list|(
name|fullname
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|updir
condition|)
name|link
operator|++
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
if|if
condition|(
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|R_OK
operator||
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|chdir
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|listname
argument_list|(
name|fullname
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|printf
argument_list|(
literal|"Scanning directory %s\n"
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|listdir
argument_list|(
name|fullname
argument_list|,
name|always
argument_list|)
expr_stmt|;
if|if
condition|(
name|updir
operator|==
literal|0
operator|||
name|link
condition|)
block|{
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|updir
operator|&&
operator|*
name|updir
condition|)
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|updir
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|chdir
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|access
argument_list|(
name|name
argument_list|,
name|R_OK
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|listname
argument_list|(
name|fullname
argument_list|,
operator|&
name|statbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|listname
argument_list|(
name|name
argument_list|,
name|st
argument_list|)
specifier|register
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|TREE
modifier|*
name|t
decl_stmt|,
modifier|*
name|ts
decl_stmt|;
specifier|register
name|int
name|new
decl_stmt|;
specifier|register
name|TREELIST
modifier|*
name|tl
decl_stmt|;
name|new
operator|=
name|st
operator|->
name|st_ctime
operator|>
name|lasttime
expr_stmt|;
if|if
condition|(
name|newonly
operator|&&
operator|!
name|new
condition|)
block|{
for|for
control|(
name|tl
operator|=
name|listTL
init|;
name|tl
operator|!=
name|NULL
condition|;
name|tl
operator|=
name|tl
operator|->
name|TLnext
control|)
if|if
condition|(
name|ts
operator|=
name|Tsearch
argument_list|(
name|tl
operator|->
name|TLtree
argument_list|,
name|name
argument_list|)
condition|)
name|ts
operator|->
name|Tflags
operator|&=
operator|~
name|FNEW
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|Tinsert
argument_list|(
operator|&
name|listT
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
return|return;
name|t
operator|->
name|Tmode
operator|=
name|st
operator|->
name|st_mode
expr_stmt|;
name|t
operator|->
name|Tctime
operator|=
name|st
operator|->
name|st_ctime
expr_stmt|;
name|t
operator|->
name|Tmtime
operator|=
name|st
operator|->
name|st_mtime
expr_stmt|;
if|if
condition|(
name|new
condition|)
name|t
operator|->
name|Tflags
operator||=
name|FNEW
expr_stmt|;
if|if
condition|(
name|ts
operator|=
name|Tsearch
argument_list|(
name|flagsT
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|t
operator|->
name|Tflags
operator||=
name|ts
operator|->
name|Tflags
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FRENAME
condition|)
name|t
operator|->
name|Tnewname
operator|=
name|salloc
argument_list|(
name|ts
operator|->
name|Tnewname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ts
operator|=
name|Tsearch
argument_list|(
name|execT
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|t
operator|->
name|Texec
operator|=
name|ts
operator|->
name|Texec
expr_stmt|;
name|ts
operator|->
name|Texec
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|listdir
argument_list|(
argument|name
argument_list|,
argument|always
argument_list|)
comment|/* expand directory */
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|always
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|dirent
modifier|*
name|dentry
decl_stmt|;
specifier|register
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|char
name|ename
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
name|newname
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
name|filename
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|newp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|dirp
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
literal|0
condition|)
return|return;
comment|/* unreadable: probably protected */
name|p
operator|=
name|name
expr_stmt|;
comment|/* punt leading ./ and trailing / */
name|newp
operator|=
name|newname
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|newp
operator|++
operator|=
operator|*
name|p
operator|++
condition|)
empty_stmt|;
comment|/* copy string */
operator|--
name|newp
expr_stmt|;
comment|/* trailing null */
while|while
condition|(
name|newp
operator|>
name|newname
operator|&&
name|newp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
operator|--
name|newp
expr_stmt|;
comment|/* trailing / */
operator|*
name|newp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|newname
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|newname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* "." ==> "" */
while|while
condition|(
name|dentry
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
condition|)
block|{
if|if
condition|(
name|dentry
operator|->
name|d_ino
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|dentry
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|dentry
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXNAMLEN
operator|&&
name|dentry
operator|->
name|d_name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|ename
index|[
name|i
index|]
operator|=
name|dentry
operator|->
name|d_name
index|[
name|i
index|]
expr_stmt|;
name|ename
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|newname
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/%s"
argument_list|,
name|newname
argument_list|,
name|ename
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|filename
argument_list|,
name|ename
argument_list|)
expr_stmt|;
name|listentry
argument_list|(
name|ename
argument_list|,
name|filename
argument_list|,
name|newname
argument_list|,
name|always
argument_list|)
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|omitanyone
argument_list|(
argument|t
argument_list|,
argument|filename
argument_list|)
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|anyglob
argument_list|(
name|t
operator|->
name|Tname
argument_list|,
operator|*
name|filename
argument_list|)
condition|)
return|return
operator|(
name|SCMERR
operator|)
return|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|anyglob
argument_list|(
argument|pattern
argument_list|,
argument|match
argument_list|)
name|char
operator|*
name|pattern
operator|,
operator|*
name|match
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|m
decl_stmt|;
specifier|register
name|char
modifier|*
name|pb
decl_stmt|,
modifier|*
name|pe
decl_stmt|;
name|p
operator|=
name|pattern
expr_stmt|;
name|m
operator|=
name|match
expr_stmt|;
while|while
condition|(
operator|*
name|m
operator|&&
operator|*
name|p
operator|==
operator|*
name|m
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|&&
operator|*
name|m
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'*'
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
if|if
condition|(
operator|*
name|m
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|*
name|p
operator|==
literal|'\0'
operator|)
return|;
if|if
condition|(
name|anyglob
argument_list|(
name|p
argument_list|,
operator|++
name|m
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
case|case
literal|'?'
case|:
return|return
operator|(
name|anyglob
argument_list|(
name|p
argument_list|,
operator|++
name|m
argument_list|)
operator|)
return|;
case|case
literal|'['
case|:
name|pb
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
operator|(
operator|++
name|p
operator|)
operator|!=
literal|']'
condition|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|pe
operator|=
name|p
expr_stmt|;
for|for
control|(
name|p
operator|=
name|pb
operator|+
literal|1
init|;
name|p
operator|!=
name|pe
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
name|p
operator|==
name|pb
operator|&&
operator|*
name|m
operator|==
literal|'-'
condition|)
block|{
name|p
operator|=
name|pe
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|anyglob
argument_list|(
name|p
argument_list|,
operator|++
name|m
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|==
name|pb
condition|)
continue|continue;
if|if
condition|(
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
name|pe
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|*
name|m
operator|>
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|&&
operator|*
name|m
operator|<=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
condition|)
block|{
name|p
operator|=
name|pe
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|anyglob
argument_list|(
name|p
argument_list|,
operator|++
name|m
argument_list|)
operator|)
return|;
block|}
continue|continue;
default|default:
if|if
condition|(
operator|*
name|m
operator|==
operator|*
name|p
condition|)
block|{
name|p
operator|=
name|pe
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|anyglob
argument_list|(
name|p
argument_list|,
operator|++
name|m
argument_list|)
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
default|default:
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/*****************************************  ***    R E A D   S C A N   F I L E    ***  *****************************************/
end_comment

begin_function
specifier|static
name|int
name|getscanfile
parameter_list|(
name|scanfile
parameter_list|)
name|char
modifier|*
name|scanfile
decl_stmt|;
block|{
name|char
name|buf
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|TREE
name|ts
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|TREE
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|t
init|=
name|NULL
decl_stmt|;
specifier|register
name|notwanted
expr_stmt|;
specifier|register
name|TREELIST
modifier|*
name|tl
decl_stmt|;
if|if
condition|(
name|scanfile
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FILESCAN
argument_list|,
name|collname
argument_list|,
name|scanfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|buf
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'V'
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|atoi
argument_list|(
name|p
argument_list|)
operator|!=
name|SCANVERSION
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|scantime
operator|=
name|sbuf
operator|.
name|st_mtime
expr_stmt|;
comment|/* upgrade time is time of supscan, 					 * i.e. time of creation of scanfile */
if|if
condition|(
name|newonly
operator|&&
name|scantime
operator|==
name|lasttime
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|notwanted
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
name|STRINGLENGTH
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|0
expr_stmt|;
name|ts
operator|.
name|Tflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'X'
condition|)
block|{
if|if
condition|(
name|notwanted
condition|)
continue|continue;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|goaway
argument_list|(
literal|"scanfile format inconsistant"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tinsert
argument_list|(
operator|&
name|t
operator|->
name|Texec
argument_list|,
operator|++
name|p
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|notwanted
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'B'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|ts
operator|.
name|Tflags
operator||=
name|FBACKUP
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'N'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|ts
operator|.
name|Tflags
operator||=
name|FNOACCT
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'R'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|ts
operator|.
name|Tflags
operator||=
name|FRENAME
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|goaway
argument_list|(
literal|"scanfile format inconsistant"
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ts
operator|.
name|Tmode
operator|=
name|atoo
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|goaway
argument_list|(
literal|"scanfile format inconsistant"
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ts
operator|.
name|Tctime
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|goaway
argument_list|(
literal|"scanfile format inconsistant"
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
name|ts
operator|.
name|Tmtime
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
name|ts
operator|.
name|Tnewname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|Tflags
operator|&
name|FRENAME
condition|)
block|{
if|if
condition|(
operator|(
name|q
operator|=
name|index
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|goaway
argument_list|(
literal|"scanfile format inconsistant"
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ts
operator|.
name|Tnewname
operator|=
name|salloc
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
name|ts
operator|.
name|Tctime
operator|>
name|lasttime
condition|)
name|ts
operator|.
name|Tflags
operator||=
name|FNEW
expr_stmt|;
elseif|else
if|if
condition|(
name|newonly
condition|)
block|{
for|for
control|(
name|tl
operator|=
name|listTL
init|;
name|tl
operator|!=
name|NULL
condition|;
name|tl
operator|=
name|tl
operator|->
name|TLnext
control|)
if|if
condition|(
name|tmp
operator|=
name|Tsearch
argument_list|(
name|tl
operator|->
name|TLtree
argument_list|,
name|q
argument_list|)
condition|)
name|tmp
operator|->
name|Tflags
operator|&=
operator|~
name|FNEW
expr_stmt|;
name|notwanted
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|Tlookup
argument_list|(
name|refuseT
argument_list|,
name|q
argument_list|)
condition|)
block|{
name|notwanted
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
name|t
operator|=
name|Tinsert
argument_list|(
operator|&
name|listT
argument_list|,
name|q
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|t
operator|->
name|Tmode
operator|=
name|ts
operator|.
name|Tmode
expr_stmt|;
name|t
operator|->
name|Tflags
operator|=
name|ts
operator|.
name|Tflags
expr_stmt|;
name|t
operator|->
name|Tctime
operator|=
name|ts
operator|.
name|Tctime
expr_stmt|;
name|t
operator|->
name|Tmtime
operator|=
name|ts
operator|.
name|Tmtime
expr_stmt|;
name|t
operator|->
name|Tnewname
operator|=
name|ts
operator|.
name|Tnewname
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************  ***    W R I T E   S C A N   F I L E    ***  *******************************************/
end_comment

begin_expr_stmt
specifier|static
name|chkscanfile
argument_list|(
argument|scanfile
argument_list|)
name|char
operator|*
name|scanfile
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|tname
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
name|fname
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|scanfile
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
name|FILESCAN
argument_list|,
name|collname
argument_list|,
name|scanfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"%s.temp"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|tname
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
name|goaway
argument_list|(
literal|"Can't test scan file temp %s for %s"
argument_list|,
name|tname
argument_list|,
name|collname
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|makescanfile
argument_list|(
argument|scanfile
argument_list|)
name|char
operator|*
name|scanfile
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|tname
index|[
name|STRINGLENGTH
index|]
decl_stmt|,
name|fname
index|[
name|STRINGLENGTH
index|]
decl_stmt|;
name|struct
name|timeval
name|tbuf
index|[
literal|2
index|]
decl_stmt|;
name|FILE
modifier|*
name|scanF
decl_stmt|;
comment|/* output file for scanned file list */
name|int
name|recordone
parameter_list|()
function_decl|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fname
argument_list|,
name|FILESCAN
argument_list|,
name|collname
argument_list|,
name|scanfile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"%s.temp"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|scanF
operator|=
name|fopen
argument_list|(
name|tname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scanF
operator|==
name|NULL
condition|)
name|goaway
argument_list|(
literal|"Can't write scan file temp %s for %s"
argument_list|,
name|tname
argument_list|,
name|collname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|scanF
argument_list|,
literal|"V%d\n"
argument_list|,
name|SCANVERSION
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|listT
argument_list|,
name|recordone
argument_list|,
name|scanF
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|scanF
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tname
argument_list|,
name|fname
argument_list|)
operator|<
literal|0
condition|)
name|goaway
argument_list|(
literal|"Can't change %s to %s"
argument_list|,
name|tname
argument_list|,
name|fname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|scantime
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|utimes
argument_list|(
name|fname
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|recordone
argument_list|(
argument|t
argument_list|,
argument|scanF
argument_list|)
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
modifier|*
name|scanF
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|recordexec
parameter_list|()
function_decl|;
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FBACKUP
condition|)
name|fprintf
argument_list|(
operator|*
name|scanF
argument_list|,
literal|"B"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FNOACCT
condition|)
name|fprintf
argument_list|(
operator|*
name|scanF
argument_list|,
literal|"N"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FRENAME
condition|)
name|fprintf
argument_list|(
operator|*
name|scanF
argument_list|,
literal|"R"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
operator|*
name|scanF
argument_list|,
literal|"%o %d %d"
argument_list|,
name|t
operator|->
name|Tmode
argument_list|,
name|t
operator|->
name|Tctime
argument_list|,
name|t
operator|->
name|Tmtime
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|Tflags
operator|&
name|FRENAME
condition|)
name|fprintf
argument_list|(
operator|*
name|scanF
argument_list|,
literal|" %s %s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|,
name|t
operator|->
name|Tnewname
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
operator|*
name|scanF
argument_list|,
literal|" %s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Tprocess
argument_list|(
name|t
operator|->
name|Texec
argument_list|,
name|recordexec
argument_list|,
operator|*
name|scanF
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|recordexec
argument_list|(
argument|t
argument_list|,
argument|scanF
argument_list|)
name|TREE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
modifier|*
name|scanF
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
operator|*
name|scanF
argument_list|,
literal|"X%s\n"
argument_list|,
name|t
operator|->
name|Tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCMOK
operator|)
return|;
block|}
end_block

begin_macro
name|cdprefix
argument_list|(
argument|prefix
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
modifier|*
name|curprefix
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|curprefix
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|prefix
operator|==
name|NULL
condition|)
return|return;
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|curprefix
operator|=
name|prefix
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prefix
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
name|curprefix
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prefix
operator|==
name|curprefix
condition|)
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|prefix
argument_list|,
name|curprefix
argument_list|)
operator|==
literal|0
condition|)
block|{
name|curprefix
operator|=
name|prefix
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|basedir
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|curprefix
operator|=
name|prefix
expr_stmt|;
block|}
end_block

end_unit

