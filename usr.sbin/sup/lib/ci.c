begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator   or   Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the rights  * to redistribute these changes.  */
end_comment

begin_comment
comment|/*  ci  -- command interpreter  *  *  Usage (etc.)  *  * HISTORY  * 22-Nov-85  Glenn Marcy (gm0w) at Carnegie-Mellon University  *	Removed checks for VIRTUE window manager.  If they don't like  *	it then they can fix the more program.  *  * 08-May-85  Steven Shafer (sas) at Carnegie-Mellon University  *	Increased MAXENTRIES and MAXHELPS from 200 to 400.  *  * 30-Apr-85  Steven Shafer (sas) at Carnegie-Mellon University  *	Adapted for 4.2 UNIX.  Added calls to check for  *	using window manager of VIRTUE.  *  * 29-Apr-85  Steven Shafer (sas) at Carnegie-Mellon University  *	Added two small bug fixes (courtesy of Richard Cohn).  *  * 14-Aug-84  Steven Shafer (sas) at Carnegie-Mellon University  *	Added fflush(stdout) after printing prompt, before asking for input line.  *  * 01-Jul-83  Steven Shafer (sas) at Carnegie-Mellon University  *	Bug fix: whitespace now required before ">filename" and not permitted  *	within or after filename.  *  * 06-Jun-83  Steven Shafer (sas) at Carnegie-Mellon University  *	Bug fix: added line to initialize "redirected" to 0.  *  * 20-May-83  Steven Shafer (sas) at Carnegie-Mellon University  *	Added quiet bits CINOSEM, CINOFILE, CIFIRSTEQUAL to allow user to  *	have special characters ;> = treated as normal data (except =  *	after first argument, which still means "variable assignment").  *	Also added output redirection via>filename on input line.  *  * 07-Mar-83  Dave McKeown (dmm) at Carnegie-Mellon University  *	(Slight alterations by Steve Shafer.)  *	Made cidepth a global, used for recursive and nested calls to  *	ci(), and accessable to the user.  Added '@x' command, similar  *	to '^x' except that the previous command interpreter name is  *	remembered and after 'x' is executed, the previous command  *	interpreter is reinvoked.  Users who plan to use this feature  *	must save the name of the previous ci in global variable   *	'ciprev' after exit from the ci().  ie.    *		ci(.........);  *		strcpy(ciprev,"ci-name");  *	Added ci state CICMDNOINDENT to allow for no indentation of the  *	command line prompt based on cidepth.  *	Reduced amount of indentation on source code.  *	Bug: the "depth" argument is now a no-op, retained for backward  *	compatibility.  Cidepth is initialized to zero, and incremented  *	upon invocation of a ci().  If cidepth is<1 then you are not  *	in a ci() instantiation.  *  * 21-Feb-83  Steven Shafer (sas) at Carnegie-Mellon University  *	Added up-arrow (^) command (and variable cinext).  ^x is used when  *	you have a ci program in which one command invokes ci with a  *	new set of commands (i.e. a subsystem of the program).  Inside the  *	subsystem, ^x will exit the subsystem, and cause the main level  *	to execute the command line "x" before reading more input lines.  *	The cinext variable is used to implement this.  Cinext can also be  *	used by any user code which desires to force ci to execute a  *	specific command before reading more input from the current file.  *  * 16-Jul-82  Steven Shafer (sas) at Carnegie-Mellon University  *	Added extra code in _ci_help to eliminate duplicate help file  *	names.  This way, if several directories are specified and there  *	is are files with the same name in more than one directory, only  *	the first of each file will be included in the help list.  *	  *	It would have been nice to do this after the qsort instead of  *	before (in ci_help).  However, qsort does not ensure that  *	"equivalent" entries are kept in the same relative  *	order; thus there would be no way to ensure that the  *	file being used was the first such file found.  *  * 07-Jul-82  William Chiles (wpc) at Carnegie-Mellon University  *	Modified so that "!" invokes shell commands from the type of   *      shell specified by the environment variable SHELL.  If SHELL  *	is not defined the standard shell is used.  *  * 21-Sep-81  Steven Shafer (sas) at Carnegie-Mellon University  *	Increased LINELENGTH (input buffer length) to 1100 to satisfy  *	voracious requirements of a certain user whose name I won't mention  *	but whose initials are "faa".  *  * 08-Oct-80  Steven Shafer (sas) at Carnegie-Mellon University  *	Added class variables:  ci_tclass cases in ci_show and ci_set.  *	Also added CICMDFPEEK in addition to existing CISETPEEK.  *  * 22-May-80  Steven Shafer (sas) at Carnegie-Mellon University  *	Ci now sorts help topics into alphabetical order.  Some interrupt  *	handling has been added, but there are bugs, for example, when  *	you interrupt "*" (the listing of command names).  The right thing  *	happens, but bogus messages are printed.  *  * 16-Apr-80  Steven Shafer (sas) at Carnegie-Mellon University  *	Ci now prints lists of names with prstab().  This uses multiple  *	columns when appropriate.  *  * 12-Mar-80  Steven Shafer (sas) at Carnegie-Mellon University  *	Added code to skip over leading blanks and tabs in the argument list  *	when executing commands, and setting and displaying variables.  *	Also fixed meta-help, which mysteriously disappeared.  *  * 19-Feb-80  Steven Shafer (sas) at Carnegie-Mellon University  *	Added "if (0) del();" to force del() routine to be loaded.  This is  *	the safest way I know of to define the external int "_del_".  If you  *	don't believe it, think again about separately compiled files.  *  * 28-Jan-80  Steven Shafer (sas) at Carnegie-Mellon University  *	Created.  Patterned (somewhat) after ci() on PDP-11.  *  */
end_comment

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<libc.h>
end_include

begin_include
include|#
directive|include
file|<ci.h>
end_include

begin_include
include|#
directive|include
file|<del.h>
end_include

begin_decl_stmt
name|char
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|_argbreak
decl_stmt|;
end_decl_stmt

begin_function_decl
name|long
name|atol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|double
name|atof
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ci_help
argument_list|()
decl_stmt|,
name|ci_show
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_ci_sho
argument_list|()
decl_stmt|,
name|_ci_set
argument_list|()
decl_stmt|,
name|ci_set
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************  ***    M A C R O S    ***  *************************/
end_comment

begin_define
define|#
directive|define
name|LINELENGTH
value|1100
end_define

begin_comment
comment|/* max length of input line */
end_comment

begin_define
define|#
directive|define
name|MAXENTRIES
value|400
end_define

begin_comment
comment|/* max entries in entry list */
end_comment

begin_define
define|#
directive|define
name|MAXHELPS
value|400
end_define

begin_comment
comment|/* max help files available */
end_comment

begin_define
define|#
directive|define
name|METAHELP
value|"/usr/lib/ci.help"
end_define

begin_comment
comment|/* standard help file */
end_comment

begin_comment
comment|/*********************************************  ***    G L O B A L   V A R I A B L E S    ***  *********************************************/
end_comment

begin_decl_stmt
name|int
name|ciquiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* init globals */
end_comment

begin_decl_stmt
name|int
name|ciexit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cidepth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ciback
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for use in '@' command */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|ciinput
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cinext
index|[
name|LINELENGTH
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|ciprev
index|[
name|LINELENGTH
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|delchoice
index|[]
init|=
block|{
comment|/* breakpoint choices */
literal|"abort		abort command file"
block|,
literal|"breakpoint	break to tty, then resume command file"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************************  ***    M A I N   R O U T I N E    ***  *************************************/
end_comment

begin_macro
name|ci
argument_list|(
argument|prompt
argument_list|,
argument|fil
argument_list|,
argument|depth
argument_list|,
argument|list
argument_list|,
argument|helppath
argument_list|,
argument|cmdfpath
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prompt message */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file */
end_comment

begin_decl_stmt
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* recursion depth */
end_comment

begin_decl_stmt
name|CIENTRY
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* entry list */
end_comment

begin_decl_stmt
name|char
modifier|*
name|helppath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* search list for help files */
end_comment

begin_decl_stmt
name|char
modifier|*
name|cmdfpath
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* search list for command files */
end_comment

begin_block
block|{
name|FILE
modifier|*
name|savfile
decl_stmt|;
comment|/* input file for calling instance of ci */
name|int
name|savquiet
decl_stmt|,
name|savexit
decl_stmt|;
comment|/* globals for calling instance of ci */
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
comment|/* temps for parsing input */
name|int
name|i
decl_stmt|;
comment|/* temp */
name|char
name|line
index|[
name|LINELENGTH
index|]
decl_stmt|;
comment|/* input line buffer */
name|int
name|firststmt
decl_stmt|;
comment|/* temp */
name|char
modifier|*
name|equals
decl_stmt|,
modifier|*
name|star
decl_stmt|;
comment|/* index of = and * in input line */
name|char
name|cfnam
index|[
literal|200
index|]
decl_stmt|;
comment|/* name of command file */
name|char
modifier|*
name|name
index|[
name|MAXENTRIES
index|]
decl_stmt|;
comment|/* name list for entries */
name|char
modifier|*
name|vname
index|[
name|MAXENTRIES
index|]
decl_stmt|;
comment|/* name list for just variables */
name|int
name|vnum
index|[
name|MAXENTRIES
index|]
decl_stmt|;
comment|/* correspondence list for variables */
name|int
name|nv
decl_stmt|;
comment|/* number of variables */
name|int
name|helpcmd
decl_stmt|;
comment|/* "help" command index */
name|FILE
modifier|*
name|newfile
decl_stmt|;
comment|/* command file just opened */
name|char
name|bprompt
index|[
literal|100
index|]
decl_stmt|;
comment|/* breakpoint prompt */
name|char
modifier|*
name|tname
index|[
name|MAXENTRIES
index|]
decl_stmt|;
comment|/* temp name list */
name|int
name|tnum
decl_stmt|;
comment|/* # entries in tname */
name|char
modifier|*
name|Shell
decl_stmt|;
comment|/* holds SHELL value from .login */
name|int
name|redirected
decl_stmt|;
comment|/* 1 iff currently redirected output */
name|FILE
name|savestdout
decl_stmt|;
comment|/* place to save normal std. output */
name|FILE
modifier|*
name|outfile
decl_stmt|;
comment|/* current output file */
name|char
modifier|*
name|outname
decl_stmt|;
comment|/* output file name */
comment|/* force del() routine to be declared */
if|if
condition|(
literal|0
condition|)
name|del
argument_list|()
expr_stmt|;
comment|/* save globals on stack */
name|cidepth
operator|++
expr_stmt|;
comment|/* bump the global depth, first CI() is 1 */
name|savquiet
operator|=
name|ciquiet
expr_stmt|;
name|savexit
operator|=
name|ciexit
expr_stmt|;
name|savfile
operator|=
name|ciinput
expr_stmt|;
name|ciexit
operator|=
literal|0
expr_stmt|;
comment|/* don't exit until this is set */
name|ciinput
operator|=
operator|(
name|fil
condition|?
name|fil
else|:
name|stdin
operator|)
expr_stmt|;
comment|/* new input file */
comment|/* construct name lists for stablk */
name|nv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|list
index|[
name|i
index|]
operator|.
name|ci_etyp
operator|!=
name|ci_tend
condition|;
name|i
operator|++
control|)
block|{
name|name
index|[
name|i
index|]
operator|=
name|list
index|[
name|i
index|]
operator|.
name|ci_enam
expr_stmt|;
if|if
condition|(
name|list
index|[
name|i
index|]
operator|.
name|ci_etyp
operator|!=
name|ci_tcmd
condition|)
block|{
comment|/* is variable */
name|vname
index|[
name|nv
index|]
operator|=
name|name
index|[
name|i
index|]
expr_stmt|;
name|vnum
index|[
name|nv
index|]
operator|=
name|i
expr_stmt|;
name|nv
operator|++
expr_stmt|;
block|}
block|}
name|helpcmd
operator|=
name|i
operator|++
expr_stmt|;
comment|/* force-feed "help" onto list */
name|name
index|[
name|helpcmd
index|]
operator|=
literal|"help"
expr_stmt|;
name|name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|vname
index|[
name|nv
index|]
operator|=
literal|0
expr_stmt|;
comment|/* loop for input lines */
name|redirected
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|ciexit
condition|)
block|{
if|if
condition|(
operator|*
name|cinext
condition|)
block|{
comment|/* get line from ^ command */
if|if
condition|(
name|ciback
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s;%s"
argument_list|,
name|cinext
argument_list|,
name|ciprev
argument_list|)
expr_stmt|;
name|ciback
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|line
argument_list|,
name|cinext
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|cinext
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
comment|/* else read file */
if|if
condition|(
operator|(
name|ciinput
operator|==
name|stderr
operator|)
operator|||
operator|(
name|ciinput
operator|==
name|stdin
operator|)
operator|||
operator|(
operator|!
operator|(
name|ciquiet
operator|&
name|CICMDFPROMPT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ciquiet
operator|&
name|CICMDNOINDENT
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|cidepth
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ciinput
operator|==
name|stderr
operator|)
operator|||
operator|(
name|ciinput
operator|==
name|stdin
operator|)
condition|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|fgets
argument_list|(
name|line
argument_list|,
name|LINELENGTH
argument_list|,
name|ciinput
argument_list|)
expr_stmt|;
comment|/* read input line */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
comment|/* EOF */
if|if
condition|(
name|_del_
condition|)
block|{
name|DELCLEAR
expr_stmt|;
name|strcpy
argument_list|(
name|line
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|p
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
name|ciexit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ciinput
operator|==
name|stdin
operator|)
operator|||
operator|(
name|ciinput
operator|==
name|stderr
operator|)
operator|||
operator|(
operator|!
operator|(
name|ciquiet
operator|&
name|CICMDFECHO
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ciinput
operator|!=
name|stderr
operator|)
operator|&&
operator|(
name|ciinput
operator|!=
name|stdin
operator|)
operator|&&
operator|(
operator|!
operator|(
name|ciquiet
operator|&
name|CICMDFECHO
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|line
init|;
operator|(
operator|*
name|p
operator|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\n'
operator|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* kill trailing newline */
name|p
operator|=
name|line
expr_stmt|;
comment|/* points to start of line */
block|}
block|}
comment|/* check for redirection of output */
if|if
condition|(
operator|!
name|ciexit
condition|)
block|{
name|outname
operator|=
name|rindex
argument_list|(
name|p
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|outname
condition|)
block|{
if|if
condition|(
name|outname
operator|==
name|p
operator|||
operator|*
operator|(
name|outname
operator|+
literal|1
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
operator|*
operator|(
name|outname
operator|-
literal|1
operator|)
operator|!=
literal|' '
operator|)
operator|&&
operator|(
operator|*
operator|(
name|outname
operator|-
literal|1
operator|)
operator|!=
literal|'\t'
operator|)
operator|)
condition|)
block|{
name|outname
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|q
operator|=
name|outname
operator|+
literal|1
init|;
operator|*
name|q
operator|&&
operator|(
operator|*
name|q
operator|!=
literal|' '
operator|)
operator|&&
operator|(
operator|*
name|q
operator|!=
literal|'\t'
operator|)
condition|;
name|q
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
name|outname
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outname
operator|&&
operator|!
operator|(
name|ciquiet
operator|&
name|CINOFILE
operator|)
condition|)
block|{
operator|*
name|outname
operator|++
operator|=
literal|0
expr_stmt|;
name|outfile
operator|=
name|fopen
argument_list|(
name|outname
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ci: Can't create output file %s\n"
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|savestdout
operator|=
operator|*
name|stdout
expr_stmt|;
operator|*
name|stdout
operator|=
operator|*
name|outfile
expr_stmt|;
name|redirected
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* loop for each command */
name|firststmt
operator|=
literal|1
expr_stmt|;
comment|/* first time through loop */
while|while
condition|(
operator|(
operator|!
name|ciexit
operator|)
operator|&&
operator|(
operator|(
operator|(
name|ciquiet
operator|&
name|CINOSEM
operator|)
operator|&&
name|firststmt
operator|)
operator|||
operator|*
operator|(
name|cmd
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|";"
argument_list|)
operator|)
operator|||
name|_argbreak
operator|)
condition|)
block|{
if|if
condition|(
name|ciquiet
operator|&
name|CINOSEM
condition|)
block|{
name|cmd
operator|=
name|p
expr_stmt|;
name|firststmt
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
comment|/* what kind of line? */
case|case
literal|':'
case|:
comment|/* :  comment */
case|case
literal|0
case|:
comment|/*    null line */
break|break;
case|case
literal|'!'
case|:
comment|/* !  shell command */
name|cmd
operator|=
name|skipover
argument_list|(
name|cmd
operator|+
literal|1
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|Shell
operator|=
literal|"sh"
expr_stmt|;
if|if
condition|(
operator|*
name|cmd
condition|)
name|runp
argument_list|(
name|Shell
argument_list|,
name|Shell
argument_list|,
literal|"-c"
argument_list|,
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|runp
argument_list|(
name|Shell
argument_list|,
name|Shell
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ciquiet
operator|&
name|CISHEXIT
operator|)
condition|)
name|printf
argument_list|(
literal|"Back to %s\n"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* ?  help */
name|cmd
operator|=
name|skipover
argument_list|(
name|cmd
operator|+
literal|1
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|ci_help
argument_list|(
name|cmd
argument_list|,
name|helppath
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
comment|/*<  command file */
name|arg
operator|=
name|cmd
operator|+
literal|1
expr_stmt|;
name|cmd
operator|=
name|nxtarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* parse name */
if|if
condition|(
operator|*
name|cmd
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"ci: missing filename\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cmdfpath
condition|)
name|newfile
operator|=
name|fopenp
argument_list|(
name|cmdfpath
argument_list|,
name|cmd
argument_list|,
name|cfnam
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
name|newfile
operator|=
name|fopen
argument_list|(
name|cmd
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfile
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"ci: can't open command file %s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ciquiet
operator|&
name|CICMDFECHO
operator|)
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ci
argument_list|(
name|prompt
argument_list|,
name|newfile
argument_list|,
name|cidepth
argument_list|,
name|list
argument_list|,
name|helppath
argument_list|,
name|cmdfpath
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|newfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ciquiet
operator|&
name|CICMDFEXIT
operator|)
condition|)
name|printf
argument_list|(
literal|"End of file\n\n"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'^'
case|:
comment|/* exit and do command */
case|case
literal|'@'
case|:
if|if
condition|(
name|cidepth
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'@'
condition|)
name|ciback
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|_argbreak
operator|==
literal|';'
condition|)
operator|*
operator|(
name|cmd
operator|+
name|strlen
argument_list|(
name|cmd
argument_list|)
operator|)
operator|=
literal|';'
expr_stmt|;
name|ciexit
operator|=
literal|1
expr_stmt|;
name|cmd
operator|=
name|skipover
argument_list|(
name|cmd
operator|+
literal|1
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cinext
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"ci: ^ not allowed at top level of ci\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* list cmds, etc. */
name|equals
operator|=
name|index
argument_list|(
name|cmd
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|equals
operator|==
name|cmd
condition|)
name|cmd
operator|++
expr_stmt|;
if|if
condition|(
name|equals
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|equals
operator|+
literal|1
operator|)
operator|==
literal|0
condition|)
operator|*
name|equals
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|equals
operator|=
literal|' '
expr_stmt|;
block|}
name|arg
operator|=
name|cmd
expr_stmt|;
comment|/* parse first word */
name|cmd
operator|=
name|nxtarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ciquiet
operator|&
name|CIFIRSTEQUAL
operator|)
operator|&&
name|equals
operator|&&
name|equals
operator|>
name|arg
condition|)
block|{
operator|*
name|equals
operator|=
literal|'='
expr_stmt|;
comment|/* if user doesn't want extra =, kill */
name|equals
operator|=
literal|0
expr_stmt|;
block|}
name|star
operator|=
name|index
argument_list|(
name|cmd
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
name|star
condition|)
operator|*
name|star
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|star
operator|&&
name|equals
condition|)
block|{
comment|/* list vars */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vname
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stlmatch
argument_list|(
name|vname
index|[
name|i
index|]
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|ci_show
argument_list|(
name|list
index|[
name|vnum
index|[
name|i
index|]
index|]
argument_list|,
name|arg
argument_list|,
name|CIPEEK
argument_list|)
expr_stmt|;
block|}
name|DELBREAK
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|star
condition|)
block|{
comment|/* list cmds */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|tnum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|name
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|==
name|helpcmd
operator|||
name|list
index|[
name|i
index|]
operator|.
name|ci_etyp
operator|==
name|ci_tcmd
operator|)
operator|&&
name|stlmatch
argument_list|(
name|name
index|[
name|i
index|]
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|tname
index|[
name|tnum
operator|++
index|]
operator|=
name|name
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|tname
index|[
name|tnum
index|]
operator|=
literal|0
expr_stmt|;
name|prstab
argument_list|(
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|_del_
condition|)
block|{
name|_DELNOTE_
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|equals
condition|)
block|{
comment|/* set var */
name|i
operator|=
name|stablk
argument_list|(
name|cmd
argument_list|,
name|vname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|ci_set
argument_list|(
name|list
index|[
name|vnum
index|[
name|i
index|]
index|]
argument_list|,
name|skipover
argument_list|(
name|arg
argument_list|,
literal|" \t"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|stablk
argument_list|(
name|cmd
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|helpcmd
condition|)
name|ci_help
argument_list|(
name|arg
argument_list|,
name|helppath
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|list
index|[
name|i
index|]
operator|.
name|ci_etyp
operator|==
name|ci_tcmd
condition|)
block|{
operator|(
operator|*
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|list
index|[
name|i
index|]
operator|.
name|ci_eptr
operator|)
operator|)
operator|(
name|skipover
argument_list|(
name|arg
argument_list|,
literal|" \t"
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|ci_show
argument_list|(
name|list
index|[
name|i
index|]
argument_list|,
name|skipover
argument_list|(
name|arg
argument_list|,
literal|" \t"
argument_list|)
argument_list|,
name|CISHOW
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* end of command */
comment|/* DEL trapping */
if|if
condition|(
name|_del_
condition|)
block|{
if|if
condition|(
name|ciinput
operator|==
name|stdin
condition|)
block|{
name|DELCLEAR
expr_stmt|;
comment|/* already at tty level */
block|}
else|else
block|{
name|_del_
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|getstab
argument_list|(
literal|"INTERRUPT:  abort or breakpoint?"
argument_list|,
name|delchoice
argument_list|,
literal|"abort"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|ciexit
operator|=
literal|1
expr_stmt|;
comment|/* abort */
else|else
block|{
comment|/* breakpoint */
name|sprintf
argument_list|(
name|bprompt
argument_list|,
literal|"Breakpoint for %s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|ci
argument_list|(
name|bprompt
argument_list|,
literal|0
argument_list|,
name|cidepth
argument_list|,
name|list
argument_list|,
name|helppath
argument_list|,
name|cmdfpath
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* end of loop for commands */
block|}
comment|/* end of loop for lines of input file */
if|if
condition|(
name|redirected
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|*
name|stdout
operator|=
name|savestdout
expr_stmt|;
name|redirected
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* restore globals */
name|cidepth
operator|--
expr_stmt|;
comment|/* update current depth */
name|ciinput
operator|=
name|savfile
expr_stmt|;
name|ciquiet
operator|=
name|savquiet
expr_stmt|;
name|ciexit
operator|=
name|savexit
expr_stmt|;
block|}
end_block

begin_comment
comment|/********************************************  ***    P R I N T   H E L P   F I L E     ***  ********************************************/
end_comment

begin_decl_stmt
specifier|static
name|int
name|_h_found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many matching names? */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|_h_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of matching names */
end_comment

begin_expr_stmt
specifier|static
name|char
argument_list|(
operator|*
name|_h_nlist
argument_list|)
index|[
literal|20
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* list of filename part of names */
end_comment

begin_function
specifier|static
name|int
name|_ci_help
parameter_list|(
name|filspec
parameter_list|)
comment|/* called by searchp to expand filspec, adding names to _h_list */
name|char
modifier|*
name|filspec
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|result
decl_stmt|;
name|char
name|dir
index|[
literal|200
index|]
decl_stmt|;
name|result
operator|=
name|expand
argument_list|(
name|filspec
argument_list|,
name|_h_list
operator|+
name|_h_found
argument_list|,
name|MAXHELPS
operator|-
name|_h_found
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|result
condition|;
control|)
block|{
comment|/* elim duplicates */
name|path
argument_list|(
name|_h_list
index|[
name|i
operator|+
name|_h_found
index|]
argument_list|,
name|dir
argument_list|,
name|_h_nlist
index|[
name|i
operator|+
name|_h_found
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|_h_found
operator|&&
name|strcmp
argument_list|(
name|_h_nlist
index|[
name|j
index|]
argument_list|,
name|_h_nlist
index|[
name|i
operator|+
name|_h_found
index|]
argument_list|)
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|<
name|_h_found
condition|)
block|{
comment|/* is duplicate */
operator|--
name|result
expr_stmt|;
name|strcpy
argument_list|(
name|_h_list
index|[
name|i
operator|+
name|_h_found
index|]
argument_list|,
name|_h_list
index|[
name|result
operator|+
name|_h_found
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|++
expr_stmt|;
comment|/* isn't duplicate */
block|}
name|_h_found
operator|+=
name|result
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* keep searching */
block|}
end_function

begin_comment
comment|/*  for use in sorting help file names */
end_comment

begin_expr_stmt
specifier|static
name|ci_hcomp
argument_list|(
argument|p
argument_list|,
argument|q
argument_list|)
name|char
operator|*
operator|*
name|p
operator|,
operator|*
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|dir
index|[
literal|200
index|]
decl_stmt|,
name|file1
index|[
literal|20
index|]
decl_stmt|,
name|file2
index|[
literal|20
index|]
decl_stmt|;
name|path
argument_list|(
operator|(
operator|*
name|p
operator|)
argument_list|,
name|dir
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|path
argument_list|(
operator|(
operator|*
name|q
operator|)
argument_list|,
name|dir
argument_list|,
name|file2
argument_list|)
expr_stmt|;
return|return
operator|(
name|strcmp
argument_list|(
name|file1
argument_list|,
name|file2
argument_list|)
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|ci_help
argument_list|(
argument|topic
argument_list|,
argument|helppath
argument_list|)
name|char
operator|*
name|topic
operator|,
operator|*
name|helppath
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|fnames
index|[
name|MAXHELPS
index|]
decl_stmt|;
comment|/* names of matching files */
name|char
name|names
index|[
name|MAXHELPS
index|]
index|[
literal|20
index|]
decl_stmt|;
comment|/* stripped filenames */
name|char
modifier|*
name|nptr
index|[
name|MAXHELPS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* list of ptrs for stablk */
name|char
name|dir
index|[
literal|200
index|]
decl_stmt|;
comment|/* temp */
name|char
name|shstr
index|[
literal|300
index|]
decl_stmt|;
comment|/* shell string for system */
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|star
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|*
name|topic
operator|==
literal|0
condition|)
block|{
comment|/* wants meta-help */
name|f
operator|=
name|fopen
argument_list|(
name|METAHELP
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Yikes!!  Can't open standard help file!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|runp
argument_list|(
literal|"more"
argument_list|,
literal|"more"
argument_list|,
name|METAHELP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_del_
condition|)
block|{
name|_DELNOTE_
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|helppath
operator|&&
operator|(
operator|*
name|helppath
operator|)
operator|&&
operator|(
operator|!
name|getbool
argument_list|(
literal|"Do you want a list of help topics?"
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
block|}
else|else
block|{
comment|/* chop at * */
name|star
operator|=
name|index
argument_list|(
name|topic
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
name|star
condition|)
operator|*
name|star
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|helppath
operator|==
literal|0
condition|)
block|{
comment|/* no help at all */
name|printf
argument_list|(
literal|"Sorry, no specific help is available for this program.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_h_found
operator|=
literal|0
expr_stmt|;
name|_h_list
operator|=
name|fnames
expr_stmt|;
name|_h_nlist
operator|=
name|names
expr_stmt|;
name|searchp
argument_list|(
name|helppath
argument_list|,
literal|"*"
argument_list|,
name|dir
argument_list|,
name|_ci_help
argument_list|)
expr_stmt|;
comment|/* find file names */
name|qsort
argument_list|(
name|fnames
argument_list|,
name|_h_found
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|ci_hcomp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_h_found
condition|;
name|i
operator|++
control|)
block|{
comment|/* strip pathnames */
name|path
argument_list|(
name|fnames
index|[
name|i
index|]
argument_list|,
name|dir
argument_list|,
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nptr
index|[
name|i
index|]
operator|=
name|names
index|[
name|i
index|]
expr_stmt|;
block|}
name|nptr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|topic
condition|)
block|{
comment|/* request some topic */
if|if
condition|(
name|_h_found
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"No help for %s.  Type '?*' for list of help messages.\n"
argument_list|,
name|topic
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|stablk
argument_list|(
name|topic
argument_list|,
name|nptr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
name|stabsearch
argument_list|(
name|topic
argument_list|,
name|nptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|f
operator|=
name|fopen
argument_list|(
name|fnames
index|[
name|i
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Yikes!  Can't open help file %s\n"
argument_list|,
name|fnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|runp
argument_list|(
literal|"more"
argument_list|,
literal|"more"
argument_list|,
name|fnames
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|_del_
condition|)
block|{
name|_DELNOTE_
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* request topic list */
name|printf
argument_list|(
literal|"\nHelp is available for these topics:\n"
argument_list|)
expr_stmt|;
name|prstab
argument_list|(
name|nptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|_del_
condition|)
block|{
name|_DELNOTE_
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_h_found
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|fnames
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*********************************************************  ***    S H O W   V A L U E   O F   V A R I A B L E    ***  *********************************************************/
end_comment

begin_expr_stmt
specifier|static
name|ci_show
argument_list|(
argument|entry
argument_list|,
argument|arg
argument_list|,
argument|mode
argument_list|)
name|CIENTRY
name|entry
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* entry to display */
end_comment

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* arg for variable procedures */
end_comment

begin_decl_stmt
name|CIMODE
name|mode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mode (CIPEEK or CISHOW) */
end_comment

begin_block
block|{
if|if
condition|(
name|entry
operator|.
name|ci_etyp
operator|==
name|ci_tproc
condition|)
block|{
comment|/* procedure */
operator|(
operator|*
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|entry
operator|.
name|ci_eptr
operator|)
operator|)
operator|(
name|mode
operator|,
name|arg
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|.
name|ci_etyp
operator|==
name|ci_tclass
condition|)
block|{
comment|/* class variable */
operator|(
operator|*
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|entry
operator|.
name|ci_eptr
operator|)
operator|)
operator|(
name|mode
operator|,
name|arg
operator|,
name|entry
operator|.
name|ci_evar
operator|,
name|entry
operator|.
name|ci_enam
operator|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%-14s \t"
argument_list|,
name|entry
operator|.
name|ci_enam
argument_list|)
expr_stmt|;
name|_ci_sho
argument_list|(
name|entry
operator|.
name|ci_etyp
argument_list|,
name|entry
operator|.
name|ci_eptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|_ci_sho
argument_list|(
argument|etype
argument_list|,
argument|eptr
argument_list|)
name|ci_type
name|etype
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ci_union
modifier|*
name|eptr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|u
decl_stmt|;
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ci_tint
case|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|eptr
operator|->
name|ci_uint
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tshort
case|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|eptr
operator|->
name|ci_ushort
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tlong
case|:
name|printf
argument_list|(
literal|"%D"
argument_list|,
name|eptr
operator|->
name|ci_ulong
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_toct
case|:
if|if
condition|(
name|eptr
operator|->
name|ci_uoct
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%o"
argument_list|,
name|eptr
operator|->
name|ci_uoct
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_thex
case|:
if|if
condition|(
name|eptr
operator|->
name|ci_uhex
condition|)
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|eptr
operator|->
name|ci_uhex
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tdouble
case|:
name|printf
argument_list|(
literal|"%g"
argument_list|,
name|eptr
operator|->
name|ci_udouble
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tfloat
case|:
name|printf
argument_list|(
literal|"%g"
argument_list|,
name|eptr
operator|->
name|ci_ufloat
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tbool
case|:
if|if
condition|(
name|eptr
operator|->
name|ci_ubool
condition|)
name|printf
argument_list|(
literal|"yes"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tstring
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|eptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcint
case|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_ucint
operator|.
name|ci_ival
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcshort
case|:
name|printf
argument_list|(
literal|"%d"
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_ucshort
operator|.
name|ci_sval
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tclong
case|:
name|printf
argument_list|(
literal|"%D"
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_uclong
operator|.
name|ci_lval
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcoct
case|:
name|u
operator|=
operator|*
operator|(
name|eptr
operator|->
name|ci_ucoct
operator|.
name|ci_uval
operator|)
expr_stmt|;
if|if
condition|(
name|u
condition|)
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%o"
argument_list|,
name|u
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tchex
case|:
name|u
operator|=
operator|*
operator|(
name|eptr
operator|->
name|ci_uchex
operator|.
name|ci_uval
operator|)
expr_stmt|;
if|if
condition|(
name|u
condition|)
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|u
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcdouble
case|:
name|printf
argument_list|(
literal|"%g"
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_ucdouble
operator|.
name|ci_dval
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcfloat
case|:
name|printf
argument_list|(
literal|"%g"
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_ucfloat
operator|.
name|ci_fval
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcbool
case|:
name|i
operator|=
operator|*
operator|(
name|eptr
operator|->
name|ci_ucbool
operator|.
name|ci_bval
operator|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|"yes"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"no"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcchr
case|:
name|i
operator|=
operator|*
operator|(
name|eptr
operator|->
name|ci_ucchr
operator|.
name|ci_cval
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|eptr
operator|->
name|ci_ucchr
operator|.
name|ci_cleg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcstring
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|eptr
operator|->
name|ci_ucstring
operator|.
name|ci_pval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tctab
case|:
name|i
operator|=
operator|*
operator|(
name|eptr
operator|->
name|ci_ucstab
operator|.
name|ci_tval
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|eptr
operator|->
name|ci_ucstab
operator|.
name|ci_ttab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcsearch
case|:
name|i
operator|=
operator|*
operator|(
name|eptr
operator|->
name|ci_ucsearch
operator|.
name|ci_tval
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|eptr
operator|->
name|ci_ucsearch
operator|.
name|ci_ttab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Yeek!  Illegal cientry type %d!\n"
argument_list|,
operator|(
name|int
operator|)
name|etype
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*************************************************************  ***    A S S I G N   V A L U E   T O   V A R I A B L E    ***  *************************************************************/
end_comment

begin_expr_stmt
specifier|static
name|ci_set
argument_list|(
argument|entry
argument_list|,
argument|arg
argument_list|)
name|CIENTRY
name|entry
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|entry
operator|.
name|ci_etyp
operator|==
name|ci_tproc
condition|)
block|{
comment|/* variable procedure */
operator|(
operator|*
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|entry
operator|.
name|ci_eptr
operator|)
operator|)
operator|(
name|CISET
operator|,
name|arg
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|.
name|ci_etyp
operator|==
name|ci_tclass
condition|)
block|{
comment|/* class variable */
operator|(
operator|*
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
name|entry
operator|.
name|ci_eptr
operator|)
operator|)
operator|(
name|CISET
operator|,
name|arg
operator|,
name|entry
operator|.
name|ci_evar
operator|,
name|entry
operator|.
name|ci_enam
operator|)
expr_stmt|;
block|}
else|else
block|{
name|_ci_set
argument_list|(
name|entry
operator|.
name|ci_etyp
argument_list|,
name|entry
operator|.
name|ci_eptr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ciquiet
operator|&
operator|(
operator|(
operator|(
name|ciinput
operator|==
name|stdin
operator|)
operator|||
operator|(
name|ciinput
operator|==
name|stderr
operator|)
operator|)
condition|?
name|CISETPEEK
else|:
name|CICMDFPEEK
operator|)
operator|)
condition|)
name|ci_show
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|,
name|CIPEEK
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|_ci_set
argument_list|(
argument|etype
argument_list|,
argument|eptr
argument_list|,
argument|arg
argument_list|)
name|ci_type
name|etype
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ci_union
modifier|*
name|eptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|u
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|etype
operator|==
name|ci_tstring
condition|)
block|{
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|eptr
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|etype
operator|==
name|ci_tcstring
condition|)
block|{
name|strarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|";"
argument_list|,
name|eptr
operator|->
name|ci_ucstring
operator|.
name|ci_pmsg
argument_list|,
name|eptr
operator|->
name|ci_ucstring
operator|.
name|ci_pval
argument_list|,
name|eptr
operator|->
name|ci_ucstring
operator|.
name|ci_pval
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|arg
expr_stmt|;
comment|/* parse first word */
name|arg
operator|=
name|nxtarg
argument_list|(
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ci_tint
case|:
name|eptr
operator|->
name|ci_uint
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tshort
case|:
name|eptr
operator|->
name|ci_ushort
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tlong
case|:
name|eptr
operator|->
name|ci_ulong
operator|=
name|atol
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_toct
case|:
name|eptr
operator|->
name|ci_uoct
operator|=
name|atoo
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_thex
case|:
if|if
condition|(
name|stlmatch
argument_list|(
name|arg
argument_list|,
literal|"0x"
argument_list|)
operator|||
name|stlmatch
argument_list|(
name|arg
argument_list|,
literal|"0X"
argument_list|)
condition|)
name|arg
operator|+=
literal|2
expr_stmt|;
name|eptr
operator|->
name|ci_uhex
operator|=
name|atoh
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tdouble
case|:
name|eptr
operator|->
name|ci_udouble
operator|=
name|atof
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tfloat
case|:
name|eptr
operator|->
name|ci_ufloat
operator|=
name|atof
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tbool
case|:
name|eptr
operator|->
name|ci_ubool
operator|=
operator|(
name|index
argument_list|(
literal|"yYtT"
argument_list|,
operator|*
name|arg
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
break|break;
case|case
name|ci_tcint
case|:
operator|*
operator|(
name|eptr
operator|->
name|ci_ucint
operator|.
name|ci_ival
operator|)
operator|=
name|intarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|eptr
operator|->
name|ci_ucint
operator|.
name|ci_imsg
argument_list|,
name|eptr
operator|->
name|ci_ucint
operator|.
name|ci_imin
argument_list|,
name|eptr
operator|->
name|ci_ucint
operator|.
name|ci_imax
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_ucint
operator|.
name|ci_ival
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcshort
case|:
operator|*
operator|(
name|eptr
operator|->
name|ci_ucshort
operator|.
name|ci_sval
operator|)
operator|=
name|shortarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|eptr
operator|->
name|ci_ucshort
operator|.
name|ci_smsg
argument_list|,
name|eptr
operator|->
name|ci_ucshort
operator|.
name|ci_smin
argument_list|,
name|eptr
operator|->
name|ci_ucshort
operator|.
name|ci_smax
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_ucshort
operator|.
name|ci_sval
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tclong
case|:
operator|*
operator|(
name|eptr
operator|->
name|ci_uclong
operator|.
name|ci_lval
operator|)
operator|=
name|longarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|eptr
operator|->
name|ci_uclong
operator|.
name|ci_lmsg
argument_list|,
name|eptr
operator|->
name|ci_uclong
operator|.
name|ci_lmin
argument_list|,
name|eptr
operator|->
name|ci_uclong
operator|.
name|ci_lmax
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_uclong
operator|.
name|ci_lval
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcoct
case|:
operator|*
operator|(
name|eptr
operator|->
name|ci_ucoct
operator|.
name|ci_uval
operator|)
operator|=
name|octarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|eptr
operator|->
name|ci_ucoct
operator|.
name|ci_umsg
argument_list|,
name|eptr
operator|->
name|ci_ucoct
operator|.
name|ci_umin
argument_list|,
name|eptr
operator|->
name|ci_ucoct
operator|.
name|ci_umax
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_ucoct
operator|.
name|ci_uval
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tchex
case|:
operator|*
operator|(
name|eptr
operator|->
name|ci_uchex
operator|.
name|ci_uval
operator|)
operator|=
name|hexarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|eptr
operator|->
name|ci_uchex
operator|.
name|ci_umsg
argument_list|,
name|eptr
operator|->
name|ci_uchex
operator|.
name|ci_umin
argument_list|,
name|eptr
operator|->
name|ci_uchex
operator|.
name|ci_umax
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_uchex
operator|.
name|ci_uval
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcdouble
case|:
operator|*
operator|(
name|eptr
operator|->
name|ci_ucdouble
operator|.
name|ci_dval
operator|)
operator|=
name|doublearg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|eptr
operator|->
name|ci_ucdouble
operator|.
name|ci_dmsg
argument_list|,
name|eptr
operator|->
name|ci_ucdouble
operator|.
name|ci_dmin
argument_list|,
name|eptr
operator|->
name|ci_ucdouble
operator|.
name|ci_dmax
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_ucdouble
operator|.
name|ci_dval
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcfloat
case|:
operator|*
operator|(
name|eptr
operator|->
name|ci_ucfloat
operator|.
name|ci_fval
operator|)
operator|=
name|floatarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|eptr
operator|->
name|ci_ucfloat
operator|.
name|ci_fmsg
argument_list|,
name|eptr
operator|->
name|ci_ucfloat
operator|.
name|ci_fmin
argument_list|,
name|eptr
operator|->
name|ci_ucfloat
operator|.
name|ci_fmax
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_ucfloat
operator|.
name|ci_fval
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcbool
case|:
operator|*
operator|(
name|eptr
operator|->
name|ci_ucbool
operator|.
name|ci_bval
operator|)
operator|=
name|boolarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|eptr
operator|->
name|ci_ucbool
operator|.
name|ci_bmsg
argument_list|,
operator|*
operator|(
name|eptr
operator|->
name|ci_ucbool
operator|.
name|ci_bval
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcchr
case|:
operator|*
operator|(
name|eptr
operator|->
name|ci_ucchr
operator|.
name|ci_cval
operator|)
operator|=
name|chrarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|eptr
operator|->
name|ci_ucchr
operator|.
name|ci_cmsg
argument_list|,
name|eptr
operator|->
name|ci_ucchr
operator|.
name|ci_cleg
argument_list|,
name|eptr
operator|->
name|ci_ucchr
operator|.
name|ci_cleg
index|[
operator|*
operator|(
name|eptr
operator|->
name|ci_ucchr
operator|.
name|ci_cval
operator|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tctab
case|:
operator|*
operator|(
name|eptr
operator|->
name|ci_ucstab
operator|.
name|ci_tval
operator|)
operator|=
name|stabarg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|eptr
operator|->
name|ci_ucstab
operator|.
name|ci_tmsg
argument_list|,
name|eptr
operator|->
name|ci_ucstab
operator|.
name|ci_ttab
argument_list|,
name|eptr
operator|->
name|ci_ucstab
operator|.
name|ci_ttab
index|[
operator|*
operator|(
name|eptr
operator|->
name|ci_ucstab
operator|.
name|ci_tval
operator|)
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|ci_tcsearch
case|:
operator|*
operator|(
name|eptr
operator|->
name|ci_ucsearch
operator|.
name|ci_tval
operator|)
operator|=
name|searcharg
argument_list|(
operator|&
name|arg
argument_list|,
literal|0
argument_list|,
name|eptr
operator|->
name|ci_ucsearch
operator|.
name|ci_tmsg
argument_list|,
name|eptr
operator|->
name|ci_ucsearch
operator|.
name|ci_ttab
argument_list|,
name|eptr
operator|->
name|ci_ucsearch
operator|.
name|ci_ttab
index|[
operator|*
operator|(
name|eptr
operator|->
name|ci_ucsearch
operator|.
name|ci_tval
operator|)
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_block

end_unit

