begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This file contains changes from the Open Software Foundation.  */
end_comment

begin_comment
comment|/*  * Copyright 1988, 1989 by the Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of M.I.T. and the M.I.T. S.I.P.B. not be  * used in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission. M.I.T. and the M.I.T.  * S.I.P.B. make no representations about the suitability of this software  * for any purpose.  It is provided "as is" without express or implied  * warranty.  *  */
end_comment

begin_comment
comment|/*  * newsyslog - roll over selected logs at the appropriate time, keeping the a  * specified number of backup files around.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_define
define|#
directive|define
name|OSF
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|COMPRESS_POSTFIX
end_ifndef

begin_define
define|#
directive|define
name|COMPRESS_POSTFIX
value|".gz"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|kbytes
parameter_list|(
name|size
parameter_list|)
value|(((size) + 1023)>> 10)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_IBMR2
end_ifdef

begin_comment
comment|/* Calculates (db * DEV_BSIZE) */
end_comment

begin_define
define|#
directive|define
name|dbtob
parameter_list|(
name|db
parameter_list|)
value|((unsigned)(db)<< UBSHIFT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CE_COMPACT
value|1
end_define

begin_comment
comment|/* Compact the achived log files */
end_comment

begin_define
define|#
directive|define
name|CE_BINARY
value|2
end_define

begin_comment
comment|/* Logfile is in binary, don't add */
end_comment

begin_comment
comment|/*  status messages */
end_comment

begin_define
define|#
directive|define
name|CE_TRIMAT
value|4
end_define

begin_comment
comment|/* trim at a specific time */
end_comment

begin_define
define|#
directive|define
name|NONE
value|-1
end_define

begin_struct
struct|struct
name|conf_entry
block|{
name|char
modifier|*
name|log
decl_stmt|;
comment|/* Name of the log */
name|char
modifier|*
name|pid_file
decl_stmt|;
comment|/* PID file */
name|int
name|uid
decl_stmt|;
comment|/* Owner of log */
name|int
name|gid
decl_stmt|;
comment|/* Group of log */
name|int
name|numlogs
decl_stmt|;
comment|/* Number of logs to keep */
name|int
name|size
decl_stmt|;
comment|/* Size cutoff to trigger trimming the log */
name|int
name|hours
decl_stmt|;
comment|/* Hours between log trimming */
name|time_t
name|trim_at
decl_stmt|;
comment|/* Specific time to do trimming */
name|int
name|permissions
decl_stmt|;
comment|/* File permissions on the log */
name|int
name|flags
decl_stmt|;
comment|/* Flags (CE_COMPACT& CE_BINARY)  */
name|int
name|sig
decl_stmt|;
comment|/* Signal to send */
name|struct
name|conf_entry
modifier|*
name|next
decl_stmt|;
comment|/* Linked list pointer */
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|archtodir
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Archive old logfiles to other directory */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print out what's going on */
end_comment

begin_decl_stmt
name|int
name|needroot
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Root privs are necessary */
end_comment

begin_decl_stmt
name|int
name|noaction
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't do anything, just show it */
end_comment

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force the trim no matter what */
end_comment

begin_decl_stmt
name|char
modifier|*
name|archdirname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory path to old logfiles archive */
end_comment

begin_decl_stmt
name|char
modifier|*
name|conf
init|=
name|_PATH_CONF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Configuration file to use */
end_comment

begin_decl_stmt
name|time_t
name|timenow
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIN_PID
value|5
end_define

begin_define
define|#
directive|define
name|MAX_PID
value|99999
end_define

begin_comment
comment|/* was lower, see /usr/include/sys/proc.h */
end_comment

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hostname */
end_comment

begin_decl_stmt
name|char
modifier|*
name|daytime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timenow in human readable form */
end_comment

begin_function_decl
specifier|static
name|struct
name|conf_entry
modifier|*
name|parse_file
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|sob
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|son
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|missing_field
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errline
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_entry
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|PRS
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dotrim
parameter_list|(
name|char
modifier|*
name|log
parameter_list|,
name|char
modifier|*
name|pid_file
parameter_list|,
name|int
name|numdays
parameter_list|,
name|int
name|falgs
parameter_list|,
name|int
name|perm
parameter_list|,
name|int
name|owner_uid
parameter_list|,
name|int
name|group_gid
parameter_list|,
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|log_trim
parameter_list|(
name|char
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compress_log
parameter_list|(
name|char
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sizefile
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|age_old_log
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pid_t
name|get_pid
parameter_list|(
name|char
modifier|*
name|pid_file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|parse8601
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|movefile
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|perm
parameter_list|,
name|int
name|owner_uid
parameter_list|,
name|int
name|group_gid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|createdir
parameter_list|(
name|char
modifier|*
name|dirpart
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|parseDWM
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|conf_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|PRS
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|needroot
operator|&&
name|getuid
argument_list|()
operator|&&
name|geteuid
argument_list|()
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"must have root privs"
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|=
name|parse_file
argument_list|(
name|argv
operator|+
name|optind
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|do_entry
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_entry
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|modtime
decl_stmt|;
name|char
modifier|*
name|pid_file
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_COMPACT
condition|)
name|printf
argument_list|(
literal|"%s<%dZ>: "
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s<%d>: "
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|sizefile
argument_list|(
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
name|modtime
operator|=
name|age_old_log
argument_list|(
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"does not exist.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_TRIMAT
condition|)
block|{
if|if
condition|(
name|timenow
operator|<
name|ent
operator|->
name|trim_at
operator|||
name|difftime
argument_list|(
name|timenow
argument_list|,
name|ent
operator|->
name|trim_at
argument_list|)
operator|>=
literal|60
operator|*
literal|60
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"--> will trim at %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|ent
operator|->
name|trim_at
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|verbose
operator|&&
name|ent
operator|->
name|hours
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"--> time is up\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
operator|&&
operator|(
name|ent
operator|->
name|size
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"size (Kb): %d [%d] "
argument_list|,
name|size
argument_list|,
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
operator|(
name|ent
operator|->
name|hours
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|" age (hr): %d [%d] "
argument_list|,
name|modtime
argument_list|,
name|ent
operator|->
name|hours
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|||
operator|(
operator|(
name|ent
operator|->
name|size
operator|>
literal|0
operator|)
operator|&&
operator|(
name|size
operator|>=
name|ent
operator|->
name|size
operator|)
operator|)
operator|||
operator|(
name|ent
operator|->
name|hours
operator|<=
literal|0
operator|&&
operator|(
name|ent
operator|->
name|flags
operator|&
name|CE_TRIMAT
operator|)
operator|)
operator|||
operator|(
operator|(
name|ent
operator|->
name|hours
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|modtime
operator|>=
name|ent
operator|->
name|hours
operator|)
operator|||
operator|(
name|modtime
operator|<
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"--> trimming log....\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noaction
operator|&&
operator|!
name|verbose
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_COMPACT
condition|)
name|printf
argument_list|(
literal|"%s<%dZ>: trimming\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s<%d>: trimming\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|pid_file
condition|)
block|{
name|pid_file
operator|=
name|ent
operator|->
name|pid_file
expr_stmt|;
block|}
else|else
block|{
comment|/* Only try to notify syslog if we are root */
if|if
condition|(
name|needroot
condition|)
name|pid_file
operator|=
name|_PATH_SYSLOGPID
expr_stmt|;
else|else
name|pid_file
operator|=
name|NULL
expr_stmt|;
block|}
name|dotrim
argument_list|(
name|ent
operator|->
name|log
argument_list|,
name|pid_file
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|,
name|ent
operator|->
name|flags
argument_list|,
name|ent
operator|->
name|permissions
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|,
name|ent
operator|->
name|sig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"--> skipping\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|PRS
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|timenow
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|daytime
operator|=
name|ctime
argument_list|(
operator|&
name|timenow
argument_list|)
operator|+
literal|4
expr_stmt|;
name|daytime
index|[
literal|15
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Let's get our hostname */
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Truncate domain */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"nrvFf:a:t:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|noaction
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|archtodir
operator|++
expr_stmt|;
name|archdirname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|needroot
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|conf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|force
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: newsyslog [-Fnrv] [-f config-file] [-a directory]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse a configuration file and return a linked list of all the logs to  * process  */
end_comment

begin_function
specifier|static
name|struct
name|conf_entry
modifier|*
name|parse_file
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|parse
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|errline
decl_stmt|,
modifier|*
name|group
decl_stmt|;
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|first
init|=
name|NULL
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|working
init|=
name|NULL
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pass
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|int
name|eol
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|conf
argument_list|,
literal|"-"
argument_list|)
condition|)
name|f
operator|=
name|fopen
argument_list|(
name|conf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
name|f
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|conf
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
condition|)
continue|continue;
name|errline
operator|=
name|strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
name|line
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|files
condition|)
block|{
for|for
control|(
name|p
operator|=
name|files
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|p
argument_list|,
name|q
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
continue|continue;
block|}
if|if
condition|(
operator|!
name|first
condition|)
block|{
if|if
condition|(
operator|(
name|working
operator|=
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|conf_entry
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|first
operator|=
name|working
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|working
operator|->
name|next
operator|=
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|conf_entry
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|working
operator|=
name|working
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|working
operator|->
name|log
operator|=
name|strdup
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|group
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|group
operator|=
name|strrchr
argument_list|(
name|q
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|group
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isnumber
argument_list|(
operator|*
name|q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pass
operator|=
name|getpwnam
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; unknown user:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|uid
operator|=
name|pass
operator|->
name|pw_uid
expr_stmt|;
block|}
else|else
name|working
operator|->
name|uid
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|working
operator|->
name|uid
operator|=
name|NONE
expr_stmt|;
name|q
operator|=
name|group
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isnumber
argument_list|(
operator|*
name|q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; unknown group:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
else|else
name|working
operator|->
name|gid
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|working
operator|->
name|gid
operator|=
name|NONE
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|working
operator|->
name|uid
operator|=
name|working
operator|->
name|gid
operator|=
name|NONE
expr_stmt|;
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|working
operator|->
name|permissions
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; bad permissions:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|working
operator|->
name|numlogs
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; bad number:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|working
operator|->
name|size
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
name|working
operator|->
name|size
operator|=
operator|-
literal|1
expr_stmt|;
name|working
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|eol
operator|=
operator|!
operator|*
name|parse
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|q
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|q
condition|)
name|working
operator|->
name|hours
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ep
operator|==
literal|'*'
condition|)
name|working
operator|->
name|hours
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ul
operator|>
name|INT_MAX
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"interval is too large:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
else|else
name|working
operator|->
name|hours
operator|=
name|ul
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
operator|&&
operator|*
name|ep
operator|!=
literal|'@'
operator|&&
operator|*
name|ep
operator|!=
literal|'*'
operator|&&
operator|*
name|ep
operator|!=
literal|'$'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed interval/at:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'@'
condition|)
block|{
if|if
condition|(
operator|(
name|working
operator|->
name|trim_at
operator|=
name|parse8601
argument_list|(
name|ep
operator|+
literal|1
argument_list|)
operator|)
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed at:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|flags
operator||=
name|CE_TRIMAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ep
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
operator|(
name|working
operator|->
name|trim_at
operator|=
name|parseDWM
argument_list|(
name|ep
operator|+
literal|1
argument_list|)
operator|)
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed at:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|flags
operator||=
name|CE_TRIMAT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
expr_stmt|;
comment|/* Optional field */
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
while|while
condition|(
name|q
operator|&&
operator|*
name|q
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|q
operator|==
literal|'Z'
operator|)
operator|||
operator|(
operator|*
name|q
operator|==
literal|'z'
operator|)
condition|)
name|working
operator|->
name|flags
operator||=
name|CE_COMPACT
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|q
operator|==
literal|'B'
operator|)
operator|||
operator|(
operator|*
name|q
operator|==
literal|'b'
operator|)
condition|)
name|working
operator|->
name|flags
operator||=
name|CE_BINARY
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|!=
literal|'-'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal flag in config file -- %c"
argument_list|,
operator|*
name|q
argument_list|)
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
expr_stmt|;
comment|/* Optional field */
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
name|working
operator|->
name|pid_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|q
operator|&&
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'/'
condition|)
name|working
operator|->
name|pid_file
operator|=
name|strdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|q
argument_list|)
condition|)
goto|goto
name|got_sig
goto|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal pid file or signal number in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
expr_stmt|;
comment|/* Optional field */
operator|*
operator|(
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
name|working
operator|->
name|sig
operator|=
name|SIGHUP
expr_stmt|;
if|if
condition|(
name|q
operator|&&
operator|*
name|q
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
name|got_sig
label|:
name|working
operator|->
name|sig
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err_sig
label|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal signal number in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|working
operator|->
name|sig
operator|<
literal|1
operator|||
name|working
operator|->
name|sig
operator|>=
name|NSIG
condition|)
goto|goto
name|err_sig
goto|;
block|}
name|free
argument_list|(
name|errline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|working
condition|)
name|working
operator|->
name|next
operator|=
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|missing_field
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errline
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
operator|*
name|p
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"missing field in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dotrim
parameter_list|(
name|char
modifier|*
name|log
parameter_list|,
name|char
modifier|*
name|pid_file
parameter_list|,
name|int
name|numdays
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|perm
parameter_list|,
name|int
name|owner_uid
parameter_list|,
name|int
name|group_gid
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|char
name|dirpart
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|namepart
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|file1
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|file2
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|zfile1
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|zfile2
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|notified
decl_stmt|,
name|need_notification
decl_stmt|,
name|fd
decl_stmt|,
name|_numdays
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
ifdef|#
directive|ifdef
name|_IBMR2
comment|/* 	 * AIX 3.1 has a broken fchown- if the owner_uid is -1, it will 	 * actually change it to be owned by uid -1, instead of leaving it 	 * as is, as it is supposed to. 	 */
if|if
condition|(
name|owner_uid
operator|==
operator|-
literal|1
condition|)
name|owner_uid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|archtodir
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* build complete name of archive directory into dirpart */
if|if
condition|(
operator|*
name|archdirname
operator|==
literal|'/'
condition|)
block|{
comment|/* absolute */
name|strlcpy
argument_list|(
name|dirpart
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|dirpart
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* relative */
comment|/* get directory part of logfile */
name|strlcpy
argument_list|(
name|dirpart
argument_list|,
name|log
argument_list|,
sizeof|sizeof
argument_list|(
name|dirpart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|dirpart
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dirpart
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|strlcat
argument_list|(
name|dirpart
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|dirpart
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* check if archive directory exists, if not, create it */
if|if
condition|(
name|lstat
argument_list|(
name|dirpart
argument_list|,
operator|&
name|st
argument_list|)
condition|)
name|createdir
argument_list|(
name|dirpart
argument_list|)
expr_stmt|;
comment|/* get filename part of logfile */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|log
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|strlcpy
argument_list|(
name|namepart
argument_list|,
name|log
argument_list|,
sizeof|sizeof
argument_list|(
name|namepart
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|namepart
argument_list|,
name|p
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|namepart
argument_list|)
argument_list|)
expr_stmt|;
comment|/* name of oldest log */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s/%s.%d"
argument_list|,
name|dirpart
argument_list|,
name|namepart
argument_list|,
name|numdays
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zfile1
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile1
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|file1
argument_list|,
name|COMPRESS_POSTFIX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* name of oldest log */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s.%d"
argument_list|,
name|log
argument_list|,
name|numdays
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zfile1
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile1
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|file1
argument_list|,
name|COMPRESS_POSTFIX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"rm -f %s\n"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rm -f %s\n"
argument_list|,
name|zfile1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|file1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|zfile1
argument_list|)
expr_stmt|;
block|}
comment|/* Move down log files */
name|_numdays
operator|=
name|numdays
expr_stmt|;
comment|/* preserve */
while|while
condition|(
name|numdays
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|file2
argument_list|,
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archtodir
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s/%s.%d"
argument_list|,
name|dirpart
argument_list|,
name|namepart
argument_list|,
name|numdays
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s.%d"
argument_list|,
name|log
argument_list|,
name|numdays
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zfile1
argument_list|,
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zfile2
argument_list|,
name|file2
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|file1
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|zfile1
argument_list|,
name|COMPRESS_POSTFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|zfile2
argument_list|,
name|COMPRESS_POSTFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|zfile1
argument_list|,
operator|&
name|st
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"mv %s %s\n"
argument_list|,
name|zfile1
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chmod %o %s\n"
argument_list|,
name|perm
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chown %d.%d %s\n"
argument_list|,
name|owner_uid
argument_list|,
name|group_gid
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|rename
argument_list|(
name|zfile1
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|zfile2
argument_list|,
name|perm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|zfile2
argument_list|,
name|owner_uid
argument_list|,
name|group_gid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|noaction
operator|&&
operator|!
operator|(
name|flags
operator|&
name|CE_BINARY
operator|)
condition|)
operator|(
name|void
operator|)
name|log_trim
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* Report the trimming to the old log */
if|if
condition|(
operator|!
name|_numdays
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"rm %s\n"
argument_list|,
name|log
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"mv %s to %s\n"
argument_list|,
name|log
argument_list|,
name|file1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|archtodir
condition|)
name|movefile
argument_list|(
name|log
argument_list|,
name|file1
argument_list|,
name|perm
argument_list|,
name|owner_uid
argument_list|,
name|group_gid
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|rename
argument_list|(
name|log
argument_list|,
name|file1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"Start new log..."
argument_list|)
expr_stmt|;
else|else
block|{
name|fd
operator|=
name|creat
argument_list|(
name|log
argument_list|,
name|perm
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't start new log"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fchown
argument_list|(
name|fd
argument_list|,
name|owner_uid
argument_list|,
name|group_gid
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't chmod new log file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CE_BINARY
operator|)
condition|)
if|if
condition|(
name|log_trim
argument_list|(
name|log
argument_list|)
condition|)
comment|/* Add status message */
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't add status message to log"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"chmod %o %s...\n"
argument_list|,
name|perm
argument_list|,
name|log
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|log
argument_list|,
name|perm
argument_list|)
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
name|need_notification
operator|=
name|notified
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pid_file
operator|!=
name|NULL
condition|)
block|{
name|need_notification
operator|=
literal|1
expr_stmt|;
name|pid
operator|=
name|get_pid
argument_list|(
name|pid_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
block|{
name|notified
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"kill -%d %d\n"
argument_list|,
name|sig
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kill
argument_list|(
name|pid
argument_list|,
name|sig
argument_list|)
condition|)
name|warn
argument_list|(
literal|"can't notify daemon, pid %d"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
else|else
block|{
name|notified
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"daemon pid %d notified\n"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|CE_COMPACT
operator|)
condition|)
block|{
if|if
condition|(
name|need_notification
operator|&&
operator|!
name|notified
condition|)
name|warnx
argument_list|(
literal|"log %s not compressed because daemon not notified"
argument_list|,
name|log
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"Compress %s.0\n"
argument_list|,
name|log
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|notified
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"small pause to allow daemon to close log\n"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archtodir
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|dirpart
argument_list|,
name|namepart
argument_list|)
expr_stmt|;
name|compress_log
argument_list|(
name|file1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compress_log
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Log the fact that the logs were turned over */
end_comment

begin_function
specifier|static
name|int
name|log_trim
parameter_list|(
name|char
modifier|*
name|log
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|log
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s %s newsyslog[%d]: logfile turned over\n"
argument_list|,
name|daytime
argument_list|,
name|hostname
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"log_trim: fclose:"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fork of gzip to compress the old log file */
end_comment

begin_function
specifier|static
name|void
name|compress_log
parameter_list|(
name|char
modifier|*
name|log
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|char
name|tmp
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%s.0"
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pid
condition|)
block|{
operator|(
name|void
operator|)
name|execl
argument_list|(
name|_PATH_GZIP
argument_list|,
name|_PATH_GZIP
argument_list|,
literal|"-f"
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
name|_PATH_GZIP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return size in kilobytes of a file */
end_comment

begin_function
specifier|static
name|int
name|sizefile
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|kbytes
argument_list|(
name|dbtob
argument_list|(
name|sb
operator|.
name|st_blocks
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the age of old log file (file.0) */
end_comment

begin_function
specifier|static
name|int
name|age_old_log
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
name|tmp
index|[
name|MAXPATHLEN
operator|+
sizeof|sizeof
argument_list|(
literal|".0"
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|COMPRESS_POSTFIX
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|archtodir
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* build name of archive directory into tmp */
if|if
condition|(
operator|*
name|archdirname
operator|==
literal|'/'
condition|)
block|{
comment|/* absolute */
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* relative */
comment|/* get directory part of logfile */
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|tmp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tmp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|tmp
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get filename part of logfile */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|p
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|".0"
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|stat
argument_list|(
name|strcat
argument_list|(
name|tmp
argument_list|,
name|COMPRESS_POSTFIX
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|timenow
operator|-
name|sb
operator|.
name|st_mtime
operator|+
literal|1800
argument_list|)
operator|/
literal|3600
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|pid_t
name|get_pid
parameter_list|(
name|char
modifier|*
name|pid_file
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|pid_t
name|pid
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|pid_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"can't open %s pid file to restart a daemon"
argument_list|,
name|pid_file
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|pid
operator|=
name|atol
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
name|MIN_PID
operator|||
name|pid
operator|>
name|MAX_PID
condition|)
block|{
name|warnx
argument_list|(
literal|"preposterous process number: %d"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|warn
argument_list|(
literal|"can't read %s pid file to restart a daemon"
argument_list|,
name|pid_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Skip Over Blanks */
end_comment

begin_function
name|char
modifier|*
name|sob
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Skip Over Non-Blanks */
end_comment

begin_function
name|char
modifier|*
name|son
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a limited subset of ISO 8601. The specific format is as follows:  *  * [CC[YY[MM[DD]]]][THH[MM[SS]]]	(where `T' is the literal letter)  *  * We don't accept a timezone specification; missing fields (including timezone)  * are defaulted to the current date but time zero.  */
end_comment

begin_function
specifier|static
name|time_t
name|parse8601
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|tmp
operator|=
name|localtime
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|tm
operator|=
operator|*
name|tmp
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
name|tm
operator|.
name|tm_min
operator|=
name|tm
operator|.
name|tm_sec
operator|=
literal|0
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'\0'
operator|&&
operator|*
name|t
operator|!=
literal|'T'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * Now t points either to the end of the string (if no time was 	 * provided) or to the letter `T' which separates date and time in 	 * ISO 8601.  The pointer arithmetic is the same for either case. 	 */
switch|switch
condition|(
name|t
operator|-
name|s
condition|)
block|{
case|case
literal|8
case|:
name|tm
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|ul
operator|/
literal|1000000
operator|)
operator|-
literal|19
operator|)
operator|*
literal|100
expr_stmt|;
name|ul
operator|=
name|ul
operator|%
literal|1000000
expr_stmt|;
case|case
literal|6
case|:
name|tm
operator|.
name|tm_year
operator|=
name|tm
operator|.
name|tm_year
operator|-
operator|(
name|tm
operator|.
name|tm_year
operator|%
literal|100
operator|)
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|+=
name|ul
operator|/
literal|10000
expr_stmt|;
name|ul
operator|=
name|ul
operator|%
literal|10000
expr_stmt|;
case|case
literal|4
case|:
name|tm
operator|.
name|tm_mon
operator|=
operator|(
name|ul
operator|/
literal|100
operator|)
operator|-
literal|1
expr_stmt|;
name|ul
operator|=
name|ul
operator|%
literal|100
expr_stmt|;
case|case
literal|2
case|:
name|tm
operator|.
name|tm_mday
operator|=
name|ul
expr_stmt|;
case|case
literal|0
case|:
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
comment|/* sanity check */
if|if
condition|(
name|tm
operator|.
name|tm_year
operator|<
literal|70
operator|||
name|tm
operator|.
name|tm_mon
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_mon
operator|>
literal|12
operator|||
name|tm
operator|.
name|tm_mday
operator|<
literal|1
operator|||
name|tm
operator|.
name|tm_mday
operator|>
literal|31
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'\0'
condition|)
block|{
name|s
operator|=
operator|++
name|t
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|t
operator|-
name|s
condition|)
block|{
case|case
literal|6
case|:
name|tm
operator|.
name|tm_sec
operator|=
name|ul
operator|%
literal|100
expr_stmt|;
name|ul
operator|/=
literal|100
expr_stmt|;
case|case
literal|4
case|:
name|tm
operator|.
name|tm_min
operator|=
name|ul
operator|%
literal|100
expr_stmt|;
name|ul
operator|/=
literal|100
expr_stmt|;
case|case
literal|2
case|:
name|tm
operator|.
name|tm_hour
operator|=
name|ul
expr_stmt|;
case|case
literal|0
case|:
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
comment|/* sanity check */
if|if
condition|(
name|tm
operator|.
name|tm_sec
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_sec
operator|>
literal|60
operator|||
name|tm
operator|.
name|tm_min
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_min
operator|>
literal|59
operator|||
name|tm
operator|.
name|tm_hour
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_hour
operator|>
literal|23
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* physically move file */
end_comment

begin_function
specifier|static
name|void
name|movefile
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|perm
parameter_list|,
name|int
name|owner_uid
parameter_list|,
name|int
name|group_gid
parameter_list|)
block|{
name|FILE
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|src
operator|=
name|fopen
argument_list|(
name|from
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fopen %s for reading"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|fopen
argument_list|(
name|to
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fopen %s for writing"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|fchown
argument_list|(
name|fileno
argument_list|(
name|dst
argument_list|)
argument_list|,
name|owner_uid
argument_list|,
name|group_gid
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fchown %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|fchmod
argument_list|(
name|fileno
argument_list|(
name|dst
argument_list|)
argument_list|,
name|perm
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fchmod %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|putc
argument_list|(
name|c
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error writing to %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|src
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error reading from %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fclose
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fclose %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fclose
argument_list|(
name|dst
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fclose %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unlink
argument_list|(
name|from
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't unlink %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* create one or more directory components of a path */
end_comment

begin_function
specifier|static
name|void
name|createdir
parameter_list|(
name|char
modifier|*
name|dirpart
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|char
name|mkdirpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|s
operator|=
name|dirpart
expr_stmt|;
name|d
operator|=
name|mkdirpath
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'/'
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|mkdirpath
argument_list|,
operator|&
name|st
argument_list|)
condition|)
name|mkdir
argument_list|(
name|mkdirpath
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*-  * Parse a cyclic time specification, the format is as follows:  *  *	[Dhh] or [Wd[Dhh]] or [Mdd[Dhh]]  *  * to rotate a logfile cyclic at  *  *	- every day (D) within a specific hour (hh)	(hh = 0...23)  *	- once a week (W) at a specific day (d)     OR	(d = 0..6, 0 = Sunday)  *	- once a month (M) at a specific day (d)	(d = 1..31,l|L)  *  * We don't accept a timezone specification; missing fields  * are defaulted to the current date but time zero.  */
end_comment

begin_function
specifier|static
name|time_t
name|parseDWM
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|int
name|nd
decl_stmt|;
specifier|static
name|int
name|mtab
index|[]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
name|int
name|WMseen
init|=
literal|0
decl_stmt|;
name|int
name|Dseen
init|=
literal|0
decl_stmt|;
name|tmp
operator|=
name|localtime
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|tm
operator|=
operator|*
name|tmp
expr_stmt|;
comment|/* set no. of days per month */
name|nd
operator|=
name|mtab
index|[
name|tm
operator|.
name|tm_mon
index|]
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_mon
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|+
literal|1900
operator|)
operator|%
literal|4
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|+
literal|1900
operator|)
operator|%
literal|100
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|+
literal|1900
operator|)
operator|%
literal|400
operator|==
literal|0
operator|)
condition|)
block|{
name|nd
operator|++
expr_stmt|;
comment|/* leap year, 29 days in february */
block|}
block|}
name|tm
operator|.
name|tm_hour
operator|=
name|tm
operator|.
name|tm_min
operator|=
name|tm
operator|.
name|tm_sec
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'D'
case|:
if|if
condition|(
name|Dseen
condition|)
return|return
operator|-
literal|1
return|;
name|Dseen
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul
operator|<
literal|0
operator|||
name|ul
operator|>
literal|23
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|.
name|tm_hour
operator|=
name|ul
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|WMseen
condition|)
return|return
operator|-
literal|1
return|;
name|WMseen
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul
operator|<
literal|0
operator|||
name|ul
operator|>
literal|6
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ul
operator|!=
name|tm
operator|.
name|tm_wday
condition|)
block|{
name|int
name|save
decl_stmt|;
if|if
condition|(
name|ul
operator|<
name|tm
operator|.
name|tm_wday
condition|)
block|{
name|save
operator|=
literal|6
operator|-
name|tm
operator|.
name|tm_wday
expr_stmt|;
name|save
operator|+=
operator|(
name|ul
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|save
operator|=
name|ul
operator|-
name|tm
operator|.
name|tm_wday
expr_stmt|;
block|}
name|tm
operator|.
name|tm_mday
operator|+=
name|save
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_mday
operator|>
name|nd
condition|)
block|{
name|tm
operator|.
name|tm_mon
operator|++
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
name|tm
operator|.
name|tm_mday
operator|-
name|nd
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|WMseen
condition|)
return|return
operator|-
literal|1
return|;
name|WMseen
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
operator|==
literal|'l'
condition|)
block|{
name|tm
operator|.
name|tm_mday
operator|=
name|nd
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|ul
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul
operator|<
literal|1
operator|||
name|ul
operator|>
literal|31
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ul
operator|>
name|nd
condition|)
return|return
operator|-
literal|1
return|;
name|tm
operator|.
name|tm_mday
operator|=
name|ul
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
operator|||
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
break|break;
else|else
name|s
operator|=
name|t
expr_stmt|;
block|}
return|return
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
return|;
block|}
end_function

end_unit

