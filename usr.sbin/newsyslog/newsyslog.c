begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This file contains changes from the Open Software Foundation.  */
end_comment

begin_comment
comment|/*  Copyright 1988, 1989 by the Massachusetts Institute of Technology  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the names of M.I.T. and the M.I.T. S.I.P.B. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission. M.I.T. and the M.I.T. S.I.P.B. make no representations about the suitability of this software for any purpose.  It is provided "as is" without express or implied warranty.  */
end_comment

begin_comment
comment|/*  *      newsyslog - roll over selected logs at the appropriate time,  *              keeping the a specified number of backup files around.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: newsyslog.c,v 1.19 1998/05/10 21:13:29 hoek Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CONF
end_ifndef

begin_define
define|#
directive|define
name|CONF
value|"/etc/athena/newsyslog.conf"
end_define

begin_comment
comment|/* Configuration file */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PIDFILE
end_ifndef

begin_define
define|#
directive|define
name|PIDFILE
value|"/etc/syslog.pid"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COMPRESS_PATH
end_ifndef

begin_define
define|#
directive|define
name|COMPRESS_PATH
value|"/usr/ucb/compress"
end_define

begin_comment
comment|/* File compression program */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COMPRESS_PROG
end_ifndef

begin_define
define|#
directive|define
name|COMPRESS_PROG
value|"compress"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COMPRESS_POSTFIX
end_ifndef

begin_define
define|#
directive|define
name|COMPRESS_POSTFIX
value|".Z"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_define
define|#
directive|define
name|kbytes
parameter_list|(
name|size
parameter_list|)
value|(((size) + 1023)>> 10)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_IBMR2
end_ifdef

begin_comment
comment|/* Calculates (db * DEV_BSIZE) */
end_comment

begin_define
define|#
directive|define
name|dbtob
parameter_list|(
name|db
parameter_list|)
value|((unsigned)(db)<< UBSHIFT)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CE_COMPACT
value|1
end_define

begin_comment
comment|/* Compact the achived log files */
end_comment

begin_define
define|#
directive|define
name|CE_BINARY
value|2
end_define

begin_comment
comment|/* Logfile is in binary, don't add */
end_comment

begin_comment
comment|/* status messages */
end_comment

begin_define
define|#
directive|define
name|NONE
value|-1
end_define

begin_struct
struct|struct
name|conf_entry
block|{
name|char
modifier|*
name|log
decl_stmt|;
comment|/* Name of the log */
name|char
modifier|*
name|pid_file
decl_stmt|;
comment|/* PID file */
name|int
name|uid
decl_stmt|;
comment|/* Owner of log */
name|int
name|gid
decl_stmt|;
comment|/* Group of log */
name|int
name|numlogs
decl_stmt|;
comment|/* Number of logs to keep */
name|int
name|size
decl_stmt|;
comment|/* Size cutoff to trigger trimming the log */
name|int
name|hours
decl_stmt|;
comment|/* Hours between log trimming */
name|int
name|permissions
decl_stmt|;
comment|/* File permissions on the log */
name|int
name|flags
decl_stmt|;
comment|/* Flags (CE_COMPACT& CE_BINARY)  */
name|int
name|sig
decl_stmt|;
comment|/* Signal to send */
name|struct
name|conf_entry
modifier|*
name|next
decl_stmt|;
comment|/* Linked list pointer */
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print out what's going on */
end_comment

begin_decl_stmt
name|int
name|needroot
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Root privs are necessary */
end_comment

begin_decl_stmt
name|int
name|noaction
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't do anything, just show it */
end_comment

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force the trim no matter what*/
end_comment

begin_decl_stmt
name|char
modifier|*
name|conf
init|=
name|CONF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Configuration file to use */
end_comment

begin_decl_stmt
name|time_t
name|timenow
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MIN_PID
value|5
end_define

begin_define
define|#
directive|define
name|MAX_PID
value|30000
end_define

begin_comment
comment|/* was 65534, see /usr/include/sys/proc.h */
end_comment

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hostname */
end_comment

begin_decl_stmt
name|char
modifier|*
name|daytime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timenow in human readable form */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|OSF
end_ifndef

begin_function_decl
name|char
modifier|*
name|strdup
parameter_list|(
name|char
modifier|*
name|strp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|conf_entry
modifier|*
name|parse_file
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|sob
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|son
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|missing_field
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errline
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_entry
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|PRS
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dotrim
parameter_list|(
name|char
modifier|*
name|log
parameter_list|,
name|char
modifier|*
name|pid_file
parameter_list|,
name|int
name|numdays
parameter_list|,
name|int
name|falgs
parameter_list|,
name|int
name|perm
parameter_list|,
name|int
name|owner_uid
parameter_list|,
name|int
name|group_gid
parameter_list|,
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|log_trim
parameter_list|(
name|char
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compress_log
parameter_list|(
name|char
modifier|*
name|log
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sizefile
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|age_old_log
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pid_t
name|get_pid
parameter_list|(
name|char
modifier|*
name|pid_file
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|conf_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|PRS
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|needroot
operator|&&
name|getuid
argument_list|()
operator|&&
name|geteuid
argument_list|()
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"must have root privs"
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|=
name|parse_file
argument_list|()
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|do_entry
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_entry
parameter_list|(
name|ent
parameter_list|)
name|struct
name|conf_entry
modifier|*
name|ent
decl_stmt|;
block|{
name|int
name|size
decl_stmt|,
name|modtime
decl_stmt|;
name|char
modifier|*
name|pid_file
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_COMPACT
condition|)
name|printf
argument_list|(
literal|"%s<%dZ>: "
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s<%d>: "
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|sizefile
argument_list|(
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
name|modtime
operator|=
name|age_old_log
argument_list|(
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"does not exist.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
operator|&&
operator|(
name|ent
operator|->
name|size
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"size (Kb): %d [%d] "
argument_list|,
name|size
argument_list|,
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
operator|(
name|ent
operator|->
name|hours
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|" age (hr): %d [%d] "
argument_list|,
name|modtime
argument_list|,
name|ent
operator|->
name|hours
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|||
operator|(
operator|(
name|ent
operator|->
name|size
operator|>
literal|0
operator|)
operator|&&
operator|(
name|size
operator|>=
name|ent
operator|->
name|size
operator|)
operator|)
operator|||
operator|(
operator|(
name|ent
operator|->
name|hours
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|modtime
operator|>=
name|ent
operator|->
name|hours
operator|)
operator|||
operator|(
name|modtime
operator|<
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"--> trimming log....\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noaction
operator|&&
operator|!
name|verbose
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_COMPACT
condition|)
name|printf
argument_list|(
literal|"%s<%dZ>: trimming\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s<%d>: trimming\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|pid_file
condition|)
block|{
name|pid_file
operator|=
name|ent
operator|->
name|pid_file
expr_stmt|;
block|}
else|else
block|{
comment|/* Only try to notify syslog if we are root */
if|if
condition|(
name|needroot
condition|)
name|pid_file
operator|=
name|PIDFILE
expr_stmt|;
else|else
name|pid_file
operator|=
name|NULL
expr_stmt|;
block|}
name|dotrim
argument_list|(
name|ent
operator|->
name|log
argument_list|,
name|pid_file
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|,
name|ent
operator|->
name|flags
argument_list|,
name|ent
operator|->
name|permissions
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|,
name|ent
operator|->
name|sig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"--> skipping\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|PRS
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|timenow
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|daytime
operator|=
name|ctime
argument_list|(
operator|&
name|timenow
argument_list|)
operator|+
literal|4
expr_stmt|;
name|daytime
index|[
literal|15
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Let's get our hostname */
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Truncate domain */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
name|optind
operator|=
literal|1
expr_stmt|;
comment|/* Start options parsing */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"nrvFf:t:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|noaction
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|needroot
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|conf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|force
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: newsyslog [-Fnrv] [-f config-file]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a configuration file and return a linked list of all the logs  * to process  */
end_comment

begin_function
specifier|static
name|struct
name|conf_entry
modifier|*
name|parse_file
parameter_list|()
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|parse
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|errline
decl_stmt|,
modifier|*
name|group
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|first
init|=
name|NULL
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|working
init|=
name|NULL
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pass
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|int
name|eol
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|conf
argument_list|,
literal|"-"
argument_list|)
condition|)
name|f
operator|=
name|fopen
argument_list|(
name|conf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
name|f
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|conf
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|f
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
condition|)
continue|continue;
name|errline
operator|=
name|strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|working
operator|=
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|conf_entry
argument_list|)
argument_list|)
expr_stmt|;
name|first
operator|=
name|working
expr_stmt|;
block|}
else|else
block|{
name|working
operator|->
name|next
operator|=
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|conf_entry
argument_list|)
argument_list|)
expr_stmt|;
name|working
operator|=
name|working
operator|->
name|next
expr_stmt|;
block|}
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
name|line
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
name|working
operator|->
name|log
operator|=
name|strdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|group
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|group
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isnumber
argument_list|(
operator|*
name|q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pass
operator|=
name|getpwnam
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; unknown user:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|uid
operator|=
name|pass
operator|->
name|pw_uid
expr_stmt|;
block|}
else|else
name|working
operator|->
name|uid
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|working
operator|->
name|uid
operator|=
name|NONE
expr_stmt|;
name|q
operator|=
name|group
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isnumber
argument_list|(
operator|*
name|q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; unknown group:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
else|else
name|working
operator|->
name|gid
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|working
operator|->
name|gid
operator|=
name|NONE
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|working
operator|->
name|uid
operator|=
name|working
operator|->
name|gid
operator|=
name|NONE
expr_stmt|;
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|working
operator|->
name|permissions
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; bad permissions:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|working
operator|->
name|numlogs
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; bad number:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|working
operator|->
name|size
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
name|working
operator|->
name|size
operator|=
operator|-
literal|1
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|eol
operator|=
operator|!
operator|*
name|parse
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|working
operator|->
name|hours
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
name|working
operator|->
name|hours
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
expr_stmt|;
comment|/* Optional field */
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
name|working
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|q
operator|&&
operator|*
name|q
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|q
operator|==
literal|'Z'
operator|)
operator|||
operator|(
operator|*
name|q
operator|==
literal|'z'
operator|)
condition|)
name|working
operator|->
name|flags
operator||=
name|CE_COMPACT
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|q
operator|==
literal|'B'
operator|)
operator|||
operator|(
operator|*
name|q
operator|==
literal|'b'
operator|)
condition|)
name|working
operator|->
name|flags
operator||=
name|CE_BINARY
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|q
operator|!=
literal|'-'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal flag in config file -- %c"
argument_list|,
operator|*
name|q
argument_list|)
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
expr_stmt|;
comment|/* Optional field */
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
name|working
operator|->
name|pid_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|q
operator|&&
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'/'
condition|)
name|working
operator|->
name|pid_file
operator|=
name|strdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|q
argument_list|)
condition|)
goto|goto
name|got_sig
goto|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal pid file or signal number in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
expr_stmt|;
comment|/* Optional field */
operator|*
operator|(
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
name|working
operator|->
name|sig
operator|=
name|SIGHUP
expr_stmt|;
if|if
condition|(
name|q
operator|&&
operator|*
name|q
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
name|got_sig
label|:
name|working
operator|->
name|sig
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err_sig
label|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal signal number in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|working
operator|->
name|sig
operator|<
literal|1
operator|||
name|working
operator|->
name|sig
operator|>=
name|NSIG
condition|)
goto|goto
name|err_sig
goto|;
block|}
name|free
argument_list|(
name|errline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|working
condition|)
name|working
operator|->
name|next
operator|=
operator|(
expr|struct
name|conf_entry
operator|*
operator|)
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|missing_field
parameter_list|(
name|p
parameter_list|,
name|errline
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|,
decl|*
name|errline
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
operator|*
name|p
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"missing field in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|dotrim
parameter_list|(
name|log
parameter_list|,
name|pid_file
parameter_list|,
name|numdays
parameter_list|,
name|flags
parameter_list|,
name|perm
parameter_list|,
name|owner_uid
parameter_list|,
name|group_gid
parameter_list|,
name|sig
parameter_list|)
name|char
modifier|*
name|log
decl_stmt|;
name|char
modifier|*
name|pid_file
decl_stmt|;
name|int
name|numdays
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|perm
decl_stmt|;
name|int
name|owner_uid
decl_stmt|;
name|int
name|group_gid
decl_stmt|;
name|int
name|sig
decl_stmt|;
block|{
name|char
name|file1
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|,
name|file2
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|zfile1
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|,
name|zfile2
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|notified
decl_stmt|,
name|need_notification
decl_stmt|,
name|fd
decl_stmt|,
name|_numdays
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
ifdef|#
directive|ifdef
name|_IBMR2
comment|/* AIX 3.1 has a broken fchown- if the owner_uid is -1, it will actually */
comment|/* change it to be owned by uid -1, instead of leaving it as is, as it is */
comment|/* supposed to. */
if|if
condition|(
name|owner_uid
operator|==
operator|-
literal|1
condition|)
name|owner_uid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Remove oldest log */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file1
argument_list|,
literal|"%s.%d"
argument_list|,
name|log
argument_list|,
name|numdays
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zfile1
argument_list|,
name|file1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|zfile1
argument_list|,
name|COMPRESS_POSTFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"rm -f %s\n"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rm -f %s\n"
argument_list|,
name|zfile1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|file1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|zfile1
argument_list|)
expr_stmt|;
block|}
comment|/* Move down log files */
name|_numdays
operator|=
name|numdays
expr_stmt|;
comment|/* preserve */
while|while
condition|(
name|numdays
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|file2
argument_list|,
name|file1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|file1
argument_list|,
literal|"%s.%d"
argument_list|,
name|log
argument_list|,
name|numdays
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zfile1
argument_list|,
name|file1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zfile2
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|file1
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|zfile1
argument_list|,
name|COMPRESS_POSTFIX
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|zfile2
argument_list|,
name|COMPRESS_POSTFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|zfile1
argument_list|,
operator|&
name|st
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"mv %s %s\n"
argument_list|,
name|zfile1
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chmod %o %s\n"
argument_list|,
name|perm
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"chown %d.%d %s\n"
argument_list|,
name|owner_uid
argument_list|,
name|group_gid
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|rename
argument_list|(
name|zfile1
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|zfile2
argument_list|,
name|perm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chown
argument_list|(
name|zfile2
argument_list|,
name|owner_uid
argument_list|,
name|group_gid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|noaction
operator|&&
operator|!
operator|(
name|flags
operator|&
name|CE_BINARY
operator|)
condition|)
operator|(
name|void
operator|)
name|log_trim
argument_list|(
name|log
argument_list|)
expr_stmt|;
comment|/* Report the trimming to the old log */
if|if
condition|(
operator|!
name|_numdays
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"rm %s\n"
argument_list|,
name|log
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"mv %s to %s\n"
argument_list|,
name|log
argument_list|,
name|file1
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|rename
argument_list|(
name|log
argument_list|,
name|file1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"Start new log..."
argument_list|)
expr_stmt|;
else|else
block|{
name|fd
operator|=
name|creat
argument_list|(
name|log
argument_list|,
name|perm
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't start new log"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fchown
argument_list|(
name|fd
argument_list|,
name|owner_uid
argument_list|,
name|group_gid
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't chmod new log file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CE_BINARY
operator|)
condition|)
if|if
condition|(
name|log_trim
argument_list|(
name|log
argument_list|)
condition|)
comment|/* Add status message */
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't add status message to log"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"chmod %o %s..."
argument_list|,
name|perm
argument_list|,
name|log
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|log
argument_list|,
name|perm
argument_list|)
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
name|need_notification
operator|=
name|notified
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pid_file
operator|!=
name|NULL
condition|)
block|{
name|need_notification
operator|=
literal|1
expr_stmt|;
name|pid
operator|=
name|get_pid
argument_list|(
name|pid_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
block|{
name|notified
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"kill -%d %d\n"
argument_list|,
name|sig
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kill
argument_list|(
name|pid
argument_list|,
name|sig
argument_list|)
condition|)
name|warn
argument_list|(
literal|"can't notify daemon, pid %d"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
else|else
block|{
name|notified
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"daemon pid %d notified\n"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|CE_COMPACT
operator|)
condition|)
block|{
if|if
condition|(
name|need_notification
operator|&&
operator|!
name|notified
condition|)
name|warnx
argument_list|(
literal|"log not compressed because daemon not notified"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"Compress %s.0\n"
argument_list|,
name|log
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|notified
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"small pause to allow daemon to close log\n"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|compress_log
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Log the fact that the logs were turned over */
end_comment

begin_function
specifier|static
name|int
name|log_trim
parameter_list|(
name|log
parameter_list|)
name|char
modifier|*
name|log
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|log
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s %s newsyslog[%d]: logfile turned over\n"
argument_list|,
name|daytime
argument_list|,
name|hostname
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"log_trim: fclose:"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fork of /usr/ucb/compress to compress the old log file */
end_comment

begin_function
specifier|static
name|void
name|compress_log
parameter_list|(
name|log
parameter_list|)
name|char
modifier|*
name|log
decl_stmt|;
block|{
name|pid_t
name|pid
decl_stmt|;
name|char
name|tmp
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s.0"
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pid
condition|)
block|{
operator|(
name|void
operator|)
name|execl
argument_list|(
name|COMPRESS_PATH
argument_list|,
name|COMPRESS_PROG
argument_list|,
literal|"-f"
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
name|COMPRESS_PATH
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return size in kilobytes of a file */
end_comment

begin_function
specifier|static
name|int
name|sizefile
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|kbytes
argument_list|(
name|dbtob
argument_list|(
name|sb
operator|.
name|st_blocks
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the age of old log file (file.0) */
end_comment

begin_function
specifier|static
name|int
name|age_old_log
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
name|tmp
index|[
name|MAXPATHLEN
operator|+
sizeof|sizeof
argument_list|(
literal|".0"
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|COMPRESS_POSTFIX
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|".0"
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|stat
argument_list|(
name|strcat
argument_list|(
name|tmp
argument_list|,
name|COMPRESS_POSTFIX
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|timenow
operator|-
name|sb
operator|.
name|st_mtime
operator|+
literal|1800
argument_list|)
operator|/
literal|3600
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|pid_t
name|get_pid
parameter_list|(
name|pid_file
parameter_list|)
name|char
modifier|*
name|pid_file
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|pid_t
name|pid
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|pid_file
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"can't open %s pid file to restart a daemon"
argument_list|,
name|pid_file
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|f
argument_list|)
condition|)
block|{
name|pid
operator|=
name|atol
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
name|MIN_PID
operator|||
name|pid
operator|>
name|MAX_PID
condition|)
block|{
name|warnx
argument_list|(
literal|"preposterous process number: %d"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
name|pid
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|warn
argument_list|(
literal|"can't read %s pid file to restart a daemon"
argument_list|,
name|pid_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
return|return
name|pid
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OSF
end_ifndef

begin_comment
comment|/* Duplicate a string using malloc */
end_comment

begin_function
name|char
modifier|*
name|strdup
parameter_list|(
name|strp
parameter_list|)
specifier|register
name|char
modifier|*
name|strp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|strp
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|strcpy
argument_list|(
name|cp
argument_list|,
name|strp
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Skip Over Blanks */
end_comment

begin_function
name|char
modifier|*
name|sob
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Skip Over Non-Blanks */
end_comment

begin_function
name|char
modifier|*
name|son
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

end_unit

