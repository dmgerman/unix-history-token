begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This file contains changes from the Open Software Foundation.  */
end_comment

begin_comment
comment|/*  * Copyright 1988, 1989 by the Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of M.I.T. and the M.I.T. S.I.P.B. not be  * used in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission. M.I.T. and the M.I.T.  * S.I.P.B. make no representations about the suitability of this software  * for any purpose.  It is provided "as is" without express or implied  * warranty.  *  */
end_comment

begin_comment
comment|/*  * newsyslog - roll over selected logs at the appropriate time, keeping the a  * specified number of backup files around.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|OSF
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|COMPRESS_POSTFIX
end_ifndef

begin_define
define|#
directive|define
name|COMPRESS_POSTFIX
value|".gz"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|BZCOMPRESS_POSTFIX
end_ifndef

begin_define
define|#
directive|define
name|BZCOMPRESS_POSTFIX
value|".bz2"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<glob.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/*  * Bit-values for the 'flags' parsed from a config-file entry.  */
end_comment

begin_define
define|#
directive|define
name|CE_COMPACT
value|0x0001
end_define

begin_comment
comment|/* Compact the achived log files with gzip. */
end_comment

begin_define
define|#
directive|define
name|CE_BZCOMPACT
value|0x0002
end_define

begin_comment
comment|/* Compact the achived log files with bzip2. */
end_comment

begin_define
define|#
directive|define
name|CE_COMPACTWAIT
value|0x0004
end_define

begin_comment
comment|/* wait until compressing one file finishes */
end_comment

begin_comment
comment|/*    before starting the next step. */
end_comment

begin_define
define|#
directive|define
name|CE_BINARY
value|0x0008
end_define

begin_comment
comment|/* Logfile is in binary, do not add status */
end_comment

begin_comment
comment|/*    messages to logfile(s) when rotating. */
end_comment

begin_define
define|#
directive|define
name|CE_NOSIGNAL
value|0x0010
end_define

begin_comment
comment|/* There is no process to signal when */
end_comment

begin_comment
comment|/*    trimming this file. */
end_comment

begin_define
define|#
directive|define
name|CE_TRIMAT
value|0x0020
end_define

begin_comment
comment|/* trim file at a specific time. */
end_comment

begin_define
define|#
directive|define
name|CE_GLOB
value|0x0040
end_define

begin_comment
comment|/* name of the log is file name pattern. */
end_comment

begin_define
define|#
directive|define
name|CE_SIGNALGROUP
value|0x0080
end_define

begin_comment
comment|/* Signal a process-group instead of a single */
end_comment

begin_comment
comment|/*    process when trimming this file. */
end_comment

begin_define
define|#
directive|define
name|CE_CREATE
value|0x0100
end_define

begin_comment
comment|/* Create the log file if it does not exist. */
end_comment

begin_define
define|#
directive|define
name|MIN_PID
value|5
end_define

begin_comment
comment|/* Don't touch pids lower than this */
end_comment

begin_define
define|#
directive|define
name|MAX_PID
value|99999
end_define

begin_comment
comment|/* was lower, see /usr/include/sys/proc.h */
end_comment

begin_define
define|#
directive|define
name|kbytes
parameter_list|(
name|size
parameter_list|)
value|(((size) + 1023)>> 10)
end_define

begin_struct
struct|struct
name|conf_entry
block|{
name|char
modifier|*
name|log
decl_stmt|;
comment|/* Name of the log */
name|char
modifier|*
name|pid_file
decl_stmt|;
comment|/* PID file */
name|char
modifier|*
name|r_reason
decl_stmt|;
comment|/* The reason this file is being rotated */
name|int
name|firstcreate
decl_stmt|;
comment|/* Creating log for the first time (-C). */
name|int
name|rotate
decl_stmt|;
comment|/* Non-zero if this file should be rotated */
name|uid_t
name|uid
decl_stmt|;
comment|/* Owner of log */
name|gid_t
name|gid
decl_stmt|;
comment|/* Group of log */
name|int
name|numlogs
decl_stmt|;
comment|/* Number of logs to keep */
name|int
name|size
decl_stmt|;
comment|/* Size cutoff to trigger trimming the log */
name|int
name|hours
decl_stmt|;
comment|/* Hours between log trimming */
name|time_t
name|trim_at
decl_stmt|;
comment|/* Specific time to do trimming */
name|int
name|permissions
decl_stmt|;
comment|/* File permissions on the log */
name|int
name|flags
decl_stmt|;
comment|/* CE_COMPACT, CE_BZCOMPACT, CE_BINARY */
name|int
name|sig
decl_stmt|;
comment|/* Signal to send */
name|int
name|def_cfg
decl_stmt|;
comment|/* Using the<default> rule for this file */
name|struct
name|conf_entry
modifier|*
name|next
decl_stmt|;
comment|/* Linked list pointer */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEFAULT_MARKER
value|"<default>"
end_define

begin_decl_stmt
name|int
name|archtodir
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Archive old logfiles to other directory */
end_comment

begin_decl_stmt
name|int
name|createlogs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create (non-GLOB) logfiles which do not */
end_comment

begin_comment
comment|/*    already exist.  1=='for entries with */
end_comment

begin_comment
comment|/*    C flag', 2=='for all entries'. */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print out what's going on */
end_comment

begin_decl_stmt
name|int
name|needroot
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Root privs are necessary */
end_comment

begin_decl_stmt
name|int
name|noaction
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't do anything, just show it */
end_comment

begin_decl_stmt
name|int
name|nosignal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do not send any signals */
end_comment

begin_decl_stmt
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force the trim no matter what */
end_comment

begin_decl_stmt
name|int
name|rotatereq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -R = Always rotate the file(s) as given */
end_comment

begin_comment
comment|/*    on the command (this also requires   */
end_comment

begin_comment
comment|/*    that a list of files *are* given on  */
end_comment

begin_comment
comment|/*    the run command). */
end_comment

begin_decl_stmt
name|char
modifier|*
name|requestor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name given on a -R request */
end_comment

begin_decl_stmt
name|char
modifier|*
name|archdirname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory path to old logfiles archive */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|conf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Configuration file to use */
end_comment

begin_decl_stmt
name|time_t
name|timenow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hostname */
end_comment

begin_decl_stmt
name|char
name|daytime
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timenow in human readable form */
end_comment

begin_function_decl
specifier|static
name|struct
name|conf_entry
modifier|*
name|get_worklist
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_file
parameter_list|(
name|FILE
modifier|*
name|cf
parameter_list|,
specifier|const
name|char
modifier|*
name|cfname
parameter_list|,
name|struct
name|conf_entry
modifier|*
modifier|*
name|work_p
parameter_list|,
name|struct
name|conf_entry
modifier|*
modifier|*
name|glob_p
parameter_list|,
name|struct
name|conf_entry
modifier|*
modifier|*
name|defconf_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|sob
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|son
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isnumberstr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|missing_field
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errline
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_entry
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_globs
parameter_list|(
name|struct
name|conf_entry
modifier|*
modifier|*
name|work_p
parameter_list|,
name|struct
name|conf_entry
modifier|*
modifier|*
name|glob_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_clist
parameter_list|(
name|struct
name|conf_entry
modifier|*
modifier|*
name|firstent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_entry
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|conf_entry
modifier|*
name|init_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|struct
name|conf_entry
modifier|*
name|src_entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dotrim
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|,
name|char
modifier|*
name|log
parameter_list|,
name|int
name|numdays
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|log_trim
parameter_list|(
specifier|const
name|char
modifier|*
name|log
parameter_list|,
specifier|const
name|struct
name|conf_entry
modifier|*
name|log_ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compress_log
parameter_list|(
name|char
modifier|*
name|log
parameter_list|,
name|int
name|dowait
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bzcompress_log
parameter_list|(
name|char
modifier|*
name|log
parameter_list|,
name|int
name|dowait
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sizefile
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|age_old_log
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|send_signal
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|movefile
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|perm
parameter_list|,
name|uid_t
name|owner_uid
parameter_list|,
name|gid_t
name|group_gid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|createdir
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|,
name|char
modifier|*
name|dirpart
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|createlog
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|parse8601
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|parseDWM
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * All the following are defined to work on an 'int', in the  * range 0 to 255, plus EOF.  Define wrappers which can take  * values of type 'char', either signed or unsigned.  */
end_comment

begin_define
define|#
directive|define
name|isdigitch
parameter_list|(
name|Anychar
parameter_list|)
value|isdigit(((int) Anychar)& 255)
end_define

begin_define
define|#
directive|define
name|isprintch
parameter_list|(
name|Anychar
parameter_list|)
value|isprint(((int) Anychar)& 255)
end_define

begin_define
define|#
directive|define
name|isspacech
parameter_list|(
name|Anychar
parameter_list|)
value|isspace(((int) Anychar)& 255)
end_define

begin_define
define|#
directive|define
name|tolowerch
parameter_list|(
name|Anychar
parameter_list|)
value|tolower(((int) Anychar)& 255)
end_define

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|conf_entry
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|needroot
operator|&&
name|getuid
argument_list|()
operator|&&
name|geteuid
argument_list|()
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"must have root privs"
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
operator|=
name|get_worklist
argument_list|(
name|argv
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|do_entry
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free_entry
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
expr_stmt|;
block|}
while|while
condition|(
name|wait
argument_list|(
name|NULL
argument_list|)
operator|>
literal|0
operator|||
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|conf_entry
modifier|*
name|init_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|struct
name|conf_entry
modifier|*
name|src_entry
parameter_list|)
block|{
name|struct
name|conf_entry
modifier|*
name|tempwork
decl_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"\t--> [creating entry for %s]\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|tempwork
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|conf_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempwork
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc of conf_entry for %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|tempwork
operator|->
name|log
operator|=
name|strdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempwork
operator|->
name|log
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"strdup for %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_entry
operator|!=
name|NULL
condition|)
block|{
name|tempwork
operator|->
name|pid_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|src_entry
operator|->
name|pid_file
condition|)
name|tempwork
operator|->
name|pid_file
operator|=
name|strdup
argument_list|(
name|src_entry
operator|->
name|pid_file
argument_list|)
expr_stmt|;
name|tempwork
operator|->
name|r_reason
operator|=
name|NULL
expr_stmt|;
name|tempwork
operator|->
name|firstcreate
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|rotate
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|uid
operator|=
name|src_entry
operator|->
name|uid
expr_stmt|;
name|tempwork
operator|->
name|gid
operator|=
name|src_entry
operator|->
name|gid
expr_stmt|;
name|tempwork
operator|->
name|numlogs
operator|=
name|src_entry
operator|->
name|numlogs
expr_stmt|;
name|tempwork
operator|->
name|size
operator|=
name|src_entry
operator|->
name|size
expr_stmt|;
name|tempwork
operator|->
name|hours
operator|=
name|src_entry
operator|->
name|hours
expr_stmt|;
name|tempwork
operator|->
name|trim_at
operator|=
name|src_entry
operator|->
name|trim_at
expr_stmt|;
name|tempwork
operator|->
name|permissions
operator|=
name|src_entry
operator|->
name|permissions
expr_stmt|;
name|tempwork
operator|->
name|flags
operator|=
name|src_entry
operator|->
name|flags
expr_stmt|;
name|tempwork
operator|->
name|sig
operator|=
name|src_entry
operator|->
name|sig
expr_stmt|;
name|tempwork
operator|->
name|def_cfg
operator|=
name|src_entry
operator|->
name|def_cfg
expr_stmt|;
block|}
else|else
block|{
comment|/* Initialize as a "do-nothing" entry */
name|tempwork
operator|->
name|pid_file
operator|=
name|NULL
expr_stmt|;
name|tempwork
operator|->
name|r_reason
operator|=
name|NULL
expr_stmt|;
name|tempwork
operator|->
name|firstcreate
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|rotate
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|uid
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tempwork
operator|->
name|gid
operator|=
operator|(
name|gid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tempwork
operator|->
name|numlogs
operator|=
literal|1
expr_stmt|;
name|tempwork
operator|->
name|size
operator|=
operator|-
literal|1
expr_stmt|;
name|tempwork
operator|->
name|hours
operator|=
operator|-
literal|1
expr_stmt|;
name|tempwork
operator|->
name|trim_at
operator|=
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
name|tempwork
operator|->
name|permissions
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|sig
operator|=
name|SIGHUP
expr_stmt|;
name|tempwork
operator|->
name|def_cfg
operator|=
literal|0
expr_stmt|;
block|}
name|tempwork
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|tempwork
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_entry
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ent
operator|->
name|log
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"\t--> [freeing entry for %s]\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
name|ent
operator|->
name|log
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|pid_file
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ent
operator|->
name|pid_file
argument_list|)
expr_stmt|;
name|ent
operator|->
name|pid_file
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|r_reason
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ent
operator|->
name|r_reason
argument_list|)
expr_stmt|;
name|ent
operator|->
name|r_reason
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_clist
parameter_list|(
name|struct
name|conf_entry
modifier|*
modifier|*
name|firstent
parameter_list|)
block|{
name|struct
name|conf_entry
modifier|*
name|ent
decl_stmt|,
modifier|*
name|nextent
decl_stmt|;
if|if
condition|(
name|firstent
operator|==
name|NULL
condition|)
return|return;
comment|/* There is nothing to do. */
name|ent
operator|=
operator|*
name|firstent
expr_stmt|;
name|firstent
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|ent
condition|)
block|{
name|nextent
operator|=
name|ent
operator|->
name|next
expr_stmt|;
name|free_entry
argument_list|(
name|ent
argument_list|)
expr_stmt|;
name|ent
operator|=
name|nextent
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_entry
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
define|#
directive|define
name|REASON_MAX
value|80
name|int
name|size
decl_stmt|,
name|modtime
decl_stmt|;
name|char
name|temp_reason
index|[
name|REASON_MAX
index|]
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_COMPACT
condition|)
name|printf
argument_list|(
literal|"%s<%dZ>: "
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_BZCOMPACT
condition|)
name|printf
argument_list|(
literal|"%s<%dJ>: "
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s<%d>: "
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|sizefile
argument_list|(
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
name|modtime
operator|=
name|age_old_log
argument_list|(
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
name|ent
operator|->
name|rotate
operator|=
literal|0
expr_stmt|;
name|ent
operator|->
name|firstcreate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
comment|/* 		 * If either the C flag or the -C option was specified, 		 * and if we won't be creating the file, then have the 		 * verbose message include a hint as to why the file 		 * will not be created. 		 */
name|temp_reason
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|createlogs
operator|>
literal|1
condition|)
name|ent
operator|->
name|firstcreate
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ent
operator|->
name|flags
operator|&
name|CE_CREATE
operator|)
operator|&&
name|createlogs
condition|)
name|ent
operator|->
name|firstcreate
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_CREATE
condition|)
name|strncpy
argument_list|(
name|temp_reason
argument_list|,
literal|" (no -C option)"
argument_list|,
name|REASON_MAX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|createlogs
condition|)
name|strncpy
argument_list|(
name|temp_reason
argument_list|,
literal|" (no C flag)"
argument_list|,
name|REASON_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|firstcreate
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"does not exist -> will create.\n"
argument_list|)
expr_stmt|;
name|createlog
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"does not exist, skipped%s.\n"
argument_list|,
name|temp_reason
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_TRIMAT
operator|&&
operator|!
name|force
operator|&&
operator|!
name|rotatereq
condition|)
block|{
if|if
condition|(
name|timenow
operator|<
name|ent
operator|->
name|trim_at
operator|||
name|difftime
argument_list|(
name|timenow
argument_list|,
name|ent
operator|->
name|trim_at
argument_list|)
operator|>=
literal|60
operator|*
literal|60
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"--> will trim at %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|ent
operator|->
name|trim_at
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|verbose
operator|&&
name|ent
operator|->
name|hours
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"--> time is up\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
operator|&&
operator|(
name|ent
operator|->
name|size
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"size (Kb): %d [%d] "
argument_list|,
name|size
argument_list|,
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
operator|(
name|ent
operator|->
name|hours
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|" age (hr): %d [%d] "
argument_list|,
name|modtime
argument_list|,
name|ent
operator|->
name|hours
argument_list|)
expr_stmt|;
comment|/* 		 * Figure out if this logfile needs to be rotated. 		 */
name|temp_reason
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rotatereq
condition|)
block|{
name|ent
operator|->
name|rotate
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|temp_reason
argument_list|,
name|REASON_MAX
argument_list|,
literal|" due to -R from %s"
argument_list|,
name|requestor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force
condition|)
block|{
name|ent
operator|->
name|rotate
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|temp_reason
argument_list|,
name|REASON_MAX
argument_list|,
literal|" due to -F request"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ent
operator|->
name|size
operator|>
literal|0
operator|)
operator|&&
operator|(
name|size
operator|>=
name|ent
operator|->
name|size
operator|)
condition|)
block|{
name|ent
operator|->
name|rotate
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|temp_reason
argument_list|,
name|REASON_MAX
argument_list|,
literal|" due to size>%dK"
argument_list|,
name|ent
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ent
operator|->
name|hours
operator|<=
literal|0
operator|&&
operator|(
name|ent
operator|->
name|flags
operator|&
name|CE_TRIMAT
operator|)
condition|)
block|{
name|ent
operator|->
name|rotate
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ent
operator|->
name|hours
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|modtime
operator|>=
name|ent
operator|->
name|hours
operator|)
operator|||
operator|(
name|modtime
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|ent
operator|->
name|rotate
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * If the file needs to be rotated, then rotate it. 		 */
if|if
condition|(
name|ent
operator|->
name|rotate
condition|)
block|{
if|if
condition|(
name|temp_reason
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|ent
operator|->
name|r_reason
operator|=
name|strdup
argument_list|(
name|temp_reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"--> trimming log....\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noaction
operator|&&
operator|!
name|verbose
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_COMPACT
condition|)
name|printf
argument_list|(
literal|"%s<%dZ>: trimming\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_BZCOMPACT
condition|)
name|printf
argument_list|(
literal|"%s<%dJ>: trimming\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s<%d>: trimming\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
block|}
name|dotrim
argument_list|(
name|ent
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|,
name|ent
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"--> skipping\n"
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|REASON_MAX
block|}
end_function

begin_comment
comment|/* Send a signal to the pid specified by pidfile */
end_comment

begin_function
specifier|static
name|int
name|send_signal
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
name|pid_t
name|target_pid
decl_stmt|;
name|int
name|did_notify
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|minok
decl_stmt|,
name|maxok
decl_stmt|,
name|rval
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_name
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|,
modifier|*
name|linep
decl_stmt|,
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|did_notify
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|ent
operator|->
name|pid_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"can't open pid file: %s"
argument_list|,
name|ent
operator|->
name|pid_file
argument_list|)
expr_stmt|;
return|return
operator|(
name|did_notify
operator|)
return|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|f
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * XXX - If the pid file is empty, is that really a 		 *	problem?  Wouldn't that mean that the process 		 *	has shut down?  In that case there would be no 		 *	problem with compressing the rotated log file. 		 */
if|if
condition|(
name|feof
argument_list|(
name|f
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"pid file is empty: %s"
argument_list|,
name|ent
operator|->
name|pid_file
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"can't read from pid file: %s"
argument_list|,
name|ent
operator|->
name|pid_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|did_notify
operator|)
return|;
comment|/* NOTREACHED */
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|target_name
operator|=
literal|"daemon"
expr_stmt|;
name|minok
operator|=
name|MIN_PID
expr_stmt|;
name|maxok
operator|=
name|MAX_PID
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_SIGNALGROUP
condition|)
block|{
comment|/* 		 * If we are expected to signal a process-group when 		 * rotating this logfile, then the value read in should 		 * be the negative of a valid process ID. 		 */
name|target_name
operator|=
literal|"process-group"
expr_stmt|;
name|minok
operator|=
operator|-
name|MAX_PID
expr_stmt|;
name|maxok
operator|=
operator|-
name|MIN_PID
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|linep
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|linep
operator|==
literal|' '
condition|)
name|linep
operator|++
expr_stmt|;
name|rval
operator|=
name|strtol
argument_list|(
name|linep
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspacech
argument_list|(
operator|*
name|endp
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"pid file does not start with a valid number: %s"
argument_list|,
name|ent
operator|->
name|pid_file
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rval
operator|<
name|minok
operator|||
name|rval
operator|>
name|maxok
condition|)
block|{
name|warnx
argument_list|(
literal|"bad value '%ld' for process number in %s"
argument_list|,
name|rval
argument_list|,
name|ent
operator|->
name|pid_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|warnx
argument_list|(
literal|"\t(expecting value between %ld and %ld)"
argument_list|,
name|minok
argument_list|,
name|maxok
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rval
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|did_notify
operator|)
return|;
comment|/* NOTREACHED */
block|}
name|target_pid
operator|=
name|rval
expr_stmt|;
if|if
condition|(
name|noaction
condition|)
block|{
name|did_notify
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\tkill -%d %d\n"
argument_list|,
name|ent
operator|->
name|sig
argument_list|,
operator|(
name|int
operator|)
name|target_pid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kill
argument_list|(
name|target_pid
argument_list|,
name|ent
operator|->
name|sig
argument_list|)
condition|)
block|{
comment|/* 		 * XXX - Iff the error was "no such process", should that 		 *	really be an error for us?  Perhaps the process 		 *	is already gone, in which case there would be no 		 *	problem with compressing the rotated log file. 		 */
name|warn
argument_list|(
literal|"can't notify %s, pid %d"
argument_list|,
name|target_name
argument_list|,
operator|(
name|int
operator|)
name|target_pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|did_notify
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%s pid %d notified\n"
argument_list|,
name|target_name
argument_list|,
operator|(
name|int
operator|)
name|target_pid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|did_notify
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|timenow
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|daytime
argument_list|,
name|ctime
argument_list|(
operator|&
name|timenow
argument_list|)
operator|+
literal|4
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|daytime
index|[
literal|15
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Let's get our hostname */
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Truncate domain */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Parse command line options. */
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:f:nrsvCFR:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|archtodir
operator|++
expr_stmt|;
name|archdirname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|conf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|noaction
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|needroot
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|nosignal
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Useful for things like rc.diskless... */
name|createlogs
operator|++
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|force
operator|++
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|rotatereq
operator|++
expr_stmt|;
name|requestor
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Used by OpenBSD for "monitor mode" */
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|rotatereq
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
name|warnx
argument_list|(
literal|"At least one filename must be given when -R is specified."
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* Make sure "requestor" value is safe for a syslog message. */
for|for
control|(
name|p
operator|=
name|requestor
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isprintch
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\t'
operator|)
condition|)
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: newsyslog [-CFnrsv] [-a directory] [-f config-file]\n"
literal|"                 [ [-R requestor] filename ... ]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse a configuration file and return a linked list of all the logs  * which should be processed.  */
end_comment

begin_function
specifier|static
name|struct
name|conf_entry
modifier|*
name|get_worklist
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
modifier|*
name|given
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|defconf
decl_stmt|,
modifier|*
name|dupent
decl_stmt|,
modifier|*
name|ent
decl_stmt|,
modifier|*
name|firstnew
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|globlist
decl_stmt|,
modifier|*
name|lastnew
decl_stmt|,
modifier|*
name|worklist
decl_stmt|;
name|int
name|gmatch
decl_stmt|,
name|fnres
decl_stmt|;
name|defconf
operator|=
name|globlist
operator|=
name|worklist
operator|=
name|NULL
expr_stmt|;
name|fname
operator|=
name|conf
expr_stmt|;
if|if
condition|(
name|fname
operator|==
name|NULL
condition|)
name|fname
operator|=
name|_PATH_CONF
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
block|{
name|f
operator|=
name|stdin
expr_stmt|;
name|fname
operator|=
literal|"<stdin>"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|conf
argument_list|)
expr_stmt|;
name|parse_file
argument_list|(
name|f
argument_list|,
name|fname
argument_list|,
operator|&
name|worklist
argument_list|,
operator|&
name|globlist
argument_list|,
operator|&
name|defconf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* 	 * All config-file information has been read in and turned into 	 * a worklist and a globlist.  If there were no specific files 	 * given on the run command, then the only thing left to do is to 	 * call a routine which finds all files matched by the globlist 	 * and adds them to the worklist.  Then return the worklist. 	 */
if|if
condition|(
operator|*
name|files
operator|==
name|NULL
condition|)
block|{
name|expand_globs
argument_list|(
operator|&
name|worklist
argument_list|,
operator|&
name|globlist
argument_list|)
expr_stmt|;
name|free_clist
argument_list|(
operator|&
name|globlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|defconf
operator|!=
name|NULL
condition|)
name|free_entry
argument_list|(
name|defconf
argument_list|)
expr_stmt|;
return|return
operator|(
name|worklist
operator|)
return|;
comment|/* NOTREACHED */
block|}
comment|/* 	 * If newsyslog was given a specific list of files to process, 	 * it may be that some of those files were not listed in any 	 * config file.  Those unlisted files should get the default 	 * rotation action.  First, create the default-rotation action 	 * if none was found in a system config file. 	 */
if|if
condition|(
name|defconf
operator|==
name|NULL
condition|)
block|{
name|defconf
operator|=
name|init_entry
argument_list|(
name|DEFAULT_MARKER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|defconf
operator|->
name|numlogs
operator|=
literal|3
expr_stmt|;
name|defconf
operator|->
name|size
operator|=
literal|50
expr_stmt|;
name|defconf
operator|->
name|permissions
operator|=
name|S_IRUSR
operator||
name|S_IWUSR
expr_stmt|;
block|}
comment|/* 	 * If newsyslog was run with a list of specific filenames, 	 * then create a new worklist which has only those files in 	 * it, picking up the rotation-rules for those files from 	 * the original worklist. 	 * 	 * XXX - Note that this will copy multiple rules for a single 	 *	logfile, if multiple entries are an exact match for 	 *	that file.  That matches the historic behavior, but do 	 *	we want to continue to allow it?  If so, it should 	 *	probably be handled more intelligently. 	 */
name|firstnew
operator|=
name|lastnew
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|given
operator|=
name|files
init|;
operator|*
name|given
condition|;
operator|++
name|given
control|)
block|{
comment|/* 		 * First try to find exact-matches for this given file. 		 */
name|gmatch
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|worklist
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ent
operator|->
name|log
argument_list|,
operator|*
name|given
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gmatch
operator|++
expr_stmt|;
name|dupent
operator|=
name|init_entry
argument_list|(
operator|*
name|given
argument_list|,
name|ent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|firstnew
condition|)
name|firstnew
operator|=
name|dupent
expr_stmt|;
else|else
name|lastnew
operator|->
name|next
operator|=
name|dupent
expr_stmt|;
name|lastnew
operator|=
name|dupent
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gmatch
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ Matched entry %s\n"
argument_list|,
operator|*
name|given
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * There was no exact-match for this given file, so look 		 * for a "glob" entry which does match. 		 */
name|gmatch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
operator|&&
name|globlist
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"\t+ Checking globs for %s\n"
argument_list|,
operator|*
name|given
argument_list|)
expr_stmt|;
for|for
control|(
name|ent
operator|=
name|globlist
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
name|fnres
operator|=
name|fnmatch
argument_list|(
name|ent
operator|->
name|log
argument_list|,
operator|*
name|given
argument_list|,
name|FNM_PATHNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+    = %d for pattern %s\n"
argument_list|,
name|fnres
argument_list|,
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnres
operator|==
literal|0
condition|)
block|{
name|gmatch
operator|++
expr_stmt|;
name|dupent
operator|=
name|init_entry
argument_list|(
operator|*
name|given
argument_list|,
name|ent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|firstnew
condition|)
name|firstnew
operator|=
name|dupent
expr_stmt|;
else|else
name|lastnew
operator|->
name|next
operator|=
name|dupent
expr_stmt|;
name|lastnew
operator|=
name|dupent
expr_stmt|;
comment|/* This new entry is not a glob! */
name|dupent
operator|->
name|flags
operator|&=
operator|~
name|CE_GLOB
expr_stmt|;
comment|/* Only allow a match to one glob-entry */
break|break;
block|}
block|}
if|if
condition|(
name|gmatch
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ Matched %s via %s\n"
argument_list|,
operator|*
name|given
argument_list|,
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * This given file was not found in any config file, so 		 * add a worklist item based on the default entry. 		 */
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ No entry matched %s  (will use %s)\n"
argument_list|,
operator|*
name|given
argument_list|,
name|DEFAULT_MARKER
argument_list|)
expr_stmt|;
name|dupent
operator|=
name|init_entry
argument_list|(
operator|*
name|given
argument_list|,
name|defconf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|firstnew
condition|)
name|firstnew
operator|=
name|dupent
expr_stmt|;
else|else
name|lastnew
operator|->
name|next
operator|=
name|dupent
expr_stmt|;
comment|/* Mark that it was *not* found in a config file */
name|dupent
operator|->
name|def_cfg
operator|=
literal|1
expr_stmt|;
name|lastnew
operator|=
name|dupent
expr_stmt|;
block|}
comment|/* 	 * Free all the entries in the original work list, the list of 	 * glob entries, and the default entry. 	 */
name|free_clist
argument_list|(
operator|&
name|worklist
argument_list|)
expr_stmt|;
name|free_clist
argument_list|(
operator|&
name|globlist
argument_list|)
expr_stmt|;
name|free_entry
argument_list|(
name|defconf
argument_list|)
expr_stmt|;
comment|/* And finally, return a worklist which matches the given files. */
return|return
operator|(
name|firstnew
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expand the list of entries with filename patterns, and add all files  * which match those glob-entries onto the worklist.  */
end_comment

begin_function
specifier|static
name|void
name|expand_globs
parameter_list|(
name|struct
name|conf_entry
modifier|*
modifier|*
name|work_p
parameter_list|,
name|struct
name|conf_entry
modifier|*
modifier|*
name|glob_p
parameter_list|)
block|{
name|int
name|gmatch
decl_stmt|,
name|gres
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|mfname
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|dupent
decl_stmt|,
modifier|*
name|ent
decl_stmt|,
modifier|*
name|firstmatch
decl_stmt|,
modifier|*
name|globent
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|lastmatch
decl_stmt|;
name|glob_t
name|pglob
decl_stmt|;
name|struct
name|stat
name|st_fm
decl_stmt|;
if|if
condition|(
operator|(
name|glob_p
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|glob_p
operator|==
name|NULL
operator|)
condition|)
return|return;
comment|/* There is nothing to do. */
comment|/* 	 * The worklist contains all fully-specified (non-GLOB) names. 	 * 	 * Now expand the list of filename-pattern (GLOB) entries into 	 * a second list, which (by definition) will only match files 	 * that already exist.  Do not add a glob-related entry for any 	 * file which already exists in the fully-specified list. 	 */
name|firstmatch
operator|=
name|lastmatch
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|globent
operator|=
operator|*
name|glob_p
init|;
name|globent
condition|;
name|globent
operator|=
name|globent
operator|->
name|next
control|)
block|{
name|gres
operator|=
name|glob
argument_list|(
name|globent
operator|->
name|log
argument_list|,
name|GLOB_NOCHECK
argument_list|,
name|NULL
argument_list|,
operator|&
name|pglob
argument_list|)
expr_stmt|;
if|if
condition|(
name|gres
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"cannot expand pattern (%d): %s"
argument_list|,
name|gres
argument_list|,
name|globent
operator|->
name|log
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ Expanding pattern %s\n"
argument_list|,
name|globent
operator|->
name|log
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pglob
operator|.
name|gl_matchc
condition|;
name|i
operator|++
control|)
block|{
name|mfname
operator|=
name|pglob
operator|.
name|gl_pathv
index|[
name|i
index|]
expr_stmt|;
comment|/* See if this file already has a specific entry. */
name|gmatch
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ent
operator|=
operator|*
name|work_p
init|;
name|ent
condition|;
name|ent
operator|=
name|ent
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|mfname
argument_list|,
name|ent
operator|->
name|log
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gmatch
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|gmatch
condition|)
continue|continue;
comment|/* Make sure the named matched is a file. */
name|gres
operator|=
name|lstat
argument_list|(
name|mfname
argument_list|,
operator|&
name|st_fm
argument_list|)
expr_stmt|;
if|if
condition|(
name|gres
operator|!=
literal|0
condition|)
block|{
comment|/* Error on a file that glob() matched?!? */
name|warn
argument_list|(
literal|"Skipping %s - lstat() error"
argument_list|,
name|mfname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st_fm
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* We only rotate files! */
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+  . skipping %s (!file)\n"
argument_list|,
name|mfname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+  . add file %s\n"
argument_list|,
name|mfname
argument_list|)
expr_stmt|;
name|dupent
operator|=
name|init_entry
argument_list|(
name|mfname
argument_list|,
name|globent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|firstmatch
condition|)
name|firstmatch
operator|=
name|dupent
expr_stmt|;
else|else
name|lastmatch
operator|->
name|next
operator|=
name|dupent
expr_stmt|;
name|lastmatch
operator|=
name|dupent
expr_stmt|;
comment|/* This new entry is not a glob! */
name|dupent
operator|->
name|flags
operator|&=
operator|~
name|CE_GLOB
expr_stmt|;
block|}
name|globfree
argument_list|(
operator|&
name|pglob
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ Done with pattern %s\n"
argument_list|,
name|globent
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
comment|/* Add the list of matched files to the end of the worklist. */
if|if
condition|(
operator|!
operator|*
name|work_p
condition|)
operator|*
name|work_p
operator|=
name|firstmatch
expr_stmt|;
else|else
block|{
name|ent
operator|=
operator|*
name|work_p
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|next
condition|)
name|ent
operator|=
name|ent
operator|->
name|next
expr_stmt|;
name|ent
operator|->
name|next
operator|=
name|firstmatch
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse a configuration file and update a linked list of all the logs to  * process.  */
end_comment

begin_function
specifier|static
name|void
name|parse_file
parameter_list|(
name|FILE
modifier|*
name|cf
parameter_list|,
specifier|const
name|char
modifier|*
name|cfname
parameter_list|,
name|struct
name|conf_entry
modifier|*
modifier|*
name|work_p
parameter_list|,
name|struct
name|conf_entry
modifier|*
modifier|*
name|glob_p
parameter_list|,
name|struct
name|conf_entry
modifier|*
modifier|*
name|defconf_p
parameter_list|)
block|{
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|parse
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|errline
decl_stmt|,
modifier|*
name|group
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|lastglob
decl_stmt|,
modifier|*
name|lastwork
decl_stmt|,
modifier|*
name|working
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|int
name|eol
decl_stmt|,
name|special
decl_stmt|;
comment|/* 	 * XXX - for now, assume that only one config file will be read, 	 *	ie, this routine is only called one time. 	 */
name|lastglob
operator|=
name|lastwork
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|cf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|errline
operator|=
name|strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|line
operator|+
literal|1
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'#'
condition|)
continue|continue;
if|if
condition|(
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|==
literal|'\\'
condition|)
block|{
name|strcpy
argument_list|(
name|cp
operator|-
literal|1
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|--
expr_stmt|;
continue|continue;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
name|line
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
name|special
operator|=
literal|0
expr_stmt|;
name|working
operator|=
name|init_entry
argument_list|(
name|q
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|DEFAULT_MARKER
argument_list|,
name|q
argument_list|)
operator|==
literal|0
condition|)
block|{
name|special
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|defconf_p
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Ignoring entry for %s in %s!"
argument_list|,
name|q
argument_list|,
name|cfname
argument_list|)
expr_stmt|;
name|free_entry
argument_list|(
name|working
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|*
name|defconf_p
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Ignoring duplicate entry for %s!"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free_entry
argument_list|(
name|working
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|defconf_p
operator|=
name|working
expr_stmt|;
block|}
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|group
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|group
operator|=
name|strrchr
argument_list|(
name|q
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|group
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isnumberstr
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; unknown user:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
block|}
else|else
name|working
operator|->
name|uid
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|working
operator|->
name|uid
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|q
operator|=
name|group
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isnumberstr
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; unknown group:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
else|else
name|working
operator|->
name|gid
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|working
operator|->
name|gid
operator|=
operator|(
name|gid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|working
operator|->
name|uid
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|working
operator|->
name|gid
operator|=
operator|(
name|gid_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|working
operator|->
name|permissions
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; bad permissions:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|working
operator|->
name|numlogs
argument_list|)
operator|||
name|working
operator|->
name|numlogs
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; bad value for count of logs to save:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isdigitch
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|working
operator|->
name|size
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
name|working
operator|->
name|size
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"Invalid value of '%s' for 'size' in line:\n%s"
argument_list|,
name|q
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|size
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|working
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|eol
operator|=
operator|!
operator|*
name|parse
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|q
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|q
condition|)
name|working
operator|->
name|hours
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ep
operator|==
literal|'*'
condition|)
name|working
operator|->
name|hours
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ul
operator|>
name|INT_MAX
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"interval is too large:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
else|else
name|working
operator|->
name|hours
operator|=
name|ul
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
operator|&&
operator|*
name|ep
operator|!=
literal|'@'
operator|&&
operator|*
name|ep
operator|!=
literal|'*'
operator|&&
operator|*
name|ep
operator|!=
literal|'$'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed interval/at:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'@'
condition|)
block|{
name|working
operator|->
name|trim_at
operator|=
name|parse8601
argument_list|(
name|ep
operator|+
literal|1
argument_list|)
expr_stmt|;
name|working
operator|->
name|flags
operator||=
name|CE_TRIMAT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ep
operator|==
literal|'$'
condition|)
block|{
name|working
operator|->
name|trim_at
operator|=
name|parseDWM
argument_list|(
name|ep
operator|+
literal|1
argument_list|)
expr_stmt|;
name|working
operator|->
name|flags
operator||=
name|CE_TRIMAT
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_TRIMAT
condition|)
block|{
if|if
condition|(
name|working
operator|->
name|trim_at
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed at:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
if|if
condition|(
name|working
operator|->
name|trim_at
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|2
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"nonexistent time:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
expr_stmt|;
comment|/* Optional field */
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
init|;
name|q
operator|&&
operator|*
name|q
operator|&&
operator|!
name|isspacech
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
block|{
switch|switch
condition|(
name|tolowerch
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
case|case
literal|'b'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_BINARY
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* 				 * XXX - 	Ick! Ugly! Remove ASAP! 				 * We want `c' and `C' for "create".  But we 				 * will temporarily treat `c' as `g', because 				 * FreeBSD releases<= 4.8 have a typo of 				 * checking  ('G' || 'c')  for CE_GLOB. 				 */
if|if
condition|(
operator|*
name|q
operator|==
literal|'c'
condition|)
block|{
name|warnx
argument_list|(
literal|"Assuming 'g' for 'c' in flags for line:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"The 'c' flag will eventually mean 'CREATE'"
argument_list|)
expr_stmt|;
name|working
operator|->
name|flags
operator||=
name|CE_GLOB
expr_stmt|;
break|break;
block|}
name|working
operator|->
name|flags
operator||=
name|CE_CREATE
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_GLOB
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_BZCOMPACT
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_NOSIGNAL
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_SIGNALGROUP
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_COMPACTWAIT
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_COMPACT
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
break|break;
case|case
literal|'f'
case|:
comment|/* Used by OpenBSD for "CE_FOLLOW" */
case|case
literal|'m'
case|:
comment|/* Used by OpenBSD for "CE_MONITOR" */
case|case
literal|'p'
case|:
comment|/* Used by NetBSD  for "CE_PLAIN0" */
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal flag in config file -- %c"
argument_list|,
operator|*
name|q
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
expr_stmt|;
comment|/* Optional field */
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
name|working
operator|->
name|pid_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|q
operator|&&
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'/'
condition|)
name|working
operator|->
name|pid_file
operator|=
name|strdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|q
argument_list|)
condition|)
goto|goto
name|got_sig
goto|;
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal pid file or signal number in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
operator|++
name|parse
argument_list|)
expr_stmt|;
comment|/* Optional field */
operator|*
operator|(
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
name|working
operator|->
name|sig
operator|=
name|SIGHUP
expr_stmt|;
if|if
condition|(
name|q
operator|&&
operator|*
name|q
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
name|got_sig
label|:
name|working
operator|->
name|sig
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err_sig
label|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal signal number in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|working
operator|->
name|sig
operator|<
literal|1
operator|||
name|working
operator|->
name|sig
operator|>=
name|NSIG
condition|)
goto|goto
name|err_sig
goto|;
block|}
comment|/* 		 * Finish figuring out what pid-file to use (if any) in 		 * later processing if this logfile needs to be rotated. 		 */
if|if
condition|(
operator|(
name|working
operator|->
name|flags
operator|&
name|CE_NOSIGNAL
operator|)
operator|==
name|CE_NOSIGNAL
condition|)
block|{
comment|/* 			 * This config-entry specified 'n' for nosignal, 			 * see if it also specified an explicit pid_file. 			 * This would be a pretty pointless combination. 			 */
if|if
condition|(
name|working
operator|->
name|pid_file
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Ignoring '%s' because flag 'n' was specified in line:\n%s"
argument_list|,
name|working
operator|->
name|pid_file
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|working
operator|->
name|pid_file
argument_list|)
expr_stmt|;
name|working
operator|->
name|pid_file
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|working
operator|->
name|pid_file
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This entry did not specify the 'n' flag, which 			 * means it should signal syslogd unless it had 			 * specified some other pid-file (and obviously the 			 * syslog pid-file will not be for a process-group). 			 * Also, we should only try to notify syslog if we 			 * are root. 			 */
if|if
condition|(
name|working
operator|->
name|flags
operator|&
name|CE_SIGNALGROUP
condition|)
block|{
name|warnx
argument_list|(
literal|"Ignoring flag 'U' in line:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|flags
operator|&=
operator|~
name|CE_SIGNALGROUP
expr_stmt|;
block|}
if|if
condition|(
name|needroot
condition|)
name|working
operator|->
name|pid_file
operator|=
name|strdup
argument_list|(
name|_PATH_SYSLOGPID
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Add this entry to the appropriate list of entries, unless 		 * it was some kind of special entry (eg:<default>). 		 */
if|if
condition|(
name|special
condition|)
block|{
empty_stmt|;
comment|/* Do not add to any list */
block|}
elseif|else
if|if
condition|(
name|working
operator|->
name|flags
operator|&
name|CE_GLOB
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|glob_p
condition|)
operator|*
name|glob_p
operator|=
name|working
expr_stmt|;
else|else
name|lastglob
operator|->
name|next
operator|=
name|working
expr_stmt|;
name|lastglob
operator|=
name|working
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|*
name|work_p
condition|)
operator|*
name|work_p
operator|=
name|working
expr_stmt|;
else|else
name|lastwork
operator|->
name|next
operator|=
name|working
expr_stmt|;
name|lastwork
operator|=
name|working
expr_stmt|;
block|}
name|free
argument_list|(
name|errline
argument_list|)
expr_stmt|;
name|errline
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|missing_field
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errline
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
operator|*
name|p
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"missing field in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dotrim
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|,
name|char
modifier|*
name|log
parameter_list|,
name|int
name|numdays
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
name|dirpart
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|namepart
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|file1
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|file2
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|zfile1
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|zfile2
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|jfile1
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|tfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|notified
decl_stmt|,
name|need_notification
decl_stmt|,
name|fd
decl_stmt|,
name|_numdays
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|archtodir
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* build complete name of archive directory into dirpart */
if|if
condition|(
operator|*
name|archdirname
operator|==
literal|'/'
condition|)
block|{
comment|/* absolute */
name|strlcpy
argument_list|(
name|dirpart
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|dirpart
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* relative */
comment|/* get directory part of logfile */
name|strlcpy
argument_list|(
name|dirpart
argument_list|,
name|log
argument_list|,
sizeof|sizeof
argument_list|(
name|dirpart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|dirpart
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dirpart
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|strlcat
argument_list|(
name|dirpart
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|dirpart
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* check if archive directory exists, if not, create it */
if|if
condition|(
name|lstat
argument_list|(
name|dirpart
argument_list|,
operator|&
name|st
argument_list|)
condition|)
name|createdir
argument_list|(
name|ent
argument_list|,
name|dirpart
argument_list|)
expr_stmt|;
comment|/* get filename part of logfile */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|log
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|strlcpy
argument_list|(
name|namepart
argument_list|,
name|log
argument_list|,
sizeof|sizeof
argument_list|(
name|namepart
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|namepart
argument_list|,
name|p
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|namepart
argument_list|)
argument_list|)
expr_stmt|;
comment|/* name of oldest log */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s/%s.%d"
argument_list|,
name|dirpart
argument_list|,
name|namepart
argument_list|,
name|numdays
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zfile1
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile1
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|file1
argument_list|,
name|COMPRESS_POSTFIX
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|jfile1
argument_list|,
sizeof|sizeof
argument_list|(
name|jfile1
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|file1
argument_list|,
name|BZCOMPRESS_POSTFIX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* name of oldest log */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s.%d"
argument_list|,
name|log
argument_list|,
name|numdays
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zfile1
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile1
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|file1
argument_list|,
name|COMPRESS_POSTFIX
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|jfile1
argument_list|,
sizeof|sizeof
argument_list|(
name|jfile1
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|file1
argument_list|,
name|BZCOMPRESS_POSTFIX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"\trm -f %s\n"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\trm -f %s\n"
argument_list|,
name|zfile1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\trm -f %s\n"
argument_list|,
name|jfile1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|file1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|zfile1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|jfile1
argument_list|)
expr_stmt|;
block|}
comment|/* Move down log files */
name|_numdays
operator|=
name|numdays
expr_stmt|;
comment|/* preserve */
while|while
condition|(
name|numdays
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|file2
argument_list|,
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archtodir
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s/%s.%d"
argument_list|,
name|dirpart
argument_list|,
name|namepart
argument_list|,
name|numdays
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s.%d"
argument_list|,
name|log
argument_list|,
name|numdays
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zfile1
argument_list|,
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zfile2
argument_list|,
name|file2
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|file1
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|zfile1
argument_list|,
name|COMPRESS_POSTFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|zfile2
argument_list|,
name|COMPRESS_POSTFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|zfile1
argument_list|,
operator|&
name|st
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|zfile1
argument_list|,
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile1
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|zfile2
argument_list|,
name|file2
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile2
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|zfile1
argument_list|,
name|BZCOMPRESS_POSTFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile1
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|zfile2
argument_list|,
name|BZCOMPRESS_POSTFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|zfile1
argument_list|,
operator|&
name|st
argument_list|)
condition|)
continue|continue;
block|}
block|}
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"\tmv %s %s\n"
argument_list|,
name|zfile1
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tchmod %o %s\n"
argument_list|,
name|ent
operator|->
name|permissions
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|uid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|ent
operator|->
name|gid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"\tchown %u:%u %s\n"
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|rename
argument_list|(
name|zfile1
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|zfile2
argument_list|,
name|ent
operator|->
name|permissions
argument_list|)
condition|)
name|warn
argument_list|(
literal|"can't chmod %s"
argument_list|,
name|file2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|uid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|ent
operator|->
name|gid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
if|if
condition|(
name|chown
argument_list|(
name|zfile2
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|)
condition|)
name|warn
argument_list|(
literal|"can't chown %s"
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|noaction
operator|&&
operator|!
operator|(
name|flags
operator|&
name|CE_BINARY
operator|)
condition|)
block|{
comment|/* Report the trimming to the old log */
operator|(
name|void
operator|)
name|log_trim
argument_list|(
name|log
argument_list|,
name|ent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|_numdays
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"\trm %s\n"
argument_list|,
name|log
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"\tmv %s to %s\n"
argument_list|,
name|log
argument_list|,
name|file1
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|archtodir
condition|)
name|movefile
argument_list|(
name|log
argument_list|,
name|file1
argument_list|,
name|ent
operator|->
name|permissions
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|rename
argument_list|(
name|log
argument_list|,
name|file1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now move the new log file into place */
comment|/* XXX - We should replace the above 'rename' with 'link(log, file1)' 	 *	then replace the following with 'createfile(ent)' */
name|strlcpy
argument_list|(
name|tfile
argument_list|,
name|log
argument_list|,
sizeof|sizeof
argument_list|(
name|tfile
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|tfile
argument_list|,
literal|".XXXXXX"
argument_list|,
sizeof|sizeof
argument_list|(
name|tfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"Start new log...\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tmktemp %s\n"
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mkstemp
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
name|fd
operator|=
name|creat
argument_list|(
name|tfile
argument_list|,
name|ent
operator|->
name|permissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't start new log"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|uid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|ent
operator|->
name|gid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
if|if
condition|(
name|fchown
argument_list|(
name|fd
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't chown new log file"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CE_BINARY
operator|)
condition|)
block|{
comment|/* Add status message to new log file */
if|if
condition|(
name|log_trim
argument_list|(
name|tfile
argument_list|,
name|ent
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't add status message to log"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"\tchmod %o %s\n"
argument_list|,
name|ent
operator|->
name|permissions
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tmv %s %s\n"
argument_list|,
name|tfile
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|tfile
argument_list|,
name|ent
operator|->
name|permissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tfile
argument_list|,
name|log
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't start new log"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Find out if there is a process to signal.  If nosignal (-s) was 	 * specified, then do not signal any process.  Note that nosignal 	 * will trigger a warning message if the rotated logfile needs to 	 * be compressed, *unless* -R was specified.  This is because there 	 * presumably still are process(es) writing to the old logfile, but 	 * we assume that a -sR request comes from a process which writes  	 * to the logfile, and as such, that process has already made sure 	 * that the logfile is not presently in use. 	 */
name|need_notification
operator|=
name|notified
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|pid_file
operator|!=
name|NULL
condition|)
block|{
name|need_notification
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|nosignal
condition|)
name|notified
operator|=
name|send_signal
argument_list|(
name|ent
argument_list|)
expr_stmt|;
comment|/* the normal case! */
elseif|else
if|if
condition|(
name|rotatereq
condition|)
name|need_notification
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|CE_COMPACT
operator|)
operator|||
operator|(
name|flags
operator|&
name|CE_BZCOMPACT
operator|)
condition|)
block|{
if|if
condition|(
name|need_notification
operator|&&
operator|!
name|notified
condition|)
name|warnx
argument_list|(
literal|"log %s.0 not compressed because daemon(s) not notified"
argument_list|,
name|log
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|noaction
condition|)
if|if
condition|(
name|flags
operator|&
name|CE_COMPACT
condition|)
name|printf
argument_list|(
literal|"\tgzip %s.0\n"
argument_list|,
name|log
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tbzip2 %s.0\n"
argument_list|,
name|log
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|notified
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"small pause to allow daemon(s) to close log\n"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|archtodir
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|dirpart
argument_list|,
name|namepart
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CE_COMPACT
condition|)
name|compress_log
argument_list|(
name|file1
argument_list|,
name|flags
operator|&
name|CE_COMPACTWAIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|CE_BZCOMPACT
condition|)
name|bzcompress_log
argument_list|(
name|file1
argument_list|,
name|flags
operator|&
name|CE_COMPACTWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|CE_COMPACT
condition|)
name|compress_log
argument_list|(
name|log
argument_list|,
name|flags
operator|&
name|CE_COMPACTWAIT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|CE_BZCOMPACT
condition|)
name|bzcompress_log
argument_list|(
name|log
argument_list|,
name|flags
operator|&
name|CE_COMPACTWAIT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Log the fact that the logs were turned over */
end_comment

begin_function
specifier|static
name|int
name|log_trim
parameter_list|(
specifier|const
name|char
modifier|*
name|log
parameter_list|,
specifier|const
name|struct
name|conf_entry
modifier|*
name|log_ent
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|char
modifier|*
name|xtra
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|log
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|xtra
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|log_ent
operator|->
name|def_cfg
condition|)
name|xtra
operator|=
literal|" using<default> rule"
expr_stmt|;
if|if
condition|(
name|log_ent
operator|->
name|firstcreate
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s %s newsyslog[%d]: logfile first created%s\n"
argument_list|,
name|daytime
argument_list|,
name|hostname
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|xtra
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|log_ent
operator|->
name|r_reason
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s %s newsyslog[%d]: logfile turned over%s%s\n"
argument_list|,
name|daytime
argument_list|,
name|hostname
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|log_ent
operator|->
name|r_reason
argument_list|,
name|xtra
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s %s newsyslog[%d]: logfile turned over%s\n"
argument_list|,
name|daytime
argument_list|,
name|hostname
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|xtra
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"log_trim: fclose:"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fork of gzip to compress the old log file */
end_comment

begin_function
specifier|static
name|void
name|compress_log
parameter_list|(
name|char
modifier|*
name|log
parameter_list|,
name|int
name|dowait
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|char
name|tmp
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
while|while
condition|(
name|dowait
operator|&&
operator|(
name|wait
argument_list|(
name|NULL
argument_list|)
operator|>
literal|0
operator|||
name|errno
operator|==
name|EINTR
operator|)
condition|)
empty_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%s.0"
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"gzip fork"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pid
condition|)
block|{
operator|(
name|void
operator|)
name|execl
argument_list|(
name|_PATH_GZIP
argument_list|,
name|_PATH_GZIP
argument_list|,
literal|"-f"
argument_list|,
name|tmp
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
name|_PATH_GZIP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fork of bzip2 to compress the old log file */
end_comment

begin_function
specifier|static
name|void
name|bzcompress_log
parameter_list|(
name|char
modifier|*
name|log
parameter_list|,
name|int
name|dowait
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|char
name|tmp
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
while|while
condition|(
name|dowait
operator|&&
operator|(
name|wait
argument_list|(
name|NULL
argument_list|)
operator|>
literal|0
operator|||
name|errno
operator|==
name|EINTR
operator|)
condition|)
empty_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"%s.0"
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"bzip2 fork"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pid
condition|)
block|{
name|execl
argument_list|(
name|_PATH_BZIP2
argument_list|,
name|_PATH_BZIP2
argument_list|,
literal|"-f"
argument_list|,
name|tmp
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
name|_PATH_BZIP2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return size in kilobytes of a file */
end_comment

begin_function
specifier|static
name|int
name|sizefile
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|kbytes
argument_list|(
name|dbtob
argument_list|(
name|sb
operator|.
name|st_blocks
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the age of old log file (file.0) */
end_comment

begin_function
specifier|static
name|int
name|age_old_log
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|char
name|tmp
index|[
name|MAXPATHLEN
operator|+
sizeof|sizeof
argument_list|(
literal|".0"
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|COMPRESS_POSTFIX
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|BZCOMPRESS_POSTFIX
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|archtodir
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* build name of archive directory into tmp */
if|if
condition|(
operator|*
name|archdirname
operator|==
literal|'/'
condition|)
block|{
comment|/* absolute */
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* relative */
comment|/* get directory part of logfile */
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|tmp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tmp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|tmp
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get filename part of logfile */
if|if
condition|(
operator|(
name|p
operator|=
name|rindex
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|p
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|tmp
argument_list|,
literal|".0"
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|tmp
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * A plain '.0' file does not exist.  Try again, first 		 * with the added suffix of '.gz', then with an added 		 * suffix of '.bz2' instead of '.gz'. 		 */
name|endp
operator|=
name|strchr
argument_list|(
name|tmp
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|COMPRESS_POSTFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|tmp
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|endp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Remove .gz */
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|BZCOMPRESS_POSTFIX
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|tmp
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|timenow
operator|-
name|sb
operator|.
name|st_mtime
operator|+
literal|1800
argument_list|)
operator|/
literal|3600
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Skip Over Blanks */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|sob
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Skip Over Non-Blanks */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|son
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check if string is actually a number */
end_comment

begin_function
specifier|static
name|int
name|isnumberstr
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
while|while
condition|(
operator|*
name|string
condition|)
block|{
if|if
condition|(
operator|!
name|isdigitch
argument_list|(
operator|*
name|string
operator|++
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* physically move file */
end_comment

begin_function
specifier|static
name|void
name|movefile
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|int
name|perm
parameter_list|,
name|uid_t
name|owner_uid
parameter_list|,
name|gid_t
name|group_gid
parameter_list|)
block|{
name|FILE
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|src
operator|=
name|fopen
argument_list|(
name|from
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fopen %s for reading"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|fopen
argument_list|(
name|to
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fopen %s for writing"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner_uid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|group_gid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|fchown
argument_list|(
name|fileno
argument_list|(
name|dst
argument_list|)
argument_list|,
name|owner_uid
argument_list|,
name|group_gid
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fchown %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fchmod
argument_list|(
name|fileno
argument_list|(
name|dst
argument_list|)
argument_list|,
name|perm
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fchmod %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|putc
argument_list|(
name|c
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error writing to %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|src
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error reading from %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fclose
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fclose %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fclose
argument_list|(
name|dst
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fclose %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unlink
argument_list|(
name|from
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't unlink %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* create one or more directory components of a path */
end_comment

begin_function
specifier|static
name|void
name|createdir
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|,
name|char
modifier|*
name|dirpart
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|char
name|mkdirpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|s
operator|=
name|dirpart
expr_stmt|;
name|d
operator|=
name|mkdirpath
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'/'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
continue|continue;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|res
operator|=
name|lstat
argument_list|(
name|mkdirpath
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"\tmkdir %s\n"
argument_list|,
name|mkdirpath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|mkdir
argument_list|(
name|mkdirpath
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Error on mkdir(\"%s\") for -a"
argument_list|,
name|mkdirpath
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
break|break;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|firstcreate
condition|)
name|printf
argument_list|(
literal|"Created directory '%s' for new %s\n"
argument_list|,
name|dirpart
argument_list|,
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Created directory '%s' for -a\n"
argument_list|,
name|dirpart
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create a new log file, destroying any currently-existing version  * of the log file in the process.  If the caller wants a backup copy  * of the file to exist, they should call 'link(logfile,logbackup)'  * before calling this routine.  */
end_comment

begin_function
name|void
name|createlog
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|failed
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|realfile
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
name|tempfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|realfile
operator|=
name|ent
operator|->
name|log
expr_stmt|;
comment|/* 	 * If this log file is being created for the first time (-C option), 	 * then it may also be true that the parent directory does not exist 	 * yet.  Check, and create that directory if it is missing. 	 */
if|if
condition|(
name|ent
operator|->
name|firstcreate
condition|)
block|{
name|strlcpy
argument_list|(
name|tempfile
argument_list|,
name|realfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tempfile
argument_list|)
argument_list|)
expr_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|tempfile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|failed
operator|=
name|lstat
argument_list|(
name|tempfile
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Error on lstat(%s)"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
name|createdir
argument_list|(
name|ent
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s exists but is not a directory"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * First create an unused filename, so it can be chown'ed and 	 * chmod'ed before it is moved into the real location.  mkstemp 	 * will create the file mode=600& owned by us.  Note that all 	 * temp files will have a suffix of '.z<something>'. 	 */
name|strlcpy
argument_list|(
name|tempfile
argument_list|,
name|realfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tempfile
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|tempfile
argument_list|,
literal|".zXXXXXX"
argument_list|,
sizeof|sizeof
argument_list|(
name|tempfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"\tmktemp %s\n"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
else|else
block|{
name|fd
operator|=
name|mkstemp
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't mkstemp logfile %s"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
comment|/* 		 * Add status message to what will become the new log file. 		 */
if|if
condition|(
operator|!
operator|(
name|ent
operator|->
name|flags
operator|&
name|CE_BINARY
operator|)
condition|)
block|{
if|if
condition|(
name|log_trim
argument_list|(
name|tempfile
argument_list|,
name|ent
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't add status message to log"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Change the owner/group, if we are supposed to */
if|if
condition|(
name|ent
operator|->
name|uid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|ent
operator|->
name|gid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"\tchown %u:%u %s\n"
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
else|else
block|{
name|failed
operator|=
name|fchown
argument_list|(
name|fd
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fchown temp file %s"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Note that if the real logfile still exists, and if the call 	 * to rename() fails, then "neither the old file nor the new 	 * file shall be changed or created" (to quote the standard). 	 * If the call succeeds, then the file will be replaced without 	 * any window where some other process might find that the file 	 * did not exist. 	 * XXX - ? It may be that for some error conditions, we could 	 *	retry by first removing the realfile and then renaming. 	 */
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"\tchmod %o %s\n"
argument_list|,
name|ent
operator|->
name|permissions
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tmv %s %s\n"
argument_list|,
name|tempfile
argument_list|,
name|realfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|failed
operator|=
name|fchmod
argument_list|(
name|fd
argument_list|,
name|ent
operator|->
name|permissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fchmod temp file '%s'"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|failed
operator|=
name|rename
argument_list|(
name|tempfile
argument_list|,
name|realfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't mv %s to %s"
argument_list|,
name|tempfile
argument_list|,
name|realfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Parse a limited subset of ISO 8601. The specific format is as follows:  *  * [CC[YY[MM[DD]]]][THH[MM[SS]]]	(where `T' is the literal letter)  *  * We don't accept a timezone specification; missing fields (including timezone)  * are defaulted to the current date but time zero.  */
end_comment

begin_function
specifier|static
name|time_t
name|parse8601
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|time_t
name|tsecs
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|tmp
operator|=
name|localtime
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|tm
operator|=
operator|*
name|tmp
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
name|tm
operator|.
name|tm_min
operator|=
name|tm
operator|.
name|tm_sec
operator|=
literal|0
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'\0'
operator|&&
operator|*
name|t
operator|!=
literal|'T'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Now t points either to the end of the string (if no time was 	 * provided) or to the letter `T' which separates date and time in 	 * ISO 8601.  The pointer arithmetic is the same for either case. 	 */
switch|switch
condition|(
name|t
operator|-
name|s
condition|)
block|{
case|case
literal|8
case|:
name|tm
operator|.
name|tm_year
operator|=
operator|(
operator|(
name|ul
operator|/
literal|1000000
operator|)
operator|-
literal|19
operator|)
operator|*
literal|100
expr_stmt|;
name|ul
operator|=
name|ul
operator|%
literal|1000000
expr_stmt|;
case|case
literal|6
case|:
name|tm
operator|.
name|tm_year
operator|-=
name|tm
operator|.
name|tm_year
operator|%
literal|100
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|+=
name|ul
operator|/
literal|10000
expr_stmt|;
name|ul
operator|=
name|ul
operator|%
literal|10000
expr_stmt|;
case|case
literal|4
case|:
name|tm
operator|.
name|tm_mon
operator|=
operator|(
name|ul
operator|/
literal|100
operator|)
operator|-
literal|1
expr_stmt|;
name|ul
operator|=
name|ul
operator|%
literal|100
expr_stmt|;
case|case
literal|2
case|:
name|tm
operator|.
name|tm_mday
operator|=
name|ul
expr_stmt|;
case|case
literal|0
case|:
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* sanity check */
if|if
condition|(
name|tm
operator|.
name|tm_year
operator|<
literal|70
operator|||
name|tm
operator|.
name|tm_mon
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_mon
operator|>
literal|12
operator|||
name|tm
operator|.
name|tm_mday
operator|<
literal|1
operator|||
name|tm
operator|.
name|tm_mday
operator|>
literal|31
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'\0'
condition|)
block|{
name|s
operator|=
operator|++
name|t
expr_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|t
operator|-
name|s
condition|)
block|{
case|case
literal|6
case|:
name|tm
operator|.
name|tm_sec
operator|=
name|ul
operator|%
literal|100
expr_stmt|;
name|ul
operator|/=
literal|100
expr_stmt|;
case|case
literal|4
case|:
name|tm
operator|.
name|tm_min
operator|=
name|ul
operator|%
literal|100
expr_stmt|;
name|ul
operator|/=
literal|100
expr_stmt|;
case|case
literal|2
case|:
name|tm
operator|.
name|tm_hour
operator|=
name|ul
expr_stmt|;
case|case
literal|0
case|:
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* sanity check */
if|if
condition|(
name|tm
operator|.
name|tm_sec
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_sec
operator|>
literal|60
operator|||
name|tm
operator|.
name|tm_min
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_min
operator|>
literal|59
operator|||
name|tm
operator|.
name|tm_hour
operator|<
literal|0
operator|||
name|tm
operator|.
name|tm_hour
operator|>
literal|23
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tsecs
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/* 	 * Check for invalid times, including things like the missing 	 * hour when switching from "daylight savings" to "standard". 	 */
if|if
condition|(
name|tsecs
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|tsecs
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|2
expr_stmt|;
return|return
operator|(
name|tsecs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Parse a cyclic time specification, the format is as follows:  *  *	[Dhh] or [Wd[Dhh]] or [Mdd[Dhh]]  *  * to rotate a logfile cyclic at  *  *	- every day (D) within a specific hour (hh)	(hh = 0...23)  *	- once a week (W) at a specific day (d)     OR	(d = 0..6, 0 = Sunday)  *	- once a month (M) at a specific day (d)	(d = 1..31,l|L)  *  * We don't accept a timezone specification; missing fields  * are defaulted to the current date but time zero.  */
end_comment

begin_function
specifier|static
name|time_t
name|parseDWM
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|time_t
name|tsecs
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|long
name|l
decl_stmt|;
name|int
name|nd
decl_stmt|;
specifier|static
name|int
name|mtab
index|[]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
name|int
name|WMseen
init|=
literal|0
decl_stmt|;
name|int
name|Dseen
init|=
literal|0
decl_stmt|;
name|tmp
operator|=
name|localtime
argument_list|(
operator|&
name|timenow
argument_list|)
expr_stmt|;
name|tm
operator|=
operator|*
name|tmp
expr_stmt|;
comment|/* set no. of days per month */
name|nd
operator|=
name|mtab
index|[
name|tm
operator|.
name|tm_mon
index|]
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_mon
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|+
literal|1900
operator|)
operator|%
literal|4
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|+
literal|1900
operator|)
operator|%
literal|100
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tm
operator|.
name|tm_year
operator|+
literal|1900
operator|)
operator|%
literal|400
operator|==
literal|0
operator|)
condition|)
block|{
name|nd
operator|++
expr_stmt|;
comment|/* leap year, 29 days in february */
block|}
block|}
name|tm
operator|.
name|tm_hour
operator|=
name|tm
operator|.
name|tm_min
operator|=
name|tm
operator|.
name|tm_sec
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'D'
case|:
if|if
condition|(
name|Dseen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|Dseen
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|l
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
operator|||
name|l
operator|>
literal|23
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tm
operator|.
name|tm_hour
operator|=
name|l
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
name|WMseen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|WMseen
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|l
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
operator|||
name|l
operator|>
literal|6
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|l
operator|!=
name|tm
operator|.
name|tm_wday
condition|)
block|{
name|int
name|save
decl_stmt|;
if|if
condition|(
name|l
operator|<
name|tm
operator|.
name|tm_wday
condition|)
block|{
name|save
operator|=
literal|6
operator|-
name|tm
operator|.
name|tm_wday
expr_stmt|;
name|save
operator|+=
operator|(
name|l
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|save
operator|=
name|l
operator|-
name|tm
operator|.
name|tm_wday
expr_stmt|;
block|}
name|tm
operator|.
name|tm_mday
operator|+=
name|save
expr_stmt|;
if|if
condition|(
name|tm
operator|.
name|tm_mday
operator|>
name|nd
condition|)
block|{
name|tm
operator|.
name|tm_mon
operator|++
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
name|tm
operator|.
name|tm_mday
operator|-
name|nd
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|WMseen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|WMseen
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
operator|==
literal|'l'
condition|)
block|{
name|tm
operator|.
name|tm_mday
operator|=
name|nd
expr_stmt|;
name|s
operator|++
expr_stmt|;
name|t
operator|=
name|s
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|1
operator|||
name|l
operator|>
literal|31
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|l
operator|>
name|nd
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tm
operator|.
name|tm_mday
operator|=
name|l
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
if|if
condition|(
operator|*
name|t
operator|==
literal|'\0'
operator|||
name|isspace
argument_list|(
operator|*
name|t
argument_list|)
condition|)
break|break;
else|else
name|s
operator|=
name|t
expr_stmt|;
block|}
name|tsecs
operator|=
name|mktime
argument_list|(
operator|&
name|tm
argument_list|)
expr_stmt|;
comment|/* 	 * Check for invalid times, including things like the missing 	 * hour when switching from "daylight savings" to "standard". 	 */
if|if
condition|(
name|tsecs
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|tsecs
operator|=
operator|(
name|time_t
operator|)
operator|-
literal|2
expr_stmt|;
return|return
operator|(
name|tsecs
operator|)
return|;
block|}
end_function

end_unit

