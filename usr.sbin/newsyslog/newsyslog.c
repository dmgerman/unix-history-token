begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * ------+---------+---------+-------- + --------+---------+---------+---------*  * This file includes significant modifications done by:  * Copyright (c) 2003, 2004  - Garance Alistair Drosehn<gad@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * ------+---------+---------+-------- + --------+---------+---------+---------*  */
end_comment

begin_comment
comment|/*  * This file contains changes from the Open Software Foundation.  */
end_comment

begin_comment
comment|/*  * Copyright 1988, 1989 by the Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and its  * documentation for any purpose and without fee is hereby granted, provided  * that the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the names of M.I.T. and the M.I.T. S.I.P.B. not be  * used in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission. M.I.T. and the M.I.T.  * S.I.P.B. make no representations about the suitability of this software  * for any purpose.  It is provided "as is" without express or implied  * warranty.  *  */
end_comment

begin_comment
comment|/*  * newsyslog - roll over selected logs at the appropriate time, keeping the a  * specified number of backup files around.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|OSF
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<glob.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * Compression suffixes  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|COMPRESS_SUFFIX_GZ
end_ifndef

begin_define
define|#
directive|define
name|COMPRESS_SUFFIX_GZ
value|".gz"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COMPRESS_SUFFIX_BZ2
end_ifndef

begin_define
define|#
directive|define
name|COMPRESS_SUFFIX_BZ2
value|".bz2"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|COMPRESS_SUFFIX_XZ
end_ifndef

begin_define
define|#
directive|define
name|COMPRESS_SUFFIX_XZ
value|".xz"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|COMPRESS_SUFFIX_MAXLEN
value|MAX(MAX(sizeof(COMPRESS_SUFFIX_GZ),sizeof(COMPRESS_SUFFIX_BZ2)),sizeof(COMPRESS_SUFFIX_XZ))
end_define

begin_comment
comment|/*  * Compression types  */
end_comment

begin_define
define|#
directive|define
name|COMPRESS_TYPES
value|4
end_define

begin_comment
comment|/* Number of supported compression types */
end_comment

begin_define
define|#
directive|define
name|COMPRESS_NONE
value|0
end_define

begin_define
define|#
directive|define
name|COMPRESS_GZIP
value|1
end_define

begin_define
define|#
directive|define
name|COMPRESS_BZIP2
value|2
end_define

begin_define
define|#
directive|define
name|COMPRESS_XZ
value|3
end_define

begin_comment
comment|/*  * Bit-values for the 'flags' parsed from a config-file entry.  */
end_comment

begin_define
define|#
directive|define
name|CE_BINARY
value|0x0008
end_define

begin_comment
comment|/* Logfile is in binary, do not add status */
end_comment

begin_comment
comment|/*    messages to logfile(s) when rotating. */
end_comment

begin_define
define|#
directive|define
name|CE_NOSIGNAL
value|0x0010
end_define

begin_comment
comment|/* There is no process to signal when */
end_comment

begin_comment
comment|/*    trimming this file. */
end_comment

begin_define
define|#
directive|define
name|CE_TRIMAT
value|0x0020
end_define

begin_comment
comment|/* trim file at a specific time. */
end_comment

begin_define
define|#
directive|define
name|CE_GLOB
value|0x0040
end_define

begin_comment
comment|/* name of the log is file name pattern. */
end_comment

begin_define
define|#
directive|define
name|CE_SIGNALGROUP
value|0x0080
end_define

begin_comment
comment|/* Signal a process-group instead of a single */
end_comment

begin_comment
comment|/*    process when trimming this file. */
end_comment

begin_define
define|#
directive|define
name|CE_CREATE
value|0x0100
end_define

begin_comment
comment|/* Create the log file if it does not exist. */
end_comment

begin_define
define|#
directive|define
name|CE_NODUMP
value|0x0200
end_define

begin_comment
comment|/* Set 'nodump' on newly created log file. */
end_comment

begin_define
define|#
directive|define
name|CE_PID2CMD
value|0x0400
end_define

begin_comment
comment|/* Replace PID file with a shell command.*/
end_comment

begin_define
define|#
directive|define
name|CE_RFC5424
value|0x0800
end_define

begin_comment
comment|/* Use RFC5424 format rotation message */
end_comment

begin_define
define|#
directive|define
name|MIN_PID
value|5
end_define

begin_comment
comment|/* Don't touch pids lower than this */
end_comment

begin_define
define|#
directive|define
name|MAX_PID
value|99999
end_define

begin_comment
comment|/* was lower, see /usr/include/sys/proc.h */
end_comment

begin_define
define|#
directive|define
name|kbytes
parameter_list|(
name|size
parameter_list|)
value|(((size) + 1023)>> 10)
end_define

begin_define
define|#
directive|define
name|DEFAULT_MARKER
value|"<default>"
end_define

begin_define
define|#
directive|define
name|DEBUG_MARKER
value|"<debug>"
end_define

begin_define
define|#
directive|define
name|INCLUDE_MARKER
value|"<include>"
end_define

begin_define
define|#
directive|define
name|DEFAULT_TIMEFNAME_FMT
value|"%Y%m%dT%H%M%S"
end_define

begin_define
define|#
directive|define
name|MAX_OLDLOGS
value|65536
end_define

begin_comment
comment|/* Default maximum number of old logfiles */
end_comment

begin_struct
struct|struct
name|compress_types
block|{
specifier|const
name|char
modifier|*
name|flag
decl_stmt|;
comment|/* Flag in configuration file */
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
comment|/* Compression suffix */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Path to compression program */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|compress_types
name|compress_type
index|[
name|COMPRESS_TYPES
index|]
init|=
block|{
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* no compression */
block|{
literal|"Z"
block|,
name|COMPRESS_SUFFIX_GZ
block|,
name|_PATH_GZIP
block|}
block|,
comment|/* gzip compression */
block|{
literal|"J"
block|,
name|COMPRESS_SUFFIX_BZ2
block|,
name|_PATH_BZIP2
block|}
block|,
comment|/* bzip2 compression */
block|{
literal|"X"
block|,
name|COMPRESS_SUFFIX_XZ
block|,
name|_PATH_XZ
block|}
comment|/* xz compression */
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|conf_entry
block|{
name|STAILQ_ENTRY
argument_list|(
argument|conf_entry
argument_list|)
name|cf_nextp
expr_stmt|;
name|char
modifier|*
name|log
decl_stmt|;
comment|/* Name of the log */
name|char
modifier|*
name|pid_cmd_file
decl_stmt|;
comment|/* PID or command file */
name|char
modifier|*
name|r_reason
decl_stmt|;
comment|/* The reason this file is being rotated */
name|int
name|firstcreate
decl_stmt|;
comment|/* Creating log for the first time (-C). */
name|int
name|rotate
decl_stmt|;
comment|/* Non-zero if this file should be rotated */
name|int
name|fsize
decl_stmt|;
comment|/* size found for the log file */
name|uid_t
name|uid
decl_stmt|;
comment|/* Owner of log */
name|gid_t
name|gid
decl_stmt|;
comment|/* Group of log */
name|int
name|numlogs
decl_stmt|;
comment|/* Number of logs to keep */
name|int
name|trsize
decl_stmt|;
comment|/* Size cutoff to trigger trimming the log */
name|int
name|hours
decl_stmt|;
comment|/* Hours between log trimming */
name|struct
name|ptime_data
modifier|*
name|trim_at
decl_stmt|;
comment|/* Specific time to do trimming */
name|unsigned
name|int
name|permissions
decl_stmt|;
comment|/* File permissions on the log */
name|int
name|flags
decl_stmt|;
comment|/* CE_BINARY */
name|int
name|compress
decl_stmt|;
comment|/* Compression */
name|int
name|sig
decl_stmt|;
comment|/* Signal to send */
name|int
name|def_cfg
decl_stmt|;
comment|/* Using the<default> rule for this file */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sigwork_entry
block|{
name|SLIST_ENTRY
argument_list|(
argument|sigwork_entry
argument_list|)
name|sw_nextp
expr_stmt|;
name|int
name|sw_signum
decl_stmt|;
comment|/* the signal to send */
name|int
name|sw_pidok
decl_stmt|;
comment|/* true if pid value is valid */
name|pid_t
name|sw_pid
decl_stmt|;
comment|/* the process id from the PID file */
specifier|const
name|char
modifier|*
name|sw_pidtype
decl_stmt|;
comment|/* "daemon" or "process group" */
name|int
name|sw_runcmd
decl_stmt|;
comment|/* run command or send PID to signal */
name|char
name|sw_fname
index|[
literal|1
index|]
decl_stmt|;
comment|/* file the PID was read from or shell cmd */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|zipwork_entry
block|{
name|SLIST_ENTRY
argument_list|(
argument|zipwork_entry
argument_list|)
name|zw_nextp
expr_stmt|;
specifier|const
name|struct
name|conf_entry
modifier|*
name|zw_conf
decl_stmt|;
comment|/* for chown/perm/flag info */
specifier|const
name|struct
name|sigwork_entry
modifier|*
name|zw_swork
decl_stmt|;
comment|/* to know success of signal */
name|int
name|zw_fsize
decl_stmt|;
comment|/* size of the file to compress */
name|char
name|zw_fname
index|[
literal|1
index|]
decl_stmt|;
comment|/* the file to compress */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|include_entry
block|{
name|STAILQ_ENTRY
argument_list|(
argument|include_entry
argument_list|)
name|inc_nextp
expr_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
comment|/* Name of file to process */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|oldlog_entry
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Filename of the log file */
name|time_t
name|t
decl_stmt|;
comment|/* Parsed timestamp of the logfile */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|FREE_ENT
block|,
name|KEEP_ENT
block|}
name|fk_entry
typedef|;
end_typedef

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|cflist
argument_list|,
name|conf_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument|swlisthead
argument_list|,
argument|sigwork_entry
argument_list|)
name|swhead
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|swhead
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument|zwlisthead
argument_list|,
argument|zipwork_entry
argument_list|)
name|zwhead
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|zwhead
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|ilist
argument_list|,
name|include_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|dbg_at_times
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -D Show details of 'trim_at' code */
end_comment

begin_decl_stmt
specifier|static
name|int
name|archtodir
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Archive old logfiles to other directory */
end_comment

begin_decl_stmt
specifier|static
name|int
name|createlogs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create (non-GLOB) logfiles which do not */
end_comment

begin_comment
comment|/*    already exist.  1=='for entries with */
end_comment

begin_comment
comment|/*    C flag', 2=='for all entries'. */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print out what's going on */
end_comment

begin_decl_stmt
specifier|static
name|int
name|needroot
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Root privs are necessary */
end_comment

begin_decl_stmt
name|int
name|noaction
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't do anything, just show it */
end_comment

begin_decl_stmt
specifier|static
name|int
name|norotate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Don't rotate */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nosignal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do not send any signals */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enforcepid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If PID file does not exist or empty, do nothing */
end_comment

begin_decl_stmt
specifier|static
name|int
name|force
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Force the trim no matter what */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rotatereq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -R = Always rotate the file(s) as given */
end_comment

begin_comment
comment|/*    on the command (this also requires   */
end_comment

begin_comment
comment|/*    that a list of files *are* given on  */
end_comment

begin_comment
comment|/*    the run command). */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|requestor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name given on a -R request */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|timefnamefmt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use time based filenames instead of .0 */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|archdirname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory path to old logfiles archive */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|destdir
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Directory to treat at root for logs */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|conf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Configuration file to use */
end_comment

begin_decl_stmt
name|struct
name|ptime_data
modifier|*
name|dbg_timenow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A "timenow" value set via -D option */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ptime_data
modifier|*
name|timenow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The time to use for checking at-fields */
end_comment

begin_define
define|#
directive|define
name|DAYTIME_LEN
value|16
end_define

begin_decl_stmt
specifier|static
name|char
name|daytime
index|[
name|DAYTIME_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The current time in human readable form, 				  * used for rotation-tracking messages. */
end_comment

begin_comment
comment|/* Another buffer to hold the current time in RFC5424 format. Fractional  * seconds are allowed by the RFC, but are not included in the  * rotation-tracking messages written by newsyslog and so are not accounted for  * in the length below.  */
end_comment

begin_define
define|#
directive|define
name|DAYTIME_RFC5424_LEN
value|sizeof("YYYY-MM-DDTHH:MM:SS+00:00")
end_define

begin_decl_stmt
specifier|static
name|char
name|daytime_rfc5424
index|[
name|DAYTIME_RFC5424_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|hostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hostname */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|path_syslogpid
init|=
name|_PATH_SYSLOGPID
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|cflist
modifier|*
name|get_worklist
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_file
parameter_list|(
name|FILE
modifier|*
name|cf
parameter_list|,
name|struct
name|cflist
modifier|*
name|work_p
parameter_list|,
name|struct
name|cflist
modifier|*
name|glob_p
parameter_list|,
name|struct
name|conf_entry
modifier|*
name|defconf_p
parameter_list|,
name|struct
name|ilist
modifier|*
name|inclist
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_to_queue
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|struct
name|ilist
modifier|*
name|inclist
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|sob
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|son
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isnumberstr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isglobstr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|missing_field
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errline
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|change_attrs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|conf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|get_logfile_suffix
parameter_list|(
specifier|const
name|char
modifier|*
name|logfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|fk_entry
name|do_entry
parameter_list|(
name|struct
name|conf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|fk_entry
name|do_rotate
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_sigwork
parameter_list|(
name|struct
name|sigwork_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_zipwork
parameter_list|(
name|struct
name|zipwork_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|sigwork_entry
modifier|*
name|save_sigwork
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|zipwork_entry
modifier|*
name|save_zipwork
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
parameter_list|,
specifier|const
name|struct
name|sigwork_entry
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_swpid
parameter_list|(
name|struct
name|sigwork_entry
modifier|*
parameter_list|,
specifier|const
name|struct
name|conf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sizefile
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expand_globs
parameter_list|(
name|struct
name|cflist
modifier|*
name|work_p
parameter_list|,
name|struct
name|cflist
modifier|*
name|glob_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_clist
parameter_list|(
name|struct
name|cflist
modifier|*
name|list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_entry
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|conf_entry
modifier|*
name|init_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|struct
name|conf_entry
modifier|*
name|src_entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_doption
parameter_list|(
specifier|const
name|char
modifier|*
name|doption
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|log_trim
parameter_list|(
specifier|const
name|char
modifier|*
name|logname
parameter_list|,
specifier|const
name|struct
name|conf_entry
modifier|*
name|log_ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|age_old_log
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|savelog
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|createdir
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|,
name|char
modifier|*
name|dirpart
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|createlog
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_signal
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * All the following take a parameter of 'int', but expect values in the  * range of unsigned char.  Define wrappers which take values of type 'char',  * whether signed or unsigned, and ensure they end up in the right range.  */
end_comment

begin_define
define|#
directive|define
name|isdigitch
parameter_list|(
name|Anychar
parameter_list|)
value|isdigit((u_char)(Anychar))
end_define

begin_define
define|#
directive|define
name|isprintch
parameter_list|(
name|Anychar
parameter_list|)
value|isprint((u_char)(Anychar))
end_define

begin_define
define|#
directive|define
name|isspacech
parameter_list|(
name|Anychar
parameter_list|)
value|isspace((u_char)(Anychar))
end_define

begin_define
define|#
directive|define
name|tolowerch
parameter_list|(
name|Anychar
parameter_list|)
value|tolower((u_char)(Anychar))
end_define

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|cflist
modifier|*
name|worklist
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|p
decl_stmt|;
name|struct
name|sigwork_entry
modifier|*
name|stmp
decl_stmt|;
name|struct
name|zipwork_entry
modifier|*
name|ztmp
decl_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|swhead
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|zwhead
argument_list|)
expr_stmt|;
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|needroot
operator|&&
name|getuid
argument_list|()
operator|&&
name|geteuid
argument_list|()
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"must have root privs"
argument_list|)
expr_stmt|;
name|worklist
operator|=
name|get_worklist
argument_list|(
name|argv
argument_list|)
expr_stmt|;
comment|/* 	 * Rotate all the files which need to be rotated.  Note that 	 * some users have *hundreds* of entries in newsyslog.conf! 	 */
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
name|worklist
argument_list|)
condition|)
block|{
name|p
operator|=
name|STAILQ_FIRST
argument_list|(
name|worklist
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
name|worklist
argument_list|,
name|cf_nextp
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_entry
argument_list|(
name|p
argument_list|)
operator|==
name|FREE_ENT
condition|)
name|free_entry
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Send signals to any processes which need a signal to tell 	 * them to close and re-open the log file(s) we have rotated. 	 * Note that zipwork_entries include pointers to these 	 * sigwork_entry's, so we can not free the entries here. 	 */
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|swhead
argument_list|)
condition|)
block|{
if|if
condition|(
name|noaction
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"Signal all daemon process(es)...\n"
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|stmp
argument_list|,
argument|&swhead
argument_list|,
argument|sw_nextp
argument_list|)
name|do_sigwork
argument_list|(
name|stmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rotatereq
operator|&&
name|nosignal
operator|)
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"\tsleep 10\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Pause 10 seconds to allow "
literal|"daemon(s) to close log file(s)\n"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Compress all files that we're expected to compress, now 	 * that all processes should have closed the files which 	 * have been rotated. 	 */
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|zwhead
argument_list|)
condition|)
block|{
if|if
condition|(
name|noaction
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"Compress all rotated log file(s)...\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|zwhead
argument_list|)
condition|)
block|{
name|ztmp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|zwhead
argument_list|)
expr_stmt|;
name|do_zipwork
argument_list|(
name|ztmp
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|zwhead
argument_list|,
name|zw_nextp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ztmp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now free all the sigwork entries. */
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|swhead
argument_list|)
condition|)
block|{
name|stmp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|swhead
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|swhead
argument_list|,
name|sw_nextp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stmp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|wait
argument_list|(
name|NULL
argument_list|)
operator|>
literal|0
operator|||
name|errno
operator|==
name|EINTR
condition|)
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|conf_entry
modifier|*
name|init_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|struct
name|conf_entry
modifier|*
name|src_entry
parameter_list|)
block|{
name|struct
name|conf_entry
modifier|*
name|tempwork
decl_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"\t--> [creating entry for %s]\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|tempwork
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|conf_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempwork
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc of conf_entry for %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|destdir
operator|==
name|NULL
operator|||
name|fname
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|tempwork
operator|->
name|log
operator|=
name|strdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
else|else
name|asprintf
argument_list|(
operator|&
name|tempwork
operator|->
name|log
argument_list|,
literal|"%s%s"
argument_list|,
name|destdir
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tempwork
operator|->
name|log
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"strdup for %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_entry
operator|!=
name|NULL
condition|)
block|{
name|tempwork
operator|->
name|pid_cmd_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|src_entry
operator|->
name|pid_cmd_file
condition|)
name|tempwork
operator|->
name|pid_cmd_file
operator|=
name|strdup
argument_list|(
name|src_entry
operator|->
name|pid_cmd_file
argument_list|)
expr_stmt|;
name|tempwork
operator|->
name|r_reason
operator|=
name|NULL
expr_stmt|;
name|tempwork
operator|->
name|firstcreate
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|rotate
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|fsize
operator|=
operator|-
literal|1
expr_stmt|;
name|tempwork
operator|->
name|uid
operator|=
name|src_entry
operator|->
name|uid
expr_stmt|;
name|tempwork
operator|->
name|gid
operator|=
name|src_entry
operator|->
name|gid
expr_stmt|;
name|tempwork
operator|->
name|numlogs
operator|=
name|src_entry
operator|->
name|numlogs
expr_stmt|;
name|tempwork
operator|->
name|trsize
operator|=
name|src_entry
operator|->
name|trsize
expr_stmt|;
name|tempwork
operator|->
name|hours
operator|=
name|src_entry
operator|->
name|hours
expr_stmt|;
name|tempwork
operator|->
name|trim_at
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|src_entry
operator|->
name|trim_at
operator|!=
name|NULL
condition|)
name|tempwork
operator|->
name|trim_at
operator|=
name|ptime_init
argument_list|(
name|src_entry
operator|->
name|trim_at
argument_list|)
expr_stmt|;
name|tempwork
operator|->
name|permissions
operator|=
name|src_entry
operator|->
name|permissions
expr_stmt|;
name|tempwork
operator|->
name|flags
operator|=
name|src_entry
operator|->
name|flags
expr_stmt|;
name|tempwork
operator|->
name|compress
operator|=
name|src_entry
operator|->
name|compress
expr_stmt|;
name|tempwork
operator|->
name|sig
operator|=
name|src_entry
operator|->
name|sig
expr_stmt|;
name|tempwork
operator|->
name|def_cfg
operator|=
name|src_entry
operator|->
name|def_cfg
expr_stmt|;
block|}
else|else
block|{
comment|/* Initialize as a "do-nothing" entry */
name|tempwork
operator|->
name|pid_cmd_file
operator|=
name|NULL
expr_stmt|;
name|tempwork
operator|->
name|r_reason
operator|=
name|NULL
expr_stmt|;
name|tempwork
operator|->
name|firstcreate
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|rotate
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|fsize
operator|=
operator|-
literal|1
expr_stmt|;
name|tempwork
operator|->
name|uid
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tempwork
operator|->
name|gid
operator|=
operator|(
name|gid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|tempwork
operator|->
name|numlogs
operator|=
literal|1
expr_stmt|;
name|tempwork
operator|->
name|trsize
operator|=
operator|-
literal|1
expr_stmt|;
name|tempwork
operator|->
name|hours
operator|=
operator|-
literal|1
expr_stmt|;
name|tempwork
operator|->
name|trim_at
operator|=
name|NULL
expr_stmt|;
name|tempwork
operator|->
name|permissions
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|tempwork
operator|->
name|compress
operator|=
name|COMPRESS_NONE
expr_stmt|;
name|tempwork
operator|->
name|sig
operator|=
name|SIGHUP
expr_stmt|;
name|tempwork
operator|->
name|def_cfg
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|tempwork
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_entry
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
if|if
condition|(
name|ent
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ent
operator|->
name|log
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"\t--> [freeing entry for %s]\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
name|ent
operator|->
name|log
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|pid_cmd_file
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ent
operator|->
name|pid_cmd_file
argument_list|)
expr_stmt|;
name|ent
operator|->
name|pid_cmd_file
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|r_reason
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ent
operator|->
name|r_reason
argument_list|)
expr_stmt|;
name|ent
operator|->
name|r_reason
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|trim_at
operator|!=
name|NULL
condition|)
block|{
name|ptime_free
argument_list|(
name|ent
operator|->
name|trim_at
argument_list|)
expr_stmt|;
name|ent
operator|->
name|trim_at
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_clist
parameter_list|(
name|struct
name|cflist
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|conf_entry
modifier|*
name|ent
decl_stmt|;
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|ent
operator|=
name|STAILQ_FIRST
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
name|list
argument_list|,
name|cf_nextp
argument_list|)
expr_stmt|;
name|free_entry
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|fk_entry
name|do_entry
parameter_list|(
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
define|#
directive|define
name|REASON_MAX
value|80
name|int
name|modtime
decl_stmt|;
name|fk_entry
name|free_or_keep
decl_stmt|;
name|double
name|diffsecs
decl_stmt|;
name|char
name|temp_reason
index|[
name|REASON_MAX
index|]
decl_stmt|;
name|int
name|oversized
decl_stmt|;
name|free_or_keep
operator|=
name|FREE_ENT
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"%s<%d%s>: "
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|,
name|compress_type
index|[
name|ent
operator|->
name|compress
index|]
operator|.
name|flag
argument_list|)
expr_stmt|;
name|ent
operator|->
name|fsize
operator|=
name|sizefile
argument_list|(
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
name|oversized
operator|=
operator|(
operator|(
name|ent
operator|->
name|trsize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ent
operator|->
name|fsize
operator|>=
name|ent
operator|->
name|trsize
operator|)
operator|)
expr_stmt|;
name|modtime
operator|=
name|age_old_log
argument_list|(
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
name|ent
operator|->
name|rotate
operator|=
literal|0
expr_stmt|;
name|ent
operator|->
name|firstcreate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|fsize
operator|<
literal|0
condition|)
block|{
comment|/* 		 * If either the C flag or the -C option was specified, 		 * and if we won't be creating the file, then have the 		 * verbose message include a hint as to why the file 		 * will not be created. 		 */
name|temp_reason
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|createlogs
operator|>
literal|1
condition|)
name|ent
operator|->
name|firstcreate
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ent
operator|->
name|flags
operator|&
name|CE_CREATE
operator|)
operator|&&
name|createlogs
condition|)
name|ent
operator|->
name|firstcreate
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_CREATE
condition|)
name|strlcpy
argument_list|(
name|temp_reason
argument_list|,
literal|" (no -C option)"
argument_list|,
name|REASON_MAX
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|createlogs
condition|)
name|strlcpy
argument_list|(
name|temp_reason
argument_list|,
literal|" (no C flag)"
argument_list|,
name|REASON_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|firstcreate
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"does not exist -> will create.\n"
argument_list|)
expr_stmt|;
name|createlog
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"does not exist, skipped%s.\n"
argument_list|,
name|temp_reason
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_TRIMAT
operator|&&
operator|!
name|force
operator|&&
operator|!
name|rotatereq
operator|&&
operator|!
name|oversized
condition|)
block|{
name|diffsecs
operator|=
name|ptimeget_diff
argument_list|(
name|timenow
argument_list|,
name|ent
operator|->
name|trim_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|diffsecs
operator|<
literal|0.0
condition|)
block|{
comment|/* trim_at is some time in the future. */
if|if
condition|(
name|verbose
condition|)
block|{
name|ptime_adjust4dst
argument_list|(
name|ent
operator|->
name|trim_at
argument_list|,
name|timenow
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--> will trim at %s"
argument_list|,
name|ptimeget_ctime
argument_list|(
name|ent
operator|->
name|trim_at
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|free_or_keep
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|diffsecs
operator|>=
literal|3600.0
condition|)
block|{
comment|/* 				 * trim_at is more than an hour in the past, 				 * so find the next valid trim_at time, and 				 * tell the user what that will be. 				 */
if|if
condition|(
name|verbose
operator|&&
name|dbg_at_times
condition|)
name|printf
argument_list|(
literal|"\n\t--> prev trim at %s\t"
argument_list|,
name|ptimeget_ctime
argument_list|(
name|ent
operator|->
name|trim_at
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|ptimeset_nxtime
argument_list|(
name|ent
operator|->
name|trim_at
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"--> will trim at %s"
argument_list|,
name|ptimeget_ctime
argument_list|(
name|ent
operator|->
name|trim_at
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|free_or_keep
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|verbose
operator|&&
name|noaction
operator|&&
name|dbg_at_times
condition|)
block|{
comment|/* 				 * If we are just debugging at-times, then 				 * a detailed message is helpful.  Also 				 * skip "doing" any commands, since they 				 * would all be turned off by no-action. 				 */
name|printf
argument_list|(
literal|"\n\t--> timematch at %s"
argument_list|,
name|ptimeget_ctime
argument_list|(
name|ent
operator|->
name|trim_at
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|free_or_keep
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|verbose
operator|&&
name|ent
operator|->
name|hours
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"--> time is up\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
operator|&&
operator|(
name|ent
operator|->
name|trsize
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"size (Kb): %d [%d] "
argument_list|,
name|ent
operator|->
name|fsize
argument_list|,
name|ent
operator|->
name|trsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
operator|(
name|ent
operator|->
name|hours
operator|>
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|" age (hr): %d [%d] "
argument_list|,
name|modtime
argument_list|,
name|ent
operator|->
name|hours
argument_list|)
expr_stmt|;
comment|/* 		 * Figure out if this logfile needs to be rotated. 		 */
name|temp_reason
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|rotatereq
condition|)
block|{
name|ent
operator|->
name|rotate
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|temp_reason
argument_list|,
name|REASON_MAX
argument_list|,
literal|" due to -R from %s"
argument_list|,
name|requestor
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|force
condition|)
block|{
name|ent
operator|->
name|rotate
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|temp_reason
argument_list|,
name|REASON_MAX
argument_list|,
literal|" due to -F request"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oversized
condition|)
block|{
name|ent
operator|->
name|rotate
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|temp_reason
argument_list|,
name|REASON_MAX
argument_list|,
literal|" due to size>%dK"
argument_list|,
name|ent
operator|->
name|trsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ent
operator|->
name|hours
operator|<=
literal|0
operator|&&
operator|(
name|ent
operator|->
name|flags
operator|&
name|CE_TRIMAT
operator|)
condition|)
block|{
name|ent
operator|->
name|rotate
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ent
operator|->
name|hours
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|modtime
operator|>=
name|ent
operator|->
name|hours
operator|)
operator|||
operator|(
name|modtime
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|ent
operator|->
name|rotate
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * If the file needs to be rotated, then rotate it. 		 */
if|if
condition|(
name|ent
operator|->
name|rotate
operator|&&
operator|!
name|norotate
condition|)
block|{
if|if
condition|(
name|temp_reason
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|ent
operator|->
name|r_reason
operator|=
name|strdup
argument_list|(
name|temp_reason
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"--> trimming log....\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noaction
operator|&&
operator|!
name|verbose
condition|)
name|printf
argument_list|(
literal|"%s<%d%s>: trimming\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|,
name|compress_type
index|[
name|ent
operator|->
name|compress
index|]
operator|.
name|flag
argument_list|)
expr_stmt|;
name|free_or_keep
operator|=
name|do_rotate
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"--> skipping\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|free_or_keep
operator|)
return|;
undef|#
directive|undef
name|REASON_MAX
block|}
end_function

begin_function
specifier|static
name|void
name|parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|timenow
operator|=
name|ptime_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ptimeset_time
argument_list|(
name|timenow
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|daytime
argument_list|,
name|ptimeget_ctime
argument_list|(
name|timenow
argument_list|)
operator|+
literal|4
argument_list|,
name|DAYTIME_LEN
argument_list|)
expr_stmt|;
name|ptimeget_ctime_rfc5424
argument_list|(
name|timenow
argument_list|,
name|daytime_rfc5424
argument_list|,
name|DAYTIME_RFC5424_LEN
argument_list|)
expr_stmt|;
comment|/* Let's get our hostname */
operator|(
name|void
operator|)
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Truncate domain */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Parse command line options. */
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"a:d:f:nrst:vCD:FNPR:S:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|archtodir
operator|++
expr_stmt|;
name|archdirname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|destdir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|conf
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|noaction
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'r'
case|:
name|needroot
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|nosignal
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|optarg
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|optarg
argument_list|,
literal|"DEFAULT"
argument_list|)
operator|==
literal|0
condition|)
name|timefnamefmt
operator|=
name|strdup
argument_list|(
name|DEFAULT_TIMEFNAME_FMT
argument_list|)
expr_stmt|;
else|else
name|timefnamefmt
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* Useful for things like rc.diskless... */
name|createlogs
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* 			 * Set some debugging option.  The specific option 			 * depends on the value of optarg.  These options 			 * may come and go without notice or documentation. 			 */
if|if
condition|(
name|parse_doption
argument_list|(
name|optarg
argument_list|)
condition|)
break|break;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|'F'
case|:
name|force
operator|++
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|norotate
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|enforcepid
operator|++
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|rotatereq
operator|++
expr_stmt|;
name|requestor
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|path_syslogpid
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* Used by OpenBSD for "monitor mode" */
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|force
operator|&&
name|norotate
condition|)
block|{
name|warnx
argument_list|(
literal|"Only one of -F and -N may be specified."
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|rotatereq
condition|)
block|{
if|if
condition|(
name|optind
operator|==
name|argc
condition|)
block|{
name|warnx
argument_list|(
literal|"At least one filename must be given when -R is specified."
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* Make sure "requestor" value is safe for a syslog message. */
for|for
control|(
name|p
operator|=
name|requestor
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isprintch
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|'\t'
operator|)
condition|)
operator|*
name|p
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dbg_timenow
condition|)
block|{
comment|/* 		 * Note that the 'daytime' variable is not changed. 		 * That is only used in messages that track when a 		 * logfile is rotated, and if a file *is* rotated, 		 * then it will still rotated at the "real now" time. 		 */
name|ptime_free
argument_list|(
name|timenow
argument_list|)
expr_stmt|;
name|timenow
operator|=
name|dbg_timenow
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Debug: Running as if TimeNow is %s"
argument_list|,
name|ptimeget_ctime
argument_list|(
name|dbg_timenow
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * These debugging options are mainly meant for developer use, such  * as writing regression-tests.  They would not be needed by users  * during normal operation of newsyslog...  */
end_comment

begin_function
specifier|static
name|int
name|parse_doption
parameter_list|(
specifier|const
name|char
modifier|*
name|doption
parameter_list|)
block|{
specifier|const
name|char
name|TN
index|[]
init|=
literal|"TN="
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|doption
argument_list|,
name|TN
argument_list|,
sizeof|sizeof
argument_list|(
name|TN
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The "TimeNow" debugging option.  This might be off 		 * by an hour when crossing a timezone change. 		 */
name|dbg_timenow
operator|=
name|ptime_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|res
operator|=
name|ptime_relparse
argument_list|(
name|dbg_timenow
argument_list|,
name|PTM_PARSE_ISO8601
argument_list|,
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|,
name|doption
operator|+
sizeof|sizeof
argument_list|(
name|TN
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"Non-existent time specified on -D %s"
argument_list|,
name|doption
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failure */
block|}
elseif|else
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Malformed time given on -D %s"
argument_list|,
name|doption
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failure */
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* successfully parsed */
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|doption
argument_list|,
literal|"ats"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dbg_at_times
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* successfully parsed */
block|}
comment|/* XXX - This check could probably be dropped. */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|doption
argument_list|,
literal|"neworder"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|doption
argument_list|,
literal|"oldorder"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"NOTE: newsyslog always uses 'neworder'."
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* successfully parsed */
block|}
name|warnx
argument_list|(
literal|"Unknown -D (debug) option: '%s'"
argument_list|,
name|doption
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failure */
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: newsyslog [-CFNPnrsv] [-a directory] [-d directory] [-f config_file]\n"
literal|"                 [-S pidfile] [-t timefmt] [[-R tagname] file ...]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse a configuration file and return a linked list of all the logs  * which should be processed.  */
end_comment

begin_function
specifier|static
name|struct
name|cflist
modifier|*
name|get_worklist
parameter_list|(
name|char
modifier|*
modifier|*
name|files
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
modifier|*
name|given
decl_stmt|;
name|struct
name|cflist
modifier|*
name|cmdlist
decl_stmt|,
modifier|*
name|filelist
decl_stmt|,
modifier|*
name|globlist
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|defconf
decl_stmt|,
modifier|*
name|dupent
decl_stmt|,
modifier|*
name|ent
decl_stmt|;
name|struct
name|ilist
name|inclist
decl_stmt|;
name|struct
name|include_entry
modifier|*
name|inc
decl_stmt|;
name|int
name|gmatch
decl_stmt|,
name|fnres
decl_stmt|;
name|defconf
operator|=
name|NULL
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|inclist
argument_list|)
expr_stmt|;
name|filelist
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cflist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|filelist
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc of filelist"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|filelist
argument_list|)
expr_stmt|;
name|globlist
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cflist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|globlist
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc of globlist"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|globlist
argument_list|)
expr_stmt|;
name|inc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|include_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc of inc"
argument_list|)
expr_stmt|;
name|inc
operator|->
name|file
operator|=
name|conf
expr_stmt|;
if|if
condition|(
name|inc
operator|->
name|file
operator|==
name|NULL
condition|)
name|inc
operator|->
name|file
operator|=
name|_PATH_CONF
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|inclist
argument_list|,
name|inc
argument_list|,
name|inc_nextp
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|inc
argument_list|,
argument|&inclist
argument_list|,
argument|inc_nextp
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|inc
operator|->
name|file
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
name|f
operator|=
name|fopen
argument_list|(
name|inc
operator|->
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
block|{
name|f
operator|=
name|stdin
expr_stmt|;
name|inc
operator|->
name|file
operator|=
literal|"<stdin>"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|f
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|inc
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Processing %s\n"
argument_list|,
name|inc
operator|->
name|file
argument_list|)
expr_stmt|;
name|parse_file
argument_list|(
name|f
argument_list|,
name|filelist
argument_list|,
name|globlist
argument_list|,
name|defconf
argument_list|,
operator|&
name|inclist
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * All config-file information has been read in and turned into 	 * a filelist and a globlist.  If there were no specific files 	 * given on the run command, then the only thing left to do is to 	 * call a routine which finds all files matched by the globlist 	 * and adds them to the filelist.  Then return the worklist. 	 */
if|if
condition|(
operator|*
name|files
operator|==
name|NULL
condition|)
block|{
name|expand_globs
argument_list|(
name|filelist
argument_list|,
name|globlist
argument_list|)
expr_stmt|;
name|free_clist
argument_list|(
name|globlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|defconf
operator|!=
name|NULL
condition|)
name|free_entry
argument_list|(
name|defconf
argument_list|)
expr_stmt|;
return|return
operator|(
name|filelist
operator|)
return|;
comment|/* NOTREACHED */
block|}
comment|/* 	 * If newsyslog was given a specific list of files to process, 	 * it may be that some of those files were not listed in any 	 * config file.  Those unlisted files should get the default 	 * rotation action.  First, create the default-rotation action 	 * if none was found in a system config file. 	 */
if|if
condition|(
name|defconf
operator|==
name|NULL
condition|)
block|{
name|defconf
operator|=
name|init_entry
argument_list|(
name|DEFAULT_MARKER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|defconf
operator|->
name|numlogs
operator|=
literal|3
expr_stmt|;
name|defconf
operator|->
name|trsize
operator|=
literal|50
expr_stmt|;
name|defconf
operator|->
name|permissions
operator|=
name|S_IRUSR
operator||
name|S_IWUSR
expr_stmt|;
block|}
comment|/* 	 * If newsyslog was run with a list of specific filenames, 	 * then create a new worklist which has only those files in 	 * it, picking up the rotation-rules for those files from 	 * the original filelist. 	 * 	 * XXX - Note that this will copy multiple rules for a single 	 *	logfile, if multiple entries are an exact match for 	 *	that file.  That matches the historic behavior, but do 	 *	we want to continue to allow it?  If so, it should 	 *	probably be handled more intelligently. 	 */
name|cmdlist
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cflist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdlist
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc of cmdlist"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
name|cmdlist
argument_list|)
expr_stmt|;
for|for
control|(
name|given
operator|=
name|files
init|;
operator|*
name|given
condition|;
operator|++
name|given
control|)
block|{
comment|/* 		 * First try to find exact-matches for this given file. 		 */
name|gmatch
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ent
argument_list|,
argument|filelist
argument_list|,
argument|cf_nextp
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ent
operator|->
name|log
argument_list|,
operator|*
name|given
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gmatch
operator|++
expr_stmt|;
name|dupent
operator|=
name|init_entry
argument_list|(
operator|*
name|given
argument_list|,
name|ent
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|cmdlist
argument_list|,
name|dupent
argument_list|,
name|cf_nextp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gmatch
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ Matched entry %s\n"
argument_list|,
operator|*
name|given
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * There was no exact-match for this given file, so look 		 * for a "glob" entry which does match. 		 */
name|gmatch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
operator|&&
name|globlist
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"\t+ Checking globs for %s\n"
argument_list|,
operator|*
name|given
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ent
argument_list|,
argument|globlist
argument_list|,
argument|cf_nextp
argument_list|)
block|{
name|fnres
operator|=
name|fnmatch
argument_list|(
name|ent
operator|->
name|log
argument_list|,
operator|*
name|given
argument_list|,
name|FNM_PATHNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+    = %d for pattern %s\n"
argument_list|,
name|fnres
argument_list|,
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnres
operator|==
literal|0
condition|)
block|{
name|gmatch
operator|++
expr_stmt|;
name|dupent
operator|=
name|init_entry
argument_list|(
operator|*
name|given
argument_list|,
name|ent
argument_list|)
expr_stmt|;
comment|/* This new entry is not a glob! */
name|dupent
operator|->
name|flags
operator|&=
operator|~
name|CE_GLOB
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|cmdlist
argument_list|,
name|dupent
argument_list|,
name|cf_nextp
argument_list|)
expr_stmt|;
comment|/* Only allow a match to one glob-entry */
break|break;
block|}
block|}
if|if
condition|(
name|gmatch
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ Matched %s via %s\n"
argument_list|,
operator|*
name|given
argument_list|,
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * This given file was not found in any config file, so 		 * add a worklist item based on the default entry. 		 */
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ No entry matched %s  (will use %s)\n"
argument_list|,
operator|*
name|given
argument_list|,
name|DEFAULT_MARKER
argument_list|)
expr_stmt|;
name|dupent
operator|=
name|init_entry
argument_list|(
operator|*
name|given
argument_list|,
name|defconf
argument_list|)
expr_stmt|;
comment|/* Mark that it was *not* found in a config file */
name|dupent
operator|->
name|def_cfg
operator|=
literal|1
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|cmdlist
argument_list|,
name|dupent
argument_list|,
name|cf_nextp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free all the entries in the original work list, the list of 	 * glob entries, and the default entry. 	 */
name|free_clist
argument_list|(
name|filelist
argument_list|)
expr_stmt|;
name|free_clist
argument_list|(
name|globlist
argument_list|)
expr_stmt|;
name|free_entry
argument_list|(
name|defconf
argument_list|)
expr_stmt|;
comment|/* And finally, return a worklist which matches the given files. */
return|return
operator|(
name|cmdlist
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expand the list of entries with filename patterns, and add all files  * which match those glob-entries onto the worklist.  */
end_comment

begin_function
specifier|static
name|void
name|expand_globs
parameter_list|(
name|struct
name|cflist
modifier|*
name|work_p
parameter_list|,
name|struct
name|cflist
modifier|*
name|glob_p
parameter_list|)
block|{
name|int
name|gmatch
decl_stmt|,
name|gres
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|char
modifier|*
name|mfname
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|dupent
decl_stmt|,
modifier|*
name|ent
decl_stmt|,
modifier|*
name|globent
decl_stmt|;
name|glob_t
name|pglob
decl_stmt|;
name|struct
name|stat
name|st_fm
decl_stmt|;
comment|/* 	 * The worklist contains all fully-specified (non-GLOB) names. 	 * 	 * Now expand the list of filename-pattern (GLOB) entries into 	 * a second list, which (by definition) will only match files 	 * that already exist.  Do not add a glob-related entry for any 	 * file which already exists in the fully-specified list. 	 */
name|STAILQ_FOREACH
argument_list|(
argument|globent
argument_list|,
argument|glob_p
argument_list|,
argument|cf_nextp
argument_list|)
block|{
name|gres
operator|=
name|glob
argument_list|(
name|globent
operator|->
name|log
argument_list|,
name|GLOB_NOCHECK
argument_list|,
name|NULL
argument_list|,
operator|&
name|pglob
argument_list|)
expr_stmt|;
if|if
condition|(
name|gres
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"cannot expand pattern (%d): %s"
argument_list|,
name|gres
argument_list|,
name|globent
operator|->
name|log
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ Expanding pattern %s\n"
argument_list|,
name|globent
operator|->
name|log
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pglob
operator|.
name|gl_matchc
condition|;
name|i
operator|++
control|)
block|{
name|mfname
operator|=
name|pglob
operator|.
name|gl_pathv
index|[
name|i
index|]
expr_stmt|;
comment|/* See if this file already has a specific entry. */
name|gmatch
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ent
argument_list|,
argument|work_p
argument_list|,
argument|cf_nextp
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|mfname
argument_list|,
name|ent
operator|->
name|log
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gmatch
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|gmatch
condition|)
continue|continue;
comment|/* Make sure the named matched is a file. */
name|gres
operator|=
name|lstat
argument_list|(
name|mfname
argument_list|,
operator|&
name|st_fm
argument_list|)
expr_stmt|;
if|if
condition|(
name|gres
operator|!=
literal|0
condition|)
block|{
comment|/* Error on a file that glob() matched?!? */
name|warn
argument_list|(
literal|"Skipping %s - lstat() error"
argument_list|,
name|mfname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st_fm
operator|.
name|st_mode
argument_list|)
condition|)
block|{
comment|/* We only rotate files! */
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+  . skipping %s (!file)\n"
argument_list|,
name|mfname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+  . add file %s\n"
argument_list|,
name|mfname
argument_list|)
expr_stmt|;
name|dupent
operator|=
name|init_entry
argument_list|(
name|mfname
argument_list|,
name|globent
argument_list|)
expr_stmt|;
comment|/* This new entry is not a glob! */
name|dupent
operator|->
name|flags
operator|&=
operator|~
name|CE_GLOB
expr_stmt|;
comment|/* Add to the worklist. */
name|STAILQ_INSERT_TAIL
argument_list|(
name|work_p
argument_list|,
name|dupent
argument_list|,
name|cf_nextp
argument_list|)
expr_stmt|;
block|}
name|globfree
argument_list|(
operator|&
name|pglob
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ Done with pattern %s\n"
argument_list|,
name|globent
operator|->
name|log
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse a configuration file and update a linked list of all the logs to  * process.  */
end_comment

begin_function
specifier|static
name|void
name|parse_file
parameter_list|(
name|FILE
modifier|*
name|cf
parameter_list|,
name|struct
name|cflist
modifier|*
name|work_p
parameter_list|,
name|struct
name|cflist
modifier|*
name|glob_p
parameter_list|,
name|struct
name|conf_entry
modifier|*
name|defconf_p
parameter_list|,
name|struct
name|ilist
modifier|*
name|inclist
parameter_list|)
block|{
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|parse
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|errline
decl_stmt|,
modifier|*
name|group
decl_stmt|;
name|struct
name|conf_entry
modifier|*
name|working
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|glob_t
name|pglob
decl_stmt|;
name|int
name|eol
decl_stmt|,
name|ptm_opts
decl_stmt|,
name|res
decl_stmt|,
name|special
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|errline
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|cf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|errline
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|errline
argument_list|)
expr_stmt|;
name|errline
operator|=
name|strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|line
operator|+
literal|1
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'#'
condition|)
continue|continue;
if|if
condition|(
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|==
literal|'\\'
condition|)
block|{
name|strcpy
argument_list|(
name|cp
operator|-
literal|1
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|--
expr_stmt|;
continue|continue;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
name|line
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Allow people to set debug options via the config file. 		 * (NOTE: debug options are undocumented, and may disappear 		 * at any time, etc). 		 */
if|if
condition|(
name|strcasecmp
argument_list|(
name|DEBUG_MARKER
argument_list|,
name|q
argument_list|)
operator|==
literal|0
condition|)
block|{
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
name|parse
operator|+
literal|1
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|warnx
argument_list|(
literal|"debug line specifies no option:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
name|parse_doption
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|INCLUDE_MARKER
argument_list|,
name|q
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found: %s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
name|parse
operator|+
literal|1
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
block|{
name|warnx
argument_list|(
literal|"include line missing argument:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isglobstr
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|res
operator|=
name|glob
argument_list|(
name|q
argument_list|,
name|GLOB_NOCHECK
argument_list|,
name|NULL
argument_list|,
operator|&
name|pglob
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"cannot expand pattern (%d): %s"
argument_list|,
name|res
argument_list|,
name|q
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ Expanding pattern %s\n"
argument_list|,
name|q
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pglob
operator|.
name|gl_matchc
condition|;
name|i
operator|++
control|)
name|add_to_queue
argument_list|(
name|pglob
operator|.
name|gl_pathv
index|[
name|i
index|]
argument_list|,
name|inclist
argument_list|)
expr_stmt|;
name|globfree
argument_list|(
operator|&
name|pglob
argument_list|)
expr_stmt|;
block|}
else|else
name|add_to_queue
argument_list|(
name|q
argument_list|,
name|inclist
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|special
operator|=
literal|0
expr_stmt|;
name|working
operator|=
name|init_entry
argument_list|(
name|q
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|DEFAULT_MARKER
argument_list|,
name|q
argument_list|)
operator|==
literal|0
condition|)
block|{
name|special
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|defconf_p
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Ignoring duplicate entry for %s!"
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free_entry
argument_list|(
name|working
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|defconf_p
operator|=
name|working
expr_stmt|;
block|}
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
name|parse
operator|+
literal|1
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|group
operator|=
name|strchr
argument_list|(
name|q
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|group
operator|=
name|strrchr
argument_list|(
name|q
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|group
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isnumberstr
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; unknown user:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
block|}
else|else
name|working
operator|->
name|uid
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|working
operator|->
name|uid
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|q
operator|=
name|group
expr_stmt|;
if|if
condition|(
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|isnumberstr
argument_list|(
name|q
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; unknown group:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
else|else
name|working
operator|->
name|gid
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
else|else
name|working
operator|->
name|gid
operator|=
operator|(
name|gid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
name|parse
operator|+
literal|1
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|working
operator|->
name|uid
operator|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
expr_stmt|;
name|working
operator|->
name|gid
operator|=
operator|(
name|gid_t
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|working
operator|->
name|permissions
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; bad permissions:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
name|parse
operator|+
literal|1
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|q
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|working
operator|->
name|numlogs
argument_list|)
operator|||
name|working
operator|->
name|numlogs
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error in config file; bad value for count of logs to save:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
name|parse
operator|+
literal|1
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed line (missing fields):\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|isdigitch
argument_list|(
operator|*
name|q
argument_list|)
condition|)
name|working
operator|->
name|trsize
operator|=
name|atoi
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|q
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
name|working
operator|->
name|trsize
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"Invalid value of '%s' for 'size' in line:\n%s"
argument_list|,
name|q
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|trsize
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|working
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|working
operator|->
name|compress
operator|=
name|COMPRESS_NONE
expr_stmt|;
name|q
operator|=
name|parse
operator|=
name|missing_field
argument_list|(
name|sob
argument_list|(
name|parse
operator|+
literal|1
argument_list|)
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
name|eol
operator|=
operator|!
operator|*
name|parse
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|u_long
name|ul
decl_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|q
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|q
condition|)
name|working
operator|->
name|hours
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ep
operator|==
literal|'*'
condition|)
name|working
operator|->
name|hours
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ul
operator|>
name|INT_MAX
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"interval is too large:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
else|else
name|working
operator|->
name|hours
operator|=
name|ul
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|ep
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|no_trimat
goto|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'@'
operator|&&
operator|*
name|ep
operator|!=
literal|'$'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed interval/at:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|flags
operator||=
name|CE_TRIMAT
expr_stmt|;
name|working
operator|->
name|trim_at
operator|=
name|ptime_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|ptm_opts
operator|=
name|PTM_PARSE_ISO8601
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'$'
condition|)
name|ptm_opts
operator|=
name|PTM_PARSE_DWM
expr_stmt|;
name|ptm_opts
operator||=
name|PTM_PARSE_MATCHDOM
expr_stmt|;
name|res
operator|=
name|ptime_relparse
argument_list|(
name|working
operator|->
name|trim_at
argument_list|,
name|ptm_opts
argument_list|,
name|ptimeget_secs
argument_list|(
name|timenow
argument_list|)
argument_list|,
name|ep
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|2
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"nonexistent time for 'at' value:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|res
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malformed 'at' value:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
name|no_trimat
label|:
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
name|parse
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Optional field */
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
init|;
name|q
operator|&&
operator|*
name|q
operator|&&
operator|!
name|isspacech
argument_list|(
operator|*
name|q
argument_list|)
condition|;
name|q
operator|++
control|)
block|{
switch|switch
condition|(
name|tolowerch
argument_list|(
operator|*
name|q
argument_list|)
condition|)
block|{
case|case
literal|'b'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_BINARY
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* 				 * XXX - 	Ick! Ugly! Remove ASAP! 				 * We want `c' and `C' for "create".  But we 				 * will temporarily treat `c' as `g', because 				 * FreeBSD releases<= 4.8 have a typo of 				 * checking  ('G' || 'c')  for CE_GLOB. 				 */
if|if
condition|(
operator|*
name|q
operator|==
literal|'c'
condition|)
block|{
name|warnx
argument_list|(
literal|"Assuming 'g' for 'c' in flags for line:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"The 'c' flag will eventually mean 'CREATE'"
argument_list|)
expr_stmt|;
name|working
operator|->
name|flags
operator||=
name|CE_GLOB
expr_stmt|;
break|break;
block|}
name|working
operator|->
name|flags
operator||=
name|CE_CREATE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_NODUMP
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_GLOB
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|working
operator|->
name|compress
operator|=
name|COMPRESS_BZIP2
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_NOSIGNAL
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_PID2CMD
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_RFC5424
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|working
operator|->
name|flags
operator||=
name|CE_SIGNALGROUP
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Deprecated flag - keep for compatibility purposes */
break|break;
case|case
literal|'x'
case|:
name|working
operator|->
name|compress
operator|=
name|COMPRESS_XZ
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|working
operator|->
name|compress
operator|=
name|COMPRESS_GZIP
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
break|break;
case|case
literal|'f'
case|:
comment|/* Used by OpenBSD for "CE_FOLLOW" */
case|case
literal|'m'
case|:
comment|/* Used by OpenBSD for "CE_MONITOR" */
case|case
literal|'p'
case|:
comment|/* Used by NetBSD  for "CE_PLAIN0" */
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal flag in config file -- %c"
argument_list|,
operator|*
name|q
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
name|parse
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Optional field */
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|parse
condition|)
name|eol
operator|=
literal|1
expr_stmt|;
operator|*
name|parse
operator|=
literal|'\0'
expr_stmt|;
block|}
name|working
operator|->
name|pid_cmd_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|q
operator|&&
operator|*
name|q
condition|)
block|{
if|if
condition|(
operator|*
name|q
operator|==
literal|'/'
condition|)
name|working
operator|->
name|pid_cmd_file
operator|=
name|strdup
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
condition|)
goto|goto
name|got_sig
goto|;
else|else
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal pid file or signal in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|eol
condition|)
name|q
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|q
operator|=
name|parse
operator|=
name|sob
argument_list|(
name|parse
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Optional field */
operator|*
operator|(
name|parse
operator|=
name|son
argument_list|(
name|parse
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
name|working
operator|->
name|sig
operator|=
name|SIGHUP
expr_stmt|;
if|if
condition|(
name|q
operator|&&
operator|*
name|q
condition|)
block|{
name|got_sig
label|:
name|working
operator|->
name|sig
operator|=
name|parse_signal
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|working
operator|->
name|sig
operator|<
literal|1
operator|||
name|working
operator|->
name|sig
operator|>=
name|sys_nsig
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"illegal signal in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Finish figuring out what pid-file to use (if any) in 		 * later processing if this logfile needs to be rotated. 		 */
if|if
condition|(
operator|(
name|working
operator|->
name|flags
operator|&
name|CE_NOSIGNAL
operator|)
operator|==
name|CE_NOSIGNAL
condition|)
block|{
comment|/* 			 * This config-entry specified 'n' for nosignal, 			 * see if it also specified an explicit pid_cmd_file. 			 * This would be a pretty pointless combination. 			 */
if|if
condition|(
name|working
operator|->
name|pid_cmd_file
operator|!=
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Ignoring '%s' because flag 'n' was specified in line:\n%s"
argument_list|,
name|working
operator|->
name|pid_cmd_file
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|working
operator|->
name|pid_cmd_file
argument_list|)
expr_stmt|;
name|working
operator|->
name|pid_cmd_file
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|working
operator|->
name|pid_cmd_file
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This entry did not specify the 'n' flag, which 			 * means it should signal syslogd unless it had 			 * specified some other pid-file (and obviously the 			 * syslog pid-file will not be for a process-group). 			 * Also, we should only try to notify syslog if we 			 * are root. 			 */
if|if
condition|(
name|working
operator|->
name|flags
operator|&
name|CE_SIGNALGROUP
condition|)
block|{
name|warnx
argument_list|(
literal|"Ignoring flag 'U' in line:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
name|working
operator|->
name|flags
operator|&=
operator|~
name|CE_SIGNALGROUP
expr_stmt|;
block|}
if|if
condition|(
name|needroot
condition|)
name|working
operator|->
name|pid_cmd_file
operator|=
name|strdup
argument_list|(
name|path_syslogpid
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Add this entry to the appropriate list of entries, unless 		 * it was some kind of special entry (eg:<default>). 		 */
if|if
condition|(
name|special
condition|)
block|{
empty_stmt|;
comment|/* Do not add to any list */
block|}
elseif|else
if|if
condition|(
name|working
operator|->
name|flags
operator|&
name|CE_GLOB
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
name|glob_p
argument_list|,
name|working
argument_list|,
name|cf_nextp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
name|work_p
argument_list|,
name|working
argument_list|,
name|cf_nextp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errline
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|errline
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|missing_field
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|errline
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
operator|||
operator|!
operator|*
name|p
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"missing field in config file:\n%s"
argument_list|,
name|errline
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In our sort we return it in the reverse of what qsort normally  * would do, as we want the newest files first.  If we have two  * entries with the same time we don't really care about order.  *  * Support function for qsort() in delete_oldest_timelog().  */
end_comment

begin_function
specifier|static
name|int
name|oldlog_entry_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|oldlog_entry
modifier|*
name|ola
init|=
name|a
decl_stmt|,
modifier|*
name|olb
init|=
name|b
decl_stmt|;
if|if
condition|(
name|ola
operator|->
name|t
operator|>
name|olb
operator|->
name|t
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|ola
operator|->
name|t
operator|<
name|olb
operator|->
name|t
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether the file corresponding to dp is an archive of the logfile  * logfname, based on the timefnamefmt format string. Return true and fill out  * tm if this is the case; otherwise return false.  */
end_comment

begin_function
specifier|static
name|int
name|validate_old_timelog
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|dirent
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|logfname
parameter_list|,
name|struct
name|tm
modifier|*
name|tm
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|size_t
name|logfname_len
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
name|logfname_len
operator|=
name|strlen
argument_list|(
name|logfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|DT_REG
condition|)
block|{
comment|/* 		 * Some filesystems (e.g. NFS) don't fill out the d_type field 		 * and leave it set to DT_UNKNOWN; in this case we must obtain 		 * the file type ourselves. 		 */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|DT_UNKNOWN
operator|||
name|fstatat
argument_list|(
name|fd
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
operator|&
name|sb
argument_list|,
name|AT_SYMLINK_NOFOLLOW
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Ignore everything but files with our logfile prefix. */
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|logfname
argument_list|,
name|logfname_len
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Ignore the actual non-rotated logfile. */
if|if
condition|(
name|dp
operator|->
name|d_namlen
operator|==
name|logfname_len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Make sure we created have found a logfile, so the 	 * postfix is valid, IE format is: '.<time>(.[bgx]z)?'. 	 */
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
name|logfname_len
index|]
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Ignoring %s which has unexpected "
literal|"extension '%s'\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
operator|&
name|dp
operator|->
name|d_name
index|[
name|logfname_len
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strptime
argument_list|(
operator|&
name|dp
operator|->
name|d_name
index|[
name|logfname_len
operator|+
literal|1
index|]
argument_list|,
name|timefnamefmt
argument_list|,
name|tm
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We could special case "old" sequentially named logfiles here, 		 * but we do not as that would require special handling to 		 * decide which one was the oldest compared to "new" time based 		 * logfiles. 		 */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Ignoring %s which does not "
literal|"match time format\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|COMPRESS_TYPES
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|compress_type
index|[
name|c
index|]
operator|.
name|suffix
argument_list|)
operator|==
literal|0
condition|)
comment|/* We're done. */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Ignoring %s which has unexpected extension '%s'\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the oldest logfiles, when using time based filenames.  */
end_comment

begin_function
specifier|static
name|void
name|delete_oldest_timelog
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|,
specifier|const
name|char
modifier|*
name|archive_dir
parameter_list|)
block|{
name|char
modifier|*
name|logfname
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|dir
decl_stmt|,
name|errbuf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|dir_fd
decl_stmt|,
name|i
decl_stmt|,
name|logcnt
decl_stmt|,
name|max_logcnt
decl_stmt|;
name|struct
name|oldlog_entry
modifier|*
name|oldlogs
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cdir
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|oldlogs
operator|=
name|malloc
argument_list|(
name|MAX_OLDLOGS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|oldlog_entry
argument_list|)
argument_list|)
expr_stmt|;
name|max_logcnt
operator|=
name|MAX_OLDLOGS
expr_stmt|;
name|logcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|archive_dir
operator|!=
name|NULL
operator|&&
name|archive_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|cdir
operator|=
name|archive_dir
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cdir
operator|=
name|dirname
argument_list|(
name|ent
operator|->
name|log
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"dirname()"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dir
operator|=
name|strdup
argument_list|(
name|cdir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"strdup()"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|basename
argument_list|(
name|ent
operator|->
name|log
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"basename()"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|logfname
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"strdup()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|logfname
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Invalid log filename - became '/'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"Searching for old logs in %s\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* First we create a 'list' of all archived logfiles */
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Cannot open log directory '%s'"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|dir_fd
operator|=
name|dirfd
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|validate_old_timelog
argument_list|(
name|dir_fd
argument_list|,
name|dp
argument_list|,
name|logfname
argument_list|,
operator|&
name|tm
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * We should now have old an old rotated logfile, so 		 * add it to the 'list'. 		 */
if|if
condition|(
operator|(
name|oldlogs
index|[
name|logcnt
index|]
operator|.
name|t
operator|=
name|timegm
argument_list|(
operator|&
name|tm
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Could not convert time string to time value"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldlogs
index|[
name|logcnt
index|]
operator|.
name|fname
operator|=
name|strdup
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"strdup()"
argument_list|)
expr_stmt|;
name|logcnt
operator|++
expr_stmt|;
comment|/* 		 * It is very unlikely we ever run out of space in the 		 * logfile array from the default size, but lets 		 * handle it anyway... 		 */
if|if
condition|(
name|logcnt
operator|>=
name|max_logcnt
condition|)
block|{
name|max_logcnt
operator|*=
literal|4
expr_stmt|;
comment|/* Detect integer overflow */
if|if
condition|(
name|max_logcnt
operator|<
name|logcnt
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Too many old logfiles found"
argument_list|)
expr_stmt|;
name|oldlogs
operator|=
name|realloc
argument_list|(
name|oldlogs
argument_list|,
name|max_logcnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|oldlog_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlogs
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"realloc()"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Second, if needed we delete oldest archived logfiles */
if|if
condition|(
name|logcnt
operator|>
literal|0
operator|&&
name|logcnt
operator|>=
name|ent
operator|->
name|numlogs
operator|&&
name|ent
operator|->
name|numlogs
operator|>
literal|1
condition|)
block|{
name|oldlogs
operator|=
name|realloc
argument_list|(
name|oldlogs
argument_list|,
name|logcnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|oldlog_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlogs
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"realloc()"
argument_list|)
expr_stmt|;
comment|/* 		 * We now sort the logs in the order of newest to 		 * oldest.  That way we can simply skip over the 		 * number of records we want to keep. 		 */
name|qsort
argument_list|(
name|oldlogs
argument_list|,
name|logcnt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oldlog_entry
argument_list|)
argument_list|,
name|oldlog_entry_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ent
operator|->
name|numlogs
operator|-
literal|1
init|;
name|i
operator|<
name|logcnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"\trm -f %s/%s\n"
argument_list|,
name|dir
argument_list|,
name|oldlogs
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlinkat
argument_list|(
name|dir_fd
argument_list|,
name|oldlogs
index|[
name|i
index|]
operator|.
name|fname
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|errbuf
argument_list|)
argument_list|,
literal|"Could not delete old logfile '%s'"
argument_list|,
name|oldlogs
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|errbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"No old logs to delete for logfile %s\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
comment|/* Third, cleanup */
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|logcnt
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|oldlogs
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|oldlogs
index|[
name|i
index|]
operator|.
name|fname
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|oldlogs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|logfname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate a log filename, when using classic filenames.  */
end_comment

begin_function
specifier|static
name|void
name|gen_classiclog_fname
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|size_t
name|fname_sz
parameter_list|,
specifier|const
name|char
modifier|*
name|archive_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|namepart
parameter_list|,
name|int
name|numlogs_c
parameter_list|)
block|{
if|if
condition|(
name|archive_dir
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|fname
argument_list|,
name|fname_sz
argument_list|,
literal|"%s/%s.%d"
argument_list|,
name|archive_dir
argument_list|,
name|namepart
argument_list|,
name|numlogs_c
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|fname
argument_list|,
name|fname_sz
argument_list|,
literal|"%s.%d"
argument_list|,
name|namepart
argument_list|,
name|numlogs_c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete a rotated logfile, when using classic filenames.  */
end_comment

begin_function
specifier|static
name|void
name|delete_classiclog
parameter_list|(
specifier|const
name|char
modifier|*
name|archive_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|namepart
parameter_list|,
name|int
name|numlog_c
parameter_list|)
block|{
name|char
name|file1
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|zfile1
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|gen_classiclog_fname
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
name|archive_dir
argument_list|,
name|namepart
argument_list|,
name|numlog_c
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|COMPRESS_TYPES
condition|;
name|c
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|zfile1
argument_list|,
sizeof|sizeof
argument_list|(
name|zfile1
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|file1
argument_list|,
name|compress_type
index|[
name|c
index|]
operator|.
name|suffix
argument_list|)
expr_stmt|;
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"\trm -f %s\n"
argument_list|,
name|zfile1
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|zfile1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Only add to the queue if the file hasn't already been added. This is  * done to prevent circular include loops.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_queue
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|struct
name|ilist
modifier|*
name|inclist
parameter_list|)
block|{
name|struct
name|include_entry
modifier|*
name|inc
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|inc
argument_list|,
argument|inclist
argument_list|,
argument|inc_nextp
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
name|inc
operator|->
name|file
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"duplicate include detected: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|inc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|include_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inc
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc of inc"
argument_list|)
expr_stmt|;
name|inc
operator|->
name|file
operator|=
name|strdup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|2
condition|)
name|printf
argument_list|(
literal|"\t+ Adding %s to the processing queue.\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|inclist
argument_list|,
name|inc
argument_list|,
name|inc_nextp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Search for logfile and return its compression suffix (if supported)  * The suffix detection is first-match in the order of compress_types  *  * Note: if logfile without suffix exists (uncompressed, COMPRESS_NONE)  * a zero-length string is returned  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_logfile_suffix
parameter_list|(
specifier|const
name|char
modifier|*
name|logfile
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|zfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|COMPRESS_TYPES
condition|;
name|c
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zfile
argument_list|,
name|logfile
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|zfile
argument_list|,
name|compress_type
index|[
name|c
index|]
operator|.
name|suffix
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstat
argument_list|(
name|zfile
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|compress_type
index|[
name|c
index|]
operator|.
name|suffix
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|fk_entry
name|do_rotate
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
name|char
name|dirpart
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|namepart
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|file1
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|file2
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|zfile1
index|[
name|MAXPATHLEN
index|]
decl_stmt|,
name|zfile2
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|logfile_suffix
decl_stmt|;
name|char
name|datetimestr
index|[
literal|30
index|]
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|numlogs_c
decl_stmt|;
name|fk_entry
name|free_or_keep
decl_stmt|;
name|struct
name|sigwork_entry
modifier|*
name|swork
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|flags
operator|=
name|ent
operator|->
name|flags
expr_stmt|;
name|free_or_keep
operator|=
name|FREE_ENT
expr_stmt|;
if|if
condition|(
name|archtodir
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* build complete name of archive directory into dirpart */
if|if
condition|(
operator|*
name|archdirname
operator|==
literal|'/'
condition|)
block|{
comment|/* absolute */
name|strlcpy
argument_list|(
name|dirpart
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|dirpart
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* relative */
comment|/* get directory part of logfile */
name|strlcpy
argument_list|(
name|dirpart
argument_list|,
name|ent
operator|->
name|log
argument_list|,
sizeof|sizeof
argument_list|(
name|dirpart
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|dirpart
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|dirpart
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|strlcat
argument_list|(
name|dirpart
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|dirpart
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* check if archive directory exists, if not, create it */
if|if
condition|(
name|lstat
argument_list|(
name|dirpart
argument_list|,
operator|&
name|st
argument_list|)
condition|)
name|createdir
argument_list|(
name|ent
argument_list|,
name|dirpart
argument_list|)
expr_stmt|;
comment|/* get filename part of logfile */
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|ent
operator|->
name|log
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|strlcpy
argument_list|(
name|namepart
argument_list|,
name|ent
operator|->
name|log
argument_list|,
sizeof|sizeof
argument_list|(
name|namepart
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|namepart
argument_list|,
name|p
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|namepart
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Tell utility functions we are not using an archive 		 * dir. 		 */
name|dirpart
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strlcpy
argument_list|(
name|namepart
argument_list|,
name|ent
operator|->
name|log
argument_list|,
sizeof|sizeof
argument_list|(
name|namepart
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Delete old logs */
if|if
condition|(
name|timefnamefmt
operator|!=
name|NULL
condition|)
name|delete_oldest_timelog
argument_list|(
name|ent
argument_list|,
name|dirpart
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Handle cleaning up after legacy newsyslog where we 		 * kept ent->numlogs + 1 files.  This code can go away 		 * at some point in the future. 		 */
name|delete_classiclog
argument_list|(
name|dirpart
argument_list|,
name|namepart
argument_list|,
name|ent
operator|->
name|numlogs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|numlogs
operator|>
literal|0
condition|)
name|delete_classiclog
argument_list|(
name|dirpart
argument_list|,
name|namepart
argument_list|,
name|ent
operator|->
name|numlogs
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timefnamefmt
operator|!=
name|NULL
condition|)
block|{
comment|/* If time functions fails we can't really do any sensible */
if|if
condition|(
name|time
argument_list|(
operator|&
name|now
argument_list|)
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
operator|||
name|localtime_r
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tm
argument_list|)
operator|==
name|NULL
condition|)
name|bzero
argument_list|(
operator|&
name|tm
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|datetimestr
argument_list|,
sizeof|sizeof
argument_list|(
name|datetimestr
argument_list|)
argument_list|,
name|timefnamefmt
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|archtodir
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s/%s.%s"
argument_list|,
name|dirpart
argument_list|,
name|namepart
argument_list|,
name|datetimestr
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|datetimestr
argument_list|)
expr_stmt|;
comment|/* Don't run the code to move down logs */
name|numlogs_c
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|gen_classiclog_fname
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
name|dirpart
argument_list|,
name|namepart
argument_list|,
name|ent
operator|->
name|numlogs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|numlogs_c
operator|=
name|ent
operator|->
name|numlogs
operator|-
literal|2
expr_stmt|;
comment|/* copy for countdown */
block|}
comment|/* Move down log files */
for|for
control|(
init|;
name|numlogs_c
operator|>=
literal|0
condition|;
name|numlogs_c
operator|--
control|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|file2
argument_list|,
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file2
argument_list|)
argument_list|)
expr_stmt|;
name|gen_classiclog_fname
argument_list|(
name|file1
argument_list|,
sizeof|sizeof
argument_list|(
name|file1
argument_list|)
argument_list|,
name|dirpart
argument_list|,
name|namepart
argument_list|,
name|numlogs_c
argument_list|)
expr_stmt|;
name|logfile_suffix
operator|=
name|get_logfile_suffix
argument_list|(
name|file1
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile_suffix
operator|==
name|NULL
condition|)
continue|continue;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zfile1
argument_list|,
name|file1
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zfile2
argument_list|,
name|file2
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|zfile1
argument_list|,
name|logfile_suffix
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|zfile2
argument_list|,
name|logfile_suffix
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"\tmv %s %s\n"
argument_list|,
name|zfile1
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* XXX - Ought to be checking for failure! */
operator|(
name|void
operator|)
name|rename
argument_list|(
name|zfile1
argument_list|,
name|zfile2
argument_list|)
expr_stmt|;
block|}
name|change_attrs
argument_list|(
name|zfile2
argument_list|,
name|ent
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|numlogs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
block|{
comment|/* 			 * Note that savelog() may succeed with using link() 			 * for the archtodir case, but there is no good way 			 * of knowing if it will when doing "noaction", so 			 * here we claim that it will have to do a copy... 			 */
if|if
condition|(
name|archtodir
condition|)
name|printf
argument_list|(
literal|"\tcp %s %s\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|file1
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tln %s %s\n"
argument_list|,
name|ent
operator|->
name|log
argument_list|,
name|file1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ttouch %s\t\t"
literal|"# Update mtime for 'when'-interval processing\n"
argument_list|,
name|file1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CE_BINARY
operator|)
condition|)
block|{
comment|/* Report the trimming to the old log */
name|log_trim
argument_list|(
name|ent
operator|->
name|log
argument_list|,
name|ent
argument_list|)
expr_stmt|;
block|}
name|savelog
argument_list|(
name|ent
operator|->
name|log
argument_list|,
name|file1
argument_list|)
expr_stmt|;
comment|/* 			 * Interval-based rotations are done using the mtime of 			 * the most recently archived log, so make sure it gets 			 * updated during a rotation. 			 */
name|utimes
argument_list|(
name|file1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|change_attrs
argument_list|(
name|file1
argument_list|,
name|ent
argument_list|)
expr_stmt|;
block|}
comment|/* Create the new log file and move it into place */
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"Start new log...\n"
argument_list|)
expr_stmt|;
name|createlog
argument_list|(
name|ent
argument_list|)
expr_stmt|;
comment|/* 	 * Save all signalling and file-compression to be done after log 	 * files from all entries have been rotated.  This way any one 	 * process will not be sent the same signal multiple times when 	 * multiple log files had to be rotated. 	 */
name|swork
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|pid_cmd_file
operator|!=
name|NULL
condition|)
name|swork
operator|=
name|save_sigwork
argument_list|(
name|ent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|numlogs
operator|>
literal|0
operator|&&
name|ent
operator|->
name|compress
operator|>
name|COMPRESS_NONE
condition|)
block|{
comment|/* 		 * The zipwork_entry will include a pointer to this 		 * conf_entry, so the conf_entry should not be freed. 		 */
name|free_or_keep
operator|=
name|KEEP_ENT
expr_stmt|;
name|save_zipwork
argument_list|(
name|ent
argument_list|,
name|swork
argument_list|,
name|ent
operator|->
name|fsize
argument_list|,
name|file1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|free_or_keep
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_sigwork
parameter_list|(
name|struct
name|sigwork_entry
modifier|*
name|swork
parameter_list|)
block|{
name|struct
name|sigwork_entry
modifier|*
name|nextsig
decl_stmt|;
name|int
name|kres
decl_stmt|,
name|secs
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|swork
operator|->
name|sw_runcmd
operator|==
literal|0
operator|&&
operator|(
operator|!
operator|(
name|swork
operator|->
name|sw_pidok
operator|)
operator|||
name|swork
operator|->
name|sw_pid
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* no work to do... */
comment|/* 	 * If nosignal (-s) was specified, then do not signal any process. 	 * Note that a nosignal request triggers a warning message if the 	 * rotated logfile needs to be compressed, *unless* -R was also 	 * specified.  We assume that an `-sR' request came from a process 	 * which writes to the logfile, and as such, we assume that process 	 * has already made sure the logfile is not presently in use.  This 	 * just sets swork->sw_pidok to a special value, and do_zipwork 	 * will print any necessary warning(s). 	 */
if|if
condition|(
name|nosignal
condition|)
block|{
if|if
condition|(
operator|!
name|rotatereq
condition|)
name|swork
operator|->
name|sw_pidok
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 	 * Compute the pause between consecutive signals.  Use a longer 	 * sleep time if we will be sending two signals to the same 	 * daemon or process-group. 	 */
name|secs
operator|=
literal|0
expr_stmt|;
name|nextsig
operator|=
name|SLIST_NEXT
argument_list|(
name|swork
argument_list|,
name|sw_nextp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextsig
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|swork
operator|->
name|sw_pid
operator|==
name|nextsig
operator|->
name|sw_pid
condition|)
name|secs
operator|=
literal|10
expr_stmt|;
else|else
name|secs
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|noaction
condition|)
block|{
if|if
condition|(
name|swork
operator|->
name|sw_runcmd
condition|)
name|printf
argument_list|(
literal|"\tsh -c '%s %d'\n"
argument_list|,
name|swork
operator|->
name|sw_fname
argument_list|,
name|swork
operator|->
name|sw_signum
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"\tkill -%d %d \t\t# %s\n"
argument_list|,
name|swork
operator|->
name|sw_signum
argument_list|,
operator|(
name|int
operator|)
name|swork
operator|->
name|sw_pid
argument_list|,
name|swork
operator|->
name|sw_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|secs
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\tsleep %d\n"
argument_list|,
name|secs
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|swork
operator|->
name|sw_runcmd
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|tmp
argument_list|,
literal|"%s %d"
argument_list|,
name|swork
operator|->
name|sw_fname
argument_list|,
name|swork
operator|->
name|sw_signum
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"can't allocate memory to run %s"
argument_list|,
name|swork
operator|->
name|sw_fname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Run command: %s\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|kres
operator|=
name|system
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|kres
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: returned non-zero exit code: %d"
argument_list|,
name|tmp
argument_list|,
name|kres
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return;
block|}
name|kres
operator|=
name|kill
argument_list|(
name|swork
operator|->
name|sw_pid
argument_list|,
name|swork
operator|->
name|sw_signum
argument_list|)
expr_stmt|;
if|if
condition|(
name|kres
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Assume that "no such process" (ESRCH) is something 		 * to warn about, but is not an error.  Presumably the 		 * process which writes to the rotated log file(s) is 		 * gone, in which case we should have no problem with 		 * compressing the rotated log file(s). 		 */
if|if
condition|(
name|errno
operator|!=
name|ESRCH
condition|)
name|swork
operator|->
name|sw_pidok
operator|=
literal|0
expr_stmt|;
name|warn
argument_list|(
literal|"can't notify %s, pid %d = %s"
argument_list|,
name|swork
operator|->
name|sw_pidtype
argument_list|,
operator|(
name|int
operator|)
name|swork
operator|->
name|sw_pid
argument_list|,
name|swork
operator|->
name|sw_fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Notified %s pid %d = %s\n"
argument_list|,
name|swork
operator|->
name|sw_pidtype
argument_list|,
operator|(
name|int
operator|)
name|swork
operator|->
name|sw_pid
argument_list|,
name|swork
operator|->
name|sw_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|secs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Pause %d second(s) between signals\n"
argument_list|,
name|secs
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|secs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_zipwork
parameter_list|(
name|struct
name|zipwork_entry
modifier|*
name|zwork
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pgm_name
decl_stmt|,
modifier|*
name|pgm_path
decl_stmt|;
name|int
name|errsav
decl_stmt|,
name|fcount
decl_stmt|,
name|zstatus
decl_stmt|;
name|pid_t
name|pidzip
decl_stmt|,
name|wpid
decl_stmt|;
name|char
name|zresult
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|assert
argument_list|(
name|zwork
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|pgm_path
operator|=
name|NULL
expr_stmt|;
name|strlcpy
argument_list|(
name|zresult
argument_list|,
name|zwork
operator|->
name|zw_fname
argument_list|,
sizeof|sizeof
argument_list|(
name|zresult
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zwork
operator|->
name|zw_conf
operator|!=
name|NULL
operator|&&
name|zwork
operator|->
name|zw_conf
operator|->
name|compress
operator|>
name|COMPRESS_NONE
condition|)
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|COMPRESS_TYPES
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|zwork
operator|->
name|zw_conf
operator|->
name|compress
operator|==
name|c
condition|)
block|{
name|pgm_path
operator|=
name|compress_type
index|[
name|c
index|]
operator|.
name|path
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|zresult
argument_list|,
name|compress_type
index|[
name|c
index|]
operator|.
name|suffix
argument_list|,
sizeof|sizeof
argument_list|(
name|zresult
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pgm_path
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid entry for %s in do_zipwork"
argument_list|,
name|zwork
operator|->
name|zw_fname
argument_list|)
expr_stmt|;
return|return;
block|}
name|pgm_name
operator|=
name|strrchr
argument_list|(
name|pgm_path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgm_name
operator|==
name|NULL
condition|)
name|pgm_name
operator|=
name|pgm_path
expr_stmt|;
else|else
name|pgm_name
operator|++
expr_stmt|;
if|if
condition|(
name|zwork
operator|->
name|zw_swork
operator|!=
name|NULL
operator|&&
name|zwork
operator|->
name|zw_swork
operator|->
name|sw_runcmd
operator|==
literal|0
operator|&&
name|zwork
operator|->
name|zw_swork
operator|->
name|sw_pidok
operator|<=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"log %s not compressed because daemon(s) not notified"
argument_list|,
name|zwork
operator|->
name|zw_fname
argument_list|)
expr_stmt|;
name|change_attrs
argument_list|(
name|zwork
operator|->
name|zw_fname
argument_list|,
name|zwork
operator|->
name|zw_conf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s %s\n"
argument_list|,
name|pgm_name
argument_list|,
name|zwork
operator|->
name|zw_fname
argument_list|)
expr_stmt|;
name|change_attrs
argument_list|(
name|zresult
argument_list|,
name|zwork
operator|->
name|zw_conf
argument_list|)
expr_stmt|;
return|return;
block|}
name|fcount
operator|=
literal|1
expr_stmt|;
name|pidzip
operator|=
name|fork
argument_list|()
expr_stmt|;
while|while
condition|(
name|pidzip
operator|<
literal|0
condition|)
block|{
comment|/* 		 * The fork failed.  If the failure was due to a temporary 		 * problem, then wait a short time and try it again. 		 */
name|errsav
operator|=
name|errno
expr_stmt|;
name|warn
argument_list|(
literal|"fork() for `%s %s'"
argument_list|,
name|pgm_name
argument_list|,
name|zwork
operator|->
name|zw_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|errsav
operator|!=
name|EAGAIN
operator|||
name|fcount
operator|>
literal|5
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Exiting..."
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|fcount
operator|*
literal|12
argument_list|)
expr_stmt|;
name|fcount
operator|++
expr_stmt|;
name|pidzip
operator|=
name|fork
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pidzip
condition|)
block|{
comment|/* The child process executes the compression command */
name|execl
argument_list|(
name|pgm_path
argument_list|,
name|pgm_path
argument_list|,
literal|"-f"
argument_list|,
name|zwork
operator|->
name|zw_fname
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"execl(`%s -f %s')"
argument_list|,
name|pgm_path
argument_list|,
name|zwork
operator|->
name|zw_fname
argument_list|)
expr_stmt|;
block|}
name|wpid
operator|=
name|waitpid
argument_list|(
name|pidzip
argument_list|,
operator|&
name|zstatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wpid
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* XXX - should this be a fatal error? */
name|warn
argument_list|(
literal|"%s: waitpid(%d)"
argument_list|,
name|pgm_path
argument_list|,
name|pidzip
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|zstatus
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"`%s -f %s' did not terminate normally"
argument_list|,
name|pgm_name
argument_list|,
name|zwork
operator|->
name|zw_fname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|zstatus
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"`%s -f %s' terminated with a non-zero status (%d)"
argument_list|,
name|pgm_name
argument_list|,
name|zwork
operator|->
name|zw_fname
argument_list|,
name|WEXITSTATUS
argument_list|(
name|zstatus
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Compression was successful, set file attributes on the result. */
name|change_attrs
argument_list|(
name|zresult
argument_list|,
name|zwork
operator|->
name|zw_conf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Save information on any process we need to signal.  Any single  * process may need to be sent different signal-values for different  * log files, but usually a single signal-value will cause the process  * to close and re-open all of it's log files.  */
end_comment

begin_function
specifier|static
name|struct
name|sigwork_entry
modifier|*
name|save_sigwork
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
name|struct
name|sigwork_entry
modifier|*
name|sprev
decl_stmt|,
modifier|*
name|stmp
decl_stmt|;
name|int
name|ndiff
decl_stmt|;
name|size_t
name|tmpsiz
decl_stmt|;
name|sprev
operator|=
name|NULL
expr_stmt|;
name|ndiff
operator|=
literal|1
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|stmp
argument_list|,
argument|&swhead
argument_list|,
argument|sw_nextp
argument_list|)
block|{
name|ndiff
operator|=
name|strcmp
argument_list|(
name|ent
operator|->
name|pid_cmd_file
argument_list|,
name|stmp
operator|->
name|sw_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndiff
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|ndiff
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|sig
operator|==
name|stmp
operator|->
name|sw_signum
condition|)
break|break;
if|if
condition|(
name|ent
operator|->
name|sig
operator|>
name|stmp
operator|->
name|sw_signum
condition|)
block|{
name|ndiff
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|sprev
operator|=
name|stmp
expr_stmt|;
block|}
if|if
condition|(
name|stmp
operator|!=
name|NULL
operator|&&
name|ndiff
operator|==
literal|0
condition|)
return|return
operator|(
name|stmp
operator|)
return|;
name|tmpsiz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sigwork_entry
argument_list|)
operator|+
name|strlen
argument_list|(
name|ent
operator|->
name|pid_cmd_file
argument_list|)
operator|+
literal|1
expr_stmt|;
name|stmp
operator|=
name|malloc
argument_list|(
name|tmpsiz
argument_list|)
expr_stmt|;
name|stmp
operator|->
name|sw_runcmd
operator|=
literal|0
expr_stmt|;
comment|/* If this is a command to run we just set the flag and run command */
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_PID2CMD
condition|)
block|{
name|stmp
operator|->
name|sw_pid
operator|=
operator|-
literal|1
expr_stmt|;
name|stmp
operator|->
name|sw_pidok
operator|=
literal|0
expr_stmt|;
name|stmp
operator|->
name|sw_runcmd
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|set_swpid
argument_list|(
name|stmp
argument_list|,
name|ent
argument_list|)
expr_stmt|;
block|}
name|stmp
operator|->
name|sw_signum
operator|=
name|ent
operator|->
name|sig
expr_stmt|;
name|strcpy
argument_list|(
name|stmp
operator|->
name|sw_fname
argument_list|,
name|ent
operator|->
name|pid_cmd_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|sprev
operator|==
name|NULL
condition|)
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|swhead
argument_list|,
name|stmp
argument_list|,
name|sw_nextp
argument_list|)
expr_stmt|;
else|else
name|SLIST_INSERT_AFTER
argument_list|(
name|sprev
argument_list|,
name|stmp
argument_list|,
name|sw_nextp
argument_list|)
expr_stmt|;
return|return
operator|(
name|stmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Save information on any file we need to compress.  We may see the same  * file multiple times, so check the full list to avoid duplicates.  The  * list itself is sorted smallest-to-largest, because that's the order we  * want to compress the files.  If the partition is very low on disk space,  * then the smallest files are the most likely to compress, and compressing  * them first will free up more space for the larger files.  */
end_comment

begin_function
specifier|static
name|struct
name|zipwork_entry
modifier|*
name|save_zipwork
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|,
specifier|const
name|struct
name|sigwork_entry
modifier|*
name|swork
parameter_list|,
name|int
name|zsize
parameter_list|,
specifier|const
name|char
modifier|*
name|zipfname
parameter_list|)
block|{
name|struct
name|zipwork_entry
modifier|*
name|zprev
decl_stmt|,
modifier|*
name|ztmp
decl_stmt|;
name|int
name|ndiff
decl_stmt|;
name|size_t
name|tmpsiz
decl_stmt|;
comment|/* Compute the size if the caller did not know it. */
if|if
condition|(
name|zsize
operator|<
literal|0
condition|)
name|zsize
operator|=
name|sizefile
argument_list|(
name|zipfname
argument_list|)
expr_stmt|;
name|zprev
operator|=
name|NULL
expr_stmt|;
name|ndiff
operator|=
literal|1
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|ztmp
argument_list|,
argument|&zwhead
argument_list|,
argument|zw_nextp
argument_list|)
block|{
name|ndiff
operator|=
name|strcmp
argument_list|(
name|zipfname
argument_list|,
name|ztmp
operator|->
name|zw_fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndiff
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|zsize
operator|>
name|ztmp
operator|->
name|zw_fsize
condition|)
name|zprev
operator|=
name|ztmp
expr_stmt|;
block|}
if|if
condition|(
name|ztmp
operator|!=
name|NULL
operator|&&
name|ndiff
operator|==
literal|0
condition|)
return|return
operator|(
name|ztmp
operator|)
return|;
name|tmpsiz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|zipwork_entry
argument_list|)
operator|+
name|strlen
argument_list|(
name|zipfname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ztmp
operator|=
name|malloc
argument_list|(
name|tmpsiz
argument_list|)
expr_stmt|;
name|ztmp
operator|->
name|zw_conf
operator|=
name|ent
expr_stmt|;
name|ztmp
operator|->
name|zw_swork
operator|=
name|swork
expr_stmt|;
name|ztmp
operator|->
name|zw_fsize
operator|=
name|zsize
expr_stmt|;
name|strcpy
argument_list|(
name|ztmp
operator|->
name|zw_fname
argument_list|,
name|zipfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|zprev
operator|==
name|NULL
condition|)
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|zwhead
argument_list|,
name|ztmp
argument_list|,
name|zw_nextp
argument_list|)
expr_stmt|;
else|else
name|SLIST_INSERT_AFTER
argument_list|(
name|zprev
argument_list|,
name|ztmp
argument_list|,
name|zw_nextp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ztmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Send a signal to the pid specified by pidfile */
end_comment

begin_function
specifier|static
name|void
name|set_swpid
parameter_list|(
name|struct
name|sigwork_entry
modifier|*
name|swork
parameter_list|,
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|long
name|minok
decl_stmt|,
name|maxok
decl_stmt|,
name|rval
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|,
modifier|*
name|linep
decl_stmt|,
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|minok
operator|=
name|MIN_PID
expr_stmt|;
name|maxok
operator|=
name|MAX_PID
expr_stmt|;
name|swork
operator|->
name|sw_pidok
operator|=
literal|0
expr_stmt|;
name|swork
operator|->
name|sw_pid
operator|=
literal|0
expr_stmt|;
name|swork
operator|->
name|sw_pidtype
operator|=
literal|"daemon"
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_SIGNALGROUP
condition|)
block|{
comment|/* 		 * If we are expected to signal a process-group when 		 * rotating this logfile, then the value read in should 		 * be the negative of a valid process ID. 		 */
name|minok
operator|=
operator|-
name|MAX_PID
expr_stmt|;
name|maxok
operator|=
operator|-
name|MIN_PID
expr_stmt|;
name|swork
operator|->
name|sw_pidtype
operator|=
literal|"process-group"
expr_stmt|;
block|}
name|f
operator|=
name|fopen
argument_list|(
name|ent
operator|->
name|pid_cmd_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
operator|&&
name|enforcepid
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Warn if the PID file doesn't exist, but do 			 * not consider it an error.  Most likely it 			 * means the process has been terminated, 			 * so it should be safe to rotate any log 			 * files that the process would have been using. 			 */
name|swork
operator|->
name|sw_pidok
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"pid file doesn't exist: %s"
argument_list|,
name|ent
operator|->
name|pid_cmd_file
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"can't open pid file: %s"
argument_list|,
name|ent
operator|->
name|pid_cmd_file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|f
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Warn if the PID file is empty, but do not consider 		 * it an error.  Most likely it means the process has 		 * has terminated, so it should be safe to rotate any 		 * log files that the process would have been using. 		 */
if|if
condition|(
name|feof
argument_list|(
name|f
argument_list|)
operator|&&
name|enforcepid
operator|==
literal|0
condition|)
block|{
name|swork
operator|->
name|sw_pidok
operator|=
literal|1
expr_stmt|;
name|warnx
argument_list|(
literal|"pid/cmd file is empty: %s"
argument_list|,
name|ent
operator|->
name|pid_cmd_file
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"can't read from pid file: %s"
argument_list|,
name|ent
operator|->
name|pid_cmd_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|linep
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|linep
operator|==
literal|' '
condition|)
name|linep
operator|++
expr_stmt|;
name|rval
operator|=
name|strtol
argument_list|(
name|linep
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspacech
argument_list|(
operator|*
name|endp
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"pid file does not start with a valid number: %s"
argument_list|,
name|ent
operator|->
name|pid_cmd_file
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rval
operator|<
name|minok
operator|||
name|rval
operator|>
name|maxok
condition|)
block|{
name|warnx
argument_list|(
literal|"bad value '%ld' for process number in %s"
argument_list|,
name|rval
argument_list|,
name|ent
operator|->
name|pid_cmd_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|warnx
argument_list|(
literal|"\t(expecting value between %ld and %ld)"
argument_list|,
name|minok
argument_list|,
name|maxok
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|swork
operator|->
name|sw_pidok
operator|=
literal|1
expr_stmt|;
name|swork
operator|->
name|sw_pid
operator|=
name|rval
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Log the fact that the logs were turned over */
end_comment

begin_function
specifier|static
name|int
name|log_trim
parameter_list|(
specifier|const
name|char
modifier|*
name|logname
parameter_list|,
specifier|const
name|struct
name|conf_entry
modifier|*
name|log_ent
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|const
name|char
modifier|*
name|xtra
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|logname
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|xtra
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|log_ent
operator|->
name|def_cfg
condition|)
name|xtra
operator|=
literal|" using<default> rule"
expr_stmt|;
if|if
condition|(
name|log_ent
operator|->
name|flags
operator|&
name|CE_RFC5424
condition|)
block|{
if|if
condition|(
name|log_ent
operator|->
name|firstcreate
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"<%d>1 %s %s newsyslog %d - - %s%s\n"
argument_list|,
name|LOG_MAKEPRI
argument_list|(
name|LOG_USER
argument_list|,
name|LOG_INFO
argument_list|)
argument_list|,
name|daytime_rfc5424
argument_list|,
name|hostname
argument_list|,
name|getpid
argument_list|()
argument_list|,
literal|"logfile first created"
argument_list|,
name|xtra
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|log_ent
operator|->
name|r_reason
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"<%d>1 %s %s newsyslog %d - - %s%s%s\n"
argument_list|,
name|LOG_MAKEPRI
argument_list|(
name|LOG_USER
argument_list|,
name|LOG_INFO
argument_list|)
argument_list|,
name|daytime_rfc5424
argument_list|,
name|hostname
argument_list|,
name|getpid
argument_list|()
argument_list|,
literal|"logfile turned over"
argument_list|,
name|log_ent
operator|->
name|r_reason
argument_list|,
name|xtra
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"<%d>1 %s %s newsyslog %d - - %s%s\n"
argument_list|,
name|LOG_MAKEPRI
argument_list|(
name|LOG_USER
argument_list|,
name|LOG_INFO
argument_list|)
argument_list|,
name|daytime_rfc5424
argument_list|,
name|hostname
argument_list|,
name|getpid
argument_list|()
argument_list|,
literal|"logfile turned over"
argument_list|,
name|xtra
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|log_ent
operator|->
name|firstcreate
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s %s newsyslog[%d]: logfile first created%s\n"
argument_list|,
name|daytime
argument_list|,
name|hostname
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|xtra
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|log_ent
operator|->
name|r_reason
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s %s newsyslog[%d]: logfile turned over%s%s\n"
argument_list|,
name|daytime
argument_list|,
name|hostname
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|log_ent
operator|->
name|r_reason
argument_list|,
name|xtra
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s %s newsyslog[%d]: logfile turned over%s\n"
argument_list|,
name|daytime
argument_list|,
name|hostname
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|xtra
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|f
argument_list|)
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"log_trim: fclose"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return size in kilobytes of a file */
end_comment

begin_function
specifier|static
name|int
name|sizefile
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|kbytes
argument_list|(
name|sb
operator|.
name|st_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the mtime of the most recent archive of the logfile, using timestamp  * based filenames.  */
end_comment

begin_function
specifier|static
name|time_t
name|mtime_old_timelog
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|int
name|dir_fd
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|logfname
decl_stmt|,
modifier|*
name|dir
decl_stmt|;
name|t
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dir
operator|=
name|dirname
argument_list|(
name|file
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"dirname() of '%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|basename
argument_list|(
name|file
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"basename() of '%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|warnx
argument_list|(
literal|"Invalid log filename '%s'"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|logfname
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"strdup()"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"Cannot open log directory '%s'"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
name|dir_fd
operator|=
name|dirfd
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
comment|/* Open the archive dir and find the most recent archive of logfname. */
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|validate_old_timelog
argument_list|(
name|dir_fd
argument_list|,
name|dp
argument_list|,
name|logfname
argument_list|,
operator|&
name|tm
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|fstatat
argument_list|(
name|dir_fd
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
operator|&
name|sb
argument_list|,
name|AT_SYMLINK_NOFOLLOW
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Cannot stat '%s'"
argument_list|,
name|file
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|t
operator|<
name|sb
operator|.
name|st_mtime
condition|)
name|t
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the age in hours of the most recent archive of the logfile. */
end_comment

begin_function
specifier|static
name|int
name|age_old_log
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
specifier|const
name|char
modifier|*
name|logfile_suffix
decl_stmt|;
name|char
name|tmp
index|[
name|MAXPATHLEN
operator|+
sizeof|sizeof
argument_list|(
literal|".0"
argument_list|)
operator|+
name|COMPRESS_SUFFIX_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
if|if
condition|(
name|archtodir
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* build name of archive directory into tmp */
if|if
condition|(
operator|*
name|archdirname
operator|==
literal|'/'
condition|)
block|{
comment|/* absolute */
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* relative */
comment|/* get directory part of logfile */
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|tmp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|tmp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|archdirname
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|tmp
argument_list|,
literal|"/"
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get filename part of logfile */
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|p
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|tmp
argument_list|,
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timefnamefmt
operator|!=
name|NULL
condition|)
block|{
name|mtime
operator|=
name|mtime_old_timelog
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|strlcat
argument_list|(
name|tmp
argument_list|,
literal|".0"
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|logfile_suffix
operator|=
name|get_logfile_suffix
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfile_suffix
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|tmp
argument_list|,
name|logfile_suffix
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|tmp
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|mtime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
block|}
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|ptimeget_secs
argument_list|(
name|timenow
argument_list|)
operator|-
name|mtime
operator|+
literal|1800
argument_list|)
operator|/
literal|3600
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Skip Over Blanks */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|sob
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|&&
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Skip Over Non-Blanks */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|son
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check if string is actually a number */
end_comment

begin_function
specifier|static
name|int
name|isnumberstr
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
while|while
condition|(
operator|*
name|string
condition|)
block|{
if|if
condition|(
operator|!
name|isdigitch
argument_list|(
operator|*
name|string
operator|++
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check if string contains a glob */
end_comment

begin_function
specifier|static
name|int
name|isglobstr
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
name|chr
decl_stmt|;
while|while
condition|(
operator|(
name|chr
operator|=
operator|*
name|string
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|chr
operator|==
literal|'*'
operator|||
name|chr
operator|==
literal|'?'
operator|||
name|chr
operator|==
literal|'['
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Save the active log file under a new name.  A link to the new name  * is the quick-and-easy way to do this.  If that fails (which it will  * if the destination is on another partition), then make a copy of  * the file to the new location.  */
end_comment

begin_function
specifier|static
name|void
name|savelog
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
name|FILE
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|c
decl_stmt|,
name|res
decl_stmt|;
name|res
operator|=
name|link
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|src
operator|=
name|fopen
argument_list|(
name|from
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fopen %s for reading"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst
operator|=
name|fopen
argument_list|(
name|to
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fopen %s for writing"
argument_list|,
name|to
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|putc
argument_list|(
name|c
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error writing to %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|src
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"error reading from %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fclose
argument_list|(
name|src
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fclose %s"
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fclose
argument_list|(
name|dst
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fclose %s"
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* create one or more directory components of a path */
end_comment

begin_function
specifier|static
name|void
name|createdir
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|,
name|char
modifier|*
name|dirpart
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|char
name|mkdirpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|s
operator|=
name|dirpart
expr_stmt|;
name|d
operator|=
name|mkdirpath
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'/'
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
continue|continue;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
name|res
operator|=
name|lstat
argument_list|(
name|mkdirpath
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"\tmkdir %s\n"
argument_list|,
name|mkdirpath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|mkdir
argument_list|(
name|mkdirpath
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Error on mkdir(\"%s\") for -a"
argument_list|,
name|mkdirpath
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
break|break;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|ent
operator|->
name|firstcreate
condition|)
name|printf
argument_list|(
literal|"Created directory '%s' for new %s\n"
argument_list|,
name|dirpart
argument_list|,
name|ent
operator|->
name|log
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Created directory '%s' for -a\n"
argument_list|,
name|dirpart
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create a new log file, destroying any currently-existing version  * of the log file in the process.  If the caller wants a backup copy  * of the file to exist, they should call 'link(logfile,logbackup)'  * before calling this routine.  */
end_comment

begin_function
name|void
name|createlog
parameter_list|(
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|failed
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|realfile
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
name|tempfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|realfile
operator|=
name|ent
operator|->
name|log
expr_stmt|;
comment|/* 	 * If this log file is being created for the first time (-C option), 	 * then it may also be true that the parent directory does not exist 	 * yet.  Check, and create that directory if it is missing. 	 */
if|if
condition|(
name|ent
operator|->
name|firstcreate
condition|)
block|{
name|strlcpy
argument_list|(
name|tempfile
argument_list|,
name|realfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tempfile
argument_list|)
argument_list|)
expr_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|tempfile
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|failed
operator|=
name|stat
argument_list|(
name|tempfile
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Error on stat(%s)"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
name|createdir
argument_list|(
name|ent
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s exists but is not a directory"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * First create an unused filename, so it can be chown'ed and 	 * chmod'ed before it is moved into the real location.  mkstemp 	 * will create the file mode=600& owned by us.  Note that all 	 * temp files will have a suffix of '.z<something>'. 	 */
name|strlcpy
argument_list|(
name|tempfile
argument_list|,
name|realfile
argument_list|,
sizeof|sizeof
argument_list|(
name|tempfile
argument_list|)
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|tempfile
argument_list|,
literal|".zXXXXXX"
argument_list|,
sizeof|sizeof
argument_list|(
name|tempfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"\tmktemp %s\n"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
else|else
block|{
name|fd
operator|=
name|mkstemp
argument_list|(
name|tempfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't mkstemp logfile %s"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
comment|/* 		 * Add status message to what will become the new log file. 		 */
if|if
condition|(
operator|!
operator|(
name|ent
operator|->
name|flags
operator|&
name|CE_BINARY
operator|)
condition|)
block|{
if|if
condition|(
name|log_trim
argument_list|(
name|tempfile
argument_list|,
name|ent
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't add status message to log"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Change the owner/group, if we are supposed to */
if|if
condition|(
name|ent
operator|->
name|uid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|ent
operator|->
name|gid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"\tchown %u:%u %s\n"
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
else|else
block|{
name|failed
operator|=
name|fchown
argument_list|(
name|fd
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fchown temp file %s"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Turn on NODUMP if it was requested in the config-file. */
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_NODUMP
condition|)
block|{
if|if
condition|(
name|noaction
condition|)
name|printf
argument_list|(
literal|"\tchflags nodump %s\n"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
else|else
block|{
name|failed
operator|=
name|fchflags
argument_list|(
name|fd
argument_list|,
name|UF_NODUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
block|{
name|warn
argument_list|(
literal|"log_trim: fchflags(NODUMP)"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Note that if the real logfile still exists, and if the call 	 * to rename() fails, then "neither the old file nor the new 	 * file shall be changed or created" (to quote the standard). 	 * If the call succeeds, then the file will be replaced without 	 * any window where some other process might find that the file 	 * did not exist. 	 * XXX - ? It may be that for some error conditions, we could 	 *	retry by first removing the realfile and then renaming. 	 */
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"\tchmod %o %s\n"
argument_list|,
name|ent
operator|->
name|permissions
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tmv %s %s\n"
argument_list|,
name|tempfile
argument_list|,
name|realfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|failed
operator|=
name|fchmod
argument_list|(
name|fd
argument_list|,
name|ent
operator|->
name|permissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't fchmod temp file '%s'"
argument_list|,
name|tempfile
argument_list|)
expr_stmt|;
name|failed
operator|=
name|rename
argument_list|(
name|tempfile
argument_list|,
name|realfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"can't mv %s to %s"
argument_list|,
name|tempfile
argument_list|,
name|realfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the attributes of a given filename to what was specified in  * the newsyslog.conf entry.  This routine is only called for files  * that newsyslog expects that it has created, and thus it is a fatal  * error if this routine finds that the file does not exist.  */
end_comment

begin_function
specifier|static
name|void
name|change_attrs
parameter_list|(
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
specifier|const
name|struct
name|conf_entry
modifier|*
name|ent
parameter_list|)
block|{
name|int
name|failed
decl_stmt|;
if|if
condition|(
name|noaction
condition|)
block|{
name|printf
argument_list|(
literal|"\tchmod %o %s\n"
argument_list|,
name|ent
operator|->
name|permissions
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|uid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|ent
operator|->
name|gid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"\tchown %u:%u %s\n"
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_NODUMP
condition|)
name|printf
argument_list|(
literal|"\tchflags nodump %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return;
block|}
name|failed
operator|=
name|chmod
argument_list|(
name|fname
argument_list|,
name|ent
operator|->
name|permissions
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EPERM
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"chmod(%s) in change_attrs"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"change_attrs couldn't chmod(%s)"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|uid
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|ent
operator|->
name|gid
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|failed
operator|=
name|chown
argument_list|(
name|fname
argument_list|,
name|ent
operator|->
name|uid
argument_list|,
name|ent
operator|->
name|gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
name|warn
argument_list|(
literal|"can't chown %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ent
operator|->
name|flags
operator|&
name|CE_NODUMP
condition|)
block|{
name|failed
operator|=
name|chflags
argument_list|(
name|fname
argument_list|,
name|UF_NODUMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|failed
condition|)
name|warn
argument_list|(
literal|"can't chflags %s NODUMP"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse a signal number or signal name. Returns the signal number parsed or -1  * on failure.  */
end_comment

begin_function
specifier|static
name|int
name|parse_signal
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|sig
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|sig
operator|=
name|strtonum
argument_list|(
name|str
argument_list|,
literal|1
argument_list|,
name|sys_nsig
operator|-
literal|1
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|==
name|NULL
condition|)
return|return
operator|(
name|sig
operator|)
return|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|str
argument_list|,
literal|"SIG"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|str
operator|+=
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|sys_nsig
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
name|sys_signame
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|i
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

