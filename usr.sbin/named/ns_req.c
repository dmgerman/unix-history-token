begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_req.c	4.47 (Berkeley) 7/1/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1986, 1988, 1990  * -  * Copyright (c) 1986, 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_struct
struct|struct
name|addinfo
block|{
name|char
modifier|*
name|a_dname
decl_stmt|;
comment|/* domain name */
name|char
modifier|*
name|a_rname
decl_stmt|;
comment|/* referred by */
name|u_int16_t
name|a_rtype
decl_stmt|;
comment|/* referred by */
name|u_int16_t
name|a_class
decl_stmt|;
comment|/* class for address */
block|}
struct|;
end_struct

begin_enum
enum|enum
name|req_action
block|{
name|Finish
block|,
name|Refuse
block|,
name|Return
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|req_action
name|req_query
name|__P
argument_list|(
operator|(
name|HEADER
operator|*
name|hp
operator|,
name|u_char
operator|*
operator|*
name|cpp
operator|,
name|u_char
operator|*
name|eom
operator|,
expr|struct
name|qstream
operator|*
name|qsp
operator|,
name|int
operator|*
name|buflenp
operator|,
name|int
operator|*
name|msglenp
operator|,
name|u_char
operator|*
name|msg
operator|,
name|int
name|dfd
operator|,
expr|struct
name|sockaddr_in
operator|*
name|from
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|req_action
name|req_iquery
name|__P
argument_list|(
operator|(
name|HEADER
operator|*
name|hp
operator|,
name|u_char
operator|*
operator|*
name|cpp
operator|,
name|u_char
operator|*
name|eom
operator|,
name|int
operator|*
name|buflenp
operator|,
name|u_char
operator|*
name|msg
operator|,
expr|struct
name|sockaddr_in
operator|*
name|from
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_decl_stmt
specifier|static
name|enum
name|req_action
name|req_notify
name|__P
argument_list|(
operator|(
name|HEADER
operator|*
name|hp
operator|,
name|u_char
operator|*
operator|*
name|cpp
operator|,
name|u_char
operator|*
name|eom
operator|,
name|u_char
operator|*
name|msg
operator|,
expr|struct
name|sockaddr_in
operator|*
name|from
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|fwritemsg
name|__P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
ifdef|#
directive|ifdef
name|DEBUG
name|printSOAdata
name|__P
argument_list|(
operator|(
expr|struct
name|databuf
operator|)
argument_list|)
decl_stmt|,
endif|#
directive|endif
name|doaxfr
name|__P
argument_list|(
operator|(
expr|struct
name|namebuf
operator|*
operator|,
name|FILE
operator|*
operator|,
expr|struct
name|namebuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|startxfr
name|__P
argument_list|(
operator|(
expr|struct
name|qstream
operator|*
operator|,
expr|struct
name|namebuf
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|InitDynUpdate
name|__P
argument_list|(
operator|(
specifier|register
name|HEADER
operator|*
name|hp
operator|,
name|char
operator|*
name|msg
operator|,
name|int
name|msglen
operator|,
name|u_char
operator|*
name|startcp
operator|,
expr|struct
name|sockaddr_in
operator|*
name|from
operator|,
expr|struct
name|qstream
operator|*
name|qsp
operator|,
name|int
name|dfd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|addinfo
name|addinfo
index|[
name|NADDRECS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|addname
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|u_int16_t
operator|,
name|u_int16_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Process request using database; assemble and send response.  */
end_comment

begin_function
name|void
name|ns_req
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|buflen
parameter_list|,
name|qsp
parameter_list|,
name|from
parameter_list|,
name|dfd
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|,
name|buflen
decl_stmt|;
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
name|int
name|dfd
decl_stmt|;
block|{
specifier|register
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
name|enum
name|req_action
name|action
decl_stmt|;
name|int
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"ns_req(from=%s)\n"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|fp_nquery
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * XXX - this decision should be made by our caller, not by us. 	 */
if|if
condition|(
name|hp
operator|->
name|qr
condition|)
block|{
name|ns_resp
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
comment|/* Now is a safe time for housekeeping */
if|if
condition|(
name|needs_prime_cache
condition|)
name|prime_cache
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* it's not a response so these bits have no business 	 * being set. will later simplify work if we can 	 * safely assume these are always 0 when a query 	 * comes in. 	 */
name|hp
operator|->
name|aa
operator|=
name|hp
operator|->
name|ra
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|eom
operator|=
name|msg
operator|+
name|msglen
expr_stmt|;
name|buflen
operator|-=
name|HFIXEDSZ
expr_stmt|;
name|free_addinfo
argument_list|()
expr_stmt|;
comment|/* sets addcount to zero */
name|dnptrs
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|opcode
condition|)
block|{
case|case
name|QUERY
case|:
name|action
operator|=
name|req_query
argument_list|(
name|hp
argument_list|,
operator|&
name|cp
argument_list|,
name|eom
argument_list|,
name|qsp
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|msglen
argument_list|,
name|msg
argument_list|,
name|dfd
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
case|case
name|IQUERY
case|:
name|action
operator|=
name|req_iquery
argument_list|(
name|hp
argument_list|,
operator|&
name|cp
argument_list|,
name|eom
argument_list|,
operator|&
name|buflen
argument_list|,
name|msg
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
case|case
name|NS_NOTIFY_OP
case|:
name|action
operator|=
name|req_notify
argument_list|(
name|hp
argument_list|,
operator|&
name|cp
argument_list|,
name|eom
argument_list|,
name|msg
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
define|#
directive|define
name|FORWARDED
value|1000
comment|/*  * In a sense the following constant should be defined in<arpa/nameser.h>,  * since it is returned here in place of a response code if the update was  * forwarded, and the response codes are defined in nameser.h.  On the other  * hand, though, this constant is only seen in this file.  The assumption  * here is that none of the other return codes equals this one (a good  * assumption, since they only occupy 4 bits over-the-wire)  */
comment|/* Call InitDynUpdate for all dynamic update requests */
case|case
name|UPDATEM
case|:
case|case
name|UPDATEMA
case|:
case|case
name|UPDATED
case|:
case|case
name|UPDATEDA
case|:
case|case
name|UPDATEA
case|:
name|n
operator|=
name|InitDynUpdate
argument_list|(
name|hp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
name|cp
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|FORWARDED
condition|)
block|{
comment|/* Return directly because InitDynUpdate 			 * forwarded the query to the primary, so we 			 * will send response later 			 */
name|action
operator|=
name|Return
expr_stmt|;
block|}
else|else
block|{
comment|/* Either sucessful primary update or failure; 			 * return response code to client 			 */
name|action
operator|=
name|Finish
expr_stmt|;
block|}
case|case
name|ZONEREF
case|:
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"Refresh Zone\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
endif|#
directive|endif
comment|/* ALLOW_UPDATES */
default|default:
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_req: Opcode %d not implemented\n"
operator|,
name|hp
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX - should syslog, limited by haveComplained */
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOTIMP
expr_stmt|;
name|action
operator|=
name|Finish
expr_stmt|;
block|}
comment|/* 	 * vector via internal opcode.  (yes, it was even uglier before.) 	 */
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|Return
case|:
return|return;
case|case
name|Refuse
case|:
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|Finish
case|:
comment|/* rest of the function handles this case */
break|break;
default|default:
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"ns_req: bad action variable"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* 	 * apply final polish 	 */
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
comment|/* set Response flag */
name|hp
operator|->
name|ra
operator|=
operator|(
name|NoRecurse
operator|==
literal|0
operator|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|n
operator|=
name|doaddinfo
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_req: answer -> %s fd=%d id=%d size=%d %s\n"
operator|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
operator|,
operator|(
name|qsp
operator|==
name|QSTREAM_NULL
operator|)
condition|?
name|dfd
else|:
name|qsp
operator|->
name|s_rfd
operator|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
operator|,
name|cp
operator|-
name|msg
operator|,
name|local
argument_list|(
name|from
argument_list|)
operator|==
name|NULL
condition|?
literal|"Remote"
else|:
literal|"Local"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qsp
operator|==
name|QSTREAM_NULL
condition|)
block|{
if|if
condition|(
name|sendto
argument_list|(
name|dfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|from
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|from
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|sendtoStr
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ns_req: sendto(%s): %m"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
block|}
name|nameserIncr
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|nssSentAns
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XSTATS
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
condition|)
name|nameserIncr
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|nssSentNXD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
condition|)
name|nameserIncr
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|nssSentNaAns
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
operator|(
name|void
operator|)
name|writemsg
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|)
expr_stmt|;
name|sq_done
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needs_prime_cache
condition|)
block|{
name|prime_cache
argument_list|()
expr_stmt|;
comment|/* Now is a safe time */
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_function
name|int
name|findZonePri
parameter_list|(
name|zp
parameter_list|,
name|from
parameter_list|)
specifier|register
specifier|const
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
block|{
specifier|register
name|u_int32_t
name|from_addr
init|=
name|from
operator|->
name|sin_addr
operator|.
name|s_addr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int
operator|)
name|i
operator|<
name|zp
operator|->
name|z_addrcnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|zp
operator|->
name|z_addr
index|[
name|i
index|]
operator|.
name|s_addr
operator|==
name|from_addr
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|req_action
name|req_notify
parameter_list|(
name|hp
parameter_list|,
name|cpp
parameter_list|,
name|eom
parameter_list|,
name|msg
parameter_list|,
name|from
parameter_list|)
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|cpp
decl_stmt|,
decl|*
name|eom
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|,
name|type
decl_stmt|,
name|class
decl_stmt|,
name|zn
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
comment|/* lookup relative to root */
comment|/* valid notify's have one question and zero answers */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|!=
literal|1
operator|)
operator|||
name|hp
operator|->
name|ancount
operator|||
name|hp
operator|->
name|nscount
operator|||
name|hp
operator|->
name|arcount
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR Notify header counts wrong\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
operator|*
name|cpp
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
name|dnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR Query expand name failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"rcvd NOTIFY(%s %s %s)"
argument_list|,
name|dnbuf
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX - when answers are allowed, we'll need to do compression 	 * correctly here, and we will need to check for packet underflow. 	 */
name|np
operator|=
name|nlookup
argument_list|(
name|dnbuf
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"rcvd NOTIFY for \"%s\", name not in cache"
argument_list|,
name|dnbuf
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|zn
operator|=
name|findMyZone
argument_list|(
name|np
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|zn
operator|==
name|DB_Z_CACHE
operator|||
name|zones
index|[
name|zn
index|]
operator|.
name|z_type
operator|!=
name|Z_SECONDARY
condition|)
block|{
comment|/* this can come if a user did an AXFR of some zone somewhere 		 * and that zone's server now wants to tell us that the SOA 		 * has changed.  AXFR's always come from nonpriv ports so it 		 * isn't possible to know whether it was the server or just 		 * "dig".  this condition can be avoided by using secure zones 		 * since that way only real secondaries can AXFR from you. 		 */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NOTIFY for non-secondary name (%s), from %s"
argument_list|,
name|dnbuf
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
if|if
condition|(
name|findZonePri
argument_list|(
operator|&
name|zones
index|[
name|zn
index|]
argument_list|,
name|from
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NOTIFY from non-master server (zone %s), from %s"
argument_list|,
name|zones
index|[
name|zn
index|]
operator|.
name|z_origin
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_SOA
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|dnbuf
argument_list|,
name|zones
index|[
name|zn
index|]
operator|.
name|z_origin
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NOTIFY(SOA) for non-origin (%s), from %s"
argument_list|,
name|dnbuf
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
if|if
condition|(
name|zones
index|[
name|zn
index|]
operator|.
name|z_flags
operator|&
operator|(
name|Z_NEED_RELOAD
operator||
name|Z_NEED_XFER
operator||
name|Z_QSERIAL
operator||
name|Z_XFER_RUNNING
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NOTIFY(SOA) for zone already xferring (%s)"
argument_list|,
name|dnbuf
argument_list|)
expr_stmt|;
goto|goto
name|noerror
goto|;
block|}
name|zones
index|[
name|zn
index|]
operator|.
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|qserial_query
argument_list|(
operator|&
name|zones
index|[
name|zn
index|]
argument_list|)
expr_stmt|;
comment|/* XXX: qserial_query() can fail due to queue full condition; 		 *	we should detect that case here and do something. 		 */
break|break;
default|default:
comment|/* unimplemented, but it's not a protocol error, just 		 * something to be ignored. 		 */
break|break;
block|}
name|noerror
label|:
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
name|refuse
label|:
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*BIND_NOTIFY*/
end_comment

begin_function
specifier|static
name|enum
name|req_action
name|req_query
parameter_list|(
name|hp
parameter_list|,
name|cpp
parameter_list|,
name|eom
parameter_list|,
name|qsp
parameter_list|,
name|buflenp
parameter_list|,
name|msglenp
parameter_list|,
name|msg
parameter_list|,
name|dfd
parameter_list|,
name|from
parameter_list|)
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|u_char
modifier|*
name|eom
decl_stmt|;
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
modifier|*
name|buflenp
decl_stmt|,
decl|*
name|msglenp
decl_stmt|,
name|dfd
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|,
name|count
decl_stmt|,
name|foundname
decl_stmt|,
name|founddata
decl_stmt|,
name|omsglen
decl_stmt|,
name|cname
decl_stmt|;
name|u_int16_t
name|id
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|dpp
decl_stmt|,
modifier|*
name|omsg
decl_stmt|,
modifier|*
name|answers
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|anp
decl_stmt|;
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|lp
decl_stmt|;
ifdef|#
directive|ifdef
name|SECURE_ZONES
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
endif|#
directive|endif
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|nssRcvdQ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XSTATS
comment|/* Statistics for queries coming from port<> 53, suspect some kind of forwarder */
if|if
condition|(
name|from
operator|->
name|sin_port
operator|!=
name|ns_port
condition|)
name|nameserIncr
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|nssNotNsQ
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|dpp
operator|=
name|dnptrs
expr_stmt|;
operator|*
name|dpp
operator|++
operator|=
name|msg
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
comment|/* valid queries have one question and zero answers */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|!=
literal|1
operator|)
operator|||
name|hp
operator|->
name|ancount
operator|||
name|hp
operator|->
name|nscount
operator|||
name|hp
operator|->
name|arcount
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR Query header counts wrong\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 * Get domain name, class, and type. 	 */
if|if
condition|(
operator|(
operator|*
operator|*
name|cpp
operator|&
name|INDIR_MASK
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|dpp
operator|++
operator|=
operator|*
name|cpp
expr_stmt|;
comment|/* remember name for compression */
block|}
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
operator|*
name|cpp
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
name|dnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR Query expand name failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|>
name|eom
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR Query message length short\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|cpp
operator|<
name|eom
condition|)
block|{
name|dprintf
argument_list|(
literal|6
argument_list|,
operator|(
name|ddt
operator|,
literal|"message length> received message\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|msglenp
operator|=
operator|*
name|cpp
operator|-
name|msg
expr_stmt|;
block|}
name|qtypeIncr
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* 	 * Process query. 	 */
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
comment|/* refuse request if not a TCP connection */
if|if
condition|(
name|qsp
operator|==
name|QSTREAM_NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"rejected UDP AXFR from %s for \"%s\""
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dnbuf
condition|?
name|dnbuf
else|:
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
comment|/* the position of this is subtle. */
name|nameserIncr
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|nssRcvdAXFR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFRNETS
if|if
condition|(
name|xfrnets
condition|)
block|{
comment|/* if xfrnets was specified, peer address 			 * must be on it.  should probably allow 			 * for negation some day. 			 */
if|if
condition|(
operator|!
name|addr_on_netlist
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|xfrnets
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"unapproved AXFR from %s for %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dnbuf
condition|?
name|dnbuf
else|:
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/*XFRNETS*/
name|dnptrs
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* don't compress names */
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
comment|/* recursion not possible */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"approved AXFR from %s for \"%s\""
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dnbuf
condition|?
name|dnbuf
else|:
literal|"."
argument_list|)
expr_stmt|;
block|}
operator|*
name|buflenp
operator|-=
operator|*
name|msglenp
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|foundname
operator|=
literal|0
expr_stmt|;
name|founddata
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|dnbuf
expr_stmt|;
name|cname
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QRYLOG
if|if
condition|(
name|qrylog
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"XX /%s/%s/%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
literal|"."
else|:
name|dname
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*QRYLOG*/
name|try_again
label|:
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: nlookup(%s) id %d type=%d class=%d\n"
operator|,
name|dname
operator|,
name|hp
operator|->
name|id
operator|,
name|type
operator|,
name|class
operator|)
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* lookup relative to root */
if|if
condition|(
operator|(
name|anp
operator|=
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fname
operator|=
literal|""
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: %s '%s' as '%s' (cname=%d)\n"
operator|,
name|np
operator|==
name|NULL
condition|?
literal|"missed"
else|:
literal|"found"
operator|,
name|dname
operator|,
name|fname
operator|,
name|cname
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCALDOM
comment|/* 	 * if nlookup failed to find the name then 	 * see if there are any '.''s in the name 	 * if not then add local domain name to the 	 * name and try again. 	 */
if|if
condition|(
operator|!
name|np
operator|&&
name|localdomain
operator|&&
operator|!
name|strchr
argument_list|(
name|dname
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|dname
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|dname
argument_list|,
name|localdomain
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: nlookup(%s) type=%d\n"
operator|,
name|dname
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*LOCALDOM*/
ifdef|#
directive|ifdef
name|YPKLUDGE
comment|/* Some braindamaged resolver software will not 	   recognize internet addresses in dot notation and 	   send out address  queries for "names" such as 	   128.93.8.1.  This kludge will prevent those 	   from flooding higher level servers. 	   We simply claim to be authoritative and that 	   the domain doesn't exist. 	   Note that we could return the address but we 	   don't do that in order to encourage that broken 	   software is fixed. 	*/
if|if
condition|(
operator|!
name|np
operator|&&
name|type
operator|==
name|T_A
operator|&&
name|class
operator|==
name|C_IN
operator|&&
name|dname
condition|)
block|{
name|struct
name|in_addr
name|ina
decl_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|dname
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"ypkludge: hit as '%s'\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/*YPKLUDGE*/
if|if
condition|(
operator|(
operator|!
name|np
operator|)
operator|||
operator|(
name|fname
operator|!=
name|dname
operator|)
condition|)
goto|goto
name|fetchns
goto|;
ifdef|#
directive|ifdef
name|SECURE_ZONES
comment|/* (gdmr) Make sure the class is correct.  If we have the same name 	 * with more than one class then we can't refuse a request for one 	 * class just because another class is blocked.  We *really* ought 	 * to look for the correct type too, but since everything in a 	 * particular class of zone has the same secure_zone attribute it 	 * doesn't really matter which type we use!  Alternatively, this lot 	 * could all be moved to after the finddata(), by which time only 	 * the correct class/type combinations will be left. 	 */
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|&&
operator|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|)
condition|)
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
if|if
condition|(
name|dp
condition|)
block|{
name|zp
operator|=
operator|&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|secure_nets
operator|&&
operator|!
name|addr_on_netlist
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|zp
operator|->
name|secure_nets
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Unauthorized request %s from %s"
argument_list|,
name|dname
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: refuse %s from %s class %d (%d)\n"
operator|,
name|dname
operator|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
operator|,
name|class
operator|,
name|zp
operator|->
name|z_class
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|foundname
operator|++
expr_stmt|;
name|answers
operator|=
operator|*
name|cpp
expr_stmt|;
name|count
operator|=
operator|*
name|cpp
operator|-
name|msg
expr_stmt|;
ifdef|#
directive|ifdef
name|NCACHE
comment|/* Look for NXDOMAIN record with appropriate class 	 * if found return immediately 	 */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|stale
argument_list|(
name|dp
argument_list|)
operator|&&
operator|(
name|dp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_class
operator|==
name|class
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|RETURNSOA
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
name|buflenp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
comment|/* this should not occur */
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
operator|*
name|msglenp
operator|+=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
comment|/* if not NXDOMAIN, the NOERROR_NODATA record might be 	 * anywhere in the chain. have to go through the grind. 	 */
endif|#
directive|endif
comment|/*NCACHE*/
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
name|buflenp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* NO data available.  Refuse AXFR requests, or 		 * look for better servers for other requests. 		 */
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"T_AXFR refused: no data\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
else|else
block|{
goto|goto
name|fetchns
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|founddata
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
endif|#
directive|endif
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
operator|*
name|msglenp
operator|+=
name|n
expr_stmt|;
name|hp
operator|->
name|ancount
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|dname
operator|&&
name|type
operator|!=
name|T_CNAME
operator|&&
name|type
operator|!=
name|T_ANY
condition|)
block|{
if|if
condition|(
name|cname
operator|++
operator|>=
name|MAXCNAMES
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, MAXCNAMES exceeded\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
goto|goto
name|try_again
goto|;
block|}
name|founddata
operator|=
literal|1
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: foundname=%d, count=%d, founddata=%d, cname=%d\n"
operator|,
name|foundname
operator|,
name|count
operator|,
name|founddata
operator|,
name|cname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|local
argument_list|(
name|from
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sort_response
argument_list|(
name|answers
argument_list|,
name|count
argument_list|,
name|lp
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
if|if
condition|(
name|type
operator|==
name|T_SOA
operator|&&
name|from
operator|->
name|sin_port
operator|==
name|ns_port
operator|&&
name|np
operator|->
name|n_data
condition|)
block|{
name|int
name|zn
init|=
name|np
operator|->
name|n_data
operator|->
name|d_zone
decl_stmt|;
if|if
condition|(
name|zn
operator|!=
name|DB_Z_CACHE
condition|)
block|{
name|struct
name|notify
modifier|*
name|ap
decl_stmt|;
comment|/* Old? */
name|ap
operator|=
name|findNotifyPeer
argument_list|(
operator|&
name|zones
index|[
name|zn
index|]
argument_list|,
name|from
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
comment|/* New? */
if|if
condition|(
operator|!
name|ap
operator|&&
operator|(
name|ap
operator|=
operator|(
expr|struct
name|notify
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ap
argument_list|)
operator|)
condition|)
block|{
name|ap
operator|->
name|addr
operator|=
name|from
operator|->
name|sin_addr
expr_stmt|;
name|ap
operator|->
name|next
operator|=
name|zones
index|[
name|zn
index|]
operator|.
name|z_notifylist
expr_stmt|;
name|zones
index|[
name|zn
index|]
operator|.
name|z_notifylist
operator|=
name|ap
expr_stmt|;
block|}
comment|/* Old or New? */
if|if
condition|(
name|ap
condition|)
name|ap
operator|->
name|last
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*BIND_NOTIFY*/
if|if
condition|(
name|type
operator|==
name|T_AXFR
condition|)
block|{
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|startxfr
argument_list|(
name|qsp
argument_list|,
name|np
argument_list|,
name|msg
argument_list|,
operator|*
name|cpp
operator|-
name|msg
argument_list|,
name|class
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|sqrm
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Return
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * If we found an authoritative answer, 	 * we're done. 	 */
if|if
condition|(
name|hp
operator|->
name|aa
condition|)
return|return
operator|(
name|Finish
operator|)
return|;
endif|#
directive|endif
name|fetchns
label|:
comment|/*  	 * Look for name servers to refer to and fill in the authority  	 * section or record the address for forwarding the query  	 * (recursion desired).  	 */
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* We are authoritative for this np. */
if|if
condition|(
operator|!
name|foundname
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: leaving (%s, rcode %d)\n"
operator|,
name|dname
operator|,
name|hp
operator|->
name|rcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|C_ANY
condition|)
block|{
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX:	should return SOA if founddata == 0, 			 *	but old named's are confused by an SOA 			 *	in the auth. section if there's no error. 			 */
if|if
condition|(
name|foundname
operator|==
literal|0
operator|&&
name|np
condition|)
block|{
name|n
operator|=
name|doaddauth
argument_list|(
name|hp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
name|np
argument_list|,
name|nsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDAUTH
block|}
elseif|else
if|if
condition|(
name|hp
operator|->
name|ancount
condition|)
block|{
comment|/* don't add NS records for NOERROR NODATA 				   as some servers can get confused */
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
case|case
name|SERVFAIL
case|:
break|break;
default|default:
if|if
condition|(
name|np
operator|&&
operator|(
name|type
operator|!=
name|T_NS
operator|||
name|np
operator|!=
name|anp
operator|)
condition|)
block|{
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*ADDAUTH*/
block|}
block|}
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|Finish
operator|)
return|;
case|case
name|SERVFAIL
case|:
comment|/* We're authoritative but the zone isn't loaded. */
if|if
condition|(
operator|!
name|founddata
operator|&&
operator|!
operator|(
name|forward_only
operator|&&
name|fwdtab
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
comment|/* 	 *  If we successfully found the answer in the cache, 	 *  or this is not a recursive query, or we are purposely 	 *  never recursing, then add the nameserver references 	 *  ("authority section") here and we're done. 	 */
if|if
condition|(
name|founddata
operator|||
operator|(
operator|!
name|hp
operator|->
name|rd
operator|)
operator|||
name|NoRecurse
condition|)
block|{
comment|/* If the qtype was NS, and the np of the authority is 		 * the same as the np of the data, we don't need to add 		 * another copy of the answer here in the authority 		 * section. 		 */
if|if
condition|(
operator|!
name|founddata
operator|||
name|type
operator|!=
name|T_NS
operator|||
name|anp
operator|!=
name|np
condition|)
block|{
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Our caller will handle the Additional section. */
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 *  At this point, we don't have the answer, but we do 	 *  have some NS's to try.  If the user would like us 	 *  to recurse, create the initial query.  If a cname 	 *  is involved, we need to build a new query and save 	 *  the old one in cmsg/cmsglen. 	 */
if|if
condition|(
name|cname
condition|)
block|{
name|omsg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
operator|*
name|msglenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|omsg
operator|==
operator|(
name|u_char
operator|*
operator|)
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ns_req: Out Of Memory"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|id
operator|=
name|hp
operator|->
name|id
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|omsglen
operator|=
operator|*
name|msglenp
expr_stmt|;
name|bcopy
argument_list|(
name|msg
argument_list|,
name|omsg
argument_list|,
name|omsglen
argument_list|)
expr_stmt|;
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|msg
argument_list|,
operator|*
name|msglenp
operator|+
operator|*
name|buflenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"res_mkquery(%s) failed"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|msglenp
operator|=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|ns_forw
argument_list|(
name|nsp
argument_list|,
name|msg
argument_list|,
operator|*
name|msglenp
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
operator|&
name|qp
argument_list|,
name|dname
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|FW_OK
operator|&&
name|cname
condition|)
name|free
argument_list|(
name|omsg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|FW_OK
case|:
if|if
condition|(
name|cname
condition|)
block|{
name|qp
operator|->
name|q_cname
operator|=
name|cname
expr_stmt|;
name|qp
operator|->
name|q_cmsg
operator|=
name|omsg
expr_stmt|;
name|qp
operator|->
name|q_cmsglen
operator|=
name|omsglen
expr_stmt|;
name|qp
operator|->
name|q_id
operator|=
name|id
expr_stmt|;
block|}
break|break;
case|case
name|FW_DUP
case|:
break|break;
comment|/* Duplicate request dropped */
case|case
name|FW_NOSERVER
case|:
comment|/* 		** Don't go into an infinite loop if 		** the admin gave root NS records in the cache 		** file without giving address records 		** for the root servers. 		*/
if|if
condition|(
name|np
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ns_req: no address for root server"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|Finish
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|VALIDATE
comment|/* 			 * we need to kill all the NS records here as 			 * validate will fail as we are talking to the parent 			 * server 			 */
name|delete_all
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|np
operator|=
name|np
operator|->
name|n_parent
expr_stmt|;
block|}
goto|goto
name|fetchns
goto|;
comment|/* Try again. */
case|case
name|FW_SERVFAIL
case|:
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|Finish
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|Return
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|enum
name|req_action
name|req_iquery
parameter_list|(
name|hp
parameter_list|,
name|cpp
parameter_list|,
name|eom
parameter_list|,
name|buflenp
parameter_list|,
name|msg
parameter_list|,
name|from
parameter_list|)
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|cpp
decl_stmt|,
decl|*
name|eom
decl_stmt|;
end_function

begin_decl_stmt
name|int
modifier|*
name|buflenp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dlen
decl_stmt|,
name|alen
decl_stmt|,
name|n
decl_stmt|,
name|type
decl_stmt|,
name|class
decl_stmt|,
name|count
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|anbuf
index|[
name|PACKETSZ
index|]
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|,
name|nssRcvdIQ
argument_list|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|->
name|ancount
operator|!=
literal|1
operator|)
operator|||
name|hp
operator|->
name|qdcount
operator|||
name|hp
operator|->
name|nscount
operator|||
name|hp
operator|->
name|arcount
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR IQuery header counts wrong\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 * Skip domain name, get class, and type. 	 */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
operator|*
name|cpp
argument_list|,
name|eom
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR IQuery packet name problem\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|dlen
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|!=
name|eom
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR IQuery message length off\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 * not all inverse queries are handled. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
ifndef|#
directive|ifndef
name|INVQ
if|if
condition|(
operator|!
name|fake_iquery
condition|)
return|return
operator|(
name|Refuse
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INVQ
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
endif|#
directive|endif
break|break;
default|default:
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: IQuery class %d type %d\n"
operator|,
name|class
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|bcopy
argument_list|(
name|fname
argument_list|,
name|anbuf
argument_list|,
name|alen
operator|=
operator|(
name|char
operator|*
operator|)
operator|*
name|cpp
operator|-
name|fname
argument_list|)
expr_stmt|;
name|data
operator|=
name|anbuf
operator|+
name|alen
operator|-
name|dlen
expr_stmt|;
operator|*
name|cpp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|fname
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|HFIXEDSZ
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QRYLOG
if|if
condition|(
name|qrylog
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"XX /%s/%s/-%s"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|inet_ntoa
argument_list|(
name|data_inaddr
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*QRYLOG*/
ifdef|#
directive|ifdef
name|INVQ
block|{
specifier|register
name|struct
name|invbuf
modifier|*
name|ip
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|invtab
index|[
name|dhash
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
name|dlen
argument_list|)
index|]
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INVBLKSZ
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|ip
operator|->
name|i_dname
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
break|break;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"dname = %d\n"
operator|,
name|np
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_size
operator|!=
name|dlen
operator|||
name|bcmp
argument_list|(
name|dp
operator|->
name|d_data
argument_list|,
name|data
argument_list|,
name|dlen
argument_list|)
condition|)
continue|continue;
name|getname
argument_list|(
name|np
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: IQuery found %s\n"
operator|,
name|dnbuf
operator|)
argument_list|)
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|QFIXEDSZ
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
name|dnbuf
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
else|#
directive|else
comment|/*INVQ*/
comment|/* 	 * We can only get here if we are compiled without INVQ (the default) 	 * and the type is T_A and the option "fake-iquery" is on in the boot 	 * file. 	 * 	 * What we do here is send back a bogus response of "[dottedquad]". 	 * A better strategy would be to turn this into a PTR query, but that 	 * would legitimize inverse queries in a way they do not deserve. 	 */
name|sprintf
argument_list|(
name|dnbuf
argument_list|,
literal|"[%s]"
argument_list|,
name|inet_ntoa
argument_list|(
name|data_inaddr
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|QFIXEDSZ
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
name|dnbuf
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/*INVQ*/
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: IQuery %d records\n"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|alen
operator|>
operator|*
name|buflenp
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|anbuf
argument_list|,
operator|*
name|cpp
argument_list|,
name|alen
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|alen
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|fwritemsg
parameter_list|(
name|rfp
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|FILE
modifier|*
name|rfp
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
block|{
name|u_char
name|len
index|[
name|INT16SZ
index|]
decl_stmt|;
name|__putshort
argument_list|(
name|msglen
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|len
argument_list|,
name|INT16SZ
argument_list|,
literal|1
argument_list|,
name|rfp
argument_list|)
operator|!=
literal|1
operator|||
name|fwrite
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|msglen
argument_list|,
literal|1
argument_list|,
name|rfp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fwritemsg: %m"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Test a datum for validity and return non-zero if it is out of date.  */
end_comment

begin_function
name|int
name|stale
parameter_list|(
name|dp
parameter_list|)
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
block|{
specifier|register
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
operator|&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
decl_stmt|;
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_PRIMARY
case|:
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|STUBS
case|case
name|Z_STUB
case|:
comment|/* root stub zones have DB_F_HINT set */
if|if
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FALLTROUGH */
endif|#
directive|endif
case|case
name|Z_SECONDARY
case|:
comment|/* 		 * Check to see whether a secondary zone 		 * has expired; if so clear authority flag 		 * for zone and return true.  If lastupdate 		 * is in the future, assume zone is up-to-date. 		 */
if|if
condition|(
call|(
name|int32_t
call|)
argument_list|(
name|tt
operator|.
name|tv_sec
operator|-
name|zp
operator|->
name|z_lastupdate
argument_list|)
operator|>
operator|(
name|int32_t
operator|)
name|zp
operator|->
name|z_expire
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"stale: secondary zone %s expired\n"
operator|,
name|zp
operator|->
name|z_origin
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stale
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"secondary zone \"%s\" expired"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_AUTH
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_lastupdate
operator|>
name|tt
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|stale
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"secondary zone \"%s\" time warp"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_AUTH
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|Z_CACHE
case|:
if|if
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|||
name|dp
operator|->
name|d_ttl
operator|>=
name|tt
operator|.
name|tv_sec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"stale: ttl %d %d (x%lx)\n"
operator|,
name|dp
operator|->
name|d_ttl
operator|,
name|dp
operator|->
name|d_ttl
operator|-
name|tt
operator|.
name|tv_sec
operator|,
operator|(
name|u_long
operator|)
name|dp
operator|->
name|d_flags
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
comment|/* FALLTHROUGH */
empty_stmt|;
block|}
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"stale: impossible condition"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Copy databuf into a resource record for replies.  * Return size of RR if OK, -1 if buffer is full.  */
end_comment

begin_function
name|int
name|make_rr
parameter_list|(
name|name
parameter_list|,
name|dp
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|,
name|doadd
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|doadd
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
specifier|register
name|int32_t
name|n
decl_stmt|;
specifier|register
name|int32_t
name|ttl
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|edp
init|=
name|dnptrs
operator|+
sizeof|sizeof
name|dnptrs
operator|/
sizeof|sizeof
name|dnptrs
index|[
literal|0
index|]
decl_stmt|;
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"make_rr(%s, %lx, %lx, %d, %d) %d zone %d ttl %d\n"
operator|,
name|name
operator|,
operator|(
name|u_long
operator|)
name|dp
operator|,
operator|(
name|u_long
operator|)
name|buf
operator|,
name|buflen
operator|,
name|doadd
operator|,
name|dp
operator|->
name|d_size
operator|,
name|dp
operator|->
name|d_zone
operator|,
name|dp
operator|->
name|d_ttl
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
ifdef|#
directive|ifdef
name|RETURNSOA
operator|&&
name|dp
operator|->
name|d_rcode
operator|!=
name|NXDOMAIN
endif|#
directive|endif
condition|)
block|{
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"make_rr: impossible d_rcode value"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|zp
operator|=
operator|&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
expr_stmt|;
comment|/* check for outdated RR before updating dnptrs by dn_comp() (?) */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_CACHE
condition|)
block|{
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
operator|-
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|||
operator|(
name|ttl
operator|<
literal|0
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"make_rr: %d=>0, %#lx\n"
operator|,
name|ttl
operator|,
operator|(
name|u_long
operator|)
name|dp
operator|->
name|d_flags
operator|)
argument_list|)
expr_stmt|;
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|->
name|d_ttl
condition|)
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
expr_stmt|;
else|else
name|ttl
operator|=
name|zp
operator|->
name|z_minimum
expr_stmt|;
comment|/* really default */
ifdef|#
directive|ifdef
name|notdef
comment|/* don't decrease ttl based on time since verification */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_SECONDARY
condition|)
block|{
comment|/* 			 * Set ttl to value received from primary, 			 * less time since we verified it (but never 			 * less than a small positive value). 			 */
name|ttl
operator|-=
name|tt
operator|.
name|tv_sec
operator|-
name|zp
operator|->
name|z_lastupdate
expr_stmt|;
if|if
condition|(
name|ttl
operator|<=
literal|0
condition|)
name|ttl
operator|=
literal|120
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|buflen
operator|-=
name|RRFIXEDSZ
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|RETURNSOA
argument_list|)
operator|&&
name|defined
argument_list|(
name|NCACHE
argument_list|)
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
condition|)
block|{
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
name|name
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|+=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|buf
operator|+
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_CNAME
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_MB
case|:
case|case
name|T_NS
case|:
comment|/* Store domain name in answer */
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|doadd
condition|)
name|addname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|name
argument_list|,
name|dp
operator|->
name|d_type
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|?
name|n
operator|+
literal|5
operator|*
name|INT32SZ
else|:
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|)
block|{
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
operator|(
name|n
operator|=
literal|5
operator|*
name|INT32SZ
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
comment|/* cp1 == our data/ cp == data of RR */
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|-=
name|INT16SZ
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* copy preference */
name|bcopy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length */
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|doadd
condition|)
name|addname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|name
argument_list|,
name|dp
operator|->
name|d_type
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|-=
name|INT16SZ
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* copy preference */
name|bcopy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|dnptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length */
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|dp
operator|->
name|d_size
operator|>
name|buflen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bcopy
argument_list|(
name|dp
operator|->
name|d_data
argument_list|,
name|cp
argument_list|,
name|dp
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_size
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dp
operator|->
name|d_size
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|-
name|buf
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|void
name|addname
argument_list|(
specifier|register
specifier|const
name|char
operator|*
name|dname
argument_list|,
specifier|register
specifier|const
name|char
operator|*
name|rname
argument_list|,
name|u_int16_t
name|rtype
argument_list|,
name|u_int16_t
name|class
argument_list|)
else|#
directive|else
decl|static
name|void
name|addname
argument_list|(
name|dname
argument_list|,
name|rname
argument_list|,
name|rtype
argument_list|,
name|class
argument_list|)
decl|register const
name|char
modifier|*
name|dname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
specifier|const
name|char
modifier|*
name|rname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16_t
name|rtype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16_t
name|class
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
operator|,
name|n
operator|=
name|addcount
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
name|dname
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* add domain name to additional section */
if|if
condition|(
name|addcount
operator|<
name|NADDRECS
condition|)
block|{
name|addcount
operator|++
expr_stmt|;
name|ap
operator|->
name|a_dname
operator|=
name|savestr
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_rname
operator|=
name|savestr
argument_list|(
name|rname
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_rtype
operator|=
name|rtype
expr_stmt|;
name|ap
operator|->
name|a_class
operator|=
name|class
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Lookup addresses for names in addinfo and put into the message's  * additional section.  */
end_comment

begin_function
name|int
name|doaddinfo
parameter_list|(
name|hp
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
block|{
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|n
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
operator|!
name|addcount
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaddinfo() addcount = %d\n"
operator|,
name|addcount
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
block|{
name|dprintf
argument_list|(
literal|4
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaddinfo(): tc already set, bailing\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|msg
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
init|;
operator|--
name|addcount
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
block|{
name|int
name|foundstale
init|=
literal|0
decl_stmt|,
name|foundany
init|=
literal|0
decl_stmt|,
name|foundcname
init|=
literal|0
decl_stmt|,
name|save_count
init|=
name|count
decl_stmt|,
name|save_msglen
init|=
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|save_cp
init|=
name|cp
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"do additional \"%s\" (from \"%s\")\n"
operator|,
name|ap
operator|->
name|a_dname
operator|,
name|ap
operator|->
name|a_rname
operator|)
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* because "nlookup" stomps on arg. */
name|np
operator|=
name|nlookup
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|ap
operator|->
name|a_dname
condition|)
goto|goto
name|next_rr
goto|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"found it\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* look for the data */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_CNAME
argument_list|)
operator|||
name|match
argument_list|(
name|dp
argument_list|,
name|C_IN
argument_list|,
name|T_CNAME
argument_list|)
condition|)
block|{
name|foundcname
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|foundany
operator|++
expr_stmt|;
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|foundstale
operator|++
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaddinfo: stale entry '%s'%s\n"
operator|,
name|np
operator|->
name|n_dname
operator|,
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|?
literal|" hint"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 *  Should be smart and eliminate duplicate 			 *  data here.	XXX 			 */
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* truncation in the additional-data section 				 * is not all that serious.  we do not set TC, 				 * since the answer and authority sections are 				 * OK; however, since we're not setting TC we 				 * have to make sure that none of the RR's for 				 * this name go out (!TC implies that all 				 * {name,type} appearances are complete -- and 				 * since we only do A RR's here, the name is 				 * the key).	vixie, 23apr93 				 */
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"addinfo: not enough room, remaining msglen = %d\n"
operator|,
name|save_msglen
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|save_cp
expr_stmt|;
name|msglen
operator|=
name|save_msglen
expr_stmt|;
name|count
operator|=
name|save_count
expr_stmt|;
break|break;
block|}
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"addinfo: adding address data n = %d\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|msglen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|next_rr
label|:
if|if
condition|(
name|foundstale
condition|)
block|{
comment|/* Cache invalidate the address RR's */
name|delete_all
argument_list|(
name|np
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
if|#
directive|if
literal|0
comment|/*XXX*/
condition|!NoRecurse&&
endif|#
directive|endif
operator|!
name|foundcname
operator|&&
operator|(
name|foundstale
operator|||
operator|!
name|foundany
operator|)
condition|)
block|{
comment|/* ask a real server for this info */
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|foundcname
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nhash
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nhash
argument_list|(
name|ap
operator|->
name|a_rname
argument_list|)
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"\"%s %s %s\" points to a CNAME (%s)"
argument_list|,
name|ap
operator|->
name|a_rname
argument_list|,
name|p_class
argument_list|(
name|ap
operator|->
name|a_class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|ap
operator|->
name|a_rtype
argument_list|)
argument_list|,
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
operator|->
name|a_rname
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|msg
operator|)
return|;
block|}
end_function

begin_function
name|int
name|doaddauth
parameter_list|(
name|hp
parameter_list|,
name|cp
parameter_list|,
name|buflen
parameter_list|,
name|np
parameter_list|,
name|dp
parameter_list|)
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
block|{
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaddauth: can't add stale '%s' (%d)\n"
operator|,
name|dnbuf
operator|,
name|buflen
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|n
operator|=
name|make_rr
argument_list|(
name|dnbuf
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaddauth: can't add oversize '%s' (%d) (n=%d)\n"
operator|,
name|dnbuf
operator|,
name|buflen
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a zone transfer (or a recursive part of a zone transfer).  * SOA record already sent.  *  * top always refers to the domain at the top of the zone being transferred.  * np refers to a domain inside the zone being transferred,  *	which will be equal to top if this is the first call,  *	or will be a subdomain below top if this is a recursive call,  * rfp is a stdio file to which output is sent.  */
end_comment

begin_function
specifier|static
name|void
name|doaxfr
parameter_list|(
name|np
parameter_list|,
name|rfp
parameter_list|,
name|top
parameter_list|,
name|class
parameter_list|)
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|FILE
modifier|*
name|rfp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|top
decl_stmt|;
name|int
name|class
decl_stmt|;
comment|/* Class to transfer */
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|gdp
decl_stmt|;
comment|/* glue databuf */
name|struct
name|namebuf
modifier|*
name|gnp
decl_stmt|;
comment|/* glue namebuf */
name|struct
name|namebuf
modifier|*
name|tnp
decl_stmt|;
comment|/* top namebuf */
name|struct
name|databuf
modifier|*
name|tdp
decl_stmt|;
comment|/* top databuf */
name|struct
name|namebuf
modifier|*
modifier|*
name|npp
decl_stmt|,
modifier|*
modifier|*
name|nppend
decl_stmt|;
name|u_char
name|msg
index|[
name|PACKETSZ
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|int
name|fndns
decl_stmt|;
if|if
condition|(
name|np
operator|==
name|top
condition|)
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"doaxfr()\n"
operator|)
argument_list|)
expr_stmt|;
name|fndns
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
name|hp
operator|->
name|opcode
operator|=
name|QUERY
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
name|dname
argument_list|)
expr_stmt|;
comment|/* first do the NS records (del@harris) */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
ifdef|#
directive|ifdef
name|GEN_AXFR
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
block|{
name|fndns
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
name|HFIXEDSZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
continue|continue;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|n
operator|+
name|HFIXEDSZ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_GLUE
if|if
condition|(
operator|(
name|np
operator|!=
name|top
operator|)
operator|||
operator|(
name|top
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
endif|#
directive|endif
comment|/*NO_GLUE*/
comment|/*  Glue the sub domains together by sending 		     *  the address records for the sub domain 		     *  name servers along if necessary. 		     *  Glue is necessary if the server is in any zone 		     *  delegated from the current (top) zone.  Such 		     *  a delegated zone might or might not be that 		     *  referred to by the NS record now being handled. 		     */
name|htp
operator|=
name|hashtab
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|msg
operator|+
name|HFIXEDSZ
operator|)
expr_stmt|;
name|gnp
operator|=
name|nlookup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnp
operator|==
name|NULL
operator|||
name|fname
operator|!=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NO_GLUE
for|for
control|(
name|tnp
operator|=
name|gnp
init|;
name|tnp
operator|!=
name|NULL
condition|;
name|tnp
operator|=
name|tnp
operator|->
name|n_parent
control|)
if|if
condition|(
name|tnp
operator|==
name|top
condition|)
break|break;
if|if
condition|(
operator|(
name|tnp
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|top
operator|->
name|n_dname
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|)
continue|continue;
comment|/* name server is not below top domain */
for|for
control|(
name|tnp
operator|=
name|gnp
init|;
name|tnp
operator|!=
name|NULL
operator|&&
name|tnp
operator|!=
name|top
condition|;
name|tnp
operator|=
name|tnp
operator|->
name|n_parent
control|)
block|{
for|for
control|(
name|tdp
operator|=
name|tnp
operator|->
name|n_data
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|d_next
control|)
block|{
ifdef|#
directive|ifdef
name|GEN_AXFR
if|if
condition|(
name|tdp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|tdp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
break|break;
block|}
if|if
condition|(
name|tdp
operator|!=
name|NULL
condition|)
break|break;
comment|/* found a zone cut */
block|}
if|if
condition|(
operator|(
name|tnp
operator|==
name|top
operator|)
operator|||
operator|(
operator|(
name|tnp
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|top
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
continue|continue;
comment|/* name server is not in a delegated zone */
comment|/* now we know glue records are needed.  send them. */
endif|#
directive|endif
comment|/*NO_GLUE*/
for|for
control|(
name|gdp
operator|=
name|gnp
operator|->
name|n_data
init|;
name|gdp
operator|!=
name|NULL
condition|;
name|gdp
operator|=
name|gdp
operator|->
name|d_next
control|)
block|{
ifdef|#
directive|ifdef
name|GEN_AXFR
if|if
condition|(
name|gdp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|gdp
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|stale
argument_list|(
name|gdp
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|gdp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
name|n
operator|=
name|make_rr
argument_list|(
name|fname
argument_list|,
name|gdp
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
name|HFIXEDSZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
continue|continue;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|n
operator|+
name|HFIXEDSZ
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NO_GLUE
block|}
endif|#
directive|endif
comment|/*NO_GLUE*/
block|}
block|}
comment|/* no need to send anything else if a delegation appeared */
if|if
condition|(
operator|(
name|np
operator|!=
name|top
operator|)
operator|&&
name|fndns
condition|)
return|return;
comment|/* do the rest of the data records */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
ifdef|#
directive|ifdef
name|GEN_AXFR
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
continue|continue;
endif|#
directive|endif
comment|/* 		 * Skip the top SOA record (marks end of data); 		 * don't send SOA for subdomains, as we're not sending them; 		 * skip the NS records because we did them first. 		 */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
operator|||
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|||
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
operator|-
name|HFIXEDSZ
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|msg
argument_list|,
name|n
operator|+
name|HFIXEDSZ
argument_list|)
expr_stmt|;
block|}
comment|/* Finally do non-delegated subdomains.  Delegated subdomains 	 * have already been handled. 	 */
comment|/* 	 * We find the subdomains by looking in the hash table for this 	 * domain, but the root domain needs special treatment, because 	 * of the following wart in the database design: 	 * 	 * The top level hash table (pointed to by the global `hashtab' 	 * variable) contains pointers to the namebuf's for the root as 	 * well as for the top-level domains below the root, in contrast 	 * to the usual situation where a hash table contains entries 	 * for domains at the same level.  The n_hash member of the 	 * namebuf for the root domain is NULL instead of pointing to a 	 * hashbuf for the top-level domains.  The n_parent members of 	 * the namebufs for the top-level domains are NULL instead of 	 * pointing to the namebuf for the root. 	 * 	 * We work around the wart as follows: 	 * 	 * If we are not dealing with the root zone then we just set 	 * htp = np->n_hash, pointing to the hash table for the current 	 * domain, and we walk through the hash table as usual, 	 * processing the namebufs for all the subdomains. 	 * 	 * If we are dealing with the root zone, then we set 	 * htp = hashtab, pointing to the global hash table (because 	 * there is no hash table associated with the root domain's 	 * namebuf.  While we walk this hash table, we take care not to 	 * recursively process the entry for the root namebuf. 	 * 	 * (apb@und nov1990) 	 */
name|htp
operator|=
operator|(
operator|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
name|hashtab
else|:
name|np
operator|->
name|n_hash
operator|)
expr_stmt|;
if|if
condition|(
name|htp
operator|==
name|NULL
condition|)
block|{
return|return;
comment|/* no subdomains */
block|}
name|npp
operator|=
name|htp
operator|->
name|h_tab
expr_stmt|;
name|nppend
operator|=
name|npp
operator|+
name|htp
operator|->
name|h_size
expr_stmt|;
while|while
condition|(
name|npp
operator|<
name|nppend
condition|)
block|{
for|for
control|(
name|np
operator|=
operator|*
name|npp
operator|++
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
block|{
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* don't redo root domain */
name|doaxfr
argument_list|(
name|np
argument_list|,
name|rfp
argument_list|,
name|top
argument_list|,
name|class
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|np
operator|==
name|top
condition|)
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"exit doaxfr()\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
end_ifdef

begin_comment
comment|/*  * Called by UPDATE{A,D,DA,M,MA} to initiate a dynamic update.  If this is the  * primary server for the zone being updated, we update the zone's serial  * number and then call doupdate directly. If this is a secondary, we just  * forward the update; this way, if the primary update fails (e.g., if the  * primary is unavailable), we don't update the secondary; if the primary  * update suceeds, ns_resp will get called with the response (when it comes  * in), and then update the secondary's copy.  */
end_comment

begin_function
specifier|static
name|int
name|InitDynUpdate
parameter_list|(
name|hp
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|startcp
parameter_list|,
name|from
parameter_list|,
name|qsp
parameter_list|,
name|dfd
parameter_list|)
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|startcp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|from
decl_stmt|;
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|int
name|dfd
decl_stmt|;
block|{
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
comment|/* lookup relative to root */
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|olddp
decl_stmt|,
modifier|*
name|newdp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|nspp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
init|=
name|startcp
decl_stmt|;
name|u_int16_t
name|class
decl_stmt|,
name|type
decl_stmt|;
name|int
name|n
decl_stmt|,
name|size
decl_stmt|,
name|zonenum
decl_stmt|;
name|char
name|ZoneName
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|znp
decl_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR InitDynUpdate expand name failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
comment|/* T_SOA updates not allowed */
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: REFUSED - SOA update\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|REFUSED
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
name|GETSHORT
argument_list|(
name|size
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/****XXX - need bounds checking here ****/
name|cp
operator|+=
name|size
expr_stmt|;
if|if
condition|(
operator|(
name|zonenum
operator|=
name|findzone
argument_list|(
name|dnbuf
argument_list|,
name|class
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* zone not found */
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
name|zp
operator|=
operator|&
name|zones
index|[
name|zonenum
index|]
expr_stmt|;
comment|/* Disallow updates for which we aren't authoratative.  Note: the 	   following test doesn't work right:  If it's for a non-local zone, 	   we will think it's a primary but be unable to lookup the namebuf, 	   thus returning 'NXDOMAIN' */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_PRIMARY
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|Z_SECONDARY
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: REFUSED - non-{primary,secondary} update\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|REFUSED
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: REFUSED - dynamic flag not set for zone\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|REFUSED
operator|)
return|;
block|}
comment|/* 	 * Lookup the zone namebuf.  Lookup "xyz" not "xyz.", since 	 * otherwise the lookup fails, because '.' may have a nil n_hash 	 * associated with it. 	 */
name|strcpy
argument_list|(
name|ZoneName
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|znp
operator|=
operator|&
name|ZoneName
index|[
name|strlen
argument_list|(
name|ZoneName
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|znp
operator|==
literal|'.'
condition|)
operator|*
name|znp
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|ZoneName
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fname
operator|!=
name|ZoneName
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"InitDynUpdate: lookup failed on zone (%s)\n"
argument_list|,
name|ZoneName
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
comment|/* 	 * If this is the primary copy increment the serial number.  Don't 	 * increment the serial number if this is a secondary; this way, if 2 	 * different secondaries both update the primary, they will both have 	 * lower serial numbers than the primary has, and hence eventually 	 * refresh and get all updates and become consistent. 	 * 	 * Note that the serial number must be incremented in both the zone 	 * data structure and the zone's namebuf. 	 */
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_SECONDARY
case|:
comment|/* forward update to primary */
name|nspp
operator|=
name|nsp
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
condition|)
block|{
if|if
condition|(
name|nspp
operator|<
operator|&
name|nsp
index|[
name|NSMAX
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|nspp
operator|++
operator|=
name|dp
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|dp
operator|->
name|d_rcnt
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
break|break;
block|}
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
comment|/* Delimiter */
if|if
condition|(
name|ns_forw
argument_list|(
name|nsp
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
name|NULL
argument_list|,
name|dnbuf
argument_list|,
name|np
argument_list|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|FORWARDED
operator|)
return|;
case|case
name|Z_PRIMARY
case|:
name|zp
operator|->
name|z_serial
operator|++
expr_stmt|;
comment|/* Find the SOA record */
for|for
control|(
name|olddp
operator|=
name|np
operator|->
name|n_data
init|;
name|olddp
operator|!=
name|NULL
condition|;
name|olddp
operator|=
name|olddp
operator|->
name|d_next
control|)
if|if
condition|(
name|match
argument_list|(
name|olddp
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|)
condition|)
break|break;
if|if
condition|(
name|olddp
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"InitDynUpdate: Couldn't find SOA RR for '%s'\n"
argument_list|,
name|ZoneName
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
name|newdp
operator|=
name|savedata
argument_list|(
name|olddp
operator|->
name|d_class
argument_list|,
name|olddp
operator|->
name|d_type
argument_list|,
name|olddp
operator|->
name|d_ttl
argument_list|,
name|olddp
operator|->
name|d_data
argument_list|,
name|olddp
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|newdp
operator|->
name|d_zone
operator|=
name|olddp
operator|->
name|d_zone
expr_stmt|;
name|newdp
operator|->
name|d_cred
operator|=
name|DB_C_AUTH
expr_stmt|;
comment|/* XXX - it may not be so */
name|newdp
operator|->
name|d_clev
operator|=
name|db_getclev
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|newdp
operator|->
name|d_data
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip origin string */
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip in-charge string */
name|putlong
argument_list|(
call|(
name|u_int32_t
call|)
argument_list|(
name|zp
operator|->
name|z_serial
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|4
argument_list|,
operator|(
name|ddt
operator|,
literal|"after stuffing data into newdp:\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|4
condition|)
name|printSOAdata
argument_list|(
name|newdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|db_update
argument_list|(
name|ZoneName
argument_list|,
name|olddp
argument_list|,
name|newdp
argument_list|,
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|)
operator|)
operator|!=
name|NOERROR
condition|)
block|{
comment|/* XXX */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: SOA update failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NOCHANGE
operator|)
return|;
block|}
comment|/* Now update the RR itself */
comment|/* XXX - DB_C_AUTH may be wrong */
if|if
condition|(
name|doupdate
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|msg
operator|+
name|HFIXEDSZ
argument_list|,
name|zonenum
argument_list|,
operator|(
expr|struct
name|databuf
operator|*
operator|)
literal|0
argument_list|,
name|DB_NODATA
argument_list|,
name|DB_C_AUTH
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"InitDynUpdate: doupdate failed\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* doupdate fills in rcode */
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|hp
operator|->
name|rcode
operator|)
return|;
block|}
name|zp
operator|->
name|z_flags
operator||=
name|Z_CHANGED
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NOERROR
operator|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Print the contents of the data in databuf pointed to by dp for an SOA record  */
end_comment

begin_function
specifier|static
name|void
name|printSOAdata
parameter_list|(
name|dp
parameter_list|)
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|debug
condition|)
return|return;
comment|/* Otherwise fprintf to ddt will bomb */
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"printSOAdata(%#lx): origin(%#lx)='%s'\n"
argument_list|,
operator|(
name|u_long
operator|)
name|dp
argument_list|,
operator|(
name|u_long
operator|)
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip origin string */
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"printSOAdata: in-charge(%#lx)='%s'\n"
argument_list|,
operator|(
name|u_long
operator|)
name|cp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* skip in-charge string */
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"printSOAdata: serial(%lx)=%d\n"
argument_list|,
name|cp
argument_list|,
operator|(
name|u_long
operator|)
name|_getlong
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|startxfr
parameter_list|(
name|qsp
parameter_list|,
name|np
parameter_list|,
name|soa
parameter_list|,
name|soalen
parameter_list|,
name|class
parameter_list|,
name|dname
parameter_list|)
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|u_char
modifier|*
name|soa
decl_stmt|;
name|int
name|soalen
decl_stmt|;
name|int
name|class
decl_stmt|;
specifier|const
name|char
modifier|*
name|dname
decl_stmt|;
block|{
name|FILE
modifier|*
name|rfp
decl_stmt|;
name|int
name|fdstat
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETVBUF
name|char
modifier|*
name|buf
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_SNDBUF
specifier|static
specifier|const
name|int
name|sndbuf
init|=
name|XFER_BUFSIZE
operator|*
literal|2
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_LINGER
specifier|static
specifier|const
name|struct
name|linger
name|ll
init|=
block|{
literal|1
block|,
literal|120
block|}
decl_stmt|;
endif|#
directive|endif
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"startxfr()\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * child does the work while 	 * the parent continues 	 */
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"startxfr(%s -> %s) failing; fork: %m"
argument_list|,
name|dname
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|qsp
operator|->
name|s_from
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
comment|/* child */
break|break;
default|default:
comment|/* parent */
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"zone transfer of \"%s\" to %s (pid %lu)"
argument_list|,
name|dname
argument_list|,
name|sin_ntoa
argument_list|(
operator|&
name|qsp
operator|->
name|s_from
argument_list|)
argument_list|,
name|pid
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Child. 	 * 	 * XXX:	this should be a vfork/exec since on non-copy-on-write 	 *	systems with huge nameserver images, this is very expensive. 	 */
name|close
argument_list|(
name|vs
argument_list|)
expr_stmt|;
name|sqflush
argument_list|(
comment|/*allbut*/
name|qsp
argument_list|)
expr_stmt|;
name|dqflush
argument_list|(
operator|(
name|time_t
operator|)
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RENICE
name|nice
argument_list|(
operator|-
literal|40
argument_list|)
expr_stmt|;
name|nice
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|nice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* back to "normal" */
endif|#
directive|endif
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"startxfr: child pid %lu\n"
operator|,
operator|(
name|u_long
operator|)
name|pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rfp
operator|=
name|fdopen
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fdopen: %m"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ns_setproctitle
argument_list|(
literal|"zone XFR to"
argument_list|,
name|qsp
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
operator|(
name|fdstat
operator|=
name|fcntl
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_GETFL): %m"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|F_SETFL
argument_list|,
name|fdstat
operator|&
operator|~
name|PORT_NONBLOCK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SETVBUF
comment|/* some systems (DEC OSF/1, SunOS) don't initialize the stdio buffer 	 * if all you do between fdopen() and fclose() are fwrite()'s.  even 	 * on systems where the buffer is correctly set, it is too small. 	 */
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|XFER_BUFSIZE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|setvbuf
argument_list|(
name|rfp
argument_list|,
name|buf
argument_list|,
name|_IOFBF
argument_list|,
name|XFER_BUFSIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_SNDBUF
comment|/* the default seems to be 4K, and we'd like it to have enough room 	 * to parallelize sending the pushed data with accumulating more 	 * write() data from us. 	 */
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sndbuf
argument_list|,
sizeof|sizeof
name|sndbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX:	some day we would like to only send the size and header out 	 *	when we fill a 64K DNS/AXFR "message" rather than on each RR. 	 *	(PVM@ISI gets credit for this idea.) 	 */
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|soa
argument_list|,
name|soalen
argument_list|)
expr_stmt|;
name|doaxfr
argument_list|(
name|np
argument_list|,
name|rfp
argument_list|,
name|np
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|fwritemsg
argument_list|(
name|rfp
argument_list|,
name|soa
argument_list|,
name|soalen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|rfp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SO_LINGER
comment|/* kernels that map pages for IO end up failing if the pipe is full 	 * at exit and we take away the final buffer.  this is really a kernel 	 * bug but it's harmless on systems that are not broken, so... 	 */
name|setsockopt
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LINGER
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ll
argument_list|,
sizeof|sizeof
name|ll
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|void
name|free_addinfo
parameter_list|()
block|{
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
init|;
operator|--
name|addcount
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
block|{
name|free
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
operator|->
name|a_rname
argument_list|)
expr_stmt|;
block|}
name|addcount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DATUMREFCNT
end_ifdef

begin_function
name|void
name|free_nsp
parameter_list|(
name|nsp
parameter_list|)
name|struct
name|databuf
modifier|*
modifier|*
name|nsp
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|nsp
condition|)
block|{
if|if
condition|(
operator|--
operator|(
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"free_nsp: %s rcnt %d\n"
operator|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_data
operator|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"free_nsp: %s rcnt %d delayed\n"
operator|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_data
operator|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|nsp
argument_list|)
expr_stmt|;
comment|/* delayed free */
block|}
operator|*
name|nsp
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

