begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_resp.c	4.65 (Berkeley) 3/3/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_resp.c,v 8.8 1995/07/07 07:33:52 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1986, 1988, 1990  * -  * Copyright (c) 1986, 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|check_root
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|check_ns
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|norootlogged
index|[
name|MAXCLASS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX- should be a bitmap */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|skipnameFailedAnswer
index|[]
init|=
literal|"skipname failed in answer"
decl_stmt|,
name|skipnameFailedQuery
index|[]
init|=
literal|"skipname failed in query"
decl_stmt|,
name|outofDataQuery
index|[]
init|=
literal|"ran out of data in query"
decl_stmt|,
name|outofDataAnswer
index|[]
init|=
literal|"ran out of data in answer"
decl_stmt|,
name|notSingleQuery
index|[]
init|=
literal|"not exactly one query"
decl_stmt|,
name|expandFailedQuery
index|[]
init|=
literal|"dn_expand failed in query"
decl_stmt|,
name|expandFailedAnswer
index|[]
init|=
literal|"dn_expand failed in answer"
decl_stmt|,
name|expandFailedAuth
index|[]
init|=
literal|"dn_expand failed in authority"
decl_stmt|,
name|outofDataAuth
index|[]
init|=
literal|"ran out of data in authority"
decl_stmt|,
name|dlenOverrunAnswer
index|[]
init|=
literal|"dlen overrun in answer"
decl_stmt|,
name|dlenUnderrunAnswer
index|[]
init|=
literal|"dlen underrun in answer"
decl_stmt|,
name|outofDataFinal
index|[]
init|=
literal|"out of data in final pass"
decl_stmt|,
name|outofDataAFinal
index|[]
init|=
literal|"out of data after final pass"
decl_stmt|,
name|editFailed
index|[]
init|=
literal|"edit of response failed"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|learntFrom
parameter_list|(
name|qp
parameter_list|,
name|server
parameter_list|)
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|server
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|ns
decl_stmt|,
modifier|*
name|na
decl_stmt|;
name|struct
name|databuf
modifier|*
name|db
decl_stmt|;
name|char
name|nsbuf
index|[
literal|20
index|]
decl_stmt|;
name|char
name|abuf
index|[
literal|20
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|buf
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
name|a
operator|=
name|ns
operator|=
name|na
operator|=
literal|"<Not Available>"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|server
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|db
operator|=
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
ifdef|#
directive|ifdef
name|STATS
if|if
condition|(
name|db
operator|->
name|d_ns
condition|)
block|{
name|strcpy
argument_list|(
name|nsbuf
argument_list|,
name|inet_ntoa
argument_list|(
name|db
operator|->
name|d_ns
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|nsbuf
expr_stmt|;
block|}
else|else
block|{
name|ns
operator|=
name|zones
index|[
name|db
operator|->
name|d_zone
index|]
operator|.
name|z_origin
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
operator|!
name|db
operator|->
name|d_rcode
condition|)
endif|#
directive|endif
name|na
operator|=
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_data
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STATS
name|db
operator|=
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|d_ns
condition|)
block|{
name|strcpy
argument_list|(
name|abuf
argument_list|,
name|inet_ntoa
argument_list|(
name|db
operator|->
name|d_ns
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|abuf
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|zones
index|[
name|db
operator|->
name|d_zone
index|]
operator|.
name|z_origin
expr_stmt|;
block|}
block|}
endif|#
directive|endif
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|a
operator|==
name|ns
operator|)
operator|&&
operator|(
name|ns
operator|==
name|na
operator|)
condition|)
comment|/* all "UNKNOWN" */
return|return
operator|(
literal|""
operator|)
return|;
ifdef|#
directive|ifdef
name|STATS
define|#
directive|define
name|LEARNTFROM
value|" '%s': learnt (A=%s,NS=%s)"
else|#
directive|else
define|#
directive|define
name|LEARNTFROM
value|" '%s'"
endif|#
directive|endif
if|if
condition|(
name|buf
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|a
operator|=
operator|(
operator|*
name|a
condition|?
name|a
else|:
literal|"\".\""
operator|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|ns
operator|=
operator|(
operator|*
name|ns
condition|?
name|ns
else|:
literal|"\".\""
operator|)
argument_list|)
operator|+
name|strlen
argument_list|(
name|na
operator|=
operator|(
operator|*
name|na
condition|?
name|na
else|:
literal|"\".\""
operator|)
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|LEARNTFROM
argument_list|)
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
name|LEARNTFROM
argument_list|,
name|na
argument_list|,
name|a
argument_list|,
name|ns
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
return|return
operator|(
literal|""
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ns_resp
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|qserv
modifier|*
name|qs
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|ns
decl_stmt|,
modifier|*
name|ns2
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|eom
init|=
name|msg
operator|+
name|msglen
decl_stmt|;
ifdef|#
directive|ifdef
name|VALIDATE
specifier|register
name|u_char
modifier|*
name|tempcp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|server
init|=
operator|&
name|from_addr
decl_stmt|;
name|int
modifier|*
name|validatelist
decl_stmt|;
name|int
name|lesscount
decl_stmt|,
name|old_ancount
decl_stmt|;
endif|#
directive|endif
name|struct
name|sockaddr_in
modifier|*
name|nsa
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|,
modifier|*
modifier|*
name|nspp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|,
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|,
name|aucount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|;
name|int
name|qtype
decl_stmt|,
name|qclass
decl_stmt|,
name|dbflags
decl_stmt|;
name|int
name|cname
init|=
literal|0
decl_stmt|;
comment|/* flag for processing cname response */
name|int
name|count
decl_stmt|,
name|founddata
decl_stmt|,
name|foundname
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|int
name|newmsglen
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|qname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
specifier|const
name|char
modifier|*
name|formerrmsg
init|=
literal|"brain damage"
decl_stmt|;
name|u_char
name|newmsg
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|dpp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|time_t
name|rtrip
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|netinfo
modifier|*
name|lp
decl_stmt|;
name|struct
name|fwdinfo
modifier|*
name|fwd
decl_stmt|;
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|qfindid
argument_list|(
name|hp
operator|->
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"DUP? dropped (id %d)\n"
operator|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdDupR
argument_list|)
expr_stmt|;
return|return;
block|}
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"Response (%s %s %s) nsid=%d id=%d\n"
operator|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
condition|?
literal|"SYSTEM"
else|:
literal|"USER"
operator|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
condition|?
literal|"PRIMING"
else|:
literal|"NORMAL"
operator|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
operator|)
condition|?
literal|"ZSERIAL"
else|:
literal|"-"
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Here we handle high level formatting problems by parsing the header. 	 */
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|aucount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
comment|/* !!! */
name|arcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|free_addinfo
argument_list|()
expr_stmt|;
comment|/* sets addcount to zero */
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|dpp
operator|=
name|dnptrs
expr_stmt|;
operator|*
name|dpp
operator|++
operator|=
name|msg
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
name|INDIR_MASK
operator|)
operator|==
literal|0
condition|)
operator|*
name|dpp
operator|++
operator|=
name|cp
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|qdcount
operator|==
literal|1
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|qname
argument_list|,
sizeof|sizeof
argument_list|(
name|qname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|expandFailedQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|qtype
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|qclass
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_msg
operator|&&
name|qp
operator|->
name|q_msglen
operator|&&
operator|!
name|res_nameinquery
argument_list|(
name|qname
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msg
operator|+
name|qp
operator|->
name|q_msglen
argument_list|)
condition|)
block|{
name|char
name|msgbuf
index|[
name|MAXDNAME
operator|*
literal|2
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"query section mismatch (%s %s %s)"
argument_list|,
name|qname
argument_list|,
name|p_class
argument_list|(
name|qclass
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|qtype
argument_list|)
argument_list|)
expr_stmt|;
name|formerrmsg
operator|=
name|msgbuf
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
block|}
else|else
block|{
comment|/* Pedantic. */
name|qname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qtype
operator|=
literal|0
expr_stmt|;
name|qclass
operator|=
literal|0
expr_stmt|;
block|}
comment|/* cp now points after the query section (if there was one). */
comment|/* 	 *  Here we handle bad responses from servers. 	 *  Several possibilities come to mind: 	 *	The server is sick and returns SERVFAIL 	 *	The server returns some garbage opcode (its sick) 	 *	The server can't understand our query and return FORMERR 	 *  In all these cases, we simply drop the packet and force 	 *  a retry.  This will make him look bad due to unresponsiveness. 	 */
if|if
condition|(
operator|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|&&
name|hp
operator|->
name|rcode
operator|!=
name|NXDOMAIN
operator|)
ifndef|#
directive|ifndef
name|NCACHE
operator|||
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
operator|&&
operator|!
name|hp
operator|->
name|aa
operator|)
comment|/* must accept this one if 						   * we allow negative caching 						   */
endif|#
directive|endif
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|!=
name|QUERY
ifdef|#
directive|ifdef
name|BIND_NOTIFY
operator|&&
name|hp
operator|->
name|opcode
operator|!=
name|NS_NOTIFY_OP
endif|#
directive|endif
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: error (ret %d, op %d), dropped\n"
operator|,
name|hp
operator|->
name|rcode
operator|,
name|hp
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|rcode
condition|)
block|{
case|case
name|SERVFAIL
case|:
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFail
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFErr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdErr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
if|if
condition|(
name|qdcount
operator|!=
literal|1
condition|)
block|{
comment|/* We don't generate or forward these (yet). */
name|formerrmsg
operator|=
name|notSingleQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
ifdef|#
directive|ifdef
name|LAME_DELEGATION
comment|/* 	 *  Non-authoritative, no answer, no error 	 */
if|if
condition|(
name|qdcount
operator|==
literal|1
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
operator|!
name|hp
operator|->
name|aa
operator|&&
name|ancount
operator|==
literal|0
operator|&&
name|aucount
operator|>
literal|0
ifdef|#
directive|ifdef
name|BIND_NOTIFY
operator|&&
name|hp
operator|->
name|opcode
operator|!=
name|NS_NOTIFY_OP
endif|#
directive|endif
condition|)
block|{
name|u_char
modifier|*
name|tp
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
name|fp_nquery
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Since there is no answer section (ancount == 0), 		 * we must be pointing at the authority section (aucount> 0). 		 */
name|tp
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|tp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|expandFailedAuth
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|>=
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAuth
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|>=
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAuth
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
comment|/* 		 * If the answer delegates us either to the same level in 		 * the hierarchy or closer to the root, we consider this 		 * server lame.  Note that for now we only log the message 		 * if the T_NS was C_IN, which is technically wrong (NS is 		 * visible in all classes) but necessary anyway (non-IN 		 * classes tend to not have good strong delegation graphs). 		 */
if|if
condition|(
name|type
operator|==
name|T_NS
operator|&&
name|samedomain
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdLDel
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LAME_LOGGING
if|if
condition|(
name|class
operator|==
name|C_IN
operator|&&
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nhash
argument_list|(
name|name
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nhash
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|)
argument_list|)
condition|)
name|syslog
argument_list|(
name|LAME_LOGGING
argument_list|,
literal|"Lame server on '%s' (in '%s'?): %s%s\n"
argument_list|,
name|qname
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|,
name|inet_etoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|,
name|learntFrom
argument_list|(
name|qp
argument_list|,
operator|&
name|from_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LAME_LOGGING */
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* LAME_DELEGATION */
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
if|if
condition|(
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|)
operator|&&
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEA
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATEM
operator|||
name|hp
operator|->
name|opcode
operator|==
name|UPDATEMA
operator|)
condition|)
block|{
comment|/* 		 * Update the secondary's copy, now that the primary 		 * successfully completed the update.  Zone doesn't matter 		 * for dyn. update -- doupdate calls findzone to find it 		 */
comment|/* XXX - DB_C_AUTH may be wrong */
operator|(
name|void
operator|)
name|doupdate
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
name|qp
operator|->
name|q_msg
operator|+
name|HFIXEDSZ
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|databuf
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|DB_C_AUTH
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, UPDATE*\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* return code filled in by doupdate */
goto|goto
name|return_msg
goto|;
block|}
endif|#
directive|endif
comment|/* ALLOW_UPDATES */
comment|/* 	 * Determine if the response came from a forwarder.  Packets from 	 * anyplace not listed as a forwarder or as a server to whom we 	 * might have forwarded the query will be dropped. 	 */
for|for
control|(
name|fwd
operator|=
name|fwdtab
init|;
name|fwd
operator|!=
operator|(
expr|struct
name|fwdinfo
operator|*
operator|)
name|NULL
condition|;
name|fwd
operator|=
name|fwd
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fwd
operator|->
name|fwdaddr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* XXX - should put this in STATS somewhere */
break|break;
block|}
block|}
comment|/* XXX:	note bad ambiguity here.  if one of our forwarders is also 	 *	a delegated server for some domain, then we will not update 	 *	the RTT information on any replies we get from those servers. 	 *	Workaround: disable recursion on authoritative servers so that 	 *	the ambiguity does not arise. 	 */
comment|/* 	 * If we weren't using a forwarder, find the qinfo pointer and update 	 * the rtt and fact that we have called on this server before. 	 */
if|if
condition|(
name|fwd
operator|==
operator|(
expr|struct
name|fwdinfo
operator|*
operator|)
name|NULL
condition|)
block|{
name|struct
name|timeval
modifier|*
name|stp
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
operator|(
name|u_int
operator|)
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
operator|,
name|qs
operator|++
control|)
if|if
condition|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
break|break;
if|if
condition|(
operator|(
name|u_int
operator|)
name|n
operator|>=
name|qp
operator|->
name|q_naddr
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|"unexpected source"
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Response from unexpected source (%s)"
argument_list|,
name|inet_etoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  			 * We don't know who this response came from so it 			 * gets dropped on the floor. 			 */
return|return;
block|}
name|stp
operator|=
operator|&
name|qs
operator|->
name|stime
expr_stmt|;
comment|/* Handle response from different (untried) interface */
if|if
condition|(
operator|(
name|qs
operator|->
name|ns
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stp
operator|->
name|tv_sec
operator|==
literal|0
operator|)
condition|)
block|{
name|ns
operator|=
name|qs
operator|->
name|ns
expr_stmt|;
while|while
condition|(
name|qs
operator|>
name|qp
operator|->
name|q_addr
operator|&&
operator|(
name|qs
operator|->
name|stime
operator|.
name|tv_sec
operator|==
literal|0
operator|||
name|qs
operator|->
name|ns
operator|!=
name|ns
operator|)
condition|)
name|qs
operator|--
expr_stmt|;
operator|*
name|stp
operator|=
name|qs
operator|->
name|stime
expr_stmt|;
comment|/* XXX - sometimes stp still ends up pointing to 			 * a zero timeval, in spite of the above attempt. 			 * Why?  What should we do about it? 			 */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"Response from unused address %s, assuming %s\n"
operator|,
name|inet_etoa
argument_list|(
operator|&
name|from_addr
argument_list|)
operator|,
name|inet_etoa
argument_list|(
operator|&
name|qs
operator|->
name|ns_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX - catch aliases here */
block|}
comment|/* compute query round trip time */
comment|/* XXX - avoid integer overflow, which is quite likely if stp 		 * points to a zero timeval (see above). 		 * rtrip is of type time_t, which we assume is at least 		 * as big as an int. 		 */
if|if
condition|(
operator|(
name|tt
operator|.
name|tv_sec
operator|-
name|stp
operator|->
name|tv_sec
operator|)
operator|>
operator|(
name|INT_MAX
operator|-
literal|999
operator|)
operator|/
literal|1000
condition|)
block|{
name|rtrip
operator|=
name|INT_MAX
expr_stmt|;
block|}
else|else
block|{
name|rtrip
operator|=
operator|(
operator|(
name|tt
operator|.
name|tv_sec
operator|-
name|stp
operator|->
name|tv_sec
operator|)
operator|*
literal|1000
operator|+
operator|(
name|tt
operator|.
name|tv_usec
operator|-
name|stp
operator|->
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"stime %lu/%lu  now %lu/%lu rtt %ld\n"
operator|,
operator|(
name|u_long
operator|)
name|stp
operator|->
name|tv_sec
operator|,
operator|(
name|u_long
operator|)
name|stp
operator|->
name|tv_usec
operator|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
operator|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_usec
operator|,
operator|(
name|long
operator|)
name|rtrip
operator|)
argument_list|)
expr_stmt|;
comment|/* prevent floating point overflow, limit to 1000 sec */
if|if
condition|(
name|rtrip
operator|>
literal|1000000
condition|)
block|{
name|rtrip
operator|=
literal|1000000
expr_stmt|;
block|}
name|ns
operator|=
name|qs
operator|->
name|nsdata
expr_stmt|;
comment|/* 		 * Don't update nstime if this doesn't look 		 * like an address databuf now.			XXX 		 */
if|if
condition|(
name|ns
operator|&&
operator|(
name|ns
operator|->
name|d_type
operator|==
name|T_A
operator|)
operator|&&
operator|(
name|ns
operator|->
name|d_class
operator|==
name|qs
operator|->
name|ns
operator|->
name|d_class
operator|)
condition|)
block|{
if|if
condition|(
name|ns
operator|->
name|d_nstime
operator|==
literal|0
condition|)
name|ns
operator|->
name|d_nstime
operator|=
operator|(
name|u_int32_t
operator|)
name|rtrip
expr_stmt|;
else|else
name|ns
operator|->
name|d_nstime
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|ns
operator|->
name|d_nstime
operator|*
name|ALPHA
operator|+
operator|(
literal|1
operator|-
name|ALPHA
operator|)
operator|*
operator|(
name|u_int32_t
operator|)
name|rtrip
argument_list|)
expr_stmt|;
comment|/* prevent floating point overflow, 			 * limit to 1000 sec 			 */
if|if
condition|(
name|ns
operator|->
name|d_nstime
operator|>
literal|1000000
condition|)
name|ns
operator|->
name|d_nstime
operator|=
literal|1000000
expr_stmt|;
block|}
comment|/* 		 * Record the source so that we do not use this NS again. 		 */
if|if
condition|(
name|ns
operator|&&
name|qs
operator|->
name|ns
operator|&&
operator|(
name|qp
operator|->
name|q_nusedns
operator|<
name|NSMAX
operator|)
condition|)
block|{
name|qp
operator|->
name|q_usedns
index|[
name|qp
operator|->
name|q_nusedns
operator|++
index|]
operator|=
name|qs
operator|->
name|ns
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"NS #%d addr %s used, rtt %d\n"
operator|,
name|n
operator|,
name|inet_etoa
argument_list|(
operator|&
name|qs
operator|->
name|ns_addr
argument_list|)
operator|,
name|ns
operator|->
name|d_nstime
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Penalize those who had earlier chances but failed 		 * by multiplying round-trip times by BETA (>1). 		 * Improve nstime for unused addresses by applying GAMMA. 		 * The GAMMA factor makes unused entries slowly 		 * improve, so they eventually get tried again. 		 * GAMMA should be slightly less than 1. 		 * Watch out for records that may have timed out 		 * and are no longer the correct type.			XXX 		 */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
operator|(
name|u_int
operator|)
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
operator|,
name|qs
operator|++
control|)
block|{
name|ns2
operator|=
name|qs
operator|->
name|nsdata
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|ns2
operator|)
operator|||
operator|(
name|ns2
operator|==
name|ns
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ns2
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|ns2
operator|->
name|d_class
operator|!=
name|qs
operator|->
name|ns
operator|->
name|d_class
condition|)
comment|/* XXX */
continue|continue;
if|if
condition|(
name|qs
operator|->
name|stime
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
name|ns2
operator|->
name|d_nstime
operator|==
literal|0
condition|)
name|ns2
operator|->
name|d_nstime
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|rtrip
operator|*
name|BETA
argument_list|)
expr_stmt|;
else|else
name|ns2
operator|->
name|d_nstime
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|ns2
operator|->
name|d_nstime
operator|*
name|BETA
operator|+
operator|(
literal|1
operator|-
name|ALPHA
operator|)
operator|*
name|rtrip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns2
operator|->
name|d_nstime
operator|>
literal|1000000
condition|)
name|ns2
operator|->
name|d_nstime
operator|=
literal|1000000
expr_stmt|;
block|}
else|else
name|ns2
operator|->
name|d_nstime
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|ns2
operator|->
name|d_nstime
operator|*
name|GAMMA
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"NS #%d %s rtt now %d\n"
operator|,
name|n
operator|,
name|inet_etoa
argument_list|(
operator|&
name|qs
operator|->
name|ns_addr
argument_list|)
operator|,
name|ns2
operator|->
name|d_nstime
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|BIND_NOTIFY
comment|/* for now, NOTIFY isn't defined for ANCOUNT!=0, AUCOUNT!=0, 	 * or ADCOUNT!=0.  therefore the only real work to be done for 	 * a NOTIFY-QR is to remove it from the query queue. 	 */
if|if
condition|(
name|hp
operator|->
name|opcode
operator|==
name|NS_NOTIFY_OP
condition|)
block|{
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/*************************************************************/
comment|/* 	 * Save answers, authority, and additional records for future use. 	 */
name|nscount
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|cp
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: ancount %d, aucount %d, arcount %d\n"
operator|,
name|ancount
operator|,
name|aucount
operator|,
name|arcount
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *  If there's an answer, check if it's a CNAME response; 	 *  if no answer but aucount> 0, see if there is an NS 	 *  or just an SOA.  (NOTE: ancount might be 1 with a CNAME, 	 *  and NS records may still be in the authority section; 	 *  we don't bother counting them, as we only use nscount 	 *  if ancount == 0.) 	 */
if|if
condition|(
name|ancount
operator|==
literal|1
operator|||
operator|(
name|ancount
operator|==
literal|0
operator|&&
name|aucount
operator|>
literal|0
operator|)
condition|)
block|{
name|c
operator|=
name|aucount
expr_stmt|;
do|do
block|{
if|if
condition|(
name|tp
operator|>=
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* name */
name|GETSHORT
argument_list|(
name|i
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* type */
name|tp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* class */
name|tp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|count
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* dlen */
if|if
condition|(
name|tp
operator|+
name|count
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|dlenOverrunAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|ancount
operator|&&
name|i
operator|==
name|T_CNAME
condition|)
block|{
name|cname
operator|++
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"CNAME - needs more processing\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|q_cmsglen
condition|)
block|{
name|qp
operator|->
name|q_cmsg
operator|=
name|qp
operator|->
name|q_msg
expr_stmt|;
name|qp
operator|->
name|q_cmsglen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 			 * See if authority record is a nameserver. 			 */
if|if
condition|(
name|ancount
operator|==
literal|0
operator|&&
name|i
operator|==
name|T_NS
condition|)
name|nscount
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|c
operator|>
literal|0
condition|)
do|;
name|tp
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|aa
operator|&&
name|ancount
operator|>
literal|0
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
name|qtype
operator|==
name|T_SOA
operator|&&
operator|(
operator|(
name|qclass
operator|==
name|C_IN
operator|)
operator|||
operator|(
name|qclass
operator|==
name|C_HS
operator|)
operator|)
condition|)
block|{
name|int
name|n
decl_stmt|;
name|u_int16_t
name|type
decl_stmt|,
name|class
decl_stmt|,
name|dlen
decl_stmt|;
name|u_int32_t
name|serial
decl_stmt|;
name|u_char
modifier|*
name|tp
init|=
name|cp
decl_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|tp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|expandFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* name */
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* type */
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* class */
name|tp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* dlen */
if|if
condition|(
name|tp
operator|>=
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|qname
argument_list|,
name|name
argument_list|)
operator|||
name|qtype
operator|!=
name|type
operator|||
name|qclass
operator|!=
name|class
condition|)
block|{
name|char
name|msgbuf
index|[
name|MAXDNAME
operator|*
literal|2
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"qserial answer mismatch (%s %s %s)"
argument_list|,
name|name
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|formerrmsg
operator|=
name|msgbuf
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
operator|(
name|u_int
operator|)
name|dlen
operator|<
operator|(
literal|5
operator|*
name|INT32SZ
operator|)
condition|)
block|{
name|formerrmsg
operator|=
name|dlenUnderrunAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
literal|0
operator|>=
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|eom
argument_list|)
operator|)
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* mname */
if|if
condition|(
literal|0
operator|>=
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|eom
argument_list|)
operator|)
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* rname */
name|GETLONG
argument_list|(
name|serial
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|qserial_answer
argument_list|(
name|qp
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Add the info received in the response to the data base. 	 */
name|c
operator|=
name|ancount
operator|+
name|aucount
operator|+
name|arcount
expr_stmt|;
ifdef|#
directive|ifdef
name|NCACHE
comment|/* -ve $ing non-existence of record, must handle non-authoritative 	 * NOERRORs with c == 0. 	 */
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
name|c
operator|==
literal|0
condition|)
block|{
goto|goto
name|return_msg
goto|;
block|}
comment|/*should ideally validate message before returning it*/
endif|#
directive|endif
comment|/*NCACHE*/
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * If the request was for a CNAME that doesn't exist, 	 * but the name is valid, fetch any other data for the name. 	 * DON'T do this now, as it will requery if data are already 	 * in the cache (maybe later with negative caching). 	 */
if|if
condition|(
name|type
operator|==
name|T_CNAME
operator|&&
name|c
operator|==
literal|0
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
operator|!
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|4
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, no CNAME\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Cause us to put it in the cache later */
name|prime
argument_list|(
name|class
argument_list|,
name|T_ANY
argument_list|,
name|qp
argument_list|)
expr_stmt|;
comment|/* Nothing to store, just give user the answer */
goto|goto
name|return_msg
goto|;
block|}
endif|#
directive|endif
comment|/* notdef */
name|nspp
operator|=
name|nsp
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
condition|)
name|dbflags
operator|=
name|DB_NOTAUTH
operator||
name|DB_NODATA
expr_stmt|;
else|else
name|dbflags
operator|=
name|DB_NOTAUTH
operator||
name|DB_NODATA
operator||
name|DB_NOHINTS
expr_stmt|;
name|count
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
condition|)
name|dbflags
operator||=
name|DB_PRIMING
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
block|{
name|count
operator|-=
name|arcount
expr_stmt|;
comment|/* truncation had to affect this */
if|if
condition|(
operator|!
name|arcount
condition|)
block|{
name|count
operator|-=
name|aucount
expr_stmt|;
comment|/* guess it got this too */
block|}
if|if
condition|(
operator|!
operator|(
name|arcount
operator|||
name|aucount
operator|)
condition|)
block|{
name|count
operator|-=
name|ancount
expr_stmt|;
comment|/* things are pretty grim */
block|}
comment|/* XXX - should retry this query with TCP */
block|}
ifdef|#
directive|ifdef
name|VALIDATE
name|tempcp
operator|=
name|cp
expr_stmt|;
name|validatelist
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|lesscount
operator|=
literal|0
expr_stmt|;
comment|/*initialize*/
name|old_ancount
operator|=
name|ancount
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|VCode
decl_stmt|;
if|if
condition|(
name|tempcp
operator|>=
name|eom
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|validatelist
argument_list|)
expr_stmt|;
name|formerrmsg
operator|=
name|outofDataFinal
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|dovalidate
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|tempcp
argument_list|,
literal|0
argument_list|,
name|dbflags
argument_list|,
name|server
argument_list|,
operator|&
name|VCode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, dovalidate failed\n"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|validatelist
argument_list|)
expr_stmt|;
comment|/* return code filled in by dovalidate */
goto|goto
name|return_msg
goto|;
block|}
name|validatelist
index|[
name|i
index|]
operator|=
name|VCode
expr_stmt|;
if|if
condition|(
name|VCode
operator|==
name|INVALID
condition|)
name|lesscount
operator|++
expr_stmt|;
name|tempcp
operator|+=
name|n
expr_stmt|;
block|}
comment|/* need to delete INVALID records from the message 	 * and change fields appropriately 	 */
name|n
operator|=
name|update_msg
argument_list|(
name|msg
argument_list|,
operator|&
name|msglen
argument_list|,
name|validatelist
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|validatelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|editFailed
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|count
operator|-=
name|lesscount
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_ancount
operator|&&
operator|!
name|ancount
condition|)
block|{
comment|/* We lost all the answers */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"validate count -> 0"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|databuf
modifier|*
name|ns3
decl_stmt|;
name|u_char
name|cred
decl_stmt|;
if|if
condition|(
name|cp
operator|>=
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataFinal
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
name|i
operator|<
name|ancount
condition|)
name|cred
operator|=
name|hp
operator|->
name|aa
condition|?
name|DB_C_AUTH
else|:
name|DB_C_ANSWER
expr_stmt|;
else|else
name|cred
operator|=
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
condition|?
name|DB_C_ANSWER
else|:
name|DB_C_ADDITIONAL
expr_stmt|;
name|ns3
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|doupdate
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|,
operator|&
name|ns3
argument_list|,
name|dbflags
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, doupdate failed\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* return code filled in by doupdate */
goto|goto
name|return_msg
goto|;
block|}
comment|/* 		 * Remember nameservers from the authority section 		 * for referrals. 		 * (This is usually overwritten by findns below(?). XXX 		 */
if|if
condition|(
name|ns3
operator|&&
name|i
operator|>=
name|ancount
operator|&&
name|i
operator|<
name|ancount
operator|+
name|aucount
operator|&&
name|nspp
operator|<
operator|&
name|nsp
index|[
name|NSMAX
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|nspp
operator|++
operator|=
name|ns3
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|ns3
operator|->
name|d_rcnt
operator|++
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
operator|&&
name|ancount
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
condition|)
name|check_root
argument_list|()
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, SYSQUERY ancount %d\n"
operator|,
name|ancount
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
if|if
condition|(
name|qp
operator|->
name|q_notifyzone
operator|!=
name|DB_Z_CACHE
condition|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
operator|&
name|zones
index|[
name|qp
operator|->
name|q_notifyzone
index|]
decl_stmt|;
comment|/* 			 * Clear this first since sysnotify() might set it. 			 */
name|qp
operator|->
name|q_notifyzone
operator|=
name|DB_Z_CACHE
expr_stmt|;
name|sysnotify
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|T_SOA
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAFinal
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
comment|/* 	 *  If there are addresses and this is a local query, 	 *  sort them appropriately for the local context. 	 */
if|if
condition|(
name|ancount
operator|>
literal|1
operator|&&
operator|(
name|lp
operator|=
name|local
argument_list|(
operator|&
name|qp
operator|->
name|q_from
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|sort_response
argument_list|(
name|tp
argument_list|,
name|ancount
argument_list|,
name|lp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
comment|/* 	 * An answer to a T_ANY query or a successful answer to a 	 * regular query with no indirection, then just return answer. 	 */
if|if
condition|(
operator|(
name|qtype
operator|==
name|T_ANY
operator|&&
name|ancount
operator|)
operator|||
operator|(
operator|!
name|cname
operator|&&
operator|!
name|qp
operator|->
name|q_cmsglen
operator|&&
name|ancount
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: got as much answer as there is\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|return_msg
goto|;
block|}
comment|/* 	 * We might want to cache this negative answer. 	 */
if|if
condition|(
operator|!
name|ancount
operator|&&
operator|(
operator|!
name|nscount
operator|||
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
operator|)
operator|&&
operator|(
name|hp
operator|->
name|aa
operator|||
name|fwd
operator|||
name|qclass
operator|==
name|C_ANY
operator|)
condition|)
block|{
comment|/* we have an authoritative NO */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving auth NO\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_cmsglen
condition|)
block|{
name|msg
operator|=
name|qp
operator|->
name|q_cmsg
expr_stmt|;
name|msglen
operator|=
name|qp
operator|->
name|q_cmsglen
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NCACHE
comment|/* answer was NO */
if|if
condition|(
name|hp
operator|->
name|aa
operator|&&
operator|(
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
operator|)
operator|||
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|)
operator|)
condition|)
block|{
name|cache_n_resp
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*NCACHE*/
goto|goto
name|return_msg
goto|;
block|}
comment|/* 	 * All messages in here need further processing.  i.e. they 	 * are either CNAMEs or we got referred again. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|founddata
operator|=
literal|0
expr_stmt|;
name|foundname
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|cname
operator|&&
name|qp
operator|->
name|q_cmsglen
operator|&&
name|ancount
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"Cname second pass\n"
operator|)
argument_list|)
expr_stmt|;
name|newmsglen
operator|=
name|qp
operator|->
name|q_cmsglen
expr_stmt|;
name|bcopy
argument_list|(
name|qp
operator|->
name|q_cmsg
argument_list|,
name|newmsg
argument_list|,
name|newmsglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newmsglen
operator|=
name|msglen
expr_stmt|;
name|bcopy
argument_list|(
name|msg
argument_list|,
name|newmsg
argument_list|,
name|newmsglen
argument_list|)
expr_stmt|;
block|}
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|newmsg
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|dnptrs
index|[
literal|0
index|]
operator|=
name|newmsg
expr_stmt|;
name|dnptrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|newmsg
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|cname
condition|)
name|cp
operator|+=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|newmsg
operator|+
name|newmsglen
argument_list|)
operator|+
name|QFIXEDSZ
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|newmsg
argument_list|,
name|newmsg
operator|+
name|newmsglen
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"dn_expand failed\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
operator|!
name|cname
condition|)
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|newmsg
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|newmsg
operator|)
expr_stmt|;
name|try_again
label|:
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: nlookup(%s) qtype=%d\n"
operator|,
name|dname
operator|,
name|qtype
operator|)
argument_list|)
expr_stmt|;
name|fname
operator|=
literal|""
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* lookup relative to root */
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: %s '%s' as '%s' (cname=%d)\n"
operator|,
name|np
operator|==
name|NULL
condition|?
literal|"missed"
else|:
literal|"found"
operator|,
name|dname
operator|,
name|fname
operator|,
name|cname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
goto|goto
name|fetch_ns
goto|;
name|foundname
operator|++
expr_stmt|;
name|count
operator|=
name|cp
operator|-
name|newmsg
expr_stmt|;
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|qclass
argument_list|,
name|qtype
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|fetch_ns
goto|;
comment|/* NO data available */
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|ancount
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|dname
operator|&&
name|qtype
operator|!=
name|T_CNAME
operator|&&
name|qtype
operator|!=
name|T_ANY
condition|)
block|{
name|cname
operator|++
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
name|founddata
operator|=
literal|1
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: foundname=%d, count=%d, founddata=%d, cname=%d\n"
operator|,
name|foundname
operator|,
name|count
operator|,
name|founddata
operator|,
name|cname
operator|)
argument_list|)
expr_stmt|;
name|fetch_ns
label|:
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
comment|/*  	 * Look for name servers to refer to and fill in the authority  	 * section or record the address for forwarding the query  	 * (recursion desired).  	 */
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|qclass
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* shouldn't happen */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"req: leaving (%s, rcode %d)\n"
operator|,
name|dname
operator|,
name|hp
operator|->
name|rcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundname
condition|)
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
if|if
condition|(
name|qclass
operator|!=
name|C_ANY
condition|)
block|{
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX:	should return SOA if founddata == 0, 			 *	but old named's are confused by an SOA 			 *	in the auth. section if there's no error. 			 */
if|if
condition|(
name|foundname
operator|==
literal|0
operator|&&
name|np
condition|)
block|{
name|n
operator|=
name|doaddauth
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|np
argument_list|,
name|nsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
block|}
goto|goto
name|return_newmsg
goto|;
case|case
name|SERVFAIL
case|:
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
name|founddata
condition|)
block|{
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|newmsg
expr_stmt|;
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
goto|goto
name|return_newmsg
goto|;
block|}
comment|/* 	 *  If we get here, we don't have the answer yet and are about 	 *  to iterate to try and get it.  First, infinite loop avoidance. 	 */
if|if
condition|(
name|qp
operator|->
name|q_nqueries
operator|++
operator|>
name|MAXQUERIES
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: MAXQUERIES exceeded (%s %s %s)\n"
operator|,
name|dname
operator|,
name|p_class
argument_list|(
name|qclass
argument_list|)
operator|,
name|p_type
argument_list|(
name|qtype
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"MAXQUERIES exceeded, possible data loop in resolving (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
comment|/* Reset the query control structure */
ifdef|#
directive|ifdef
name|DATUMREFCNT
comment|/* XXX - this code should be shared with qfree()'s similar logic. */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int
operator|)
name|i
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
block|{
specifier|static
specifier|const
name|char
name|freed
index|[]
init|=
literal|"freed"
decl_stmt|,
name|busy
index|[]
init|=
literal|"busy"
decl_stmt|;
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|--
operator|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_rcnt
operator|)
operator|)
condition|)
name|result
operator|=
name|busy
expr_stmt|;
else|else
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
argument_list|)
expr_stmt|;
name|result
operator|=
name|freed
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_resp: ns %s rcnt %d (%s)\n"
operator|,
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_data
operator|,
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_rcnt
operator|,
name|result
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|--
operator|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
operator|->
name|d_rcnt
operator|)
operator|)
condition|)
name|result
operator|=
name|busy
expr_stmt|;
else|else
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
argument_list|)
expr_stmt|;
name|result
operator|=
name|freed
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_resp: nsdata %08.8X rcnt %d (%s)\n"
operator|,
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
operator|->
name|d_data
operator|)
operator|,
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
operator|->
name|d_rcnt
operator|,
name|result
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|qp
operator|->
name|q_naddr
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_curaddr
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_fwd
operator|=
name|fwdtab
expr_stmt|;
ifdef|#
directive|ifdef
name|LAME_DELEGATION
name|getname
argument_list|(
name|np
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|,
sizeof|sizeof
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LAME_DELEGATION */
if|if
condition|(
operator|(
name|n
operator|=
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|,
name|dname
argument_list|,
literal|"ns_resp"
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: nslookup reports danger\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: no addrs found for NS's\n"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cname
condition|)
comment|/* a remote CNAME that does not have data */
goto|goto
name|return_newmsg
goto|;
goto|goto
name|servfail
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|u_int
operator|)
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
control|)
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|stime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|q_fwd
condition|)
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
if|if
condition|(
name|cname
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_cname
operator|++
operator|==
name|MAXCNAMES
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: leaving, MAXCNAMES exceeded\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"q_cname = %d\n"
operator|,
name|qp
operator|->
name|q_cname
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: building recursive query; nslookup\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_msg
condition|)
operator|(
name|void
operator|)
name|free
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"resp: malloc error\n"
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|dname
argument_list|,
name|qclass
argument_list|,
name|qtype
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"resp: res_mkquery(%s) failed"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
name|qp
operator|->
name|q_msglen
operator|=
name|n
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
name|nsid_next
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_fwd
condition|)
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
name|nsa
operator|=
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: forw -> %s ds=%d nsid=%d id=%d %dms\n"
operator|,
name|inet_etoa
argument_list|(
name|nsa
argument_list|)
operator|,
name|ds
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|,
operator|(
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|!=
name|NULL
operator|)
condition|?
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|->
name|d_nstime
else|:
operator|(
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sendto
argument_list|(
name|ds
argument_list|,
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|nsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nsa
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|sendtoStr
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ns_resp: sendto(%s): %m"
argument_list|,
name|inet_etoa
argument_list|(
name|nsa
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
comment|/* leave set to 0 for dup detection */
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSentFwdR
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFwdR
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"resp: Query sent.\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
name|formerr
label|:
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|nhash
argument_list|(
name|formerrmsg
argument_list|)
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Malformed response from %s (%s)\n"
argument_list|,
name|inet_etoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|,
name|formerrmsg
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssSentFErr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
name|return_msg
label|:
name|nameserIncr
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFwdR
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentFwdR
argument_list|)
expr_stmt|;
comment|/* The "standard" return code */
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NoRecurse
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
name|return_newmsg
label|:
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentAns
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XSTATS
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
condition|)
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentNaAns
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
condition|)
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentNXD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|doaddinfo
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NoRecurse
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
name|newmsg
argument_list|,
name|cp
operator|-
name|newmsg
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
name|servfail
label|:
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentFail
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|cname
condition|?
name|qp
operator|->
name|q_cmsg
else|:
name|qp
operator|->
name|q_msg
operator|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NoRecurse
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|hp
argument_list|,
operator|(
name|cname
condition|?
name|qp
operator|->
name|q_cmsglen
else|:
name|qp
operator|->
name|q_msglen
operator|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_comment
comment|/*  * Decode the resource record 'rrp' and update the database.  * If savens is non-nil, record pointer for forwarding queries a second time.  */
end_comment

begin_function
name|int
name|doupdate
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|rrp
parameter_list|,
name|zone
parameter_list|,
name|savens
parameter_list|,
name|flags
parameter_list|,
name|cred
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|,
decl|*
name|rrp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|databuf
modifier|*
modifier|*
name|savens
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msglen
decl_stmt|,
name|zone
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|cred
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dlen
decl_stmt|,
name|n1
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|;
name|u_char
name|data
index|[
name|BUFSIZ
index|]
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
name|int
name|zonenum
decl_stmt|;
endif|#
directive|endif
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"doupdate(zone %d, savens %#lx, flags %#lx)\n"
operator|,
name|zone
operator|,
operator|(
name|u_long
operator|)
name|savens
operator|,
operator|(
name|u_long
operator|)
name|flags
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rrp
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
name|dname
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"doupdate: dname %s type %d class %d ttl %d\n"
operator|,
name|dname
operator|,
name|type
operator|,
name|class
operator|,
name|ttl
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the resource record data into the internal 	 * database format. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
if|if
condition|(
name|dlen
operator|!=
name|INT32SZ
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*FALLTHROUGH*/
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_UINFO
case|:
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
case|case
name|T_ISDN
case|:
case|case
name|T_NSAP
case|:
case|case
name|T_LOC
case|:
ifdef|#
directive|ifdef
name|ALLOW_T_UNSPEC
case|case
name|T_UNSPEC
case|:
endif|#
directive|endif
name|cp1
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dlen
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_SOA
case|:
case|case
name|T_RP
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
name|n1
operator|-=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|bcopy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
operator|=
literal|5
operator|*
name|INT32SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
comment|/* grab preference */
name|bcopy
argument_list|(
name|cp
argument_list|,
name|data
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* get name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
comment|/* grab preference */
name|bcopy
argument_list|(
name|cp
argument_list|,
name|data
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* get MAP822 name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
operator|(
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|n
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
default|default:
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"unknown type %d\n"
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
operator|-
name|rrp
operator|)
operator|+
name|dlen
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"update type %d: %d bytes is too much data\n"
operator|,
name|type
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ALLOW_UPDATES
comment|/* 	 * If this is a dynamic update request, process it specially; else, 	 * execute normal update code. 	 */
switch|switch
condition|(
name|hp
operator|->
name|opcode
condition|)
block|{
comment|/* For UPDATEM and UPDATEMA, do UPDATED/UPDATEDA followed by UPDATEA */
case|case
name|UPDATEM
case|:
case|case
name|UPDATEMA
case|:
comment|/* 	 * The named code for UPDATED and UPDATEDA is the same except that for 	 * UPDATEDA we we ignore any data that was passed: we just delete all 	 * RRs whose name, type, and class matches 	 */
case|case
name|UPDATED
case|:
case|case
name|UPDATEDA
case|:
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
comment|/* Not allowed */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"UDPATE: REFUSED - SOA delete\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Don't check message length if doing UPDATEM/UPDATEMA, 		 * since the whole message wont have been demarshalled until 		 * we reach the code for UPDATEA 		 */
if|if
condition|(
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|)
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
operator|)
condition|)
block|{
if|if
condition|(
name|cp
operator|!=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|msg
operator|+
name|msglen
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR UPDATE message length off\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|zonenum
operator|=
name|findzone
argument_list|(
name|dname
argument_list|,
name|class
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_flags
operator|&
name|Z_DYNADDONLY
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|)
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEM
operator|)
condition|)
block|{
comment|/* Make a dp for use in db_update, as old dp */
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|cred
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|db_getclev
argument_list|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
name|DB_MEXIST
operator||
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|OK
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"UPDATE: db_update failed\n"
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* UPDATEDA or UPDATEMA */
name|int
name|DeletedOne
init|=
literal|0
decl_stmt|;
comment|/* Make a dp for use in db_update, as old dp */
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|cred
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|db_getclev
argument_list|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Loop and delete all matching RR(s) */
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|OK
condition|)
break|break;
name|DeletedOne
operator|++
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
comment|/* Ok for UPDATEMA not to have deleted any RRs */
if|if
condition|(
operator|!
name|DeletedOne
operator|&&
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"UPDATE: db_update failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATED
operator|)
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|==
name|UPDATEDA
operator|)
condition|)
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
empty_stmt|;
comment|/* 		 * Else unmarshal the RR to be added and continue on to 		 * UPDATEA code for UPDATEM/UPDATEMA 		 */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR UPDATE expand name failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|cp
expr_stmt|;
comment|/**** XXX - need bounds checking here ****/
name|cp
operator|+=
name|n
expr_stmt|;
case|case
name|UPDATEA
case|:
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"UPDATE: too much data\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cp
operator|!=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|msg
operator|+
name|msglen
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"FORMERR UPDATE message length off\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|zonenum
operator|=
name|findzone
argument_list|(
name|dname
argument_list|,
name|class
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_flags
operator|&
name|Z_DYNADDONLY
condition|)
block|{
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
if|if
condition|(
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|dname
argument_list|,
name|fname
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"refusing add of existing name\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|cred
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|db_getclev
argument_list|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|,
name|DB_NODATA
argument_list|,
name|hashtab
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"UPDATE: db_update failed\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* ALLOW_UPDATES */
if|if
condition|(
name|zone
operator|==
literal|0
condition|)
name|ttl
operator|+=
name|tt
operator|.
name|tv_sec
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TRACEROOT
argument_list|)
operator|||
name|defined
argument_list|(
name|BOGUSNS
argument_list|)
if|if
condition|(
operator|(
name|type
operator|==
name|T_NS
operator|)
operator|&&
operator|(
name|savens
operator|!=
name|NULL
operator|)
condition|)
block|{
name|char
name|qname
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
specifier|register
name|int
name|bogus
init|=
literal|0
decl_stmt|;
name|int
name|bogusns
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|BOGUSNS
if|if
condition|(
name|addr_on_netlist
argument_list|(
name|from_addr
operator|.
name|sin_addr
argument_list|,
name|boglist
argument_list|)
condition|)
block|{
name|bogusns
operator|++
expr_stmt|;
name|bogus
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|bogus
operator|&&
operator|(
operator|(
name|temp
operator|=
name|strrchr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|temp
argument_list|,
literal|".arpa"
argument_list|)
condition|)
name|bogus
operator|++
expr_stmt|;
name|qname
index|[
literal|0
index|]
operator|=
name|qname
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|msg
operator|+
name|HFIXEDSZ
argument_list|,
name|qname
argument_list|,
sizeof|sizeof
argument_list|(
name|qname
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|qname
index|[
literal|0
index|]
operator|=
literal|'?'
expr_stmt|;
elseif|else
if|if
condition|(
name|qname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|qname
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|bogus
operator|&&
operator|(
operator|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
name|zone
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|"bogus root NS"
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"bogus root NS %s rcvd from %s on query for \"%s\""
argument_list|,
name|data
argument_list|,
name|inet_etoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|,
name|qname
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|BOGUSNS
if|if
condition|(
name|bogusns
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|from_addr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
literal|"bogus nonroot NS"
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"bogus nonroot NS %s rcvd from %s on query for \"%s\""
argument_list|,
name|data
argument_list|,
name|inet_etoa
argument_list|(
operator|&
name|from_addr
argument_list|)
argument_list|,
name|qname
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/*TRACEROOT || BOGUSNS*/
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zone
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|cred
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
literal|0
expr_stmt|;
comment|/* We trust what is on disk more, except root srvrs */
if|if
condition|(
operator|(
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|dp
argument_list|,
name|flags
argument_list|,
name|hashtab
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&&
operator|(
name|n
operator|!=
name|DATAEXISTS
operator|)
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update failed (%d)\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update failed (DATAEXISTS)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|T_NS
operator|&&
name|savens
operator|!=
name|NULL
condition|)
operator|*
name|savens
operator|=
name|dp
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
end_block

begin_function
name|int
name|send_msg
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|qp
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
block|{
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"send_msg -> %s (%s %d) id=%d\n"
argument_list|,
name|inet_etoa
argument_list|(
operator|&
name|qp
operator|->
name|q_from
argument_list|)
argument_list|,
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|?
literal|"UDP"
else|:
literal|"TCP"
argument_list|,
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|?
name|qp
operator|->
name|q_dfd
else|:
name|qp
operator|->
name|q_stream
operator|->
name|s_rfd
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|4
condition|)
block|{
name|struct
name|qinfo
modifier|*
name|tqp
decl_stmt|;
for|for
control|(
name|tqp
operator|=
name|nsqhead
init|;
name|tqp
operator|!=
name|QINFO_NULL
condition|;
name|tqp
operator|=
name|tqp
operator|->
name|q_link
control|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"qp %#lx q_id: %d  q_nsid: %d q_msglen: %d "
argument_list|,
operator|(
name|u_long
operator|)
name|tqp
argument_list|,
name|tqp
operator|->
name|q_id
argument_list|,
name|tqp
operator|->
name|q_nsid
argument_list|,
name|tqp
operator|->
name|q_msglen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"q_naddr: %d q_curaddr: %d\n"
argument_list|,
name|tqp
operator|->
name|q_naddr
argument_list|,
name|tqp
operator|->
name|q_curaddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"q_next: %#lx q_link: %#lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
operator|->
name|q_next
argument_list|,
operator|(
name|u_long
operator|)
name|qp
operator|->
name|q_link
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|qp
operator|->
name|q_stream
operator|==
name|QSTREAM_NULL
condition|)
block|{
if|if
condition|(
name|sendto
argument_list|(
name|qp
operator|->
name|q_dfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|qp
operator|->
name|q_from
argument_list|,
sizeof|sizeof
argument_list|(
name|qp
operator|->
name|q_from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|sendtoStr
argument_list|)
condition|)
if|#
directive|if
name|defined
argument_list|(
name|SPURIOUS_ECONNREFUSED
argument_list|)
if|if
condition|(
name|errno
operator|!=
name|ECONNREFUSED
condition|)
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"send_msg: sendto(%s): %m"
argument_list|,
name|inet_etoa
argument_list|(
operator|&
name|qp
operator|->
name|q_from
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|writemsg
argument_list|(
name|qp
operator|->
name|q_stream
operator|->
name|s_rfd
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|sq_done
argument_list|(
name|qp
operator|->
name|q_stream
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/* i don't quite understand this but the only ref to it is notdef'd --vix */
end_comment

begin_macro
name|prime
argument_list|(
argument|class
argument_list|,
argument|type
argument_list|,
argument|oqp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|qinfo
modifier|*
name|oqp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|dname
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|oqp
operator|->
name|q_msg
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dn_expand
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
name|oqp
operator|->
name|q_msglen
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
name|HFIXEDSZ
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
return|return;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"prime: %s\n"
operator|,
name|dname
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|prime_cache
parameter_list|()
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"prime_cache: priming = %d\n"
operator|,
name|priming
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priming
operator|&&
name|fcachetab
operator|->
name|h_tab
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
operator|!
name|forward_only
condition|)
block|{
name|priming
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|qp
operator|=
name|sysquery
argument_list|(
literal|""
argument_list|,
name|C_IN
argument_list|,
name|T_NS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
operator|)
condition|)
name|priming
operator|=
literal|0
expr_stmt|;
else|else
name|qp
operator|->
name|q_flags
operator||=
operator|(
name|Q_SYSTEM
operator||
name|Q_PRIMING
operator|)
expr_stmt|;
block|}
name|needs_prime_cache
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_function
name|struct
name|notify
modifier|*
name|findNotifyPeer
parameter_list|(
name|zp
parameter_list|,
name|ina
parameter_list|)
specifier|const
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
block|{
specifier|register
name|struct
name|notify
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|zp
operator|->
name|z_notifylist
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
if|if
condition|(
name|ap
operator|->
name|addr
operator|.
name|s_addr
operator|==
name|ina
operator|.
name|s_addr
condition|)
break|break;
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sysnotify(dname, class, type)  *	cause a NOTIFY request to be sysquery()'d to each secondary server  *	of the zone that "dname" is within.  */
end_comment

begin_function
name|void
name|sysnotify
parameter_list|(
name|dname
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|soaname
decl_stmt|,
modifier|*
name|zname
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|struct
name|in_addr
name|nss
index|[
name|NSMAX
index|]
decl_stmt|;
name|int
name|nns
decl_stmt|,
name|na
decl_stmt|,
name|zn
decl_stmt|,
name|nsc
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|struct
name|notify
modifier|*
name|ap
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
condition|)
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"sysnotify: can't find name"
argument_list|)
expr_stmt|;
name|zn
operator|=
name|findMyZone
argument_list|(
name|np
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|zn
operator|==
name|DB_Z_CACHE
condition|)
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"sysnotify: not auth zone"
argument_list|)
expr_stmt|;
name|zp
operator|=
operator|&
name|zones
index|[
name|zn
index|]
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_PRIMARY
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|Z_SECONDARY
condition|)
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"sysnotify: not pri/sec"
argument_list|)
expr_stmt|;
name|zname
operator|=
name|zp
operator|->
name|z_origin
expr_stmt|;
comment|/* **DBG**	syslog(LOG_INFO, "sysnotify: found \"%s\" in \"%s\" (%s)", **DBG**	       dname, zname, zoneTypeString(zp)); */
name|nns
operator|=
name|na
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Send to recent AXFR peers. 	 */
for|for
control|(
name|ap
operator|=
name|zp
operator|->
name|z_notifylist
init|;
name|ap
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tt
operator|.
name|tv_sec
operator|-
name|ap
operator|->
name|last
operator|>=
name|zp
operator|->
name|z_refresh
condition|)
block|{
comment|/* XXX - probably should do GC here. */
continue|continue;
block|}
name|nss
index|[
literal|0
index|]
operator|=
name|ap
operator|->
name|addr
expr_stmt|;
name|nsc
operator|=
literal|1
expr_stmt|;
name|nns
operator|++
expr_stmt|;
name|na
operator|++
expr_stmt|;
name|sysquery
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|,
name|nss
argument_list|,
name|nsc
argument_list|,
name|NS_NOTIFY_OP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_PRIMARY
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Master. 	 */
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|zname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|np
condition|)
name|panic
argument_list|(
operator|-
literal|1
argument_list|,
literal|"sysnotify: found name but not zone"
argument_list|)
expr_stmt|;
name|soaname
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|dp
operator|->
name|d_zone
operator|||
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|soaname
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"multiple SOA's for zone \"%s\"?"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
return|return;
block|}
name|soaname
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|soaname
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"no SOA found for zone \"%s\""
argument_list|,
name|zname
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|adp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|anp
decl_stmt|;
if|if
condition|(
operator|!
name|dp
operator|->
name|d_zone
operator|||
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
condition|)
continue|continue;
comment|/* NS RDATA is server name. */
if|if
condition|(
name|strcasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|soaname
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|anp
operator|=
name|nlookup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anp
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sysnotify: can't nlookup(%s)?"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nsc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|adp
operator|=
name|anp
operator|->
name|n_data
init|;
name|adp
condition|;
name|adp
operator|=
name|adp
operator|->
name|d_next
control|)
block|{
name|struct
name|in_addr
name|ina
decl_stmt|;
if|if
condition|(
operator|!
name|match
argument_list|(
name|adp
argument_list|,
name|class
argument_list|,
name|T_A
argument_list|)
condition|)
continue|continue;
name|ina
operator|=
name|data_inaddr
argument_list|(
name|adp
operator|->
name|d_data
argument_list|)
expr_stmt|;
comment|/* Don't send to things we handled above. */
name|ap
operator|=
name|findNotifyPeer
argument_list|(
name|zp
argument_list|,
name|ina
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|&&
name|tt
operator|.
name|tv_sec
operator|-
name|ap
operator|->
name|last
operator|<
name|zp
operator|->
name|z_refresh
condition|)
goto|goto
name|nextns
goto|;
if|if
condition|(
name|nsc
operator|<
name|NSMAX
condition|)
name|nss
index|[
name|nsc
operator|++
index|]
operator|=
name|ina
expr_stmt|;
block|}
comment|/*next A*/
if|if
condition|(
name|nsc
operator|==
literal|0
condition|)
block|{
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|qp
operator|=
name|sysquery
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
comment|/*NS name*/
name|class
argument_list|,
comment|/*XXX: C_IN?*/
name|T_A
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
condition|)
name|qp
operator|->
name|q_notifyzone
operator|=
name|zn
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|,
name|nss
argument_list|,
name|nsc
argument_list|,
name|NS_NOTIFY_OP
argument_list|)
expr_stmt|;
name|nns
operator|++
expr_stmt|;
name|na
operator|+=
name|nsc
expr_stmt|;
name|nextns
label|:
empty_stmt|;
block|}
comment|/*next NS*/
name|done
label|:
if|if
condition|(
name|nns
operator|||
name|na
condition|)
block|{
name|char
name|tmp
index|[
name|MAXDNAME
operator|*
literal|2
index|]
decl_stmt|;
comment|/* Many syslog()'s only take 5 args. */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s %s %s"
argument_list|,
name|dname
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Sent NOTIFY for \"%s\" (%s); %d NS, %d A"
argument_list|,
name|tmp
argument_list|,
name|zname
argument_list|,
name|nns
argument_list|,
name|na
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*BIND_NOTIFY*/
end_comment

begin_function
name|struct
name|qinfo
modifier|*
name|sysquery
parameter_list|(
name|dname
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|,
name|nss
parameter_list|,
name|nsc
parameter_list|,
name|opcode
parameter_list|)
specifier|const
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|nss
decl_stmt|;
name|int
name|nsc
decl_stmt|,
name|opcode
decl_stmt|;
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|,
modifier|*
name|oqp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|nsa
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|n
decl_stmt|,
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery(%s, %d, %d, %#lx, %d)\n"
operator|,
name|dname
operator|,
name|class
operator|,
name|type
operator|,
operator|(
name|u_long
operator|)
name|nss
operator|,
name|nsc
operator|)
argument_list|)
expr_stmt|;
name|qp
operator|=
name|qnew
argument_list|()
expr_stmt|;
if|if
condition|(
name|nss
operator|&&
name|nsc
condition|)
block|{
name|np
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|htp
operator|=
name|hashtab
expr_stmt|;
if|if
condition|(
name|priming
operator|&&
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|np
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sysquery: nlookup error on %s?"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|err1
label|:
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|n
operator|=
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|NXDOMAIN
case|:
case|case
name|SERVFAIL
case|:
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"sysquery: findns error (%d) on %s?"
argument_list|,
name|n
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|err2
label|:
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|err1
goto|;
block|}
block|}
comment|/* build new qinfo struct */
name|qp
operator|->
name|q_cmsg
operator|=
name|qp
operator|->
name|q_msg
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|q_dfd
operator|=
name|ds
expr_stmt|;
if|if
condition|(
name|nss
operator|&&
name|nsc
condition|)
name|qp
operator|->
name|q_fwd
operator|=
name|NULL
expr_stmt|;
else|else
name|qp
operator|->
name|q_fwd
operator|=
name|fwdtab
expr_stmt|;
name|qp
operator|->
name|q_expire
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|RETRY_TIMEOUT
operator|*
literal|2
expr_stmt|;
name|qp
operator|->
name|q_flags
operator||=
name|Q_SYSTEM
expr_stmt|;
ifdef|#
directive|ifdef
name|LAME_DELEGATION
name|getname
argument_list|(
name|np
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|,
sizeof|sizeof
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LAME_DELEGATION */
if|if
condition|(
operator|(
name|qp
operator|->
name|q_msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|BUFSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"sysquery: malloc failed"
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
name|n
operator|=
name|res_mkquery
argument_list|(
name|opcode
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sysquery: res_mkquery(%s) failed"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
name|qp
operator|->
name|q_msglen
operator|=
name|n
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
name|nsid_next
argument_list|()
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
operator|(
name|qp
operator|->
name|q_fwd
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* First check for an already pending query for this data */
for|for
control|(
name|oqp
operator|=
name|nsqhead
init|;
name|oqp
operator|!=
name|QINFO_NULL
condition|;
name|oqp
operator|=
name|oqp
operator|->
name|q_link
control|)
block|{
if|if
condition|(
operator|(
name|oqp
operator|!=
name|qp
operator|)
operator|&&
operator|(
name|oqp
operator|->
name|q_msglen
operator|==
name|qp
operator|->
name|q_msglen
operator|)
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|oqp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|qp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|qp
operator|->
name|q_msglen
operator|-
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BIND_NOTIFY
comment|/* XXX - need fancier test to suppress duplicate 			 *       NOTIFYs to the same server (compare nss?) 			 */
if|if
condition|(
name|opcode
operator|!=
name|NS_NOTIFY_OP
condition|)
endif|#
directive|endif
comment|/*BIND_NOTIFY*/
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery: duplicate\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
block|}
block|}
if|if
condition|(
name|nss
operator|&&
name|nsc
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|qserv
modifier|*
name|qs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
name|i
operator|<
name|nsc
condition|;
name|i
operator|++
operator|,
name|qs
operator|++
control|)
block|{
name|qs
operator|->
name|ns_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
operator|=
name|nss
index|[
name|i
index|]
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_port
operator|=
name|ns_port
expr_stmt|;
name|qs
operator|->
name|ns
operator|=
name|NULL
expr_stmt|;
name|qs
operator|->
name|nsdata
operator|=
name|NULL
expr_stmt|;
name|qs
operator|->
name|stime
operator|=
name|tt
expr_stmt|;
name|qs
operator|->
name|nretry
operator|=
literal|0
expr_stmt|;
block|}
name|qp
operator|->
name|q_naddr
operator|=
name|nsc
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|,
name|dname
argument_list|,
literal|"sysquery"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sysquery: nslookup reports danger (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
else|else
comment|/* "." domain gets LOG_WARNING here. */
name|syslog
argument_list|(
name|dname
index|[
literal|0
index|]
condition|?
name|LOG_INFO
else|:
name|LOG_WARNING
argument_list|,
literal|"sysquery: no addrs found for NS (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
block|}
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_fwd
operator|==
name|NULL
condition|)
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
comment|/* XXX - why not every? */
name|nsa
operator|=
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"sysquery: send -> %s dfd=%d nsid=%d id=%d retry=%ld\n"
operator|,
name|inet_etoa
argument_list|(
name|nsa
argument_list|)
operator|,
name|qp
operator|->
name|q_dfd
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|,
name|qp
operator|->
name|q_time
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sendto
argument_list|(
name|qp
operator|->
name|q_dfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|nsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nsa
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|sendtoStr
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"sysquery: sendto(%s): %m"
argument_list|,
name|inet_etoa
argument_list|(
name|nsa
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
block|}
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSentSysQ
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|qp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the list of root servers after receiving a response  * to a query for the root servers.  */
end_comment

begin_function
specifier|static
name|void
name|check_root
parameter_list|()
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|priming
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|hashtab
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"check_root: Can't find root!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
name|count
operator|++
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"%d root servers\n"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|MINROOTS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"check_root: %d root servers after query to root server< min"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
name|pdp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
operator|&&
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|&&
name|dp
operator|->
name|d_ttl
operator|<
name|tt
operator|.
name|tv_sec
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"deleting old root server '%s'\n"
operator|,
name|dp
operator|->
name|d_data
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|)
expr_stmt|;
comment|/* SHOULD DELETE FROM HINTS ALSO */
continue|continue;
block|}
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
name|check_ns
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Check the root to make sure that for each NS record we have a A RR  */
end_comment

begin_function
specifier|static
name|void
name|check_ns
parameter_list|()
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|tdp
decl_stmt|;
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|tnp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|found_arr
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|time_t
name|curtime
decl_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_ns()\n"
operator|)
argument_list|)
expr_stmt|;
name|curtime
operator|=
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
for|for
control|(
name|np
operator|=
name|hashtab
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
block|{
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_NS
condition|)
continue|continue;
comment|/* look for A records */
name|dname
operator|=
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|tnp
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnp
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_ns: %s: not found %s %#lx\n"
operator|,
name|dname
operator|,
name|fname
operator|,
operator|(
name|u_long
operator|)
name|tnp
operator|)
argument_list|)
expr_stmt|;
name|sysquery
argument_list|(
name|dname
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* look for name server addresses */
name|found_arr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tdp
operator|=
name|tnp
operator|->
name|n_data
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|tdp
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|tdp
operator|->
name|d_class
operator|!=
name|dp
operator|->
name|d_class
condition|)
continue|continue;
if|if
condition|(
operator|(
name|tdp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tdp
operator|->
name|d_ttl
operator|<
name|curtime
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"check_ns: stale entry '%s'\n"
operator|,
name|tnp
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
comment|/* Cache invalidate the address RR's */
name|delete_all
argument_list|(
name|tnp
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
name|found_arr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|found_arr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found_arr
condition|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* int findns(npp, class, nsp, countp, flag)  *	Find NS' or an SOA  * npp, class:  *	dname whose most enclosing NS is wanted  * nsp, countp:  *	result array and count; array will also be NULL terminated  * flag:  *	boolean: we're being called from ADDAUTH, bypass authority checks  * return value:  *	NXDOMAIN: we are authoritative for this {dname,class}  *	SERVFAIL: we are auth but zone isn't loaded; or, no root servers found  *	OK: success (this is the only case where *countp and nsp[] are valid)  */
end_comment

begin_function
name|int
name|findns
parameter_list|(
name|npp
parameter_list|,
name|class
parameter_list|,
name|nsp
parameter_list|,
name|countp
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|namebuf
modifier|*
modifier|*
name|npp
decl_stmt|;
name|int
name|class
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|nsp
decl_stmt|;
name|int
modifier|*
name|countp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|namebuf
modifier|*
name|np
init|=
operator|*
name|npp
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
modifier|*
name|nspp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|priming
operator|&&
operator|(
name|np
operator|==
name|NULL
operator|||
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|htp
operator|=
name|fcachetab
expr_stmt|;
else|else
name|htp
operator|=
name|hashtab
expr_stmt|;
name|try_again
label|:
if|if
condition|(
name|htp
operator|==
name|fcachetab
condition|)
name|needs_prime_cache
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|np
operator|==
name|NULL
operator|&&
name|htp
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: using %s\n"
operator|,
name|htp
operator|==
name|hashtab
condition|?
literal|"cache"
else|:
literal|"hints"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|htp
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
if|if
condition|(
name|np
operator|->
name|n_dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|htp
operator|=
operator|(
name|htp
operator|==
name|hashtab
condition|?
name|fcachetab
else|:
name|NULL
operator|)
expr_stmt|;
comment|/* Fallback */
block|}
while|while
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: np %#lx '%s'\n"
operator|,
operator|(
name|u_long
operator|)
name|np
operator|,
name|np
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
comment|/* Look first for SOA records. */
ifdef|#
directive|ifdef
name|ADDAUTH
if|if
condition|(
operator|!
name|flag
condition|)
endif|#
directive|endif
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|!=
literal|0
operator|&&
ifdef|#
directive|ifdef
name|PURGE_ZONE
operator|(
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_type
operator|==
name|Z_PRIMARY
operator|)
operator|||
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_type
operator|==
name|Z_SECONDARY
operator|)
operator|)
operator|&&
endif|#
directive|endif
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: SOA found\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_flags
operator|&
name|Z_AUTH
condition|)
block|{
operator|*
name|npp
operator|=
name|np
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|dp
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|nsp
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|dp
operator|->
name|d_rcnt
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
else|else
block|{
comment|/* XXX:	zone isn't loaded but we're 					 *	primary or secondary for it. 					 *	should we fwd this? 					 */
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
block|}
block|}
comment|/* If no SOA records, look for NS records. */
name|nspp
operator|=
operator|&
name|nsp
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
comment|/* 			 * Don't use records that may become invalid to 			 * reference later when we do the rtt computation. 			 * Never delete our safety-belt information! 			 * 			 * XXX:	this is horribly bogus. 			 */
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
ifdef|#
directive|ifdef
name|DATUMREFCNT
operator|(
name|dp
operator|->
name|d_ttl
operator|<
name|tt
operator|.
name|tv_sec
operator|)
operator|&&
else|#
directive|else
operator|(
name|dp
operator|->
name|d_ttl
operator|<
operator|(
name|tt
operator|.
name|tv_sec
operator|+
literal|900
operator|)
operator|)
operator|&&
endif|#
directive|endif
operator|!
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: stale entry '%s'\n"
operator|,
name|np
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
comment|/* Cache invalidate the NS RR's. */
ifndef|#
directive|ifndef
name|DATUMREFCNT
if|if
condition|(
name|dp
operator|->
name|d_ttl
operator|<
name|tt
operator|.
name|tv_sec
condition|)
endif|#
directive|endif
name|delete_all
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
expr_stmt|;
goto|goto
name|try_parent
goto|;
block|}
if|if
condition|(
name|nspp
operator|<
operator|&
name|nsp
index|[
name|NSMAX
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|nspp
operator|++
operator|=
name|dp
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|dp
operator|->
name|d_rcnt
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
operator|*
name|countp
operator|=
name|nspp
operator|-
name|nsp
expr_stmt|;
if|if
condition|(
operator|*
name|countp
operator|>
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: %d NS's added for '%s'\n"
operator|,
operator|*
name|countp
operator|,
name|np
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
operator|*
name|npp
operator|=
name|np
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
comment|/* Success, got some NS's */
block|}
name|try_parent
label|:
name|np
operator|=
name|np
operator|->
name|n_parent
expr_stmt|;
block|}
if|if
condition|(
name|htp
condition|)
goto|goto
name|try_again
goto|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"findns: No root nameservers for class %s?\n"
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|class
operator|<
name|MAXCLASS
operator|&&
name|norootlogged
index|[
name|class
index|]
operator|==
literal|0
condition|)
block|{
name|norootlogged
index|[
name|class
index|]
operator|=
literal|1
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"No root nameservers for class %s\n"
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Extract RR's from the given node that match class and type.  *  Return number of bytes added to response.  *  If no matching data is found, then 0 is returned.  */
end_comment

begin_function
name|int
name|finddata
parameter_list|(
name|np
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|,
name|hp
parameter_list|,
name|dnamep
parameter_list|,
name|lenp
parameter_list|,
name|countp
parameter_list|)
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
modifier|*
name|dnamep
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|,
decl|*
name|countp
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|n
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|foundstale
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ROUND_ROBIN
if|if
condition|(
name|type
operator|!=
name|T_ANY
operator|&&
name|type
operator|!=
name|T_PTR
condition|)
block|{
comment|/* cycle order of RRs, for a load balancing effect... */
specifier|register
name|struct
name|databuf
modifier|*
modifier|*
name|dpp
decl_stmt|;
for|for
control|(
name|dpp
operator|=
operator|&
name|np
operator|->
name|n_data
init|;
name|dp
operator|=
operator|*
name|dpp
condition|;
name|dpp
operator|=
operator|&
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_next
operator|&&
name|wanted
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|lp
decl_stmt|;
operator|*
name|dpp
operator|=
name|lp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
name|dp
operator|->
name|d_next
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dpp
operator|=
operator|&
name|lp
operator|->
name|d_next
init|;
operator|*
name|dpp
condition|;
name|dpp
operator|=
operator|&
name|lp
operator|->
name|d_next
control|)
name|lp
operator|=
operator|*
name|dpp
expr_stmt|;
operator|*
name|dpp
operator|=
name|dp
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/*ROUND_ROBIN*/
name|buflen
operator|=
operator|*
name|lenp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|buflen
operator|>
name|PACKETSZ
condition|)
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"finddata(): buflen=%d\n"
operator|,
name|buflen
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|)
operator|+
operator|*
name|countp
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|wanted
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|NCACHE
comment|/*if no negative caching then cname => nothing else*/
if|if
condition|(
name|type
operator|==
name|T_CNAME
operator|&&
name|class
operator|==
name|dp
operator|->
name|d_class
condition|)
block|{
comment|/* any data means no CNAME exists */
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*NCACHE*/
continue|continue;
block|}
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
comment|/* 			 * Don't use stale data. 			 * Would like to call delete_all here 			 * and continue, but the data chain would get 			 * munged; can't restart, as make_rr has side 			 * effects (leaving pointers in dnptr). 			 * Just skip this entry for now 			 * and call delete_all at the end. 			 */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"finddata: stale entry '%s'\n"
operator|,
name|np
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
condition|)
name|foundstale
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dp
operator|->
name|d_cred
operator|==
name|DB_C_ADDITIONAL
condition|)
block|{
comment|/* we want to expire additional data very 			 * quickly.  current strategy is to cut 5% 			 * off each time it is accessed.  this makes 			 * stale(dp) true faster when this datum is 			 * used often. 			 */
name|dp
operator|->
name|d_ttl
operator|=
name|tt
operator|.
name|tv_sec
operator|+
literal|0.95
operator|*
call|(
name|int
call|)
argument_list|(
name|dp
operator|->
name|d_ttl
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NCACHE
comment|/* -ve $ing stuff, anant@isi.edu 		 * if we have a -ve $ed record, change the rcode on the 		 * header to reflect that 		 */
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * This should not happen, yet it does... 				 */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NODATA& data for \"%s\" type %d class %d"
argument_list|,
operator|*
name|dnamep
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|!=
name|T_ANY
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NOERROR_NODATA
expr_stmt|;
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
comment|/* XXX - we have to report success */
block|}
comment|/* don't satisfy T_ANY queries from -$ info */
continue|continue;
block|}
ifndef|#
directive|ifndef
name|RETURNSOA
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
condition|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * This should not happen, yet it might... 				 */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"NXDOMAIN& data for \"%s\" type %d class %d"
argument_list|,
operator|*
name|dnamep
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|!=
name|T_ANY
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
comment|/* XXX - we have to report success */
block|}
comment|/* don't satisfy T_ANY queries from -$ info */
continue|continue;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/*NCACHE*/
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
operator|*
name|dnamep
argument_list|,
name|dp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
operator|*
name|lenp
operator|-
name|buflen
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* this isn't right for glue records, aa is set in ns_req */
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|&&
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_flags
operator|&
name|Z_AUTH
operator|)
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|T_ANY
condition|)
block|{
comment|/* or T_NS? */
operator|*
name|dnamep
operator|=
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|!=
name|DB_Z_CACHE
operator|&&
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_flags
operator|&
name|Z_AUTH
operator|)
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
comment|/* XXX */
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
block|}
break|break;
block|}
block|}
comment|/* 	 * Cache invalidate the other RR's of same type 	 * if some have timed out 	 */
if|if
condition|(
name|foundstale
condition|)
block|{
name|delete_all
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* XXX this isn't right if 'type' is something special 		 * such as T_AXFR or T_MAILB, since the matching done 		 * by match() in delete_all() is different from that 		 * done by wanted() above. 		 */
block|}
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"finddata: added %d class %d type %d RRs\n"
operator|,
name|count
operator|,
name|class
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
operator|*
name|lenp
operator|-
name|buflen
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Do we want this data record based on the class and type?  */
end_comment

begin_function
name|int
name|wanted
parameter_list|(
name|dp
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|)
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"wanted(%#lx, %d, %d) [%s %s]\n"
operator|,
operator|(
name|u_long
operator|)
name|dp
operator|,
name|class
operator|,
name|type
operator|,
name|p_class
argument_list|(
name|dp
operator|->
name|d_class
argument_list|)
operator|,
name|p_type
argument_list|(
name|dp
operator|->
name|d_type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|dp
operator|->
name|d_type
condition|)
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|NCACHE
comment|/*-ve $ing stuff, for a T_ANY query, we do not want to return 	 * -ve $ed RRs. 	 */
if|if
condition|(
name|type
operator|==
name|T_ANY
operator|&&
name|dp
operator|->
name|d_rcode
operator|==
name|NOERROR_NODATA
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_ANY
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_CNAME
case|:
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|!=
name|NOERROR_NODATA
condition|)
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|NCACHE
else|else
break|break;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_ANY
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_MAILB
case|:
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_MR
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MINFO
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|T_AXFR
case|:
comment|/* T_AXFR needs an authoritative SOA */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
operator|&&
name|dp
operator|->
name|d_zone
operator|!=
literal|0
operator|&&
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_flags
operator|&
name|Z_AUTH
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Add RR entries from dpp array to a query/response.  *  Return the number of bytes added or negative the amount  *  added if truncation was required.  Typically you are  *  adding NS records to a response.  */
end_comment

begin_function
name|int
name|add_data
parameter_list|(
name|np
parameter_list|,
name|dpp
parameter_list|,
name|cp
parameter_list|,
name|buflen
parameter_list|)
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|dpp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|buflen
decl_stmt|;
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
operator|*
name|dpp
operator|++
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
operator|*
name|dpp
operator|++
control|)
block|{
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
comment|/* ignore old cache entry */
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|count
operator|)
return|;
comment|/* Truncation */
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|+=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  This is best thought of as a "cache invalidate" function.  *  It is called whenever a piece of data is determined to have  *  timed out.  It is better to have no information, than to  *  have partial information you pass off as complete.  */
end_comment

begin_function
name|void
name|delete_all
parameter_list|(
name|np
parameter_list|,
name|class
parameter_list|,
name|type
parameter_list|)
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"delete_all(%#lx:\"%s\" %s %s)\n"
operator|,
operator|(
name|u_long
operator|)
name|np
operator|,
name|np
operator|->
name|n_dname
operator|,
name|p_class
argument_list|(
name|class
argument_list|)
operator|,
name|p_type
argument_list|(
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pdp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|&&
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
block|}
end_function

end_unit

