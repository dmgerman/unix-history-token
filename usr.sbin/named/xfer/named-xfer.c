begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The original version of xfer by Kevin Dunlap.  * Completed and integrated with named by David Waitzman  *	(dwaitzman@bbn.com) 3/14/88.  * Modified by M. Karels and O. Kure 10-88.  * Modified extensively since then by just about everybody.  */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1988, 1990  * -  * Copyright (c) 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1988, 1990 The Regents of the University of California.\n\  portions Copyright (c) 1993 Digital Equipment Corporation\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)named-xfer.c	4.18 (Berkeley) 3/7/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__osf__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_define
define|#
directive|define
name|TIME_H_INCLUDED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|MAIN_PROGRAM
end_define

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_undef
undef|#
directive|undef
name|MAIN_PROGRAM
end_undef

begin_ifndef
ifndef|#
directive|ifndef
name|LOG_PERROR
end_ifndef

begin_define
define|#
directive|define
name|LOG_PERROR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|zoneinfo
name|zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zone information */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ddtfilename
index|[]
init|=
name|_PATH_TMPXFER
decl_stmt|,
modifier|*
name|ddtfile
init|=
name|ddtfilename
decl_stmt|,
modifier|*
name|tmpname
decl_stmt|,
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* domain being xfered */
end_comment

begin_decl_stmt
specifier|static
name|int
name|quiet
init|=
literal|0
decl_stmt|,
name|read_interrupted
init|=
literal|0
decl_stmt|,
name|curclass
decl_stmt|,
name|domain_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* strlen(domain) */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|,
modifier|*
name|dbfp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ProgName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getzone
name|__P
argument_list|(
operator|(
expr|struct
name|zoneinfo
operator|*
operator|,
name|u_int32_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|print_output
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|int
operator|,
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|netread
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SIG_FN
name|read_alarm
name|__P
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|soa_zinfo
name|__P
argument_list|(
operator|(
expr|struct
name|zoneinfo
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|,
name|getopt
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|dbfile
init|=
name|NULL
decl_stmt|,
modifier|*
name|tracefile
init|=
name|NULL
decl_stmt|,
modifier|*
name|tm
init|=
name|NULL
decl_stmt|;
name|int
name|dbfd
decl_stmt|,
name|ddtd
decl_stmt|,
name|result
decl_stmt|,
name|c
decl_stmt|,
name|fd
decl_stmt|,
name|closed
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|serial_no
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|port
init|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|STUBS
name|int
name|stub_only
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GEN_AXFR
name|int
name|class
init|=
name|C_IN
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ProgName
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
name|ProgName
operator|++
expr_stmt|;
else|else
name|ProgName
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
comment|/* this is a hack; closing everything in the parent is hard. */
for|for
control|(
name|fd
operator|=
name|getdtablesize
argument_list|()
operator|-
literal|1
init|;
name|fd
operator|>
name|STDERR_FILENO
condition|;
name|fd
operator|--
control|)
name|closed
operator|+=
operator|(
name|close
argument_list|(
name|fd
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RENICE
name|nice
argument_list|(
operator|-
literal|40
argument_list|)
expr_stmt|;
comment|/* this is the recommended procedure to        */
name|nice
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/*   reset the priority of the current process */
name|nice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*   to "normal" (== 0) - see nice(3)          */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LOG_DAEMON
name|openlog
argument_list|(
name|ProgName
argument_list|,
name|LOG_PID
operator||
name|LOG_CONS
operator||
name|LOG_PERROR
argument_list|,
name|LOGFAC
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
name|ProgName
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STUBS
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"C:d:l:s:t:z:f:p:P:qS"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
else|#
directive|else
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"C:d:l:s:t:z:f:p:P:q"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|GEN_AXFR
case|case
literal|'C'
case|:
name|class
operator|=
name|get_class
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'l'
case|:
name|ddtfile
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|".XXXXXX"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHORT_FNAMES
name|filenamecpy
argument_list|(
name|ddtfile
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ddtfile
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SHORT_FNAMES */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|ddtfile
argument_list|,
literal|".XXXXXX"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|serial_no
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tracefile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* zone == domain */
name|domain
operator|=
name|optarg
expr_stmt|;
name|domain_len
operator|=
name|strlen
argument_list|(
name|domain
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|domain_len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|domain
index|[
name|domain_len
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
name|domain
index|[
operator|--
name|domain_len
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|dbfile
operator|=
name|optarg
expr_stmt|;
name|tmpname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|".XXXXXX"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHORT_FNAMES
name|filenamecpy
argument_list|(
name|tmpname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SHORT_FNAMES */
break|break;
case|case
literal|'p'
case|:
name|port
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|port
operator|=
operator|(
name|u_int16_t
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|STUBS
case|case
literal|'S'
case|:
name|stub_only
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
literal|"unrecognized argument"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|!
name|domain
operator|||
operator|!
name|dbfile
operator|||
name|optind
operator|>=
name|argc
condition|)
block|{
if|if
condition|(
operator|!
name|domain
condition|)
name|usage
argument_list|(
literal|"no domain"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbfile
condition|)
name|usage
argument_list|(
literal|"no dbfile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
name|usage
argument_list|(
literal|"not enough arguments"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|stat
argument_list|(
name|dbfile
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISFIFO
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
name|usage
argument_list|(
literal|"dbfile must be a regular file or FIFO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracefile
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|tracefile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perror
argument_list|(
name|tracefile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tmpname
argument_list|,
literal|".XXXXXX"
argument_list|)
expr_stmt|;
comment|/* tmpname is now something like "/etc/named/named.bu.db.XXXXXX" */
if|if
condition|(
operator|(
name|dbfd
operator|=
name|mkstemp
argument_list|(
name|tmpname
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't make tmpfile (%s): %m\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_FCHMOD
if|if
condition|(
name|fchmod
argument_list|(
name|dbfd
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|chmod
argument_list|(
name|tmpname
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|perror
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't [f]chmod tmpfile (%s): %m\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dbfp
operator|=
name|fdopen
argument_list|(
name|dbfd
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't fdopen tmpfile (%s)"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
comment|/* ddtfile is now something like "/usr/tmp/xfer.ddt.XXXXXX" */
if|if
condition|(
operator|(
name|ddtd
operator|=
name|mkstemp
argument_list|(
name|ddtfile
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|ddtfile
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|HAVE_FCHMOD
elseif|else
if|if
condition|(
name|fchmod
argument_list|(
name|ddtd
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
name|chmod
argument_list|(
name|ddtfile
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|perror
argument_list|(
name|ddtfile
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ddt
operator|=
name|fdopen
argument_list|(
name|ddtd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|ddtfile
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|HAVE_SETVBUF
name|setvbuf
argument_list|(
name|ddt
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|setlinebuf
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Ignore many types of signals that named (assumed to be our parent) 	 * considers important- if not, the user controlling named with 	 * signals usually kills us. 	 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGSYS
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SIGUSR1&&SIGUSR2 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGUSR1&&SIGUSR2 */
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"domain `%s'; file `%s'; serial %lu; closed %d\n"
operator|,
name|domain
operator|,
name|dbfile
operator|,
operator|(
name|u_long
operator|)
name|serial_no
operator|,
name|closed
operator|)
argument_list|)
expr_stmt|;
name|buildservicelist
argument_list|()
expr_stmt|;
name|buildprotolist
argument_list|()
expr_stmt|;
comment|/* init zone data */
name|zp
operator|=
operator|&
name|zone
expr_stmt|;
ifdef|#
directive|ifdef
name|STUBS
if|if
condition|(
name|stub_only
condition|)
name|zp
operator|->
name|z_type
operator|=
name|Z_STUB
expr_stmt|;
else|else
endif|#
directive|endif
name|zp
operator|->
name|z_type
operator|=
name|Z_SECONDARY
expr_stmt|;
ifdef|#
directive|ifdef
name|GEN_AXFR
name|zp
operator|->
name|z_class
operator|=
name|class
expr_stmt|;
endif|#
directive|endif
name|zp
operator|->
name|z_origin
operator|=
name|domain
expr_stmt|;
name|zp
operator|->
name|z_source
operator|=
name|dbfile
expr_stmt|;
name|zp
operator|->
name|z_addrcnt
operator|=
literal|0
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"zone found (%d): \"%s\", source = %s\n"
operator|,
name|zp
operator|->
name|z_type
operator|,
operator|(
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
literal|"."
else|:
name|zp
operator|->
name|z_origin
operator|,
name|zp
operator|->
name|z_source
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|!=
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|tm
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|tm
argument_list|,
operator|&
name|zp
operator|->
name|z_addr
index|[
name|zp
operator|->
name|z_addrcnt
index|]
argument_list|)
condition|)
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"uninterpretable server (%s) for %s\n"
argument_list|,
name|tm
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|zp
operator|->
name|z_addr
index|[
name|zp
operator|->
name|z_addrcnt
index|]
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"Arg: \"%s\"\n"
operator|,
name|tm
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_addr
index|[
name|zp
operator|->
name|z_addrcnt
index|]
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"SOA query to 0.0.0.0 (%s) for %s"
argument_list|,
name|tm
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|++
name|zp
operator|->
name|z_addrcnt
operator|>=
name|NSMAX
condition|)
block|{
name|zp
operator|->
name|z_addrcnt
operator|=
name|NSMAX
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"NSMAX reached\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"addrcnt = %d\n"
operator|,
name|zp
operator|->
name|z_addrcnt
operator|)
argument_list|)
expr_stmt|;
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator||
name|RES_RECURSE
operator|)
expr_stmt|;
name|result
operator|=
name|getzone
argument_list|(
name|zp
argument_list|,
name|serial_no
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|dbfp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|XFER_SUCCESS
case|:
comment|/* ok exit */
if|if
condition|(
name|rename
argument_list|(
name|tmpname
argument_list|,
name|dbfile
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"rename"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rename %s to %s: %m"
argument_list|,
name|tmpname
argument_list|,
name|dbfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|XFER_SUCCESS
argument_list|)
expr_stmt|;
case|case
name|XFER_UPTODATE
case|:
comment|/* the zone was already uptodate */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_UPTODATE
argument_list|)
expr_stmt|;
case|case
name|XFER_TIMEOUT
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|debug
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* servers not reachable exit */
case|case
name|XFER_FAIL
case|:
default|default:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|debug
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
comment|/* yuck exit */
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|UsageText
index|[]
init|=
block|{
literal|"\t-z zone_to_transfer\n"
block|,
literal|"\t-f db_file\n"
block|,
literal|"\t-s serial_no\n"
block|,
literal|"\t[-d debug_level]\n"
block|,
literal|"\t[-l debug_log_file]\n"
block|,
literal|"\t[-t trace_file]\n"
block|,
literal|"\t[-p port]\n"
block|,
ifdef|#
directive|ifdef
name|STUBS
literal|"\t[-S]\n"
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GEN_AXFR
literal|"\t[-C class]\n"
block|,
endif|#
directive|endif
literal|"\tservers...\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|char
modifier|*
specifier|const
modifier|*
name|line
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage error: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s\n"
argument_list|,
name|ProgName
argument_list|)
expr_stmt|;
for|for
control|(
name|line
operator|=
name|UsageText
init|;
operator|*
name|line
condition|;
name|line
operator|++
control|)
name|fputs
argument_list|(
operator|*
name|line
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DEF_DNAME
value|'\001'
end_define

begin_comment
comment|/* '\0' means the root domain */
end_comment

begin_comment
comment|/* XXX: The following variables should probably all be "static" */
end_comment

begin_decl_stmt
name|int
name|minimum_ttl
init|=
literal|0
decl_stmt|,
name|got_soa
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prev_comment
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* was previous record a comment? */
end_comment

begin_decl_stmt
name|char
name|zone_top
index|[
name|MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the top of the zone */
end_comment

begin_decl_stmt
name|char
name|prev_origin
index|[
name|MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from most recent $ORIGIN line */
end_comment

begin_decl_stmt
name|char
name|prev_dname
index|[
name|MAXDNAME
index|]
init|=
block|{
name|DEF_DNAME
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from previous record */
end_comment

begin_decl_stmt
name|char
name|prev_ns_dname
index|[
name|MAXDNAME
index|]
init|=
block|{
name|DEF_DNAME
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from most recent NS record */
end_comment

begin_function
specifier|static
name|int
name|getzone
parameter_list|(
name|zp
parameter_list|,
name|serial_no
parameter_list|,
name|port
parameter_list|)
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|u_int32_t
name|serial_no
decl_stmt|;
name|int
name|port
decl_stmt|;
block|{
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_int16_t
name|len
decl_stmt|;
name|u_int32_t
name|serial
decl_stmt|;
name|int
name|s
decl_stmt|,
name|n
decl_stmt|,
name|l
decl_stmt|,
name|nscnt
decl_stmt|,
name|soacnt
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|u_int
name|cnt
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|nmp
decl_stmt|,
modifier|*
name|eom
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|u_char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|u_int
name|bufsize
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|name2
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|zoneinfo
name|zp_start
decl_stmt|,
name|zp_finish
decl_stmt|;
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
name|struct
name|sigaction
name|sv
decl_stmt|,
name|osv
decl_stmt|;
else|#
directive|else
name|struct
name|sigvec
name|sv
decl_stmt|,
name|osv
decl_stmt|;
endif|#
directive|endif
name|int
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|,
name|aucount
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|badsoa_msg
init|=
literal|"Nil"
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"getzone() %s "
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_STUB
case|:
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"stub\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_SECONDARY
case|:
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"secondary\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"unknown type\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sv
argument_list|,
sizeof|sizeof
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|.
name|sa_handler
operator|=
operator|(
name|SIG_FN
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|read_alarm
expr_stmt|;
comment|/* SA_ONSTACK isn't recommended for strict POSIX code */
comment|/* is it absolutely necessary? */
comment|/* sv.sa_flags = SA_ONSTACK; */
name|sigfillset
argument_list|(
operator|&
name|sv
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|sv
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
else|#
directive|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sv
argument_list|,
sizeof|sizeof
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|.
name|sv_handler
operator|=
name|read_alarm
expr_stmt|;
name|sv
operator|.
name|sv_mask
operator|=
operator|~
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|sv
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|zone_top
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|=
name|strlen
argument_list|(
name|zone_top
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|zone_top
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|zone_top
index|[
name|l
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|prev_origin
argument_list|,
name|zone_top
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|zp
operator|->
name|z_addrcnt
condition|;
name|cnt
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|GEN_AXFR
name|curclass
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
else|#
directive|else
name|curclass
operator|=
name|C_IN
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
name|PACKETSZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malloc(%u) failed"
argument_list|,
literal|2
operator|*
name|PACKETSZ
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
name|bufsize
operator|=
literal|2
operator|*
name|PACKETSZ
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
operator|(
name|u_int16_t
operator|)
name|port
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|zp
operator|->
name|z_addr
index|[
name|cnt
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"socket: %m"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"connecting to server #%d [%s].%d\n"
operator|,
name|cnt
operator|+
literal|1
operator|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
operator|,
name|ntohs
argument_list|(
name|sin
operator|.
name|sin_port
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"connect(%s) for zone %s failed: %m"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifndef|#
directive|ifndef
name|GEN_AXFR
name|tryagain
label|:
endif|#
directive|endif
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|curclass
argument_list|,
name|T_SOA
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"zone %s: res_mkquery T_SOA failed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
comment|/* 		 * Send length& message for SOA query 		 */
if|if
condition|(
name|writemsg
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"writemsg: %m"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Get out your butterfly net and catch the SOA 		 */
if|if
condition|(
name|netread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|INT16SZ
argument_list|,
name|XFER_TIMER
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|_getshort
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|len
operator|>
name|bufsize
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malloc(%u) failed for SOA from server [%s], zone %s\n"
argument_list|,
name|len
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bufsize
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|netread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|,
name|XFER_TIMER
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"len = %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fp_nquery
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|buf
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|aucount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
comment|/* 		 * close socket if any of these apply: 		 *  1) rcode != NOERROR 		 *  2) not an authority response 		 *  3) not an answer to our question 		 *  4) both the number of answers and authority count< 1) 		 */
if|if
condition|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
operator|!
name|hp
operator|->
name|aa
operator|||
name|qdcount
operator|!=
literal|1
operator|||
operator|(
name|ancount
operator|<
literal|1
operator|&&
name|aucount
operator|<
literal|1
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|GEN_AXFR
if|if
condition|(
name|curclass
operator|==
name|C_IN
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"SOA failed, trying C_HS\n"
operator|)
argument_list|)
expr_stmt|;
name|curclass
operator|=
name|C_HS
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s from [%s], zone %s: rcode %d, aa %d, ancount %d, aucount %d\n"
argument_list|,
literal|"bad response to SOA query"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|hp
operator|->
name|aa
argument_list|,
name|ancount
argument_list|,
name|aucount
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|zp_start
operator|=
operator|*
name|zp
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|len
operator|<
name|HFIXEDSZ
operator|+
name|QFIXEDSZ
condition|)
block|{
name|badsoa_msg
operator|=
literal|"too short"
expr_stmt|;
name|badsoa
label|:
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malformed SOA from [%s], zone %s: %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|badsoa_msg
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Step through response. 		 */
name|tmp
operator|=
name|buf
operator|+
name|HFIXEDSZ
expr_stmt|;
name|eom
operator|=
name|buf
operator|+
name|len
expr_stmt|;
comment|/* Query Section. */
name|n
operator|=
name|dn_expand
argument_list|(
name|buf
argument_list|,
name|eom
argument_list|,
name|tmp
argument_list|,
name|name2
argument_list|,
sizeof|sizeof
name|name2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|badsoa_msg
operator|=
literal|"qname error"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
name|tmp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|curclass
operator|||
name|type
operator|!=
name|T_SOA
operator|||
name|strcasecmp
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|name2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"wrong query in resp from [%s], zone %s: [%s %s %s]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|name2
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* ... Answer Section. */
name|n
operator|=
name|dn_expand
argument_list|(
name|buf
argument_list|,
name|eom
argument_list|,
name|tmp
argument_list|,
name|name2
argument_list|,
sizeof|sizeof
name|name2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|badsoa_msg
operator|=
literal|"aname error"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
name|tmp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|name2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"wrong answer in resp from [%s], zone %s: [%s %s %s]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|name2
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|badsoa_msg
operator|=
name|soa_zinfo
argument_list|(
operator|&
name|zp_start
argument_list|,
name|tmp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|badsoa_msg
condition|)
goto|goto
name|badsoa
goto|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|zp_start
operator|.
name|z_serial
argument_list|,
name|serial_no
argument_list|)
operator|||
operator|!
name|serial_no
condition|)
block|{
specifier|const
name|char
modifier|*
name|l
decl_stmt|,
modifier|*
name|nl
decl_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"need update, serial %lu\n"
operator|,
operator|(
name|u_long
operator|)
name|zp_start
operator|.
name|z_serial
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|buf
expr_stmt|;
name|soacnt
operator|=
literal|0
expr_stmt|;
name|nscnt
operator|=
literal|0
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|Version
init|;
name|l
condition|;
name|l
operator|=
name|nl
control|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|nl
operator|=
name|strchr
argument_list|(
name|l
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|nl
operator|-
name|l
expr_stmt|;
name|nl
operator|=
name|nl
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|nl
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|l
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|l
condition|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; BIND version %.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; zone '%s'   last serial %lu\n"
argument_list|,
name|domain
argument_list|,
operator|(
name|u_long
operator|)
name|serial_no
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; from %s   at %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ctimel
argument_list|(
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|soacnt
operator|==
literal|0
operator|)
operator|||
operator|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
operator|)
condition|)
block|{
name|int
name|type
decl_stmt|;
ifdef|#
directive|ifdef
name|STUBS
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
condition|)
block|{
if|if
condition|(
operator|!
name|soacnt
condition|)
name|type
operator|=
name|T_SOA
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|nscnt
condition|)
name|type
operator|=
name|T_NS
expr_stmt|;
else|else
name|type
operator|=
name|T_SOA
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|type
operator|=
name|T_AXFR
expr_stmt|;
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|curclass
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
ifdef|#
directive|ifdef
name|STUBS
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
operator|(
name|type
operator|==
name|T_SOA
operator|)
condition|?
literal|"zone %s: res_mkquery T_SOA failed"
else|:
literal|"zone %s: res_mkquery T_NS failed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"zone %s: res_mkquery T_AXFR failed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
comment|/* 					 * Send length& msg for zone transfer 					 */
if|if
condition|(
name|writemsg
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"writemsg: %m"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 				 * Receive length& response 				 */
if|if
condition|(
name|netread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|INT16SZ
argument_list|,
operator|(
name|soacnt
operator|==
literal|0
operator|)
condition|?
literal|300
else|:
name|XFER_TIMER
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|_getshort
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|eom
operator|=
name|buf
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|netread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|,
name|XFER_TIMER
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"len = %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fp_nquery
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
condition|)
name|fp_nquery
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|<
name|HFIXEDSZ
condition|)
block|{
name|badrec
label|:
name|error
operator|++
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"record too short from [%s], zone %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
break|break;
block|}
name|cp
operator|=
name|buf
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|qdcount
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
name|n
operator|+
name|QFIXEDSZ
operator|>=
name|eom
operator|-
name|cp
condition|)
goto|goto
name|badrec
goto|;
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
block|}
name|nmp
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|badrec
goto|;
name|tmp
operator|=
name|cp
operator|+
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|STUBS
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
condition|)
block|{
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|ancount
condition|;
name|cnt
operator|++
control|)
block|{
name|n
operator|=
name|print_output
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|nscount
condition|)
block|{
comment|/* we should not get here */
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|ancount
condition|;
name|cnt
operator|++
control|)
block|{
name|n
operator|=
name|print_output
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
block|}
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|ancount
condition|;
name|cnt
operator|++
control|)
block|{
name|n
operator|=
name|print_output
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|eom
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"print_output: short answer (%d, %d), zone %s"
argument_list|,
name|cp
operator|-
name|buf
argument_list|,
name|n
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/*STUBS*/
name|n
operator|=
name|print_output
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|n
operator|!=
name|eom
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"print_output: short answer (%d, %d), zone %s"
argument_list|,
name|cp
operator|-
name|buf
argument_list|,
name|n
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|STUBS
block|}
endif|#
directive|endif
name|GETSHORT
argument_list|(
name|n
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|T_SOA
condition|)
block|{
if|if
condition|(
name|soacnt
operator|==
literal|0
condition|)
block|{
name|soacnt
operator|++
expr_stmt|;
if|if
condition|(
name|dn_expand
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|PACKETSZ
argument_list|,
name|nmp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|badsoa_msg
operator|=
literal|"soa name error"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"wrong zone name in AXFR (wanted \"%s\", got \"%s\")"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|badsoa_msg
operator|=
literal|"wrong soa name"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
if|if
condition|(
name|eom
operator|-
name|tmp
operator|<=
literal|2
operator|*
name|INT16SZ
operator|+
name|INT32SZ
condition|)
block|{
name|badsoa_msg
operator|=
literal|"soa header"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
name|tmp
operator|+=
literal|2
operator|*
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tmp
argument_list|,
name|eom
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|badsoa_msg
operator|=
literal|"soa mname"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
name|tmp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tmp
argument_list|,
name|eom
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|badsoa_msg
operator|=
literal|"soa hname"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
name|tmp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|eom
operator|-
name|tmp
operator|<=
name|INT32SZ
condition|)
block|{
name|badsoa_msg
operator|=
literal|"soa dlen"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
name|GETLONG
argument_list|(
name|serial
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"first SOA for %s, serial %lu\n"
operator|,
name|name
operator|,
operator|(
name|u_long
operator|)
name|serial
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|dn_expand
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|PACKETSZ
argument_list|,
name|nmp
argument_list|,
name|name2
argument_list|,
sizeof|sizeof
name|name2
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|badsoa_msg
operator|=
literal|"soa name error#2"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"got extra SOA for \"%s\" in zone \"%s\""
argument_list|,
name|name2
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|tmp
operator|-=
name|INT16SZ
expr_stmt|;
comment|/* Put TYPE back. */
name|badsoa_msg
operator|=
name|soa_zinfo
argument_list|(
operator|&
name|zp_finish
argument_list|,
name|tmp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|badsoa_msg
condition|)
goto|goto
name|badsoa
goto|;
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"SOA, serial %lu\n"
operator|,
operator|(
name|u_long
operator|)
name|zp_finish
operator|.
name|z_serial
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial
operator|!=
name|zp_finish
operator|.
name|z_serial
condition|)
block|{
name|soacnt
operator|=
literal|0
expr_stmt|;
name|got_soa
operator|=
literal|0
expr_stmt|;
name|minimum_ttl
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|prev_origin
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|prev_dname
index|[
literal|0
index|]
operator|=
name|DEF_DNAME
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"serial changed, restart\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 					 * Flush buffer, truncate file 					 * and seek to beginning to restart. 					 */
name|fflush
argument_list|(
name|dbfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|dbfp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ftruncate %s: %m\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
name|fseek
argument_list|(
name|dbfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
ifdef|#
directive|ifdef
name|STUBS
block|}
elseif|else
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
operator|&&
name|n
operator|==
name|T_NS
condition|)
block|{
name|nscnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
condition|)
block|{
break|break;
endif|#
directive|endif
block|}
block|}
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|XFER_SUCCESS
operator|)
return|;
block|}
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"error receiving zone transfer\n"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zp_start
operator|.
name|z_serial
operator|==
name|serial_no
condition|)
block|{
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"zone up-to-date, serial %u\n"
operator|,
name|zp_start
operator|.
name|z_serial
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFER_UPTODATE
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"serial from [%s], zone %s: %u lower than current: %u\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp_start
operator|.
name|z_serial
argument_list|,
name|serial_no
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|XFER_TIMEOUT
operator|)
return|;
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set flag saying to read was interrupted  * used for a read timer  */
end_comment

begin_function
specifier|static
name|SIG_FN
name|read_alarm
parameter_list|()
block|{
name|read_interrupted
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|netread
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|timeout
parameter_list|)
name|int
name|fd
decl_stmt|;
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
specifier|static
specifier|const
name|char
name|setitimerStr
index|[]
init|=
literal|"setitimer: %m"
decl_stmt|;
name|struct
name|itimerval
name|ival
decl_stmt|,
name|zeroival
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NETREAD_BROKEN
argument_list|)
name|int
name|retries
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|zeroival
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|zeroival
argument_list|)
expr_stmt|;
name|ival
operator|=
name|zeroival
expr_stmt|;
name|ival
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|timeout
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|ival
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|setitimerStr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|recv
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|errno
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NETREAD_BROKEN
argument_list|)
if|if
condition|(
operator|++
name|retries
operator|<
literal|42
condition|)
comment|/* doug adams */
continue|continue;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"premature EOF, fetching \"%s\""
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NETREAD_BROKEN
argument_list|)
if|if
condition|(
operator|++
name|retries
operator|<
literal|42
condition|)
comment|/* doug adams */
continue|continue;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"recv(len=%d): n=%d&& !errno"
argument_list|,
name|len
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
operator|!
name|read_interrupted
condition|)
block|{
comment|/* It wasn't a timeout; ignore it. */
continue|continue;
block|}
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"recv(len=%d): %m"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|buf
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|zeroival
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|setitimerStr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|soa_zinfo
parameter_list|(
name|zp
parameter_list|,
name|cp
parameter_list|,
name|eom
parameter_list|)
specifier|register
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|eom
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|;
name|u_long
name|ttl
decl_stmt|;
comment|/* Are type, class, and ttl OK? */
if|if
condition|(
name|eom
operator|-
name|cp
operator|<
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
condition|)
return|return
operator|(
literal|"zinfo too short"
operator|)
return|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* dlen */
if|if
condition|(
name|type
operator|!=
name|T_SOA
operator|||
name|class
operator|!=
name|curclass
operator|||
name|ttl
operator|==
literal|0
condition|)
return|return
operator|(
literal|"zinfo wrong typ/cla/ttl"
operator|)
return|;
comment|/* Skip master name and contact name, we can't validate them. */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|"zinfo mname"
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|"zinfo hname"
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Grab the data fields. */
if|if
condition|(
name|eom
operator|-
name|cp
operator|<
literal|5
operator|*
name|INT32SZ
condition|)
return|return
operator|(
literal|"zinfo dlen"
operator|)
return|;
name|GETLONG
argument_list|(
name|zp
operator|->
name|z_serial
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|zp
operator|->
name|z_refresh
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|zp
operator|->
name|z_retry
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|zp
operator|->
name|z_expire
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|zp
operator|->
name|z_minimum
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the message, determine if it should be printed, and if so, print it  * in .db file form.  * Does minimal error checking on the message content.  */
end_comment

begin_function
specifier|static
name|int
name|print_output
parameter_list|(
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|rrp
parameter_list|)
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|rrp
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|,
name|ttl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|tab
decl_stmt|,
name|result
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dlen
decl_stmt|,
name|n1
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|iso_addr
name|isoa
decl_stmt|;
name|char
name|data
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
modifier|*
name|temp_ptr
decl_stmt|;
name|char
modifier|*
name|cdata
decl_stmt|,
modifier|*
name|origin
decl_stmt|,
modifier|*
name|proto
decl_stmt|,
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
modifier|*
name|ignore
init|=
literal|""
decl_stmt|;
name|cp
operator|=
name|rrp
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|origin
operator|=
name|strchr
argument_list|(
name|dname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|==
name|NULL
condition|)
name|origin
operator|=
literal|""
expr_stmt|;
else|else
name|origin
operator|++
expr_stmt|;
comment|/* move past the '.' */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"print_output: dname %s type %d class %d ttl %d\n"
operator|,
name|dname
operator|,
name|type
operator|,
name|class
operator|,
name|ttl
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the resource record data into the internal database format. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_UINFO
case|:
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
case|case
name|T_ISDN
case|:
case|case
name|T_LOC
case|:
case|case
name|T_NSAP
case|:
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
name|cp1
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dlen
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_SOA
case|:
case|case
name|T_RP
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|n
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
name|data
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
name|n1
operator|-=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|temp_ptr
operator|=
name|cp
operator|+
literal|4
operator|*
name|INT32SZ
expr_stmt|;
name|GETLONG
argument_list|(
name|minimum_ttl
argument_list|,
name|temp_ptr
argument_list|)
expr_stmt|;
name|n
operator|=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
comment|/* grab preference */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|data
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* get name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
comment|/* grab preference */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|data
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* get MAP822 name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
operator|(
name|n
operator|=
operator|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
name|data
operator|-
name|n
expr_stmt|;
comment|/* get MAPX400 name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"\"%s %s %s\" - unknown type (%d)"
argument_list|,
name|dname
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOTIMP
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"update type %d: %d bytes is too much data\n"
operator|,
name|type
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cdata
operator|=
operator|(
name|char
operator|*
operator|)
name|cp1
expr_stmt|;
name|result
operator|=
name|cp
operator|-
name|rrp
expr_stmt|;
comment|/* 	 * Only print one SOA per db file 	 */
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
if|if
condition|(
name|got_soa
condition|)
return|return
operator|(
name|result
operator|)
return|;
else|else
name|got_soa
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NO_GLUE
comment|/* 	 * If they are trying to tell us info about something that is 	 * not in the zone that we are transfering, then ignore it! 	 * They don't have the authority to tell us this info. 	 * 	 * We have to do a bit of checking here - the name that we are 	 * checking vs is fully qualified& may be in a subdomain of the 	 * zone in question.  We also need to ignore any final dots. 	 * 	 * If a domain has both NS records and non-NS records, (for 	 * example, NS and MX records), then we should ignore the non-NS 	 * records (except that we should not ignore glue A records). 	 * XXX: It is difficult to do this properly, so we just compare 	 * the current dname with that in the most recent NS record. 	 * This defends against the most common error case, 	 * where the remote server sends MX records soon after the 	 * NS records for a particular domain.  If sent earlier, we lose. XXX 	 */
if|if
condition|(
operator|!
name|samedomain
argument_list|(
name|dname
argument_list|,
name|domain
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; Ignoring info about %s, not in zone %s.\n"
argument_list|,
name|dname
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|ignore
operator|=
literal|"; "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|T_NS
operator|&&
name|type
operator|!=
name|T_A
operator|&&
name|strcasecmp
argument_list|(
name|zone_top
argument_list|,
name|dname
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|prev_ns_dname
argument_list|,
name|dname
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; Ignoring extra info about %s, invalid after NS delegation.\n"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|ignore
operator|=
literal|"; "
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*NO_GLUE*/
comment|/* 	 * If the current record is not being ignored, but the 	 * previous record was ignored, then we invalidate information 	 * that might have been altered by ignored records. 	 * (This means that we sometimes output unnecessary $ORIGIN 	 * lines, but that is harmless.) 	 * 	 * Also update prev_comment now. 	 */
if|if
condition|(
name|prev_comment
operator|&&
name|ignore
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|prev_dname
index|[
literal|0
index|]
operator|=
name|DEF_DNAME
expr_stmt|;
name|prev_origin
index|[
literal|0
index|]
operator|=
name|DEF_DNAME
expr_stmt|;
block|}
name|prev_comment
operator|=
operator|(
name|ignore
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
expr_stmt|;
comment|/* 	 * set prev_ns_dname if necessary 	 */
if|if
condition|(
name|type
operator|==
name|T_NS
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prev_ns_dname
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the origin has changed, print the new origin 	 */
if|if
condition|(
name|strcasecmp
argument_list|(
name|prev_origin
argument_list|,
name|origin
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prev_origin
argument_list|,
name|origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s$ORIGIN %s.\n"
argument_list|,
name|ignore
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
name|tab
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|prev_dname
argument_list|,
name|dname
argument_list|)
condition|)
block|{
comment|/* 		 * set the prev_dname to be the current dname, then cut off all 		 * characters of dname after (and including) the first '.' 		 */
name|char
modifier|*
name|cutp
init|=
name|strchr
argument_list|(
name|dname
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prev_dname
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cutp
condition|)
operator|*
name|cutp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|origin
index|[
literal|0
index|]
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s.\t"
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s.%s.\t"
argument_list|,
name|ignore
argument_list|,
name|origin
argument_list|)
expr_stmt|;
comment|/* ??? */
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s%s\t"
argument_list|,
name|ignore
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dname
argument_list|)
operator|<
operator|(
name|size_t
operator|)
literal|8
condition|)
name|tab
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\t"
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|tab
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ttl
operator|!=
literal|0
operator|&&
name|ttl
operator|!=
name|minimum_ttl
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%d\t"
argument_list|,
operator|(
name|int
operator|)
name|ttl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tab
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\t%s\t"
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cdata
expr_stmt|;
comment|/* 	 * Print type specific data 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_IN
case|:
case|case
name|C_HS
case|:
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|htonl
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|n
argument_list|)
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NS
case|:
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cdata
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|".\t"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_HINFO
case|:
case|case
name|T_ISDN
case|:
name|cp2
operator|=
name|cp
operator|+
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|cp1
operator|=
name|cp
operator|+
name|n
expr_stmt|;
if|if
condition|(
name|cp1
operator|>
name|cp2
condition|)
name|cp1
operator|=
name|cp2
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cp1
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|cp
operator|=
name|cp1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'"'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
operator|&&
operator|(
name|type
operator|!=
name|T_ISDN
operator|||
name|i
operator|==
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'?'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s. (\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\t\t%lu"
argument_list|,
name|ignore
argument_list|,
operator|(
name|u_long
operator|)
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %lu"
argument_list|,
operator|(
name|u_long
operator|)
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %lu"
argument_list|,
operator|(
name|u_long
operator|)
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %lu"
argument_list|,
operator|(
name|u_long
operator|)
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %lu )\n"
argument_list|,
operator|(
name|u_long
operator|)
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
name|GETSHORT
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|u_long
operator|)
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
name|GETSHORT
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|u_long
operator|)
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
name|cp1
operator|=
name|cp
operator|+
name|n
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cp1
condition|)
block|{
if|if
condition|(
name|i
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>
literal|0
operator|&&
name|cp
operator|<
name|cp1
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
literal|'"'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\"\n"
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NSAP
case|:
name|isoa
operator|.
name|isoa_len
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|isoa
operator|.
name|isoa_len
operator|>
sizeof|sizeof
argument_list|(
name|isoa
operator|.
name|isoa_genaddr
argument_list|)
condition|)
name|isoa
operator|.
name|isoa_len
operator|=
sizeof|sizeof
argument_list|(
name|isoa
operator|.
name|isoa_genaddr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cp
argument_list|,
name|isoa
operator|.
name|isoa_genaddr
argument_list|,
name|isoa
operator|.
name|isoa_len
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\n"
argument_list|,
name|iso_ntoa
argument_list|(
operator|&
name|isoa
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UINFO
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\"%s\"\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|LOC_RR
case|case
name|T_LOC
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\n"
argument_list|,
name|loc_ntoa
argument_list|(
name|cp
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* LOC_RR */
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
if|if
condition|(
name|n
operator|==
name|INT32SZ
condition|)
block|{
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_WKS
case|:
name|GETLONG
argument_list|(
name|addr
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|htonl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addr
argument_list|)
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
name|proto
operator|=
name|protocolname
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s "
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|<
operator|(
name|u_char
operator|*
operator|)
name|cdata
operator|+
name|n
condition|)
block|{
name|j
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
name|j
operator|&
literal|0200
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s"
argument_list|,
name|servicename
argument_list|(
name|i
argument_list|,
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|&
literal|07
condition|)
do|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"???\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|dbfp
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SHORT_FNAMES
end_ifdef

begin_comment
comment|/* ** This routine handles creating temporary files with mkstemp ** in the presence of a 14 char filename system.  Pathconf() ** does not work over NFS. */
end_comment

begin_macro
name|filenamecpy
argument_list|(
argument|ddtfile
argument_list|,
argument|optarg
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|ddtfile
decl_stmt|,
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|namelen
decl_stmt|,
name|extra
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
comment|/* determine the length of filename allowed */
if|if
condition|(
operator|(
name|dirname
operator|=
name|strrchr
argument_list|(
name|optarg
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|filename
operator|=
name|optarg
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dirname
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|filename
operator|=
name|dirname
expr_stmt|;
block|}
name|namelen
operator|=
name|pathconf
argument_list|(
name|dirname
operator|==
name|NULL
condition|?
literal|"."
else|:
name|optarg
argument_list|,
name|_PC_NAME_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|<=
literal|0
condition|)
name|namelen
operator|=
literal|255
expr_stmt|;
comment|/* length could not be determined */
if|if
condition|(
name|dirname
operator|!=
name|NULL
condition|)
operator|*
operator|--
name|dirname
operator|=
literal|'/'
expr_stmt|;
comment|/* copy a shorter name if it will be longer than allowed */
name|extra
operator|=
operator|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
literal|".XXXXXX"
argument_list|)
operator|)
operator|-
name|namelen
expr_stmt|;
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|-
name|extra
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ddtfile
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ddtfile
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ddtfile
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHORT_FNAMES */
end_comment

end_unit

