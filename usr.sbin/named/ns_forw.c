begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_forw.c	4.32 (Berkeley) 3/3/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1986  * -  * Copyright (c) 1986  *    The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_comment
comment|/*  * Forward the query to get the answer since its not in the database.  * Returns FW_OK if a request struct is allocated and the query sent.  * Returns FW_DUP if this is a duplicate of a pending request.  * Returns FW_NOSERVER if there were no addresses for the nameservers.  * Returns FW_SERVFAIL on malloc error or if asked to do something  * dangerous, such as fwd to ourselves or fwd to the host that asked us.  *  * (no action is taken on errors and qpp is not filled in.)  */
end_comment

begin_function
name|int
name|ns_forw
parameter_list|(
name|nsp
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|,
name|fp
parameter_list|,
name|qsp
parameter_list|,
name|dfd
parameter_list|,
name|qpp
parameter_list|,
name|dname
parameter_list|,
name|np
parameter_list|)
name|struct
name|databuf
modifier|*
name|nsp
index|[]
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|fp
decl_stmt|;
name|struct
name|qstream
modifier|*
name|qsp
decl_stmt|;
name|int
name|dfd
decl_stmt|;
name|struct
name|qinfo
modifier|*
modifier|*
name|qpp
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|nsa
decl_stmt|;
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_int16_t
name|id
decl_stmt|;
name|int
name|n
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"ns_forw()\n"
operator|)
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
name|id
operator|=
name|hp
operator|->
name|id
expr_stmt|;
comment|/* Look at them all */
for|for
control|(
name|qp
operator|=
name|nsqhead
init|;
name|qp
operator|!=
name|QINFO_NULL
condition|;
name|qp
operator|=
name|qp
operator|->
name|q_link
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_id
operator|==
name|id
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qp
operator|->
name|q_from
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|qp
operator|->
name|q_from
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|qp
operator|->
name|q_cmsglen
operator|==
literal|0
operator|&&
name|qp
operator|->
name|q_msglen
operator|==
name|msglen
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|msg
operator|+
literal|2
argument_list|,
name|msglen
operator|-
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|qp
operator|->
name|q_cmsglen
operator|==
name|msglen
operator|&&
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_cmsg
operator|+
literal|2
argument_list|,
name|msg
operator|+
literal|2
argument_list|,
name|msglen
operator|-
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"forw: dropped DUP id=%d\n"
operator|,
name|ntohs
argument_list|(
name|id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|fp
operator|->
name|sin_addr
argument_list|,
name|nssRcvdDupQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|FW_DUP
operator|)
return|;
block|}
block|}
name|qp
operator|=
name|qnew
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|LAME_DELEGATION
name|getname
argument_list|(
name|np
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|,
sizeof|sizeof
name|qp
operator|->
name|q_domain
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qp
operator|->
name|q_from
operator|=
operator|*
name|fp
expr_stmt|;
comment|/* nslookup wants to know this */
if|if
condition|(
operator|(
name|n
operator|=
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|,
name|dname
argument_list|,
literal|"ns_forw"
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"forw: nslookup reports danger\n"
operator|)
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
name|FW_SERVFAIL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
operator|!
operator|(
name|forward_only
operator|&&
name|fwdtab
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"forw: no nameservers found\n"
operator|)
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
name|FW_NOSERVER
operator|)
return|;
block|}
name|qp
operator|->
name|q_stream
operator|=
name|qsp
expr_stmt|;
name|qp
operator|->
name|q_curaddr
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_fwd
operator|=
name|fwdtab
expr_stmt|;
name|qp
operator|->
name|q_dfd
operator|=
name|dfd
expr_stmt|;
name|qp
operator|->
name|q_id
operator|=
name|id
expr_stmt|;
name|qp
operator|->
name|q_expire
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|RETRY_TIMEOUT
operator|*
literal|2
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
name|nsid_next
argument_list|()
argument_list|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|msglen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"forw: malloc: %m"
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
name|FW_SERVFAIL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|msg
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
operator|=
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|q_fwd
condition|)
block|{
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SLAVE_FORWARD
if|if
condition|(
name|forward_only
condition|)
name|schedretry
argument_list|(
name|qp
argument_list|,
operator|(
name|time_t
operator|)
name|slave_retry
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* SLAVE_FORWARD */
name|schedretry
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|q_fwd
condition|?
operator|(
literal|2
operator|*
name|RETRYBASE
operator|)
else|:
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
name|nsa
operator|=
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"forw: forw -> [%s].%d ds=%d nsid=%d id=%d %dms retry %dsec\n"
operator|,
name|inet_ntoa
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
operator|,
name|ntohs
argument_list|(
name|nsa
operator|->
name|sin_port
argument_list|)
operator|,
name|ds
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|,
operator|(
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|!=
name|NULL
operator|)
condition|?
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|->
name|d_nstime
else|:
operator|-
literal|1
operator|,
call|(
name|int
call|)
argument_list|(
name|qp
operator|->
name|q_time
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sendto
argument_list|(
name|ds
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|nsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nsa
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|sendtoStr
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ns_forw: sendto([%s].%d): %m"
argument_list|,
name|inet_ntoa
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|nsa
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
block|}
name|nameserIncr
argument_list|(
name|fp
operator|->
name|sin_addr
argument_list|,
name|nssRcvdFwdQ
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSentFwdQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|qpp
condition|)
operator|*
name|qpp
operator|=
name|qp
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* struct qdatagram *  * aIsUs(addr)  *	scan the datagramq (our list of interface addresses) for "addr"  * returns:  *	pointer to qdatagram entry or NULL if no match is found  * notes:  *	INADDR_ANY ([0.0.0.0]) is on the datagramq, so it's considered "us"  * author:  *	Paul Vixie (DECWRL) April 1991  */
end_comment

begin_function
name|struct
name|qdatagram
modifier|*
name|aIsUs
parameter_list|(
name|addr
parameter_list|)
name|struct
name|in_addr
name|addr
decl_stmt|;
block|{
name|struct
name|qdatagram
modifier|*
name|dqp
decl_stmt|;
for|for
control|(
name|dqp
operator|=
name|datagramq
init|;
name|dqp
operator|!=
name|QDATAGRAM_NULL
condition|;
name|dqp
operator|=
name|dqp
operator|->
name|dq_next
control|)
block|{
if|if
condition|(
name|addr
operator|.
name|s_addr
operator|==
name|dqp
operator|->
name|dq_addr
operator|.
name|s_addr
condition|)
block|{
return|return
name|dqp
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* haveComplained(tag1, tag2)  *	check to see if we have complained about (tag1,tag2) recently  *	(note that these are declared as pointers but are never deref'd)  * returns:  *	boolean: have we complained recently?  * side-effects:  *	outdated complaint records removed from our static list  * author:  *	Paul Vixie (DECWRL) April 1991  */
end_comment

begin_function
name|int
name|haveComplained
parameter_list|(
name|tag1
parameter_list|,
name|tag2
parameter_list|)
specifier|const
name|char
modifier|*
name|tag1
decl_stmt|,
decl|*
name|tag2
decl_stmt|;
end_function

begin_block
block|{
struct|struct
name|complaint
block|{
specifier|const
name|char
modifier|*
name|tag1
decl_stmt|,
modifier|*
name|tag2
decl_stmt|;
name|time_t
name|expire
decl_stmt|;
name|struct
name|complaint
modifier|*
name|next
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|complaint
modifier|*
name|List
init|=
name|NULL
decl_stmt|;
name|struct
name|complaint
modifier|*
name|cur
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|List
operator|,
name|prev
operator|=
name|NULL
init|;
name|cur
condition|;
name|prev
operator|=
name|cur
operator|,
name|cur
operator|=
name|next
control|)
block|{
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tt
operator|.
name|tv_sec
operator|>
name|cur
operator|->
name|expire
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
else|else
name|List
operator|=
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|=
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tag1
operator|==
name|cur
operator|->
name|tag1
operator|)
operator|&&
operator|(
name|tag2
operator|==
name|cur
operator|->
name|tag2
operator|)
condition|)
block|{
name|r
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|cur
operator|=
operator|(
expr|struct
name|complaint
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|complaint
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|->
name|tag1
operator|=
name|tag1
expr_stmt|;
name|cur
operator|->
name|tag2
operator|=
name|tag2
expr_stmt|;
name|cur
operator|->
name|expire
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|INIT_REFRESH
expr_stmt|;
comment|/* "10 minutes" */
name|cur
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|cur
expr_stmt|;
else|else
name|List
operator|=
name|cur
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_block

begin_comment
comment|/* void  * nslookupComplain(sysloginfo, queryname, complaint, dname, a_rr)  *	Issue a complaint about a dangerous situation found by nslookup().  * params:  *	sysloginfo is a string identifying the complainant.  *	queryname is the domain name associated with the problem.  *	complaint is a string describing what is wrong.  *	dname and a_rr are the problematic other name server.  */
end_comment

begin_function
name|void
name|nslookupComplain
parameter_list|(
name|sysloginfo
parameter_list|,
name|queryname
parameter_list|,
name|complaint
parameter_list|,
name|dname
parameter_list|,
name|a_rr
parameter_list|)
specifier|const
name|char
modifier|*
name|sysloginfo
decl_stmt|,
decl|*
name|queryname
decl_stmt|,
modifier|*
name|complaint
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
end_function

begin_decl_stmt
specifier|const
name|struct
name|databuf
modifier|*
name|a_rr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"NS '%s' %s\n"
operator|,
name|dname
operator|,
name|complaint
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysloginfo
operator|&&
name|queryname
operator|&&
operator|!
name|haveComplained
argument_list|(
name|queryname
argument_list|,
name|complaint
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|999
index|]
decl_stmt|;
comment|/* syslog only takes 5 params */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: query(%s) %s (%s:%s)"
argument_list|,
name|sysloginfo
argument_list|,
name|queryname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|inet_ntoa
argument_list|(
name|data_inaddr
argument_list|(
name|a_rr
operator|->
name|d_data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * nslookup(nsp, qp, syslogdname, sysloginfo)  *	Lookup the address for each nameserver in `nsp' and add it to  * 	the list saved in the qinfo structure pointed to by `qp'.  *	Omits information about nameservers that we shouldn't ask.  *	Detects the following dangerous operations:  *		One of the A records for one of the nameservers in nsp  *		refers to the address of one of our own interfaces;  *		One of the A records refers to the nameserver port on  *		the host that asked us this question.  * returns: the number of addresses added, or -1 if a dangerous operation  *	is detected.  * side effects:  *	if a dangerous situation is detected and (syslogdname&& sysloginfo),  *		calls syslog.  */
end_comment

begin_function
name|int
name|nslookup
parameter_list|(
name|nsp
parameter_list|,
name|qp
parameter_list|,
name|syslogdname
parameter_list|,
name|sysloginfo
parameter_list|)
name|struct
name|databuf
modifier|*
name|nsp
index|[]
decl_stmt|;
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
specifier|const
name|char
modifier|*
name|syslogdname
decl_stmt|;
specifier|const
name|char
modifier|*
name|sysloginfo
decl_stmt|;
block|{
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|nsdp
decl_stmt|;
specifier|register
name|struct
name|qserv
modifier|*
name|qs
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|tmphtp
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|oldn
decl_stmt|,
name|naddr
decl_stmt|,
name|class
decl_stmt|,
name|found_arr
decl_stmt|;
name|time_t
name|curtime
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"nslookup(nsp=0x%lx, qp=0x%lx, \"%s\")\n"
operator|,
operator|(
name|u_long
operator|)
name|nsp
operator|,
operator|(
name|u_long
operator|)
name|qp
operator|,
name|syslogdname
operator|)
argument_list|)
expr_stmt|;
name|naddr
operator|=
name|n
operator|=
name|qp
operator|->
name|q_naddr
expr_stmt|;
name|curtime
operator|=
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
while|while
condition|(
operator|(
name|nsdp
operator|=
operator|*
name|nsp
operator|++
operator|)
operator|!=
name|NULL
condition|)
block|{
name|class
operator|=
name|nsdp
operator|->
name|d_class
expr_stmt|;
name|dname
operator|=
operator|(
name|char
operator|*
operator|)
name|nsdp
operator|->
name|d_data
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"nslookup: NS \"%s\" c=%d t=%d (%#lx)\n"
operator|,
name|dname
operator|,
name|class
operator|,
name|nsdp
operator|->
name|d_type
operator|,
operator|(
name|u_long
operator|)
name|nsdp
operator|->
name|d_flags
operator|)
argument_list|)
expr_stmt|;
comment|/* don't put in servers we have tried */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|q_nusedns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_usedns
index|[
name|i
index|]
operator|==
name|nsdp
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
operator|(
name|ddt
operator|,
literal|"skipping used NS w/name %s\n"
operator|,
name|nsdp
operator|->
name|d_data
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|skipserver
goto|;
block|}
block|}
name|tmphtp
operator|=
operator|(
operator|(
name|nsdp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|?
name|fcachetab
else|:
name|hashtab
operator|)
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|tmphtp
argument_list|,
operator|&
name|fname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"%s: not found %s %lx\n"
operator|,
name|dname
operator|,
name|fname
operator|,
operator|(
name|u_long
operator|)
name|np
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|found_arr
operator|=
literal|0
expr_stmt|;
name|oldn
operator|=
name|n
expr_stmt|;
comment|/* look for name server addresses */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
name|struct
name|in_addr
name|nsa
decl_stmt|;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
operator|&&
name|dp
operator|->
name|d_class
operator|==
name|class
condition|)
goto|goto
name|skipserver
goto|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|dp
operator|->
name|d_class
operator|!=
name|class
condition|)
continue|continue;
if|if
condition|(
name|data_inaddr
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Bogus (0.0.0.0) A RR for %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Don't use records that may become invalid to 			 * reference later when we do the rtt computation. 			 * Never delete our safety-belt information! 			 */
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
literal|0
operator|)
operator|&&
ifdef|#
directive|ifdef
name|DATUMREFCNT
operator|(
name|dp
operator|->
name|d_ttl
operator|<
name|curtime
operator|)
operator|&&
else|#
directive|else
operator|(
name|dp
operator|->
name|d_ttl
operator|<
operator|(
name|curtime
operator|+
literal|900
operator|)
operator|)
operator|&&
endif|#
directive|endif
operator|!
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"nslookup: stale entry '%s'\n"
operator|,
name|np
operator|->
name|n_dname
operator|)
argument_list|)
expr_stmt|;
comment|/* Cache invalidate the NS RR's */
ifndef|#
directive|ifndef
name|DATUMREFCNT
if|if
condition|(
name|dp
operator|->
name|d_ttl
operator|<
name|curtime
condition|)
endif|#
directive|endif
block|{
name|delete_all
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|T_A
argument_list|)
expr_stmt|;
name|n
operator|=
name|oldn
expr_stmt|;
name|found_arr
operator|=
literal|0
expr_stmt|;
goto|goto
name|need_sysquery
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|VALIDATE
comment|/* anant@isi.edu validation procedure, maintains a 			 * table of server names-addresses used recently 			 */
name|store_name_addr
argument_list|(
name|dname
argument_list|,
name|data_inaddr
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
argument_list|,
name|syslogdname
argument_list|,
name|sysloginfo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*VALIDATE*/
name|found_arr
operator|++
expr_stmt|;
name|nsa
operator|=
name|data_inaddr
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
comment|/* don't put in duplicates */
name|qs
operator|=
name|qp
operator|->
name|q_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
operator|,
name|qs
operator|++
control|)
if|if
condition|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|nsa
operator|.
name|s_addr
condition|)
goto|goto
name|skipaddr
goto|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_port
operator|=
name|ns_port
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
operator|=
name|nsa
expr_stmt|;
name|qs
operator|->
name|ns
operator|=
name|nsdp
expr_stmt|;
name|qs
operator|->
name|nsdata
operator|=
name|dp
expr_stmt|;
name|qs
operator|->
name|nretry
operator|=
literal|0
expr_stmt|;
comment|/* 			 * if we are being asked to fwd a query whose 			 * nameserver list includes our own name/address(es), 			 * then we have detected a lame delegation and rather 			 * than melt down the network and hose down the other 			 * servers (who will hose us in return), we'll return 			 * -1 here which will cause SERVFAIL to be sent to 			 * the client's resolver which will hopefully then 			 * shut up. 			 * 			 * (originally done in nsContainsUs by vix@dec mar92; 			 * moved into nslookup by apb@und jan1993) 			 */
if|if
condition|(
name|aIsUs
argument_list|(
name|nsa
argument_list|)
condition|)
block|{
specifier|static
name|char
modifier|*
name|complaint
init|=
literal|"contains our address"
decl_stmt|;
name|nslookupComplain
argument_list|(
name|sysloginfo
argument_list|,
name|syslogdname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 			 * If we want to forward to a host that asked us 			 * this question then either we or they are sick 			 * (unless they asked from some port other than 			 * their nameserver port).  (apb@und jan1993) 			 */
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|qp
operator|->
name|q_from
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|qs
operator|->
name|ns_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|qp
operator|->
name|q_from
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
modifier|*
name|complaint
init|=
literal|"forwarding loop"
decl_stmt|;
name|nslookupComplain
argument_list|(
name|sysloginfo
argument_list|,
name|syslogdname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|BOGUSNS
comment|/* 			 * Don't forward queries to bogus servers.  Note 			 * that this is unlike the previous tests, which 			 * are fatal to the query.  Here we just skip the 			 * server, which is only fatal if it's the last 			 * server.  Note also that we antialias here -- all 			 * A RR's of a server are considered the same server, 			 * and if any of them is bogus we skip the whole 			 * server.  Those of you using multiple A RR's to 			 * load-balance your servers will (rightfully) lose 			 * here.  But (unfortunately) only if they are bogus. 			 */
if|if
condition|(
name|addr_on_netlist
argument_list|(
name|nsa
argument_list|,
name|boglist
argument_list|)
condition|)
goto|goto
name|skipserver
goto|;
endif|#
directive|endif
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|NSMAX
condition|)
goto|goto
name|out
goto|;
name|skipaddr
label|:
name|NULL
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|8
argument_list|,
operator|(
name|ddt
operator|,
literal|"nslookup: %d ns addrs\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|need_sysquery
label|:
if|if
condition|(
name|found_arr
operator|==
literal|0
operator|&&
operator|!
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
condition|)
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
name|skipserver
label|:
name|NULL
expr_stmt|;
block|}
name|out
label|:
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"nslookup: %d ns addrs total\n"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_naddr
operator|=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
comment|/* must be run before the sort */
for|for
control|(
name|i
operator|=
name|naddr
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
operator|->
name|d_rcnt
operator|++
expr_stmt|;
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_rcnt
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|n
operator|>
literal|1
condition|)
block|{
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_addr
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qserv
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
operator|)
name|qcomp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|-
name|naddr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * qcomp - compare two NS addresses, and return a negative, zero, or  *	   positive value depending on whether the first NS address is  *	   "better than", "equally good as", or "inferior to" the second  *	   NS address.  *  * How "goodness" is defined (for the purposes of this routine):  *  - If the estimated round trip times differ by an amount deemed significant  *    then the one with the smaller estimate is preferred; else  *  - If we can determine which one is topologically closer then the  *    closer one is preferred; else  *  - The one with the smaller estimated round trip time is preferred  *    (zero is returned if the two estimates are identical).  *  * How "topological closeness" is defined (for the purposes of this routine):  *    Ideally, named could consult some magic map of the Internet and  *    determine the length of the path to an arbitrary destination.  Sadly,  *    no such magic map exists.  However, named does have a little bit of  *    topological information in the form of the sortlist (which includes  *    the directly connected subnet(s), the directly connected net(s), and  *    any additional nets that the administrator has added using the "sortlist"  *    directive in the bootfile.  Thus, if only one of the addresses matches  *    something in the sortlist then it is considered to be topologically  *    closer.  If both match, but match different entries in the sortlist,  *    then the one that matches the entry closer to the beginning of the  *    sorlist is considered to be topologically closer.  In all other cases,  *    topological closeness is ignored because it's either indeterminate or  *    equal.  *  * How times are compared:  *    Both times are rounded to the closest multiple of the NOISE constant  *    defined below and then compared.  If the rounded values are equal  *    then the difference in the times is deemed insignificant.  Rounding  *    is used instead of merely taking the absolute value of the difference  *    because doing the latter would make the ordering defined by this  *    routine be incomplete in the mathematical sense (e.g. A> B and  *    B> C would not imply A> C).  The mathematics are important in  *    practice to avoid core dumps in qsort().  *  * XXX: this doesn't solve the European root nameserver problem very well.  * XXX: we should detect and mark as inferior nameservers that give bogus  *      answers  *  * (this was originally vixie's stuff but almquist fixed fatal bugs in it  * and wrote the above documentation)  */
end_comment

begin_comment
comment|/*  * RTT delta deemed to be significant, in milliseconds.  With the current  * definition of RTTROUND it must be a power of 2.  */
end_comment

begin_define
define|#
directive|define
name|NOISE
value|128
end_define

begin_comment
comment|/* milliseconds; 0.128 seconds */
end_comment

begin_define
define|#
directive|define
name|sign
parameter_list|(
name|x
parameter_list|)
value|(((x)< 0) ? -1 : ((x)> 0) ? 1 : 0)
end_define

begin_define
define|#
directive|define
name|RTTROUND
parameter_list|(
name|rtt
parameter_list|)
value|(((rtt) + (NOISE>> 1))& ~(NOISE - 1))
end_define

begin_function
name|int
name|qcomp
parameter_list|(
name|qs1
parameter_list|,
name|qs2
parameter_list|)
name|struct
name|qserv
modifier|*
name|qs1
decl_stmt|,
decl|*
name|qs2
decl_stmt|;
end_function

begin_block
block|{
name|int
name|pos1
decl_stmt|,
name|pos2
decl_stmt|,
name|pdiff
decl_stmt|;
name|u_long
name|rtt1
decl_stmt|,
name|rtt2
decl_stmt|;
name|long
name|tdiff
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|qs1
operator|->
name|nsdata
operator|)
operator|||
operator|(
operator|!
name|qs2
operator|->
name|nsdata
operator|)
condition|)
return|return
literal|0
return|;
name|rtt1
operator|=
name|qs1
operator|->
name|nsdata
operator|->
name|d_nstime
expr_stmt|;
name|rtt2
operator|=
name|qs2
operator|->
name|nsdata
operator|->
name|d_nstime
expr_stmt|;
name|dprintf
argument_list|(
literal|10
argument_list|,
operator|(
name|ddt
operator|,
literal|"qcomp(%s, %s) %lu (%lu) - %lu (%lu) = %lu"
operator|,
name|inet_ntoa
argument_list|(
name|qs1
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
operator|,
name|inet_ntoa
argument_list|(
name|qs2
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
operator|,
name|rtt1
operator|,
name|RTTROUND
argument_list|(
name|rtt1
argument_list|)
operator|,
name|rtt2
operator|,
name|RTTROUND
argument_list|(
name|rtt2
argument_list|)
operator|,
name|rtt1
operator|-
name|rtt2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RTTROUND
argument_list|(
name|rtt1
argument_list|)
operator|==
name|RTTROUND
argument_list|(
name|rtt2
argument_list|)
condition|)
block|{
name|pos1
operator|=
name|position_on_netlist
argument_list|(
name|qs1
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|,
name|nettab
argument_list|)
expr_stmt|;
name|pos2
operator|=
name|position_on_netlist
argument_list|(
name|qs2
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|,
name|nettab
argument_list|)
expr_stmt|;
name|pdiff
operator|=
name|pos1
operator|-
name|pos2
expr_stmt|;
name|dprintf
argument_list|(
literal|10
argument_list|,
operator|(
name|ddt
operator|,
literal|", pos1=%d, pos2=%d\n"
operator|,
name|pos1
operator|,
name|pos2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdiff
condition|)
return|return
operator|(
name|pdiff
operator|)
return|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|10
argument_list|,
operator|(
name|ddt
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|tdiff
operator|=
name|rtt1
operator|-
name|rtt2
expr_stmt|;
return|return
operator|(
name|sign
argument_list|(
name|tdiff
argument_list|)
operator|)
return|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|sign
end_undef

begin_undef
undef|#
directive|undef
name|RTTROUND
end_undef

begin_comment
comment|/*  * Arrange that forwarded query (qp) is retried after t seconds.  * Query list will be sorted after z_time is updated.  */
end_comment

begin_function
name|void
name|schedretry
parameter_list|(
name|qp
parameter_list|,
name|t
parameter_list|)
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|time_t
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp1
decl_stmt|,
modifier|*
name|qp2
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"schedretry(0x%lx, %ld sec)\n"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|,
operator|(
name|long
operator|)
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_time
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"WARNING: schedretry(%#lx, %ld) q_time already %ld\n"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|,
operator|(
name|long
operator|)
name|t
argument_list|,
operator|(
name|long
operator|)
name|qp
operator|->
name|q_time
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|t
operator|+=
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|qp
operator|->
name|q_time
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|qp1
operator|=
name|retryqp
operator|)
operator|==
name|NULL
condition|)
block|{
name|retryqp
operator|=
name|qp
expr_stmt|;
name|qp
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|t
operator|<
name|qp1
operator|->
name|q_time
condition|)
block|{
name|qp
operator|->
name|q_next
operator|=
name|qp1
expr_stmt|;
name|retryqp
operator|=
name|qp
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|qp2
operator|=
name|qp1
operator|->
name|q_next
operator|)
operator|!=
name|NULL
operator|&&
name|qp2
operator|->
name|q_time
operator|<
name|t
condition|)
name|qp1
operator|=
name|qp2
expr_stmt|;
name|qp1
operator|->
name|q_next
operator|=
name|qp
expr_stmt|;
name|qp
operator|->
name|q_next
operator|=
name|qp2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unsched is called to remove a forwarded query entry.  */
end_comment

begin_function
name|void
name|unsched
parameter_list|(
name|qp
parameter_list|)
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|np
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"unsched(%#lx, %d)\n"
operator|,
operator|(
name|u_long
operator|)
name|qp
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retryqp
operator|==
name|qp
condition|)
block|{
name|retryqp
operator|=
name|qp
operator|->
name|q_next
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|np
operator|=
name|retryqp
init|;
name|np
operator|->
name|q_next
operator|!=
name|QINFO_NULL
condition|;
name|np
operator|=
name|np
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|np
operator|->
name|q_next
operator|!=
name|qp
condition|)
continue|continue;
name|np
operator|->
name|q_next
operator|=
name|qp
operator|->
name|q_next
expr_stmt|;
comment|/* dequeue */
break|break;
block|}
block|}
name|qp
operator|->
name|q_next
operator|=
name|QINFO_NULL
expr_stmt|;
comment|/* sanity check */
name|qp
operator|->
name|q_time
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retry is called to retransmit query 'qp'.  */
end_comment

begin_function
name|void
name|retry
parameter_list|(
name|qp
parameter_list|)
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|nsa
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"retry(x%lx) id=%d\n"
operator|,
operator|(
name|u_long
operator|)
name|qp
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_msg
operator|==
name|NULL
condition|)
block|{
comment|/* XXX - why? */
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qp
operator|->
name|q_expire
operator|&&
operator|(
name|qp
operator|->
name|q_expire
operator|<
name|tt
operator|.
name|tv_sec
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"retry(x%lx): expired @ %lu (%d secs before now (%lu))\n"
operator|,
operator|(
name|u_long
operator|)
name|qp
operator|,
operator|(
name|u_long
operator|)
name|qp
operator|->
name|q_expire
operator|,
call|(
name|int
call|)
argument_list|(
name|tt
operator|.
name|tv_sec
operator|-
name|qp
operator|->
name|q_expire
argument_list|)
operator|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_stream
condition|)
comment|/* return failure code on stream */
goto|goto
name|fail
goto|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* try next address */
name|n
operator|=
name|qp
operator|->
name|q_curaddr
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_fwd
condition|)
block|{
name|qp
operator|->
name|q_fwd
operator|=
name|qp
operator|->
name|q_fwd
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_fwd
condition|)
goto|goto
name|found
goto|;
comment|/* out of forwarders, try direct queries */
block|}
else|else
operator|++
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nretry
expr_stmt|;
if|if
condition|(
operator|!
name|forward_only
condition|)
block|{
do|do
block|{
if|if
condition|(
operator|++
name|n
operator|>=
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|)
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nretry
operator|<
name|MAXRETRY
condition|)
goto|goto
name|found
goto|;
block|}
do|while
condition|(
name|n
operator|!=
name|qp
operator|->
name|q_curaddr
condition|)
do|;
block|}
name|fail
label|:
comment|/* 	 * Give up. Can't reach destination. 	 */
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|qp
operator|->
name|q_cmsg
condition|?
name|qp
operator|->
name|q_cmsg
else|:
name|qp
operator|->
name|q_msg
operator|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
condition|)
block|{
comment|/* Can't give up priming */
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
operator|(
name|time_t
operator|)
literal|60
operator|*
literal|60
argument_list|)
expr_stmt|;
comment|/* 1 hour */
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
comment|/* Lets be safe, reset the query */
name|hp
operator|->
name|qr
operator|=
name|hp
operator|->
name|aa
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_fwd
operator|=
name|fwdtab
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
control|)
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nretry
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"give up\n"
operator|)
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_cmsg
condition|?
name|qp
operator|->
name|q_cmsglen
else|:
name|qp
operator|->
name|q_msglen
operator|)
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NoRecurse
operator|==
literal|0
operator|)
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|n
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|send_msg
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|hp
argument_list|,
name|n
argument_list|,
name|qp
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"gave up retry(x%lx) nsid=%d id=%d\n"
operator|,
operator|(
name|u_long
operator|)
name|qp
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentFail
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
name|found
label|:
if|if
condition|(
name|qp
operator|->
name|q_fwd
operator|==
literal|0
operator|&&
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nretry
operator|==
literal|0
condition|)
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
name|qp
operator|->
name|q_curaddr
operator|=
name|n
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
operator|(
name|qp
operator|->
name|q_fwd
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|nsa
operator|=
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"%s(addr=%d n=%d) -> [%s].%d ds=%d nsid=%d id=%d %dms\n"
operator|,
operator|(
name|qp
operator|->
name|q_fwd
condition|?
literal|"reforw"
else|:
literal|"resend"
operator|)
operator|,
name|n
operator|,
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nretry
operator|,
name|inet_ntoa
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
operator|,
name|ntohs
argument_list|(
name|nsa
operator|->
name|sin_port
argument_list|)
operator|,
name|ds
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
operator|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
operator|,
operator|(
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nsdata
operator|!=
literal|0
operator|)
condition|?
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nsdata
operator|->
name|d_nstime
else|:
operator|(
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|fp_nquery
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NOSTRICT */
if|if
condition|(
name|sendto
argument_list|(
name|ds
argument_list|,
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|nsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"error resending msg errno=%d\n"
operator|,
name|errno
operator|)
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
comment|/* leave set to 1 for dup detection */
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSentDupQ
argument_list|)
expr_stmt|;
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SLAVE_FORWARD
if|if
condition|(
name|forward_only
condition|)
name|schedretry
argument_list|(
name|qp
argument_list|,
operator|(
name|time_t
operator|)
name|slave_retry
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* SLAVE_FORWARD */
name|schedretry
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|q_fwd
condition|?
operator|(
literal|2
operator|*
name|RETRYBASE
operator|)
else|:
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute retry time for the next server for a query.  * Use a minimum time of RETRYBASE (4 sec.) or twice the estimated  * service time; * back off exponentially on retries, but place a 45-sec.  * ceiling on retry times for now.  (This is because we don't hold a reference  * on servers or their addresses, and we have to finish before they time out.)  */
end_comment

begin_function
name|time_t
name|retrytime
parameter_list|(
name|qp
parameter_list|)
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
block|{
name|time_t
name|t
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
name|struct
name|qserv
modifier|*
name|ns
init|=
operator|&
name|qp
operator|->
name|q_addr
index|[
name|qp
operator|->
name|q_curaddr
index|]
decl_stmt|;
if|if
condition|(
name|ns
operator|->
name|nsdata
operator|!=
name|NULL
condition|)
name|t
operator|=
operator|(
name|time_t
operator|)
name|MAX
argument_list|(
name|RETRYBASE
argument_list|,
literal|2
operator|*
name|ns
operator|->
name|nsdata
operator|->
name|d_nstime
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
operator|(
name|time_t
operator|)
name|RETRYBASE
expr_stmt|;
name|u
operator|=
name|t
operator|<<
name|ns
operator|->
name|nretry
expr_stmt|;
name|v
operator|=
name|MIN
argument_list|(
name|u
argument_list|,
name|RETRY_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* max. retry timeout for now */
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"retrytime: nstime%ldms t%ld nretry%ld u%ld : v%ld\n"
operator|,
name|ns
operator|->
name|nsdata
condition|?
call|(
name|long
call|)
argument_list|(
name|ns
operator|->
name|nsdata
operator|->
name|d_nstime
operator|/
literal|1000
argument_list|)
else|:
operator|(
name|long
operator|)
operator|-
literal|1
operator|,
operator|(
name|long
operator|)
name|t
operator|,
operator|(
name|long
operator|)
name|ns
operator|->
name|nretry
operator|,
operator|(
name|long
operator|)
name|u
operator|,
operator|(
name|long
operator|)
name|v
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
name|void
name|qflush
parameter_list|()
block|{
while|while
condition|(
name|nsqhead
condition|)
name|qremove
argument_list|(
name|nsqhead
argument_list|)
expr_stmt|;
name|nsqhead
operator|=
name|QINFO_NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|qremove
parameter_list|(
name|qp
parameter_list|)
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"qremove(x%lx)\n"
operator|,
operator|(
name|u_long
operator|)
name|qp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
condition|)
name|qserial_answer
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|qfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_decl_stmt
name|struct
name|qinfo
modifier|*
name|qfindid
argument_list|(
name|u_int16_t
name|id
argument_list|)
else|#
directive|else
decl|struct
name|qinfo
modifier|*
name|qfindid
argument_list|(
name|id
argument_list|)
decl|register
name|u_int16_t
name|id
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"qfindid(%d)\n"
operator|,
name|ntohs
argument_list|(
name|id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|qp
operator|=
name|nsqhead
init|;
name|qp
operator|!=
name|QINFO_NULL
condition|;
name|qp
operator|=
name|qp
operator|->
name|q_link
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_nsid
operator|==
name|id
condition|)
return|return
operator|(
name|qp
operator|)
return|;
block|}
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"qp not found\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_function
name|struct
name|qinfo
modifier|*
ifdef|#
directive|ifdef
name|DMALLOC
name|qnew_tagged
parameter_list|(
name|file
parameter_list|,
name|line
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
else|#
directive|else
function|qnew
parameter_list|()
endif|#
directive|endif
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|qp
operator|=
operator|(
expr|struct
name|qinfo
operator|*
operator|)
ifdef|#
directive|ifdef
name|DMALLOC
name|dcalloc
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qinfo
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qinfo
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"qnew: calloc error\n"
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"forw: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|5
argument_list|,
operator|(
name|ddt
operator|,
literal|"qnew(x%lx)\n"
operator|,
operator|(
name|u_long
operator|)
name|qp
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
name|qp
operator|->
name|q_notifyzone
operator|=
name|DB_Z_CACHE
expr_stmt|;
endif|#
directive|endif
name|qp
operator|->
name|q_link
operator|=
name|nsqhead
expr_stmt|;
name|nsqhead
operator|=
name|qp
expr_stmt|;
return|return
operator|(
name|qp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|qfree
parameter_list|(
name|qp
parameter_list|)
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
block|{
specifier|register
name|struct
name|qinfo
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"Qfree(x%lx)\n"
operator|,
operator|(
name|u_long
operator|)
name|qp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_next
condition|)
name|dprintf
argument_list|(
literal|1
argument_list|,
operator|(
name|ddt
operator|,
literal|"WARNING: qfree of linked ptr x%lx\n"
operator|,
operator|(
name|u_long
operator|)
name|qp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_msg
condition|)
name|free
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_cmsg
condition|)
name|free
argument_list|(
name|qp
operator|->
name|q_cmsg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DATUMREFCNT
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
block|{
name|dp
operator|=
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
expr_stmt|;
if|if
condition|(
name|dp
condition|)
if|if
condition|(
operator|--
operator|(
name|dp
operator|->
name|d_rcnt
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"qfree: ns %s rcnt %d\n"
operator|,
name|dp
operator|->
name|d_data
operator|,
name|dp
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"qfree: ns %s rcnt %d delayed\n"
operator|,
name|dp
operator|->
name|d_data
operator|,
name|dp
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
block|}
name|dp
operator|=
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
expr_stmt|;
if|if
condition|(
name|dp
condition|)
if|if
condition|(
operator|(
operator|--
operator|(
name|dp
operator|->
name|d_rcnt
operator|)
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"qfree: nsdata %08.8X rcnt %d\n"
operator|,
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|dp
operator|->
name|d_data
operator|)
operator|,
name|dp
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|3
argument_list|,
operator|(
name|ddt
operator|,
literal|"qfree: nsdata %08.8X rcnt %d delayed\n"
operator|,
operator|*
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|dp
operator|->
name|d_data
operator|)
operator|,
name|dp
operator|->
name|d_rcnt
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|nsqhead
operator|==
name|qp
condition|)
block|{
name|nsqhead
operator|=
name|qp
operator|->
name|q_link
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|np
operator|=
name|nsqhead
init|;
name|np
operator|->
name|q_link
operator|!=
name|QINFO_NULL
condition|;
name|np
operator|=
name|np
operator|->
name|q_link
control|)
block|{
if|if
condition|(
name|np
operator|->
name|q_link
operator|!=
name|qp
condition|)
continue|continue;
name|np
operator|->
name|q_link
operator|=
name|qp
operator|->
name|q_link
expr_stmt|;
comment|/* dequeue */
break|break;
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

