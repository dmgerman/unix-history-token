begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/clnt.h>
end_include

begin_include
include|#
directive|include
file|<rpc/pmap_clnt.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/yp.h>
end_include

begin_struct
struct|struct
name|dom_binding
block|{}
struct|;
end_struct

begin_include
include|#
directive|include
file|<rpcsvc/ypclnt.h>
end_include

begin_include
include|#
directive|include
file|"ypxfr_extern.h"
end_include

begin_include
include|#
directive|include
file|"yppush_extern.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|progname
init|=
literal|"yppush"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rpcpmstart
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yp_dir
init|=
name|_PATH_YP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|yppush_mapname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map to transfer. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|yppush_domain
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Domain in which map resides. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|yppush_master
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Master NIS server for said domain. */
end_comment

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Toggle verbose mode. */
end_comment

begin_decl_stmt
name|unsigned
name|long
name|yppush_transid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yppush_timeout
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default timeout. */
end_comment

begin_decl_stmt
name|int
name|yppush_jobs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of allowed concurrent jobs. */
end_comment

begin_decl_stmt
name|int
name|yppush_running_jobs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of currently running jobs. */
end_comment

begin_decl_stmt
name|int
name|yppush_alarm_tripped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure for holding information about a running job. */
end_comment

begin_struct
struct|struct
name|jobs
block|{
name|unsigned
name|long
name|tid
decl_stmt|;
name|int
name|sock
decl_stmt|;
name|int
name|port
decl_stmt|;
name|ypxfrstat
name|stat
decl_stmt|;
name|unsigned
name|long
name|prognum
decl_stmt|;
name|char
modifier|*
name|server
decl_stmt|;
name|char
modifier|*
name|map
decl_stmt|;
name|int
name|polled
decl_stmt|;
name|struct
name|jobs
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|jobs
modifier|*
name|yppush_joblist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of running jobs. */
end_comment

begin_comment
comment|/*  * Local error messages.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|yppusherr_string
parameter_list|(
name|err
parameter_list|)
name|int
name|err
decl_stmt|;
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|YPPUSH_TIMEDOUT
case|:
return|return
operator|(
literal|"transfer or callback timed out"
operator|)
return|;
case|case
name|YPPUSH_YPSERV
case|:
return|return
operator|(
literal|"failed to contact ypserv"
operator|)
return|;
case|case
name|YPPUSH_NOHOST
case|:
return|return
operator|(
literal|"no such host"
operator|)
return|;
case|case
name|YPPUSH_PMAP
case|:
return|return
operator|(
literal|"portmapper failure"
operator|)
return|;
default|default:
return|return
operator|(
literal|"unknown error code"
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Report state of a job.  */
end_comment

begin_function
specifier|static
name|int
name|yppush_show_status
parameter_list|(
name|status
parameter_list|,
name|tid
parameter_list|)
name|ypxfrstat
name|status
decl_stmt|;
name|unsigned
name|long
name|tid
decl_stmt|;
block|{
name|struct
name|jobs
modifier|*
name|job
decl_stmt|;
name|job
operator|=
name|yppush_joblist
expr_stmt|;
while|while
condition|(
name|job
condition|)
block|{
if|if
condition|(
name|job
operator|->
name|tid
operator|==
name|tid
condition|)
break|break;
name|job
operator|=
name|job
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|job
operator|->
name|polled
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|yp_error
argument_list|(
literal|"checking return status: transaction ID: %lu"
argument_list|,
name|job
operator|->
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|YPPUSH_SUCC
operator|||
name|verbose
condition|)
block|{
name|yp_error
argument_list|(
literal|"transfer of map %s to server %s %s"
argument_list|,
name|job
operator|->
name|map
argument_list|,
name|job
operator|->
name|server
argument_list|,
name|status
operator|==
name|YPPUSH_SUCC
condition|?
literal|"succeeded"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
name|yp_error
argument_list|(
literal|"status returned by ypxfr: %s"
argument_list|,
name|status
operator|>
name|YPPUSH_AGE
condition|?
name|yppusherr_string
argument_list|(
name|status
argument_list|)
else|:
name|ypxfrerr_string
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|job
operator|->
name|polled
operator|=
literal|1
expr_stmt|;
name|svc_unregister
argument_list|(
name|job
operator|->
name|prognum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|yppush_running_jobs
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Exit routine. */
end_comment

begin_function
specifier|static
name|void
name|yppush_exit
parameter_list|(
name|now
parameter_list|)
name|int
name|now
decl_stmt|;
block|{
name|struct
name|jobs
modifier|*
name|jptr
decl_stmt|;
name|int
name|still_pending
init|=
literal|1
decl_stmt|;
comment|/* Let all the information trickle in. */
while|while
condition|(
operator|!
name|now
operator|&&
name|still_pending
condition|)
block|{
name|jptr
operator|=
name|yppush_joblist
expr_stmt|;
name|still_pending
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|jptr
condition|)
block|{
if|if
condition|(
name|jptr
operator|->
name|polled
operator|==
literal|0
condition|)
block|{
name|still_pending
operator|++
expr_stmt|;
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|yp_error
argument_list|(
literal|"%s has not responded"
argument_list|,
name|jptr
operator|->
name|server
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|yp_error
argument_list|(
literal|"%s has responded"
argument_list|,
name|jptr
operator|->
name|server
argument_list|)
expr_stmt|;
block|}
name|jptr
operator|=
name|jptr
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|still_pending
condition|)
block|{
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|yp_error
argument_list|(
literal|"%d transfer%sstill pending"
argument_list|,
name|still_pending
argument_list|,
name|still_pending
operator|>
literal|1
condition|?
literal|"s "
else|:
literal|" "
argument_list|)
expr_stmt|;
name|yppush_alarm_tripped
operator|=
literal|0
expr_stmt|;
name|alarm
argument_list|(
name|YPPUSH_RESPONSE_TIMEOUT
argument_list|)
expr_stmt|;
name|pause
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|yppush_alarm_tripped
operator|==
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"timed out"
argument_list|)
expr_stmt|;
name|now
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|yp_error
argument_list|(
literal|"all transfers complete"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* All stats collected and reported -- kill all the stragglers. */
name|jptr
operator|=
name|yppush_joblist
expr_stmt|;
while|while
condition|(
name|jptr
condition|)
block|{
if|if
condition|(
operator|!
name|jptr
operator|->
name|polled
condition|)
name|yp_error
argument_list|(
literal|"warning: exiting with transfer \ to %s (transid = %lu) still pending"
argument_list|,
name|jptr
operator|->
name|server
argument_list|,
name|jptr
operator|->
name|tid
argument_list|)
expr_stmt|;
name|svc_unregister
argument_list|(
name|jptr
operator|->
name|prognum
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|jptr
operator|=
name|jptr
operator|->
name|next
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handler for 'normal' signals.  */
end_comment

begin_function
specifier|static
name|void
name|handler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|sig
operator|==
name|SIGTERM
operator|||
name|sig
operator|==
name|SIGINT
operator|||
name|sig
operator|==
name|SIGABRT
condition|)
block|{
name|yppush_jobs
operator|=
literal|0
expr_stmt|;
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sig
operator|==
name|SIGALRM
condition|)
block|{
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|yppush_alarm_tripped
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Dispatch loop for callback RPC services.  */
end_comment

begin_function
specifier|static
name|void
name|yppush_svc_run
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|FD_SETSIZE
name|fd_set
name|readfds
decl_stmt|;
else|#
directive|else
name|int
name|readfds
decl_stmt|;
endif|#
directive|endif
comment|/* def FD_SETSIZE */
name|struct
name|timeval
name|timeout
decl_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|5
expr_stmt|;
name|retry
label|:
ifdef|#
directive|ifdef
name|FD_SETSIZE
name|readfds
operator|=
name|svc_fdset
expr_stmt|;
else|#
directive|else
name|readfds
operator|=
name|svc_fds
expr_stmt|;
endif|#
directive|endif
comment|/* def FD_SETSIZE */
switch|switch
condition|(
name|select
argument_list|(
name|_rpc_dtablesize
argument_list|()
argument_list|,
operator|&
name|readfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|retry
goto|;
name|yp_error
argument_list|(
literal|"select failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|yp_error
argument_list|(
literal|"select() timed out"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|svc_getreqset
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Special handler for asynchronous socket I/O. We mark the  * sockets of the callback handlers as O_ASYNC and handle SIGIO  * events here, which will occur when the callback handler has  * something interesting to tell us.  */
end_comment

begin_function
specifier|static
name|void
name|async_handler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|yppush_svc_run
argument_list|()
expr_stmt|;
comment|/* reset any pending alarms. */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|yppush_alarm_tripped
operator|++
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * RPC service routines for callbacks.  */
end_comment

begin_function
name|void
modifier|*
name|yppushproc_null_1_svc
parameter_list|(
name|void
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|result
decl_stmt|;
comment|/* Do nothing -- RPC conventions call for all a null proc. */
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|yppushproc_xfrresp_1_svc
parameter_list|(
name|yppushresp_xfr
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|result
decl_stmt|;
name|yppush_show_status
argument_list|(
name|argp
operator|->
name|status
argument_list|,
name|argp
operator|->
name|transid
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit a YPPROC_XFR request to ypserv.  */
end_comment

begin_function
specifier|static
name|int
name|yppush_send_xfr
parameter_list|(
name|job
parameter_list|)
name|struct
name|jobs
modifier|*
name|job
decl_stmt|;
block|{
name|ypreq_xfr
name|req
decl_stmt|;
comment|/*	ypresp_xfr *resp; */
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|CLIENT
modifier|*
name|clnt
decl_stmt|;
name|struct
name|rpc_err
name|err
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The ypreq_xfr structure has a member of type map_parms, 	 * which seems to require the order number of the map. 	 * It isn't actually used at the other end (at least the 	 * FreeBSD ypserv doesn't use it) but we fill it in here 	 * for the sake of completeness. 	 */
name|key
operator|.
name|data
operator|=
literal|"YP_LAST_MODIFIED"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_LAST_MODIFIED"
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|yp_get_record
argument_list|(
name|yppush_domain
argument_list|,
name|yppush_mapname
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to read order number from %s: %s: %s"
argument_list|,
name|yppush_mapname
argument_list|,
name|yperr_string
argument_list|(
name|yp_errno
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Fill in the request arguments */
name|req
operator|.
name|map_parms
operator|.
name|ordernum
operator|=
name|atoi
argument_list|(
name|data
operator|.
name|data
argument_list|)
expr_stmt|;
name|req
operator|.
name|map_parms
operator|.
name|domain
operator|=
name|yppush_domain
expr_stmt|;
name|req
operator|.
name|map_parms
operator|.
name|peer
operator|=
name|yppush_master
expr_stmt|;
name|req
operator|.
name|map_parms
operator|.
name|map
operator|=
name|job
operator|->
name|map
expr_stmt|;
name|req
operator|.
name|transid
operator|=
name|job
operator|->
name|tid
expr_stmt|;
name|req
operator|.
name|prog
operator|=
name|job
operator|->
name|prognum
expr_stmt|;
name|req
operator|.
name|port
operator|=
name|job
operator|->
name|port
expr_stmt|;
comment|/* Get a handle to the remote ypserv. */
if|if
condition|(
operator|(
name|clnt
operator|=
name|clnt_create
argument_list|(
name|job
operator|->
name|server
argument_list|,
name|YPPROG
argument_list|,
name|YPVERS
argument_list|,
literal|"udp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|job
operator|->
name|server
argument_list|,
name|clnt_spcreateerror
argument_list|(
literal|"couldn't \ create udp handle to NIS server"
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rpc_createerr
operator|.
name|cf_stat
condition|)
block|{
case|case
name|RPC_UNKNOWNHOST
case|:
name|job
operator|->
name|stat
operator|=
name|YPPUSH_NOHOST
expr_stmt|;
break|break;
case|case
name|RPC_PMAPFAILURE
case|:
name|job
operator|->
name|stat
operator|=
name|YPPUSH_PMAP
expr_stmt|;
break|break;
default|default:
name|job
operator|->
name|stat
operator|=
name|YPPUSH_RPC
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Reduce timeout to nothing since we may not 	 * get a response from ypserv and we don't want to block. 	 */
if|if
condition|(
name|clnt_control
argument_list|(
name|clnt
argument_list|,
name|CLSET_TIMEOUT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|timeout
argument_list|)
operator|==
name|FALSE
condition|)
name|yp_error
argument_list|(
literal|"failed to set timeout on ypproc_xfr call"
argument_list|)
expr_stmt|;
comment|/* Invoke the ypproc_xfr service. */
if|if
condition|(
name|ypproc_xfr_2
argument_list|(
operator|&
name|req
argument_list|,
name|clnt
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|clnt_geterr
argument_list|(
name|clnt
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|re_status
operator|!=
name|RPC_SUCCESS
operator|&&
name|err
operator|.
name|re_status
operator|!=
name|RPC_TIMEDOUT
condition|)
block|{
name|yp_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|job
operator|->
name|server
argument_list|,
name|clnt_sperror
argument_list|(
name|clnt
argument_list|,
literal|"yp_xfr failed"
argument_list|)
argument_list|)
expr_stmt|;
name|job
operator|->
name|stat
operator|=
name|YPPUSH_YPSERV
expr_stmt|;
name|clnt_destroy
argument_list|(
name|clnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|clnt_destroy
argument_list|(
name|clnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Main driver function. Register the callback service, add the transfer  * request to the internal list, send the YPPROC_XFR request to ypserv  * do other magic things.  */
end_comment

begin_function
name|int
name|yp_push
parameter_list|(
name|server
parameter_list|,
name|map
parameter_list|,
name|tid
parameter_list|)
name|char
modifier|*
name|server
decl_stmt|;
name|char
modifier|*
name|map
decl_stmt|;
name|unsigned
name|long
name|tid
decl_stmt|;
block|{
name|unsigned
name|long
name|prognum
decl_stmt|;
name|int
name|sock
init|=
name|RPC_ANYSOCK
decl_stmt|;
name|SVCXPRT
modifier|*
name|xprt
decl_stmt|;
name|struct
name|jobs
modifier|*
name|job
decl_stmt|;
comment|/* 	 * Register the callback service on the first free 	 * transient program number. 	 */
name|xprt
operator|=
name|svcudp_create
argument_list|(
name|sock
argument_list|)
expr_stmt|;
for|for
control|(
name|prognum
operator|=
literal|0x40000000
init|;
name|prognum
operator|<
literal|0x5FFFFFFF
condition|;
name|prognum
operator|++
control|)
block|{
if|if
condition|(
name|svc_register
argument_list|(
name|xprt
argument_list|,
name|prognum
argument_list|,
literal|1
argument_list|,
name|yppush_xfrrespprog_1
argument_list|,
name|IPPROTO_UDP
argument_list|)
operator|==
name|TRUE
condition|)
break|break;
block|}
comment|/* Register the job in our linked list of jobs. */
if|if
condition|(
operator|(
name|job
operator|=
operator|(
expr|struct
name|jobs
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|jobs
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the info for this job. */
name|job
operator|->
name|stat
operator|=
literal|0
expr_stmt|;
name|job
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
name|job
operator|->
name|port
operator|=
name|xprt
operator|->
name|xp_port
expr_stmt|;
name|job
operator|->
name|sock
operator|=
name|xprt
operator|->
name|xp_sock
expr_stmt|;
comment|/*XXX: Evil!! EEEEEEEVIL!!! */
name|job
operator|->
name|server
operator|=
name|strdup
argument_list|(
name|server
argument_list|)
expr_stmt|;
name|job
operator|->
name|map
operator|=
name|strdup
argument_list|(
name|map
argument_list|)
expr_stmt|;
name|job
operator|->
name|prognum
operator|=
name|prognum
expr_stmt|;
name|job
operator|->
name|polled
operator|=
literal|0
expr_stmt|;
name|job
operator|->
name|next
operator|=
name|yppush_joblist
expr_stmt|;
name|yppush_joblist
operator|=
name|job
expr_stmt|;
comment|/* 	 * Set the RPC sockets to asynchronous mode. This will 	 * cause the system to smack us with a SIGIO when an RPC 	 * callback is delivered. This in turn allows us to handle 	 * the callback even though we may be in the middle of doing 	 * something else at the time. 	 * 	 * XXX This is a horrible thing to do for two reasons, 	 * both of which have to do with portability: 	 * 1) We really ought not to be sticking our grubby mits 	 *    into the RPC service transport handle like this. 	 * 2) Even in this day and age, there are still some *NIXes 	 *    that don't support async socket I/O. 	 */
if|if
condition|(
name|fcntl
argument_list|(
name|xprt
operator|->
name|xp_sock
argument_list|,
name|F_SETOWN
argument_list|,
name|getpid
argument_list|()
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|fcntl
argument_list|(
name|xprt
operator|->
name|xp_sock
argument_list|,
name|F_SETFL
argument_list|,
name|O_ASYNC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to set async I/O mode: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|yp_error
argument_list|(
literal|"initiating transfer: %s -> %s (transid = %lu)"
argument_list|,
name|yppush_mapname
argument_list|,
name|server
argument_list|,
name|tid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Send the XFR request to ypserv. We don't have to wait for 	 * a response here since we can handle them asynchronously. 	 */
if|if
condition|(
name|yppush_send_xfr
argument_list|(
name|job
argument_list|)
condition|)
block|{
comment|/* Transfer request blew up. */
name|yppush_show_status
argument_list|(
name|job
operator|->
name|stat
condition|?
name|job
operator|->
name|stat
else|:
name|YPPUSH_YPSERV
argument_list|,
name|job
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|yp_error
argument_list|(
literal|"%s has been called"
argument_list|,
name|server
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called for each entry in the ypservers map from yp_get_map(), which  * is our private yp_all() routine.  */
end_comment

begin_function
name|int
name|yppush_foreach
parameter_list|(
name|status
parameter_list|,
name|key
parameter_list|,
name|keylen
parameter_list|,
name|val
parameter_list|,
name|vallen
parameter_list|,
name|data
parameter_list|)
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|keylen
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|vallen
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|{
name|char
name|server
index|[
name|YPMAXRECORD
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|status
operator|!=
name|YP_TRUE
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|snprintf
argument_list|(
name|server
argument_list|,
sizeof|sizeof
argument_list|(
name|server
argument_list|)
argument_list|,
literal|"%.*s"
argument_list|,
name|vallen
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * Restrict the number of concurrent jobs. If yppush_jobs number 	 * of jobs have already been dispatched and are still pending, 	 * wait for one of them to finish so we can reuse its slot. 	 */
if|if
condition|(
name|yppush_jobs
operator|<=
literal|1
condition|)
block|{
name|yppush_alarm_tripped
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|yppush_alarm_tripped
operator|&&
name|yppush_running_jobs
condition|)
block|{
name|alarm
argument_list|(
name|yppush_timeout
argument_list|)
expr_stmt|;
name|yppush_alarm_tripped
operator|=
literal|0
expr_stmt|;
name|pause
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|yppush_alarm_tripped
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|yppush_alarm_tripped
operator|&&
name|yppush_running_jobs
operator|>=
name|yppush_jobs
condition|)
block|{
name|alarm
argument_list|(
name|yppush_timeout
argument_list|)
expr_stmt|;
name|yppush_alarm_tripped
operator|=
literal|0
expr_stmt|;
name|pause
argument_list|()
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Cleared for takeoff: set everything in motion. */
if|if
condition|(
name|yp_push
argument_list|(
operator|&
name|server
argument_list|,
name|yppush_mapname
argument_list|,
name|yppush_transid
argument_list|)
condition|)
return|return
operator|(
name|yp_errno
operator|)
return|;
comment|/* Bump the job counter and transaction ID. */
name|yppush_running_jobs
operator|++
expr_stmt|;
name|yppush_transid
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n"
argument_list|,
literal|"usage: yppush [-d domain] [-t timeout] [-j #parallel jobs] [-h host]"
argument_list|,
literal|"              [-p path] mapname"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Entry point. (About time!)  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|data
decl_stmt|;
name|char
name|myname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
struct|struct
name|hostlist
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|hostlist
modifier|*
name|next
decl_stmt|;
block|}
struct|;
name|struct
name|hostlist
modifier|*
name|yppush_hostlist
init|=
name|NULL
decl_stmt|;
name|struct
name|hostlist
modifier|*
name|tmp
decl_stmt|;
name|struct
name|sigaction
name|sa
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"d:j:p:h:t:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
name|yppush_domain
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|yppush_jobs
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|yppush_jobs
operator|<=
literal|0
condition|)
name|yppush_jobs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|yp_dir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* we can handle multiple hosts */
if|if
condition|(
operator|(
name|tmp
operator|=
operator|(
expr|struct
name|hostlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hostlist
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|yppush_hostlist
expr_stmt|;
name|yppush_hostlist
operator|=
name|tmp
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|yppush_timeout
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|yppush_mapname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|yppush_mapname
operator|==
name|NULL
condition|)
block|{
comment|/* "No guts, no glory." */
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * If no domain was specified, try to find the default 	 * domain. If we can't find that, we're doomed and must bail. 	 */
if|if
condition|(
name|yppush_domain
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|yppush_check_domain
decl_stmt|;
if|if
condition|(
operator|!
name|yp_get_default_domain
argument_list|(
operator|&
name|yppush_check_domain
argument_list|)
operator|&&
operator|!
name|_yp_check
argument_list|(
operator|&
name|yppush_check_domain
argument_list|)
condition|)
block|{
name|yp_error
argument_list|(
literal|"no domain specified and NIS not running"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
else|else
name|yp_get_default_domain
argument_list|(
operator|&
name|yppush_domain
argument_list|)
expr_stmt|;
block|}
comment|/* Check to see that we are the master for this map. */
if|if
condition|(
name|gethostname
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|myname
argument_list|,
sizeof|sizeof
argument_list|(
name|myname
argument_list|)
argument_list|)
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to get name of local host: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|key
operator|.
name|data
operator|=
literal|"YP_MASTER_NAME"
expr_stmt|;
name|key
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
literal|"YP_MASTER_NAME"
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|yp_get_record
argument_list|(
name|yppush_domain
argument_list|,
name|yppush_mapname
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|data
argument_list|,
literal|1
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"couldn't open %s map: %s"
argument_list|,
name|yppush_mapname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|myname
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|size
argument_list|)
condition|)
block|{
name|yp_error
argument_list|(
literal|"warning: this host is not the master for %s"
argument_list|,
name|yppush_mapname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NITPICKY
name|yppush_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|yppush_master
operator|=
name|malloc
argument_list|(
name|data
operator|.
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|yppush_master
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|size
argument_list|)
expr_stmt|;
name|yppush_master
index|[
name|data
operator|.
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Install some handy handlers. */
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the SIGIO handler. Make sure that some of the 	 * other signals are blocked while the handler is running so 	 * select() doesn't get interrupted. 	 */
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
comment|/* Goes without saying. */
name|sigaddset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|async_handler
expr_stmt|;
name|sigaction
argument_list|(
name|SIGIO
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* set initial transaction ID */
name|time
argument_list|(
operator|&
name|yppush_transid
argument_list|)
expr_stmt|;
if|if
condition|(
name|yppush_hostlist
condition|)
block|{
comment|/* 	 * Host list was specified on the command line: 	 * kick off the transfers by hand. 	 */
name|tmp
operator|=
name|yppush_hostlist
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|yppush_foreach
argument_list|(
name|YP_TRUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|tmp
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|tmp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * Do a yp_all() on the ypservers map and initiate a ypxfr 	 * for each one. 	 */
name|ypxfr_get_map
argument_list|(
literal|"ypservers"
argument_list|,
name|yppush_domain
argument_list|,
literal|"localhost"
argument_list|,
name|yppush_foreach
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|yp_error
argument_list|(
literal|"all jobs dispatched"
argument_list|)
expr_stmt|;
comment|/* All done -- normal exit. */
name|yppush_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Just in case. */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

