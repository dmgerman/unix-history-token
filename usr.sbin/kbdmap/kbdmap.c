begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Jonathan Belson<jon@witchspace.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stringlist.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"kbdmap.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lang_default
init|=
name|DEFAULT_LANG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lang
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|program
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|keymapdir
init|=
name|DEFAULT_KEYMAP_DIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|fontdir
init|=
name|DEFAULT_FONT_DIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sysconfig
init|=
name|DEFAULT_SYSCONFIG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|font_default
init|=
name|DEFAULT_FONT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|font_current
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|menu
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|x11
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|show
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|print
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|keymap
block|{
name|char
modifier|*
name|desc
decl_stmt|;
name|char
modifier|*
name|keym
decl_stmt|;
name|int
name|mark
decl_stmt|;
name|SLIST_ENTRY
argument_list|(
argument|keymap
argument_list|)
name|entries
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument|slisthead
argument_list|,
argument|keymap
argument_list|)
name|head
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Get keymap entry for 'key', or NULL of not found  */
end_comment

begin_function
specifier|static
name|struct
name|keymap
modifier|*
name|get_keymap
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|keymap
modifier|*
name|km
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|km
argument_list|,
argument|&head
argument_list|,
argument|entries
argument_list|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|km
operator|->
name|keym
argument_list|,
name|key
argument_list|)
condition|)
return|return
name|km
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Count the number of keymaps we found  */
end_comment

begin_function
specifier|static
name|int
name|get_num_keymaps
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|keymap
modifier|*
name|km
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|km
argument_list|,
argument|&head
argument_list|,
argument|entries
argument_list|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/*  * Remove any keymap with given keym  */
end_comment

begin_function
specifier|static
name|void
name|remove_keymap
parameter_list|(
specifier|const
name|char
modifier|*
name|keym
parameter_list|)
block|{
name|struct
name|keymap
modifier|*
name|km
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|km
argument_list|,
argument|&head
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|keym
argument_list|,
name|km
operator|->
name|keym
argument_list|)
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|head
argument_list|,
name|km
argument_list|,
name|keymap
argument_list|,
name|entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|km
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add to hash with 'key'  */
end_comment

begin_function
specifier|static
name|void
name|add_keymap
parameter_list|(
specifier|const
name|char
modifier|*
name|desc
parameter_list|,
name|int
name|mark
parameter_list|,
specifier|const
name|char
modifier|*
name|keym
parameter_list|)
block|{
name|struct
name|keymap
modifier|*
name|km
decl_stmt|,
modifier|*
name|km_new
decl_stmt|;
comment|/* Is there already an entry with this key? */
name|SLIST_FOREACH
argument_list|(
argument|km
argument_list|,
argument|&head
argument_list|,
argument|entries
argument_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|km
operator|->
name|keym
argument_list|,
name|keym
argument_list|)
condition|)
block|{
comment|/* Reuse this entry */
name|free
argument_list|(
name|km
operator|->
name|desc
argument_list|)
expr_stmt|;
name|km
operator|->
name|desc
operator|=
name|strdup
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|km
operator|->
name|mark
operator|=
name|mark
expr_stmt|;
return|return;
block|}
block|}
name|km_new
operator|=
operator|(
expr|struct
name|keymap
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|keymap
argument_list|)
argument_list|)
expr_stmt|;
name|km_new
operator|->
name|desc
operator|=
name|strdup
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|km_new
operator|->
name|keym
operator|=
name|strdup
argument_list|(
name|keym
argument_list|)
expr_stmt|;
name|km_new
operator|->
name|mark
operator|=
name|mark
expr_stmt|;
comment|/* Add to keymap list */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|head
argument_list|,
name|km_new
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Figure out the default language to use.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_locale
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|locale
decl_stmt|;
if|if
condition|(
operator|(
name|locale
operator|=
name|getenv
argument_list|(
literal|"LC_ALL"
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|locale
operator|=
name|getenv
argument_list|(
literal|"LC_CTYPE"
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|locale
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|locale
operator|=
name|lang_default
expr_stmt|;
comment|/* Check for alias */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|locale
argument_list|,
literal|"C"
argument_list|)
condition|)
name|locale
operator|=
name|DEFAULT_LANG
expr_stmt|;
return|return
name|locale
return|;
block|}
end_function

begin_comment
comment|/*  * Extract filename part  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|extract_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|p
operator|+
literal|1
return|;
return|return
name|name
return|;
block|}
end_function

begin_comment
comment|/*  * Return file extension or NULL  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_extension
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|p
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Read font from /etc/rc.conf else return default.  * Freeing the memory is the caller's responsibility.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_font
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|line
index|[
literal|256
index|]
decl_stmt|,
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|fnt
init|=
name|NULL
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|sysconfig
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|matches
decl_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
name|matches
operator|=
name|sscanf
argument_list|(
name|line
argument_list|,
literal|" font%dx%d = \"%20[-.0-9a-zA-Z_]"
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"NO"
argument_list|)
condition|)
block|{
if|if
condition|(
name|fnt
condition|)
name|free
argument_list|(
name|fnt
argument_list|)
expr_stmt|;
name|fnt
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fnt
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not open %s for reading\n"
argument_list|,
name|sysconfig
argument_list|)
expr_stmt|;
return|return
name|fnt
return|;
block|}
end_function

begin_comment
comment|/*  * Set a font using 'vidcontrol'  */
end_comment

begin_function
specifier|static
name|void
name|vidcontrol
parameter_list|(
specifier|const
name|char
modifier|*
name|fnt
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* syscons test failed */
if|if
condition|(
name|x11
condition|)
return|return;
name|tmp
operator|=
name|strdup
argument_list|(
name|fnt
argument_list|)
expr_stmt|;
comment|/* Extract font size */
name|p
operator|=
name|strrchr
argument_list|(
name|tmp
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|++
expr_stmt|;
comment|/* Remove any '.fnt' extension */
if|if
condition|(
operator|(
name|q
operator|=
name|strstr
argument_list|(
name|p
argument_list|,
literal|".fnt"
argument_list|)
operator|)
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * Check font size is valid, with no trailing characters 		 *  ('&ch' should not be matched) 		 */
if|if
condition|(
name|sscanf
argument_list|(
name|p
argument_list|,
literal|"%dx%d%c"
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|ch
argument_list|)
operator|!=
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Which font size? %s\n"
argument_list|,
name|fnt
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|cmd
argument_list|,
literal|"vidcontrol -f %s %s"
argument_list|,
name|p
argument_list|,
name|fnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Which font size? %s\n"
argument_list|,
name|fnt
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Execute 'kbdcontrol' with the appropriate arguments  */
end_comment

begin_function
specifier|static
name|void
name|do_kbdcontrol
parameter_list|(
name|struct
name|keymap
modifier|*
name|km
parameter_list|)
block|{
name|char
modifier|*
name|kbd_cmd
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|kbd_cmd
argument_list|,
literal|"kbdcontrol -l %s/%s"
argument_list|,
name|dir
argument_list|,
name|km
operator|->
name|keym
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x11
condition|)
name|system
argument_list|(
name|kbd_cmd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"keymap=%s\n"
argument_list|,
name|km
operator|->
name|keym
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kbd_cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call 'vidcontrol' with the appropriate arguments  */
end_comment

begin_function
specifier|static
name|void
name|do_vidfont
parameter_list|(
name|struct
name|keymap
modifier|*
name|km
parameter_list|)
block|{
name|char
modifier|*
name|vid_cmd
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|vid_cmd
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|km
operator|->
name|keym
argument_list|)
expr_stmt|;
name|vidcontrol
argument_list|(
name|vid_cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vid_cmd
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|strdup
argument_list|(
name|km
operator|->
name|keym
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|tmp
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|q
operator|=
name|get_extension
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"font%s=%s\n"
argument_list|,
name|p
argument_list|,
name|km
operator|->
name|keym
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display dialog from 'keymaps[]'  */
end_comment

begin_function
specifier|static
name|void
name|show_dialog
parameter_list|(
name|struct
name|keymap
modifier|*
modifier|*
name|km_sorted
parameter_list|,
name|int
name|num_keymaps
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|dialog
decl_stmt|;
name|char
name|tmp_name
index|[]
init|=
literal|"/tmp/_kbd_lang.XXXX"
decl_stmt|;
specifier|const
name|char
modifier|*
name|ext
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|,
name|size
decl_stmt|;
name|fd
operator|=
name|mkstemp
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not open temporary file \"%s\"\n"
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|asprintf
argument_list|(
operator|&
name|dialog
argument_list|,
literal|"/usr/bin/dialog --clear --title \"Keyboard Menu\" "
literal|"--menu \"%s\" -1 -1 10"
argument_list|,
name|menu
argument_list|)
expr_stmt|;
name|ext
operator|=
name|extract_name
argument_list|(
name|dir
argument_list|)
expr_stmt|;
comment|/* start right font, assume that current font is equal 	 * to default font in /etc/rc.conf 	 *	 	 * $font is the font which require the language $lang; e.g. 	 * russian *need* a koi8 font 	 * $font_current is the current font from /etc/rc.conf 	 */
if|if
condition|(
name|font
operator|&&
name|strcmp
argument_list|(
name|font
argument_list|,
name|font_current
argument_list|)
condition|)
name|vidcontrol
argument_list|(
name|font
argument_list|)
expr_stmt|;
comment|/* Build up the command */
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_keymaps
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Each 'font' is passed as ' "font" ""', so allow the 		 * extra space 		 */
name|size
operator|+=
name|strlen
argument_list|(
name|km_sorted
index|[
name|i
index|]
operator|->
name|desc
argument_list|)
operator|+
literal|6
expr_stmt|;
block|}
comment|/* Allow the space for '2> tmpfilename' redirection */
name|size
operator|+=
name|strlen
argument_list|(
name|tmp_name
argument_list|)
operator|+
literal|3
expr_stmt|;
name|cmd
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|dialog
argument_list|)
operator|+
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmd
argument_list|,
name|dialog
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_keymaps
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|cmd
argument_list|,
literal|" \""
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
name|km_sorted
index|[
name|i
index|]
operator|->
name|desc
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
literal|" \"\""
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|cmd
argument_list|,
literal|" 2>"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
name|tmp_name
argument_list|)
expr_stmt|;
comment|/* Show the dialog.. */
name|system
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|tmp_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|char
name|choice
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|choice
argument_list|,
literal|64
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Find key for desc */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_keymaps
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|choice
argument_list|,
name|km_sorted
index|[
name|i
index|]
operator|->
name|desc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|program
argument_list|,
literal|"kbdmap"
argument_list|)
condition|)
name|do_kbdcontrol
argument_list|(
name|km_sorted
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|do_vidfont
argument_list|(
name|km_sorted
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|font
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|font
argument_list|,
name|font_current
argument_list|)
condition|)
comment|/* Cancelled, restore old font */
name|vidcontrol
argument_list|(
name|font_current
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Failed to open temporary file"
argument_list|)
expr_stmt|;
comment|/* Tidy up */
name|remove
argument_list|(
name|tmp_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dialog
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Search for 'token' in comma delimited array 'buffer'.  * Return true for found, false for not found.  */
end_comment

begin_function
specifier|static
name|int
name|find_token
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
name|char
modifier|*
name|buffer_tmp
decl_stmt|,
modifier|*
name|buffer_copy
decl_stmt|,
modifier|*
name|inputstring
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
name|int
name|found
decl_stmt|;
name|buffer_copy
operator|=
name|strdup
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer_tmp
operator|=
name|buffer_copy
expr_stmt|;
name|inputstring
operator|=
name|buffer_copy
expr_stmt|;
name|ap
operator|=
operator|&
name|buffer_tmp
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|ap
operator|=
name|strsep
argument_list|(
operator|&
name|inputstring
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buffer_tmp
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|buffer_copy
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * Compare function for qsort  */
end_comment

begin_function
specifier|static
name|int
name|compare_keymap
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
comment|/* We've been passed pointers to pointers, so: */
specifier|const
name|struct
name|keymap
modifier|*
name|km1
init|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|keymap
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|struct
name|keymap
modifier|*
name|km2
init|=
operator|*
operator|(
operator|(
specifier|const
expr|struct
name|keymap
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|km1
operator|->
name|desc
argument_list|,
name|km2
operator|->
name|desc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare function for qsort  */
end_comment

begin_function
specifier|static
name|int
name|compare_lang
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|l1
init|=
operator|*
operator|(
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|l2
init|=
operator|*
operator|(
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|l1
argument_list|,
name|l2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change '8x8' to '8x08' so qsort will put it before eg. '8x14'  */
end_comment

begin_function
specifier|static
name|void
name|kludge_desc
parameter_list|(
name|struct
name|keymap
modifier|*
modifier|*
name|km_sorted
parameter_list|,
name|int
name|num_keymaps
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_keymaps
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|km
init|=
name|km_sorted
index|[
name|i
index|]
operator|->
name|desc
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strstr
argument_list|(
name|km
argument_list|,
literal|"8x8"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|offset
operator|=
name|p
operator|-
name|km
expr_stmt|;
comment|/* Make enough space for the extra '0' */
name|len
operator|=
name|strlen
argument_list|(
name|km
argument_list|)
expr_stmt|;
name|km
operator|=
name|realloc
argument_list|(
name|km
argument_list|,
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|len
init|;
name|j
operator|!=
name|offset
operator|+
literal|1
condition|;
name|j
operator|--
control|)
name|km
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|km
index|[
name|j
index|]
expr_stmt|;
name|km
index|[
name|offset
operator|+
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
name|km_sorted
index|[
name|i
index|]
operator|->
name|desc
operator|=
name|km
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Reverse 'kludge_desc()' - change '8x08' back to '8x8'  */
end_comment

begin_function
specifier|static
name|void
name|unkludge_desc
parameter_list|(
name|struct
name|keymap
modifier|*
modifier|*
name|km_sorted
parameter_list|,
name|int
name|num_keymaps
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_keymaps
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|km
init|=
name|km_sorted
index|[
name|i
index|]
operator|->
name|desc
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strstr
argument_list|(
name|km
argument_list|,
literal|"8x08"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
name|p
index|[
operator|-
literal|1
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|km
operator|=
name|realloc
argument_list|(
name|km
argument_list|,
name|p
operator|-
name|km
operator|-
literal|1
argument_list|)
expr_stmt|;
name|km_sorted
index|[
name|i
index|]
operator|->
name|desc
operator|=
name|km
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Return 0 if file exists and is readable, else -1  */
end_comment

begin_function
specifier|static
name|int
name|check_file
parameter_list|(
specifier|const
name|char
modifier|*
name|keym
parameter_list|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|access
argument_list|(
name|keym
argument_list|,
name|R_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|fn
decl_stmt|;
name|asprintf
argument_list|(
operator|&
name|fn
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|keym
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|fn
argument_list|,
name|R_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s not found!\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No read permission for %s!\n"
argument_list|,
name|keym
argument_list|)
expr_stmt|;
name|status
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Read options from the relevent configuration file, then  *  present to user.  */
end_comment

begin_function
specifier|static
name|void
name|menu_read
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|lg
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|mark
decl_stmt|,
name|num_keymaps
decl_stmt|,
name|items
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buffer
index|[
literal|256
index|]
decl_stmt|,
name|filename
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|keym
index|[
literal|64
index|]
decl_stmt|,
name|lng
index|[
literal|64
index|]
decl_stmt|,
name|desc
index|[
literal|64
index|]
decl_stmt|;
name|char
name|dialect
index|[
literal|64
index|]
decl_stmt|,
name|lang_abk
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|keymap
modifier|*
name|km
decl_stmt|;
name|struct
name|keymap
modifier|*
modifier|*
name|km_sorted
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|StringList
modifier|*
name|lang_list
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|lang_list
operator|=
name|sl_init
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s/INDEX.%s"
argument_list|,
name|dir
argument_list|,
name|extract_name
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* en_US.ISO8859-1 -> en_..\.ISO8859-1 */
name|strlcpy
argument_list|(
name|dialect
argument_list|,
name|lang
argument_list|,
sizeof|sizeof
argument_list|(
name|dialect
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dialect
argument_list|)
operator|>=
literal|6
operator|&&
name|dialect
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
block|{
name|dialect
index|[
literal|3
index|]
operator|=
literal|'.'
expr_stmt|;
name|dialect
index|[
literal|4
index|]
operator|=
literal|'.'
expr_stmt|;
block|}
comment|/* en_US.ISO8859-1 -> en */
name|strlcpy
argument_list|(
name|lang_abk
argument_list|,
name|lang
argument_list|,
sizeof|sizeof
argument_list|(
name|lang_abk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|lang_abk
argument_list|)
operator|>=
literal|3
operator|&&
name|lang_abk
index|[
literal|2
index|]
operator|==
literal|'_'
condition|)
name|lang_abk
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lang_default = %s\n"
argument_list|,
name|lang_default
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dialect = %s\n"
argument_list|,
name|dialect
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"lang_abk = %s\n"
argument_list|,
name|lang_abk
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|int
name|matches
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|p
operator|=
name|buffer
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* Parse input, removing newline */
name|matches
operator|=
name|sscanf
argument_list|(
name|p
argument_list|,
literal|"%64[^:]:%64[^:]:%64[^:\n]"
argument_list|,
name|keym
argument_list|,
name|lng
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|keym
argument_list|,
literal|"FONT"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|keym
argument_list|,
literal|"MENU"
argument_list|)
condition|)
block|{
comment|/* Check file exists& is readable */
if|if
condition|(
name|check_file
argument_list|(
name|keym
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
block|}
block|}
if|if
condition|(
name|show
condition|)
block|{
comment|/* 				 * Take note of supported languages, which 				 * might be in a comma-delimited list 				 */
name|char
modifier|*
name|tmp
init|=
name|strdup
argument_list|(
name|lng
argument_list|)
decl_stmt|;
name|char
modifier|*
name|delim
init|=
name|tmp
decl_stmt|;
for|for
control|(
name|delim
operator|=
name|tmp
init|;
condition|;
control|)
block|{
name|char
name|ch
init|=
operator|*
name|delim
operator|++
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|','
operator|||
name|ch
operator|==
literal|'\0'
condition|)
block|{
name|delim
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|sl_find
argument_list|(
name|lang_list
argument_list|,
name|tmp
argument_list|)
condition|)
name|sl_add
argument_list|(
name|lang_list
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
break|break;
name|tmp
operator|=
name|delim
expr_stmt|;
block|}
block|}
block|}
comment|/* Set empty language to default language */
if|if
condition|(
name|lng
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|lg
operator|=
name|lang_default
expr_stmt|;
else|else
name|lg
operator|=
name|lng
expr_stmt|;
comment|/* 4) Your choice if it exists 			 * 3) Long match eg. en_GB.ISO8859-1 is equal to 			 *      en_..\.ISO8859-1 			 * 2) short match 'de' 			 * 1) default langlist 'en' 			 * 0) any language 			 * 			 * Language may be a comma separated list 			 * A higher match overwrites a lower 			 * A later entry overwrites a previous if it exists 			 *     twice in the database 			 */
comment|/* Check for favoured language */
name|km
operator|=
name|get_keymap
argument_list|(
name|keym
argument_list|)
expr_stmt|;
name|mark
operator|=
operator|(
name|km
operator|)
condition|?
name|km
operator|->
name|mark
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|find_token
argument_list|(
name|lg
argument_list|,
name|lang
argument_list|)
condition|)
name|add_keymap
argument_list|(
name|desc
argument_list|,
literal|4
argument_list|,
name|keym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mark
operator|<=
literal|3
operator|&&
name|find_token
argument_list|(
name|lg
argument_list|,
name|dialect
argument_list|)
condition|)
name|add_keymap
argument_list|(
name|desc
argument_list|,
literal|3
argument_list|,
name|keym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mark
operator|<=
literal|2
operator|&&
name|find_token
argument_list|(
name|lg
argument_list|,
name|lang_abk
argument_list|)
condition|)
name|add_keymap
argument_list|(
name|desc
argument_list|,
literal|2
argument_list|,
name|keym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mark
operator|<=
literal|1
operator|&&
name|find_token
argument_list|(
name|lg
argument_list|,
name|lang_default
argument_list|)
condition|)
name|add_keymap
argument_list|(
name|desc
argument_list|,
literal|1
argument_list|,
name|keym
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mark
operator|<=
literal|0
condition|)
name|add_keymap
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
name|keym
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Could not open file\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
condition|)
block|{
name|qsort
argument_list|(
name|lang_list
operator|->
name|sl_str
argument_list|,
name|lang_list
operator|->
name|sl_cur
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare_lang
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Currently supported languages: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|lang_list
operator|->
name|sl_cur
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|lang_list
operator|->
name|sl_str
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|km
operator|=
name|get_keymap
argument_list|(
literal|"MENU"
argument_list|)
expr_stmt|;
if|if
condition|(
name|km
condition|)
comment|/* Take note of menu title */
name|menu
operator|=
name|strdup
argument_list|(
name|km
operator|->
name|desc
argument_list|)
expr_stmt|;
name|km
operator|=
name|get_keymap
argument_list|(
literal|"FONT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|km
condition|)
comment|/* Take note of language font */
name|font
operator|=
name|strdup
argument_list|(
name|km
operator|->
name|desc
argument_list|)
expr_stmt|;
comment|/* Remove unwanted items from list */
name|remove_keymap
argument_list|(
literal|"MENU"
argument_list|)
expr_stmt|;
name|remove_keymap
argument_list|(
literal|"FONT"
argument_list|)
expr_stmt|;
comment|/* Look for keymaps not in database */
name|dirp
operator|=
name|opendir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
condition|)
block|{
while|while
condition|(
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|ext
init|=
name|get_extension
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|ext
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|strcmp
argument_list|(
name|ext
argument_list|,
literal|".fnt"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|ext
argument_list|,
literal|".kbd"
argument_list|)
operator|)
operator|&&
operator|!
name|get_keymap
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Remove any .fnt or .kbd extension */
name|q
operator|=
name|strdup
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
operator|*
operator|(
name|get_extension
argument_list|(
name|q
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|add_keymap
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"'%s' not in database\n"
argument_list|,
name|dp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not open directory '%s'\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* Sort items in keymap */
name|num_keymaps
operator|=
name|get_num_keymaps
argument_list|()
expr_stmt|;
name|km_sorted
operator|=
operator|(
expr|struct
name|keymap
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|num_keymaps
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|keymap
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make array of pointers to items in hash */
name|items
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|km
argument_list|,
argument|&head
argument_list|,
argument|entries
argument_list|)
name|km_sorted
index|[
name|items
operator|++
index|]
operator|=
name|km
expr_stmt|;
comment|/* Change '8x8' to '8x08' so sort works as we might expect... */
name|kludge_desc
argument_list|(
name|km_sorted
argument_list|,
name|num_keymaps
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|km_sorted
argument_list|,
name|num_keymaps
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|keymap
operator|*
argument_list|)
argument_list|,
name|compare_keymap
argument_list|)
expr_stmt|;
comment|/* ...change back again */
name|unkludge_desc
argument_list|(
name|km_sorted
argument_list|,
name|num_keymaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|print
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_keymaps
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|km_sorted
index|[
name|i
index|]
operator|->
name|desc
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|show_dialog
argument_list|(
name|km_sorted
argument_list|,
name|num_keymaps
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|km_sorted
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Display usage information and exit  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s\t[-K] [-V] [-d|-default] [-h|-help] "
literal|"[-l|-lang language]\n\t\t[-p|-print] [-r|-restore] [-s|-show] "
literal|"[-v|-verbose]\n"
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_args
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
name|usage
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-help"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-h"
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-verbose"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-v"
argument_list|)
condition|)
name|verbose
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-l"
argument_list|)
condition|)
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
else|else
name|lang
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-default"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-d"
argument_list|)
condition|)
name|lang
operator|=
name|lang_default
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-show"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-s"
argument_list|)
condition|)
name|show
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-print"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-p"
argument_list|)
condition|)
name|print
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-restore"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-r"
argument_list|)
condition|)
block|{
name|vidcontrol
argument_list|(
name|font_current
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-K"
argument_list|)
condition|)
name|dir
operator|=
name|keymapdir
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-V"
argument_list|)
condition|)
name|dir
operator|=
name|fontdir
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * A front-end for the 'vidfont' and 'kbdmap' programs.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|x11
operator|=
name|system
argument_list|(
literal|"kbdcontrol -d>/dev/null"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x11
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You are not on a virtual console - "
literal|"expect certain strange side-effects\n"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|head
argument_list|)
expr_stmt|;
name|lang
operator|=
name|get_locale
argument_list|()
expr_stmt|;
name|program
operator|=
name|extract_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|font_current
operator|=
name|get_font
argument_list|()
expr_stmt|;
if|if
condition|(
name|font_current
operator|==
name|NULL
condition|)
name|font_current
operator|=
name|font_default
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|program
argument_list|,
literal|"kbdmap"
argument_list|)
condition|)
name|dir
operator|=
name|fontdir
expr_stmt|;
else|else
name|dir
operator|=
name|keymapdir
expr_stmt|;
comment|/* Parse command line arguments */
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* Read and display options */
name|menu_read
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

