begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995  *	A.R. Gordon (andrew.gordon@net-tel.co.uk).  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed for the FreeBSD project  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ANDREW GORDON AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_comment
comment|/* for gethostbyname()		*/
end_comment

begin_include
include|#
directive|include
file|"statd.h"
end_include

begin_comment
comment|/* sm_stat_1 --------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	RPC call to enquire if a host can be monitored    Returns:	TRUE for any hostname that can be looked up to give 		an address. */
end_comment

begin_function
name|struct
name|sm_stat_res
modifier|*
name|sm_stat_1_svc
parameter_list|(
name|sm_name
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|)
block|{
specifier|static
name|sm_stat_res
name|res
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"stat called for host %s"
argument_list|,
name|arg
operator|->
name|mon_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gethostbyname
argument_list|(
name|arg
operator|->
name|mon_name
argument_list|)
condition|)
name|res
operator|.
name|res_stat
operator|=
name|stat_succ
expr_stmt|;
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"invalid hostname to sm_stat: %s"
argument_list|,
name|arg
operator|->
name|mon_name
argument_list|)
expr_stmt|;
name|res
operator|.
name|res_stat
operator|=
name|stat_fail
expr_stmt|;
block|}
name|res
operator|.
name|state
operator|=
name|status_info
operator|->
name|ourState
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sm_mon_1 ---------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	RPC procedure to establish a monitor request    Returns:	Success, unless lack of resources prevents 		the necessary structures from being set up 		to record the request, or if the hostname is not 		valid (as judged by gethostbyname()) */
end_comment

begin_function
name|struct
name|sm_stat_res
modifier|*
name|sm_mon_1_svc
parameter_list|(
name|mon
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|)
block|{
specifier|static
name|sm_stat_res
name|res
decl_stmt|;
name|HostInfo
modifier|*
name|hp
decl_stmt|;
name|MonList
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"monitor request for host %s"
argument_list|,
name|arg
operator|->
name|mon_id
operator|.
name|mon_name
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"recall host: %s prog: %d ver: %d proc: %d"
argument_list|,
name|arg
operator|->
name|mon_id
operator|.
name|mon_name
argument_list|,
name|arg
operator|->
name|mon_id
operator|.
name|my_id
operator|.
name|my_name
argument_list|,
name|arg
operator|->
name|mon_id
operator|.
name|my_id
operator|.
name|my_prog
argument_list|,
name|arg
operator|->
name|mon_id
operator|.
name|my_id
operator|.
name|my_vers
argument_list|,
name|arg
operator|->
name|mon_id
operator|.
name|my_id
operator|.
name|my_proc
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|res_stat
operator|=
name|stat_fail
expr_stmt|;
comment|/* Assume fail until set otherwise	*/
name|res
operator|.
name|state
operator|=
name|status_info
operator|->
name|ourState
expr_stmt|;
comment|/* Find existing host entry, or create one if not found		*/
comment|/* If find_host() fails, it will have logged the error already.	*/
if|if
condition|(
operator|!
name|gethostbyname
argument_list|(
name|arg
operator|->
name|mon_id
operator|.
name|mon_name
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Invalid hostname to sm_mon: %s"
argument_list|,
name|arg
operator|->
name|mon_id
operator|.
name|mon_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|hp
operator|=
name|find_host
argument_list|(
name|arg
operator|->
name|mon_id
operator|.
name|mon_name
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
block|{
name|lp
operator|=
operator|(
name|MonList
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MonList
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|lp
operator|->
name|notifyHost
argument_list|,
name|arg
operator|->
name|mon_id
operator|.
name|my_id
operator|.
name|my_name
argument_list|,
name|SM_MAXSTRLEN
argument_list|)
expr_stmt|;
name|lp
operator|->
name|notifyProg
operator|=
name|arg
operator|->
name|mon_id
operator|.
name|my_id
operator|.
name|my_prog
expr_stmt|;
name|lp
operator|->
name|notifyVers
operator|=
name|arg
operator|->
name|mon_id
operator|.
name|my_id
operator|.
name|my_vers
expr_stmt|;
name|lp
operator|->
name|notifyProc
operator|=
name|arg
operator|->
name|mon_id
operator|.
name|my_id
operator|.
name|my_proc
expr_stmt|;
name|memcpy
argument_list|(
name|lp
operator|->
name|notifyData
argument_list|,
name|arg
operator|->
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
name|lp
operator|->
name|notifyData
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|->
name|next
operator|=
name|hp
operator|->
name|monList
expr_stmt|;
name|hp
operator|->
name|monList
operator|=
name|lp
expr_stmt|;
name|sync_file
argument_list|()
expr_stmt|;
name|res
operator|.
name|res_stat
operator|=
name|stat_succ
expr_stmt|;
comment|/* Report success			*/
block|}
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* do_unmon ---------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Remove a monitor request from a host    Returns:	TRUE if found, FALSE if not found.    Notes:	Common code from sm_unmon_1_svc and sm_unmon_all_1_svc 		In the unlikely event of more than one identical monitor 		request, all are removed. */
end_comment

begin_function
specifier|static
name|int
name|do_unmon
parameter_list|(
name|HostInfo
modifier|*
name|hp
parameter_list|,
name|my_id
modifier|*
name|idp
parameter_list|)
block|{
name|MonList
modifier|*
name|lp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|MonList
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
name|int
name|result
init|=
name|FALSE
decl_stmt|;
name|lp
operator|=
name|hp
operator|->
name|monList
expr_stmt|;
while|while
condition|(
name|lp
condition|)
block|{
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|idp
operator|->
name|my_name
argument_list|,
name|lp
operator|->
name|notifyHost
argument_list|,
name|SM_MAXSTRLEN
argument_list|)
operator|&&
operator|(
name|idp
operator|->
name|my_prog
operator|==
name|lp
operator|->
name|notifyProg
operator|)
operator|&&
operator|(
name|idp
operator|->
name|my_proc
operator|==
name|lp
operator|->
name|notifyProc
operator|)
operator|&&
operator|(
name|idp
operator|->
name|my_vers
operator|==
name|lp
operator|->
name|notifyVers
operator|)
condition|)
block|{
comment|/* found one.  Unhook from chain and free.		*/
name|next
operator|=
name|lp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|last
operator|->
name|next
operator|=
name|next
expr_stmt|;
else|else
name|hp
operator|->
name|monList
operator|=
name|next
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|lp
operator|=
name|next
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
name|lp
expr_stmt|;
name|lp
operator|=
name|lp
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sm_unmon_1 -------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	RPC procedure to release a monitor request.    Returns:	Local machine's status number    Notes:	The supplied mon_id should match the value passed in an 		earlier call to sm_mon_1 */
end_comment

begin_function
name|struct
name|sm_stat
modifier|*
name|sm_unmon_1_svc
parameter_list|(
name|mon_id
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|)
block|{
specifier|static
name|sm_stat
name|res
decl_stmt|;
name|HostInfo
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"un-monitor request for host %s"
argument_list|,
name|arg
operator|->
name|mon_name
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"recall host: %s prog: %d ver: %d proc: %d"
argument_list|,
name|arg
operator|->
name|mon_name
argument_list|,
name|arg
operator|->
name|my_id
operator|.
name|my_name
argument_list|,
name|arg
operator|->
name|my_id
operator|.
name|my_prog
argument_list|,
name|arg
operator|->
name|my_id
operator|.
name|my_vers
argument_list|,
name|arg
operator|->
name|my_id
operator|.
name|my_proc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hp
operator|=
name|find_host
argument_list|(
name|arg
operator|->
name|mon_name
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|do_unmon
argument_list|(
name|hp
argument_list|,
operator|&
name|arg
operator|->
name|my_id
argument_list|)
condition|)
name|sync_file
argument_list|()
expr_stmt|;
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unmon request from %s, no matching monitor"
argument_list|,
name|arg
operator|->
name|my_id
operator|.
name|my_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unmon request from %s for unknown host %s"
argument_list|,
name|arg
operator|->
name|my_id
operator|.
name|my_name
argument_list|,
name|arg
operator|->
name|mon_name
argument_list|)
expr_stmt|;
name|res
operator|.
name|state
operator|=
name|status_info
operator|->
name|ourState
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sm_unmon_all_1 ---------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	RPC procedure to release monitor requests.    Returns:	Local machine's status number    Notes:	Releases all monitor requests (if any) from the specified 		host and program number. */
end_comment

begin_function
name|struct
name|sm_stat
modifier|*
name|sm_unmon_all_1_svc
parameter_list|(
name|my_id
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|)
block|{
specifier|static
name|sm_stat
name|res
decl_stmt|;
name|HostInfo
modifier|*
name|hp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unmon_all for host: %s prog: %d ver: %d proc: %d"
argument_list|,
name|arg
operator|->
name|my_name
argument_list|,
name|arg
operator|->
name|my_prog
argument_list|,
name|arg
operator|->
name|my_vers
argument_list|,
name|arg
operator|->
name|my_proc
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|status_info
operator|->
name|noOfHosts
operator|,
name|hp
operator|=
name|status_info
operator|->
name|hosts
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|hp
operator|++
control|)
block|{
name|do_unmon
argument_list|(
name|hp
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|sync_file
argument_list|()
expr_stmt|;
name|res
operator|.
name|state
operator|=
name|status_info
operator|->
name|ourState
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sm_simu_crash_1 --------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	RPC procedure to simulate a crash    Returns:	Nothing    Notes:	Standardised mechanism for debug purposes 		The specification says that we should drop all of our 		status information (apart from the list of monitored hosts 		on disc).  However, this would confuse the rpc.lockd 		which would be unaware that all of its monitor requests 		had been silently junked.  Hence we in fact retain all 		current requests and simply increment the status counter 		and inform all hosts on the monitor list. */
end_comment

begin_function
name|void
modifier|*
name|sm_simu_crash_1_svc
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|)
block|{
specifier|static
name|char
name|dummy
decl_stmt|;
name|int
name|work_to_do
decl_stmt|;
name|HostInfo
modifier|*
name|hp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"simu_crash called!!"
argument_list|)
expr_stmt|;
comment|/* Simulate crash by setting notify-required flag on all monitored	*/
comment|/* hosts, and incrementing our status number.  notify_hosts() is	*/
comment|/* then called to fork a process to do the notifications.		*/
for|for
control|(
name|i
operator|=
name|status_info
operator|->
name|noOfHosts
operator|,
name|hp
operator|=
name|status_info
operator|->
name|hosts
init|;
name|i
condition|;
name|i
operator|--
operator|,
name|hp
operator|++
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|monList
condition|)
block|{
name|work_to_do
operator|=
name|TRUE
expr_stmt|;
name|hp
operator|->
name|notifyReqd
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|status_info
operator|->
name|ourState
operator|+=
literal|2
expr_stmt|;
comment|/* always even numbers if not crashed	*/
if|if
condition|(
name|work_to_do
condition|)
name|notify_hosts
argument_list|()
expr_stmt|;
return|return
operator|(
operator|&
name|dummy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sm_notify_1 ------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	RPC procedure notifying local statd of the crash of another    Returns:	Nothing    Notes:	There is danger of deadlock, since it is quite likely that 		the client procedure that we call will in turn call us 		to remove or adjust the monitor request. 		We therefore fork() a process to do the notifications. 		Note that the main HostInfo structure is in a mmap() 		region and so will be shared with the child, but the 		monList pointed to by the HostInfo is in normal memory. 		Hence if we read the monList before forking, we are 		protected from the parent servicing other requests 		that modify the list. */
end_comment

begin_function
name|void
modifier|*
name|sm_notify_1_svc
parameter_list|(
name|stat_chge
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|timeval
name|timeout
init|=
block|{
literal|20
block|,
literal|0
block|}
decl_stmt|;
comment|/* 20 secs timeout		*/
name|CLIENT
modifier|*
name|cli
decl_stmt|;
specifier|static
name|char
name|dummy
decl_stmt|;
name|status
name|tx_arg
decl_stmt|;
comment|/* arg sent to callback procedure	*/
name|MonList
modifier|*
name|lp
decl_stmt|;
name|HostInfo
modifier|*
name|hp
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"notify from host %s, new state %d"
argument_list|,
name|arg
operator|->
name|mon_name
argument_list|,
name|arg
operator|->
name|state
argument_list|)
expr_stmt|;
name|hp
operator|=
name|find_host
argument_list|(
name|arg
operator|->
name|mon_name
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
block|{
comment|/* Never heard of this host - why is it notifying us?		*/
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unsolicited notification from host %s"
argument_list|,
name|arg
operator|->
name|mon_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|lp
operator|=
name|hp
operator|->
name|monList
expr_stmt|;
if|if
condition|(
operator|!
name|lp
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* We know this host, but have no	*/
comment|/* outstanding requests.		*/
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to fork notify process - %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pid
condition|)
return|return
operator|(
operator|&
name|dummy
operator|)
return|;
comment|/* Parent returns			*/
while|while
condition|(
name|lp
condition|)
block|{
name|tx_arg
operator|.
name|mon_name
operator|=
name|arg
operator|->
name|mon_name
expr_stmt|;
name|tx_arg
operator|.
name|state
operator|=
name|arg
operator|->
name|state
expr_stmt|;
name|memcpy
argument_list|(
name|tx_arg
operator|.
name|priv
argument_list|,
name|lp
operator|->
name|notifyData
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_arg
operator|.
name|priv
argument_list|)
argument_list|)
expr_stmt|;
name|cli
operator|=
name|clnt_create
argument_list|(
name|lp
operator|->
name|notifyHost
argument_list|,
name|lp
operator|->
name|notifyProg
argument_list|,
name|lp
operator|->
name|notifyVers
argument_list|,
literal|"udp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cli
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to contact host %s%s"
argument_list|,
name|lp
operator|->
name|notifyHost
argument_list|,
name|clnt_spcreateerror
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|lp
operator|->
name|notifyProc
argument_list|,
name|xdr_status
argument_list|,
operator|&
name|tx_arg
argument_list|,
name|xdr_void
argument_list|,
operator|&
name|dummy
argument_list|,
name|timeout
argument_list|)
operator|!=
name|RPC_SUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Failed to call rpc.statd client at host %s"
argument_list|,
name|lp
operator|->
name|notifyHost
argument_list|)
expr_stmt|;
block|}
name|clnt_destroy
argument_list|(
name|cli
argument_list|)
expr_stmt|;
block|}
name|lp
operator|=
name|lp
operator|->
name|next
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Child quits	*/
block|}
end_function

end_unit

