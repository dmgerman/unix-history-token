begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Edward Tomasz Napierala under sponsorship  * from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"autofs_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|yyin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|yytext
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|yylex
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_master_yyin
parameter_list|(
name|struct
name|node
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|master
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_map_yyin
parameter_list|(
name|struct
name|node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|executable_key
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|char
modifier|*
name|checked_strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|c
decl_stmt|;
name|assert
argument_list|(
name|s
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|c
operator|=
name|strdup
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"strdup"
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Concatenate two strings, inserting separator between them, unless not needed.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
name|char
name|separator
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
name|char
name|s1last
decl_stmt|,
name|s2first
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|s1
operator|==
name|NULL
condition|)
name|s1
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|s2
operator|==
name|NULL
condition|)
name|s2
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|s1
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|s1last
operator|=
literal|'\0'
expr_stmt|;
else|else
name|s1last
operator|=
name|s1
index|[
name|strlen
argument_list|(
name|s1
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|s2first
operator|=
name|s2
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|s1last
operator|==
name|separator
operator|&&
name|s2first
operator|==
name|separator
condition|)
block|{
comment|/* 		 * If s1 ends with the separator and s2 begins with 		 * it - skip the latter; otherwise concatenating "/" 		 * and "/foo" would end up returning "//foo". 		 */
name|ret
operator|=
name|asprintf
argument_list|(
operator|&
name|result
argument_list|,
literal|"%s%s"
argument_list|,
name|s1
argument_list|,
name|s2
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s1last
operator|==
name|separator
operator|||
name|s2first
operator|==
name|separator
operator|||
name|s1
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|s2
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ret
operator|=
name|asprintf
argument_list|(
operator|&
name|result
argument_list|,
literal|"%s%s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|asprintf
argument_list|(
operator|&
name|result
argument_list|,
literal|"%s%c%s"
argument_list|,
name|s1
argument_list|,
name|separator
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
comment|//log_debugx("%s: got %s and %s, returning %s", __func__, s1, s2, result);
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|create_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|component
decl_stmt|,
modifier|*
name|copy
decl_stmt|,
modifier|*
name|tofree
decl_stmt|,
modifier|*
name|partial
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|assert
argument_list|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
argument_list|)
expr_stmt|;
comment|/* 	 * +1 to skip the leading slash. 	 */
name|copy
operator|=
name|tofree
operator|=
name|checked_strdup
argument_list|(
name|path
operator|+
literal|1
argument_list|)
expr_stmt|;
name|partial
operator|=
name|checked_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|component
operator|=
name|strsep
argument_list|(
operator|&
name|copy
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|component
operator|==
name|NULL
condition|)
break|break;
name|tmp
operator|=
name|concat
argument_list|(
name|partial
argument_list|,
literal|'/'
argument_list|,
name|component
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|partial
argument_list|)
expr_stmt|;
name|partial
operator|=
name|tmp
expr_stmt|;
comment|//log_debugx("creating \"%s\"", partial);
name|error
operator|=
name|mkdir
argument_list|(
name|partial
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|log_warn
argument_list|(
literal|"cannot create %s"
argument_list|,
name|partial
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|node
modifier|*
name|node_new_root
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
comment|// XXX
name|n
operator|->
name|n_key
operator|=
name|checked_strdup
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_options
operator|=
name|checked_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|n
operator|->
name|n_children
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|node
modifier|*
name|node_new
parameter_list|(
name|struct
name|node
modifier|*
name|parent
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|char
modifier|*
name|options
parameter_list|,
name|char
modifier|*
name|location
parameter_list|,
specifier|const
name|char
modifier|*
name|config_file
parameter_list|,
name|int
name|config_line
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|n
operator|->
name|n_children
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|key
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_key
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
condition|)
name|n
operator|->
name|n_options
operator|=
name|options
expr_stmt|;
else|else
name|n
operator|->
name|n_options
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_location
operator|=
name|location
expr_stmt|;
name|assert
argument_list|(
name|config_file
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_config_file
operator|=
name|config_file
expr_stmt|;
name|assert
argument_list|(
name|config_line
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_config_line
operator|=
name|config_line
expr_stmt|;
name|assert
argument_list|(
name|parent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_parent
operator|=
name|parent
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|parent
operator|->
name|n_children
argument_list|,
name|n
argument_list|,
name|n_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|node
modifier|*
name|node_new_map
parameter_list|(
name|struct
name|node
modifier|*
name|parent
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|char
modifier|*
name|options
parameter_list|,
name|char
modifier|*
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|config_file
parameter_list|,
name|int
name|config_line
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|n
operator|->
name|n_children
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|key
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_key
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
condition|)
name|n
operator|->
name|n_options
operator|=
name|options
expr_stmt|;
else|else
name|n
operator|->
name|n_options
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_map
operator|=
name|map
expr_stmt|;
name|assert
argument_list|(
name|config_file
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_config_file
operator|=
name|config_file
expr_stmt|;
name|assert
argument_list|(
name|config_line
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_config_line
operator|=
name|config_line
expr_stmt|;
name|assert
argument_list|(
name|parent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_parent
operator|=
name|parent
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|parent
operator|->
name|n_children
argument_list|,
name|n
argument_list|,
name|n_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|node
modifier|*
name|node_duplicate
parameter_list|(
specifier|const
name|struct
name|node
modifier|*
name|o
parameter_list|,
name|struct
name|node
modifier|*
name|parent
parameter_list|)
block|{
specifier|const
name|struct
name|node
modifier|*
name|child
decl_stmt|;
name|struct
name|node
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
name|parent
operator|=
name|o
operator|->
name|n_parent
expr_stmt|;
name|n
operator|=
name|node_new
argument_list|(
name|parent
argument_list|,
name|o
operator|->
name|n_key
argument_list|,
name|o
operator|->
name|n_options
argument_list|,
name|o
operator|->
name|n_location
argument_list|,
name|o
operator|->
name|n_config_file
argument_list|,
name|o
operator|->
name|n_config_line
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&o->n_children
argument_list|,
argument|n_next
argument_list|)
name|node_duplicate
argument_list|(
name|child
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|node_delete
parameter_list|(
name|struct
name|node
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|child
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|assert
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|child
argument_list|,
argument|&n->n_children
argument_list|,
argument|n_next
argument_list|,
argument|tmp
argument_list|)
name|node_delete
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|n_parent
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|n
operator|->
name|n_parent
operator|->
name|n_children
argument_list|,
name|n
argument_list|,
name|n_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Move (reparent) node 'n' to make it sibling of 'previous', placed  * just after it.  */
end_comment

begin_function
specifier|static
name|void
name|node_move_after
parameter_list|(
name|struct
name|node
modifier|*
name|n
parameter_list|,
name|struct
name|node
modifier|*
name|previous
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|n
operator|->
name|n_parent
operator|->
name|n_children
argument_list|,
name|n
argument_list|,
name|n_next
argument_list|)
expr_stmt|;
name|n
operator|->
name|n_parent
operator|=
name|previous
operator|->
name|n_parent
expr_stmt|;
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|previous
operator|->
name|n_parent
operator|->
name|n_children
argument_list|,
name|previous
argument_list|,
name|n
argument_list|,
name|n_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|node_expand_includes
parameter_list|(
name|struct
name|node
modifier|*
name|root
parameter_list|,
name|bool
name|is_master
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|n
decl_stmt|,
modifier|*
name|n2
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|,
modifier|*
name|tmproot
decl_stmt|;
name|int
name|error
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|n
argument_list|,
argument|&root->n_children
argument_list|,
argument|n_next
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|n
operator|->
name|n_key
index|[
literal|0
index|]
operator|!=
literal|'+'
condition|)
continue|continue;
name|error
operator|=
name|access
argument_list|(
name|AUTO_INCLUDE_PATH
argument_list|,
name|F_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"directory services not configured; "
literal|"%s does not exist"
argument_list|,
name|AUTO_INCLUDE_PATH
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * "+1" to skip leading "+". 		 */
name|yyin
operator|=
name|auto_popen
argument_list|(
name|AUTO_INCLUDE_PATH
argument_list|,
name|n
operator|->
name|n_key
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|yyin
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tmproot
operator|=
name|node_new_root
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_master
condition|)
name|parse_master_yyin
argument_list|(
name|tmproot
argument_list|,
name|n
operator|->
name|n_key
argument_list|)
expr_stmt|;
else|else
name|parse_map_yyin
argument_list|(
name|tmproot
argument_list|,
name|n
operator|->
name|n_key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|auto_pclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"failed to handle include \"%s\""
argument_list|,
name|n
operator|->
name|n_key
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Entries to be included are now in tmproot.  We need to merge 		 * them with the rest, preserving their place and ordering. 		 */
name|TAILQ_FOREACH_REVERSE_SAFE
argument_list|(
argument|n2
argument_list|,
argument|&tmproot->n_children
argument_list|,
argument|nodehead
argument_list|,
argument|n_next
argument_list|,
argument|tmp2
argument_list|)
block|{
name|node_move_after
argument_list|(
name|n2
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|node_delete
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|node_delete
argument_list|(
name|tmproot
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|expand_ampersand
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|expanded
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|before_len
init|=
literal|0
decl_stmt|;
name|bool
name|backslashed
init|=
name|false
decl_stmt|;
name|assert
argument_list|(
name|key
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|expanded
operator|=
name|checked_strdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|string
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|backslashed
operator|==
name|false
condition|)
block|{
name|backslashed
operator|=
name|true
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|backslashed
condition|)
block|{
name|backslashed
operator|=
name|false
expr_stmt|;
continue|continue;
block|}
name|backslashed
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'&'
condition|)
continue|continue;
comment|/* 		 * The 'before_len' variable contains the number 		 * of characters before the '&'. 		 */
name|before_len
operator|=
name|i
expr_stmt|;
comment|//assert(i + 1< (int)strlen(string));
name|ret
operator|=
name|asprintf
argument_list|(
operator|&
name|expanded
argument_list|,
literal|"%.*s%s%s"
argument_list|,
name|before_len
argument_list|,
name|string
argument_list|,
name|key
argument_list|,
name|string
operator|+
name|before_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
comment|//log_debugx("\"%s\" expanded with key \"%s\" to \"%s\"",
comment|//    string, key, expanded);
comment|/* 		 * Figure out where to start searching for next variable. 		 */
name|string
operator|=
name|expanded
expr_stmt|;
name|i
operator|=
name|before_len
operator|+
name|strlen
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|backslashed
operator|=
name|false
expr_stmt|;
comment|//assert(i< (int)strlen(string));
block|}
return|return
operator|(
name|expanded
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expand "&" in n_location.  If the key is NULL, try to use  * key from map entries themselves.  Keep in mind that maps  * consist of tho levels of node structures, the key is one  * level up.  *  * Variant with NULL key is for "automount -LL".  */
end_comment

begin_function
name|void
name|node_expand_ampersand
parameter_list|(
name|struct
name|node
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|child
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|n_location
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|n_parent
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|n
operator|->
name|n_parent
operator|->
name|n_key
argument_list|,
literal|"*"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|n
operator|->
name|n_location
operator|=
name|expand_ampersand
argument_list|(
name|n
operator|->
name|n_location
argument_list|,
name|n
operator|->
name|n_parent
operator|->
name|n_key
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|n
operator|->
name|n_location
operator|=
name|expand_ampersand
argument_list|(
name|n
operator|->
name|n_location
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&n->n_children
argument_list|,
argument|n_next
argument_list|)
name|node_expand_ampersand
argument_list|(
name|child
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Expand "*" in n_key.  */
end_comment

begin_function
name|void
name|node_expand_wildcard
parameter_list|(
name|struct
name|node
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|child
decl_stmt|,
modifier|*
name|expanded
decl_stmt|;
name|assert
argument_list|(
name|key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|n
operator|->
name|n_key
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|expanded
operator|=
name|node_duplicate
argument_list|(
name|n
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expanded
operator|->
name|n_key
operator|=
name|checked_strdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|node_move_after
argument_list|(
name|expanded
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&n->n_children
argument_list|,
argument|n_next
argument_list|)
name|node_expand_wildcard
argument_list|(
name|child
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|node_expand_defined
parameter_list|(
name|struct
name|node
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|child
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cumulated_error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|n_location
operator|!=
name|NULL
condition|)
block|{
name|n
operator|->
name|n_location
operator|=
name|defined_expand
argument_list|(
name|n
operator|->
name|n_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|n_location
operator|==
name|NULL
condition|)
block|{
name|log_warnx
argument_list|(
literal|"failed to expand location for %s"
argument_list|,
name|node_path
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&n->n_children
argument_list|,
argument|n_next
argument_list|)
block|{
name|error
operator|=
name|node_expand_defined
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|cumulated_error
operator|==
literal|0
condition|)
name|cumulated_error
operator|=
name|error
expr_stmt|;
block|}
return|return
operator|(
name|cumulated_error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|node_is_direct_key
parameter_list|(
specifier|const
name|struct
name|node
modifier|*
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|->
name|n_parent
operator|!=
name|NULL
operator|&&
name|n
operator|->
name|n_parent
operator|->
name|n_parent
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|n
operator|->
name|n_key
argument_list|,
literal|"/-"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|node_is_direct_map
parameter_list|(
specifier|const
name|struct
name|node
modifier|*
name|n
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|assert
argument_list|(
name|n
operator|->
name|n_parent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|n_parent
operator|->
name|n_parent
operator|==
name|NULL
condition|)
break|break;
name|n
operator|=
name|n
operator|->
name|n_parent
expr_stmt|;
block|}
return|return
operator|(
name|node_is_direct_key
argument_list|(
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|node_has_wildcards
parameter_list|(
specifier|const
name|struct
name|node
modifier|*
name|n
parameter_list|)
block|{
specifier|const
name|struct
name|node
modifier|*
name|child
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&n->n_children
argument_list|,
argument|n_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|child
operator|->
name|n_key
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|node_expand_maps
parameter_list|(
name|struct
name|node
modifier|*
name|n
parameter_list|,
name|bool
name|indirect
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|child
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|child
argument_list|,
argument|&n->n_children
argument_list|,
argument|n_next
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|node_is_direct_map
argument_list|(
name|child
argument_list|)
condition|)
block|{
if|if
condition|(
name|indirect
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|indirect
operator|==
name|false
condition|)
continue|continue;
block|}
comment|/* 		 * This is the first-level map node; the one that contains 		 * the key and subnodes with mountpoints and actual map names. 		 */
if|if
condition|(
name|child
operator|->
name|n_map
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|indirect
condition|)
block|{
name|log_debugx
argument_list|(
literal|"map \"%s\" is an indirect map, parsing"
argument_list|,
name|child
operator|->
name|n_map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"map \"%s\" is a direct map, parsing"
argument_list|,
name|child
operator|->
name|n_map
argument_list|)
expr_stmt|;
block|}
name|parse_map
argument_list|(
name|child
argument_list|,
name|child
operator|->
name|n_map
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|node_expand_direct_maps
parameter_list|(
name|struct
name|node
modifier|*
name|n
parameter_list|)
block|{
name|node_expand_maps
argument_list|(
name|n
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|node_expand_indirect_maps
parameter_list|(
name|struct
name|node
modifier|*
name|n
parameter_list|)
block|{
name|node_expand_maps
argument_list|(
name|n
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|node_path_x
parameter_list|(
specifier|const
name|struct
name|node
modifier|*
name|n
parameter_list|,
name|char
modifier|*
name|x
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
name|n
operator|->
name|n_parent
operator|==
name|NULL
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* 	 * Return "/-" for direct maps only if we were asked for path 	 * to the "/-" node itself, not to any of its subnodes. 	 */
if|if
condition|(
name|node_is_direct_key
argument_list|(
name|n
argument_list|)
operator|&&
name|x
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|assert
argument_list|(
name|n
operator|->
name|n_key
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|path
operator|=
name|concat
argument_list|(
name|n
operator|->
name|n_key
argument_list|,
literal|'/'
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|node_path_x
argument_list|(
name|n
operator|->
name|n_parent
argument_list|,
name|path
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return full path for node, consisting of concatenated  * paths of node itself and all its parents, up to the root.  */
end_comment

begin_function
name|char
modifier|*
name|node_path
parameter_list|(
specifier|const
name|struct
name|node
modifier|*
name|n
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|path
operator|=
name|node_path_x
argument_list|(
name|n
argument_list|,
name|checked_strdup
argument_list|(
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Strip trailing slash, unless the whole path is "/". 	 */
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|path
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|node_options_x
parameter_list|(
specifier|const
name|struct
name|node
modifier|*
name|n
parameter_list|,
name|char
modifier|*
name|x
parameter_list|)
block|{
name|char
modifier|*
name|options
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return
operator|(
name|x
operator|)
return|;
name|options
operator|=
name|concat
argument_list|(
name|x
argument_list|,
literal|','
argument_list|,
name|n
operator|->
name|n_options
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|node_options_x
argument_list|(
name|n
operator|->
name|n_parent
argument_list|,
name|options
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return options for node, consisting of concatenated  * options from the node itself and all its parents,  * up to the root.  */
end_comment

begin_function
name|char
modifier|*
name|node_options
parameter_list|(
specifier|const
name|struct
name|node
modifier|*
name|n
parameter_list|)
block|{
return|return
operator|(
name|node_options_x
argument_list|(
name|n
argument_list|,
name|checked_strdup
argument_list|(
literal|""
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|node_print_indent
parameter_list|(
specifier|const
name|struct
name|node
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|cmdline_options
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
specifier|const
name|struct
name|node
modifier|*
name|child
decl_stmt|,
modifier|*
name|first_child
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|options
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|path
operator|=
name|node_path
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|node_options
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|options
operator|=
name|concat
argument_list|(
name|cmdline_options
argument_list|,
literal|','
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* 	 * Do not show both parent and child node if they have the same 	 * mountpoint; only show the child node.  This means the typical, 	 * "key location", map entries are shown in a single line; 	 * the "key mountpoint1 location2 mountpoint2 location2" entries 	 * take multiple lines. 	 */
name|first_child
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|n
operator|->
name|n_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_child
operator|==
name|NULL
operator|||
name|TAILQ_NEXT
argument_list|(
name|first_child
argument_list|,
name|n_next
argument_list|)
operator|!=
name|NULL
operator|||
name|strcmp
argument_list|(
name|path
argument_list|,
name|node_path
argument_list|(
name|first_child
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|n
operator|->
name|n_location
operator|==
name|NULL
operator|||
name|n
operator|->
name|n_map
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%*.s%-*s %s%-*s %-*s # %s map %s at %s:%d\n"
argument_list|,
name|indent
argument_list|,
literal|""
argument_list|,
literal|25
operator|-
name|indent
argument_list|,
name|path
argument_list|,
name|options
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
literal|"-"
else|:
literal|" "
argument_list|,
literal|20
argument_list|,
name|options
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|options
else|:
literal|""
argument_list|,
literal|20
argument_list|,
name|n
operator|->
name|n_location
operator|!=
name|NULL
condition|?
name|n
operator|->
name|n_location
else|:
name|n
operator|->
name|n_map
operator|!=
name|NULL
condition|?
name|n
operator|->
name|n_map
else|:
literal|""
argument_list|,
name|node_is_direct_map
argument_list|(
name|n
argument_list|)
condition|?
literal|"direct"
else|:
literal|"indirect"
argument_list|,
name|indent
operator|==
literal|0
condition|?
literal|"referenced"
else|:
literal|"defined"
argument_list|,
name|n
operator|->
name|n_config_file
argument_list|,
name|n
operator|->
name|n_config_line
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&n->n_children
argument_list|,
argument|n_next
argument_list|)
name|node_print_indent
argument_list|(
name|child
argument_list|,
name|cmdline_options
argument_list|,
name|indent
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Recursively print node with all its children.  The cmdline_options  * argument is used for additional options to be prepended to all the  * others - usually those are the options passed by command line.  */
end_comment

begin_function
name|void
name|node_print
parameter_list|(
specifier|const
name|struct
name|node
modifier|*
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|cmdline_options
parameter_list|)
block|{
specifier|const
name|struct
name|node
modifier|*
name|child
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&n->n_children
argument_list|,
argument|n_next
argument_list|)
name|node_print_indent
argument_list|(
name|child
argument_list|,
name|cmdline_options
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|node
modifier|*
name|node_find_x
parameter_list|(
name|struct
name|node
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|child
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|size_t
name|tmplen
decl_stmt|;
comment|//log_debugx("looking up %s in %s", path, node_path(node));
if|if
condition|(
operator|!
name|node_is_direct_key
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|node_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|tmplen
operator|=
name|strlen
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tmp
argument_list|,
name|path
argument_list|,
name|tmplen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|path
index|[
name|tmplen
index|]
operator|!=
literal|'/'
operator|&&
name|path
index|[
name|tmplen
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* 			 * If we have two map entries like 'foo' and 'foobar', make 			 * sure the search for 'foobar' won't match 'foo' instead. 			 */
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&node->n_children
argument_list|,
argument|n_next
argument_list|)
block|{
name|found
operator|=
name|node_find_x
argument_list|(
name|child
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
return|return
operator|(
name|found
operator|)
return|;
block|}
if|if
condition|(
name|node
operator|->
name|n_parent
operator|==
name|NULL
operator|||
name|node_is_direct_key
argument_list|(
name|node
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|node
modifier|*
name|node_find
parameter_list|(
name|struct
name|node
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|node
modifier|*
name|node
decl_stmt|;
name|assert
argument_list|(
name|root
operator|->
name|n_parent
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|node
operator|=
name|node_find_x
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|assert
argument_list|(
name|node
operator|!=
name|root
argument_list|)
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Canonical form of a map entry looks like this:  *  * key [-options] [ [/mountpoint] [-options2] location ... ]  *  * Entries for executable maps are slightly different, as they  * lack the 'key' field and are always single-line; the key field  * for those maps is taken from 'executable_key' argument.  *  * We parse it in such a way that a map always has two levels - first  * for key, and the second, for the mountpoint.  */
end_comment

begin_function
specifier|static
name|void
name|parse_map_yyin
parameter_list|(
name|struct
name|node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|executable_key
parameter_list|)
block|{
name|char
modifier|*
name|key
init|=
name|NULL
decl_stmt|,
modifier|*
name|options
init|=
name|NULL
decl_stmt|,
modifier|*
name|mountpoint
init|=
name|NULL
decl_stmt|,
modifier|*
name|options2
init|=
name|NULL
decl_stmt|,
modifier|*
name|location
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|node
modifier|*
name|node
decl_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|executable_key
operator|!=
name|NULL
condition|)
name|key
operator|=
name|checked_strdup
argument_list|(
name|executable_key
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ret
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|ret
operator|==
name|NEWLINE
condition|)
block|{
comment|/* 			 * In case of executable map, the key is always 			 * non-NULL, even if the map is empty.  So, make sure 			 * we don't fail empty maps here. 			 */
if|if
condition|(
operator|(
name|key
operator|!=
name|NULL
operator|&&
name|executable_key
operator|==
name|NULL
operator|)
operator|||
name|options
operator|!=
name|NULL
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"truncated entry at %s, line %d"
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|executable_key
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * End of file. 				 */
break|break;
block|}
else|else
block|{
name|key
operator|=
name|options
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|key
operator|=
name|checked_strdup
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|==
literal|'+'
condition|)
block|{
name|node_new
argument_list|(
name|parent
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|key
operator|=
name|options
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|yytext
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|options
operator|!=
name|NULL
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"duplicated options at %s, line %d"
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * +1 to skip leading "-". 			 */
name|options
operator|=
name|checked_strdup
argument_list|(
name|yytext
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We cannot properly handle a situation where the map key 		 * is "/".  Ignore such entries. 		 * 		 * XXX: According to Piete Brooks, Linux automounter uses 		 *	"/" as a wildcard character in LDAP maps.  Perhaps 		 *	we should work around this braindamage by substituting 		 *	"*" for "/"? 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|log_warnx
argument_list|(
literal|"nonsensical map key \"/\" at %s, line %d; "
literal|"ignoring map entry "
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* 			 * Skip the rest of the entry. 			 */
do|do
block|{
name|ret
operator|=
name|yylex
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|!=
literal|0
operator|&&
name|ret
operator|!=
name|NEWLINE
condition|)
do|;
name|key
operator|=
name|options
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|//log_debugx("adding map node, %s", key);
name|node
operator|=
name|node_new
argument_list|(
name|parent
argument_list|,
name|key
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|key
operator|=
name|options
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|yytext
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|mountpoint
operator|!=
name|NULL
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"duplicated mountpoint "
literal|"in %s, line %d"
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options2
operator|!=
name|NULL
operator|||
name|location
operator|!=
name|NULL
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"mountpoint out of order "
literal|"in %s, line %d"
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
name|mountpoint
operator|=
name|checked_strdup
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|yytext
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|options2
operator|!=
name|NULL
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"duplicated options "
literal|"in %s, line %d"
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|location
operator|!=
name|NULL
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"options out of order "
literal|"in %s, line %d"
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
name|options2
operator|=
name|checked_strdup
argument_list|(
name|yytext
operator|+
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|location
operator|!=
name|NULL
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"too many arguments "
literal|"in %s, line %d"
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If location field starts with colon, e.g. ":/dev/cd0", 			 * then strip it. 			 */
if|if
condition|(
name|yytext
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
name|location
operator|=
name|checked_strdup
argument_list|(
name|yytext
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|location
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"empty location in %s, "
literal|"line %d"
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|location
operator|=
name|checked_strdup
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mountpoint
operator|==
name|NULL
condition|)
name|mountpoint
operator|=
name|checked_strdup
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|options2
operator|==
name|NULL
condition|)
name|options2
operator|=
name|checked_strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|log_debugx("adding map node, %s %s %s", 			    mountpoint, options2, location);
endif|#
directive|endif
name|node_new
argument_list|(
name|node
argument_list|,
name|mountpoint
argument_list|,
name|options2
argument_list|,
name|location
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|mountpoint
operator|=
name|options2
operator|=
name|location
operator|=
name|NULL
expr_stmt|;
name|again
label|:
name|ret
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|ret
operator|==
name|NEWLINE
condition|)
block|{
if|if
condition|(
name|mountpoint
operator|!=
name|NULL
operator|||
name|options2
operator|!=
name|NULL
operator|||
name|location
operator|!=
name|NULL
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"truncated entry "
literal|"in %s, line %d"
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Parse output of a special map called without argument.  It is a list  * of keys, separated by newlines.  They can contain whitespace, so use  * getline(3) instead of lexer used for maps.  */
end_comment

begin_function
specifier|static
name|void
name|parse_map_keys_yyin
parameter_list|(
name|struct
name|node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|)
block|{
name|char
modifier|*
name|line
init|=
name|NULL
decl_stmt|,
modifier|*
name|key
decl_stmt|;
name|size_t
name|linecap
init|=
literal|0
decl_stmt|;
name|ssize_t
name|linelen
decl_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|linelen
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|linecap
argument_list|,
name|yyin
argument_list|)
expr_stmt|;
if|if
condition|(
name|linelen
operator|<
literal|0
condition|)
block|{
comment|/* 			 * End of file. 			 */
break|break;
block|}
if|if
condition|(
name|linelen
operator|<=
literal|1
condition|)
block|{
comment|/* 			 * Empty line, consisting of just the newline. 			 */
continue|continue;
block|}
comment|/* 		 * "-1" to strip the trailing newline. 		 */
name|key
operator|=
name|strndup
argument_list|(
name|line
argument_list|,
name|linelen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|log_debugx
argument_list|(
literal|"adding key \"%s\""
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|node_new
argument_list|(
name|parent
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|map
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|file_is_executable
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"cannot stat %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IXUSR
operator|)
operator|||
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IXGRP
operator|)
operator|||
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IXOTH
operator|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a special map, e.g. "-hosts".  */
end_comment

begin_function
specifier|static
name|void
name|parse_special_map
parameter_list|(
name|struct
name|node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|;
name|assert
argument_list|(
name|map
index|[
literal|0
index|]
operator|==
literal|'-'
argument_list|)
expr_stmt|;
comment|/* 	 * +1 to skip leading "-" in map name. 	 */
name|ret
operator|=
name|asprintf
argument_list|(
operator|&
name|path
argument_list|,
literal|"%s/special_%s"
argument_list|,
name|AUTO_SPECIAL_PREFIX
argument_list|,
name|map
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|auto_popen
argument_list|(
name|path
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|yyin
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|parse_map_keys_yyin
argument_list|(
name|parent
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_map_yyin
argument_list|(
name|parent
argument_list|,
name|map
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|auto_pclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"failed to handle special map \"%s\""
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|node_expand_includes
argument_list|(
name|parent
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|node_expand_direct_maps
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve and parse map from directory services, e.g. LDAP.  * Note that it is different from executable maps, in that  * the include script outputs the whole map to standard output  * (as opposed to executable maps that only output a single  * entry, without the key), and it takes the map name as an  * argument, instead of key.  */
end_comment

begin_function
specifier|static
name|void
name|parse_included_map
parameter_list|(
name|struct
name|node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|assert
argument_list|(
name|map
index|[
literal|0
index|]
operator|!=
literal|'-'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|map
index|[
literal|0
index|]
operator|!=
literal|'/'
argument_list|)
expr_stmt|;
name|error
operator|=
name|access
argument_list|(
name|AUTO_INCLUDE_PATH
argument_list|,
name|F_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"directory services not configured;"
literal|" %s does not exist"
argument_list|,
name|AUTO_INCLUDE_PATH
argument_list|)
expr_stmt|;
block|}
name|yyin
operator|=
name|auto_popen
argument_list|(
name|AUTO_INCLUDE_PATH
argument_list|,
name|map
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|yyin
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|parse_map_yyin
argument_list|(
name|parent
argument_list|,
name|map
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|auto_pclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"failed to handle remote map \"%s\""
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|node_expand_includes
argument_list|(
name|parent
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|node_expand_direct_maps
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|parse_map
parameter_list|(
name|struct
name|node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|map
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|bool
modifier|*
name|wildcards
parameter_list|)
block|{
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|;
name|bool
name|executable
decl_stmt|;
name|assert
argument_list|(
name|map
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|map
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|log_debugx
argument_list|(
literal|"parsing map \"%s\""
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|wildcards
operator|!=
name|NULL
condition|)
operator|*
name|wildcards
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|map
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|wildcards
operator|!=
name|NULL
condition|)
operator|*
name|wildcards
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|parse_special_map
argument_list|(
name|parent
argument_list|,
name|map
argument_list|,
name|key
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|map
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|path
operator|=
name|checked_strdup
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|asprintf
argument_list|(
operator|&
name|path
argument_list|,
literal|"%s/%s"
argument_list|,
name|AUTO_MAP_PREFIX
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|log_debugx
argument_list|(
literal|"map \"%s\" maps to \"%s\""
argument_list|,
name|map
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* 		 * See if the file exists.  If not, try to obtain the map 		 * from directory services. 		 */
name|error
operator|=
name|access
argument_list|(
name|path
argument_list|,
name|F_OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|log_debugx
argument_list|(
literal|"map file \"%s\" does not exist; falling "
literal|"back to directory services"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|parse_included_map
argument_list|(
name|parent
argument_list|,
name|map
argument_list|)
operator|)
return|;
block|}
block|}
name|executable
operator|=
name|file_is_executable
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|executable
condition|)
block|{
name|log_debugx
argument_list|(
literal|"map \"%s\" is executable"
argument_list|,
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|wildcards
operator|!=
name|NULL
condition|)
operator|*
name|wildcards
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
name|yyin
operator|=
name|auto_popen
argument_list|(
name|path
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yyin
operator|=
name|auto_popen
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|yyin
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|yyin
operator|=
name|fopen
argument_list|(
name|path
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyin
operator|==
name|NULL
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"unable to open \"%s\""
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
name|parse_map_yyin
argument_list|(
name|parent
argument_list|,
name|map
argument_list|,
name|executable
condition|?
name|key
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|executable
condition|)
block|{
name|error
operator|=
name|auto_pclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"failed to handle executable map \"%s\""
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
block|}
name|yyin
operator|=
name|NULL
expr_stmt|;
name|log_debugx
argument_list|(
literal|"done parsing map \"%s\""
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|node_expand_includes
argument_list|(
name|parent
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|node_expand_direct_maps
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_master_yyin
parameter_list|(
name|struct
name|node
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|master
parameter_list|)
block|{
name|char
modifier|*
name|mountpoint
init|=
name|NULL
decl_stmt|,
modifier|*
name|map
init|=
name|NULL
decl_stmt|,
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * XXX: 1 gives incorrect values; wtf? 	 */
name|lineno
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ret
operator|=
name|yylex
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|ret
operator|==
name|NEWLINE
condition|)
block|{
if|if
condition|(
name|mountpoint
operator|!=
name|NULL
condition|)
block|{
comment|//log_debugx("adding map for %s", mountpoint);
name|node_new_map
argument_list|(
name|root
argument_list|,
name|mountpoint
argument_list|,
name|options
argument_list|,
name|map
argument_list|,
name|master
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
break|break;
block|}
else|else
block|{
name|mountpoint
operator|=
name|map
operator|=
name|options
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|mountpoint
operator|==
name|NULL
condition|)
block|{
name|mountpoint
operator|=
name|checked_strdup
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
name|map
operator|=
name|checked_strdup
argument_list|(
name|yytext
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|options
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * +1 to skip leading "-". 			 */
name|options
operator|=
name|checked_strdup
argument_list|(
name|yytext
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"too many arguments at %s, line %d"
argument_list|,
name|master
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|parse_master
parameter_list|(
name|struct
name|node
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|master
parameter_list|)
block|{
name|log_debugx
argument_list|(
literal|"parsing auto_master file at \"%s\""
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|fopen
argument_list|(
name|master
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyin
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to open %s"
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|parse_master_yyin
argument_list|(
name|root
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|yyin
argument_list|)
expr_stmt|;
name|yyin
operator|=
name|NULL
expr_stmt|;
name|log_debugx
argument_list|(
literal|"done parsing \"%s\""
argument_list|,
name|master
argument_list|)
expr_stmt|;
name|node_expand_includes
argument_list|(
name|root
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|node_expand_direct_maps
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Two things daemon(3) does, that we actually also want to do  * when running in foreground, is closing the stdin and chdiring  * to "/".  This is what we do here.  */
end_comment

begin_function
name|void
name|lesser_daemon
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|;
name|error
operator|=
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|log_warn
argument_list|(
literal|"chdir"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|_PATH_DEVNULL
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|log_warn
argument_list|(
literal|"cannot open %s"
argument_list|,
name|_PATH_DEVNULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|log_warn
argument_list|(
literal|"dup2"
argument_list|)
expr_stmt|;
name|error
operator|=
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Bloody hell. */
name|log_warn
argument_list|(
literal|"close"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|cmdname
decl_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"NULL command name"
argument_list|)
expr_stmt|;
name|cmdname
operator|=
name|basename
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"automount"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|main_automount
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"automountd"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|main_automountd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmdname
argument_list|,
literal|"autounmountd"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|main_autounmountd
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
else|else
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"binary name should be either \"automount\", "
literal|"\"automountd\", or \"autounmountd\""
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

