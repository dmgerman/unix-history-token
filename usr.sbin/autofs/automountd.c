begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Edward Tomasz Napierala under sponsorship  * from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"autofs_ioctl.h"
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_define
define|#
directive|define
name|AUTOMOUNTD_PIDFILE
value|"/var/run/automountd.pid"
end_define

begin_decl_stmt
specifier|static
name|int
name|nchildren
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|autofs_fd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|request_id
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|done
parameter_list|(
name|int
name|request_error
parameter_list|,
name|bool
name|wildcards
parameter_list|)
block|{
name|struct
name|autofs_daemon_done
name|add
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|add
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|add
argument_list|)
argument_list|)
expr_stmt|;
name|add
operator|.
name|add_id
operator|=
name|request_id
expr_stmt|;
name|add
operator|.
name|add_wildcards
operator|=
name|wildcards
expr_stmt|;
name|add
operator|.
name|add_error
operator|=
name|request_error
expr_stmt|;
name|log_debugx
argument_list|(
literal|"completing request %d with error %d"
argument_list|,
name|request_id
argument_list|,
name|request_error
argument_list|)
expr_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|autofs_fd
argument_list|,
name|AUTOFSDONE
argument_list|,
operator|&
name|add
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|log_warn
argument_list|(
literal|"AUTOFSDONE"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove "fstype=whatever" from optionsp and return the "whatever" part.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|pick_option
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|char
modifier|*
modifier|*
name|optionsp
parameter_list|)
block|{
name|char
modifier|*
name|tofree
decl_stmt|,
modifier|*
name|pair
decl_stmt|,
modifier|*
name|newoptions
decl_stmt|;
name|char
modifier|*
name|picked
init|=
name|NULL
decl_stmt|;
name|bool
name|first
init|=
name|true
decl_stmt|;
name|tofree
operator|=
operator|*
name|optionsp
expr_stmt|;
name|newoptions
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|strlen
argument_list|(
operator|*
name|optionsp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newoptions
operator|==
name|NULL
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pair
operator|=
name|strsep
argument_list|(
name|optionsp
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * XXX: strncasecmp(3) perhaps? 		 */
if|if
condition|(
name|strncmp
argument_list|(
name|pair
argument_list|,
name|option
argument_list|,
name|strlen
argument_list|(
name|option
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|picked
operator|=
name|checked_strdup
argument_list|(
name|pair
operator|+
name|strlen
argument_list|(
name|option
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|first
operator|==
name|false
condition|)
name|strcat
argument_list|(
name|newoptions
argument_list|,
literal|","
argument_list|)
expr_stmt|;
else|else
name|first
operator|=
name|false
expr_stmt|;
name|strcat
argument_list|(
name|newoptions
argument_list|,
name|pair
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
operator|*
name|optionsp
operator|=
name|newoptions
expr_stmt|;
return|return
operator|(
name|picked
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_subtree
parameter_list|(
specifier|const
name|struct
name|node
modifier|*
name|node
parameter_list|,
name|bool
name|incomplete
parameter_list|)
block|{
specifier|const
name|struct
name|node
modifier|*
name|child
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|bool
name|wildcard_found
init|=
name|false
decl_stmt|;
comment|/* 	 * Skip wildcard nodes. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|node
operator|->
name|n_key
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|path
operator|=
name|node_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|log_debugx
argument_list|(
literal|"creating subtree at %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|create_directory
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|incomplete
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&node->n_children
argument_list|,
argument|n_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|child
operator|->
name|n_key
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wildcard_found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|wildcard_found
condition|)
block|{
name|log_debugx
argument_list|(
literal|"node %s contains wildcard entry; "
literal|"not creating its subdirectories due to -d flag"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&node->n_children
argument_list|,
argument|n_next
argument_list|)
name|create_subtree
argument_list|(
name|child
argument_list|,
name|incomplete
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|exit_callback
parameter_list|(
name|void
parameter_list|)
block|{
name|done
argument_list|(
name|EIO
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_request
parameter_list|(
specifier|const
name|struct
name|autofs_daemon_request
modifier|*
name|adr
parameter_list|,
name|char
modifier|*
name|cmdline_options
parameter_list|,
name|bool
name|incomplete_hierarchy
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|map
decl_stmt|;
name|struct
name|node
modifier|*
name|root
decl_stmt|,
modifier|*
name|parent
decl_stmt|,
modifier|*
name|node
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|options
decl_stmt|,
modifier|*
name|fstype
decl_stmt|,
modifier|*
name|nobrowse
decl_stmt|,
modifier|*
name|retrycnt
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bool
name|wildcards
decl_stmt|;
name|log_debugx
argument_list|(
literal|"got request %d: from %s, path %s, prefix \"%s\", "
literal|"key \"%s\", options \"%s\""
argument_list|,
name|adr
operator|->
name|adr_id
argument_list|,
name|adr
operator|->
name|adr_from
argument_list|,
name|adr
operator|->
name|adr_path
argument_list|,
name|adr
operator|->
name|adr_prefix
argument_list|,
name|adr
operator|->
name|adr_key
argument_list|,
name|adr
operator|->
name|adr_options
argument_list|)
expr_stmt|;
comment|/* 	 * Try to notify the kernel about any problems. 	 */
name|request_id
operator|=
name|adr
operator|->
name|adr_id
expr_stmt|;
name|atexit
argument_list|(
name|exit_callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|adr
operator|->
name|adr_from
argument_list|,
literal|"map "
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"invalid mountfrom \"%s\"; failing request"
argument_list|,
name|adr
operator|->
name|adr_from
argument_list|)
expr_stmt|;
block|}
name|map
operator|=
name|adr
operator|->
name|adr_from
operator|+
literal|4
expr_stmt|;
comment|/* 4 for strlen("map "); */
name|root
operator|=
name|node_new_root
argument_list|()
expr_stmt|;
if|if
condition|(
name|adr
operator|->
name|adr_prefix
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|adr
operator|->
name|adr_prefix
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Direct map.  autofs(4) doesn't have a way to determine 		 * correct map key, but since it's a direct map, we can just 		 * use adr_path instead. 		 */
name|parent
operator|=
name|root
expr_stmt|;
name|key
operator|=
name|checked_strdup
argument_list|(
name|adr
operator|->
name|adr_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Indirect map. 		 */
name|parent
operator|=
name|node_new_map
argument_list|(
name|root
argument_list|,
name|checked_strdup
argument_list|(
name|adr
operator|->
name|adr_prefix
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|checked_strdup
argument_list|(
name|map
argument_list|)
argument_list|,
name|checked_strdup
argument_list|(
literal|"[kernel request]"
argument_list|)
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|adr
operator|->
name|adr_key
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|key
operator|=
name|NULL
expr_stmt|;
else|else
name|key
operator|=
name|checked_strdup
argument_list|(
name|adr
operator|->
name|adr_key
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * "Wildcards" here actually means "make autofs(4) request 	 * automountd(8) action if the node being looked up does not 	 * exist, even though the parent is marked as cached".  This 	 * needs to be done for maps with wildcard entries, but also 	 * for special and executable maps. 	 */
name|parse_map
argument_list|(
name|parent
argument_list|,
name|map
argument_list|,
name|key
argument_list|,
operator|&
name|wildcards
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wildcards
condition|)
name|wildcards
operator|=
name|node_has_wildcards
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|wildcards
condition|)
name|log_debugx
argument_list|(
literal|"map may contain wildcard entries"
argument_list|)
expr_stmt|;
else|else
name|log_debugx
argument_list|(
literal|"map does not contain wildcard entries"
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
name|node_expand_wildcard
argument_list|(
name|root
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|node
operator|=
name|node_find
argument_list|(
name|root
argument_list|,
name|adr
operator|->
name|adr_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"map %s does not contain key for \"%s\"; "
literal|"failing mount"
argument_list|,
name|map
argument_list|,
name|adr
operator|->
name|adr_path
argument_list|)
expr_stmt|;
block|}
name|options
operator|=
name|node_options
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* 	 * Append options from auto_master. 	 */
name|options
operator|=
name|concat
argument_list|(
name|options
argument_list|,
literal|','
argument_list|,
name|adr
operator|->
name|adr_options
argument_list|)
expr_stmt|;
comment|/* 	 * Prepend options passed via automountd(8) command line. 	 */
name|options
operator|=
name|concat
argument_list|(
name|cmdline_options
argument_list|,
literal|','
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|n_location
operator|==
name|NULL
condition|)
block|{
name|log_debugx
argument_list|(
literal|"found node defined at %s:%d; not a mountpoint"
argument_list|,
name|node
operator|->
name|n_config_file
argument_list|,
name|node
operator|->
name|n_config_line
argument_list|)
expr_stmt|;
name|nobrowse
operator|=
name|pick_option
argument_list|(
literal|"nobrowse"
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|nobrowse
operator|!=
name|NULL
operator|&&
name|key
operator|==
name|NULL
condition|)
block|{
name|log_debugx
argument_list|(
literal|"skipping map %s due to \"nobrowse\" "
literal|"option; exiting"
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|0
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* 			 * Exit without calling exit_callback(). 			 */
name|quick_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Not a mountpoint; create directories in the autofs mount 		 * and complete the request. 		 */
name|create_subtree
argument_list|(
name|node
argument_list|,
name|incomplete_hierarchy
argument_list|)
expr_stmt|;
if|if
condition|(
name|incomplete_hierarchy
operator|&&
name|key
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We still need to create the single subdirectory 			 * user is trying to access. 			 */
name|tmp
operator|=
name|concat
argument_list|(
name|adr
operator|->
name|adr_path
argument_list|,
literal|'/'
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|node
operator|=
name|node_find
argument_list|(
name|root
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
name|create_subtree
argument_list|(
name|node
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|log_debugx
argument_list|(
literal|"nothing to mount; exiting"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|0
argument_list|,
name|wildcards
argument_list|)
expr_stmt|;
comment|/* 		 * Exit without calling exit_callback(). 		 */
name|quick_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|log_debugx
argument_list|(
literal|"found node defined at %s:%d; it is a mountpoint"
argument_list|,
name|node
operator|->
name|n_config_file
argument_list|,
name|node
operator|->
name|n_config_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
name|node_expand_ampersand
argument_list|(
name|node
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|error
operator|=
name|node_expand_defined
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"variable expansion failed for %s; "
literal|"failing mount"
argument_list|,
name|adr
operator|->
name|adr_path
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Append "automounted". 	 */
name|options
operator|=
name|concat
argument_list|(
name|options
argument_list|,
literal|','
argument_list|,
literal|"automounted"
argument_list|)
expr_stmt|;
comment|/* 	 * Remove "nobrowse", mount(8) doesn't understand it. 	 */
name|pick_option
argument_list|(
literal|"nobrowse"
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
comment|/* 	 * Figure out fstype. 	 */
name|fstype
operator|=
name|pick_option
argument_list|(
literal|"fstype="
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstype
operator|==
name|NULL
condition|)
block|{
name|log_debugx
argument_list|(
literal|"fstype not specified in options; "
literal|"defaulting to \"nfs\""
argument_list|)
expr_stmt|;
name|fstype
operator|=
name|checked_strdup
argument_list|(
literal|"nfs"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|fstype
argument_list|,
literal|"nfs"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The mount_nfs(8) command defaults to retry undefinitely. 		 * We do not want that behaviour, because it leaves mount_nfs(8) 		 * instances and automountd(8) children hanging forever. 		 * Disable retries unless the option was passed explicitly. 		 */
name|retrycnt
operator|=
name|pick_option
argument_list|(
literal|"retrycnt="
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|retrycnt
operator|==
name|NULL
condition|)
block|{
name|log_debugx
argument_list|(
literal|"retrycnt not specified in options; "
literal|"defaulting to 1"
argument_list|)
expr_stmt|;
name|options
operator|=
name|concat
argument_list|(
name|options
argument_list|,
literal|','
argument_list|,
literal|"retrycnt=1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|options
operator|=
name|concat
argument_list|(
name|options
argument_list|,
literal|','
argument_list|,
name|concat
argument_list|(
literal|"retrycnt"
argument_list|,
literal|'='
argument_list|,
name|retrycnt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|f
operator|=
name|auto_popen
argument_list|(
literal|"mount"
argument_list|,
literal|"-t"
argument_list|,
name|fstype
argument_list|,
literal|"-o"
argument_list|,
name|options
argument_list|,
name|node
operator|->
name|n_location
argument_list|,
name|adr
operator|->
name|adr_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|f
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|auto_pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"mount failed"
argument_list|)
expr_stmt|;
name|log_debugx
argument_list|(
literal|"mount done; exiting"
argument_list|)
expr_stmt|;
name|done
argument_list|(
literal|0
argument_list|,
name|wildcards
argument_list|)
expr_stmt|;
comment|/* 	 * Exit without calling exit_callback(). 	 */
name|quick_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sigchld_handler
parameter_list|(
name|int
name|dummy
name|__unused
parameter_list|)
block|{
comment|/* 	 * The only purpose of this handler is to make SIGCHLD 	 * interrupt the AUTOFSREQUEST ioctl(2), so we can call 	 * wait_for_children(). 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|register_sigchld
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sigaction
name|sa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|sigchld_handler
expr_stmt|;
name|sigfillset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|error
operator|=
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"sigaction"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wait_for_children
parameter_list|(
name|bool
name|block
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If "block" is true, wait for at least one process. 		 */
if|if
condition|(
name|block
operator|&&
name|num
operator|==
literal|0
condition|)
name|pid
operator|=
name|wait4
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|pid
operator|=
name|wait4
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|log_warnx
argument_list|(
literal|"child process %d terminated with signal %d"
argument_list|,
name|pid
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_debugx
argument_list|(
literal|"child process %d terminated with exit status %d"
argument_list|,
name|pid
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"child process %d terminated gracefully"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
name|num
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|num
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage_automountd
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: automountd [-D name=value][-m maxproc]"
literal|"[-o opts][-Tidv]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main_automountd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|pidfh
modifier|*
name|pidfh
decl_stmt|;
name|pid_t
name|pid
decl_stmt|,
name|otherpid
decl_stmt|;
specifier|const
name|char
modifier|*
name|pidfile_path
init|=
name|AUTOMOUNTD_PIDFILE
decl_stmt|;
name|char
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
name|struct
name|autofs_daemon_request
name|request
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|debug
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|,
name|maxproc
init|=
literal|30
decl_stmt|,
name|retval
decl_stmt|,
name|saved_errno
decl_stmt|;
name|bool
name|dont_daemonize
init|=
name|false
decl_stmt|,
name|incomplete_hierarchy
init|=
name|false
decl_stmt|;
name|defined_init
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"D:Tdim:o:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'D'
case|:
name|defined_parse_and_add
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* 			 * For compatibility with other implementations, 			 * such as OS X. 			 */
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dont_daemonize
operator|=
name|true
expr_stmt|;
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|incomplete_hierarchy
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|maxproc
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|options
operator|=
name|concat
argument_list|(
name|options
argument_list|,
literal|','
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage_automountd
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|0
condition|)
name|usage_automountd
argument_list|()
expr_stmt|;
name|log_init
argument_list|(
name|debug
argument_list|)
expr_stmt|;
name|pidfh
operator|=
name|pidfile_open
argument_list|(
name|pidfile_path
argument_list|,
literal|0600
argument_list|,
operator|&
name|otherpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidfh
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
block|{
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"daemon already running, pid: %jd."
argument_list|,
operator|(
name|intmax_t
operator|)
name|otherpid
argument_list|)
expr_stmt|;
block|}
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"cannot open or create pidfile \"%s\""
argument_list|,
name|pidfile_path
argument_list|)
expr_stmt|;
block|}
name|autofs_fd
operator|=
name|open
argument_list|(
name|AUTOFS_PATH
argument_list|,
name|O_RDWR
operator||
name|O_CLOEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|autofs_fd
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
name|retval
operator|=
name|kldload
argument_list|(
literal|"autofs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
operator|-
literal|1
condition|)
name|autofs_fd
operator|=
name|open
argument_list|(
name|AUTOFS_PATH
argument_list|,
name|O_RDWR
operator||
name|O_CLOEXEC
argument_list|)
expr_stmt|;
else|else
name|errno
operator|=
name|saved_errno
expr_stmt|;
block|}
if|if
condition|(
name|autofs_fd
operator|<
literal|0
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"failed to open %s"
argument_list|,
name|AUTOFS_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|dont_daemonize
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_warn
argument_list|(
literal|"cannot daemonize"
argument_list|)
expr_stmt|;
name|pidfile_remove
argument_list|(
name|pidfh
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lesser_daemon
argument_list|()
expr_stmt|;
block|}
name|pidfile_write
argument_list|(
name|pidfh
argument_list|)
expr_stmt|;
name|register_sigchld
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|log_debugx
argument_list|(
literal|"waiting for request from the kernel"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|request
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ioctl
argument_list|(
name|autofs_fd
argument_list|,
name|AUTOFSREQUEST
argument_list|,
operator|&
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|nchildren
operator|-=
name|wait_for_children
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nchildren
operator|>=
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"AUTOFSREQUEST"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dont_daemonize
condition|)
block|{
name|log_debugx
argument_list|(
literal|"not forking due to -d flag; "
literal|"will exit after servicing a single request"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nchildren
operator|-=
name|wait_for_children
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nchildren
operator|>=
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|maxproc
operator|>
literal|0
operator|&&
name|nchildren
operator|>=
name|maxproc
condition|)
block|{
name|log_debugx
argument_list|(
literal|"maxproc limit of %d child processes hit; "
literal|"waiting for child process to exit"
argument_list|,
name|maxproc
argument_list|)
expr_stmt|;
name|nchildren
operator|-=
name|wait_for_children
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|nchildren
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
name|log_debugx
argument_list|(
literal|"got request; forking child process #%d"
argument_list|,
name|nchildren
argument_list|)
expr_stmt|;
name|nchildren
operator|++
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
continue|continue;
block|}
name|pidfile_close
argument_list|(
name|pidfh
argument_list|)
expr_stmt|;
name|handle_request
argument_list|(
operator|&
name|request
argument_list|,
name|options
argument_list|,
name|incomplete_hierarchy
argument_list|)
expr_stmt|;
block|}
name|pidfile_close
argument_list|(
name|pidfh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

