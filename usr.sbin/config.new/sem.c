begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratories.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)sem.c	8.1 (Berkeley) 6/6/93  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"sem.h"
end_include

begin_comment
comment|/*  * config semantics.  */
end_comment

begin_define
define|#
directive|define
name|NAMESIZE
value|100
end_define

begin_comment
comment|/* local name buffers */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s_generic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|s_qmark
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|hashtab
modifier|*
name|attrtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for attribute lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hashtab
modifier|*
name|cfhashtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for config lookup */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hashtab
modifier|*
name|devitab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* etc */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|attr
name|errattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|devbase
name|errdev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|devbase
modifier|*
modifier|*
name|nextbase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|config
modifier|*
modifier|*
name|nextcf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|devi
modifier|*
modifier|*
name|nextdevi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|devi
modifier|*
modifier|*
name|nextpseudo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|has_errobj
name|__P
argument_list|(
operator|(
expr|struct
name|nvlist
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nvlist
modifier|*
name|addtoattr
name|__P
argument_list|(
operator|(
expr|struct
name|nvlist
operator|*
operator|,
expr|struct
name|devbase
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exclude
name|__P
argument_list|(
operator|(
expr|struct
name|nvlist
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|resolve
name|__P
argument_list|(
operator|(
expr|struct
name|nvlist
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|nvlist
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lresolve
name|__P
argument_list|(
operator|(
expr|struct
name|nvlist
operator|*
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|nvlist
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|devi
modifier|*
name|newdevi
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|devbase
operator|*
name|d
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|devi
modifier|*
name|getdevi
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|concat
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|split
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|size_t
operator|,
name|char
operator|*
operator|,
name|size_t
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|selectbase
name|__P
argument_list|(
operator|(
expr|struct
name|devbase
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|onlist
name|__P
argument_list|(
operator|(
expr|struct
name|nvlist
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|fixloc
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|attr
operator|*
operator|,
expr|struct
name|nvlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|initsem
parameter_list|()
block|{
name|attrtab
operator|=
name|ht_new
argument_list|()
expr_stmt|;
name|errattr
operator|.
name|a_name
operator|=
literal|"<internal>"
expr_stmt|;
name|allbases
operator|=
name|NULL
expr_stmt|;
name|nextbase
operator|=
operator|&
name|allbases
expr_stmt|;
name|cfhashtab
operator|=
name|ht_new
argument_list|()
expr_stmt|;
name|allcf
operator|=
name|NULL
expr_stmt|;
name|nextcf
operator|=
operator|&
name|allcf
expr_stmt|;
name|devitab
operator|=
name|ht_new
argument_list|()
expr_stmt|;
name|alldevi
operator|=
name|NULL
expr_stmt|;
name|nextdevi
operator|=
operator|&
name|alldevi
expr_stmt|;
name|errdev
operator|.
name|d_name
operator|=
literal|"<internal>"
expr_stmt|;
name|allpseudo
operator|=
name|NULL
expr_stmt|;
name|nextpseudo
operator|=
operator|&
name|allpseudo
expr_stmt|;
name|s_generic
operator|=
name|intern
argument_list|(
literal|"generic"
argument_list|)
expr_stmt|;
name|s_qmark
operator|=
name|intern
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|enddefs
parameter_list|(
name|fname
parameter_list|)
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
block|{
specifier|register
name|struct
name|devbase
modifier|*
name|dev
decl_stmt|;
for|for
control|(
name|dev
operator|=
name|allbases
init|;
name|dev
operator|!=
name|NULL
condition|;
name|dev
operator|=
name|dev
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|dev
operator|->
name|d_isdef
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: device `%s' used but not defined\n"
argument_list|,
name|fname
argument_list|,
name|dev
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|errors
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Stop.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|setdefmaxusers
parameter_list|(
name|min
parameter_list|,
name|def
parameter_list|,
name|max
parameter_list|)
name|int
name|min
decl_stmt|,
name|def
decl_stmt|,
name|max
decl_stmt|;
block|{
if|if
condition|(
name|min
operator|<
literal|1
operator|||
name|min
operator|>
name|def
operator|||
name|def
operator|>
name|max
condition|)
name|error
argument_list|(
literal|"maxusers must have 1<= min<= default<= max"
argument_list|)
expr_stmt|;
else|else
block|{
name|minmaxusers
operator|=
name|min
expr_stmt|;
name|defmaxusers
operator|=
name|def
expr_stmt|;
name|maxmaxusers
operator|=
name|max
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|setmaxusers
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|maxusers
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"duplicate maxusers parameter"
argument_list|)
expr_stmt|;
return|return;
block|}
name|maxusers
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|minmaxusers
condition|)
block|{
name|error
argument_list|(
literal|"warning: minimum of %d maxusers assumed\n"
argument_list|,
name|minmaxusers
argument_list|)
expr_stmt|;
name|errors
operator|--
expr_stmt|;
comment|/* take it away */
name|maxusers
operator|=
name|minmaxusers
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
name|maxmaxusers
condition|)
block|{
name|error
argument_list|(
literal|"warning: maxusers (%d)> %d"
argument_list|,
name|n
argument_list|,
name|maxmaxusers
argument_list|)
expr_stmt|;
name|errors
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Define an attribute, optionally with an interface (a locator list).  * Since an empty locator list is logically different from "no interface",  * all locator lists include a dummy head node, which we discard here.  */
end_comment

begin_function
name|int
name|defattr
parameter_list|(
name|name
parameter_list|,
name|locs
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|nvlist
modifier|*
name|locs
decl_stmt|;
block|{
specifier|register
name|struct
name|attr
modifier|*
name|a
decl_stmt|;
specifier|register
name|struct
name|nvlist
modifier|*
name|nv
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|a
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ht_insert
argument_list|(
name|attrtab
argument_list|,
name|name
argument_list|,
name|a
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"attribute `%s' already defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|nvfreel
argument_list|(
name|locs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|a
operator|->
name|a_name
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|locs
operator|!=
name|NULL
condition|)
block|{
name|a
operator|->
name|a_iattr
operator|=
literal|1
expr_stmt|;
name|a
operator|->
name|a_locs
operator|=
name|locs
operator|->
name|nv_next
expr_stmt|;
name|nvfree
argument_list|(
name|locs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|->
name|a_iattr
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|a_locs
operator|=
name|NULL
expr_stmt|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nv
operator|=
name|a
operator|->
name|a_locs
init|;
name|nv
operator|!=
name|NULL
condition|;
name|nv
operator|=
name|nv
operator|->
name|nv_next
control|)
name|len
operator|++
expr_stmt|;
name|a
operator|->
name|a_loclen
operator|=
name|len
expr_stmt|;
name|a
operator|->
name|a_devs
operator|=
name|NULL
expr_stmt|;
name|a
operator|->
name|a_refs
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if the given `error object' is embedded in the given  * pointer list.  */
end_comment

begin_function
specifier|static
name|int
name|has_errobj
parameter_list|(
name|nv
parameter_list|,
name|obj
parameter_list|)
specifier|register
name|struct
name|nvlist
modifier|*
name|nv
decl_stmt|;
specifier|register
name|void
modifier|*
name|obj
decl_stmt|;
block|{
for|for
control|(
init|;
name|nv
operator|!=
name|NULL
condition|;
name|nv
operator|=
name|nv
operator|->
name|nv_next
control|)
if|if
condition|(
name|nv
operator|->
name|nv_ptr
operator|==
name|obj
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a device base to a list in an attribute (actually, to any list).  * Note that this does not check for duplicates, and does reverse the  * list order, but no one cares anyway.  */
end_comment

begin_function
specifier|static
name|struct
name|nvlist
modifier|*
name|addtoattr
parameter_list|(
name|l
parameter_list|,
name|dev
parameter_list|)
specifier|register
name|struct
name|nvlist
modifier|*
name|l
decl_stmt|;
specifier|register
name|struct
name|devbase
modifier|*
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|nvlist
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|newnv
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|n
operator|->
name|nv_next
operator|=
name|l
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device a device, giving its allowable parent attachments, if any.  * This may (or may not) also define an interface attribute and/or refer  * to existing attributes.  There may be a list of vectors.  */
end_comment

begin_function
name|void
name|defdev
parameter_list|(
name|dev
parameter_list|,
name|ispseudo
parameter_list|,
name|atlist
parameter_list|,
name|vectors
parameter_list|,
name|loclist
parameter_list|,
name|attrs
parameter_list|)
specifier|register
name|struct
name|devbase
modifier|*
name|dev
decl_stmt|;
name|int
name|ispseudo
decl_stmt|;
name|struct
name|nvlist
modifier|*
name|atlist
decl_stmt|,
decl|*
name|vectors
decl_stmt|,
modifier|*
name|loclist
decl_stmt|,
modifier|*
name|attrs
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|nvlist
modifier|*
name|nv
decl_stmt|;
specifier|register
name|struct
name|attr
modifier|*
name|a
decl_stmt|;
if|if
condition|(
name|dev
operator|==
operator|&
name|errdev
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|dev
operator|->
name|d_isdef
condition|)
block|{
name|error
argument_list|(
literal|"redefinition of `%s'"
argument_list|,
name|dev
operator|->
name|d_name
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dev
operator|->
name|d_isdef
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|has_errobj
argument_list|(
name|attrs
argument_list|,
operator|&
name|errattr
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Handle implicit attribute definition from locator list.  Do 	 * this before scanning the `at' list so that we can have, e.g.: 	 *	device foo at other, foo { slot = -1 } 	 * (where you can plug in a foo-bus extender to a foo-bus). 	 */
if|if
condition|(
name|loclist
operator|!=
name|NULL
condition|)
block|{
name|nv
operator|=
name|loclist
expr_stmt|;
name|loclist
operator|=
name|NULL
expr_stmt|;
comment|/* defattr disposes of them for us */
if|if
condition|(
name|defattr
argument_list|(
name|dev
operator|->
name|d_name
argument_list|,
name|nv
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|nv
operator|=
name|newnv
argument_list|(
name|dev
operator|->
name|d_name
argument_list|,
name|NULL
argument_list|,
name|getattr
argument_list|(
name|dev
operator|->
name|d_name
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nv
operator|->
name|nv_next
operator|=
name|attrs
expr_stmt|;
name|attrs
operator|=
name|nv
expr_stmt|;
block|}
comment|/* Committed!  Set up fields. */
name|dev
operator|->
name|d_ispseudo
operator|=
name|ispseudo
expr_stmt|;
name|dev
operator|->
name|d_atlist
operator|=
name|atlist
expr_stmt|;
name|dev
operator|->
name|d_vectors
operator|=
name|vectors
expr_stmt|;
name|dev
operator|->
name|d_attrs
operator|=
name|attrs
expr_stmt|;
comment|/* 	 * Turn the `at' list into interface attributes (map each 	 * nv_name to an attribute, or to NULL for root), and add 	 * this device to those attributes, so that children can 	 * be listed at this particular device if they are supported 	 * by that attribute. 	 */
for|for
control|(
name|nv
operator|=
name|atlist
init|;
name|nv
operator|!=
name|NULL
condition|;
name|nv
operator|=
name|nv
operator|->
name|nv_next
control|)
block|{
if|if
condition|(
name|nv
operator|->
name|nv_name
operator|==
name|NULL
condition|)
block|{
name|nv
operator|->
name|nv_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* at root */
continue|continue;
block|}
name|nv
operator|->
name|nv_ptr
operator|=
name|a
operator|=
name|getattr
argument_list|(
name|nv
operator|->
name|nv_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|==
operator|&
name|errattr
condition|)
continue|continue;
comment|/* already complained */
if|if
condition|(
operator|!
name|a
operator|->
name|a_iattr
condition|)
name|error
argument_list|(
literal|"%s cannot be at plain attribute `%s'"
argument_list|,
name|dev
operator|->
name|d_name
argument_list|,
name|a
operator|->
name|a_name
argument_list|)
expr_stmt|;
else|else
name|a
operator|->
name|a_devs
operator|=
name|addtoattr
argument_list|(
name|a
operator|->
name|a_devs
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For each interface attribute this device refers to, add this 	 * device to its reference list.  This makes, e.g., finding all 	 * "scsi"s easier. 	 */
for|for
control|(
name|nv
operator|=
name|attrs
init|;
name|nv
operator|!=
name|NULL
condition|;
name|nv
operator|=
name|nv
operator|->
name|nv_next
control|)
block|{
name|a
operator|=
name|nv
operator|->
name|nv_ptr
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|a_iattr
condition|)
name|a
operator|->
name|a_refs
operator|=
name|addtoattr
argument_list|(
name|a
operator|->
name|a_refs
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
return|return;
name|bad
label|:
name|nvfreel
argument_list|(
name|atlist
argument_list|)
expr_stmt|;
name|nvfreel
argument_list|(
name|vectors
argument_list|)
expr_stmt|;
name|nvfreel
argument_list|(
name|loclist
argument_list|)
expr_stmt|;
name|nvfreel
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Look up a devbase.  Also makes sure it is a reasonable name,  * i.e., does not end in a digit or contain special characters.  */
end_comment

begin_function
name|struct
name|devbase
modifier|*
name|getdevbase
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|devbase
modifier|*
name|dev
decl_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|isalpha
argument_list|(
operator|*
name|p
argument_list|)
condition|)
goto|goto
name|badname
goto|;
while|while
condition|(
operator|*
operator|++
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|&&
operator|*
name|p
operator|!=
literal|'_'
condition|)
goto|goto
name|badname
goto|;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|--
name|p
argument_list|)
condition|)
block|{
name|badname
label|:
name|error
argument_list|(
literal|"bad device base name `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|errdev
operator|)
return|;
block|}
name|dev
operator|=
name|ht_lookup
argument_list|(
name|devbasetab
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|dev
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|d_name
operator|=
name|name
expr_stmt|;
name|dev
operator|->
name|d_next
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|d_isdef
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|d_major
operator|=
name|NODEV
expr_stmt|;
name|dev
operator|->
name|d_atlist
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|d_vectors
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|d_attrs
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|d_ihead
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|d_ipp
operator|=
operator|&
name|dev
operator|->
name|d_ihead
expr_stmt|;
name|dev
operator|->
name|d_umax
operator|=
literal|0
expr_stmt|;
operator|*
name|nextbase
operator|=
name|dev
expr_stmt|;
name|nextbase
operator|=
operator|&
name|dev
operator|->
name|d_next
expr_stmt|;
if|if
condition|(
name|ht_insert
argument_list|(
name|devbasetab
argument_list|,
name|name
argument_list|,
name|dev
argument_list|)
condition|)
name|panic
argument_list|(
literal|"getdevbase(%s)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dev
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up an attribute.  */
end_comment

begin_function
name|struct
name|attr
modifier|*
name|getattr
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|attr
modifier|*
name|a
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|ht_lookup
argument_list|(
name|attrtab
argument_list|,
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"undefined attribute `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|a
operator|=
operator|&
name|errattr
expr_stmt|;
block|}
return|return
operator|(
name|a
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the major device number for a device, so that it can be used  * as a root/swap/dumps "on" device in a configuration.  */
end_comment

begin_function
name|void
name|setmajor
parameter_list|(
name|d
parameter_list|,
name|n
parameter_list|)
name|struct
name|devbase
modifier|*
name|d
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|d
operator|!=
operator|&
name|errdev
operator|&&
name|d
operator|->
name|d_major
operator|!=
name|NODEV
condition|)
name|error
argument_list|(
literal|"device `%s' is already major %d"
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
name|d
operator|->
name|d_major
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|d_major
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|ABS
parameter_list|(
name|x
parameter_list|)
value|((x)< 0 ? -(x) : (x))
end_define

begin_function
specifier|static
name|int
name|exclude
parameter_list|(
name|nv
parameter_list|,
name|name
parameter_list|,
name|what
parameter_list|)
name|struct
name|nvlist
modifier|*
name|nv
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|what
decl_stmt|;
end_function

begin_block
block|{
if|if
condition|(
name|nv
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: swap generic must not specify %s"
argument_list|,
name|name
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Map things like "ra0b" => makedev(major("ra"), 0*8 + 'b'-'a').  * Handle the case where the device number is given but there is no  * corresponding name, and map NULL to the default.  */
end_comment

begin_function
specifier|static
name|int
name|resolve
parameter_list|(
name|nvp
parameter_list|,
name|name
parameter_list|,
name|what
parameter_list|,
name|dflt
parameter_list|,
name|part
parameter_list|)
specifier|register
name|struct
name|nvlist
modifier|*
modifier|*
name|nvp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|what
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|nvlist
modifier|*
name|dflt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|part
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nvlist
modifier|*
name|nv
decl_stmt|;
specifier|register
name|struct
name|devbase
modifier|*
name|dev
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|maj
decl_stmt|,
name|min
decl_stmt|,
name|l
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|char
name|buf
index|[
name|NAMESIZE
index|]
decl_stmt|;
if|if
condition|(
call|(
name|u_int
call|)
argument_list|(
name|part
operator|-=
literal|'a'
argument_list|)
operator|>=
literal|7
condition|)
name|panic
argument_list|(
literal|"resolve"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nv
operator|=
operator|*
name|nvp
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Apply default.  Easiest to do this by number. 		 */
name|maj
operator|=
name|major
argument_list|(
name|dflt
operator|->
name|nv_int
argument_list|)
expr_stmt|;
name|min
operator|=
operator|(
name|minor
argument_list|(
name|dflt
operator|->
name|nv_int
argument_list|)
operator|&
operator|~
literal|7
operator|)
operator||
name|part
expr_stmt|;
operator|*
name|nvp
operator|=
name|nv
operator|=
name|newnv
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|makedev
argument_list|(
name|maj
argument_list|,
name|min
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nv
operator|->
name|nv_int
operator|!=
name|NODEV
condition|)
block|{
comment|/* 		 * By the numbers.  Find the appropriate major number 		 * to make a name. 		 */
name|maj
operator|=
name|major
argument_list|(
name|nv
operator|->
name|nv_int
argument_list|)
expr_stmt|;
name|min
operator|=
name|minor
argument_list|(
name|nv
operator|->
name|nv_int
argument_list|)
expr_stmt|;
for|for
control|(
name|dev
operator|=
name|allbases
init|;
name|dev
operator|!=
name|NULL
condition|;
name|dev
operator|=
name|dev
operator|->
name|d_next
control|)
if|if
condition|(
name|dev
operator|->
name|d_major
operator|==
name|maj
condition|)
break|break;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"<%d/%d>"
argument_list|,
name|maj
argument_list|,
name|min
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%d%c"
argument_list|,
name|dev
operator|->
name|d_name
argument_list|,
name|min
operator|>>
literal|3
argument_list|,
operator|(
name|min
operator|&
literal|7
operator|)
operator|+
literal|'a'
argument_list|)
expr_stmt|;
name|nv
operator|->
name|nv_str
operator|=
name|intern
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * The normal case: things like "ra2b".  Check for partition 	 * suffix, remove it if there, and split into name ("ra") and 	 * unit (2). 	 */
name|l
operator|=
name|strlen
argument_list|(
name|nv
operator|->
name|nv_str
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|nv
operator|->
name|nv_str
index|[
name|l
index|]
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|1
operator|&&
operator|*
operator|--
name|cp
operator|>=
literal|'a'
operator|&&
operator|*
name|cp
operator|<=
literal|'h'
operator|&&
name|isdigit
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|l
operator|--
expr_stmt|;
name|part
operator|=
operator|*
name|cp
operator|-
literal|'a'
expr_stmt|;
block|}
name|cp
operator|=
name|nv
operator|->
name|nv_str
expr_stmt|;
if|if
condition|(
name|split
argument_list|(
name|cp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
operator|&
name|unit
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s: invalid %s device name `%s'"
argument_list|,
name|name
argument_list|,
name|what
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|dev
operator|=
name|ht_lookup
argument_list|(
name|devbasetab
argument_list|,
name|intern
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
operator|||
name|dev
operator|->
name|d_major
operator|==
name|NODEV
condition|)
block|{
name|error
argument_list|(
literal|"%s: can't make %s device from `%s'"
argument_list|,
name|name
argument_list|,
name|what
argument_list|,
name|nv
operator|->
name|nv_str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|nv
operator|->
name|nv_name
operator|=
name|dev
operator|->
name|d_name
expr_stmt|;
name|nv
operator|->
name|nv_int
operator|=
name|makedev
argument_list|(
name|dev
operator|->
name|d_major
argument_list|,
name|unit
operator|*
literal|8
operator|+
name|part
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|lresolve
parameter_list|(
name|nvp
parameter_list|,
name|name
parameter_list|,
name|what
parameter_list|,
name|dflt
parameter_list|,
name|part
parameter_list|)
specifier|register
name|struct
name|nvlist
modifier|*
modifier|*
name|nvp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|what
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|nvlist
modifier|*
name|dflt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|part
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|err
decl_stmt|;
while|while
condition|(
operator|(
name|err
operator|=
name|resolve
argument_list|(
name|nvp
argument_list|,
name|name
argument_list|,
name|what
argument_list|,
name|dflt
argument_list|,
name|part
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|*
name|nvp
operator|)
operator|->
name|nv_next
operator|!=
name|NULL
condition|)
name|nvp
operator|=
operator|&
operator|(
operator|*
name|nvp
operator|)
operator|->
name|nv_next
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Add a completed configuration to the list.  */
end_comment

begin_function
name|void
name|addconf
parameter_list|(
name|cf0
parameter_list|)
specifier|register
name|struct
name|config
modifier|*
name|cf0
decl_stmt|;
block|{
specifier|register
name|struct
name|config
modifier|*
name|cf
decl_stmt|;
specifier|register
name|struct
name|nvlist
modifier|*
name|nv
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|cf0
operator|->
name|cf_name
expr_stmt|;
name|cf
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|cf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ht_insert
argument_list|(
name|cfhashtab
argument_list|,
name|name
argument_list|,
name|cf
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"configuration `%s' already defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cf
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|*
name|cf
operator|=
operator|*
name|cf0
expr_stmt|;
comment|/* 	 * Look for "swap generic". 	 */
for|for
control|(
name|nv
operator|=
name|cf
operator|->
name|cf_swap
init|;
name|nv
operator|!=
name|NULL
condition|;
name|nv
operator|=
name|nv
operator|->
name|nv_next
control|)
if|if
condition|(
name|nv
operator|->
name|nv_str
operator|==
name|s_generic
condition|)
break|break;
if|if
condition|(
name|nv
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Make sure no root or dump device specified, and no 		 * other swap devices.  Note single | here (check all). 		 */
name|nv
operator|=
name|cf
operator|->
name|cf_swap
expr_stmt|;
if|if
condition|(
name|exclude
argument_list|(
name|cf
operator|->
name|cf_root
argument_list|,
name|name
argument_list|,
literal|"root device"
argument_list|)
operator||
name|exclude
argument_list|(
name|nv
operator|->
name|nv_next
argument_list|,
name|name
argument_list|,
literal|"additional swap devices"
argument_list|)
operator||
name|exclude
argument_list|(
name|cf
operator|->
name|cf_dump
argument_list|,
name|name
argument_list|,
literal|"dump device"
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
name|nv
operator|=
name|cf
operator|->
name|cf_root
expr_stmt|;
if|if
condition|(
name|nv
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: no root device specified"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|resolve
argument_list|(
operator|&
name|cf
operator|->
name|cf_root
argument_list|,
name|name
argument_list|,
literal|"root"
argument_list|,
name|nv
argument_list|,
literal|'a'
argument_list|)
operator||
name|lresolve
argument_list|(
operator|&
name|cf
operator|->
name|cf_swap
argument_list|,
name|name
argument_list|,
literal|"swap"
argument_list|,
name|nv
argument_list|,
literal|'b'
argument_list|)
operator||
name|resolve
argument_list|(
operator|&
name|cf
operator|->
name|cf_dump
argument_list|,
name|name
argument_list|,
literal|"dumps"
argument_list|,
name|nv
argument_list|,
literal|'b'
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
operator|*
name|nextcf
operator|=
name|cf
expr_stmt|;
name|nextcf
operator|=
operator|&
name|cf
operator|->
name|cf_next
expr_stmt|;
return|return;
name|bad
label|:
name|nvfreel
argument_list|(
name|cf0
operator|->
name|cf_root
argument_list|)
expr_stmt|;
name|nvfreel
argument_list|(
name|cf0
operator|->
name|cf_swap
argument_list|)
expr_stmt|;
name|nvfreel
argument_list|(
name|cf0
operator|->
name|cf_dump
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setconf
parameter_list|(
name|npp
parameter_list|,
name|what
parameter_list|,
name|v
parameter_list|)
specifier|register
name|struct
name|nvlist
modifier|*
modifier|*
name|npp
decl_stmt|;
specifier|const
name|char
modifier|*
name|what
decl_stmt|;
name|struct
name|nvlist
modifier|*
name|v
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|npp
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"duplicate %s specification"
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|nvfreel
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|npp
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|devi
modifier|*
name|newdevi
parameter_list|(
name|name
parameter_list|,
name|unit
parameter_list|,
name|d
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|struct
name|devbase
modifier|*
name|d
decl_stmt|;
block|{
specifier|register
name|struct
name|devi
modifier|*
name|i
decl_stmt|;
name|i
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|i
argument_list|)
expr_stmt|;
name|i
operator|->
name|i_name
operator|=
name|name
expr_stmt|;
name|i
operator|->
name|i_unit
operator|=
name|unit
expr_stmt|;
name|i
operator|->
name|i_base
operator|=
name|d
expr_stmt|;
name|i
operator|->
name|i_next
operator|=
name|NULL
expr_stmt|;
name|i
operator|->
name|i_bsame
operator|=
name|NULL
expr_stmt|;
name|i
operator|->
name|i_alias
operator|=
name|NULL
expr_stmt|;
name|i
operator|->
name|i_at
operator|=
name|NULL
expr_stmt|;
name|i
operator|->
name|i_atattr
operator|=
name|NULL
expr_stmt|;
name|i
operator|->
name|i_atdev
operator|=
name|NULL
expr_stmt|;
name|i
operator|->
name|i_locs
operator|=
name|NULL
expr_stmt|;
name|i
operator|->
name|i_cfflags
operator|=
literal|0
expr_stmt|;
name|i
operator|->
name|i_lineno
operator|=
name|currentline
argument_list|()
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|d
operator|->
name|d_umax
condition|)
name|d
operator|->
name|d_umax
operator|=
name|unit
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the named device as attaching to the named attribute (or perhaps  * another device instead) plus unit number.  */
end_comment

begin_function
name|void
name|adddev
parameter_list|(
name|name
parameter_list|,
name|at
parameter_list|,
name|loclist
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|at
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|nvlist
modifier|*
name|loclist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|devi
modifier|*
name|i
decl_stmt|;
comment|/* the new instance */
specifier|register
name|struct
name|attr
modifier|*
name|attr
decl_stmt|;
comment|/* attribute that allows attach */
specifier|register
name|struct
name|devbase
modifier|*
name|ib
decl_stmt|;
comment|/* i->i_base */
specifier|register
name|struct
name|devbase
modifier|*
name|ab
decl_stmt|;
comment|/* not NULL => at another dev */
specifier|register
name|struct
name|nvlist
modifier|*
name|nv
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|atunit
decl_stmt|;
name|char
name|atbuf
index|[
name|NAMESIZE
index|]
decl_stmt|;
name|ab
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|at
operator|==
name|NULL
condition|)
block|{
comment|/* "at root" */
if|if
condition|(
operator|(
name|i
operator|=
name|getdevi
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* 		 * Must warn about i_unit> 0 later, after taking care of 		 * the STAR cases (we could do non-star's here but why 		 * bother?).  Make sure this device can be at root. 		 */
name|ib
operator|=
name|i
operator|->
name|i_base
expr_stmt|;
if|if
condition|(
operator|!
name|onlist
argument_list|(
name|ib
operator|->
name|d_atlist
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s's cannot attach to the root"
argument_list|,
name|ib
operator|->
name|d_name
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|attr
operator|=
operator|&
name|errattr
expr_stmt|;
comment|/* a convenient "empty" attr */
block|}
else|else
block|{
if|if
condition|(
name|split
argument_list|(
name|at
argument_list|,
name|strlen
argument_list|(
name|at
argument_list|)
argument_list|,
name|atbuf
argument_list|,
sizeof|sizeof
name|atbuf
argument_list|,
operator|&
name|atunit
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid attachment name `%s'"
argument_list|,
name|at
argument_list|)
expr_stmt|;
comment|/* (void)getdevi(name); -- ??? */
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|getdevi
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|ib
operator|=
name|i
operator|->
name|i_base
expr_stmt|;
name|cp
operator|=
name|intern
argument_list|(
name|atbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|attr
operator|=
name|ht_lookup
argument_list|(
name|attrtab
argument_list|,
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Have to work a bit harder to see whether we have 			 * something like "tg0 at esp0" (where esp is merely 			 * not an attribute) or "tg0 at nonesuch0" (where 			 * nonesuch is not even a device). 			 */
if|if
condition|(
operator|(
name|ab
operator|=
name|ht_lookup
argument_list|(
name|devbasetab
argument_list|,
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s at %s: `%s' unknown"
argument_list|,
name|name
argument_list|,
name|at
argument_list|,
name|atbuf
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 			 * See if the named parent carries an attribute 			 * that allows it to supervise device ib. 			 */
for|for
control|(
name|nv
operator|=
name|ab
operator|->
name|d_attrs
init|;
name|nv
operator|!=
name|NULL
condition|;
name|nv
operator|=
name|nv
operator|->
name|nv_next
control|)
block|{
name|attr
operator|=
name|nv
operator|->
name|nv_ptr
expr_stmt|;
if|if
condition|(
name|onlist
argument_list|(
name|attr
operator|->
name|a_devs
argument_list|,
name|ib
argument_list|)
condition|)
goto|goto
name|ok
goto|;
block|}
name|attr
operator|=
operator|&
name|errattr
expr_stmt|;
comment|/* now onlist below will fail */
block|}
if|if
condition|(
operator|!
name|onlist
argument_list|(
name|attr
operator|->
name|a_devs
argument_list|,
name|ib
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"%s's cannot attach to %s's"
argument_list|,
name|ib
operator|->
name|d_name
argument_list|,
name|atbuf
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|ok
label|:
if|if
condition|(
operator|(
name|i
operator|->
name|i_locs
operator|=
name|fixloc
argument_list|(
name|name
argument_list|,
name|attr
argument_list|,
name|loclist
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|i
operator|->
name|i_unit
operator|==
name|STAR
operator|&&
name|ib
operator|->
name|d_vectors
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s's cannot be *'d as they have preset vectors"
argument_list|,
name|ib
operator|->
name|d_name
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|i
operator|->
name|i_at
operator|=
name|at
expr_stmt|;
name|i
operator|->
name|i_atattr
operator|=
name|attr
expr_stmt|;
name|i
operator|->
name|i_atdev
operator|=
name|ab
expr_stmt|;
name|i
operator|->
name|i_atunit
operator|=
name|atunit
expr_stmt|;
name|i
operator|->
name|i_cfflags
operator|=
name|flags
expr_stmt|;
name|selectbase
argument_list|(
name|ib
argument_list|)
expr_stmt|;
comment|/* all done, fall into ... */
name|bad
label|:
name|nvfreel
argument_list|(
name|loclist
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_function
name|void
name|addpseudo
parameter_list|(
name|name
parameter_list|,
name|number
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|number
decl_stmt|;
block|{
specifier|register
name|struct
name|devbase
modifier|*
name|d
decl_stmt|;
specifier|register
name|struct
name|devi
modifier|*
name|i
decl_stmt|;
name|d
operator|=
name|ht_lookup
argument_list|(
name|devbasetab
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"undefined pseudo-device %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|d_ispseudo
condition|)
block|{
name|error
argument_list|(
literal|"%s is a real device, not a pseudo-device"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ht_lookup
argument_list|(
name|devitab
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"`%s' already defined"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|newdevi
argument_list|(
name|name
argument_list|,
name|number
operator|-
literal|1
argument_list|,
name|d
argument_list|)
expr_stmt|;
comment|/* foo 16 => "foo0..foo15" */
if|if
condition|(
name|ht_insert
argument_list|(
name|devitab
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
condition|)
name|panic
argument_list|(
literal|"addpseudo(%s)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|selectbase
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
name|nextpseudo
operator|=
name|i
expr_stmt|;
name|nextpseudo
operator|=
operator|&
name|i
operator|->
name|i_next
expr_stmt|;
name|npseudo
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Define a new instance of a specific device.  */
end_comment

begin_function
specifier|static
name|struct
name|devi
modifier|*
name|getdevi
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|devi
modifier|*
name|i
decl_stmt|,
modifier|*
name|firsti
decl_stmt|;
specifier|register
name|struct
name|devbase
modifier|*
name|d
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|char
name|base
index|[
name|NAMESIZE
index|]
decl_stmt|;
if|if
condition|(
name|split
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|base
argument_list|,
sizeof|sizeof
name|base
argument_list|,
operator|&
name|unit
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid device name `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|d
operator|=
name|ht_lookup
argument_list|(
name|devbasetab
argument_list|,
name|intern
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"%s: unknown device `%s'"
argument_list|,
name|name
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|d
operator|->
name|d_ispseudo
condition|)
block|{
name|error
argument_list|(
literal|"%s: %s is a pseudo-device"
argument_list|,
name|name
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|firsti
operator|=
name|ht_lookup
argument_list|(
name|devitab
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
name|newdevi
argument_list|(
name|name
argument_list|,
name|unit
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|firsti
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ht_insert
argument_list|(
name|devitab
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
condition|)
name|panic
argument_list|(
literal|"getdevi(%s)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|d
operator|->
name|d_ipp
operator|=
name|i
expr_stmt|;
name|d
operator|->
name|d_ipp
operator|=
operator|&
name|i
operator|->
name|i_bsame
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|firsti
operator|->
name|i_alias
condition|)
name|firsti
operator|=
name|firsti
operator|->
name|i_alias
expr_stmt|;
name|firsti
operator|->
name|i_alias
operator|=
name|i
expr_stmt|;
block|}
operator|*
name|nextdevi
operator|=
name|i
expr_stmt|;
name|nextdevi
operator|=
operator|&
name|i
operator|->
name|i_next
expr_stmt|;
name|ndevi
operator|++
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|concat
parameter_list|(
name|name
parameter_list|,
name|c
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
name|NAMESIZE
index|]
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
literal|2
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"device name `%s%c' too long"
argument_list|,
name|name
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
name|buf
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|intern
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|starref
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
operator|(
name|concat
argument_list|(
name|name
argument_list|,
literal|'*'
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|wildref
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
return|return
operator|(
name|concat
argument_list|(
name|name
argument_list|,
literal|'?'
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split a name like "foo0" into base name (foo) and unit number (0).  * Return 0 on success.  To make this useful for names like "foo0a",  * the length of the "foo0" part is one of the arguments.  */
end_comment

begin_function
specifier|static
name|int
name|split
parameter_list|(
name|name
parameter_list|,
name|nlen
parameter_list|,
name|base
parameter_list|,
name|bsize
parameter_list|,
name|aunit
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|nlen
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
name|size_t
name|bsize
decl_stmt|;
name|int
modifier|*
name|aunit
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|l
decl_stmt|;
name|l
operator|=
name|nlen
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|2
operator|||
name|l
operator|>=
name|bsize
operator|||
name|isdigit
argument_list|(
operator|*
name|name
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|c
operator|=
operator|(
name|u_char
operator|)
name|name
index|[
operator|--
name|l
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
operator|*
name|aunit
operator|=
name|STAR
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
operator|*
name|aunit
operator|=
name|WILD
expr_stmt|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|cp
operator|=
operator|&
name|name
index|[
name|l
index|]
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
name|cp
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
name|l
operator|--
operator|,
name|cp
operator|--
expr_stmt|;
operator|*
name|aunit
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|name
argument_list|,
name|base
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|base
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We have an instance of the base foo, so select it and all its  * attributes for "optional foo".  */
end_comment

begin_function
specifier|static
name|void
name|selectbase
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|devbase
modifier|*
name|d
decl_stmt|;
block|{
specifier|register
name|struct
name|attr
modifier|*
name|a
decl_stmt|;
specifier|register
name|struct
name|nvlist
modifier|*
name|nv
decl_stmt|;
operator|(
name|void
operator|)
name|ht_insert
argument_list|(
name|selecttab
argument_list|,
name|d
operator|->
name|d_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|d_name
argument_list|)
expr_stmt|;
for|for
control|(
name|nv
operator|=
name|d
operator|->
name|d_attrs
init|;
name|nv
operator|!=
name|NULL
condition|;
name|nv
operator|=
name|nv
operator|->
name|nv_next
control|)
block|{
name|a
operator|=
name|nv
operator|->
name|nv_ptr
expr_stmt|;
operator|(
name|void
operator|)
name|ht_insert
argument_list|(
name|selecttab
argument_list|,
name|a
operator|->
name|a_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|a
operator|->
name|a_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Is the given pointer on the given list of pointers?  */
end_comment

begin_function
specifier|static
name|int
name|onlist
parameter_list|(
name|nv
parameter_list|,
name|ptr
parameter_list|)
specifier|register
name|struct
name|nvlist
modifier|*
name|nv
decl_stmt|;
specifier|register
name|void
modifier|*
name|ptr
decl_stmt|;
block|{
for|for
control|(
init|;
name|nv
operator|!=
name|NULL
condition|;
name|nv
operator|=
name|nv
operator|->
name|nv_next
control|)
if|if
condition|(
name|nv
operator|->
name|nv_ptr
operator|==
name|ptr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|extend
parameter_list|(
name|p
parameter_list|,
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|int
name|l
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|p
operator|+=
name|l
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check that we got all required locators, and default any that are  * given as "?" and have defaults.  Return 0 on success.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|fixloc
parameter_list|(
name|name
parameter_list|,
name|attr
parameter_list|,
name|got
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|attr
modifier|*
name|attr
decl_stmt|;
specifier|register
name|struct
name|nvlist
modifier|*
name|got
decl_stmt|;
block|{
specifier|register
name|struct
name|nvlist
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
specifier|register
name|int
name|ord
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
modifier|*
name|lp
decl_stmt|;
name|int
name|nmissing
decl_stmt|,
name|nextra
decl_stmt|,
name|nnodefault
decl_stmt|;
name|char
modifier|*
name|mp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|ndp
decl_stmt|;
name|char
name|missing
index|[
literal|1000
index|]
decl_stmt|,
name|extra
index|[
literal|1000
index|]
decl_stmt|,
name|nodefault
index|[
literal|1000
index|]
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|nullvec
index|[
literal|1
index|]
decl_stmt|;
comment|/* 	 * Look for all required locators, and number the given ones 	 * according to the required order.  While we are numbering, 	 * set default values for defaulted locators. 	 */
if|if
condition|(
name|attr
operator|->
name|a_loclen
operator|==
literal|0
condition|)
comment|/* e.g., "at root" */
name|lp
operator|=
name|nullvec
expr_stmt|;
else|else
name|lp
operator|=
name|emalloc
argument_list|(
operator|(
name|attr
operator|->
name|a_loclen
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|got
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|nv_next
control|)
name|n
operator|->
name|nv_int
operator|=
operator|-
literal|1
expr_stmt|;
name|nmissing
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
name|missing
expr_stmt|;
comment|/* yes, this is O(mn), but m and n should be small */
for|for
control|(
name|ord
operator|=
literal|0
operator|,
name|m
operator|=
name|attr
operator|->
name|a_locs
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|nv_next
operator|,
name|ord
operator|++
control|)
block|{
for|for
control|(
name|n
operator|=
name|got
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|nv_next
control|)
block|{
if|if
condition|(
name|n
operator|->
name|nv_name
operator|==
name|m
operator|->
name|nv_name
condition|)
block|{
name|n
operator|->
name|nv_int
operator|=
name|ord
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|n
operator|==
name|NULL
operator|&&
name|m
operator|->
name|nv_int
operator|==
literal|0
condition|)
block|{
name|nmissing
operator|++
expr_stmt|;
name|mp
operator|=
name|extend
argument_list|(
name|mp
argument_list|,
name|m
operator|->
name|nv_name
argument_list|)
expr_stmt|;
block|}
name|lp
index|[
name|ord
index|]
operator|=
name|m
operator|->
name|nv_str
expr_stmt|;
block|}
if|if
condition|(
name|ord
operator|!=
name|attr
operator|->
name|a_loclen
condition|)
name|panic
argument_list|(
literal|"fixloc"
argument_list|)
expr_stmt|;
name|lp
index|[
name|ord
index|]
operator|=
name|NULL
expr_stmt|;
name|nextra
operator|=
literal|0
expr_stmt|;
name|ep
operator|=
name|extra
expr_stmt|;
name|nnodefault
operator|=
literal|0
expr_stmt|;
name|ndp
operator|=
name|nodefault
expr_stmt|;
for|for
control|(
name|n
operator|=
name|got
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|nv_next
control|)
block|{
if|if
condition|(
name|n
operator|->
name|nv_int
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|->
name|nv_str
operator|!=
name|NULL
condition|)
name|lp
index|[
name|n
operator|->
name|nv_int
index|]
operator|=
name|n
operator|->
name|nv_str
expr_stmt|;
elseif|else
if|if
condition|(
name|lp
index|[
name|n
operator|->
name|nv_int
index|]
operator|==
name|NULL
condition|)
block|{
name|nnodefault
operator|++
expr_stmt|;
name|ndp
operator|=
name|extend
argument_list|(
name|ndp
argument_list|,
name|n
operator|->
name|nv_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nextra
operator|++
expr_stmt|;
name|ep
operator|=
name|extend
argument_list|(
name|ep
argument_list|,
name|n
operator|->
name|nv_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nextra
condition|)
block|{
name|ep
index|[
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* kill ", " */
name|error
argument_list|(
literal|"%s: extraneous locator%s: %s"
argument_list|,
name|name
argument_list|,
name|nextra
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|extra
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nmissing
condition|)
block|{
name|mp
index|[
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"%s: must specify %s"
argument_list|,
name|name
argument_list|,
name|missing
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nnodefault
condition|)
block|{
name|ndp
index|[
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"%s: cannot wildcard %s"
argument_list|,
name|name
argument_list|,
name|nodefault
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nmissing
operator|||
name|nnodefault
condition|)
block|{
name|free
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|lp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|lp
operator|)
return|;
block|}
end_function

end_unit

