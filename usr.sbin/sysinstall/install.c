begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The new sysinstall program.  *  * This is probably the last program in the `sysinstall' line - the next  * generation being essentially a complete rewrite.  *  * $FreeBSD$  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    verbatim and that no modifications are made prior to this  *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/consio.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_define
define|#
directive|define
name|MSDOSFS
end_define

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/msdosfsmount.h>
end_include

begin_undef
undef|#
directive|undef
name|MSDOSFS
end_undef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<libdisk.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_comment
comment|/* Hack for rsaref package add, which displays interactive license.  * Used by package.c  */
end_comment

begin_decl_stmt
name|int
name|_interactiveHack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|FixItMode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|NCpus
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|create_termcap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixit_common
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|TERMCAP_FILE
value|"/usr/share/misc/termcap"
end_define

begin_function_decl
specifier|static
name|void
name|installConfigure
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|Boolean
name|checkLabels
parameter_list|(
name|Boolean
name|whinge
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|Boolean
name|status
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|PartInfo
modifier|*
name|pi
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Don't allow whinging if noWarn is set */
if|if
condition|(
name|variable_get
argument_list|(
name|VAR_NO_WARN
argument_list|)
condition|)
name|whinge
operator|=
name|FALSE
expr_stmt|;
name|status
operator|=
name|TRUE
expr_stmt|;
name|HomeChunk
operator|=
name|RootChunk
operator|=
name|SwapChunk
operator|=
name|NULL
expr_stmt|;
name|TmpChunk
operator|=
name|UsrChunk
operator|=
name|VarChunk
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|__ia64__
name|EfiChunk
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* We don't need to worry about root/usr/swap if we're already multiuser */
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|status
return|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
comment|/* First verify that we have a root device */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for root filesystem\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|__ia64__
name|c2
operator|=
name|c1
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|apple
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
else|#
directive|else
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
endif|#
directive|endif
name|pi
operator|=
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
expr_stmt|;
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|pi
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pi
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
block|{
if|if
condition|(
name|RootChunk
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one root device set?!\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|RootChunk
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found rootdev at %s!\n"
argument_list|,
name|RootChunk
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pi
operator|->
name|mountpoint
argument_list|,
literal|"/usr"
argument_list|)
condition|)
block|{
if|if
condition|(
name|UsrChunk
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /usr filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|UsrChunk
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found usrdev at %s!\n"
argument_list|,
name|UsrChunk
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pi
operator|->
name|mountpoint
argument_list|,
literal|"/var"
argument_list|)
condition|)
block|{
if|if
condition|(
name|VarChunk
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /var filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|VarChunk
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found vardev at %s!\n"
argument_list|,
name|VarChunk
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pi
operator|->
name|mountpoint
argument_list|,
literal|"/tmp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|TmpChunk
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /tmp filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|TmpChunk
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found tmpdev at %s!\n"
argument_list|,
name|TmpChunk
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pi
operator|->
name|mountpoint
argument_list|,
literal|"/home"
argument_list|)
condition|)
block|{
if|if
condition|(
name|HomeChunk
condition|)
block|{
if|if
condition|(
name|whinge
condition|)
name|msgConfirm
argument_list|(
literal|"WARNING:  You have more than one /home filesystem.\n"
literal|"Using the first one found."
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|HomeChunk
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found homedev at %s!\n"
argument_list|,
name|HomeChunk
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|__ia64__
block|}
block|}
endif|#
directive|endif
block|}
block|}
comment|/* Now check for swap devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for swap partitions\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|__ia64__
name|c2
operator|=
name|c1
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|apple
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
else|#
directive|else
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
endif|#
directive|endif
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
operator|&&
operator|!
name|SwapChunk
condition|)
block|{
name|SwapChunk
operator|=
name|c2
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"Found swapdev at %s!\n"
argument_list|,
name|SwapChunk
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|__ia64__
block|}
block|}
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|__ia64__
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
operator|!=
name|NULL
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
name|pi
operator|=
operator|(
name|PartInfo
operator|*
operator|)
name|c1
operator|->
name|private_data
expr_stmt|;
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|efi
operator|&&
name|pi
operator|!=
name|NULL
operator|&&
name|pi
operator|->
name|mountpoint
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|EfiChunk
operator|=
name|c1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|RootChunk
operator|&&
name|whinge
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No root device found - you must label a partition as /\n"
literal|"in the label editor."
argument_list|)
expr_stmt|;
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SwapChunk
operator|&&
name|whinge
condition|)
block|{
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"No swap devices found - you should create at least one\n"
literal|"swap partition.  Without swap, the install will fail\n"
literal|"if you do not have enough RAM.  Continue anyway?"
argument_list|)
condition|)
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__ia64__
if|if
condition|(
name|EfiChunk
operator|==
name|NULL
operator|&&
name|whinge
condition|)
block|{
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"No (mounted) EFI system partition found. Is this what you want?"
argument_list|)
condition|)
name|status
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|status
return|;
block|}
specifier|static
name|int
name|installInitial
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|Boolean
name|alreadyDone
init|=
name|FALSE
decl_stmt|;
name|int
name|status
init|=
name|DITEM_SUCCESS
decl_stmt|;
if|if
condition|(
name|alreadyDone
condition|)
return|return
name|DITEM_SUCCESS
return|;
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_LABELLED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to assign disk labels before you can proceed with\n"
literal|"the installation."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
comment|/* If it's labelled, assume it's also partitioned */
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|DISK_PARTITIONED
argument_list|)
condition|)
name|variable_set2
argument_list|(
name|DISK_PARTITIONED
argument_list|,
literal|"yes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we refuse to proceed, bail. */
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|VAR_NO_WARN
argument_list|)
condition|)
block|{
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Last Chance!  Are you SURE you want continue the installation?\n\n"
literal|"If you're running this on a disk with data you wish to save\n"
literal|"then WE STRONGLY ENCOURAGE YOU TO MAKE PROPER BACKUPS before\n"
literal|"proceeding!\n\n"
literal|"We can take no responsibility for lost disk contents!"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskLabelCommit
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't make filesystems properly.  Aborting."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|copySelf
argument_list|()
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"installInitial: Couldn't clone the boot floppy onto the\n"
literal|"root file system.  Aborting!"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|Restarting
operator|&&
name|chroot
argument_list|(
literal|"/mnt"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"installInitial: Unable to chroot to %s - this is bad!"
argument_list|,
literal|"/mnt"
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|RUNNING_ON_ROOT
argument_list|,
literal|"yes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure various files in /etc */
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|configResolv
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
name|status
operator|=
name|DITEM_FAILURE
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|configFstab
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
name|status
operator|=
name|DITEM_FAILURE
expr_stmt|;
comment|/* stick a helpful shell over on the 4th VTY */
if|if
condition|(
operator|!
name|variable_get
argument_list|(
name|VAR_NO_HOLOSHELL
argument_list|)
condition|)
name|systemCreateHoloshell
argument_list|()
expr_stmt|;
name|alreadyDone
operator|=
name|TRUE
expr_stmt|;
return|return
name|status
return|;
block|}
name|int
name|installFixitHoloShell
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|FixItMode
operator|=
literal|1
expr_stmt|;
name|systemCreateHoloshell
argument_list|()
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
name|FixItMode
operator|=
literal|0
expr_stmt|;
block|}
name|int
name|installFixitCDROM
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|need_eject
decl_stmt|;
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|DITEM_SUCCESS
return|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"fixit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rmdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
name|need_eject
operator|=
literal|0
expr_stmt|;
name|CDROMInitQuiet
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|need_eject
condition|)
name|msgConfirm
argument_list|(
literal|"Please insert a FreeBSD live filesystem CD/DVD and press return"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|mediaSetCDROM
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
operator|||
operator|!
name|DEVICE_INIT
argument_list|(
name|mediaDevice
argument_list|)
condition|)
block|{
comment|/* If we can't initialize it, it's probably not a FreeBSD CDROM so punt on it */
name|mediaClose
argument_list|()
expr_stmt|;
if|if
condition|(
name|need_eject
operator|&&
name|msgYesNo
argument_list|(
literal|"Unable to mount the disc. Do you want to try again?"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DITEM_FAILURE
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/dist/rescue/ldconfig"
argument_list|)
condition|)
block|{
name|mediaClose
argument_list|()
expr_stmt|;
if|if
condition|(
name|need_eject
operator|&&
name|msgYesNo
argument_list|(
literal|"Unable to find a FreeBSD live filesystem. Do you want to try again?"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|DITEM_FAILURE
return|;
block|}
else|else
break|break;
name|CDROMInitQuiet
operator|=
literal|0
expr_stmt|;
name|need_eject
operator|=
literal|1
expr_stmt|;
block|}
name|CDROMInitQuiet
operator|=
literal|0
expr_stmt|;
comment|/* Since the fixit code expects everything to be in /mnt2, and the CDROM mounting stuff /dist, do      * a little kludge dance here..      */
if|if
condition|(
name|symlink
argument_list|(
literal|"/dist"
argument_list|,
literal|"/mnt2"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to symlink /mnt2 to the disc mount point.  Please report this\n"
literal|"unexpected failure to freebsd-bugs@FreeBSD.org."
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
comment|/*      * If /tmp points to /mnt2/tmp from a previous fixit floppy session, it's      * not very good for us if we point it to the CDROM now.  Rather make it      * a directory in the root MFS then.  Experienced admins will still be      * able to mount their disk's /tmp over this if they need.      */
if|if
condition|(
name|lstat
argument_list|(
literal|"/tmp"
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFLNK
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
name|Mkdir
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
comment|/*      * Since setuid binaries ignore LD_LIBRARY_PATH, we indeed need the      * ld.so.hints file.  Fortunately, it's fairly small (~ 3 KB).      */
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/var/run/ld.so.hints"
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/var/run"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsystem
argument_list|(
literal|"/mnt2/rescue/ldconfig -s /mnt2/lib /mnt2/usr/lib"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning: ldconfig could not create the ld.so hints file.\n"
literal|"Dynamic executables from the disc likely won't work."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Yet more iggly hardcoded pathnames. */
name|Mkdir
argument_list|(
literal|"/libexec"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/libexec/ld.so"
argument_list|)
operator|&&
name|file_readable
argument_list|(
literal|"/mnt2/libexec/ld.so"
argument_list|)
condition|)
block|{
if|if
condition|(
name|symlink
argument_list|(
literal|"/mnt2/libexec/ld.so"
argument_list|,
literal|"/libexec/ld.so"
argument_list|)
condition|)
name|msgDebug
argument_list|(
literal|"Couldn't link to ld.so - not necessarily a problem for ELF\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/libexec/ld-elf.so.1"
argument_list|)
condition|)
block|{
if|if
condition|(
name|symlink
argument_list|(
literal|"/mnt2/libexec/ld-elf.so.1"
argument_list|,
literal|"/libexec/ld-elf.so.1"
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning: could not create the symlink for ld-elf.so.1\n"
literal|"Dynamic executables from the disc likely won't work."
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* optional nicety */
if|if
condition|(
operator|!
name|file_readable
argument_list|(
literal|"/usr/bin/vi"
argument_list|)
condition|)
name|symlink
argument_list|(
literal|"/mnt2/usr/bin/vi"
argument_list|,
literal|"/usr/bin/vi"
argument_list|)
expr_stmt|;
name|fixit_common
argument_list|()
expr_stmt|;
name|mediaClose
argument_list|()
expr_stmt|;
if|if
condition|(
name|need_eject
condition|)
name|msgConfirm
argument_list|(
literal|"Please remove the FreeBSD fixit CDROM/DVD now."
argument_list|)
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
name|int
name|installFixitFloppy
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|struct
name|ufs_args
name|args
decl_stmt|;
specifier|extern
name|char
modifier|*
name|distWanted
decl_stmt|;
if|if
condition|(
operator|!
name|RunningAsInit
condition|)
return|return
name|DITEM_SUCCESS
return|;
comment|/* Try to open the floppy drive */
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|mediaSetFloppy
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
operator|||
operator|!
name|mediaDevice
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to set media device to floppy."
argument_list|)
expr_stmt|;
name|mediaClose
argument_list|()
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|fspec
operator|=
name|mediaDevice
operator|->
name|devname
expr_stmt|;
name|mediaDevice
operator|->
name|private
operator|=
literal|"/mnt2"
expr_stmt|;
name|distWanted
operator|=
name|NULL
expr_stmt|;
name|Mkdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"fixit"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|DEVICE_INIT
argument_list|(
name|mediaDevice
argument_list|)
condition|)
block|{
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"The attempt to mount the fixit floppy failed, bad floppy\n"
literal|"or unclean filesystem.  Do you want to try again?"
argument_list|)
condition|)
return|return
name|DITEM_FAILURE
return|;
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/tmp"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/mnt2/tmp"
argument_list|,
literal|"/tmp"
argument_list|)
expr_stmt|;
name|fixit_common
argument_list|()
expr_stmt|;
name|mediaClose
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Please remove the fixit floppy now."
argument_list|)
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
comment|/*  * The common code for both fixit variants.  */
specifier|static
name|void
name|fixit_common
parameter_list|(
name|void
parameter_list|)
block|{
name|pid_t
name|child
decl_stmt|;
name|int
name|waitstatus
decl_stmt|;
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/var/tmp/vi.recover"
argument_list|)
condition|)
block|{
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|Mkdir
argument_list|(
literal|"/var/tmp/vi.recover"
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning:  Was unable to create a /var/tmp/vi.recover directory.\n"
literal|"vi will kvetch and moan about it as a result but should still\n"
literal|"be essentially usable."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|directory_exists
argument_list|(
literal|"/bin"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|Mkdir
argument_list|(
literal|"/bin"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|symlink
argument_list|(
literal|"/stand/sh"
argument_list|,
literal|"/bin/sh"
argument_list|)
expr_stmt|;
comment|/* Link the /etc/ files */
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|Mkdir
argument_list|(
literal|"/etc"
argument_list|)
argument_list|)
operator|!=
name|DITEM_SUCCESS
condition|)
name|msgConfirm
argument_list|(
literal|"Unable to create an /etc directory!  Things are weird on this floppy.."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/spwd.db"
argument_list|,
literal|"/etc/spwd.db"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/protocols"
argument_list|,
literal|"/etc/protocols"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/group"
argument_list|,
literal|"/etc/group"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
operator|||
operator|(
name|symlink
argument_list|(
literal|"/mnt2/etc/services"
argument_list|,
literal|"/etc/services"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
operator|)
condition|)
name|msgConfirm
argument_list|(
literal|"Couldn't symlink the /etc/ files!  I'm not sure I like this.."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
name|TERMCAP_FILE
argument_list|)
condition|)
name|create_termcap
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|VAR_FIXIT_TTY
argument_list|)
argument_list|,
literal|"serial"
argument_list|)
operator|==
literal|0
condition|)
name|systemSuspendDialog
argument_list|()
expr_stmt|;
comment|/* must be before the fork() */
if|if
condition|(
operator|!
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|termios
name|foo
decl_stmt|;
specifier|extern
name|int
name|login_tty
argument_list|(
name|int
argument_list|)
decl_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|getdtablesize
argument_list|()
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|VAR_FIXIT_TTY
argument_list|)
argument_list|,
literal|"serial"
argument_list|)
operator|==
literal|0
condition|)
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/console"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
else|else
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/ttyv3"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSCTTY
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|DebugFD
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|login_tty
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgDebug
argument_list|(
literal|"fixit: I can't set the controlling terminal.\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTTOU
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
literal|0
argument_list|,
operator|&
name|foo
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|foo
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|=
literal|'\010'
expr_stmt|;
if|if
condition|(
name|tcsetattr
argument_list|(
literal|0
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|foo
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|msgDebug
argument_list|(
literal|"fixit shell: Unable to set erase character.\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|msgDebug
argument_list|(
literal|"fixit shell: Unable to get terminal attributes!\n"
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"PATH"
argument_list|,
literal|"/bin:/sbin:/usr/bin:/usr/sbin:/stand:"
literal|"/mnt2/stand:/mnt2/bin:/mnt2/sbin:/mnt2/usr/bin:/mnt2/usr/sbin"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|VAR_FIXIT_TTY
argument_list|)
argument_list|,
literal|"serial"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Waiting for fixit shell to exit.\n"
literal|"When you are done, type ``exit'' to exit\n"
literal|"the fixit shell and be returned here.\n\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ioctl
argument_list|(
name|fd
argument_list|,
name|VT_ACTIVATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* use the .profile from the fixit medium */
name|setenv
argument_list|(
literal|"HOME"
argument_list|,
literal|"/mnt2"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|"/mnt2"
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"-sh"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|msgDebug
argument_list|(
literal|"fixit shell: Failed to execute shell!\n"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|VAR_FIXIT_TTY
argument_list|)
argument_list|,
literal|"standard"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Waiting for fixit shell to exit.  Go to VTY4 now by\n"
literal|"typing ALT-F4.  When you are done, type ``exit'' to exit\n"
literal|"the fixit shell and be returned here\n."
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|waitpid
argument_list|(
name|child
argument_list|,
operator|&
name|waitstatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|variable_get
argument_list|(
name|VAR_FIXIT_TTY
argument_list|)
argument_list|,
literal|"serial"
argument_list|)
operator|==
literal|0
condition|)
name|systemResumeDialog
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|OnVTY
condition|)
block|{
name|ioctl
argument_list|(
literal|0
argument_list|,
name|VT_ACTIVATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msgInfo
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
block|}
name|int
name|installExpress
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"express"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_SLICES
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|diskPartitionEditor
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
endif|#
directive|endif
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|diskLabelEditor
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_SUCCESS
condition|)
block|{
name|i
operator||=
name|DITEM_LEAVE_MENU
expr_stmt|;
comment|/* Give user the option of one last configuration spree */
name|installConfigure
argument_list|()
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
comment|/* Standard mode installation */
name|int
name|installStandard
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|tries
init|=
literal|0
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"standard"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_SLICES
name|msgConfirm
argument_list|(
literal|"In the next menu, you will need to set up a DOS-style (\"fdisk\") partitioning\n"
literal|"scheme for your hard disk.  If you simply wish to devote all disk space\n"
literal|"to FreeBSD (overwriting anything else that might be on the disk(s) selected)\n"
literal|"then use the (A)ll command to select the default partitioning scheme followed\n"
literal|"by a (Q)uit.  If you wish to allocate only free space to FreeBSD, move to a\n"
literal|"partition marked \"unused\" and use the (C)reate command."
argument_list|)
expr_stmt|;
name|nodisks
label|:
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskPartitionEditor
argument_list|(
name|self
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|DITEM_FAILURE
return|;
if|if
condition|(
name|diskGetSelectCount
argument_list|(
operator|&
name|devs
argument_list|)
operator|<=
literal|0
operator|&&
name|tries
operator|<
literal|3
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to select some disks to operate on!  Be sure to use SPACE\n"
literal|"instead of RETURN in the disk selection menu when selecting a disk."
argument_list|)
expr_stmt|;
operator|++
name|tries
expr_stmt|;
goto|goto
name|nodisks
goto|;
block|}
name|msgConfirm
argument_list|(
literal|"Now you need to create BSD partitions inside of the fdisk partition(s)\n"
literal|"just created.  If you have a reasonable amount of disk space (1GB or more)\n"
literal|"and don't have any special requirements, simply use the (A)uto command to\n"
literal|"allocate space automatically.  If you have more specific needs or just don't\n"
literal|"care for the layout chosen by (A)uto, press F1 for more information on\n"
literal|"manual layout."
argument_list|)
expr_stmt|;
else|#
directive|else
name|msgConfirm
argument_list|(
literal|"First you need to create BSD partitions on the disk which you are\n"
literal|"installing to.  If you have a reasonable amount of disk space (1GB or more)\n"
literal|"and don't have any special requirements, simply use the (A)uto command to\n"
literal|"allocate space automatically.  If you have more specific needs or just don't\n"
literal|"care for the layout chosen by (A)uto, press F1 for more information on\n"
literal|"manual layout."
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|diskLabelEditor
argument_list|(
name|self
argument_list|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|DITEM_FAILURE
return|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
block|{
name|dialog_clear
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Installation completed with some errors.  You may wish to\n"
literal|"scroll through the debugging messages on VTY1 with the\n"
literal|"scroll-lock feature.  You can also choose \"No\" at the next\n"
literal|"prompt and go back into the installation menus to retry\n"
literal|"whichever operations have failed."
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
else|else
block|{
name|dialog_clear
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Congratulations!  You now have FreeBSD installed on your system.\n\n"
literal|"We will now move on to the final configuration questions.\n"
literal|"For any option you do not wish to configure, simply select\n"
literal|"No.\n\n"
literal|"If you wish to re-enter this utility after the system is up, you\n"
literal|"may do so by typing: /usr/sbin/sysinstall."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mediaDevice
operator|->
name|type
operator|!=
name|DEVICE_TYPE_FTP
operator|&&
name|mediaDevice
operator|->
name|type
operator|!=
name|DEVICE_TYPE_NFS
condition|)
block|{
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to configure any Ethernet or SLIP/PPP network devices?"
argument_list|)
condition|)
block|{
name|Device
modifier|*
name|tmp
init|=
name|tcpDeviceSelect
argument_list|()
decl_stmt|;
if|if
condition|(
name|tmp
operator|&&
operator|!
operator|(
operator|(
name|DevInfo
operator|*
operator|)
name|tmp
operator|->
name|private
operator|)
operator|->
name|use_dhcp
operator|&&
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to bring the %s interface up right now?"
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
condition|)
if|if
condition|(
operator|!
name|DEVICE_INIT
argument_list|(
name|tmp
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"Initialization of %s device failed."
argument_list|,
name|tmp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Do you want this machine to function as a network gateway?"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"gateway_enable"
argument_list|,
literal|"YES"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Do you want to configure inetd and the network services that it provides?"
argument_list|)
condition|)
name|configInetd
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Would you like to enable SSH login?"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"sshd_enable"
argument_list|,
literal|"YES"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Do you want to have anonymous FTP access to this machine?"
argument_list|)
condition|)
name|configAnonFTP
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Do you want to configure this machine as an NFS server?"
argument_list|)
condition|)
name|configNFSServer
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Do you want to configure this machine as an NFS client?"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"nfs_client_enable"
argument_list|,
literal|"YES"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_SYSCONS
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Would you like to customize your system console settings?"
argument_list|)
condition|)
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuSyscons
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to set this machine's time zone now?"
argument_list|)
condition|)
name|systemExecute
argument_list|(
literal|"tzsetup"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_LINUX
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to enable Linux binary compatibility?"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|configLinux
argument_list|(
name|self
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__alpha__
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to enable OSF/1 binary compatibility?"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|configOSF1
argument_list|(
name|self
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WITH_MICE
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Does this system have a PS/2, serial, or bus mouse?"
argument_list|)
condition|)
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuMouse
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__i386__
if|if
condition|(
name|checkLoaderACPI
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"ACPI was disabled during boot.\n"
literal|"Would you like to disable it permanently?"
argument_list|)
condition|)
operator|(
name|void
operator|)
name|configLoaderACPI
argument_list|(
literal|1
comment|/*disable*/
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Now would be a good time to checkpoint the configuration data */
name|configRC_conf
argument_list|()
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"The FreeBSD package collection is a collection of thousands of ready-to-run\n"
literal|"applications, from text editors to games to WEB servers and more.  Would you\n"
literal|"like to browse the collection now?"
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|configPackages
argument_list|(
name|self
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to add any initial user accounts to the system?\n"
literal|"Adding at least one account for yourself at this stage is suggested\n"
literal|"since working as the \"root\" user is dangerous (it is easy to do\n"
literal|"things which adversely affect the entire system)."
argument_list|)
condition|)
operator|(
name|void
operator|)
name|configUsers
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Now you must set the system manager's password.\n"
literal|"This is the password you'll use to log in as \"root\"."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|systemExecute
argument_list|(
literal|"passwd root"
argument_list|)
condition|)
name|variable_set2
argument_list|(
literal|"root_password"
argument_list|,
literal|"YES"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX Put whatever other nice configuration questions you'd like to ask the user here XXX */
comment|/* Give user the option of one last configuration spree */
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|installConfigure
argument_list|()
expr_stmt|;
return|return
name|DITEM_LEAVE_MENU
return|;
block|}
comment|/* The version of commit we call from the Install Custom menu */
name|int
name|installCustomCommit
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|installCommit
argument_list|(
name|self
argument_list|)
expr_stmt|;
if|if
condition|(
name|DITEM_STATUS
argument_list|(
name|i
argument_list|)
operator|==
name|DITEM_SUCCESS
condition|)
block|{
comment|/* Give user the option of one last configuration spree */
name|installConfigure
argument_list|()
expr_stmt|;
return|return
name|i
return|;
block|}
else|else
name|msgConfirm
argument_list|(
literal|"The commit operation completed with errors.  Not\n"
literal|"updating /etc files."
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
comment|/*  * What happens when we finally decide to going ahead with the installation.  *  * This is broken into multiple stages so that the user can do a full  * installation but come back here again to load more distributions,  * perhaps from a different media type.  This would allow, for  * example, the user to load the majority of the system from CDROM and  * then use ftp to load a different dist.  */
name|int
name|installCommit
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|Dists
condition|)
name|distConfig
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Dists
condition|)
block|{
operator|(
name|void
operator|)
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuDistributions
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* select reasonable defaults if necessary */
if|if
condition|(
operator|!
name|Dists
condition|)
name|Dists
operator|=
name|_DIST_USER
expr_stmt|;
if|if
condition|(
operator|!
name|KernelDists
condition|)
name|KernelDists
operator|=
name|selectKernel
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
name|DITEM_FAILURE
return|;
name|str
operator|=
name|variable_get
argument_list|(
name|SYSTEM_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDebug
argument_list|()
condition|)
name|msgDebug
argument_list|(
literal|"installCommit: System state is `%s'\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Installation stuff we wouldn't do to a running system */
if|if
condition|(
name|RunningAsInit
operator|&&
name|DITEM_STATUS
argument_list|(
operator|(
name|i
operator|=
name|installInitial
argument_list|()
operator|)
argument_list|)
operator|==
name|DITEM_FAILURE
condition|)
return|return
name|i
return|;
name|try_media
label|:
if|if
condition|(
operator|!
name|DEVICE_INIT
argument_list|(
name|mediaDevice
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Unable to initialize selected media. Would you like to\n"
literal|"adjust your media configuration and try again?"
argument_list|)
condition|)
block|{
name|mediaDevice
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
name|DITEM_FAILURE
return|;
else|else
goto|goto
name|try_media
goto|;
block|}
else|else
return|return
name|DITEM_FAILURE
return|;
block|}
comment|/* Now go get it all */
name|i
operator|=
name|distExtractAll
argument_list|(
name|self
argument_list|)
expr_stmt|;
comment|/* When running as init, *now* it's safe to grab the rc.foo vars */
name|installEnvironment
argument_list|()
expr_stmt|;
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
name|DITEM_STATUS
argument_list|(
name|i
argument_list|)
operator|==
name|DITEM_FAILURE
condition|?
literal|"error-install"
else|:
literal|"full-install"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
specifier|static
name|void
name|installConfigure
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Final menu of last resort */
if|if
condition|(
operator|!
name|msgNoYes
argument_list|(
literal|"Visit the general configuration menu for a chance to set\n"
literal|"any last options?"
argument_list|)
condition|)
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuConfigure
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|configRC_conf
argument_list|()
expr_stmt|;
name|sync
argument_list|()
expr_stmt|;
block|}
name|int
name|installFixupBase
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
ifdef|#
directive|ifdef
name|__ia64__
specifier|const
name|char
modifier|*
name|efi_mntpt
decl_stmt|;
endif|#
directive|endif
comment|/* All of this is done only as init, just to be safe */
if|if
condition|(
name|RunningAsInit
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
literal|"/boot/loader.conf"
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|OnVTY
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"# -- sysinstall generated deltas -- #\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"console=\"comconsole\"\n"
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* BOGON #2: We leave /etc in a bad state */
name|chmod
argument_list|(
literal|"/etc"
argument_list|,
literal|0755
argument_list|)
expr_stmt|;
comment|/* BOGON #3: No /var/db/mountdtab complains */
name|Mkdir
argument_list|(
literal|"/var/db"
argument_list|)
expr_stmt|;
name|creat
argument_list|(
literal|"/var/db/mountdtab"
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
comment|/* BOGON #4: /compat created by default in root fs */
name|Mkdir
argument_list|(
literal|"/usr/compat"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"ln -s usr/compat /compat"
argument_list|)
expr_stmt|;
comment|/* BOGON #5: aliases database not built for bin */
name|vsystem
argument_list|(
literal|"newaliases"
argument_list|)
expr_stmt|;
comment|/* BOGON #6: Remove /stand (finally) */
name|vsystem
argument_list|(
literal|"rm -rf /stand"
argument_list|)
expr_stmt|;
comment|/* Now run all the mtree stuff to fix things up */
name|vsystem
argument_list|(
literal|"mtree -deU -f /etc/mtree/BSD.root.dist -p /"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"mtree -deU -f /etc/mtree/BSD.var.dist -p /var"
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"mtree -deU -f /etc/mtree/BSD.usr.dist -p /usr"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__ia64__
comment|/* Move /boot to the the EFI partition and make /boot a link to it. */
name|efi_mntpt
operator|=
operator|(
name|EfiChunk
operator|!=
name|NULL
operator|)
condition|?
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|EfiChunk
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|efi_mntpt
operator|!=
name|NULL
condition|)
block|{
name|vsystem
argument_list|(
literal|"if [ ! -L /boot ]; then mv /boot %s; fi"
argument_list|,
name|efi_mntpt
argument_list|)
expr_stmt|;
name|vsystem
argument_list|(
literal|"if [ ! -e /boot ]; then ln -sf %s/boot /boot; fi"
argument_list|,
name|efi_mntpt
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Skip leading '/' */
comment|/* Make sure the kernel knows which partition is the root file system. */
name|vsystem
argument_list|(
literal|"echo 'vfs.root.mountfrom=\"ufs:/dev/%s\"'>> /boot/loader.conf"
argument_list|,
name|RootChunk
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Do all the last ugly work-arounds here */
block|}
return|return
name|DITEM_SUCCESS
operator||
name|DITEM_RESTORE
return|;
block|}
name|int
name|installFixupKernel
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|,
name|int
name|dists
parameter_list|)
block|{
comment|/* All of this is done only as init, just to be safe */
if|if
condition|(
name|RunningAsInit
condition|)
block|{
comment|/* 	 * Install something as /boot/kernel.  Prefer SMP 	 * over generic--this should handle the case where 	 * both SMP and GENERIC are installed (otherwise we 	 * select the one kernel that was installed). 	 * 	 * NB: we assume any existing kernel has been saved 	 *     already and the /boot/kernel we remove is empty. 	 */
name|vsystem
argument_list|(
literal|"rm -rf /boot/kernel"
argument_list|)
expr_stmt|;
if|#
directive|if
name|WITH_SMP
if|if
condition|(
name|dists
operator|&
name|DIST_KERNEL_SMP
condition|)
name|vsystem
argument_list|(
literal|"mv /boot/SMP /boot/kernel"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|vsystem
argument_list|(
literal|"mv /boot/GENERIC /boot/kernel"
argument_list|)
expr_stmt|;
block|}
return|return
name|DITEM_SUCCESS
operator||
name|DITEM_RESTORE
return|;
block|}
define|#
directive|define
name|QUEUE_YES
value|1
define|#
directive|define
name|QUEUE_NO
value|0
specifier|static
name|int
name|performNewfs
parameter_list|(
name|PartInfo
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|dname
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|char
name|buffer
index|[
name|LINE_MAX
index|]
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|do_newfs
condition|)
block|{
switch|switch
condition|(
name|pi
operator|->
name|newfs_type
condition|)
block|{
case|case
name|NEWFS_UFS
case|:
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|LINE_MAX
argument_list|,
literal|"%s %s %s %s %s"
argument_list|,
name|NEWFS_UFS_CMD
argument_list|,
name|pi
operator|->
name|newfs_data
operator|.
name|newfs_ufs
operator|.
name|softupdates
condition|?
literal|"-U"
else|:
literal|""
argument_list|,
name|pi
operator|->
name|newfs_data
operator|.
name|newfs_ufs
operator|.
name|ufs1
condition|?
literal|"-O1"
else|:
literal|"-O2"
argument_list|,
name|pi
operator|->
name|newfs_data
operator|.
name|newfs_ufs
operator|.
name|user_options
argument_list|,
name|dname
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEWFS_MSDOS
case|:
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|LINE_MAX
argument_list|,
literal|"%s %s"
argument_list|,
name|NEWFS_MSDOS_CMD
argument_list|,
name|dname
argument_list|)
expr_stmt|;
break|break;
case|case
name|NEWFS_CUSTOM
case|:
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|LINE_MAX
argument_list|,
literal|"%s %s"
argument_list|,
name|pi
operator|->
name|newfs_data
operator|.
name|newfs_custom
operator|.
name|command
argument_list|,
name|dname
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|queue
operator|==
name|QUEUE_YES
condition|)
block|{
name|command_shell_add
argument_list|(
name|pi
operator|->
name|mountpoint
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
return|return
operator|(
name|vsystem
argument_list|(
name|buffer
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Go newfs and/or mount all the filesystems we've been asked to */
name|int
name|installFilesystems
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|PartInfo
modifier|*
name|root
decl_stmt|;
name|char
name|dname
index|[
literal|80
index|]
decl_stmt|;
name|Boolean
name|upgrade
init|=
name|FALSE
decl_stmt|;
comment|/* If we've already done this, bail out */
if|if
condition|(
operator|!
name|variable_cmp
argument_list|(
name|DISK_LABELLED
argument_list|,
literal|"written"
argument_list|)
condition|)
return|return
name|DITEM_SUCCESS
return|;
name|upgrade
operator|=
operator|!
name|variable_cmp
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"upgrade"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|checkLabels
argument_list|(
name|TRUE
argument_list|)
condition|)
return|return
name|DITEM_FAILURE
return|;
name|root
operator|=
operator|(
name|RootChunk
operator|!=
name|NULL
operator|)
condition|?
operator|(
name|PartInfo
operator|*
operator|)
name|RootChunk
operator|->
name|private_data
else|:
name|NULL
expr_stmt|;
name|command_clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|SwapChunk
operator|&&
name|RunningAsInit
condition|)
block|{
comment|/* As the very first thing, try to get ourselves some swap space */
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|SwapChunk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fake
operator|&&
operator|!
name|file_readable
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to find device node for %s in /dev!\n"
literal|"The creation of filesystems will be aborted."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
return|;
block|}
if|if
condition|(
operator|!
name|Fake
condition|)
block|{
if|if
condition|(
operator|!
name|swapon
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Added %s as initial swap device"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msgConfirm
argument_list|(
literal|"WARNING!  Unable to swap to %s: %s\n"
literal|"This may cause the installation to fail at some point\n"
literal|"if you don't have a lot of memory."
argument_list|,
name|dname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|RootChunk
operator|&&
name|RunningAsInit
condition|)
block|{
comment|/* Next, create and/or mount the root device */
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|RootChunk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fake
operator|&&
operator|!
name|file_readable
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make device node for %s in /dev!\n"
literal|"The creation of filesystems will be aborted."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|root
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: %s is marked as a root partition but is mounted on %s"
argument_list|,
name|RootChunk
operator|->
name|name
argument_list|,
name|root
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|do_newfs
operator|&&
operator|(
operator|!
name|upgrade
operator|||
operator|!
name|msgNoYes
argument_list|(
literal|"You are upgrading - are you SURE you want to newfs "
literal|"the root partition?"
argument_list|)
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Making a new root filesystem on %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|performNewfs
argument_list|(
name|root
argument_list|,
name|dname
argument_list|,
name|QUEUE_NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make new root filesystem on %s!\n"
literal|"Command returned status %d"
argument_list|,
name|dname
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|upgrade
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Warning:  Using existing root partition."
argument_list|)
expr_stmt|;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Checking integrity of existing %s filesystem."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"fsck_ffs -y %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: fsck returned status of %d for %s.\n"
literal|"This partition may be unsafe to use."
argument_list|,
name|i
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If soft updates was enabled in the editor but we didn't newfs, 	 * use tunefs to update the soft updates flag on the file system. 	 */
if|if
condition|(
operator|!
name|root
operator|->
name|do_newfs
operator|&&
name|root
operator|->
name|newfs_type
operator|==
name|NEWFS_UFS
operator|&&
name|root
operator|->
name|newfs_data
operator|.
name|newfs_ufs
operator|.
name|softupdates
condition|)
block|{
name|i
operator|=
name|vsystem
argument_list|(
literal|"tunefs -n enable %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: Unable to enable soft updates"
literal|" for root file system on %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
comment|/* Switch to block device */
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%s"
argument_list|,
name|RootChunk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mount
argument_list|(
literal|"/mnt"
argument_list|,
name|dname
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to mount the root file system on %s!  Giving up."
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
comment|/* Mount devfs for other partitions to mount */
name|Mkdir
argument_list|(
literal|"/mnt/dev"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Fake
condition|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|4
index|]
decl_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
literal|"fstype"
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|)
operator|+
literal|1
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
literal|"devfs"
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
argument_list|)
operator|+
literal|1
expr_stmt|;
name|iov
index|[
literal|2
index|]
operator|.
name|iov_base
operator|=
literal|"fspath"
expr_stmt|;
name|iov
index|[
literal|2
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|iov
index|[
literal|2
index|]
operator|.
name|iov_base
argument_list|)
operator|+
literal|1
expr_stmt|;
name|iov
index|[
literal|3
index|]
operator|.
name|iov_base
operator|=
literal|"/mnt/dev"
expr_stmt|;
name|iov
index|[
literal|3
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|iov
index|[
literal|3
index|]
operator|.
name|iov_base
argument_list|)
operator|+
literal|1
expr_stmt|;
name|i
operator|=
name|nmount
argument_list|(
name|iov
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"Unable to mount DEVFS (error %d)"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
block|}
block|}
comment|/* Now buzz through the rest of the partitions and mount them too */
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|DITEM_FAILURE
operator||
name|DITEM_RESTORE
return|;
block|}
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|__ia64__
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|part
condition|)
block|{
name|c2
operator|=
name|c1
expr_stmt|;
block|{
elif|#
directive|elif
name|defined
argument_list|(
name|__powerpc__
argument_list|)
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|apple
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
else|#
directive|else
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
endif|#
directive|endif
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private_data
condition|)
block|{
name|PartInfo
modifier|*
name|tmp
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private_data
decl_stmt|;
comment|/* Already did root */
if|if
condition|(
name|c2
operator|==
name|RootChunk
condition|)
continue|continue;
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"%s/dev/%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|do_newfs
operator|&&
operator|(
operator|!
name|upgrade
operator|||
operator|!
name|msgNoYes
argument_list|(
literal|"You are upgrading - are you SURE you"
literal|" want to newfs /dev/%s?"
argument_list|,
name|c2
operator|->
name|name
argument_list|)
operator|)
condition|)
name|performNewfs
argument_list|(
name|tmp
argument_list|,
name|dname
argument_list|,
name|QUEUE_YES
argument_list|)
expr_stmt|;
else|else
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"fsck_ffs -y %s/dev/%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (tmp->soft) 			    command_shell_add(tmp->mountpoint, 			    "tunefs -n enable %s/dev/%s", RunningAsInit ? 			    "/mnt" : "", c2->name);
endif|#
directive|endif
name|command_func_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
name|Mount
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
block|{
name|char
name|fname
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|c2
operator|==
name|SwapChunk
condition|)
continue|continue;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"%s/dev/%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|Fake
operator|||
name|swapon
argument_list|(
name|fname
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Added %s as an additional swap device"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msgConfirm
argument_list|(
literal|"Unable to add %s as a swap device: %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|fat
operator|&&
name|c1
operator|->
name|private_data
operator|&&
operator|(
name|root
operator|->
name|do_newfs
operator|||
name|upgrade
operator|)
condition|)
block|{
name|char
name|name
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s/%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|c1
operator|->
name|private_data
operator|)
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
name|Mkdir
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__ia64__
argument_list|)
elseif|else
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|efi
operator|&&
name|c1
operator|->
name|private_data
condition|)
block|{
name|char
name|bootdir
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|PartInfo
modifier|*
name|pi
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|c1
operator|->
name|private_data
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"%s/dev/%s"
argument_list|,
name|RunningAsInit
condition|?
literal|"/mnt"
else|:
literal|""
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|do_newfs
operator|&&
operator|(
operator|!
name|upgrade
operator|||
operator|!
name|msgNoYes
argument_list|(
literal|"You are upgrading - are you SURE you want to "
literal|"newfs /dev/%s?"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
operator|)
condition|)
name|performNewfs
argument_list|(
name|pi
argument_list|,
name|dname
argument_list|,
name|QUEUE_YES
argument_list|)
expr_stmt|;
name|command_func_add
argument_list|(
name|pi
operator|->
name|mountpoint
argument_list|,
name|Mount_msdosfs
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|command_sort
argument_list|()
expr_stmt|;
name|command_execute
argument_list|()
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
return|return
name|DITEM_SUCCESS
operator||
name|DITEM_RESTORE
return|;
block|}
comment|/* Initialize various user-settable values to their defaults */
name|int
name|installVarDefaults
parameter_list|(
name|dialogMenuItem
modifier|*
name|self
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|ncpus
index|[
literal|10
index|]
decl_stmt|;
comment|/* Set default startup options */
name|cp
operator|=
name|getsysctlbyname
argument_list|(
literal|"kern.osrelease"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_RELNAME
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_CPIO_VERBOSITY
argument_list|,
literal|"high"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_TAPE_BLOCKSIZE
argument_list|,
name|DEFAULT_TAPE_BLOCKSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_INSTALL_ROOT
argument_list|,
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_INSTALL_CFG
argument_list|,
literal|"install.cfg"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_SKIP_PCCARD
argument_list|,
literal|"NO"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
name|cp
operator|=
literal|"/usr/bin/ee"
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_EDITOR
argument_list|,
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_FTP_USER
argument_list|,
literal|"ftp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_BROWSER_PACKAGE
argument_list|,
literal|"links"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_BROWSER_BINARY
argument_list|,
literal|"/usr/local/bin/links"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_FTP_STATE
argument_list|,
literal|"passive"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_NFS_SECURE
argument_list|,
literal|"NO"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_NFS_TCP
argument_list|,
literal|"NO"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_NFS_V3
argument_list|,
literal|"YES"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|OnVTY
condition|)
name|variable_set2
argument_list|(
name|VAR_FIXIT_TTY
argument_list|,
literal|"standard"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|variable_set2
argument_list|(
name|VAR_FIXIT_TTY
argument_list|,
literal|"serial"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_PKG_TMPDIR
argument_list|,
literal|"/var/tmp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_MEDIA_TIMEOUT
argument_list|,
name|itoa
argument_list|(
name|MEDIA_TIMEOUT
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|getpid
argument_list|()
operator|!=
literal|1
condition|)
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"update"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|variable_set2
argument_list|(
name|SYSTEM_STATE
argument_list|,
literal|"init"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_NEWFS_ARGS
argument_list|,
literal|"-b 16384 -f 2048"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_CONSTERM
argument_list|,
literal|"NO"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PC98
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|NCpus
operator|=
name|acpi_detect
argument_list|()
expr_stmt|;
if|if
condition|(
name|NCpus
operator|==
operator|-
literal|1
condition|)
name|NCpus
operator|=
name|biosmptable_detect
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|NCpus
operator|<=
literal|0
condition|)
name|NCpus
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|ncpus
argument_list|,
sizeof|sizeof
argument_list|(
name|ncpus
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|NCpus
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|VAR_NCPUS
argument_list|,
name|ncpus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|DITEM_SUCCESS
return|;
block|}
comment|/* Load the environment up from various system configuration files */
name|void
name|installEnvironment
parameter_list|(
name|void
parameter_list|)
block|{
name|configEnvironmentRC_conf
argument_list|()
expr_stmt|;
if|if
condition|(
name|file_readable
argument_list|(
literal|"/etc/resolv.conf"
argument_list|)
condition|)
name|configEnvironmentResolv
argument_list|(
literal|"/etc/resolv.conf"
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the boot floppy contents into /stand */
name|Boolean
name|copySelf
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|file_readable
argument_list|(
literal|"/boot.help"
argument_list|)
condition|)
name|vsystem
argument_list|(
literal|"cp /boot.help /mnt"
argument_list|)
expr_stmt|;
name|msgWeHaveOutput
argument_list|(
literal|"Copying the boot floppy to /stand on root filesystem"
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"find -x /stand | cpio %s -pdum /mnt"
argument_list|,
name|cpioVerbosity
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Copy returned error status of %d!"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* Copy the /etc files into their rightful place */
if|if
condition|(
name|vsystem
argument_list|(
literal|"cd /mnt/stand; find etc | cpio %s -pdum /mnt"
argument_list|,
name|cpioVerbosity
argument_list|()
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Couldn't copy up the /etc files!"
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|TRUE
return|;
block|}
specifier|static
name|void
name|create_termcap
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|caps
index|[]
init|=
block|{
name|termcap_vt100
block|,
name|termcap_cons25
block|,
name|termcap_cons25_m
block|,
name|termcap_cons25r
block|,
name|termcap_cons25r_m
block|,
name|termcap_cons25l1
block|,
name|termcap_cons25l1_m
block|,
name|termcap_xterm
block|,
name|NULL
block|,     }
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
operator|!
name|file_readable
argument_list|(
name|TERMCAP_FILE
argument_list|)
condition|)
block|{
name|Mkdir
argument_list|(
literal|"/usr/share/misc"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|TERMCAP_FILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to initialize termcap file. Some screen-oriented\nutilities may not work."
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|caps
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
operator|*
operator|(
name|cp
operator|++
operator|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

