begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * copy diverted (or tee'd) packets to a file in 'tcpdump' format  * (ie. this uses the '-lpcap' routines).  *  * example usage:  *	# ipfwpcap -r 8091 divt.log&  *	# ipfw add 2864 divert 8091 ip from 128.432.53.82 to any  *	# ipfw add 2864 divert 8091 ip from any to 128.432.53.82  *  *   the resulting dump file can be read with ...  *	# tcpdump -nX -r divt.log  */
end_comment

begin_comment
comment|/*  * Written by P Kern { pkern [AT] cns.utoronto.ca }  *  * Copyright (c) 2004 University of Toronto. All rights reserved.  * Anyone may use or copy this software except that this copyright  * notice remain intact and that credit is given where it is due.  * The University of Toronto and the author make no warranty and  * accept no liability for this software.  *  * From: Header: /local/src/local.lib/SRC/ipfwpcap/RCS/ipfwpcap.c,v 1.4 2004/01/15 16:19:07 pkern Exp  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* for MAXPATHLEN */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_comment
comment|/* for IP_MAXPACKET */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_comment
comment|/* for IP_MAXPACKET */
end_comment

begin_comment
comment|/* XXX normally defined in config.h */
end_comment

begin_define
define|#
directive|define
name|HAVE_STRLCPY
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_SNPRINTF
value|1
end_define

begin_define
define|#
directive|define
name|HAVE_VSNPRINTF
value|1
end_define

begin_include
include|#
directive|include
file|<pcap-int.h>
end_include

begin_comment
comment|/* see pcap(3) and /usr/src/contrib/libpcap/. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IP_MAXPACKET
end_ifdef

begin_define
define|#
directive|define
name|BUFMAX
value|IP_MAXPACKET
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUFMAX
value|65535
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXPATHLEN
end_ifndef

begin_define
define|#
directive|define
name|MAXPATHLEN
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reflect
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 == write packet back to socket. */
end_comment

begin_decl_stmt
specifier|static
name|ssize_t
name|totbytes
init|=
literal|0
decl_stmt|,
name|maxbytes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ssize_t
name|totpkts
init|=
literal|0
decl_stmt|,
name|maxpkts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prog
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|pidfile
index|[
name|MAXPATHLEN
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * tidy up.  */
end_comment

begin_function
name|void
name|quit
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * do the "paper work"  *	- save my own pid in /var/run/$0.{port#}.pid  */
end_comment

begin_macro
name|okay
argument_list|(
argument|pn
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pn
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|numlen
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|numbuf
index|[
literal|80
index|]
decl_stmt|;
name|numlen
operator|=
sizeof|sizeof
argument_list|(
name|numbuf
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|numbuf
argument_list|,
name|numlen
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|numbuf
argument_list|,
name|numlen
operator|-
literal|1
argument_list|,
literal|"%ld\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|numlen
operator|=
name|strlen
argument_list|(
name|numbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidfile
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|rindex
argument_list|(
name|prog
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|p
operator|==
name|NULL
operator|)
condition|?
name|prog
else|:
name|p
operator|+
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|pidfile
argument_list|,
sizeof|sizeof
argument_list|(
name|pidfile
argument_list|)
operator|-
literal|1
argument_list|,
literal|"%s%s.%d.pid"
argument_list|,
name|_PATH_VARRUN
argument_list|,
name|p
argument_list|,
name|pn
argument_list|)
expr_stmt|;
block|}
name|fd
operator|=
name|open
argument_list|(
name|pidfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|21
argument_list|)
expr_stmt|;
block|}
name|siginterrupt
argument_list|(
name|SIGTERM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|siginterrupt
argument_list|(
name|SIGHUP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|quit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|quit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|quit
argument_list|)
expr_stmt|;
name|n
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|numbuf
argument_list|,
name|numlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|23
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ \n\ usage:\n\     %s [-dr] [-b maxbytes] [-p maxpkts] [-P pidfile] portnum dumpfile\n\ \n\ where:\n\ 	'-d'  = enable debugging messages.\n\ 	'-r'  = reflect. write packets back to the divert socket.\n\ 		(ie. simulate the original intent of \"ipfw tee\").\n\ 	'-rr' = indicate that it is okay to quit if packet-count or\n\ 		byte-count limits are reached (see the NOTE below\n\ 		about what this implies).\n\ 	'-b bytcnt'   = stop dumping after {bytcnt} bytes.\n\ 	'-p pktcnt'   = stop dumping after {pktcnt} packets.\n\ 	'-P pidfile'  = alternate file to store the PID\n\ 			(default: /var/run/%s.{portnum}.pid).\n\ \n\ 	portnum  = divert(4) socket port number.\n\ 	dumpfile = file to write captured packets (tcpdump format).\n\ 		   (specify '-' to write packets to stdout).\n\ \n\ "
argument_list|,
name|prog
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ The '-r' option should not be necessary, but because \"ipfw tee\" is broken\n\ (see BUGS in ipfw(8) for details) this feature can be used along with\n\ an \"ipfw divert\" rule to simulate the original intent of \"ipfw tee\".\n\ \n\ NOTE: With an \"ipfw divert\" rule, diverted packets will silently\n\       disappear if there is nothing listening to the divert socket.\n\ \n\ "
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
name|av
index|[]
decl_stmt|;
block|{
name|int
name|r
decl_stmt|,
name|sd
decl_stmt|,
name|portnum
decl_stmt|,
name|l
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|errflg
init|=
literal|0
decl_stmt|;
name|int
name|nfd
decl_stmt|;
name|fd_set
name|rds
decl_stmt|;
name|ssize_t
name|nr
decl_stmt|;
name|char
modifier|*
name|dumpf
decl_stmt|,
name|buf
index|[
name|BUFMAX
index|]
decl_stmt|;
name|pcap_t
modifier|*
name|p
decl_stmt|;
name|pcap_dumper_t
modifier|*
name|dp
decl_stmt|;
name|struct
name|pcap_pkthdr
name|phd
decl_stmt|;
name|prog
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"drb:p:P:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|r
condition|)
block|{
case|case
literal|'d'
case|:
name|debug
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|reflect
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|maxbytes
operator|=
operator|(
name|ssize_t
operator|)
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|maxpkts
operator|=
operator|(
name|ssize_t
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|strcpy
argument_list|(
name|pidfile
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|errflg
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|ac
operator|-
name|optind
operator|)
operator|!=
literal|2
operator|||
name|errflg
condition|)
name|usage
argument_list|()
expr_stmt|;
name|portnum
operator|=
name|atoi
argument_list|(
name|av
index|[
name|optind
operator|++
index|]
argument_list|)
expr_stmt|;
name|dumpf
operator|=
name|av
index|[
name|optind
index|]
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bind to %d.\ndump to '%s'.\n"
argument_list|,
name|portnum
argument_list|,
name|dumpf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|socket
argument_list|(
name|PF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_DIVERT
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"socket(DIVERT)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|sd
operator|=
name|r
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|portnum
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"bind(divert)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|pcap_open_dead
argument_list|(
name|DLT_RAW
argument_list|,
name|BUFMAX
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pcap_dump_open
argument_list|(
name|p
argument_list|,
name|dumpf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
name|pcap_perror
argument_list|(
name|p
argument_list|,
name|dumpf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|okay
argument_list|(
name|portnum
argument_list|)
expr_stmt|;
name|nfd
operator|=
name|sd
operator|+
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|rds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sd
argument_list|,
operator|&
name|rds
argument_list|)
expr_stmt|;
name|r
operator|=
name|select
argument_list|(
name|nfd
argument_list|,
operator|&
name|rds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|11
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|sd
argument_list|,
operator|&
name|rds
argument_list|)
condition|)
comment|/* hmm. no work. */
continue|continue;
comment|/* 		 * use recvfrom(3 and sendto(3) as in natd(8). 		 * see /usr/src/sbin/natd/natd.c 		 * see ipfw(8) about using 'divert' and 'tee'. 		 */
comment|/* 		 * read packet. 		 */
name|l
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|nr
operator|=
name|recvfrom
argument_list|(
name|sd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recvfrom(%d) = %d (%d)\n"
argument_list|,
name|sd
argument_list|,
name|nr
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|perror
argument_list|(
literal|"recvfrom(sd)"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nr
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|reflect
condition|)
block|{
comment|/* 			 * write packet back so it can continue 			 * being processed by any further IPFW rules. 			 */
name|l
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|r
operator|=
name|sendto
argument_list|(
name|sd
argument_list|,
name|buf
argument_list|,
name|nr
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  sendto(%d) = %d\n"
argument_list|,
name|sd
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"sendto(sd)"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|13
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * check maximums, if any. 		 * but don't quit if must continue reflecting packets. 		 */
if|if
condition|(
name|maxpkts
condition|)
block|{
name|totpkts
operator|++
expr_stmt|;
if|if
condition|(
name|totpkts
operator|>
name|maxpkts
condition|)
block|{
if|if
condition|(
name|reflect
operator|==
literal|1
condition|)
continue|continue;
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|maxbytes
condition|)
block|{
name|totbytes
operator|+=
name|nr
expr_stmt|;
if|if
condition|(
name|totbytes
operator|>
name|maxbytes
condition|)
block|{
if|if
condition|(
name|reflect
operator|==
literal|1
condition|)
continue|continue;
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * save packet in tcpdump(1) format. see pcap(3). 		 * divert packets are fully assembled. see ipfw(8). 		 */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
operator|(
name|phd
operator|.
name|ts
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|phd
operator|.
name|caplen
operator|=
name|phd
operator|.
name|len
operator|=
name|nr
expr_stmt|;
name|pcap_dump
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|dp
argument_list|,
operator|&
name|phd
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|dp
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|dumpf
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|14
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
operator|(
name|FILE
operator|*
operator|)
name|dp
argument_list|)
expr_stmt|;
block|}
name|quit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

