begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: rpcb_svc_com.c,v 1.9 2002/11/08 00:16:39 fvdl Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*  * Sun RPC is a product of Sun Microsystems, Inc. and is provided for  * unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify Sun RPC without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *   * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE  * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR  * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  *   * Sun RPC is provided with no support and without any obligation on the  * part of Sun Microsystems, Inc. to assist in its use, correction,  * modification or enhancement.  *   * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC  * OR ANY PART THEREOF.  *   * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *   * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986 - 1991 by Sun Microsystems, Inc.  */
end_comment

begin_comment
comment|/* #ident	"@(#)rpcb_svc_com.c	1.18	94/05/02 SMI" */
end_comment

begin_comment
comment|/*  * rpcb_svc_com.c  * The commom server procedure for the rpcbind.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcb_prot.h>
end_include

begin_include
include|#
directive|include
file|<rpc/svc_dg.h>
end_include

begin_include
include|#
directive|include
file|<netconfig.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PORTMAP
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<rpc/pmap_prot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PORTMAP */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"rpcbind.h"
end_include

begin_define
define|#
directive|define
name|RPC_BUF_MAX
value|65536
end_define

begin_comment
comment|/* can be raised if required */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nullstring
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rpcb_rmtcalls
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|rmtcallfd_list
block|{
name|int
name|fd
decl_stmt|;
name|SVCXPRT
modifier|*
name|xprt
decl_stmt|;
name|char
modifier|*
name|netid
decl_stmt|;
name|struct
name|rmtcallfd_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NFORWARD
value|64
end_define

begin_define
define|#
directive|define
name|MAXTIME_OFF
value|300
end_define

begin_comment
comment|/* 5 minutes */
end_comment

begin_struct
struct|struct
name|finfo
block|{
name|int
name|flag
decl_stmt|;
define|#
directive|define
name|FINFO_ACTIVE
value|0x1
name|u_int32_t
name|caller_xid
decl_stmt|;
name|struct
name|netbuf
modifier|*
name|caller_addr
decl_stmt|;
name|u_int32_t
name|forward_xid
decl_stmt|;
name|int
name|forward_fd
decl_stmt|;
name|char
modifier|*
name|uaddr
decl_stmt|;
name|rpcproc_t
name|reply_type
decl_stmt|;
name|rpcvers_t
name|versnum
decl_stmt|;
name|time_t
name|time
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|finfo
name|FINFO
index|[
name|NFORWARD
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool_t
name|xdr_encap_parms
name|__P
argument_list|(
operator|(
name|XDR
operator|*
operator|,
expr|struct
name|encap_parms
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool_t
name|xdr_rmtcall_args
name|__P
argument_list|(
operator|(
name|XDR
operator|*
operator|,
expr|struct
name|r_rmtcall_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool_t
name|xdr_rmtcall_result
name|__P
argument_list|(
operator|(
name|XDR
operator|*
operator|,
expr|struct
name|r_rmtcall_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool_t
name|xdr_opaque_parms
name|__P
argument_list|(
operator|(
name|XDR
operator|*
operator|,
expr|struct
name|r_rmtcall_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|find_rmtcallfd_by_netid
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|SVCXPRT
modifier|*
name|find_rmtcallxprt_by_fd
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|forward_register
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|,
expr|struct
name|netbuf
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|rpcproc_t
operator|,
name|rpcvers_t
operator|,
name|u_int32_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|finfo
modifier|*
name|forward_find
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_slot_by_xid
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_slot_by_index
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|netbufcmp
name|__P
argument_list|(
operator|(
expr|struct
name|netbuf
operator|*
operator|,
expr|struct
name|netbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|netbuf
modifier|*
name|netbufdup
name|__P
argument_list|(
operator|(
expr|struct
name|netbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|netbuffree
name|__P
argument_list|(
operator|(
expr|struct
name|netbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_rmtcalls
name|__P
argument_list|(
operator|(
expr|struct
name|pollfd
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|xprt_set_caller
name|__P
argument_list|(
operator|(
name|SVCXPRT
operator|*
operator|,
expr|struct
name|finfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_svcsyserr
name|__P
argument_list|(
operator|(
name|SVCXPRT
operator|*
operator|,
expr|struct
name|finfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_reply
name|__P
argument_list|(
operator|(
name|int
operator|,
name|SVCXPRT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|find_versions
name|__P
argument_list|(
operator|(
name|rpcprog_t
operator|,
name|char
operator|*
operator|,
name|rpcvers_t
operator|*
operator|,
name|rpcvers_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rpcblist_ptr
name|find_service
name|__P
argument_list|(
operator|(
name|rpcprog_t
operator|,
name|rpcvers_t
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|getowner
name|__P
argument_list|(
operator|(
name|SVCXPRT
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_pmaplist
name|__P
argument_list|(
operator|(
name|RPCB
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|del_pmaplist
name|__P
argument_list|(
operator|(
name|RPCB
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Set a mapping of program, version, netid  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
modifier|*
name|rpcbproc_set_com
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
name|__unused
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|,
name|rpcvers_t
name|rpcbversnum
parameter_list|)
block|{
name|RPCB
modifier|*
name|regp
init|=
operator|(
name|RPCB
operator|*
operator|)
name|arg
decl_stmt|;
specifier|static
name|bool_t
name|ans
decl_stmt|;
name|char
name|owner
index|[
literal|64
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|RPCBIND_DEBUG
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RPCB_SET request for (%lu, %lu, %s, %s) : "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|regp
operator|->
name|r_prog
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|regp
operator|->
name|r_vers
argument_list|,
name|regp
operator|->
name|r_netid
argument_list|,
name|regp
operator|->
name|r_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ans
operator|=
name|map_set
argument_list|(
name|regp
argument_list|,
name|getowner
argument_list|(
name|transp
argument_list|,
name|owner
argument_list|,
sizeof|sizeof
name|owner
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RPCBIND_DEBUG
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|ans
operator|==
name|TRUE
condition|?
literal|"succeeded"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX: should have used some defined constant here */
name|rpcbs_set
argument_list|(
name|rpcbversnum
operator|-
literal|2
argument_list|,
name|ans
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
operator|&
name|ans
return|;
block|}
end_function

begin_function
name|bool_t
name|map_set
parameter_list|(
name|RPCB
modifier|*
name|regp
parameter_list|,
name|char
modifier|*
name|owner
parameter_list|)
block|{
name|RPCB
name|reg
decl_stmt|,
modifier|*
name|a
decl_stmt|;
name|rpcblist_ptr
name|rbl
decl_stmt|,
name|fnd
decl_stmt|;
name|reg
operator|=
operator|*
name|regp
expr_stmt|;
comment|/* 	 * check to see if already used 	 * find_service returns a hit even if 	 * the versions don't match, so check for it 	 */
name|fnd
operator|=
name|find_service
argument_list|(
name|reg
operator|.
name|r_prog
argument_list|,
name|reg
operator|.
name|r_vers
argument_list|,
name|reg
operator|.
name|r_netid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnd
operator|&&
operator|(
name|fnd
operator|->
name|rpcb_map
operator|.
name|r_vers
operator|==
name|reg
operator|.
name|r_vers
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fnd
operator|->
name|rpcb_map
operator|.
name|r_addr
argument_list|,
name|reg
operator|.
name|r_addr
argument_list|)
condition|)
comment|/* 			 * if these match then it is already 			 * registered so just say "OK". 			 */
return|return
operator|(
name|TRUE
operator|)
return|;
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * add to the end of the list 	 */
name|rbl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RPCBLIST
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbl
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|a
operator|=
operator|&
operator|(
name|rbl
operator|->
name|rpcb_map
operator|)
expr_stmt|;
name|a
operator|->
name|r_prog
operator|=
name|reg
operator|.
name|r_prog
expr_stmt|;
name|a
operator|->
name|r_vers
operator|=
name|reg
operator|.
name|r_vers
expr_stmt|;
name|a
operator|->
name|r_netid
operator|=
name|strdup
argument_list|(
name|reg
operator|.
name|r_netid
argument_list|)
expr_stmt|;
name|a
operator|->
name|r_addr
operator|=
name|strdup
argument_list|(
name|reg
operator|.
name|r_addr
argument_list|)
expr_stmt|;
name|a
operator|->
name|r_owner
operator|=
name|strdup
argument_list|(
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|r_addr
operator|||
operator|!
name|a
operator|->
name|r_netid
operator|||
operator|!
name|a
operator|->
name|r_owner
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|r_netid
condition|)
name|free
argument_list|(
name|a
operator|->
name|r_netid
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|r_addr
condition|)
name|free
argument_list|(
name|a
operator|->
name|r_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|r_owner
condition|)
name|free
argument_list|(
name|a
operator|->
name|r_owner
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rbl
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|rbl
operator|->
name|rpcb_next
operator|=
operator|(
name|rpcblist_ptr
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|list_rbl
operator|==
name|NULL
condition|)
block|{
name|list_rbl
operator|=
name|rbl
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|fnd
operator|=
name|list_rbl
init|;
name|fnd
operator|->
name|rpcb_next
condition|;
name|fnd
operator|=
name|fnd
operator|->
name|rpcb_next
control|)
empty_stmt|;
name|fnd
operator|->
name|rpcb_next
operator|=
name|rbl
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PORTMAP
operator|(
name|void
operator|)
name|add_pmaplist
argument_list|(
name|regp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unset a mapping of program, version, netid  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
modifier|*
name|rpcbproc_unset_com
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
name|__unused
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|,
name|rpcvers_t
name|rpcbversnum
parameter_list|)
block|{
name|RPCB
modifier|*
name|regp
init|=
operator|(
name|RPCB
operator|*
operator|)
name|arg
decl_stmt|;
specifier|static
name|bool_t
name|ans
decl_stmt|;
name|char
name|owner
index|[
literal|64
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|RPCBIND_DEBUG
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RPCB_UNSET request for (%lu, %lu, %s) : "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|regp
operator|->
name|r_prog
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|regp
operator|->
name|r_vers
argument_list|,
name|regp
operator|->
name|r_netid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ans
operator|=
name|map_unset
argument_list|(
name|regp
argument_list|,
name|getowner
argument_list|(
name|transp
argument_list|,
name|owner
argument_list|,
sizeof|sizeof
name|owner
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RPCBIND_DEBUG
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|ans
operator|==
name|TRUE
condition|?
literal|"succeeded"
else|:
literal|"failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX: should have used some defined constant here */
name|rpcbs_unset
argument_list|(
name|rpcbversnum
operator|-
literal|2
argument_list|,
name|ans
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
operator|&
name|ans
return|;
block|}
end_function

begin_function
name|bool_t
name|map_unset
parameter_list|(
name|RPCB
modifier|*
name|regp
parameter_list|,
name|char
modifier|*
name|owner
parameter_list|)
block|{
name|int
name|ans
init|=
literal|0
decl_stmt|;
name|rpcblist_ptr
name|rbl
decl_stmt|,
name|prev
decl_stmt|,
name|tmp
decl_stmt|;
if|if
condition|(
name|owner
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|prev
operator|=
name|NULL
operator|,
name|rbl
operator|=
name|list_rbl
init|;
name|rbl
condition|;
comment|/* cstyle */
control|)
block|{
if|if
condition|(
operator|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_prog
operator|!=
name|regp
operator|->
name|r_prog
operator|)
operator|||
operator|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_vers
operator|!=
name|regp
operator|->
name|r_vers
operator|)
operator|||
operator|(
name|regp
operator|->
name|r_netid
index|[
literal|0
index|]
operator|&&
name|strcasecmp
argument_list|(
name|regp
operator|->
name|r_netid
argument_list|,
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_netid
argument_list|)
operator|)
condition|)
block|{
comment|/* both rbl& prev move forwards */
name|prev
operator|=
name|rbl
expr_stmt|;
name|rbl
operator|=
name|rbl
operator|->
name|rpcb_next
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Check whether appropriate uid. Unset only 		 * if superuser or the owner itself. 		 */
if|if
condition|(
name|strcmp
argument_list|(
name|owner
argument_list|,
literal|"superuser"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_owner
argument_list|,
name|owner
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* found it; rbl moves forward, prev stays */
name|ans
operator|=
literal|1
expr_stmt|;
name|tmp
operator|=
name|rbl
expr_stmt|;
name|rbl
operator|=
name|rbl
operator|->
name|rpcb_next
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|list_rbl
operator|=
name|rbl
expr_stmt|;
else|else
name|prev
operator|->
name|rpcb_next
operator|=
name|rbl
expr_stmt|;
name|free
argument_list|(
name|tmp
operator|->
name|rpcb_map
operator|.
name|r_addr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
operator|->
name|rpcb_map
operator|.
name|r_netid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
operator|->
name|rpcb_map
operator|.
name|r_owner
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PORTMAP
if|if
condition|(
name|ans
condition|)
operator|(
name|void
operator|)
name|del_pmaplist
argument_list|(
name|regp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We return 1 either when the entry was not there or it 	 * was able to unset it.  It can come to this point only if 	 * atleast one of the conditions is true. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|delete_prog
parameter_list|(
name|unsigned
name|int
name|prog
parameter_list|)
block|{
name|RPCB
name|reg
decl_stmt|;
specifier|register
name|rpcblist_ptr
name|rbl
decl_stmt|;
for|for
control|(
name|rbl
operator|=
name|list_rbl
init|;
name|rbl
operator|!=
name|NULL
condition|;
name|rbl
operator|=
name|rbl
operator|->
name|rpcb_next
control|)
block|{
if|if
condition|(
operator|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_prog
operator|!=
name|prog
operator|)
condition|)
continue|continue;
if|if
condition|(
name|is_bound
argument_list|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_netid
argument_list|,
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_addr
argument_list|)
condition|)
continue|continue;
name|reg
operator|.
name|r_prog
operator|=
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_prog
expr_stmt|;
name|reg
operator|.
name|r_vers
operator|=
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_vers
expr_stmt|;
name|reg
operator|.
name|r_netid
operator|=
name|strdup
argument_list|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_netid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|map_unset
argument_list|(
operator|&
name|reg
argument_list|,
literal|"superuser"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reg
operator|.
name|r_netid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|rpcbproc_getaddr_com
parameter_list|(
name|RPCB
modifier|*
name|regp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
name|__unused
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|,
name|rpcvers_t
name|rpcbversnum
parameter_list|,
name|rpcvers_t
name|verstype
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|uaddr
decl_stmt|;
name|char
modifier|*
name|saddr
init|=
name|NULL
decl_stmt|;
name|rpcblist_ptr
name|fnd
decl_stmt|;
if|if
condition|(
name|uaddr
operator|!=
name|NULL
operator|&&
name|uaddr
operator|!=
name|nullstring
condition|)
block|{
name|free
argument_list|(
name|uaddr
argument_list|)
expr_stmt|;
name|uaddr
operator|=
name|NULL
expr_stmt|;
block|}
name|fnd
operator|=
name|find_service
argument_list|(
name|regp
operator|->
name|r_prog
argument_list|,
name|regp
operator|->
name|r_vers
argument_list|,
name|transp
operator|->
name|xp_netid
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnd
operator|&&
operator|(
operator|(
name|verstype
operator|==
name|RPCB_ALLVERS
operator|)
operator|||
operator|(
name|regp
operator|->
name|r_vers
operator|==
name|fnd
operator|->
name|rpcb_map
operator|.
name|r_vers
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|regp
operator|->
name|r_addr
operator|)
operator|!=
literal|'\0'
condition|)
block|{
comment|/* may contain a hint about */
name|saddr
operator|=
name|regp
operator|->
name|r_addr
expr_stmt|;
comment|/* the interface that we    */
block|}
comment|/* should use */
if|if
condition|(
operator|!
operator|(
name|uaddr
operator|=
name|mergeaddr
argument_list|(
name|transp
argument_list|,
name|transp
operator|->
name|xp_netid
argument_list|,
name|fnd
operator|->
name|rpcb_map
operator|.
name|r_addr
argument_list|,
name|saddr
argument_list|)
operator|)
condition|)
block|{
comment|/* Try whatever we have */
name|uaddr
operator|=
name|strdup
argument_list|(
name|fnd
operator|->
name|rpcb_map
operator|.
name|r_addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|uaddr
index|[
literal|0
index|]
condition|)
block|{
comment|/* 			 * The server died.  Unset all versions of this prog. 			 */
name|delete_prog
argument_list|(
name|regp
operator|->
name|r_prog
argument_list|)
expr_stmt|;
name|uaddr
operator|=
name|nullstring
expr_stmt|;
block|}
block|}
else|else
block|{
name|uaddr
operator|=
name|nullstring
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RPCBIND_DEBUG
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getaddr: %s\n"
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX: should have used some defined constant here */
name|rpcbs_getaddr
argument_list|(
name|rpcbversnum
operator|-
literal|2
argument_list|,
name|regp
operator|->
name|r_prog
argument_list|,
name|regp
operator|->
name|r_vers
argument_list|,
name|transp
operator|->
name|xp_netid
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
operator|&
name|uaddr
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
modifier|*
name|rpcbproc_gettime_com
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
name|__unused
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
name|__unused
parameter_list|,
name|rpcvers_t
name|rpcbversnum
name|__unused
parameter_list|)
block|{
specifier|static
name|time_t
name|curtime
decl_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
operator|&
name|curtime
return|;
block|}
end_function

begin_comment
comment|/*  * Convert uaddr to taddr. Should be used only by  * local servers/clients. (kernel level stuff only)  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
modifier|*
name|rpcbproc_uaddr2taddr_com
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
name|__unused
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|,
name|rpcvers_t
name|rpcbversnum
name|__unused
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|uaddrp
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|nconf
decl_stmt|;
specifier|static
name|struct
name|netbuf
name|nbuf
decl_stmt|;
specifier|static
name|struct
name|netbuf
modifier|*
name|taddr
decl_stmt|;
if|if
condition|(
name|taddr
condition|)
block|{
name|free
argument_list|(
name|taddr
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|taddr
argument_list|)
expr_stmt|;
name|taddr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|nconf
operator|=
name|rpcbind_get_conf
argument_list|(
name|transp
operator|->
name|xp_netid
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|taddr
operator|=
name|uaddr2taddr
argument_list|(
name|nconf
argument_list|,
operator|*
name|uaddrp
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|netbuf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
operator|&
name|nbuf
return|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
name|taddr
return|;
block|}
end_function

begin_comment
comment|/*  * Convert taddr to uaddr. Should be used only by  * local servers/clients. (kernel level stuff only)  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
modifier|*
name|rpcbproc_taddr2uaddr_com
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
name|__unused
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|,
name|rpcvers_t
name|rpcbversnum
name|__unused
parameter_list|)
block|{
name|struct
name|netbuf
modifier|*
name|taddr
init|=
operator|(
expr|struct
name|netbuf
operator|*
operator|)
name|arg
decl_stmt|;
specifier|static
name|char
modifier|*
name|uaddr
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|nconf
decl_stmt|;
ifdef|#
directive|ifdef
name|CHEW_FDS
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|uaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|uaddr
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* CHEW_FDS */
if|if
condition|(
name|uaddr
operator|!=
name|NULL
operator|&&
name|uaddr
operator|!=
name|nullstring
condition|)
block|{
name|free
argument_list|(
name|uaddr
argument_list|)
expr_stmt|;
name|uaddr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|nconf
operator|=
name|rpcbind_get_conf
argument_list|(
name|transp
operator|->
name|xp_netid
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|uaddr
operator|=
name|taddr2uaddr
argument_list|(
name|nconf
argument_list|,
name|taddr
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|uaddr
operator|=
name|nullstring
expr_stmt|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
operator|&
name|uaddr
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdr_encap_parms
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|struct
name|encap_parms
modifier|*
name|epp
parameter_list|)
block|{
return|return
operator|(
name|xdr_bytes
argument_list|(
name|xdrs
argument_list|,
operator|&
operator|(
name|epp
operator|->
name|args
operator|)
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
operator|(
name|epp
operator|->
name|arglen
operator|)
argument_list|,
operator|~
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XDR remote call arguments.  It ignores the address part.  * written for XDR_DECODE direction only  */
end_comment

begin_function
specifier|static
name|bool_t
name|xdr_rmtcall_args
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|struct
name|r_rmtcall_args
modifier|*
name|cap
parameter_list|)
block|{
comment|/* does not get the address or the arguments */
if|if
condition|(
name|xdr_u_int32_t
argument_list|(
name|xdrs
argument_list|,
operator|&
operator|(
name|cap
operator|->
name|rmt_prog
operator|)
argument_list|)
operator|&&
name|xdr_u_int32_t
argument_list|(
name|xdrs
argument_list|,
operator|&
operator|(
name|cap
operator|->
name|rmt_vers
operator|)
argument_list|)
operator|&&
name|xdr_u_int32_t
argument_list|(
name|xdrs
argument_list|,
operator|&
operator|(
name|cap
operator|->
name|rmt_proc
operator|)
argument_list|)
condition|)
block|{
return|return
operator|(
name|xdr_encap_parms
argument_list|(
name|xdrs
argument_list|,
operator|&
operator|(
name|cap
operator|->
name|rmt_args
operator|)
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XDR remote call results along with the address.  Ignore  * program number, version  number and proc number.  * Written for XDR_ENCODE direction only.  */
end_comment

begin_function
specifier|static
name|bool_t
name|xdr_rmtcall_result
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|struct
name|r_rmtcall_args
modifier|*
name|cap
parameter_list|)
block|{
name|bool_t
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|PORTMAP
if|if
condition|(
name|cap
operator|->
name|rmt_localvers
operator|==
name|PMAPVERS
condition|)
block|{
name|int
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|,
name|h4
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|u_long
name|port
decl_stmt|;
comment|/* interpret the universal address for TCP/IP */
if|if
condition|(
name|sscanf
argument_list|(
name|cap
operator|->
name|rmt_uaddr
argument_list|,
literal|"%d.%d.%d.%d.%d.%d"
argument_list|,
operator|&
name|h1
argument_list|,
operator|&
name|h2
argument_list|,
operator|&
name|h3
argument_list|,
operator|&
name|h4
argument_list|,
operator|&
name|p1
argument_list|,
operator|&
name|p2
argument_list|)
operator|!=
literal|6
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|port
operator|=
operator|(
operator|(
name|p1
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|p2
operator|&
literal|0xff
operator|)
expr_stmt|;
name|result
operator|=
name|xdr_u_long
argument_list|(
name|xdrs
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|(
name|cap
operator|->
name|rmt_localvers
operator|==
name|RPCBVERS
operator|)
operator|||
operator|(
name|cap
operator|->
name|rmt_localvers
operator|==
name|RPCBVERS4
operator|)
condition|)
block|{
name|result
operator|=
name|xdr_wrapstring
argument_list|(
name|xdrs
argument_list|,
operator|&
operator|(
name|cap
operator|->
name|rmt_uaddr
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|TRUE
condition|)
return|return
operator|(
name|xdr_encap_parms
argument_list|(
name|xdrs
argument_list|,
operator|&
operator|(
name|cap
operator|->
name|rmt_args
operator|)
argument_list|)
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * only worries about the struct encap_parms part of struct r_rmtcall_args.  * The arglen must already be set!!  */
end_comment

begin_function
specifier|static
name|bool_t
name|xdr_opaque_parms
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|struct
name|r_rmtcall_args
modifier|*
name|cap
parameter_list|)
block|{
return|return
operator|(
name|xdr_opaque
argument_list|(
name|xdrs
argument_list|,
name|cap
operator|->
name|rmt_args
operator|.
name|args
argument_list|,
name|cap
operator|->
name|rmt_args
operator|.
name|arglen
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|rmtcallfd_list
modifier|*
name|rmthead
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rmtcallfd_list
modifier|*
name|rmttail
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|create_rmtcall_fd
parameter_list|(
name|struct
name|netconfig
modifier|*
name|nconf
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|rmtcallfd_list
modifier|*
name|rmt
decl_stmt|;
name|SVCXPRT
modifier|*
name|xprt
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|__rpc_nconf2fd
argument_list|(
name|nconf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"create_rmtcall_fd: couldn't open \"%s\" (errno %d)\n"
argument_list|,
name|nconf
operator|->
name|nc_device
argument_list|,
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|xprt
operator|=
name|svc_tli_create
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|t_bind
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xprt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"create_rmtcall_fd: svc_tli_create failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rmt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rmtcallfd_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmt
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"create_rmtcall_fd: no memory!"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rmt
operator|->
name|xprt
operator|=
name|xprt
expr_stmt|;
name|rmt
operator|->
name|netid
operator|=
name|strdup
argument_list|(
name|nconf
operator|->
name|nc_netid
argument_list|)
expr_stmt|;
name|xprt
operator|->
name|xp_netid
operator|=
name|rmt
operator|->
name|netid
expr_stmt|;
name|rmt
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|rmt
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rmthead
operator|==
name|NULL
condition|)
block|{
name|rmthead
operator|=
name|rmt
expr_stmt|;
name|rmttail
operator|=
name|rmt
expr_stmt|;
block|}
else|else
block|{
name|rmttail
operator|->
name|next
operator|=
name|rmt
expr_stmt|;
name|rmttail
operator|=
name|rmt
expr_stmt|;
block|}
comment|/* XXX not threadsafe */
if|if
condition|(
name|fd
operator|>
name|svc_maxfd
condition|)
name|svc_maxfd
operator|=
name|fd
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|svc_fdset
argument_list|)
expr_stmt|;
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_rmtcallfd_by_netid
parameter_list|(
name|char
modifier|*
name|netid
parameter_list|)
block|{
name|struct
name|rmtcallfd_list
modifier|*
name|rmt
decl_stmt|;
for|for
control|(
name|rmt
operator|=
name|rmthead
init|;
name|rmt
operator|!=
name|NULL
condition|;
name|rmt
operator|=
name|rmt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|netid
argument_list|,
name|rmt
operator|->
name|netid
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|rmt
operator|->
name|fd
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|SVCXPRT
modifier|*
name|find_rmtcallxprt_by_fd
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|struct
name|rmtcallfd_list
modifier|*
name|rmt
decl_stmt|;
for|for
control|(
name|rmt
operator|=
name|rmthead
init|;
name|rmt
operator|!=
name|NULL
condition|;
name|rmt
operator|=
name|rmt
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fd
operator|==
name|rmt
operator|->
name|fd
condition|)
block|{
return|return
operator|(
name|rmt
operator|->
name|xprt
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Call a remote procedure service.  This procedure is very quiet when things  * go wrong.  The proc is written to support broadcast rpc.  In the broadcast  * case, a machine should shut-up instead of complain, lest the requestor be  * overrun with complaints at the expense of not hearing a valid reply.  * When receiving a request and verifying that the service exists, we  *  *	receive the request  *  *	open a new TLI endpoint on the same transport on which we received  *	the original request  *  *	remember the original request's XID (which requires knowing the format  *	of the svc_dg_data structure)  *  *	forward the request, with a new XID, to the requested service,  *	remembering the XID used to send this request (for later use in  *	reassociating the answer with the original request), the requestor's  *	address, the file descriptor on which the forwarded request is  *	made and the service's address.  *  *	mark the file descriptor on which we anticipate receiving a reply from  *	the service and one to select for in our private svc_run procedure  *  * At some time in the future, a reply will be received from the service to  * which we forwarded the request.  At that time, we detect that the socket  * used was for forwarding (by looking through the finfo structures to see  * whether the fd corresponds to one of those) and call handle_reply() to  *  *	receive the reply  *  *	bundle the reply, along with the service's universal address  *  *	create a SVCXPRT structure and use a version of svc_sendreply  *	that allows us to specify the reply XID and destination, send the reply  *	to the original requestor.  */
end_comment

begin_function
name|void
name|rpcbproc_callit_com
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|,
name|rpcproc_t
name|reply_type
parameter_list|,
name|rpcvers_t
name|versnum
parameter_list|)
block|{
specifier|register
name|rpcblist_ptr
name|rbl
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|nconf
decl_stmt|;
name|struct
name|netbuf
modifier|*
name|caller
decl_stmt|;
name|struct
name|r_rmtcall_args
name|a
decl_stmt|;
name|char
modifier|*
name|buf_alloc
init|=
name|NULL
decl_stmt|,
modifier|*
name|outbufp
decl_stmt|;
name|char
modifier|*
name|outbuf_alloc
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|RPC_BUF_MAX
index|]
decl_stmt|,
name|outbuf
index|[
name|RPC_BUF_MAX
index|]
decl_stmt|;
name|struct
name|netbuf
modifier|*
name|na
init|=
operator|(
expr|struct
name|netbuf
operator|*
operator|)
name|NULL
decl_stmt|;
name|struct
name|rpc_msg
name|call_msg
decl_stmt|;
name|int
name|outlen
decl_stmt|;
name|u_int
name|sendsz
decl_stmt|;
name|XDR
name|outxdr
decl_stmt|;
name|AUTH
modifier|*
name|auth
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|uaddr
decl_stmt|,
modifier|*
name|m_uaddr
init|=
name|NULL
decl_stmt|,
modifier|*
name|local_uaddr
init|=
name|NULL
decl_stmt|;
name|u_int32_t
modifier|*
name|xidp
decl_stmt|;
name|struct
name|__rpc_sockinfo
name|si
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|localsa
decl_stmt|;
name|struct
name|netbuf
name|tbuf
decl_stmt|;
if|if
condition|(
operator|!
name|__rpc_fd2sockinfo
argument_list|(
name|transp
operator|->
name|xp_fd
argument_list|,
operator|&
name|si
argument_list|)
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|si
operator|.
name|si_socktype
operator|!=
name|SOCK_DGRAM
condition|)
return|return;
comment|/* Only datagram type accepted */
name|sendsz
operator|=
name|__rpc_get_t_size
argument_list|(
name|si
operator|.
name|si_af
argument_list|,
name|si
operator|.
name|si_proto
argument_list|,
name|UDPMSGSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendsz
operator|==
literal|0
condition|)
block|{
comment|/* data transfer not supported */
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Should be multiple of 4 for XDR. 	 */
name|sendsz
operator|=
operator|(
operator|(
name|sendsz
operator|+
literal|3
operator|)
operator|/
literal|4
operator|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|sendsz
operator|>
name|RPC_BUF_MAX
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|buf_alloc
operator|=
name|alloca
argument_list|(
name|sendsz
argument_list|)
expr_stmt|;
comment|/* not in IDR2? */
else|#
directive|else
name|buf_alloc
operator|=
name|malloc
argument_list|(
name|sendsz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notyet */
if|if
condition|(
name|buf_alloc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  No Memory!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|a
operator|.
name|rmt_args
operator|.
name|args
operator|=
name|buf_alloc
expr_stmt|;
block|}
else|else
block|{
name|a
operator|.
name|rmt_args
operator|.
name|args
operator|=
name|buf
expr_stmt|;
block|}
name|call_msg
operator|.
name|rm_xid
operator|=
literal|0
expr_stmt|;
comment|/* For error checking purposes */
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_rmtcall_args
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  svc_getargs failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|check_callit
argument_list|(
name|transp
argument_list|,
operator|&
name|a
argument_list|,
name|versnum
argument_list|)
condition|)
block|{
name|svcerr_weakauth
argument_list|(
name|transp
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|caller
operator|=
name|svc_getrpccaller
argument_list|(
name|transp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RPCBIND_DEBUG
if|if
condition|(
name|debugging
condition|)
block|{
name|uaddr
operator|=
name|taddr2uaddr
argument_list|(
name|rpcbind_get_conf
argument_list|(
name|transp
operator|->
name|xp_netid
argument_list|)
argument_list|,
name|caller
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s %s req for (%lu, %lu, %lu, %s) from %s : "
argument_list|,
name|versnum
operator|==
name|PMAPVERS
condition|?
literal|"pmap_rmtcall"
else|:
name|versnum
operator|==
name|RPCBVERS
condition|?
literal|"rpcb_rmtcall"
else|:
name|versnum
operator|==
name|RPCBVERS4
condition|?
literal|"rpcb_indirect"
else|:
literal|"unknown"
argument_list|,
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|?
literal|"indirect"
else|:
literal|"callit"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|a
operator|.
name|rmt_prog
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|a
operator|.
name|rmt_vers
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|a
operator|.
name|rmt_proc
argument_list|,
name|transp
operator|->
name|xp_netid
argument_list|,
name|uaddr
condition|?
name|uaddr
else|:
literal|"unknown"
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaddr
condition|)
name|free
argument_list|(
name|uaddr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|rbl
operator|=
name|find_service
argument_list|(
name|a
operator|.
name|rmt_prog
argument_list|,
name|a
operator|.
name|rmt_vers
argument_list|,
name|transp
operator|->
name|xp_netid
argument_list|)
expr_stmt|;
name|rpcbs_rmtcall
argument_list|(
name|versnum
operator|-
literal|2
argument_list|,
name|reply_type
argument_list|,
name|a
operator|.
name|rmt_prog
argument_list|,
name|a
operator|.
name|rmt_vers
argument_list|,
name|a
operator|.
name|rmt_proc
argument_list|,
name|transp
operator|->
name|xp_netid
argument_list|,
name|rbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|rbl
operator|==
operator|(
name|rpcblist_ptr
operator|)
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|RPCBIND_DEBUG
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not found\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_noprog
argument_list|(
name|transp
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_vers
operator|!=
name|a
operator|.
name|rmt_vers
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
block|{
name|rpcvers_t
name|vers_low
decl_stmt|,
name|vers_high
decl_stmt|;
name|find_versions
argument_list|(
name|a
operator|.
name|rmt_prog
argument_list|,
name|transp
operator|->
name|xp_netid
argument_list|,
operator|&
name|vers_low
argument_list|,
operator|&
name|vers_high
argument_list|)
expr_stmt|;
name|svcerr_progvers
argument_list|(
name|transp
argument_list|,
name|vers_low
argument_list|,
name|vers_high
argument_list|)
expr_stmt|;
block|}
goto|goto
name|error
goto|;
block|}
ifdef|#
directive|ifdef
name|RPCBIND_DEBUG
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"found at uaddr %s\n"
argument_list|,
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 *	Check whether this entry is valid and a server is present 	 *	Mergeaddr() returns NULL if no such entry is present, and 	 *	returns "" if the entry was present but the server is not 	 *	present (i.e., it crashed). 	 */
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
block|{
name|uaddr
operator|=
name|mergeaddr
argument_list|(
name|transp
argument_list|,
name|transp
operator|->
name|xp_netid
argument_list|,
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaddr
operator|==
name|NULL
operator|||
name|uaddr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|svcerr_noprog
argument_list|(
name|transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uaddr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|uaddr
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|free
argument_list|(
name|uaddr
argument_list|)
expr_stmt|;
block|}
name|nconf
operator|=
name|rpcbind_get_conf
argument_list|(
name|transp
operator|->
name|xp_netid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nconf
operator|==
operator|(
expr|struct
name|netconfig
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  rpcbind_get_conf failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|localsa
operator|=
name|local_sa
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|caller
operator|->
name|buf
operator|)
operator|->
name|sa_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|localsa
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com: no local address\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|tbuf
operator|.
name|len
operator|=
name|tbuf
operator|.
name|maxlen
operator|=
name|localsa
operator|->
name|sa_len
expr_stmt|;
name|tbuf
operator|.
name|buf
operator|=
name|localsa
expr_stmt|;
name|local_uaddr
operator|=
name|addrmerge
argument_list|(
operator|&
name|tbuf
argument_list|,
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_addr
argument_list|,
name|NULL
argument_list|,
name|nconf
operator|->
name|nc_netid
argument_list|)
expr_stmt|;
name|m_uaddr
operator|=
name|addrmerge
argument_list|(
name|caller
argument_list|,
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_addr
argument_list|,
name|NULL
argument_list|,
name|nconf
operator|->
name|nc_netid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RPCBIND_DEBUG
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"merged uaddr %s\n"
argument_list|,
name|m_uaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|fd
operator|=
name|find_rmtcallfd_by_netid
argument_list|(
name|nconf
operator|->
name|nc_netid
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|xidp
operator|=
name|__rpcb_get_dg_xidp
argument_list|(
name|transp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|forward_register
argument_list|(
operator|*
name|xidp
argument_list|,
name|caller
argument_list|,
name|fd
argument_list|,
name|m_uaddr
argument_list|,
name|reply_type
argument_list|,
name|versnum
argument_list|,
operator|&
name|call_msg
operator|.
name|rm_xid
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* Success; forward_register() will free m_uaddr for us. */
name|m_uaddr
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* 		 * A duplicate request for the slow server.  Let's not 		 * beat on it any more. 		 */
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  duplicate request\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
case|case
operator|-
literal|1
case|:
comment|/*  forward_register failed.  Perhaps no memory. */
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  forward_register failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG_RMTCALL
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  original XID %x, new XID %x\n"
argument_list|,
operator|*
name|xidp
argument_list|,
name|call_msg
operator|.
name|rm_xid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|call_msg
operator|.
name|rm_direction
operator|=
name|CALL
expr_stmt|;
name|call_msg
operator|.
name|rm_call
operator|.
name|cb_rpcvers
operator|=
name|RPC_MSG_VERSION
expr_stmt|;
name|call_msg
operator|.
name|rm_call
operator|.
name|cb_prog
operator|=
name|a
operator|.
name|rmt_prog
expr_stmt|;
name|call_msg
operator|.
name|rm_call
operator|.
name|cb_vers
operator|=
name|a
operator|.
name|rmt_vers
expr_stmt|;
if|if
condition|(
name|sendsz
operator|>
name|RPC_BUF_MAX
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|outbuf_alloc
operator|=
name|alloca
argument_list|(
name|sendsz
argument_list|)
expr_stmt|;
comment|/* not in IDR2? */
else|#
directive|else
name|outbuf_alloc
operator|=
name|malloc
argument_list|(
name|sendsz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notyet */
if|if
condition|(
name|outbuf_alloc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  No memory!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|xdrmem_create
argument_list|(
operator|&
name|outxdr
argument_list|,
name|outbuf_alloc
argument_list|,
name|sendsz
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xdrmem_create
argument_list|(
operator|&
name|outxdr
argument_list|,
name|outbuf
argument_list|,
name|sendsz
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|xdr_callhdr
argument_list|(
operator|&
name|outxdr
argument_list|,
operator|&
name|call_msg
argument_list|)
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  xdr_callhdr failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|xdr_u_int32_t
argument_list|(
operator|&
name|outxdr
argument_list|,
operator|&
operator|(
name|a
operator|.
name|rmt_proc
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  xdr_u_long failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|rqstp
operator|->
name|rq_cred
operator|.
name|oa_flavor
operator|==
name|AUTH_NULL
condition|)
block|{
name|auth
operator|=
name|authnone_create
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rqstp
operator|->
name|rq_cred
operator|.
name|oa_flavor
operator|==
name|AUTH_SYS
condition|)
block|{
name|struct
name|authunix_parms
modifier|*
name|au
decl_stmt|;
name|au
operator|=
operator|(
expr|struct
name|authunix_parms
operator|*
operator|)
name|rqstp
operator|->
name|rq_clntcred
expr_stmt|;
name|auth
operator|=
name|authunix_create
argument_list|(
name|au
operator|->
name|aup_machname
argument_list|,
name|au
operator|->
name|aup_uid
argument_list|,
name|au
operator|->
name|aup_gid
argument_list|,
name|au
operator|->
name|aup_len
argument_list|,
name|au
operator|->
name|aup_gids
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth
operator|==
name|NULL
condition|)
comment|/* fall back */
name|auth
operator|=
name|authnone_create
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* we do not support any other authentication scheme */
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  oa_flavor != AUTH_NONE and oa_flavor != AUTH_SYS\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_weakauth
argument_list|(
name|transp
argument_list|)
expr_stmt|;
comment|/* XXX too strong.. */
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|auth
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  authwhatever_create returned NULL\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|AUTH_MARSHALL
argument_list|(
name|auth
argument_list|,
operator|&
name|outxdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  AUTH_MARSHALL failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_opaque_parms
argument_list|(
operator|&
name|outxdr
argument_list|,
operator|&
name|a
argument_list|)
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  xdr_opaque_parms failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|outlen
operator|=
operator|(
name|int
operator|)
name|XDR_GETPOS
argument_list|(
operator|&
name|outxdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuf_alloc
condition|)
name|outbufp
operator|=
name|outbuf_alloc
expr_stmt|;
else|else
name|outbufp
operator|=
name|outbuf
expr_stmt|;
name|na
operator|=
name|uaddr2taddr
argument_list|(
name|nconf
argument_list|,
name|local_uaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|na
condition|)
block|{
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|sendto
argument_list|(
name|fd
argument_list|,
name|outbufp
argument_list|,
name|outlen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|na
operator|->
name|buf
argument_list|,
name|na
operator|->
name|len
argument_list|)
operator|!=
name|outlen
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"rpcbproc_callit_com:  sendto failed:  errno %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
goto|goto
name|out
goto|;
name|error
label|:
if|if
condition|(
name|call_msg
operator|.
name|rm_xid
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|free_slot_by_xid
argument_list|(
name|call_msg
operator|.
name|rm_xid
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|local_uaddr
condition|)
name|free
argument_list|(
name|local_uaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_alloc
condition|)
name|free
argument_list|(
name|buf_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuf_alloc
condition|)
name|free
argument_list|(
name|outbuf_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
condition|)
block|{
name|free
argument_list|(
name|na
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m_uaddr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|m_uaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Makes an entry into the FIFO for the given request.  * Returns 1 on success, 0 if this is a duplicate request, or -1 on error.  * *callxidp is set to the xid of the call.  */
end_comment

begin_function
specifier|static
name|int
name|forward_register
parameter_list|(
name|u_int32_t
name|caller_xid
parameter_list|,
name|struct
name|netbuf
modifier|*
name|caller_addr
parameter_list|,
name|int
name|forward_fd
parameter_list|,
name|char
modifier|*
name|uaddr
parameter_list|,
name|rpcproc_t
name|reply_type
parameter_list|,
name|rpcvers_t
name|versnum
parameter_list|,
name|u_int32_t
modifier|*
name|callxidp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|time_t
name|min_time
decl_stmt|,
name|time_now
decl_stmt|;
specifier|static
name|u_int32_t
name|lastxid
decl_stmt|;
name|int
name|entry
init|=
operator|-
literal|1
decl_stmt|;
name|min_time
operator|=
name|FINFO
index|[
literal|0
index|]
operator|.
name|time
expr_stmt|;
name|time_now
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* initialization */
if|if
condition|(
name|lastxid
operator|==
literal|0
condition|)
name|lastxid
operator|=
name|time_now
operator|*
name|NFORWARD
expr_stmt|;
comment|/* 	 * Check if it is a duplicate entry. Then, 	 * try to find an empty slot.  If not available, then 	 * use the slot with the earliest time. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFORWARD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FINFO
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|FINFO_ACTIVE
condition|)
block|{
if|if
condition|(
operator|(
name|FINFO
index|[
name|i
index|]
operator|.
name|caller_xid
operator|==
name|caller_xid
operator|)
operator|&&
operator|(
name|FINFO
index|[
name|i
index|]
operator|.
name|reply_type
operator|==
name|reply_type
operator|)
operator|&&
operator|(
name|FINFO
index|[
name|i
index|]
operator|.
name|versnum
operator|==
name|versnum
operator|)
operator|&&
operator|(
operator|!
name|netbufcmp
argument_list|(
name|FINFO
index|[
name|i
index|]
operator|.
name|caller_addr
argument_list|,
name|caller_addr
argument_list|)
operator|)
condition|)
block|{
name|FINFO
index|[
name|i
index|]
operator|.
name|time
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Duplicate entry */
block|}
else|else
block|{
comment|/* Should we wait any longer */
if|if
condition|(
operator|(
name|time_now
operator|-
name|FINFO
index|[
name|i
index|]
operator|.
name|time
operator|)
operator|>
name|MAXTIME_OFF
condition|)
operator|(
name|void
operator|)
name|free_slot_by_index
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|FINFO
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|FINFO_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|entry
operator|=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FINFO
index|[
name|i
index|]
operator|.
name|time
operator|<
name|min_time
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
name|min_time
operator|=
name|FINFO
index|[
name|i
index|]
operator|.
name|time
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|entry
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* use this empty slot */
name|j
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|free_slot_by_index
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|FINFO
index|[
name|j
index|]
operator|.
name|caller_addr
operator|=
name|netbufdup
argument_list|(
name|caller_addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rpcb_rmtcalls
operator|++
expr_stmt|;
comment|/* no of pending calls */
name|FINFO
index|[
name|j
index|]
operator|.
name|flag
operator|=
name|FINFO_ACTIVE
expr_stmt|;
name|FINFO
index|[
name|j
index|]
operator|.
name|reply_type
operator|=
name|reply_type
expr_stmt|;
name|FINFO
index|[
name|j
index|]
operator|.
name|versnum
operator|=
name|versnum
expr_stmt|;
name|FINFO
index|[
name|j
index|]
operator|.
name|time
operator|=
name|time_now
expr_stmt|;
name|FINFO
index|[
name|j
index|]
operator|.
name|caller_xid
operator|=
name|caller_xid
expr_stmt|;
name|FINFO
index|[
name|j
index|]
operator|.
name|forward_fd
operator|=
name|forward_fd
expr_stmt|;
comment|/* 	 * Though uaddr is not allocated here, it will still be freed 	 * from free_slot_*(). 	 */
name|FINFO
index|[
name|j
index|]
operator|.
name|uaddr
operator|=
name|uaddr
expr_stmt|;
name|lastxid
operator|=
name|lastxid
operator|+
name|NFORWARD
expr_stmt|;
comment|/* Don't allow a zero xid below. */
if|if
condition|(
call|(
name|u_int32_t
call|)
argument_list|(
name|lastxid
operator|+
name|NFORWARD
argument_list|)
operator|<=
name|NFORWARD
condition|)
name|lastxid
operator|=
name|NFORWARD
expr_stmt|;
name|FINFO
index|[
name|j
index|]
operator|.
name|forward_xid
operator|=
name|lastxid
operator|+
name|j
expr_stmt|;
comment|/* encode slot */
operator|*
name|callxidp
operator|=
name|FINFO
index|[
name|j
index|]
operator|.
name|forward_xid
expr_stmt|;
comment|/* forward on this xid */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|finfo
modifier|*
name|forward_find
parameter_list|(
name|u_int32_t
name|reply_xid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|reply_xid
operator|%
operator|(
name|u_int32_t
operator|)
name|NFORWARD
expr_stmt|;
if|if
condition|(
operator|(
name|FINFO
index|[
name|i
index|]
operator|.
name|flag
operator|&
name|FINFO_ACTIVE
operator|)
operator|&&
operator|(
name|FINFO
index|[
name|i
index|]
operator|.
name|forward_xid
operator|==
name|reply_xid
operator|)
condition|)
block|{
return|return
operator|(
operator|&
name|FINFO
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_slot_by_xid
parameter_list|(
name|u_int32_t
name|xid
parameter_list|)
block|{
name|int
name|entry
decl_stmt|;
name|entry
operator|=
name|xid
operator|%
operator|(
name|u_int32_t
operator|)
name|NFORWARD
expr_stmt|;
return|return
operator|(
name|free_slot_by_index
argument_list|(
name|entry
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|free_slot_by_index
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|struct
name|finfo
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
operator|&
name|FINFO
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|flag
operator|&
name|FINFO_ACTIVE
condition|)
block|{
name|netbuffree
argument_list|(
name|fi
operator|->
name|caller_addr
argument_list|)
expr_stmt|;
comment|/* XXX may be too big, but can't access xprt array here */
if|if
condition|(
name|fi
operator|->
name|forward_fd
operator|>=
name|svc_maxfd
condition|)
name|svc_maxfd
operator|--
expr_stmt|;
name|free
argument_list|(
name|fi
operator|->
name|uaddr
argument_list|)
expr_stmt|;
name|fi
operator|->
name|flag
operator|&=
operator|~
name|FINFO_ACTIVE
expr_stmt|;
name|rpcb_rmtcalls
operator|--
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|netbufcmp
parameter_list|(
name|struct
name|netbuf
modifier|*
name|n1
parameter_list|,
name|struct
name|netbuf
modifier|*
name|n2
parameter_list|)
block|{
return|return
operator|(
operator|(
name|n1
operator|->
name|len
operator|!=
name|n2
operator|->
name|len
operator|)
operator|||
name|memcmp
argument_list|(
name|n1
operator|->
name|buf
argument_list|,
name|n2
operator|->
name|buf
argument_list|,
name|n1
operator|->
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|netbuf
modifier|*
name|netbufdup
parameter_list|(
name|struct
name|netbuf
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|netbuf
modifier|*
name|np
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|netbuf
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|np
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|ap
operator|->
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|np
operator|->
name|maxlen
operator|=
name|np
operator|->
name|len
operator|=
name|ap
operator|->
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|np
operator|->
name|buf
argument_list|,
name|ap
operator|->
name|buf
argument_list|,
name|ap
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|netbuffree
parameter_list|(
name|struct
name|netbuf
modifier|*
name|ap
parameter_list|)
block|{
name|free
argument_list|(
name|ap
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MASKVAL
value|(POLLIN | POLLPRI | POLLRDNORM | POLLRDBAND)
end_define

begin_function_decl
specifier|extern
name|bool_t
name|__svc_clean_idle
parameter_list|(
name|fd_set
modifier|*
parameter_list|,
name|int
parameter_list|,
name|bool_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|my_svc_run
parameter_list|()
block|{
name|size_t
name|nfds
decl_stmt|;
name|struct
name|pollfd
name|pollfds
index|[
name|FD_SETSIZE
index|]
decl_stmt|;
name|int
name|poll_ret
decl_stmt|,
name|check_ret
decl_stmt|;
name|int
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|SVC_RUN_DEBUG
name|int
name|i
decl_stmt|;
endif|#
directive|endif
specifier|register
name|struct
name|pollfd
modifier|*
name|p
decl_stmt|;
name|fd_set
name|cleanfds
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|p
operator|=
name|pollfds
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|svc_maxfd
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|n
argument_list|,
operator|&
name|svc_fdset
argument_list|)
condition|)
block|{
name|p
operator|->
name|fd
operator|=
name|n
expr_stmt|;
name|p
operator|->
name|events
operator|=
name|MASKVAL
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
name|nfds
operator|=
name|p
operator|-
name|pollfds
expr_stmt|;
name|poll_ret
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SVC_RUN_DEBUG
if|if
condition|(
name|debugging
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"polling for read on fd< "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|pollfds
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|events
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d "
argument_list|,
name|p
operator|->
name|fd
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|poll_ret
operator|=
name|poll
argument_list|(
name|pollfds
argument_list|,
name|nfds
argument_list|,
literal|30
operator|*
literal|1000
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* 			 * We ignore all errors, continuing with the assumption 			 * that it was set by the signal handlers (or any 			 * other outside event) and not caused by poll(). 			 */
case|case
literal|0
case|:
name|cleanfds
operator|=
name|svc_fdset
expr_stmt|;
name|__svc_clean_idle
argument_list|(
operator|&
name|cleanfds
argument_list|,
literal|30
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
continue|continue;
default|default:
ifdef|#
directive|ifdef
name|SVC_RUN_DEBUG
if|if
condition|(
name|debugging
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"poll returned read fds< "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|pollfds
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|->
name|revents
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d "
argument_list|,
name|p
operator|->
name|fd
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|">\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 			 * If we found as many replies on callback fds 			 * as the number of descriptors selectable which 			 * poll() returned, there can be no more so we 			 * don't call svc_getreq_poll.  Otherwise, there 			 * must be another so we must call svc_getreq_poll. 			 */
if|if
condition|(
operator|(
name|check_ret
operator|=
name|check_rmtcalls
argument_list|(
name|pollfds
argument_list|,
name|nfds
argument_list|)
operator|)
operator|==
name|poll_ret
condition|)
continue|continue;
name|svc_getreq_poll
argument_list|(
name|pollfds
argument_list|,
name|poll_ret
operator|-
name|check_ret
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SVC_RUN_DEBUG
if|if
condition|(
name|debugging
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"svc_maxfd now %u\n"
argument_list|,
name|svc_maxfd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|check_rmtcalls
parameter_list|(
name|struct
name|pollfd
modifier|*
name|pfds
parameter_list|,
name|int
name|nfds
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|ncallbacks_found
init|=
literal|0
decl_stmt|,
name|rmtcalls_pending
decl_stmt|;
name|SVCXPRT
modifier|*
name|xprt
decl_stmt|;
if|if
condition|(
name|rpcb_rmtcalls
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rmtcalls_pending
operator|=
name|rpcb_rmtcalls
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nfds
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|xprt
operator|=
name|find_rmtcallxprt_by_fd
argument_list|(
name|pfds
index|[
name|j
index|]
operator|.
name|fd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pfds
index|[
name|j
index|]
operator|.
name|revents
condition|)
block|{
name|ncallbacks_found
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RMTCALL
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"my_svc_run:  polled on forwarding fd %d, netid %s - calling handle_reply\n"
argument_list|,
name|pfds
index|[
name|j
index|]
operator|.
name|fd
argument_list|,
name|xprt
operator|->
name|xp_netid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|handle_reply
argument_list|(
name|pfds
index|[
name|j
index|]
operator|.
name|fd
argument_list|,
name|xprt
argument_list|)
expr_stmt|;
name|pfds
index|[
name|j
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ncallbacks_found
operator|>=
name|rmtcalls_pending
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
return|return
operator|(
name|ncallbacks_found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xprt_set_caller
parameter_list|(
name|SVCXPRT
modifier|*
name|xprt
parameter_list|,
name|struct
name|finfo
modifier|*
name|fi
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|xidp
decl_stmt|;
operator|*
operator|(
name|svc_getrpccaller
argument_list|(
name|xprt
argument_list|)
operator|)
operator|=
operator|*
operator|(
name|fi
operator|->
name|caller_addr
operator|)
expr_stmt|;
name|xidp
operator|=
name|__rpcb_get_dg_xidp
argument_list|(
name|xprt
argument_list|)
expr_stmt|;
operator|*
name|xidp
operator|=
name|fi
operator|->
name|caller_xid
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call svcerr_systemerr() only if RPCBVERS4  */
end_comment

begin_function
specifier|static
name|void
name|send_svcsyserr
parameter_list|(
name|SVCXPRT
modifier|*
name|xprt
parameter_list|,
name|struct
name|finfo
modifier|*
name|fi
parameter_list|)
block|{
if|if
condition|(
name|fi
operator|->
name|reply_type
operator|==
name|RPCBPROC_INDIRECT
condition|)
block|{
name|xprt_set_caller
argument_list|(
name|xprt
argument_list|,
name|fi
argument_list|)
expr_stmt|;
name|svcerr_systemerr
argument_list|(
name|xprt
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_reply
parameter_list|(
name|int
name|fd
parameter_list|,
name|SVCXPRT
modifier|*
name|xprt
parameter_list|)
block|{
name|XDR
name|reply_xdrs
decl_stmt|;
name|struct
name|rpc_msg
name|reply_msg
decl_stmt|;
name|struct
name|rpc_err
name|reply_error
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|struct
name|finfo
modifier|*
name|fi
decl_stmt|;
name|int
name|inlen
decl_stmt|,
name|pos
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|r_rmtcall_args
name|a
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|socklen_t
name|fromlen
decl_stmt|;
ifdef|#
directive|ifdef
name|SVC_RUN_DEBUG
name|char
modifier|*
name|uaddr
decl_stmt|;
endif|#
directive|endif
name|buffer
operator|=
name|malloc
argument_list|(
name|RPC_BUF_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
do|do
block|{
name|inlen
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buffer
argument_list|,
name|RPC_BUF_MAX
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inlen
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
do|;
if|if
condition|(
name|inlen
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"handle_reply:  recvfrom returned %d, errno %d\n"
argument_list|,
name|inlen
argument_list|,
name|errno
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|reply_msg
operator|.
name|acpted_rply
operator|.
name|ar_verf
operator|=
name|_null_auth
expr_stmt|;
name|reply_msg
operator|.
name|acpted_rply
operator|.
name|ar_results
operator|.
name|where
operator|=
literal|0
expr_stmt|;
name|reply_msg
operator|.
name|acpted_rply
operator|.
name|ar_results
operator|.
name|proc
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_void
expr_stmt|;
name|xdrmem_create
argument_list|(
operator|&
name|reply_xdrs
argument_list|,
name|buffer
argument_list|,
operator|(
name|u_int
operator|)
name|inlen
argument_list|,
name|XDR_DECODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_replymsg
argument_list|(
operator|&
name|reply_xdrs
argument_list|,
operator|&
name|reply_msg
argument_list|)
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"handle_reply:  xdr_replymsg failed\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|fi
operator|=
name|forward_find
argument_list|(
name|reply_msg
operator|.
name|rm_xid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVC_RUN_DEBUG
if|if
condition|(
name|debugging
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"handle_reply:  reply xid: %d fi addr: %p\n"
argument_list|,
name|reply_msg
operator|.
name|rm_xid
argument_list|,
name|fi
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fi
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|_seterr_reply
argument_list|(
operator|&
name|reply_msg
argument_list|,
operator|&
name|reply_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply_error
operator|.
name|re_status
operator|!=
name|RPC_SUCCESS
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"handle_reply:  %s\n"
argument_list|,
name|clnt_sperrno
argument_list|(
name|reply_error
operator|.
name|re_status
argument_list|)
argument_list|)
expr_stmt|;
name|send_svcsyserr
argument_list|(
name|xprt
argument_list|,
name|fi
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|pos
operator|=
name|XDR_GETPOS
argument_list|(
operator|&
name|reply_xdrs
argument_list|)
expr_stmt|;
name|len
operator|=
name|inlen
operator|-
name|pos
expr_stmt|;
name|a
operator|.
name|rmt_args
operator|.
name|args
operator|=
operator|&
name|buffer
index|[
name|pos
index|]
expr_stmt|;
name|a
operator|.
name|rmt_args
operator|.
name|arglen
operator|=
name|len
expr_stmt|;
name|a
operator|.
name|rmt_uaddr
operator|=
name|fi
operator|->
name|uaddr
expr_stmt|;
name|a
operator|.
name|rmt_localvers
operator|=
name|fi
operator|->
name|versnum
expr_stmt|;
name|xprt_set_caller
argument_list|(
name|xprt
argument_list|,
name|fi
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVC_RUN_DEBUG
name|uaddr
operator|=
name|taddr2uaddr
argument_list|(
name|rpcbind_get_conf
argument_list|(
literal|"udp"
argument_list|)
argument_list|,
name|svc_getrpccaller
argument_list|(
name|xprt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"handle_reply:  forwarding address %s to %s\n"
argument_list|,
name|a
operator|.
name|rmt_uaddr
argument_list|,
name|uaddr
condition|?
name|uaddr
else|:
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uaddr
condition|)
name|free
argument_list|(
name|uaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|svc_sendreply
argument_list|(
name|xprt
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_rmtcall_result
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|a
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|buffer
condition|)
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply_msg
operator|.
name|rm_xid
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SVC_RUN_DEBUG
if|if
condition|(
name|debugging
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"handle_reply:  NULL xid on exit!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
operator|(
name|void
operator|)
name|free_slot_by_xid
argument_list|(
name|reply_msg
operator|.
name|rm_xid
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|find_versions
parameter_list|(
name|rpcprog_t
name|prog
parameter_list|,
name|char
modifier|*
name|netid
parameter_list|,
name|rpcvers_t
modifier|*
name|lowvp
parameter_list|,
name|rpcvers_t
modifier|*
name|highvp
parameter_list|)
block|{
specifier|register
name|rpcblist_ptr
name|rbl
decl_stmt|;
name|unsigned
name|int
name|lowv
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|highv
init|=
literal|0
decl_stmt|;
for|for
control|(
name|rbl
operator|=
name|list_rbl
init|;
name|rbl
operator|!=
name|NULL
condition|;
name|rbl
operator|=
name|rbl
operator|->
name|rpcb_next
control|)
block|{
if|if
condition|(
operator|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_prog
operator|!=
name|prog
operator|)
operator|||
operator|(
operator|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_netid
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_netid
argument_list|,
name|netid
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|lowv
operator|==
literal|0
condition|)
block|{
name|highv
operator|=
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_vers
expr_stmt|;
name|lowv
operator|=
name|highv
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_vers
operator|<
name|lowv
condition|)
block|{
name|lowv
operator|=
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_vers
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_vers
operator|>
name|highv
condition|)
block|{
name|highv
operator|=
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_vers
expr_stmt|;
block|}
block|}
operator|*
name|lowvp
operator|=
name|lowv
expr_stmt|;
operator|*
name|highvp
operator|=
name|highv
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * returns the item with the given program, version number and netid.  * If that version number is not found, it returns the item with that  * program number, so that address is now returned to the caller. The  * caller when makes a call to this program, version number, the call  * will fail and it will return with PROGVERS_MISMATCH. The user can  * then determine the highest and the lowest version number for this  * program using clnt_geterr() and use those program version numbers.  *  * Returns the RPCBLIST for the given prog, vers and netid  */
end_comment

begin_function
specifier|static
name|rpcblist_ptr
name|find_service
parameter_list|(
name|rpcprog_t
name|prog
parameter_list|,
name|rpcvers_t
name|vers
parameter_list|,
name|char
modifier|*
name|netid
parameter_list|)
block|{
specifier|register
name|rpcblist_ptr
name|hit
init|=
name|NULL
decl_stmt|;
specifier|register
name|rpcblist_ptr
name|rbl
decl_stmt|;
for|for
control|(
name|rbl
operator|=
name|list_rbl
init|;
name|rbl
operator|!=
name|NULL
condition|;
name|rbl
operator|=
name|rbl
operator|->
name|rpcb_next
control|)
block|{
if|if
condition|(
operator|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_prog
operator|!=
name|prog
operator|)
operator|||
operator|(
operator|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_netid
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcasecmp
argument_list|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_netid
argument_list|,
name|netid
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
continue|continue;
name|hit
operator|=
name|rbl
expr_stmt|;
if|if
condition|(
name|rbl
operator|->
name|rpcb_map
operator|.
name|r_vers
operator|==
name|vers
condition|)
break|break;
block|}
return|return
operator|(
name|hit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copies the name associated with the uid of the caller and returns  * a pointer to it.  Similar to getwd().  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|getowner
parameter_list|(
name|SVCXPRT
modifier|*
name|transp
parameter_list|,
name|char
modifier|*
name|owner
parameter_list|,
name|size_t
name|ownersize
parameter_list|)
block|{
name|uid_t
name|uid
decl_stmt|;
if|if
condition|(
name|__rpc_get_local_uid
argument_list|(
name|transp
argument_list|,
operator|&
name|uid
argument_list|)
operator|<
literal|0
condition|)
name|strlcpy
argument_list|(
name|owner
argument_list|,
literal|"unknown"
argument_list|,
name|ownersize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
name|strlcpy
argument_list|(
name|owner
argument_list|,
literal|"superuser"
argument_list|,
name|ownersize
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|owner
argument_list|,
name|ownersize
argument_list|,
literal|"%d"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
return|return
name|owner
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PORTMAP
end_ifdef

begin_comment
comment|/*  * Add this to the pmap list only if it is UDP or TCP.  */
end_comment

begin_function
specifier|static
name|int
name|add_pmaplist
parameter_list|(
name|RPCB
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pmap
name|pmap
decl_stmt|;
name|struct
name|pmaplist
modifier|*
name|pml
decl_stmt|;
name|int
name|h1
decl_stmt|,
name|h2
decl_stmt|,
name|h3
decl_stmt|,
name|h4
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|r_netid
argument_list|,
name|udptrans
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It is UDP! */
name|pmap
operator|.
name|pm_prot
operator|=
name|IPPROTO_UDP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|r_netid
argument_list|,
name|tcptrans
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It is TCP */
name|pmap
operator|.
name|pm_prot
operator|=
name|IPPROTO_TCP
expr_stmt|;
block|}
else|else
comment|/* Not an IP protocol */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* interpret the universal address for TCP/IP */
if|if
condition|(
name|sscanf
argument_list|(
name|arg
operator|->
name|r_addr
argument_list|,
literal|"%d.%d.%d.%d.%d.%d"
argument_list|,
operator|&
name|h1
argument_list|,
operator|&
name|h2
argument_list|,
operator|&
name|h3
argument_list|,
operator|&
name|h4
argument_list|,
operator|&
name|p1
argument_list|,
operator|&
name|p2
argument_list|)
operator|!=
literal|6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pmap
operator|.
name|pm_port
operator|=
operator|(
operator|(
name|p1
operator|&
literal|0xff
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
name|p2
operator|&
literal|0xff
operator|)
expr_stmt|;
name|pmap
operator|.
name|pm_prog
operator|=
name|arg
operator|->
name|r_prog
expr_stmt|;
name|pmap
operator|.
name|pm_vers
operator|=
name|arg
operator|->
name|r_vers
expr_stmt|;
comment|/* 	 * add to END of list 	 */
name|pml
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pmaplist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pml
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rpcbind: no memory!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pml
operator|->
name|pml_map
operator|=
name|pmap
expr_stmt|;
name|pml
operator|->
name|pml_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|list_pml
operator|==
name|NULL
condition|)
block|{
name|list_pml
operator|=
name|pml
expr_stmt|;
block|}
else|else
block|{
name|struct
name|pmaplist
modifier|*
name|fnd
decl_stmt|;
comment|/* Attach to the end of the list */
for|for
control|(
name|fnd
operator|=
name|list_pml
init|;
name|fnd
operator|->
name|pml_next
condition|;
name|fnd
operator|=
name|fnd
operator|->
name|pml_next
control|)
empty_stmt|;
name|fnd
operator|->
name|pml_next
operator|=
name|pml
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete this from the pmap list only if it is UDP or TCP.  */
end_comment

begin_function
specifier|static
name|int
name|del_pmaplist
parameter_list|(
name|RPCB
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pmaplist
modifier|*
name|pml
decl_stmt|;
name|struct
name|pmaplist
modifier|*
name|prevpml
decl_stmt|,
modifier|*
name|fnd
decl_stmt|;
name|unsigned
name|long
name|prot
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|r_netid
argument_list|,
name|udptrans
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It is UDP! */
name|prot
operator|=
name|IPPROTO_UDP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|r_netid
argument_list|,
name|tcptrans
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It is TCP */
name|prot
operator|=
name|IPPROTO_TCP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|r_netid
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|prot
operator|=
literal|0
expr_stmt|;
comment|/* Remove all occurrences */
block|}
else|else
block|{
comment|/* Not an IP protocol */
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|prevpml
operator|=
name|NULL
operator|,
name|pml
operator|=
name|list_pml
init|;
name|pml
condition|;
comment|/* cstyle */
control|)
block|{
if|if
condition|(
operator|(
name|pml
operator|->
name|pml_map
operator|.
name|pm_prog
operator|!=
name|arg
operator|->
name|r_prog
operator|)
operator|||
operator|(
name|pml
operator|->
name|pml_map
operator|.
name|pm_vers
operator|!=
name|arg
operator|->
name|r_vers
operator|)
operator|||
operator|(
name|prot
operator|&&
operator|(
name|pml
operator|->
name|pml_map
operator|.
name|pm_prot
operator|!=
name|prot
operator|)
operator|)
condition|)
block|{
comment|/* both pml& prevpml move forwards */
name|prevpml
operator|=
name|pml
expr_stmt|;
name|pml
operator|=
name|pml
operator|->
name|pml_next
expr_stmt|;
continue|continue;
block|}
comment|/* found it; pml moves forward, prevpml stays */
name|fnd
operator|=
name|pml
expr_stmt|;
name|pml
operator|=
name|pml
operator|->
name|pml_next
expr_stmt|;
if|if
condition|(
name|prevpml
operator|==
name|NULL
condition|)
name|list_pml
operator|=
name|pml
expr_stmt|;
else|else
name|prevpml
operator|->
name|pml_next
operator|=
name|pml
expr_stmt|;
name|free
argument_list|(
name|fnd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PORTMAP */
end_comment

end_unit

