begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1996  *	David L. Nugent.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY DAVID L. NUGENT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DAVID L. NUGENT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<login_cap.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_MD5RAND
argument_list|)
end_if

begin_include
include|#
directive|include
file|<md5.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pw.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_if
if|#
directive|if
operator|(
name|MAXLOGNAME
operator|-
literal|1
operator|)
operator|>
name|UT_NAMESIZE
end_if

begin_define
define|#
directive|define
name|LOGNAMESIZE
value|UT_NAMESIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LOGNAMESIZE
value|(MAXLOGNAME-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|locked_str
index|[]
init|=
literal|"*LOCKED*"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|print_user
parameter_list|(
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|int
name|pretty
parameter_list|,
name|int
name|v7
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uid_t
name|pw_uidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uid_t
name|pw_gidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|nam
parameter_list|,
name|gid_t
name|prefer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|pw_pwdpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|pw_exppolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pw_homepolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
specifier|const
modifier|*
name|user
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pw_shellpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|newshell
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pw_password
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
specifier|const
modifier|*
name|user
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|shell_path
parameter_list|(
name|char
specifier|const
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|shells
index|[]
parameter_list|,
name|char
modifier|*
name|sh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmat
parameter_list|(
name|uid_t
name|uid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmopie
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*-  * -C config      configuration file  * -q             quiet operation  * -n name        login name  * -u uid         user id  * -c comment     user name/comment  * -d directory   home directory  * -e date        account expiry date  * -p date        password expiry date  * -g grp         primary group  * -G grp1,grp2   additional groups  * -m [ -k dir ]  create and set up home  * -s shell       name of login shell  * -o             duplicate uid ok  * -L class       user class  * -l name        new login name  * -h fd          password filehandle  * -H fd          encrypted password filehandle  * -F             force print or add  *   Setting defaults:  * -D             set user defaults  * -b dir         default home root dir  * -e period      default expiry period  * -p period      default password change period  * -g group       default group  * -G             grp1,grp2.. default additional groups  * -L class       default login class  * -k dir         default home skeleton  * -s shell       default shell  * -w method      default password method  */
end_comment

begin_function
name|int
name|pw_user
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|edited
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|passtmp
decl_stmt|;
name|struct
name|carg
modifier|*
name|a_name
decl_stmt|;
name|struct
name|carg
modifier|*
name|a_uid
decl_stmt|;
name|struct
name|carg
modifier|*
name|arg
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|NULL
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|line
index|[
name|_PASSWORD_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|mode_t
name|dmode
decl_stmt|;
name|char
modifier|*
name|dmode_c
decl_stmt|;
name|void
modifier|*
name|set
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|passwd
name|fakeuser
init|=
block|{
name|NULL
block|,
literal|"*"
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|""
block|,
literal|"User&"
block|,
literal|"/nonexistent"
block|,
literal|"/bin/sh"
block|,
literal|0
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
block|,
literal|0
endif|#
directive|endif
block|}
decl_stmt|;
comment|/* 	 * With M_NEXT, we only need to return the 	 * next uid to stdout 	 */
if|if
condition|(
name|mode
operator|==
name|M_NEXT
condition|)
block|{
name|uid_t
name|next
init|=
name|pw_uidpolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'q'
argument_list|)
condition|)
return|return
name|next
return|;
name|printf
argument_list|(
literal|"%ld:"
argument_list|,
operator|(
name|long
operator|)
name|next
argument_list|)
expr_stmt|;
name|pw_group
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|/* 	 * We can do all of the common legwork here 	 */
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'b'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cnf
operator|->
name|home
operator|=
name|arg
operator|->
name|val
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'M'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dmode_c
operator|=
name|arg
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|set
operator|=
name|setmode
argument_list|(
name|dmode_c
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid directory creation mode '%s'"
argument_list|,
name|dmode_c
argument_list|)
expr_stmt|;
name|dmode
operator|=
name|getmode
argument_list|(
name|set
argument_list|,
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|cnf
operator|->
name|homemode
operator|=
name|dmode
expr_stmt|;
block|}
comment|/* 	 * If we'll need to use it or we're updating it, 	 * then create the base home directory if necessary 	 */
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|||
name|getarg
argument_list|(
name|args
argument_list|,
literal|'m'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|cnf
operator|->
name|home
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|>
literal|1
operator|&&
name|cnf
operator|->
name|home
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
comment|/* Shave off any trailing path delimiter */
name|cnf
operator|->
name|home
index|[
operator|--
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|2
operator|||
operator|*
name|cnf
operator|->
name|home
operator|!=
literal|'/'
condition|)
comment|/* Check for absolute path name */
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid base directory for home '%s'"
argument_list|,
name|cnf
operator|->
name|home
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|cnf
operator|->
name|home
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|dbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* 			 * This is a kludge especially for Joerg :) 			 * If the home directory would be created in the root partition, then 			 * we really create it under /usr which is likely to have more space. 			 * But we create a symlink from cnf->home -> "/usr" -> cnf->home 			 */
if|if
condition|(
name|strchr
argument_list|(
name|cnf
operator|->
name|home
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|dbuf
argument_list|,
literal|"/usr"
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|dbuf
argument_list|,
name|cnf
operator|->
name|home
argument_list|,
name|MAXPATHLEN
operator|-
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|dbuf
argument_list|,
name|cnf
operator|->
name|homemode
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|==
name|EEXIST
condition|)
block|{
name|chown
argument_list|(
name|dbuf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 					 * Skip first "/" and create symlink: 					 * /home -> usr/home 					 */
name|symlink
argument_list|(
name|dbuf
operator|+
literal|1
argument_list|,
name|cnf
operator|->
name|home
argument_list|)
expr_stmt|;
block|}
comment|/* If this falls, fall back to old method */
block|}
name|strlcpy
argument_list|(
name|dbuf
argument_list|,
name|cnf
operator|->
name|home
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|dbuf
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dbuf
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
operator|++
name|p
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dbuf
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|dbuf
argument_list|,
name|cnf
operator|->
name|homemode
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|direrr
goto|;
name|chown
argument_list|(
name|dbuf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"'%s' (root home parent) is not a directory"
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stat
argument_list|(
name|dbuf
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|dbuf
argument_list|,
name|cnf
operator|->
name|homemode
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|direrr
label|:
name|err
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"mkdir '%s'"
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
block|}
name|chown
argument_list|(
name|dbuf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"root home `%s' is not a directory"
argument_list|,
name|cnf
operator|->
name|home
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'e'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cnf
operator|->
name|expire_days
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'y'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cnf
operator|->
name|nispasswd
operator|=
name|arg
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'p'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|arg
operator|->
name|val
condition|)
name|cnf
operator|->
name|password_days
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'g'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|*
operator|(
name|p
operator|=
name|arg
operator|->
name|val
operator|)
condition|)
comment|/* Handle empty group list specially */
name|cnf
operator|->
name|default_group
operator|=
literal|""
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|||
operator|(
name|grp
operator|=
name|GETGRGID
argument_list|(
operator|(
name|gid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"group `%s' does not exist"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|cnf
operator|->
name|default_group
operator|=
name|newstr
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'L'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cnf
operator|->
name|default_class
operator|=
name|pw_checkname
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|->
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'G'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|arg
operator|->
name|val
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|", \t"
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|", \t"
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
operator|||
operator|(
name|grp
operator|=
name|GETGRGID
argument_list|(
operator|(
name|gid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"group `%s' does not exist"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extendarray
argument_list|(
operator|&
name|cnf
operator|->
name|groups
argument_list|,
operator|&
name|cnf
operator|->
name|numgroups
argument_list|,
name|i
operator|+
literal|2
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|cnf
operator|->
name|groups
index|[
name|i
operator|++
index|]
operator|=
name|newstr
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|cnf
operator|->
name|numgroups
condition|)
name|cnf
operator|->
name|groups
index|[
name|i
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'k'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|cnf
operator|->
name|dotdir
operator|=
name|arg
operator|->
name|val
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"skeleton `%s' is not a directory or does not exist"
argument_list|,
name|cnf
operator|->
name|dotdir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'s'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cnf
operator|->
name|shell_default
operator|=
name|arg
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'w'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cnf
operator|->
name|default_password
operator|=
name|boolean_val
argument_list|(
name|arg
operator|->
name|val
argument_list|,
name|cnf
operator|->
name|default_password
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|M_ADD
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'D'
argument_list|)
condition|)
block|{
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'n'
argument_list|)
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"can't combine `-D' with `-n name'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'u'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|", \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cnf
operator|->
name|min_uid
operator|=
operator|(
name|uid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|cnf
operator|->
name|min_uid
operator|=
literal|1000
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" ,\t"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cnf
operator|->
name|max_uid
operator|=
operator|(
name|uid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|<
name|cnf
operator|->
name|min_uid
condition|)
name|cnf
operator|->
name|max_uid
operator|=
literal|32000
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'i'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|", \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cnf
operator|->
name|min_gid
operator|=
operator|(
name|gid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|cnf
operator|->
name|min_gid
operator|=
literal|1000
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" ,\t"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cnf
operator|->
name|max_gid
operator|=
operator|(
name|gid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|<
name|cnf
operator|->
name|min_gid
condition|)
name|cnf
operator|->
name|max_gid
operator|=
literal|32000
expr_stmt|;
block|}
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_userconfig
argument_list|(
name|arg
condition|?
name|arg
operator|->
name|val
else|:
name|NULL
argument_list|)
condition|)
return|return
name|EXIT_SUCCESS
return|;
name|warn
argument_list|(
literal|"config update"
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|M_PRINT
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'a'
argument_list|)
condition|)
block|{
name|int
name|pretty
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'P'
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|int
name|v7
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'7'
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|SETPWENT
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pwd
operator|=
name|GETPWENT
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
name|print_user
argument_list|(
name|pwd
argument_list|,
name|pretty
argument_list|,
name|v7
argument_list|)
expr_stmt|;
name|ENDPWENT
argument_list|()
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
if|if
condition|(
operator|(
name|a_name
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pwd
operator|=
name|GETPWNAM
argument_list|(
name|pw_checkname
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|a_name
operator|->
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|a_uid
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_uid
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|a_name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"user name or id required"
argument_list|)
expr_stmt|;
comment|/* 		 * Determine whether 'n' switch is name or uid - we don't 		 * really don't really care which we have, but we need to 		 * know. 		 */
if|if
condition|(
name|mode
operator|!=
name|M_ADD
operator|&&
name|pwd
operator|==
name|NULL
operator|&&
name|strspn
argument_list|(
name|a_name
operator|->
name|val
argument_list|,
literal|"0123456789"
argument_list|)
operator|==
name|strlen
argument_list|(
name|a_name
operator|->
name|val
argument_list|)
operator|&&
name|atoi
argument_list|(
name|a_name
operator|->
name|val
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Assume uid */
operator|(
name|a_uid
operator|=
name|a_name
operator|)
operator|->
name|ch
operator|=
literal|'u'
expr_stmt|;
name|a_name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Update, delete& print require that the user exists 	 */
if|if
condition|(
name|mode
operator|==
name|M_UPDATE
operator|||
name|mode
operator|==
name|M_DELETE
operator|||
name|mode
operator|==
name|M_PRINT
operator|||
name|mode
operator|==
name|M_LOCK
operator|||
name|mode
operator|==
name|M_UNLOCK
condition|)
block|{
if|if
condition|(
name|a_name
operator|==
name|NULL
operator|&&
name|pwd
operator|==
name|NULL
condition|)
comment|/* Try harder */
name|pwd
operator|=
name|GETPWUID
argument_list|(
name|atoi
argument_list|(
name|a_uid
operator|->
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|M_PRINT
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'F'
argument_list|)
condition|)
block|{
name|fakeuser
operator|.
name|pw_name
operator|=
name|a_name
condition|?
name|a_name
operator|->
name|val
else|:
literal|"nouser"
expr_stmt|;
name|fakeuser
operator|.
name|pw_uid
operator|=
name|a_uid
condition|?
operator|(
name|uid_t
operator|)
name|atol
argument_list|(
name|a_uid
operator|->
name|val
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|print_user
argument_list|(
operator|&
name|fakeuser
argument_list|,
name|getarg
argument_list|(
name|args
argument_list|,
literal|'P'
argument_list|)
operator|!=
name|NULL
argument_list|,
name|getarg
argument_list|(
name|args
argument_list|,
literal|'7'
argument_list|)
operator|!=
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|a_name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such uid `%s'"
argument_list|,
name|a_uid
operator|->
name|val
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such user `%s'"
argument_list|,
name|a_name
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a_name
operator|==
name|NULL
condition|)
comment|/* May be needed later */
name|a_name
operator|=
name|addarg
argument_list|(
name|args
argument_list|,
literal|'n'
argument_list|,
name|newstr
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The M_LOCK and M_UNLOCK functions simply add or remove 		 * a "*LOCKED*" prefix from in front of the password to 		 * prevent it decoding correctly, and therefore prevents 		 * access. Of course, this only prevents access via 		 * password authentication (not ssh, kerberos or any 		 * other method that does not use the UNIX password) but 		 * that is a known limitation. 		 */
if|if
condition|(
name|mode
operator|==
name|M_LOCK
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|,
name|locked_str
argument_list|,
sizeof|sizeof
argument_list|(
name|locked_str
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"user '%s' is already locked"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|passtmp
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|locked_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|passtmp
operator|==
name|NULL
condition|)
comment|/* disaster */
name|errx
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|passtmp
argument_list|,
name|locked_str
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|passtmp
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|passtmp
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|M_UNLOCK
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|,
name|locked_str
argument_list|,
sizeof|sizeof
argument_list|(
name|locked_str
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"user '%s' is not locked"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|+=
sizeof|sizeof
argument_list|(
name|locked_str
argument_list|)
operator|-
literal|1
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|M_DELETE
condition|)
block|{
comment|/* 			 * Handle deletions now 			 */
name|char
name|file
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|home
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|uid_t
name|uid
init|=
name|pwd
operator|->
name|pw_uid
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"cannot remove user 'root'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PWALTDIR
argument_list|()
condition|)
block|{
comment|/* 				 * Remove opie record from /etc/opiekeys 		        	 */
name|rmopie
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
comment|/* 				 * Remove crontabs 				 */
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"/var/cron/tabs/%s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"crontab -u %s -r"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Save these for later, since contents of pwd may be 			 * invalidated by deletion 			 */
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|_PATH_MAILDIR
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|home
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|home
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|delpwent
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_IOERR
argument_list|,
literal|"user '%s' does not exist"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"passwd update"
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
if|if
condition|(
name|cnf
operator|->
name|nispasswd
operator|&&
operator|*
name|cnf
operator|->
name|nispasswd
operator|==
literal|'/'
condition|)
block|{
name|rc
operator|=
name|delnispwent
argument_list|(
name|cnf
operator|->
name|nispasswd
argument_list|,
name|a_name
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"WARNING: user '%s' does not exist in NIS passwd"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"WARNING: NIS passwd update"
argument_list|)
expr_stmt|;
comment|/* non-fatal */
block|}
name|editgroups
argument_list|(
name|a_name
operator|->
name|val
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ld) account removed"
argument_list|,
name|a_name
operator|->
name|val
argument_list|,
operator|(
name|long
operator|)
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PWALTDIR
argument_list|()
condition|)
block|{
comment|/* 				 * Remove mail file 				 */
name|remove
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* 				 * Remove at jobs 				 */
if|if
condition|(
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|==
name|NULL
condition|)
name|rmat
argument_list|(
name|uid
argument_list|)
expr_stmt|;
comment|/* 				 * Remove home directory and contents 				 */
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'r'
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|home
operator|==
literal|'/'
operator|&&
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|home
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rm_r
argument_list|(
name|home
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ld) home '%s' %sremoved"
argument_list|,
name|a_name
operator|->
name|val
argument_list|,
operator|(
name|long
operator|)
name|uid
argument_list|,
name|home
argument_list|,
name|stat
argument_list|(
name|home
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
literal|"not completely "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|M_PRINT
condition|)
return|return
name|print_user
argument_list|(
name|pwd
argument_list|,
name|getarg
argument_list|(
name|args
argument_list|,
literal|'P'
argument_list|)
operator|!=
name|NULL
argument_list|,
name|getarg
argument_list|(
name|args
argument_list|,
literal|'7'
argument_list|)
operator|!=
name|NULL
argument_list|)
return|;
comment|/* 		 * The rest is edit code 		 */
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'l'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"can't rename `root' account"
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_name
operator|=
name|pw_checkname
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|->
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'u'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|arg
operator|->
name|val
argument_list|)
condition|)
block|{
name|pwd
operator|->
name|pw_uid
operator|=
operator|(
name|uid_t
operator|)
name|atol
argument_list|(
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"can't change uid of `root' account"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"WARNING: account `%s' will have a uid of 0 (superuser access!)"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'g'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|pwd
operator|->
name|pw_uid
operator|!=
literal|0
condition|)
block|{
comment|/* Already checked this */
name|gid_t
name|newgid
init|=
operator|(
name|gid_t
operator|)
name|GETGRNAM
argument_list|(
name|cnf
operator|->
name|default_group
argument_list|)
operator|->
name|gr_gid
decl_stmt|;
if|if
condition|(
name|newgid
operator|!=
name|pwd
operator|->
name|pw_gid
condition|)
block|{
name|edited
operator|=
literal|1
expr_stmt|;
name|pwd
operator|->
name|pw_gid
operator|=
name|newgid
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'p'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|arg
operator|->
name|val
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pwd
operator|->
name|pw_change
operator|!=
literal|0
condition|)
block|{
name|pwd
operator|->
name|pw_change
operator|=
literal|0
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|time_t
name|expire
init|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|arg
operator|->
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|now
operator|==
name|expire
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid password change date `%s'"
argument_list|,
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_change
operator|!=
name|expire
condition|)
block|{
name|pwd
operator|->
name|pw_change
operator|=
name|expire
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'e'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|arg
operator|->
name|val
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pwd
operator|->
name|pw_expire
operator|!=
literal|0
condition|)
block|{
name|pwd
operator|->
name|pw_expire
operator|=
literal|0
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|time_t
name|expire
init|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|arg
operator|->
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|now
operator|==
name|expire
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid account expiry date `%s'"
argument_list|,
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_expire
operator|!=
name|expire
condition|)
block|{
name|pwd
operator|->
name|pw_expire
operator|=
name|expire
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'s'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|shell
init|=
name|shell_path
argument_list|(
name|cnf
operator|->
name|shelldir
argument_list|,
name|cnf
operator|->
name|shells
argument_list|,
name|arg
operator|->
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|shell
operator|==
name|NULL
condition|)
name|shell
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|shell
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pwd
operator|->
name|pw_shell
operator|=
name|shell
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'L'
argument_list|)
condition|)
block|{
if|if
condition|(
name|cnf
operator|->
name|default_class
operator|==
name|NULL
condition|)
name|cnf
operator|->
name|default_class
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_class
argument_list|,
name|cnf
operator|->
name|default_class
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pwd
operator|->
name|pw_class
operator|=
name|cnf
operator|->
name|default_class
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'d'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|,
name|arg
operator|->
name|val
argument_list|)
condition|)
name|edited
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|pwd
operator|->
name|pw_dir
operator|=
name|arg
operator|->
name|val
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'m'
argument_list|)
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|,
literal|"/nonexistent"
argument_list|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"WARNING: home `%s' does not exist"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"WARNING: home `%s' is not a directory"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'w'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'h'
argument_list|)
operator|==
name|NULL
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'H'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|login_cap_t
modifier|*
name|lc
decl_stmt|;
name|lc
operator|=
name|login_getpwclass
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
operator|||
name|login_setcryptfmt
argument_list|(
name|lc
argument_list|,
literal|"md5"
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"setting crypt(3) format"
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|pw_password
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|login_cap_t
modifier|*
name|lc
decl_stmt|;
comment|/* 		 * Add code 		 */
if|if
condition|(
name|a_name
operator|==
name|NULL
condition|)
comment|/* Required */
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"login name required"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pwd
operator|=
name|GETPWNAM
argument_list|(
name|a_name
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
comment|/* Exists */
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"login name `%s' already exists"
argument_list|,
name|a_name
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* 		 * Now, set up defaults for a new user 		 */
name|pwd
operator|=
operator|&
name|fakeuser
expr_stmt|;
name|pwd
operator|->
name|pw_name
operator|=
name|a_name
operator|->
name|val
expr_stmt|;
name|pwd
operator|->
name|pw_class
operator|=
name|cnf
operator|->
name|default_class
condition|?
name|cnf
operator|->
name|default_class
else|:
literal|""
expr_stmt|;
name|pwd
operator|->
name|pw_uid
operator|=
name|pw_uidpolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_gid
operator|=
name|pw_gidpolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|gid_t
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_change
operator|=
name|pw_pwdpolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_expire
operator|=
name|pw_exppolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_dir
operator|=
name|pw_homepolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_shell
operator|=
name|pw_shellpolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lc
operator|=
name|login_getpwclass
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
operator|||
name|login_setcryptfmt
argument_list|(
name|lc
argument_list|,
literal|"md5"
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"setting crypt(3) format"
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|pw_password
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"WARNING: new account `%s' has a uid of 0 (superuser access!)"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Shared add/edit code 	 */
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'c'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|gecos
init|=
name|pw_checkname
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|->
name|val
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_gecos
argument_list|,
name|gecos
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pwd
operator|->
name|pw_gecos
operator|=
name|gecos
expr_stmt|;
name|edited
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'h'
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'H'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|pwd
operator|->
name|pw_passwd
operator|||
operator|*
name|pwd
operator|->
name|pw_passwd
operator|!=
literal|'*'
condition|)
block|{
name|pwd
operator|->
name|pw_passwd
operator|=
literal|"*"
expr_stmt|;
comment|/* No access */
name|edited
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|fd
init|=
name|atoi
argument_list|(
name|arg
operator|->
name|val
argument_list|)
decl_stmt|;
name|int
name|precrypt
init|=
operator|(
name|arg
operator|->
name|ch
operator|==
literal|'H'
operator|)
decl_stmt|;
name|int
name|b
decl_stmt|;
name|int
name|istty
init|=
name|isatty
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|struct
name|termios
name|t
decl_stmt|;
name|login_cap_t
modifier|*
name|lc
decl_stmt|;
if|if
condition|(
name|istty
condition|)
block|{
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|t
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|istty
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|struct
name|termios
name|n
init|=
name|t
decl_stmt|;
comment|/* Disable echo */
name|n
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHO
operator|)
expr_stmt|;
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%spassword for user %s:"
argument_list|,
operator|(
name|mode
operator|==
name|M_UPDATE
operator|)
condition|?
literal|"new "
else|:
literal|""
argument_list|,
name|precrypt
condition|?
literal|"encrypted "
else|:
literal|""
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|istty
condition|)
block|{
comment|/* Restore state */
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"-%c file descriptor"
argument_list|,
name|precrypt
condition|?
literal|'H'
else|:
literal|'h'
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
name|line
index|[
name|b
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strpbrk
argument_list|(
name|line
argument_list|,
literal|" \t\r\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"empty password read on file descriptor %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|precrypt
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|EX_DATAERR
return|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
name|lc
operator|=
name|login_getpwclass
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
operator|||
name|login_setcryptfmt
argument_list|(
name|lc
argument_list|,
literal|"md5"
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"setting crypt(3) format"
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|pw_pwcrypt
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|edited
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Special case: -N only displays& exits 	 */
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'N'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|print_user
argument_list|(
name|pwd
argument_list|,
name|getarg
argument_list|(
name|args
argument_list|,
literal|'P'
argument_list|)
operator|!=
name|NULL
argument_list|,
name|getarg
argument_list|(
name|args
argument_list|,
literal|'7'
argument_list|)
operator|!=
name|NULL
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|M_ADD
condition|)
block|{
name|edited
operator|=
literal|1
expr_stmt|;
comment|/* Always */
name|rc
operator|=
name|addpwent
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"user '%s' already exists"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"passwd file update"
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
if|if
condition|(
name|cnf
operator|->
name|nispasswd
operator|&&
operator|*
name|cnf
operator|->
name|nispasswd
operator|==
literal|'/'
condition|)
block|{
name|rc
operator|=
name|addnispwent
argument_list|(
name|cnf
operator|->
name|nispasswd
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"User '%s' already exists in NIS passwd"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"NIS passwd update"
argument_list|)
expr_stmt|;
comment|/* NOTE: we treat NIS-only update errors as non-fatal */
block|}
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|M_UPDATE
operator|||
name|mode
operator|==
name|M_LOCK
operator|||
name|mode
operator|==
name|M_UNLOCK
condition|)
block|{
if|if
condition|(
name|edited
condition|)
block|{
comment|/* Only updated this if required */
name|rc
operator|=
name|chgpwent
argument_list|(
name|a_name
operator|->
name|val
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"user '%s' does not exist (NIS?)"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"passwd file update"
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
if|if
condition|(
name|cnf
operator|->
name|nispasswd
operator|&&
operator|*
name|cnf
operator|->
name|nispasswd
operator|==
literal|'/'
condition|)
block|{
name|rc
operator|=
name|chgnispwent
argument_list|(
name|cnf
operator|->
name|nispasswd
argument_list|,
name|a_name
operator|->
name|val
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"User '%s' not found in NIS passwd"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
else|else
name|warn
argument_list|(
literal|"NIS passwd update"
argument_list|)
expr_stmt|;
comment|/* NOTE: NIS-only update errors are not fatal */
block|}
block|}
block|}
comment|/* 	 * Ok, user is created or changed - now edit group file 	 */
if|if
condition|(
name|mode
operator|==
name|M_ADD
operator|||
name|getarg
argument_list|(
name|args
argument_list|,
literal|'G'
argument_list|)
operator|!=
name|NULL
condition|)
name|editgroups
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|cnf
operator|->
name|groups
argument_list|)
expr_stmt|;
comment|/* go get a current version of pwd */
name|pwd
operator|=
name|GETPWNAM
argument_list|(
name|a_name
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
comment|/* This will fail when we rename, so special case that */
if|if
condition|(
name|mode
operator|==
name|M_UPDATE
operator|&&
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'l'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|a_name
operator|->
name|val
operator|=
name|arg
operator|->
name|val
expr_stmt|;
comment|/* update new name */
name|pwd
operator|=
name|GETPWNAM
argument_list|(
name|a_name
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* refetch renamed rec */
block|}
block|}
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
comment|/* can't go on without this */
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"user '%s' disappeared during update"
argument_list|,
name|a_name
operator|->
name|val
argument_list|)
expr_stmt|;
name|grp
operator|=
name|GETGRGID
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ld):%s(%ld):%s:%s:%s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|grp
condition|?
name|grp
operator|->
name|gr_name
else|:
literal|"unknown"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|grp
condition|?
name|grp
operator|->
name|gr_gid
else|:
operator|-
literal|1
argument_list|)
argument_list|,
name|pwd
operator|->
name|pw_gecos
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
comment|/* 	 * If adding, let's touch and chown the user's mail file. This is not 	 * strictly necessary under BSD with a 0755 maildir but it also 	 * doesn't hurt anything to create the empty mailfile 	 */
if|if
condition|(
name|mode
operator|==
name|M_ADD
condition|)
block|{
if|if
condition|(
operator|!
name|PWALTDIR
argument_list|()
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s/%s"
argument_list|,
name|_PATH_MAILDIR
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|open
argument_list|(
name|line
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Preserve contents& 									 * mtime */
name|chown
argument_list|(
name|line
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Let's create and populate the user's home directory. Note 	 * that this also `works' for editing users if -m is used, but 	 * existing files will *not* be overwritten. 	 */
if|if
condition|(
operator|!
name|PWALTDIR
argument_list|()
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'m'
argument_list|)
operator|!=
name|NULL
operator|&&
name|pwd
operator|->
name|pw_dir
operator|&&
operator|*
name|pwd
operator|->
name|pw_dir
operator|==
literal|'/'
operator|&&
name|pwd
operator|->
name|pw_dir
index|[
literal|1
index|]
condition|)
block|{
name|copymkdir
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|,
name|cnf
operator|->
name|dotdir
argument_list|,
name|cnf
operator|->
name|homemode
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ld) home %s made"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Finally, send mail to the new user as well, if we are asked to 	 */
if|if
condition|(
name|mode
operator|==
name|M_ADD
operator|&&
operator|!
name|PWALTDIR
argument_list|()
operator|&&
name|cnf
operator|->
name|newmail
operator|&&
operator|*
name|cnf
operator|->
name|newmail
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|cnf
operator|->
name|newmail
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|pfp
init|=
name|popen
argument_list|(
name|_PATH_SENDMAIL
literal|" -t"
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"sendmail"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|pfp
argument_list|,
literal|"From: root\n"
literal|"To: %s\n"
literal|"Subject: Welcome!\n\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Do substitutions? */
name|fputs
argument_list|(
name|line
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
block|}
name|pclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ld) new user mail sent"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|uid_t
name|pw_uidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|uid_t
name|uid
init|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
decl_stmt|;
name|struct
name|carg
modifier|*
name|a_uid
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'u'
argument_list|)
decl_stmt|;
comment|/* 	 * Check the given uid, if any 	 */
if|if
condition|(
name|a_uid
operator|!=
name|NULL
condition|)
block|{
name|uid
operator|=
operator|(
name|uid_t
operator|)
name|atol
argument_list|(
name|a_uid
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pwd
operator|=
name|GETPWUID
argument_list|(
name|uid
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'o'
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"uid `%ld' has already been allocated"
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bitmap
name|bm
decl_stmt|;
comment|/* 		 * We need to allocate the next available uid under one of 		 * two policies a) Grab the first unused uid b) Grab the 		 * highest possible unused uid 		 */
if|if
condition|(
name|cnf
operator|->
name|min_uid
operator|>=
name|cnf
operator|->
name|max_uid
condition|)
block|{
comment|/* Sanity 							 * claus^H^H^H^Hheck */
name|cnf
operator|->
name|min_uid
operator|=
literal|1000
expr_stmt|;
name|cnf
operator|->
name|max_uid
operator|=
literal|32000
expr_stmt|;
block|}
name|bm
operator|=
name|bm_alloc
argument_list|(
name|cnf
operator|->
name|max_uid
operator|-
name|cnf
operator|->
name|min_uid
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Now, let's fill the bitmap from the password file 		 */
name|SETPWENT
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pwd
operator|=
name|GETPWENT
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|>=
operator|(
name|uid_t
operator|)
name|cnf
operator|->
name|min_uid
operator|&&
name|pwd
operator|->
name|pw_uid
operator|<=
operator|(
name|uid_t
operator|)
name|cnf
operator|->
name|max_uid
condition|)
name|bm_setbit
argument_list|(
operator|&
name|bm
argument_list|,
name|pwd
operator|->
name|pw_uid
operator|-
name|cnf
operator|->
name|min_uid
argument_list|)
expr_stmt|;
name|ENDPWENT
argument_list|()
expr_stmt|;
comment|/* 		 * Then apply the policy, with fallback to reuse if necessary 		 */
if|if
condition|(
name|cnf
operator|->
name|reuse_uids
operator|||
operator|(
name|uid
operator|=
call|(
name|uid_t
call|)
argument_list|(
name|bm_lastset
argument_list|(
operator|&
name|bm
argument_list|)
operator|+
name|cnf
operator|->
name|min_uid
operator|+
literal|1
argument_list|)
operator|)
operator|>
name|cnf
operator|->
name|max_uid
condition|)
name|uid
operator|=
call|(
name|uid_t
call|)
argument_list|(
name|bm_firstunset
argument_list|(
operator|&
name|bm
argument_list|)
operator|+
name|cnf
operator|->
name|min_uid
argument_list|)
expr_stmt|;
comment|/* 		 * Another sanity check 		 */
if|if
condition|(
name|uid
operator|<
name|cnf
operator|->
name|min_uid
operator|||
name|uid
operator|>
name|cnf
operator|->
name|max_uid
condition|)
name|errx
argument_list|(
name|EX_SOFTWARE
argument_list|,
literal|"unable to allocate a new uid - range fully used"
argument_list|)
expr_stmt|;
name|bm_dealloc
argument_list|(
operator|&
name|bm
argument_list|)
expr_stmt|;
block|}
return|return
name|uid
return|;
block|}
end_function

begin_function
specifier|static
name|uid_t
name|pw_gidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|nam
parameter_list|,
name|gid_t
name|prefer
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|gid_t
name|gid
init|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
decl_stmt|;
name|struct
name|carg
modifier|*
name|a_gid
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'g'
argument_list|)
decl_stmt|;
comment|/* 	 * If no arg given, see if default can help out 	 */
if|if
condition|(
name|a_gid
operator|==
name|NULL
operator|&&
name|cnf
operator|->
name|default_group
operator|&&
operator|*
name|cnf
operator|->
name|default_group
condition|)
name|a_gid
operator|=
name|addarg
argument_list|(
name|args
argument_list|,
literal|'g'
argument_list|,
name|cnf
operator|->
name|default_group
argument_list|)
expr_stmt|;
comment|/* 	 * Check the given gid, if any 	 */
name|SETGRENT
argument_list|()
expr_stmt|;
if|if
condition|(
name|a_gid
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|a_gid
operator|->
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|gid
operator|=
operator|(
name|gid_t
operator|)
name|atol
argument_list|(
name|a_gid
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gid
operator|==
literal|0
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|a_gid
operator|->
name|val
argument_list|)
operator|)
operator|||
operator|(
name|grp
operator|=
name|GETGRGID
argument_list|(
name|gid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"group `%s' is not defined"
argument_list|,
name|a_gid
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|nam
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|grp
operator|->
name|gr_mem
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
comment|/* Already created? Use it anyway... */
block|}
else|else
block|{
name|struct
name|cargs
name|grpargs
decl_stmt|;
name|char
name|tmp
index|[
literal|32
index|]
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|grpargs
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|&
name|grpargs
argument_list|,
literal|'n'
argument_list|,
name|nam
argument_list|)
expr_stmt|;
comment|/* 		 * We need to auto-create a group with the user's name. We 		 * can send all the appropriate output to our sister routine 		 * bit first see if we can create a group with gid==uid so we 		 * can keep the user and group ids in sync. We purposely do 		 * NOT check the gid range if we can force the sync. If the 		 * user's name dups an existing group, then the group add 		 * function will happily handle that case for us and exit. 		 */
if|if
condition|(
name|GETGRGID
argument_list|(
name|prefer
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|prefer
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|&
name|grpargs
argument_list|,
literal|'g'
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'N'
argument_list|)
condition|)
block|{
name|addarg
argument_list|(
operator|&
name|grpargs
argument_list|,
literal|'N'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|&
name|grpargs
argument_list|,
literal|'q'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gid
operator|=
name|pw_group
argument_list|(
name|cnf
argument_list|,
name|M_NEXT
argument_list|,
operator|&
name|grpargs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pw_group
argument_list|(
name|cnf
argument_list|,
name|M_ADD
argument_list|,
operator|&
name|grpargs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|nam
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
name|a_gid
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|grpargs
argument_list|)
expr_stmt|;
while|while
condition|(
name|a_gid
operator|!=
name|NULL
condition|)
block|{
name|struct
name|carg
modifier|*
name|t
init|=
name|LIST_NEXT
argument_list|(
name|a_gid
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|a_gid
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|a_gid
operator|=
name|t
expr_stmt|;
block|}
block|}
name|ENDGRENT
argument_list|()
expr_stmt|;
return|return
name|gid
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|pw_pwdpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
block|{
name|time_t
name|result
init|=
literal|0
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|carg
modifier|*
name|arg
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'p'
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|result
operator|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|arg
operator|->
name|val
argument_list|)
operator|)
operator|==
name|now
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid date/time `%s'"
argument_list|,
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cnf
operator|->
name|password_days
operator|>
literal|0
condition|)
name|result
operator|=
name|now
operator|+
operator|(
operator|(
name|long
operator|)
name|cnf
operator|->
name|password_days
operator|*
literal|86400L
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|pw_exppolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
block|{
name|time_t
name|result
init|=
literal|0
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|carg
modifier|*
name|arg
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'e'
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|result
operator|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|arg
operator|->
name|val
argument_list|)
operator|)
operator|==
name|now
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid date/time `%s'"
argument_list|,
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cnf
operator|->
name|expire_days
operator|>
literal|0
condition|)
name|result
operator|=
name|now
operator|+
operator|(
operator|(
name|long
operator|)
name|cnf
operator|->
name|expire_days
operator|*
literal|86400L
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pw_homepolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
specifier|const
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|carg
modifier|*
name|arg
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'d'
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
condition|)
return|return
name|arg
operator|->
name|val
return|;
else|else
block|{
specifier|static
name|char
name|home
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|cnf
operator|->
name|home
operator|==
name|NULL
operator|||
operator|*
name|cnf
operator|->
name|home
operator|==
literal|'\0'
condition|)
name|errx
argument_list|(
name|EX_CONFIG
argument_list|,
literal|"no base home directory set"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|home
argument_list|,
literal|"%s/%s"
argument_list|,
name|cnf
operator|->
name|home
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
name|home
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|shell_path
parameter_list|(
name|char
specifier|const
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|shells
index|[]
parameter_list|,
name|char
modifier|*
name|sh
parameter_list|)
block|{
if|if
condition|(
name|sh
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|sh
operator|==
literal|'/'
operator|||
operator|*
name|sh
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|sh
return|;
comment|/* specified full path or forced none */
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|paths
index|[
name|_UC_MAXLINE
index|]
decl_stmt|;
comment|/* 		 * We need to search paths 		 */
name|strlcpy
argument_list|(
name|paths
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|paths
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
name|paths
argument_list|,
literal|": \t\r\n"
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|": \t\r\n"
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|shellpath
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|sh
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|shellpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|p
argument_list|,
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|shellpath
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|shellpath
return|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_UC_MAXSHELLS
operator|&&
name|shells
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|shellpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|p
argument_list|,
name|shells
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|shellpath
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|shellpath
return|;
block|}
block|}
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"can't find shell `%s' in shell paths"
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_CONFIG
argument_list|,
literal|"no default shell available or defined"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pw_shellpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|newshell
parameter_list|)
block|{
name|char
modifier|*
name|sh
init|=
name|newshell
decl_stmt|;
name|struct
name|carg
modifier|*
name|arg
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'s'
argument_list|)
decl_stmt|;
if|if
condition|(
name|newshell
operator|==
name|NULL
operator|&&
name|arg
operator|!=
name|NULL
condition|)
name|sh
operator|=
name|arg
operator|->
name|val
expr_stmt|;
return|return
name|shell_path
argument_list|(
name|cnf
operator|->
name|shelldir
argument_list|,
name|cnf
operator|->
name|shells
argument_list|,
name|sh
condition|?
name|sh
else|:
name|cnf
operator|->
name|shell_default
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
specifier|const
name|chars
index|[]
init|=
literal|"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ."
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|pw_pwcrypt
parameter_list|(
name|char
modifier|*
name|password
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|salt
index|[
literal|12
index|]
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* 	 * Calculate a salt value 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|salt
index|[
name|i
index|]
operator|=
name|chars
index|[
name|arc4random
argument_list|()
operator|%
literal|63
index|]
expr_stmt|;
name|salt
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|strcpy
argument_list|(
name|buf
argument_list|,
name|crypt
argument_list|(
name|password
argument_list|,
name|salt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_MD5RAND
argument_list|)
end_if

begin_function
name|u_char
modifier|*
name|pw_getrand
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
comment|/* cryptographically secure rng */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|u_char
name|ubuf
index|[
literal|16
index|]
decl_stmt|;
name|MD5_CTX
name|md5_ctx
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|,
name|tvo
decl_stmt|;
name|struct
name|rusage
name|ru
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|t
decl_stmt|;
name|MD5Init
argument_list|(
operator|&
name|md5_ctx
argument_list|)
expr_stmt|;
name|t
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|t
argument_list|,
sizeof|sizeof
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|getppid
argument_list|()
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|t
argument_list|,
sizeof|sizeof
name|t
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tvo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
do|do
block|{
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|ru
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ru
argument_list|,
sizeof|sizeof
name|ru
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tv
argument_list|,
sizeof|sizeof
name|tv
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|++
operator|<
literal|20
operator|||
name|tv
operator|.
name|tv_usec
operator|-
name|tvo
operator|.
name|tv_usec
operator|<
literal|100
operator|*
literal|1000
condition|)
do|;
name|MD5Final
argument_list|(
name|ubuf
argument_list|,
operator|&
name|md5_ctx
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|i
argument_list|,
name|ubuf
argument_list|,
name|MIN
argument_list|(
literal|16
argument_list|,
name|len
operator|-
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Portable version */
end_comment

begin_function
specifier|static
name|u_char
modifier|*
name|pw_getrand
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|val
init|=
name|arc4random
argument_list|()
decl_stmt|;
comment|/* Use all bits in the random value */
name|buf
index|[
name|i
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|val
operator|>>
literal|24
operator|)
operator|^
operator|(
name|val
operator|>>
literal|16
operator|)
operator|^
operator|(
name|val
operator|>>
literal|8
operator|)
operator|^
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|pw_password
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
specifier|const
modifier|*
name|user
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|char
name|pwbuf
index|[
literal|32
index|]
decl_stmt|;
name|u_char
name|rndbuf
index|[
sizeof|sizeof
name|pwbuf
index|]
decl_stmt|;
switch|switch
condition|(
name|cnf
operator|->
name|default_password
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Random password */
name|l
operator|=
operator|(
name|arc4random
argument_list|()
operator|%
literal|8
operator|+
literal|8
operator|)
expr_stmt|;
comment|/* 8 - 16 chars */
name|pw_getrand
argument_list|(
name|rndbuf
argument_list|,
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|pwbuf
index|[
name|i
index|]
operator|=
name|chars
index|[
name|rndbuf
index|[
name|i
index|]
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|chars
argument_list|)
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|pwbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * We give this information back to the user 		 */
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'h'
argument_list|)
operator|==
name|NULL
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'H'
argument_list|)
operator|==
name|NULL
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'N'
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Password for '%s' is: "
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|pwbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|2
case|:
comment|/* No password at all! */
return|return
literal|""
return|;
case|case
literal|0
case|:
comment|/* No login - default */
default|default:
return|return
literal|"*"
return|;
case|case
literal|1
case|:
comment|/* user's name */
name|strlcpy
argument_list|(
name|pwbuf
argument_list|,
name|user
argument_list|,
sizeof|sizeof
argument_list|(
name|pwbuf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|pw_pwcrypt
argument_list|(
name|pwbuf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_user
parameter_list|(
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|int
name|pretty
parameter_list|,
name|int
name|v7
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pretty
condition|)
block|{
name|char
name|buf
index|[
name|_UC_MAXLINE
index|]
decl_stmt|;
name|fmtpwentry
argument_list|(
name|buf
argument_list|,
name|pwd
argument_list|,
name|v7
condition|?
name|PWF_PASSWD
else|:
name|PWF_STANDARD
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
init|=
name|GETGRGID
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
decl_stmt|;
name|char
name|uname
index|[
literal|60
index|]
init|=
literal|"User&"
decl_stmt|,
name|office
index|[
literal|60
index|]
init|=
literal|"[None]"
decl_stmt|,
name|wphone
index|[
literal|60
index|]
init|=
literal|"[None]"
decl_stmt|,
name|hphone
index|[
literal|60
index|]
init|=
literal|"[None]"
decl_stmt|;
name|char
name|acexpire
index|[
literal|32
index|]
init|=
literal|"[None]"
decl_stmt|,
name|pwexpire
index|[
literal|32
index|]
init|=
literal|"[None]"
decl_stmt|;
name|struct
name|tm
modifier|*
name|tptr
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|pwd
operator|->
name|pw_gecos
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|uname
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|uname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|office
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|office
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|wphone
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|wphone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|""
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|hphone
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|hphone
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 		 * Handle '&' in gecos field 		 */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|uname
argument_list|,
literal|'&'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
decl_stmt|;
name|int
name|m
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|memmove
argument_list|(
name|p
operator|+
name|l
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|l
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|toupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pwd
operator|->
name|pw_expire
operator|>
operator|(
name|time_t
operator|)
literal|0
operator|&&
operator|(
name|tptr
operator|=
name|localtime
argument_list|(
operator|&
name|pwd
operator|->
name|pw_expire
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|strftime
argument_list|(
name|acexpire
argument_list|,
sizeof|sizeof
name|acexpire
argument_list|,
literal|"%c"
argument_list|,
name|tptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_change
operator|>
operator|(
name|time_t
operator|)
literal|0
operator|&&
operator|(
name|tptr
operator|=
name|localtime
argument_list|(
operator|&
name|pwd
operator|->
name|pw_change
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|strftime
argument_list|(
name|pwexpire
argument_list|,
sizeof|sizeof
name|pwexpire
argument_list|,
literal|"%c"
argument_list|,
name|tptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Login Name: %-15s   #%-12ld Group: %-15s   #%ld\n"
literal|" Full Name: %s\n"
literal|"      Home: %-26.26s      Class: %s\n"
literal|"     Shell: %-26.26s     Office: %s\n"
literal|"Work Phone: %-26.26s Home Phone: %s\n"
literal|"Acc Expire: %-26.26s Pwd Expire: %s\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|grp
condition|?
name|grp
operator|->
name|gr_name
else|:
literal|"(invalid)"
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_gid
argument_list|,
name|uname
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_class
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|,
name|office
argument_list|,
name|wphone
argument_list|,
name|hphone
argument_list|,
name|acexpire
argument_list|,
name|pwexpire
argument_list|)
expr_stmt|;
name|SETGRENT
argument_list|()
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|grp
operator|=
name|GETGRENT
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|j
operator|++
operator|==
literal|0
condition|?
literal|"    Groups: %s"
else|:
literal|",%s"
argument_list|,
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
name|ENDGRENT
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|j
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|pw_checkname
parameter_list|(
name|u_char
modifier|*
name|name
parameter_list|,
name|int
name|gecos
parameter_list|)
block|{
name|char
name|showch
index|[
literal|8
index|]
decl_stmt|;
name|u_char
specifier|const
modifier|*
name|badchars
decl_stmt|,
modifier|*
name|ch
decl_stmt|,
modifier|*
name|showtype
decl_stmt|;
name|int
name|reject
decl_stmt|;
name|ch
operator|=
name|name
expr_stmt|;
name|reject
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gecos
condition|)
block|{
comment|/* See if the name is valid as a gecos (comment) field. */
name|badchars
operator|=
literal|":!@"
expr_stmt|;
name|showtype
operator|=
literal|"gecos field"
expr_stmt|;
block|}
else|else
block|{
comment|/* See if the name is valid as a userid or group. */
name|badchars
operator|=
literal|" ,\t:+&#%$^()!@~*?<>=|\\/\""
expr_stmt|;
name|showtype
operator|=
literal|"userid/group name"
expr_stmt|;
comment|/* Userids and groups can not have a leading '-'. */
if|if
condition|(
operator|*
name|ch
operator|==
literal|'-'
condition|)
name|reject
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reject
condition|)
block|{
while|while
condition|(
operator|*
name|ch
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|badchars
argument_list|,
operator|*
name|ch
argument_list|)
operator|!=
name|NULL
operator|||
operator|*
name|ch
operator|<
literal|' '
operator|||
operator|*
name|ch
operator|==
literal|127
condition|)
block|{
name|reject
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 8-bit characters are only allowed in GECOS fields */
if|if
condition|(
operator|!
name|gecos
operator|&&
operator|(
operator|*
name|ch
operator|&
literal|0x80
operator|)
condition|)
block|{
name|reject
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ch
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * A `$' is allowed as the final character for userids and groups, 	 * mainly for the benefit of samba. 	 */
if|if
condition|(
name|reject
operator|&&
operator|!
name|gecos
condition|)
block|{
if|if
condition|(
operator|*
name|ch
operator|==
literal|'$'
operator|&&
operator|*
operator|(
name|ch
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|reject
operator|=
literal|0
expr_stmt|;
name|ch
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reject
condition|)
block|{
name|snprintf
argument_list|(
name|showch
argument_list|,
sizeof|sizeof
argument_list|(
name|showch
argument_list|)
argument_list|,
operator|(
operator|*
name|ch
operator|>=
literal|' '
operator|&&
operator|*
name|ch
operator|<
literal|127
operator|)
condition|?
literal|"`%c'"
else|:
literal|"0x%02x"
argument_list|,
operator|*
name|ch
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid character %s at position %d in %s"
argument_list|,
name|showch
argument_list|,
operator|(
name|ch
operator|-
name|name
operator|)
argument_list|,
name|showtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gecos
operator|&&
operator|(
name|ch
operator|-
name|name
operator|)
operator|>
name|LOGNAMESIZE
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"name too long `%s' (max is %d)"
argument_list|,
name|name
argument_list|,
name|LOGNAMESIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rmat
parameter_list|(
name|uid_t
name|uid
parameter_list|)
block|{
name|DIR
modifier|*
name|d
init|=
name|opendir
argument_list|(
literal|"/var/at/jobs"
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|struct
name|dirent
modifier|*
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|e
operator|->
name|d_name
argument_list|,
literal|".lock"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|&&
name|stat
argument_list|(
name|e
operator|->
name|d_name
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
name|st
operator|.
name|st_uid
operator|==
name|uid
condition|)
block|{
name|char
name|tmp
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"/usr/bin/atrm %s"
argument_list|,
name|e
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rmopie
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|etcopie
index|[]
init|=
literal|"/etc/opiekeys"
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|etcopie
argument_list|,
literal|"r+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|char
name|tmp
index|[
literal|1024
index|]
decl_stmt|;
name|off_t
name|atofs
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
name|tmp
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|tmp
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|&&
name|tmp
index|[
name|length
index|]
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
name|atofs
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fwrite
argument_list|(
literal|"#"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Comment username out */
block|}
break|break;
block|}
name|atofs
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we got an error of any sort, don't update! 		 */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

