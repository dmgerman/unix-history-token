begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1996  *	David L. Nugent.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY DAVID L. NUGENT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DAVID L. NUGENT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<login_cap.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pw.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"psdate.h"
end_include

begin_define
define|#
directive|define
name|LOGNAMESIZE
value|(MAXLOGNAME-1)
end_define

begin_decl_stmt
specifier|static
name|char
name|locked_str
index|[]
init|=
literal|"*LOCKED*"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|passwd
name|fakeuser
init|=
block|{
literal|"nouser"
block|,
literal|"*"
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|""
block|,
literal|"User&"
block|,
literal|"/nonexistent"
block|,
literal|"/bin/sh"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|print_user
parameter_list|(
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|bool
name|pretty
parameter_list|,
name|bool
name|v7
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uid_t
name|pw_uidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|intmax_t
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uid_t
name|pw_gidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|char
modifier|*
name|grname
parameter_list|,
name|char
modifier|*
name|nam
parameter_list|,
name|gid_t
name|prefer
parameter_list|,
name|bool
name|dryrun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pw_homepolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|char
modifier|*
name|homedir
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pw_shellpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pw_password
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|char
specifier|const
modifier|*
name|user
parameter_list|,
name|bool
name|dryrun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|shell_path
parameter_list|(
name|char
specifier|const
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|shells
index|[]
parameter_list|,
name|char
modifier|*
name|sh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmat
parameter_list|(
name|uid_t
name|uid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmopie
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|mkdir_home_parents
parameter_list|(
name|int
name|dfd
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|dirs
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
operator|*
name|dir
operator|!=
literal|'/'
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid base directory for home '%s'"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|dir
operator|++
expr_stmt|;
if|if
condition|(
name|fstatat
argument_list|(
name|dfd
argument_list|,
name|dir
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return;
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"root home `/%s' is not a directory"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
name|dirs
operator|=
name|strdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirs
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|strrchr
argument_list|(
name|dirs
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
return|return;
block|}
name|tmp
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * This is a kludge especially for Joerg :) 	 * If the home directory would be created in the root partition, then 	 * we really create it under /usr which is likely to have more space. 	 * But we create a symlink from cnf->home -> "/usr" -> cnf->home 	 */
if|if
condition|(
name|strchr
argument_list|(
name|dirs
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|tmp
argument_list|,
literal|"usr/%s"
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdirat
argument_list|(
name|dfd
argument_list|,
name|tmp
argument_list|,
name|_DEF_DIRMODE
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|==
name|EEXIST
condition|)
block|{
name|fchownat
argument_list|(
name|dfd
argument_list|,
name|tmp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symlinkat
argument_list|(
name|tmp
argument_list|,
name|dfd
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|dirs
expr_stmt|;
if|if
condition|(
name|fstatat
argument_list|(
name|dfd
argument_list|,
name|dirs
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
while|while
condition|(
operator|(
name|tmp
operator|=
name|strchr
argument_list|(
name|tmp
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|tmp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|fstatat
argument_list|(
name|dfd
argument_list|,
name|dirs
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mkdirat
argument_list|(
name|dfd
argument_list|,
name|dirs
argument_list|,
name|_DEF_DIRMODE
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"'%s' (root home parent) is not a directory"
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
block|}
operator|*
name|tmp
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fstatat
argument_list|(
name|dfd
argument_list|,
name|dirs
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mkdirat
argument_list|(
name|dfd
argument_list|,
name|dirs
argument_list|,
name|_DEF_DIRMODE
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"'%s' (root home parent) is not a directory"
argument_list|,
name|dirs
argument_list|)
expr_stmt|;
name|fchownat
argument_list|(
name|dfd
argument_list|,
name|dirs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dirs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_and_populate_homedir
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
specifier|const
name|char
modifier|*
name|skeldir
parameter_list|,
name|mode_t
name|homemode
parameter_list|,
name|bool
name|update
parameter_list|)
block|{
name|int
name|skelfd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Create home parents directories */
name|mkdir_home_parents
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|skeldir
operator|!=
name|NULL
operator|&&
operator|*
name|skeldir
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|skeldir
operator|==
literal|'/'
condition|)
name|skeldir
operator|++
expr_stmt|;
name|skelfd
operator|=
name|openat
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|skeldir
argument_list|,
name|O_DIRECTORY
operator||
name|O_CLOEXEC
argument_list|)
expr_stmt|;
block|}
name|copymkdir
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|skelfd
argument_list|,
name|homemode
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|update
condition|?
name|M_UPDATE
else|:
name|M_ADD
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ju) home %s made"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pw_set_passwd
parameter_list|(
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|int
name|fd
parameter_list|,
name|bool
name|precrypted
parameter_list|,
name|bool
name|update
parameter_list|)
block|{
name|int
name|b
decl_stmt|,
name|istty
decl_stmt|;
name|struct
name|termios
name|t
decl_stmt|,
name|n
decl_stmt|;
name|login_cap_t
modifier|*
name|lc
decl_stmt|;
name|char
name|line
index|[
name|_PASSWORD_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|fd
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|!
name|pwd
operator|->
name|pw_passwd
operator|||
operator|*
name|pwd
operator|->
name|pw_passwd
operator|!=
literal|'*'
condition|)
block|{
name|pwd
operator|->
name|pw_passwd
operator|=
literal|"*"
expr_stmt|;
comment|/* No access */
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|istty
operator|=
name|isatty
argument_list|(
name|fd
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|t
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|istty
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|n
operator|=
name|t
expr_stmt|;
name|n
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHO
operator|)
expr_stmt|;
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%spassword for user %s:"
argument_list|,
name|update
condition|?
literal|"new "
else|:
literal|""
argument_list|,
name|precrypted
condition|?
literal|"encrypted "
else|:
literal|""
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|istty
condition|)
block|{
comment|/* Restore state */
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_IOERR
argument_list|,
literal|"-%c file descriptor"
argument_list|,
name|precrypted
condition|?
literal|'H'
else|:
literal|'h'
argument_list|)
expr_stmt|;
name|line
index|[
name|b
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strpbrk
argument_list|(
name|line
argument_list|,
literal|"\r\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"empty password read on file descriptor %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|precrypted
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"bad encrypted password"
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|strdup
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lc
operator|=
name|login_getpwclass
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
operator|||
name|login_setcryptfmt
argument_list|(
name|lc
argument_list|,
literal|"sha512"
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"setting crypt(3) format"
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|pw_pwcrypt
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|perform_chgpwent
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|char
modifier|*
name|nispasswd
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|passwd
modifier|*
name|nispwd
decl_stmt|;
comment|/* duplicate for nis so that chgpwent is not modifying before NIS */
if|if
condition|(
name|nispasswd
operator|&&
operator|*
name|nispasswd
operator|==
literal|'/'
condition|)
name|nispwd
operator|=
name|pw_dup
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
name|rc
operator|=
name|chgpwent
argument_list|(
name|name
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_IOERR
argument_list|,
literal|"user '%s' does not exist (NIS?)"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|err
argument_list|(
name|EX_IOERR
argument_list|,
literal|"passwd file update"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nispasswd
operator|&&
operator|*
name|nispasswd
operator|==
literal|'/'
condition|)
block|{
name|rc
operator|=
name|chgnispwent
argument_list|(
name|nispasswd
argument_list|,
name|name
argument_list|,
name|nispwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"User '%s' not found in NIS passwd"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"NIS passwd update"
argument_list|)
expr_stmt|;
comment|/* NOTE: NIS-only update errors are not fatal */
block|}
block|}
end_function

begin_comment
comment|/*  * The M_LOCK and M_UNLOCK functions simply add or remove  * a "*LOCKED*" prefix from in front of the password to  * prevent it decoding correctly, and therefore prevents  * access. Of course, this only prevents access via  * password authentication (not ssh, kerberos or any  * other method that does not use the UNIX password) but  * that is a known limitation.  */
end_comment

begin_function
specifier|static
name|int
name|pw_userlock
parameter_list|(
name|char
modifier|*
name|arg1
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|passtmp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|bool
name|locked
init|=
name|false
decl_stmt|;
name|uid_t
name|id
init|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
name|errx
argument_list|(
name|EX_NOPERM
argument_list|,
literal|"you must be root"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"username or id required"
argument_list|)
expr_stmt|;
name|name
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|arg1
index|[
name|strspn
argument_list|(
name|name
argument_list|,
literal|"0123456789"
argument_list|)
index|]
operator|==
literal|'\0'
condition|)
name|id
operator|=
name|pw_checkid
argument_list|(
name|name
argument_list|,
name|UID_MAX
argument_list|)
expr_stmt|;
name|pwd
operator|=
name|GETPWNAM
argument_list|(
name|pw_checkname
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
operator|&&
name|id
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
condition|)
block|{
name|pwd
operator|=
name|GETPWUID
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
name|name
operator|=
name|pwd
operator|->
name|pw_name
expr_stmt|;
block|}
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|id
operator|==
operator|(
name|uid_t
operator|)
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such name or uid `%ju'"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|id
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such user `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|pwd
operator|->
name|pw_name
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|pwd
operator|->
name|pw_passwd
argument_list|,
name|locked_str
argument_list|,
sizeof|sizeof
argument_list|(
name|locked_str
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|locked
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|M_LOCK
operator|&&
name|locked
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"user '%s' is already locked"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|M_UNLOCK
operator|&&
operator|!
name|locked
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"user '%s' is not locked"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|M_LOCK
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|passtmp
argument_list|,
literal|"%s%s"
argument_list|,
name|locked_str
argument_list|,
name|pwd
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|passtmp
operator|==
name|NULL
condition|)
comment|/* disaster */
name|errx
argument_list|(
name|EX_UNAVAILABLE
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|passtmp
expr_stmt|;
block|}
else|else
block|{
name|pwd
operator|->
name|pw_passwd
operator|+=
sizeof|sizeof
argument_list|(
name|locked_str
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
name|perform_chgpwent
argument_list|(
name|name
argument_list|,
name|pwd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|passtmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uid_t
name|pw_uidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|intmax_t
name|id
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|bitmap
name|bm
decl_stmt|;
name|uid_t
name|uid
init|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* 	 * Check the given uid, if any 	 */
if|if
condition|(
name|id
operator|>=
literal|0
condition|)
block|{
name|uid
operator|=
operator|(
name|uid_t
operator|)
name|id
expr_stmt|;
if|if
condition|(
operator|(
name|pwd
operator|=
name|GETPWUID
argument_list|(
name|uid
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|conf
operator|.
name|checkduplicate
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"uid `%ju' has already been allocated"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
return|return
operator|(
name|uid
operator|)
return|;
block|}
comment|/* 	 * We need to allocate the next available uid under one of 	 * two policies a) Grab the first unused uid b) Grab the 	 * highest possible unused uid 	 */
if|if
condition|(
name|cnf
operator|->
name|min_uid
operator|>=
name|cnf
operator|->
name|max_uid
condition|)
block|{
comment|/* Sanity 						 * claus^H^H^H^Hheck */
name|cnf
operator|->
name|min_uid
operator|=
literal|1000
expr_stmt|;
name|cnf
operator|->
name|max_uid
operator|=
literal|32000
expr_stmt|;
block|}
name|bm
operator|=
name|bm_alloc
argument_list|(
name|cnf
operator|->
name|max_uid
operator|-
name|cnf
operator|->
name|min_uid
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Now, let's fill the bitmap from the password file 	 */
name|SETPWENT
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pwd
operator|=
name|GETPWENT
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|>=
operator|(
name|uid_t
operator|)
name|cnf
operator|->
name|min_uid
operator|&&
name|pwd
operator|->
name|pw_uid
operator|<=
operator|(
name|uid_t
operator|)
name|cnf
operator|->
name|max_uid
condition|)
name|bm_setbit
argument_list|(
operator|&
name|bm
argument_list|,
name|pwd
operator|->
name|pw_uid
operator|-
name|cnf
operator|->
name|min_uid
argument_list|)
expr_stmt|;
name|ENDPWENT
argument_list|()
expr_stmt|;
comment|/* 	 * Then apply the policy, with fallback to reuse if necessary 	 */
if|if
condition|(
name|cnf
operator|->
name|reuse_uids
operator|||
operator|(
name|uid
operator|=
call|(
name|uid_t
call|)
argument_list|(
name|bm_lastset
argument_list|(
operator|&
name|bm
argument_list|)
operator|+
name|cnf
operator|->
name|min_uid
operator|+
literal|1
argument_list|)
operator|)
operator|>
name|cnf
operator|->
name|max_uid
condition|)
name|uid
operator|=
call|(
name|uid_t
call|)
argument_list|(
name|bm_firstunset
argument_list|(
operator|&
name|bm
argument_list|)
operator|+
name|cnf
operator|->
name|min_uid
argument_list|)
expr_stmt|;
comment|/* 	 * Another sanity check 	 */
if|if
condition|(
name|uid
operator|<
name|cnf
operator|->
name|min_uid
operator|||
name|uid
operator|>
name|cnf
operator|->
name|max_uid
condition|)
name|errx
argument_list|(
name|EX_SOFTWARE
argument_list|,
literal|"unable to allocate a new uid - range fully used"
argument_list|)
expr_stmt|;
name|bm_dealloc
argument_list|(
operator|&
name|bm
argument_list|)
expr_stmt|;
return|return
operator|(
name|uid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uid_t
name|pw_gidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|char
modifier|*
name|grname
parameter_list|,
name|char
modifier|*
name|nam
parameter_list|,
name|gid_t
name|prefer
parameter_list|,
name|bool
name|dryrun
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|gid_t
name|gid
init|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
decl_stmt|;
comment|/* 	 * Check the given gid, if any 	 */
name|SETGRENT
argument_list|()
expr_stmt|;
if|if
condition|(
name|grname
condition|)
block|{
if|if
condition|(
operator|(
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|grname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|gid
operator|=
name|pw_checkid
argument_list|(
name|grname
argument_list|,
name|GID_MAX
argument_list|)
expr_stmt|;
name|grp
operator|=
name|GETGRGID
argument_list|(
name|gid
argument_list|)
expr_stmt|;
block|}
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|nam
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|grp
operator|->
name|gr_mem
operator|==
name|NULL
operator|||
name|grp
operator|->
name|gr_mem
index|[
literal|0
index|]
operator|==
name|NULL
operator|)
condition|)
block|{
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
comment|/* Already created? Use it anyway... */
block|}
else|else
block|{
name|intmax_t
name|grid
init|=
operator|-
literal|1
decl_stmt|;
comment|/* 		 * We need to auto-create a group with the user's name. We 		 * can send all the appropriate output to our sister routine 		 * bit first see if we can create a group with gid==uid so we 		 * can keep the user and group ids in sync. We purposely do 		 * NOT check the gid range if we can force the sync. If the 		 * user's name dups an existing group, then the group add 		 * function will happily handle that case for us and exit. 		 */
if|if
condition|(
name|GETGRGID
argument_list|(
name|prefer
argument_list|)
operator|==
name|NULL
condition|)
name|grid
operator|=
name|prefer
expr_stmt|;
if|if
condition|(
name|dryrun
condition|)
block|{
name|gid
operator|=
name|pw_groupnext
argument_list|(
name|cnf
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|grid
operator|==
operator|-
literal|1
condition|)
name|grid
operator|=
name|pw_groupnext
argument_list|(
name|cnf
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|groupadd
argument_list|(
name|cnf
argument_list|,
name|nam
argument_list|,
name|grid
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|,
name|false
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|nam
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
block|}
name|ENDGRENT
argument_list|()
expr_stmt|;
return|return
operator|(
name|gid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pw_homepolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|char
modifier|*
name|homedir
parameter_list|,
specifier|const
name|char
modifier|*
name|user
parameter_list|)
block|{
specifier|static
name|char
name|home
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|homedir
condition|)
return|return
operator|(
name|homedir
operator|)
return|;
if|if
condition|(
name|cnf
operator|->
name|home
operator|==
name|NULL
operator|||
operator|*
name|cnf
operator|->
name|home
operator|==
literal|'\0'
condition|)
name|errx
argument_list|(
name|EX_CONFIG
argument_list|,
literal|"no base home directory set"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|home
argument_list|,
sizeof|sizeof
argument_list|(
name|home
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|cnf
operator|->
name|home
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
operator|(
name|home
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|shell_path
parameter_list|(
name|char
specifier|const
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|shells
index|[]
parameter_list|,
name|char
modifier|*
name|sh
parameter_list|)
block|{
if|if
condition|(
name|sh
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|sh
operator|==
literal|'/'
operator|||
operator|*
name|sh
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|sh
return|;
comment|/* specified full path or forced none */
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|paths
index|[
name|_UC_MAXLINE
index|]
decl_stmt|;
comment|/* 		 * We need to search paths 		 */
name|strlcpy
argument_list|(
name|paths
argument_list|,
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|paths
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
name|paths
argument_list|,
literal|": \t\r\n"
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|": \t\r\n"
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|shellpath
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|sh
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|shellpath
argument_list|,
sizeof|sizeof
argument_list|(
name|shellpath
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|p
argument_list|,
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|shellpath
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|shellpath
return|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_UC_MAXSHELLS
operator|&&
name|shells
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|shellpath
argument_list|,
sizeof|sizeof
argument_list|(
name|shellpath
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|p
argument_list|,
name|shells
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|shellpath
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|shellpath
return|;
block|}
block|}
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"can't find shell `%s' in shell paths"
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_CONFIG
argument_list|,
literal|"no default shell available or defined"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pw_shellpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|)
block|{
return|return
name|shell_path
argument_list|(
name|cnf
operator|->
name|shelldir
argument_list|,
name|cnf
operator|->
name|shells
argument_list|,
name|cnf
operator|->
name|shell_default
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SALTSIZE
value|32
end_define

begin_decl_stmt
specifier|static
name|char
specifier|const
name|chars
index|[]
init|=
literal|"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ./"
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|pw_pwcrypt
parameter_list|(
name|char
modifier|*
name|password
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|salt
index|[
name|SALTSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|cryptpw
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|size_t
name|pwlen
decl_stmt|;
comment|/* 	 * Calculate a salt value 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SALTSIZE
condition|;
name|i
operator|++
control|)
name|salt
index|[
name|i
index|]
operator|=
name|chars
index|[
name|arc4random_uniform
argument_list|(
sizeof|sizeof
argument_list|(
name|chars
argument_list|)
operator|-
literal|1
argument_list|)
index|]
expr_stmt|;
name|salt
index|[
name|SALTSIZE
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cryptpw
operator|=
name|crypt
argument_list|(
name|password
argument_list|,
name|salt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cryptpw
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_CONFIG
argument_list|,
literal|"crypt(3) failure"
argument_list|)
expr_stmt|;
name|pwlen
operator|=
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|cryptpw
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pwlen
operator|<
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pw_password
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|char
specifier|const
modifier|*
name|user
parameter_list|,
name|bool
name|dryrun
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|char
name|pwbuf
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|cnf
operator|->
name|default_password
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Random password */
name|l
operator|=
operator|(
name|arc4random
argument_list|()
operator|%
literal|8
operator|+
literal|8
operator|)
expr_stmt|;
comment|/* 8 - 16 chars */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|pwbuf
index|[
name|i
index|]
operator|=
name|chars
index|[
name|arc4random_uniform
argument_list|(
sizeof|sizeof
argument_list|(
name|chars
argument_list|)
operator|-
literal|1
argument_list|)
index|]
expr_stmt|;
name|pwbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * We give this information back to the user 		 */
if|if
condition|(
name|conf
operator|.
name|fd
operator|==
operator|-
literal|1
operator|&&
operator|!
name|dryrun
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Password for '%s' is: "
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|pwbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|2
case|:
comment|/* No password at all! */
return|return
literal|""
return|;
case|case
literal|0
case|:
comment|/* No login - default */
default|default:
return|return
literal|"*"
return|;
case|case
literal|1
case|:
comment|/* user's name */
name|strlcpy
argument_list|(
name|pwbuf
argument_list|,
name|user
argument_list|,
sizeof|sizeof
argument_list|(
name|pwbuf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|pw_pwcrypt
argument_list|(
name|pwbuf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_user
parameter_list|(
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|bool
name|pretty
parameter_list|,
name|bool
name|v7
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
init|=
name|GETGRGID
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
decl_stmt|;
name|char
name|uname
index|[
literal|60
index|]
init|=
literal|"User&"
decl_stmt|,
name|office
index|[
literal|60
index|]
init|=
literal|"[None]"
decl_stmt|,
name|wphone
index|[
literal|60
index|]
init|=
literal|"[None]"
decl_stmt|,
name|hphone
index|[
literal|60
index|]
init|=
literal|"[None]"
decl_stmt|;
name|char
name|acexpire
index|[
literal|32
index|]
init|=
literal|"[None]"
decl_stmt|,
name|pwexpire
index|[
literal|32
index|]
init|=
literal|"[None]"
decl_stmt|;
name|struct
name|tm
modifier|*
name|tptr
decl_stmt|;
if|if
condition|(
operator|!
name|pretty
condition|)
block|{
name|p
operator|=
name|v7
condition|?
name|pw_make_v7
argument_list|(
name|pwd
argument_list|)
else|:
name|pw_make
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|pwd
operator|->
name|pw_gecos
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|uname
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|uname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|office
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|office
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|wphone
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|wphone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|""
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|hphone
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|hphone
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Handle '&' in gecos field 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|uname
argument_list|,
literal|'&'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
decl_stmt|;
name|int
name|m
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|memmove
argument_list|(
name|p
operator|+
name|l
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|l
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|toupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pwd
operator|->
name|pw_expire
operator|>
operator|(
name|time_t
operator|)
literal|0
operator|&&
operator|(
name|tptr
operator|=
name|localtime
argument_list|(
operator|&
name|pwd
operator|->
name|pw_expire
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|strftime
argument_list|(
name|acexpire
argument_list|,
sizeof|sizeof
name|acexpire
argument_list|,
literal|"%c"
argument_list|,
name|tptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_change
operator|>
operator|(
name|time_t
operator|)
literal|0
operator|&&
operator|(
name|tptr
operator|=
name|localtime
argument_list|(
operator|&
name|pwd
operator|->
name|pw_change
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|strftime
argument_list|(
name|pwexpire
argument_list|,
sizeof|sizeof
name|pwexpire
argument_list|,
literal|"%c"
argument_list|,
name|tptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Login Name: %-15s   #%-12ju Group: %-15s   #%ju\n"
literal|" Full Name: %s\n"
literal|"      Home: %-26.26s      Class: %s\n"
literal|"     Shell: %-26.26s     Office: %s\n"
literal|"Work Phone: %-26.26s Home Phone: %s\n"
literal|"Acc Expire: %-26.26s Pwd Expire: %s\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|grp
condition|?
name|grp
operator|->
name|gr_name
else|:
literal|"(invalid)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pwd
operator|->
name|pw_gid
argument_list|,
name|uname
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_class
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|,
name|office
argument_list|,
name|wphone
argument_list|,
name|hphone
argument_list|,
name|acexpire
argument_list|,
name|pwexpire
argument_list|)
expr_stmt|;
name|SETGRENT
argument_list|()
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|grp
operator|=
name|GETGRENT
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|grp
operator|->
name|gr_mem
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|j
operator|++
operator|==
literal|0
condition|?
literal|"    Groups: %s"
else|:
literal|",%s"
argument_list|,
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
block|}
name|ENDGRENT
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|j
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|pw_checkname
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|gecos
parameter_list|)
block|{
name|char
name|showch
index|[
literal|8
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|badchars
decl_stmt|,
modifier|*
name|ch
decl_stmt|,
modifier|*
name|showtype
decl_stmt|;
name|int
name|reject
decl_stmt|;
name|ch
operator|=
name|name
expr_stmt|;
name|reject
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gecos
condition|)
block|{
comment|/* See if the name is valid as a gecos (comment) field. */
name|badchars
operator|=
literal|":!@"
expr_stmt|;
name|showtype
operator|=
literal|"gecos field"
expr_stmt|;
block|}
else|else
block|{
comment|/* See if the name is valid as a userid or group. */
name|badchars
operator|=
literal|" ,\t:+&#%$^()!@~*?<>=|\\/\""
expr_stmt|;
name|showtype
operator|=
literal|"userid/group name"
expr_stmt|;
comment|/* Userids and groups can not have a leading '-'. */
if|if
condition|(
operator|*
name|ch
operator|==
literal|'-'
condition|)
name|reject
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reject
condition|)
block|{
while|while
condition|(
operator|*
name|ch
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|badchars
argument_list|,
operator|*
name|ch
argument_list|)
operator|!=
name|NULL
operator|||
operator|(
operator|!
name|gecos
operator|&&
operator|*
name|ch
operator|<
literal|' '
operator|)
operator|||
operator|*
name|ch
operator|==
literal|127
condition|)
block|{
name|reject
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 8-bit characters are only allowed in GECOS fields */
if|if
condition|(
operator|!
name|gecos
operator|&&
operator|(
operator|*
name|ch
operator|&
literal|0x80
operator|)
condition|)
block|{
name|reject
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ch
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * A `$' is allowed as the final character for userids and groups, 	 * mainly for the benefit of samba. 	 */
if|if
condition|(
name|reject
operator|&&
operator|!
name|gecos
condition|)
block|{
if|if
condition|(
operator|*
name|ch
operator|==
literal|'$'
operator|&&
operator|*
operator|(
name|ch
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
block|{
name|reject
operator|=
literal|0
expr_stmt|;
name|ch
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reject
condition|)
block|{
name|snprintf
argument_list|(
name|showch
argument_list|,
sizeof|sizeof
argument_list|(
name|showch
argument_list|)
argument_list|,
operator|(
operator|*
name|ch
operator|>=
literal|' '
operator|&&
operator|*
name|ch
operator|<
literal|127
operator|)
condition|?
literal|"`%c'"
else|:
literal|"0x%02x"
argument_list|,
operator|*
name|ch
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid character %s at position %td in %s"
argument_list|,
name|showch
argument_list|,
operator|(
name|ch
operator|-
name|name
operator|)
argument_list|,
name|showtype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gecos
operator|&&
operator|(
name|ch
operator|-
name|name
operator|)
operator|>
name|LOGNAMESIZE
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"name too long `%s' (max is %d)"
argument_list|,
name|name
argument_list|,
name|LOGNAMESIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rmat
parameter_list|(
name|uid_t
name|uid
parameter_list|)
block|{
name|DIR
modifier|*
name|d
init|=
name|opendir
argument_list|(
literal|"/var/at/jobs"
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|struct
name|dirent
modifier|*
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|e
operator|->
name|d_name
argument_list|,
literal|".lock"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|&&
name|stat
argument_list|(
name|e
operator|->
name|d_name
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
name|st
operator|.
name|st_uid
operator|==
name|uid
condition|)
block|{
name|char
name|tmp
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|"/usr/bin/atrm %s"
argument_list|,
name|e
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rmopie
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|char
name|tmp
index|[
literal|1014
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|off_t
name|atofs
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|openat
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
literal|"etc/opiekeys"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|tmp
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|tmp
index|[
name|len
index|]
operator|==
literal|' '
condition|)
block|{
comment|/* Comment username out */
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
name|atofs
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
literal|0
condition|)
name|fwrite
argument_list|(
literal|"#"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
name|atofs
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we got an error of any sort, don't update! 	 */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pw_user_next
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|name
name|__unused
parameter_list|)
block|{
name|struct
name|userconf
modifier|*
name|cnf
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|bool
name|quiet
init|=
name|false
decl_stmt|;
name|uid_t
name|next
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"C:q"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'C'
case|:
name|cfg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|quiet
condition|)
name|freopen
argument_list|(
name|_PATH_DEVNULL
argument_list|,
literal|"w"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|cnf
operator|=
name|get_userconfig
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|next
operator|=
name|pw_uidpolicy
argument_list|(
name|cnf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%ju:"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|next
argument_list|)
expr_stmt|;
name|pw_groupnext
argument_list|(
name|cnf
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pw_user_show
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|intmax_t
name|id
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|bool
name|all
init|=
name|false
decl_stmt|;
name|bool
name|pretty
init|=
name|false
decl_stmt|;
name|bool
name|force
init|=
name|false
decl_stmt|;
name|bool
name|v7
init|=
name|false
decl_stmt|;
name|bool
name|quiet
init|=
name|false
decl_stmt|;
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arg1
index|[
name|strspn
argument_list|(
name|arg1
argument_list|,
literal|"0123456789"
argument_list|)
index|]
operator|==
literal|'\0'
condition|)
name|id
operator|=
name|pw_checkid
argument_list|(
name|arg1
argument_list|,
name|UID_MAX
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|arg1
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"C:qn:u:FPa7"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'C'
case|:
comment|/* ignore compatibility */
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|id
operator|=
name|pw_checkid
argument_list|(
name|optarg
argument_list|,
name|UID_MAX
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|force
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|pretty
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|all
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
name|v7
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|quiet
condition|)
name|freopen
argument_list|(
name|_PATH_DEVNULL
argument_list|,
literal|"w"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|all
condition|)
block|{
name|SETPWENT
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pwd
operator|=
name|GETPWENT
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
name|print_user
argument_list|(
name|pwd
argument_list|,
name|pretty
argument_list|,
name|v7
argument_list|)
expr_stmt|;
name|ENDPWENT
argument_list|()
expr_stmt|;
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
block|}
if|if
condition|(
name|id
operator|<
literal|0
operator|&&
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"username or id required"
argument_list|)
expr_stmt|;
name|pwd
operator|=
operator|(
name|name
operator|!=
name|NULL
operator|)
condition|?
name|GETPWNAM
argument_list|(
name|pw_checkname
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|GETPWUID
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
name|pwd
operator|=
operator|&
name|fakeuser
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such uid `%ju'"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|id
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such user `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|print_user
argument_list|(
name|pwd
argument_list|,
name|pretty
argument_list|,
name|v7
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pw_user_del
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|userconf
modifier|*
name|cnf
init|=
name|NULL
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|NULL
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|,
modifier|*
name|grp
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|char
name|grname
index|[
name|MAXLOGNAME
index|]
decl_stmt|;
name|char
modifier|*
name|nispasswd
init|=
name|NULL
decl_stmt|;
name|char
name|file
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|home
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|intmax_t
name|id
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|rc
decl_stmt|;
name|bool
name|nis
init|=
name|false
decl_stmt|;
name|bool
name|deletehome
init|=
name|false
decl_stmt|;
name|bool
name|quiet
init|=
name|false
decl_stmt|;
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arg1
index|[
name|strspn
argument_list|(
name|arg1
argument_list|,
literal|"0123456789"
argument_list|)
index|]
operator|==
literal|'\0'
condition|)
name|id
operator|=
name|pw_checkid
argument_list|(
name|arg1
argument_list|,
name|UID_MAX
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|arg1
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"C:qn:u:rYy:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'C'
case|:
name|cfg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|id
operator|=
name|pw_checkid
argument_list|(
name|optarg
argument_list|,
name|UID_MAX
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|deletehome
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|nispasswd
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|nis
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|quiet
condition|)
name|freopen
argument_list|(
name|_PATH_DEVNULL
argument_list|,
literal|"w"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|&&
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"username or id required"
argument_list|)
expr_stmt|;
name|cnf
operator|=
name|get_userconfig
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nispasswd
operator|==
name|NULL
condition|)
name|nispasswd
operator|=
name|cnf
operator|->
name|nispasswd
expr_stmt|;
name|pwd
operator|=
operator|(
name|name
operator|!=
name|NULL
operator|)
condition|?
name|GETPWNAM
argument_list|(
name|pw_checkname
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|GETPWUID
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such uid `%ju'"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|id
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such user `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|PWF
operator|.
name|_altdir
operator|==
name|PWF_REGULAR
operator|&&
operator|(
operator|(
name|pwd
operator|->
name|pw_fields
operator|&
name|_PWF_SOURCE
operator|)
operator|!=
name|_PWF_FILES
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pwd
operator|->
name|pw_fields
operator|&
name|_PWF_SOURCE
operator|)
operator|==
name|_PWF_NIS
condition|)
block|{
if|if
condition|(
operator|!
name|nis
operator|&&
name|nispasswd
operator|&&
operator|*
name|nispasswd
operator|!=
literal|'/'
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"Cannot remove NIS user `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"Cannot remove non local user `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|id
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|pwd
operator|->
name|pw_name
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"cannot remove user 'root'"
argument_list|)
expr_stmt|;
comment|/* Remove opie record from /etc/opiekeys */
if|if
condition|(
name|PWALTDIR
argument_list|()
operator|!=
name|PWF_ALT
condition|)
name|rmopie
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PWALTDIR
argument_list|()
condition|)
block|{
comment|/* Remove crontabs */
name|snprintf
argument_list|(
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|file
argument_list|)
argument_list|,
literal|"/var/cron/tabs/%s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|file
argument_list|)
argument_list|,
literal|"crontab -u %s -r"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Save these for later, since contents of pwd may be 	 * invalidated by deletion 	 */
name|snprintf
argument_list|(
name|file
argument_list|,
sizeof|sizeof
argument_list|(
name|file
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|_PATH_MAILDIR
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|home
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|home
argument_list|)
argument_list|)
expr_stmt|;
name|gr
operator|=
name|GETGRGID
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|!=
name|NULL
condition|)
name|strlcpy
argument_list|(
name|grname
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|,
name|LOGNAMESIZE
argument_list|)
expr_stmt|;
else|else
name|grname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rc
operator|=
name|delpwent
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EX_IOERR
argument_list|,
literal|"user '%s' does not exist"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|err
argument_list|(
name|EX_IOERR
argument_list|,
literal|"passwd update"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nis
operator|&&
name|nispasswd
operator|&&
operator|*
name|nispasswd
operator|==
literal|'/'
condition|)
block|{
name|rc
operator|=
name|delnispwent
argument_list|(
name|nispasswd
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"WARNING: user '%s' does not exist in NIS passwd"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"WARNING: NIS passwd update"
argument_list|)
expr_stmt|;
block|}
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|!=
name|NULL
operator|&&
operator|(
name|grp
operator|->
name|gr_mem
operator|==
name|NULL
operator|||
operator|*
name|grp
operator|->
name|gr_mem
operator|==
name|NULL
operator|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|grname
argument_list|)
operator|==
literal|0
condition|)
name|delgrent
argument_list|(
name|GETGRNAM
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SETGRENT
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|grp
operator|=
name|GETGRENT
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|group
index|[
name|MAXLOGNAME
index|]
decl_stmt|;
if|if
condition|(
name|grp
operator|->
name|gr_mem
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
init|;
name|grp
operator|->
name|gr_mem
index|[
name|j
index|]
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
name|grp
operator|->
name|gr_mem
index|[
name|j
index|]
operator|=
name|grp
operator|->
name|gr_mem
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|strlcpy
argument_list|(
name|group
argument_list|,
name|grp
operator|->
name|gr_name
argument_list|,
name|MAXLOGNAME
argument_list|)
expr_stmt|;
name|chggrent
argument_list|(
name|group
argument_list|,
name|grp
argument_list|)
expr_stmt|;
block|}
block|}
name|ENDGRENT
argument_list|()
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|M_DELETE
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ju) account removed"
argument_list|,
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|id
argument_list|)
expr_stmt|;
comment|/* Remove mail file */
if|if
condition|(
name|PWALTDIR
argument_list|()
operator|!=
name|PWF_ALT
condition|)
name|unlinkat
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|file
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Remove at jobs */
if|if
condition|(
operator|!
name|PWALTDIR
argument_list|()
operator|&&
name|getpwuid
argument_list|(
name|id
argument_list|)
operator|==
name|NULL
condition|)
name|rmat
argument_list|(
name|id
argument_list|)
expr_stmt|;
comment|/* Remove home directory and contents */
if|if
condition|(
name|PWALTDIR
argument_list|()
operator|!=
name|PWF_ALT
operator|&&
name|deletehome
operator|&&
operator|*
name|home
operator|==
literal|'/'
operator|&&
name|GETPWUID
argument_list|(
name|id
argument_list|)
operator|==
name|NULL
operator|&&
name|fstatat
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|home
operator|+
literal|1
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rm_r
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|home
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|M_DELETE
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ju) home '%s' %s"
literal|"removed"
argument_list|,
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|id
argument_list|,
name|home
argument_list|,
name|fstatat
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|home
operator|+
literal|1
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
literal|"not "
literal|"completely "
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pw_user_lock
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|arg1
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Cq"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'C'
case|:
case|case
literal|'q'
case|:
comment|/* compatibility */
break|break;
block|}
block|}
return|return
operator|(
name|pw_userlock
argument_list|(
name|arg1
argument_list|,
name|M_LOCK
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pw_user_unlock
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|arg1
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Cq"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'C'
case|:
case|case
literal|'q'
case|:
comment|/* compatibility */
break|break;
block|}
block|}
return|return
operator|(
name|pw_userlock
argument_list|(
name|arg1
argument_list|,
name|M_UNLOCK
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|group
modifier|*
name|group_from_name_or_id
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|errstr
init|=
name|NULL
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|uintmax_t
name|id
decl_stmt|;
if|if
condition|(
operator|(
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|id
operator|=
name|strtounum
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|GID_MAX
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"group `%s' does not exist"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|grp
operator|=
name|GETGRGID
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"group `%s' does not exist"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|grp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|split_groups
parameter_list|(
name|StringList
modifier|*
modifier|*
name|groups
parameter_list|,
name|char
modifier|*
name|groupsstr
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|tok
index|[]
init|=
literal|", \t"
decl_stmt|;
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
name|groupsstr
argument_list|,
name|tok
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|tok
argument_list|)
control|)
block|{
name|grp
operator|=
name|group_from_name_or_id
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|groups
operator|==
name|NULL
condition|)
operator|*
name|groups
operator|=
name|sl_init
argument_list|()
expr_stmt|;
name|sl_add
argument_list|(
operator|*
name|groups
argument_list|,
name|newstr
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|validate_grname
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|char
modifier|*
name|group
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
if|if
condition|(
name|group
operator|==
name|NULL
operator|||
operator|*
name|group
operator|==
literal|'\0'
condition|)
block|{
name|cnf
operator|->
name|default_group
operator|=
literal|""
expr_stmt|;
return|return;
block|}
name|grp
operator|=
name|group_from_name_or_id
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|cnf
operator|->
name|default_group
operator|=
name|newstr
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|mode_t
name|validate_mode
parameter_list|(
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|mode_t
name|m
decl_stmt|;
name|void
modifier|*
name|set
decl_stmt|;
if|if
condition|(
operator|(
name|set
operator|=
name|setmode
argument_list|(
name|mode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid directory creation mode '%s'"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|m
operator|=
name|getmode
argument_list|(
name|set
argument_list|,
name|_DEF_DIRMODE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mix_config
parameter_list|(
name|struct
name|userconf
modifier|*
name|cmdcnf
parameter_list|,
name|struct
name|userconf
modifier|*
name|cfg
parameter_list|)
block|{
if|if
condition|(
name|cmdcnf
operator|->
name|default_password
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|default_password
operator|=
name|cfg
operator|->
name|default_password
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|reuse_uids
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|reuse_uids
operator|=
name|cfg
operator|->
name|reuse_uids
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|reuse_gids
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|reuse_gids
operator|=
name|cfg
operator|->
name|reuse_gids
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|nispasswd
operator|==
name|NULL
condition|)
name|cmdcnf
operator|->
name|nispasswd
operator|=
name|cfg
operator|->
name|nispasswd
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|dotdir
operator|==
name|NULL
condition|)
name|cmdcnf
operator|->
name|dotdir
operator|=
name|cfg
operator|->
name|dotdir
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|newmail
operator|==
name|NULL
condition|)
name|cmdcnf
operator|->
name|newmail
operator|=
name|cfg
operator|->
name|newmail
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|logfile
operator|==
name|NULL
condition|)
name|cmdcnf
operator|->
name|logfile
operator|=
name|cfg
operator|->
name|logfile
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|home
operator|==
name|NULL
condition|)
name|cmdcnf
operator|->
name|home
operator|=
name|cfg
operator|->
name|home
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|homemode
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|homemode
operator|=
name|cfg
operator|->
name|homemode
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|shelldir
operator|==
name|NULL
condition|)
name|cmdcnf
operator|->
name|shelldir
operator|=
name|cfg
operator|->
name|shelldir
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|shells
operator|==
name|NULL
condition|)
name|cmdcnf
operator|->
name|shells
operator|=
name|cfg
operator|->
name|shells
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|shell_default
operator|==
name|NULL
condition|)
name|cmdcnf
operator|->
name|shell_default
operator|=
name|cfg
operator|->
name|shell_default
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|default_group
operator|==
name|NULL
condition|)
name|cmdcnf
operator|->
name|default_group
operator|=
name|cfg
operator|->
name|default_group
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|groups
operator|==
name|NULL
condition|)
name|cmdcnf
operator|->
name|groups
operator|=
name|cfg
operator|->
name|groups
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|default_class
operator|==
name|NULL
condition|)
name|cmdcnf
operator|->
name|default_class
operator|=
name|cfg
operator|->
name|default_class
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|min_uid
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|min_uid
operator|=
name|cfg
operator|->
name|min_uid
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|max_uid
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|max_uid
operator|=
name|cfg
operator|->
name|max_uid
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|min_gid
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|min_gid
operator|=
name|cfg
operator|->
name|min_gid
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|max_gid
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|max_gid
operator|=
name|cfg
operator|->
name|max_gid
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|expire_days
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|expire_days
operator|=
name|cfg
operator|->
name|expire_days
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|password_days
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|password_days
operator|=
name|cfg
operator|->
name|password_days
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pw_user_add
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|userconf
modifier|*
name|cnf
decl_stmt|,
modifier|*
name|cmdcnf
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|args
index|[]
init|=
literal|"C:qn:u:c:d:e:p:g:G:mM:k:s:oL:i:w:h:H:Db:NPy:Y"
decl_stmt|;
name|char
name|line
index|[
name|_PASSWORD_LEN
operator|+
literal|1
index|]
decl_stmt|,
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|gecos
decl_stmt|,
modifier|*
name|homedir
decl_stmt|,
modifier|*
name|skel
decl_stmt|,
modifier|*
name|walk
decl_stmt|,
modifier|*
name|userid
decl_stmt|,
modifier|*
name|groupid
decl_stmt|,
modifier|*
name|grname
decl_stmt|;
name|char
modifier|*
name|default_passwd
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|login_cap_t
modifier|*
name|lc
decl_stmt|;
name|FILE
modifier|*
name|pfp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|intmax_t
name|id
init|=
operator|-
literal|1
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|ch
decl_stmt|,
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|bool
name|dryrun
decl_stmt|,
name|nis
decl_stmt|,
name|pretty
decl_stmt|,
name|quiet
decl_stmt|,
name|createhome
decl_stmt|,
name|precrypted
decl_stmt|,
name|genconf
decl_stmt|;
name|dryrun
operator|=
name|nis
operator|=
name|pretty
operator|=
name|quiet
operator|=
name|createhome
operator|=
name|precrypted
operator|=
name|false
expr_stmt|;
name|genconf
operator|=
name|false
expr_stmt|;
name|gecos
operator|=
name|homedir
operator|=
name|skel
operator|=
name|userid
operator|=
name|groupid
operator|=
name|default_passwd
operator|=
name|NULL
expr_stmt|;
name|grname
operator|=
name|name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|cmdcnf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|userconf
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"calloc()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arg1
index|[
name|strspn
argument_list|(
name|arg1
argument_list|,
literal|"0123456789"
argument_list|)
index|]
operator|==
literal|'\0'
condition|)
name|id
operator|=
name|pw_checkid
argument_list|(
name|arg1
argument_list|,
name|UID_MAX
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|arg1
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|args
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'C'
case|:
name|cfg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|userid
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|gecos
operator|=
name|pw_checkname
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|homedir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|cmdcnf
operator|->
name|expire_days
operator|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|cmdcnf
operator|->
name|password_days
operator|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|validate_grname
argument_list|(
name|cmdcnf
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|grname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|split_groups
argument_list|(
operator|&
name|cmdcnf
operator|->
name|groups
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|createhome
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|cmdcnf
operator|->
name|homemode
operator|=
name|validate_mode
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|walk
operator|=
name|skel
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
operator|*
name|walk
operator|==
literal|'/'
condition|)
name|walk
operator|++
expr_stmt|;
if|if
condition|(
name|fstatat
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|walk
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"skeleton `%s' does not "
literal|"exists"
argument_list|,
name|skel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"skeleton `%s' is not a "
literal|"directory"
argument_list|,
name|skel
argument_list|)
expr_stmt|;
name|cmdcnf
operator|->
name|dotdir
operator|=
name|skel
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|cmdcnf
operator|->
name|shell_default
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|conf
operator|.
name|checkduplicate
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|cmdcnf
operator|->
name|default_class
operator|=
name|pw_checkname
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|groupid
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|default_passwd
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"'-h' and '-H' are mutually "
literal|"exclusive options"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|pw_checkfd
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|precrypted
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|fd
operator|==
literal|'-'
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"-H expects a file descriptor"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"'-h' and '-H' are mutually "
literal|"exclusive options"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|pw_checkfd
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|genconf
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|cmdcnf
operator|->
name|home
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|dryrun
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|pretty
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|cmdcnf
operator|->
name|nispasswd
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|nis
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
operator|&&
operator|!
name|dryrun
condition|)
name|errx
argument_list|(
name|EX_NOPERM
argument_list|,
literal|"you must be root"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
condition|)
name|freopen
argument_list|(
name|_PATH_DEVNULL
argument_list|,
literal|"w"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|cnf
operator|=
name|get_userconfig
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|mix_config
argument_list|(
name|cmdcnf
argument_list|,
name|cnf
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_passwd
condition|)
name|cmdcnf
operator|->
name|default_password
operator|=
name|passwd_val
argument_list|(
name|default_passwd
argument_list|,
name|cnf
operator|->
name|default_password
argument_list|)
expr_stmt|;
if|if
condition|(
name|genconf
condition|)
block|{
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"can't combine `-D' with `-n name'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|userid
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|userid
argument_list|,
literal|", \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cmdcnf
operator|->
name|min_uid
operator|=
name|pw_checkid
argument_list|(
name|p
argument_list|,
name|UID_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|min_uid
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|min_uid
operator|=
literal|1000
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" ,\t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cmdcnf
operator|->
name|max_uid
operator|=
name|pw_checkid
argument_list|(
name|p
argument_list|,
name|UID_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|max_uid
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|max_uid
operator|=
literal|32000
expr_stmt|;
block|}
if|if
condition|(
name|groupid
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|groupid
argument_list|,
literal|", \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cmdcnf
operator|->
name|min_gid
operator|=
name|pw_checkid
argument_list|(
name|p
argument_list|,
name|GID_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|min_gid
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|min_gid
operator|=
literal|1000
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" ,\t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cmdcnf
operator|->
name|max_gid
operator|=
name|pw_checkid
argument_list|(
name|p
argument_list|,
name|GID_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdcnf
operator|->
name|max_gid
operator|==
literal|0
condition|)
name|cmdcnf
operator|->
name|max_gid
operator|=
literal|32000
expr_stmt|;
block|}
if|if
condition|(
name|write_userconfig
argument_list|(
name|cmdcnf
argument_list|,
name|cfg
argument_list|)
condition|)
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
name|err
argument_list|(
name|EX_IOERR
argument_list|,
literal|"config update"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|userid
condition|)
name|id
operator|=
name|pw_checkid
argument_list|(
name|userid
argument_list|,
name|UID_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|&&
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"user name or id required"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"login name required"
argument_list|)
expr_stmt|;
if|if
condition|(
name|GETPWNAM
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"login name `%s' already exists"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|grname
condition|)
name|grname
operator|=
name|cmdcnf
operator|->
name|default_group
expr_stmt|;
name|pwd
operator|=
operator|&
name|fakeuser
expr_stmt|;
name|pwd
operator|->
name|pw_name
operator|=
name|name
expr_stmt|;
name|pwd
operator|->
name|pw_class
operator|=
name|cmdcnf
operator|->
name|default_class
condition|?
name|cmdcnf
operator|->
name|default_class
else|:
literal|""
expr_stmt|;
name|pwd
operator|->
name|pw_uid
operator|=
name|pw_uidpolicy
argument_list|(
name|cmdcnf
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_gid
operator|=
name|pw_gidpolicy
argument_list|(
name|cnf
argument_list|,
name|grname
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|gid_t
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|dryrun
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_change
operator|=
name|cmdcnf
operator|->
name|password_days
expr_stmt|;
name|pwd
operator|->
name|pw_expire
operator|=
name|cmdcnf
operator|->
name|expire_days
expr_stmt|;
name|pwd
operator|->
name|pw_dir
operator|=
name|pw_homepolicy
argument_list|(
name|cmdcnf
argument_list|,
name|homedir
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_shell
operator|=
name|pw_shellpolicy
argument_list|(
name|cmdcnf
argument_list|)
expr_stmt|;
name|lc
operator|=
name|login_getpwclass
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
operator|||
name|login_setcryptfmt
argument_list|(
name|lc
argument_list|,
literal|"sha512"
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"setting crypt(3) format"
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|pw_password
argument_list|(
name|cmdcnf
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|dryrun
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"WARNING: new account `%s' has a uid of 0 "
literal|"(superuser access!)"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gecos
condition|)
name|pwd
operator|->
name|pw_gecos
operator|=
name|gecos
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|pw_set_passwd
argument_list|(
name|pwd
argument_list|,
name|fd
argument_list|,
name|precrypted
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|dryrun
condition|)
return|return
operator|(
name|print_user
argument_list|(
name|pwd
argument_list|,
name|pretty
argument_list|,
name|false
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|addpwent
argument_list|(
name|pwd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_IOERR
argument_list|,
literal|"user '%s' already exists"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|err
argument_list|(
name|EX_IOERR
argument_list|,
literal|"passwd file update"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nis
operator|&&
name|cmdcnf
operator|->
name|nispasswd
operator|&&
operator|*
name|cmdcnf
operator|->
name|nispasswd
operator|==
literal|'/'
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cmdcnf
operator|->
name|nispasswd
argument_list|)
expr_stmt|;
name|rc
operator|=
name|addnispwent
argument_list|(
name|cmdcnf
operator|->
name|nispasswd
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
name|warnx
argument_list|(
literal|"User '%s' already exists in NIS passwd"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"NIS passwd update"
argument_list|)
expr_stmt|;
comment|/* NOTE: we treat NIS-only update errors as non-fatal */
block|}
if|if
condition|(
name|cmdcnf
operator|->
name|groups
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmdcnf
operator|->
name|groups
operator|->
name|sl_cur
condition|;
name|i
operator|++
control|)
block|{
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|cmdcnf
operator|->
name|groups
operator|->
name|sl_str
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|grp
operator|=
name|gr_add
argument_list|(
name|grp
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
comment|/* 			 * grp can only be NULL in 2 cases: 			 * - the new member is already a member 			 * - a problem with memory occurs 			 * in both cases we want to skip now. 			 */
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
continue|continue;
name|chggrent
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|,
name|grp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|grp
argument_list|)
expr_stmt|;
block|}
block|}
name|pwd
operator|=
name|GETPWNAM
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"user '%s' disappeared during update"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|grp
operator|=
name|GETGRGID
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|M_ADD
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ju):%s(%ju):%s:%s:%s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|grp
condition|?
name|grp
operator|->
name|gr_name
else|:
literal|"unknown"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|grp
condition|?
name|grp
operator|->
name|gr_gid
else|:
operator|(
name|uid_t
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
name|pwd
operator|->
name|pw_gecos
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
comment|/* 	 * let's touch and chown the user's mail file. This is not 	 * strictly necessary under BSD with a 0755 maildir but it also 	 * doesn't hurt anything to create the empty mailfile 	 */
if|if
condition|(
name|PWALTDIR
argument_list|()
operator|!=
name|PWF_ALT
condition|)
block|{
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|_PATH_MAILDIR
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
comment|/* Preserve contents& mtime */
name|close
argument_list|(
name|openat
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|path
operator|+
literal|1
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
argument_list|)
expr_stmt|;
name|fchownat
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|path
operator|+
literal|1
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|,
name|AT_SYMLINK_NOFOLLOW
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Let's create and populate the user's home directory. Note 	 * that this also `works' for editing users if -m is used, but 	 * existing files will *not* be overwritten. 	 */
if|if
condition|(
name|PWALTDIR
argument_list|()
operator|!=
name|PWF_ALT
operator|&&
name|createhome
operator|&&
name|pwd
operator|->
name|pw_dir
operator|&&
operator|*
name|pwd
operator|->
name|pw_dir
operator|==
literal|'/'
operator|&&
name|pwd
operator|->
name|pw_dir
index|[
literal|1
index|]
condition|)
name|create_and_populate_homedir
argument_list|(
name|cmdcnf
argument_list|,
name|pwd
argument_list|,
name|cmdcnf
operator|->
name|dotdir
argument_list|,
name|cmdcnf
operator|->
name|homemode
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PWALTDIR
argument_list|()
operator|&&
name|cmdcnf
operator|->
name|newmail
operator|&&
operator|*
name|cmdcnf
operator|->
name|newmail
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|cnf
operator|->
name|newmail
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pfp
operator|=
name|popen
argument_list|(
name|_PATH_SENDMAIL
literal|" -t"
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"sendmail"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|pfp
argument_list|,
literal|"From: root\n"
literal|"To: %s\n"
literal|"Subject: Welcome!\n\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Do substitutions? */
name|fputs
argument_list|(
name|line
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
block|}
name|pclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|M_ADD
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ju) new user mail sent"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nis
operator|&&
name|nis_update
argument_list|()
operator|==
literal|0
condition|)
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|M_ADD
argument_list|,
name|W_USER
argument_list|,
literal|"NIS maps updated"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pw_user_mod
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|userconf
modifier|*
name|cnf
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|StringList
modifier|*
name|groups
init|=
name|NULL
decl_stmt|;
name|char
name|args
index|[]
init|=
literal|"C:qn:u:c:d:e:p:g:G:mM:l:k:s:w:L:h:H:NPYy:"
decl_stmt|;
specifier|const
name|char
modifier|*
name|cfg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|gecos
decl_stmt|,
modifier|*
name|homedir
decl_stmt|,
modifier|*
name|grname
decl_stmt|,
modifier|*
name|name
decl_stmt|,
modifier|*
name|newname
decl_stmt|,
modifier|*
name|walk
decl_stmt|,
modifier|*
name|skel
decl_stmt|,
modifier|*
name|shell
decl_stmt|;
name|char
modifier|*
name|passwd
decl_stmt|,
modifier|*
name|class
decl_stmt|,
modifier|*
name|nispasswd
decl_stmt|;
name|login_cap_t
modifier|*
name|lc
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|intmax_t
name|id
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|;
name|bool
name|quiet
decl_stmt|,
name|createhome
decl_stmt|,
name|pretty
decl_stmt|,
name|dryrun
decl_stmt|,
name|nis
decl_stmt|,
name|edited
decl_stmt|;
name|bool
name|precrypted
decl_stmt|;
name|mode_t
name|homemode
init|=
literal|0
decl_stmt|;
name|time_t
name|expire_days
decl_stmt|,
name|password_days
decl_stmt|,
name|now
decl_stmt|;
name|expire_days
operator|=
name|password_days
operator|=
operator|-
literal|1
expr_stmt|;
name|gecos
operator|=
name|homedir
operator|=
name|grname
operator|=
name|name
operator|=
name|newname
operator|=
name|skel
operator|=
name|shell
operator|=
name|NULL
expr_stmt|;
name|passwd
operator|=
name|NULL
expr_stmt|;
name|class
operator|=
name|nispasswd
operator|=
name|NULL
expr_stmt|;
name|quiet
operator|=
name|createhome
operator|=
name|pretty
operator|=
name|dryrun
operator|=
name|nis
operator|=
name|precrypted
operator|=
name|false
expr_stmt|;
name|edited
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arg1
index|[
name|strspn
argument_list|(
name|arg1
argument_list|,
literal|"0123456789"
argument_list|)
index|]
operator|==
literal|'\0'
condition|)
name|id
operator|=
name|pw_checkid
argument_list|(
name|arg1
argument_list|,
name|UID_MAX
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|arg1
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|args
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'C'
case|:
name|cfg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|name
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|id
operator|=
name|pw_checkid
argument_list|(
name|optarg
argument_list|,
name|UID_MAX
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|gecos
operator|=
name|pw_checkname
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|homedir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|expire_days
operator|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|password_days
operator|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|group_from_name_or_id
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|grname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|split_groups
argument_list|(
operator|&
name|groups
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|createhome
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|homemode
operator|=
name|validate_mode
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|newname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|walk
operator|=
name|skel
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
operator|*
name|walk
operator|==
literal|'/'
condition|)
name|walk
operator|++
expr_stmt|;
if|if
condition|(
name|fstatat
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|walk
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"skeleton `%s' does not "
literal|"exists"
argument_list|,
name|skel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"skeleton `%s' is not a "
literal|"directory"
argument_list|,
name|skel
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|shell
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|passwd
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|class
operator|=
name|pw_checkname
argument_list|(
name|optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"'-h' and '-H' are mutually "
literal|"exclusive options"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|pw_checkfd
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|precrypted
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|fd
operator|==
literal|'-'
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"-H expects a file descriptor"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"'-h' and '-H' are mutually "
literal|"exclusive options"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|pw_checkfd
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|dryrun
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|pretty
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|nispasswd
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'Y'
case|:
name|nis
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
operator|&&
operator|!
name|dryrun
condition|)
name|errx
argument_list|(
name|EX_NOPERM
argument_list|,
literal|"you must be root"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet
condition|)
name|freopen
argument_list|(
name|_PATH_DEVNULL
argument_list|,
literal|"w"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|cnf
operator|=
name|get_userconfig
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|&&
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"username or id required"
argument_list|)
expr_stmt|;
name|pwd
operator|=
operator|(
name|name
operator|!=
name|NULL
operator|)
condition|?
name|GETPWNAM
argument_list|(
name|pw_checkname
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
argument_list|)
else|:
name|GETPWUID
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such uid `%ju'"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|id
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such user `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|pwd
operator|->
name|pw_name
expr_stmt|;
if|if
condition|(
name|nis
operator|&&
name|nispasswd
operator|==
name|NULL
condition|)
name|nispasswd
operator|=
name|cnf
operator|->
name|nispasswd
expr_stmt|;
if|if
condition|(
name|PWF
operator|.
name|_altdir
operator|==
name|PWF_REGULAR
operator|&&
operator|(
operator|(
name|pwd
operator|->
name|pw_fields
operator|&
name|_PWF_SOURCE
operator|)
operator|!=
name|_PWF_FILES
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pwd
operator|->
name|pw_fields
operator|&
name|_PWF_SOURCE
operator|)
operator|==
name|_PWF_NIS
condition|)
block|{
if|if
condition|(
operator|!
name|nis
operator|&&
name|nispasswd
operator|&&
operator|*
name|nispasswd
operator|!=
literal|'/'
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"Cannot modify NIS user `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"Cannot modify non local user `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newname
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"can't rename `root' account"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|newname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pwd
operator|->
name|pw_name
operator|=
name|pw_checkname
argument_list|(
name|newname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|edited
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|id
operator|>=
literal|0
operator|&&
name|pwd
operator|->
name|pw_uid
operator|!=
name|id
condition|)
block|{
name|pwd
operator|->
name|pw_uid
operator|=
name|id
expr_stmt|;
name|edited
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"can't change uid of `root' account"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"WARNING: account `%s' will have a uid of 0 "
literal|"(superuser access!)"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|grname
operator|&&
name|pwd
operator|->
name|pw_uid
operator|!=
literal|0
condition|)
block|{
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|grname
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
name|grp
operator|=
name|GETGRGID
argument_list|(
name|pw_checkid
argument_list|(
name|grname
argument_list|,
name|GID_MAX
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|->
name|gr_gid
operator|!=
name|pwd
operator|->
name|pw_gid
condition|)
block|{
name|pwd
operator|->
name|pw_gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
name|edited
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|password_days
operator|>=
literal|0
operator|&&
name|pwd
operator|->
name|pw_change
operator|!=
name|password_days
condition|)
block|{
name|pwd
operator|->
name|pw_change
operator|=
name|password_days
expr_stmt|;
name|edited
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|expire_days
operator|>=
literal|0
operator|&&
name|pwd
operator|->
name|pw_expire
operator|!=
name|expire_days
condition|)
block|{
name|pwd
operator|->
name|pw_expire
operator|=
name|expire_days
expr_stmt|;
name|edited
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|shell
condition|)
block|{
name|shell
operator|=
name|shell_path
argument_list|(
name|cnf
operator|->
name|shelldir
argument_list|,
name|cnf
operator|->
name|shells
argument_list|,
name|shell
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell
operator|==
name|NULL
condition|)
name|shell
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|shell
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pwd
operator|->
name|pw_shell
operator|=
name|shell
expr_stmt|;
name|edited
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|class
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_class
argument_list|,
name|class
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pwd
operator|->
name|pw_class
operator|=
name|class
expr_stmt|;
name|edited
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|homedir
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|,
name|homedir
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pwd
operator|->
name|pw_dir
operator|=
name|homedir
expr_stmt|;
name|edited
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|fstatat
argument_list|(
name|conf
operator|.
name|rootfd
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|createhome
condition|)
name|warnx
argument_list|(
literal|"WARNING: home `%s' does not exist"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: home `%s' is not a directory"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|passwd
operator|&&
name|conf
operator|.
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|lc
operator|=
name|login_getpwclass
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
operator|||
name|login_setcryptfmt
argument_list|(
name|lc
argument_list|,
literal|"sha512"
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"setting crypt(3) format"
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
name|cnf
operator|->
name|default_password
operator|=
name|passwd_val
argument_list|(
name|passwd
argument_list|,
name|cnf
operator|->
name|default_password
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|pw_password
argument_list|(
name|cnf
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|dryrun
argument_list|)
expr_stmt|;
name|edited
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|gecos
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_gecos
argument_list|,
name|gecos
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pwd
operator|->
name|pw_gecos
operator|=
name|gecos
expr_stmt|;
name|edited
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|edited
operator|=
name|pw_set_passwd
argument_list|(
name|pwd
argument_list|,
name|fd
argument_list|,
name|precrypted
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|dryrun
condition|)
return|return
operator|(
name|print_user
argument_list|(
name|pwd
argument_list|,
name|pretty
argument_list|,
name|false
argument_list|)
operator|)
return|;
if|if
condition|(
name|edited
condition|)
comment|/* Only updated this if required */
name|perform_chgpwent
argument_list|(
name|name
argument_list|,
name|pwd
argument_list|,
name|nis
condition|?
name|nispasswd
else|:
name|NULL
argument_list|)
expr_stmt|;
comment|/* Now perform the needed changes concern groups */
if|if
condition|(
name|groups
operator|!=
name|NULL
condition|)
block|{
comment|/* Delete User from groups using old name */
name|SETGRENT
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|grp
operator|=
name|GETGRENT
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|grp
operator|->
name|gr_mem
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
init|;
name|grp
operator|->
name|gr_mem
index|[
name|j
index|]
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
name|grp
operator|->
name|gr_mem
index|[
name|j
index|]
operator|=
name|grp
operator|->
name|gr_mem
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|chggrent
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|,
name|grp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ENDGRENT
argument_list|()
expr_stmt|;
comment|/* Add the user to the needed groups */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|groups
operator|->
name|sl_cur
condition|;
name|i
operator|++
control|)
block|{
name|grp
operator|=
name|GETGRNAM
argument_list|(
name|groups
operator|->
name|sl_str
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|grp
operator|=
name|gr_add
argument_list|(
name|grp
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|==
name|NULL
condition|)
continue|continue;
name|chggrent
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|,
name|grp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|grp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* In case of rename we need to walk over the different groups */
if|if
condition|(
name|newname
condition|)
block|{
name|SETGRENT
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|grp
operator|=
name|GETGRENT
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|grp
operator|->
name|gr_mem
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
operator|=
name|newname
expr_stmt|;
name|chggrent
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|,
name|grp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* go get a current version of pwd */
if|if
condition|(
name|newname
condition|)
name|name
operator|=
name|newname
expr_stmt|;
name|pwd
operator|=
name|GETPWNAM
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"user '%s' disappeared during update"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|grp
operator|=
name|GETGRGID
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|M_UPDATE
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ju):%s(%ju):%s:%s:%s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|grp
condition|?
name|grp
operator|->
name|gr_name
else|:
literal|"unknown"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
name|grp
condition|?
name|grp
operator|->
name|gr_gid
else|:
operator|(
name|uid_t
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
name|pwd
operator|->
name|pw_gecos
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
comment|/* 	 * Let's create and populate the user's home directory. Note 	 * that this also `works' for editing users if -m is used, but 	 * existing files will *not* be overwritten. 	 */
if|if
condition|(
name|PWALTDIR
argument_list|()
operator|!=
name|PWF_ALT
operator|&&
name|createhome
operator|&&
name|pwd
operator|->
name|pw_dir
operator|&&
operator|*
name|pwd
operator|->
name|pw_dir
operator|==
literal|'/'
operator|&&
name|pwd
operator|->
name|pw_dir
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|skel
condition|)
name|skel
operator|=
name|cnf
operator|->
name|dotdir
expr_stmt|;
if|if
condition|(
name|homemode
operator|==
literal|0
condition|)
name|homemode
operator|=
name|cnf
operator|->
name|homemode
expr_stmt|;
name|create_and_populate_homedir
argument_list|(
name|cnf
argument_list|,
name|pwd
argument_list|,
name|skel
argument_list|,
name|homemode
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nis
operator|&&
name|nis_update
argument_list|()
operator|==
literal|0
condition|)
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|M_UPDATE
argument_list|,
name|W_USER
argument_list|,
literal|"NIS maps updated"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXIT_SUCCESS
operator|)
return|;
block|}
end_function

end_unit

