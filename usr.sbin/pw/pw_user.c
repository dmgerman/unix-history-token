begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1996  *	David L. Nugent.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY DAVID L. NUGENT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL DAVID L. NUGENT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: pw_user.c,v 1.26 1999/02/08 21:26:44 des Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_MD5RAND
argument_list|)
end_if

begin_include
include|#
directive|include
file|<md5.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pw.h"
end_include

begin_include
include|#
directive|include
file|"bitmap.h"
end_include

begin_include
include|#
directive|include
file|"pwupd.h"
end_include

begin_if
if|#
directive|if
operator|(
name|MAXLOGNAME
operator|-
literal|1
operator|)
operator|>
name|UT_NAMESIZE
end_if

begin_define
define|#
directive|define
name|LOGNAMESIZE
value|UT_NAMESIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LOGNAMESIZE
value|(MAXLOGNAME-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|randinit
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|print_user
parameter_list|(
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|int
name|pretty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uid_t
name|pw_uidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uid_t
name|pw_gidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|nam
parameter_list|,
name|gid_t
name|prefer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|pw_pwdpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|pw_exppolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pw_homepolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
specifier|const
modifier|*
name|user
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pw_shellpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|newshell
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pw_password
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
specifier|const
modifier|*
name|user
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|shell_path
parameter_list|(
name|char
specifier|const
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|shells
index|[]
parameter_list|,
name|char
modifier|*
name|sh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmat
parameter_list|(
name|uid_t
name|uid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmskey
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*-  * -C config      configuration file  * -q             quiet operation  * -n name        login name  * -u uid         user id  * -c comment     user name/comment  * -d directory   home directory  * -e date        account expiry date  * -p date        password expiry date  * -g grp         primary group  * -G grp1,grp2   additional groups  * -m [ -k dir ]  create and set up home  * -s shell       name of login shell  * -o             duplicate uid ok  * -L class       user class  * -l name        new login name  * -h fd          password filehandle  * -F             force print or add  *   Setting defaults:  * -D             set user defaults  * -b dir         default home root dir  * -e period      default expiry period  * -p period      default password change period  * -g group       default group  * -G             grp1,grp2.. default additional groups  * -L class       default login class  * -k dir         default home skeleton  * -s shell       default shell  * -w method      default password method  */
end_comment

begin_function
name|int
name|pw_user
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|r1
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|struct
name|carg
modifier|*
name|a_name
decl_stmt|;
name|struct
name|carg
modifier|*
name|a_uid
decl_stmt|;
name|struct
name|carg
modifier|*
name|arg
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
init|=
name|NULL
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|line
index|[
name|_PASSWORD_LEN
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|struct
name|passwd
name|fakeuser
init|=
block|{
name|NULL
block|,
literal|"*"
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|""
block|,
literal|"User&"
block|,
literal|"/bin/sh"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* 	 * With M_NEXT, we only need to return the 	 * next uid to stdout 	 */
if|if
condition|(
name|mode
operator|==
name|M_NEXT
condition|)
block|{
name|uid_t
name|next
init|=
name|pw_uidpolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|)
decl_stmt|;
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'q'
argument_list|)
condition|)
return|return
name|next
return|;
name|printf
argument_list|(
literal|"%ld:"
argument_list|,
operator|(
name|long
operator|)
name|next
argument_list|)
expr_stmt|;
name|pw_group
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
comment|/* 	 * We can do all of the common legwork here 	 */
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'b'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cnf
operator|->
name|home
operator|=
name|arg
operator|->
name|val
expr_stmt|;
block|}
comment|/* 	 * If we'll need to use it or we're updating it, 	 * then create the base home directory if necessary 	 */
if|if
condition|(
name|arg
operator|!=
name|NULL
operator|||
name|getarg
argument_list|(
name|args
argument_list|,
literal|'m'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|cnf
operator|->
name|home
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|>
literal|1
operator|&&
name|cnf
operator|->
name|home
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
comment|/* Shave off any trailing path delimiter */
name|cnf
operator|->
name|home
index|[
operator|--
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|2
operator|||
operator|*
name|cnf
operator|->
name|home
operator|!=
literal|'/'
condition|)
comment|/* Check for absolute path name */
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid base directory for home '%s'"
argument_list|,
name|cnf
operator|->
name|home
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|cnf
operator|->
name|home
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|dbuf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* 			 * This is a kludge especially for Joerg :) 			 * If the home directory would be created in the root partition, then 			 * we really create it under /usr which is likely to have more space. 			 * But we create a symlink from cnf->home -> "/usr" -> cnf->home 			 */
if|if
condition|(
name|strchr
argument_list|(
name|cnf
operator|->
name|home
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|dbuf
argument_list|,
literal|"/usr"
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|dbuf
argument_list|,
name|cnf
operator|->
name|home
argument_list|,
name|MAXPATHLEN
operator|-
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|dbuf
argument_list|,
literal|0755
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|errno
operator|==
name|EEXIST
condition|)
block|{
name|chown
argument_list|(
name|dbuf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|symlink
argument_list|(
name|dbuf
argument_list|,
name|cnf
operator|->
name|home
argument_list|)
expr_stmt|;
block|}
comment|/* If this falls, fall back to old method */
block|}
name|p
operator|=
name|strncpy
argument_list|(
name|dbuf
argument_list|,
name|cnf
operator|->
name|home
argument_list|,
sizeof|sizeof
name|dbuf
argument_list|)
expr_stmt|;
name|dbuf
index|[
name|MAXPATHLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dbuf
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
operator|++
name|p
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|dbuf
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|dbuf
argument_list|,
literal|0755
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|direrr
goto|;
name|chown
argument_list|(
name|dbuf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"'%s' (root home parent) is not a directory"
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stat
argument_list|(
name|dbuf
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mkdir
argument_list|(
name|dbuf
argument_list|,
literal|0755
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|direrr
label|:
name|err
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"mkdir '%s'"
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
block|}
name|chown
argument_list|(
name|dbuf
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"root home `%s' is not a directory"
argument_list|,
name|cnf
operator|->
name|home
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'e'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cnf
operator|->
name|expire_days
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'y'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cnf
operator|->
name|nispasswd
operator|=
name|arg
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'p'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|arg
operator|->
name|val
condition|)
name|cnf
operator|->
name|password_days
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'g'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|arg
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|(
name|grp
operator|=
name|getgrgid
argument_list|(
operator|(
name|gid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"group `%s' does not exist"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|cnf
operator|->
name|default_group
operator|=
name|newstr
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'L'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cnf
operator|->
name|default_class
operator|=
name|pw_checkname
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|->
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'G'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|arg
operator|->
name|val
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|", \t"
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|", \t"
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|(
name|grp
operator|=
name|getgrgid
argument_list|(
operator|(
name|gid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"group `%s' does not exist"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extendarray
argument_list|(
operator|&
name|cnf
operator|->
name|groups
argument_list|,
operator|&
name|cnf
operator|->
name|numgroups
argument_list|,
name|i
operator|+
literal|2
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|cnf
operator|->
name|groups
index|[
name|i
operator|++
index|]
operator|=
name|newstr
argument_list|(
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|cnf
operator|->
name|numgroups
condition|)
name|cnf
operator|->
name|groups
index|[
name|i
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'k'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|cnf
operator|->
name|dotdir
operator|=
name|arg
operator|->
name|val
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"skeleton `%s' is not a directory or does not exist"
argument_list|,
name|cnf
operator|->
name|dotdir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'s'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cnf
operator|->
name|shell_default
operator|=
name|arg
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|M_ADD
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'D'
argument_list|)
condition|)
block|{
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'n'
argument_list|)
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"can't combine `-D' with `-n name'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'u'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|", \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cnf
operator|->
name|min_uid
operator|=
operator|(
name|uid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|cnf
operator|->
name|min_uid
operator|=
literal|1000
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" ,\t"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cnf
operator|->
name|max_uid
operator|=
operator|(
name|uid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|<
name|cnf
operator|->
name|min_uid
condition|)
name|cnf
operator|->
name|max_uid
operator|=
literal|32000
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'i'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|", \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cnf
operator|->
name|min_gid
operator|=
operator|(
name|gid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|cnf
operator|->
name|min_gid
operator|=
literal|1000
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" ,\t"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cnf
operator|->
name|max_gid
operator|=
operator|(
name|gid_t
operator|)
name|atoi
argument_list|(
name|p
argument_list|)
operator|)
operator|<
name|cnf
operator|->
name|min_gid
condition|)
name|cnf
operator|->
name|max_gid
operator|=
literal|32000
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'w'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cnf
operator|->
name|default_password
operator|=
name|boolean_val
argument_list|(
name|arg
operator|->
name|val
argument_list|,
name|cnf
operator|->
name|default_password
argument_list|)
expr_stmt|;
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
if|if
condition|(
name|write_userconfig
argument_list|(
name|arg
condition|?
name|arg
operator|->
name|val
else|:
name|NULL
argument_list|)
condition|)
return|return
name|EXIT_SUCCESS
return|;
name|warn
argument_list|(
literal|"config update"
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
if|if
condition|(
name|mode
operator|==
name|M_PRINT
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'a'
argument_list|)
condition|)
block|{
name|int
name|pretty
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'P'
argument_list|)
operator|!=
name|NULL
decl_stmt|;
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pwd
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
name|print_user
argument_list|(
name|pwd
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
if|if
condition|(
operator|(
name|a_name
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pwd
operator|=
name|getpwnam
argument_list|(
name|pw_checkname
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|a_name
operator|->
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|a_uid
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'u'
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_uid
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|a_name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"user name or id required"
argument_list|)
expr_stmt|;
comment|/* 		 * Determine whether 'n' switch is name or uid - we don't 		 * really don't really care which we have, but we need to 		 * know. 		 */
if|if
condition|(
name|mode
operator|!=
name|M_ADD
operator|&&
name|pwd
operator|==
name|NULL
operator|&&
name|strspn
argument_list|(
name|a_name
operator|->
name|val
argument_list|,
literal|"0123456789"
argument_list|)
operator|==
name|strlen
argument_list|(
name|a_name
operator|->
name|val
argument_list|)
operator|&&
name|atoi
argument_list|(
name|a_name
operator|->
name|val
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Assume uid */
operator|(
name|a_uid
operator|=
name|a_name
operator|)
operator|->
name|ch
operator|=
literal|'u'
expr_stmt|;
name|a_name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Update, delete& print require that the user exists 	 */
if|if
condition|(
name|mode
operator|==
name|M_UPDATE
operator|||
name|mode
operator|==
name|M_DELETE
operator|||
name|mode
operator|==
name|M_PRINT
condition|)
block|{
if|if
condition|(
name|a_name
operator|==
name|NULL
operator|&&
name|pwd
operator|==
name|NULL
condition|)
comment|/* Try harder */
name|pwd
operator|=
name|getpwuid
argument_list|(
name|atoi
argument_list|(
name|a_uid
operator|->
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mode
operator|==
name|M_PRINT
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'F'
argument_list|)
condition|)
block|{
name|fakeuser
operator|.
name|pw_name
operator|=
name|a_name
condition|?
name|a_name
operator|->
name|val
else|:
literal|"nouser"
expr_stmt|;
name|fakeuser
operator|.
name|pw_uid
operator|=
name|a_uid
condition|?
operator|(
name|uid_t
operator|)
name|atol
argument_list|(
name|a_uid
operator|->
name|val
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
return|return
name|print_user
argument_list|(
operator|&
name|fakeuser
argument_list|,
name|getarg
argument_list|(
name|args
argument_list|,
literal|'P'
argument_list|)
operator|!=
name|NULL
argument_list|)
return|;
block|}
if|if
condition|(
name|a_name
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such uid `%s'"
argument_list|,
name|a_uid
operator|->
name|val
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"no such user `%s'"
argument_list|,
name|a_name
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a_name
operator|==
name|NULL
condition|)
comment|/* May be needed later */
name|a_name
operator|=
name|addarg
argument_list|(
name|args
argument_list|,
literal|'n'
argument_list|,
name|newstr
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Handle deletions now 		 */
if|if
condition|(
name|mode
operator|==
name|M_DELETE
condition|)
block|{
name|char
name|file
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
name|home
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|uid_t
name|uid
init|=
name|pwd
operator|->
name|pw_uid
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"cannot remove user 'root'"
argument_list|)
expr_stmt|;
comment|/* 			 * Remove skey record from /etc/skeykeys 			 */
name|rmskey
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
comment|/* 			 * Remove crontabs 			 */
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"/var/cron/tabs/%s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|file
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"crontab -u %s -r"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Save these for later, since contents of pwd may be 			 * invalidated by deletion 			 */
name|sprintf
argument_list|(
name|file
argument_list|,
literal|"%s/%s"
argument_list|,
name|_PATH_MAILDIR
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|home
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
sizeof|sizeof
name|home
argument_list|)
expr_stmt|;
name|home
index|[
sizeof|sizeof
name|home
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|delpwent
argument_list|(
name|pwd
argument_list|)
condition|)
name|err
argument_list|(
name|EX_IOERR
argument_list|,
literal|"error updating passwd file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnf
operator|->
name|nispasswd
operator|&&
operator|*
name|cnf
operator|->
name|nispasswd
operator|==
literal|'/'
operator|&&
operator|!
name|delnispwent
argument_list|(
name|cnf
operator|->
name|nispasswd
argument_list|,
name|a_name
operator|->
name|val
argument_list|)
condition|)
name|warn
argument_list|(
literal|"WARNING: NIS passwd update"
argument_list|)
expr_stmt|;
name|editgroups
argument_list|(
name|a_name
operator|->
name|val
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ld) account removed"
argument_list|,
name|a_name
operator|->
name|val
argument_list|,
operator|(
name|long
operator|)
name|uid
argument_list|)
expr_stmt|;
comment|/* 			 * Remove mail file 			 */
name|remove
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* 			 * Remove at jobs 			 */
if|if
condition|(
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|==
name|NULL
condition|)
name|rmat
argument_list|(
name|uid
argument_list|)
expr_stmt|;
comment|/* 			 * Remove home directory and contents 			 */
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'r'
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|home
operator|==
literal|'/'
operator|&&
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|home
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rm_r
argument_list|(
name|home
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ld) home '%s' %sremoved"
argument_list|,
name|a_name
operator|->
name|val
argument_list|,
operator|(
name|long
operator|)
name|uid
argument_list|,
name|home
argument_list|,
name|stat
argument_list|(
name|home
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|?
literal|""
else|:
literal|"not completely "
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|M_PRINT
condition|)
return|return
name|print_user
argument_list|(
name|pwd
argument_list|,
name|getarg
argument_list|(
name|args
argument_list|,
literal|'P'
argument_list|)
operator|!=
name|NULL
argument_list|)
return|;
comment|/* 		 * The rest is edit code 		 */
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'l'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"can't rename `root' account"
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_name
operator|=
name|pw_checkname
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|->
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'u'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|isdigit
argument_list|(
operator|*
name|arg
operator|->
name|val
argument_list|)
condition|)
block|{
name|pwd
operator|->
name|pw_uid
operator|=
operator|(
name|uid_t
operator|)
name|atol
argument_list|(
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"can't change uid of `root' account"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"WARNING: account `%s' will have a uid of 0 (superuser access!)"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'g'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|pwd
operator|->
name|pw_uid
operator|!=
literal|0
condition|)
comment|/* Already checked this */
name|pwd
operator|->
name|pw_gid
operator|=
operator|(
name|gid_t
operator|)
name|getgrnam
argument_list|(
name|cnf
operator|->
name|default_group
argument_list|)
operator|->
name|gr_gid
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'p'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|arg
operator|->
name|val
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
name|pwd
operator|->
name|pw_change
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|time_t
name|expire
init|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|arg
operator|->
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|now
operator|==
name|expire
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid password change date `%s'"
argument_list|,
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_change
operator|=
name|expire
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'e'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|arg
operator|->
name|val
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
name|pwd
operator|->
name|pw_expire
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|time_t
name|expire
init|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|arg
operator|->
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|now
operator|==
name|expire
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid account expiry date `%s'"
argument_list|,
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_expire
operator|=
name|expire
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'s'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pwd
operator|->
name|pw_shell
operator|=
name|shell_path
argument_list|(
name|cnf
operator|->
name|shelldir
argument_list|,
name|cnf
operator|->
name|shells
argument_list|,
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'L'
argument_list|)
condition|)
name|pwd
operator|->
name|pw_class
operator|=
name|cnf
operator|->
name|default_class
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'d'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|pwd
operator|->
name|pw_dir
operator|=
name|arg
operator|->
name|val
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'m'
argument_list|)
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|,
literal|"/nonexistent"
argument_list|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"WARNING: home `%s' does not exist"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"WARNING: home `%s' is not a directory"
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'w'
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'h'
argument_list|)
operator|==
name|NULL
condition|)
name|pwd
operator|->
name|pw_passwd
operator|=
name|pw_password
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|a_name
operator|==
name|NULL
condition|)
comment|/* Required */
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"login name required"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|a_name
operator|->
name|val
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
comment|/* Exists */
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"login name `%s' already exists"
argument_list|,
name|a_name
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* 		 * Now, set up defaults for a new user 		 */
name|pwd
operator|=
operator|&
name|fakeuser
expr_stmt|;
name|pwd
operator|->
name|pw_name
operator|=
name|a_name
operator|->
name|val
expr_stmt|;
name|pwd
operator|->
name|pw_class
operator|=
name|cnf
operator|->
name|default_class
condition|?
name|cnf
operator|->
name|default_class
else|:
literal|""
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|pw_password
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_uid
operator|=
name|pw_uidpolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_gid
operator|=
name|pw_gidpolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|gid_t
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_change
operator|=
name|pw_pwdpolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_expire
operator|=
name|pw_exppolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_dir
operator|=
name|pw_homepolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_shell
operator|=
name|pw_shellpolicy
argument_list|(
name|cnf
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
literal|"root"
argument_list|)
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"WARNING: new account `%s' has a uid of 0 (superuser access!)"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Shared add/edit code 	 */
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'c'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pwd
operator|->
name|pw_gecos
operator|=
name|pw_checkname
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|arg
operator|->
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'h'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|val
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|pwd
operator|->
name|pw_passwd
operator|=
literal|"*"
expr_stmt|;
comment|/* No access */
else|else
block|{
name|int
name|fd
init|=
name|atoi
argument_list|(
name|arg
operator|->
name|val
argument_list|)
decl_stmt|;
name|int
name|b
decl_stmt|;
name|int
name|istty
init|=
name|isatty
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|struct
name|termios
name|t
decl_stmt|;
if|if
condition|(
name|istty
condition|)
block|{
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|t
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|istty
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|struct
name|termios
name|n
init|=
name|t
decl_stmt|;
comment|/* Disable echo */
name|n
operator|.
name|c_lflag
operator|&=
operator|~
operator|(
name|ECHO
operator|)
expr_stmt|;
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sassword for user %s:"
argument_list|,
operator|(
name|mode
operator|==
name|M_UPDATE
operator|)
condition|?
literal|"New p"
else|:
literal|"P"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
name|b
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|istty
condition|)
block|{
comment|/* Restore state */
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|b
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"-h file descriptor"
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
name|line
index|[
name|b
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strpbrk
argument_list|(
name|line
argument_list|,
literal|" \t\r\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|line
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"empty password read on file descriptor %d"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|pwd
operator|->
name|pw_passwd
operator|=
name|pw_pwcrypt
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Special case: -N only displays& exits 	 */
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'N'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|print_user
argument_list|(
name|pwd
argument_list|,
name|getarg
argument_list|(
name|args
argument_list|,
literal|'P'
argument_list|)
operator|!=
name|NULL
argument_list|)
return|;
name|r
operator|=
name|r1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|M_ADD
condition|)
block|{
name|r
operator|=
name|addpwent
argument_list|(
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
name|cnf
operator|->
name|nispasswd
operator|&&
operator|*
name|cnf
operator|->
name|nispasswd
operator|==
literal|'/'
condition|)
name|r1
operator|=
name|addnispwent
argument_list|(
name|cnf
operator|->
name|nispasswd
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|M_UPDATE
condition|)
block|{
name|r
operator|=
name|chgpwent
argument_list|(
name|a_name
operator|->
name|val
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
name|cnf
operator|->
name|nispasswd
operator|&&
operator|*
name|cnf
operator|->
name|nispasswd
operator|==
literal|'/'
condition|)
name|r1
operator|=
name|chgnispwent
argument_list|(
name|cnf
operator|->
name|nispasswd
argument_list|,
name|a_name
operator|->
name|val
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|warn
argument_list|(
literal|"password update"
argument_list|)
expr_stmt|;
return|return
name|EX_IOERR
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|r1
condition|)
block|{
name|warn
argument_list|(
literal|"WARNING: NIS password update"
argument_list|)
expr_stmt|;
comment|/* Keep on trucking */
block|}
comment|/* 	 * Ok, user is created or changed - now edit group file 	 */
if|if
condition|(
name|mode
operator|==
name|M_ADD
operator|||
name|getarg
argument_list|(
name|args
argument_list|,
literal|'G'
argument_list|)
operator|!=
name|NULL
condition|)
name|editgroups
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|cnf
operator|->
name|groups
argument_list|)
expr_stmt|;
comment|/* pwd may have been invalidated */
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwnam
argument_list|(
name|a_name
operator|->
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"user '%s' disappeared during update"
argument_list|,
name|a_name
operator|->
name|val
argument_list|)
expr_stmt|;
name|grp
operator|=
name|getgrgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ld):%s(%d):%s:%s:%s"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|grp
condition|?
name|grp
operator|->
name|gr_name
else|:
literal|"unknown"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|grp
condition|?
name|grp
operator|->
name|gr_gid
else|:
operator|-
literal|1
argument_list|)
argument_list|,
name|pwd
operator|->
name|pw_gecos
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
comment|/* 	 * If adding, let's touch and chown the user's mail file. This is not 	 * strictly necessary under BSD with a 0755 maildir but it also 	 * doesn't hurt anything to create the empty mailfile 	 */
if|if
condition|(
name|mode
operator|==
name|M_ADD
condition|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s/%s"
argument_list|,
name|_PATH_MAILDIR
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|open
argument_list|(
name|line
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Preserve contents& 								 * mtime */
name|chown
argument_list|(
name|line
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
comment|/* 		 * Send mail to the new user as well, if we are asked to 		 */
if|if
condition|(
name|cnf
operator|->
name|newmail
operator|&&
operator|*
name|cnf
operator|->
name|newmail
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|cnf
operator|->
name|newmail
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|FILE
modifier|*
name|pfp
init|=
name|popen
argument_list|(
name|_PATH_SENDMAIL
literal|" -t"
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"sendmail"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|pfp
argument_list|,
literal|"From: root\n"
literal|"To: %s\n"
literal|"Subject: Welcome!\n\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Do substitutions? */
name|fputs
argument_list|(
name|line
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
block|}
name|pclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ld) new user mail sent"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Finally, let's create and populate the user's home directory. Note 	 * that this also `works' for editing users if -m is used, but 	 * existing files will *not* be overwritten. 	 */
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'m'
argument_list|)
operator|!=
name|NULL
operator|&&
name|pwd
operator|->
name|pw_dir
operator|&&
operator|*
name|pwd
operator|->
name|pw_dir
operator|==
literal|'/'
operator|&&
name|pwd
operator|->
name|pw_dir
index|[
literal|1
index|]
condition|)
block|{
name|copymkdir
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|,
name|cnf
operator|->
name|dotdir
argument_list|,
literal|0755
argument_list|,
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|pw_log
argument_list|(
name|cnf
argument_list|,
name|mode
argument_list|,
name|W_USER
argument_list|,
literal|"%s(%ld) home %s made"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|uid_t
name|pw_uidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|uid_t
name|uid
init|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
decl_stmt|;
name|struct
name|carg
modifier|*
name|a_uid
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'u'
argument_list|)
decl_stmt|;
comment|/* 	 * Check the given uid, if any 	 */
if|if
condition|(
name|a_uid
operator|!=
name|NULL
condition|)
block|{
name|uid
operator|=
operator|(
name|uid_t
operator|)
name|atol
argument_list|(
name|a_uid
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pwd
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'o'
argument_list|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"uid `%ld' has already been allocated"
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|bitmap
name|bm
decl_stmt|;
comment|/* 		 * We need to allocate the next available uid under one of 		 * two policies a) Grab the first unused uid b) Grab the 		 * highest possible unused uid 		 */
if|if
condition|(
name|cnf
operator|->
name|min_uid
operator|>=
name|cnf
operator|->
name|max_uid
condition|)
block|{
comment|/* Sanity 							 * claus^H^H^H^Hheck */
name|cnf
operator|->
name|min_uid
operator|=
literal|1000
expr_stmt|;
name|cnf
operator|->
name|max_uid
operator|=
literal|32000
expr_stmt|;
block|}
name|bm
operator|=
name|bm_alloc
argument_list|(
name|cnf
operator|->
name|max_uid
operator|-
name|cnf
operator|->
name|min_uid
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Now, let's fill the bitmap from the password file 		 */
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|pwd
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pwd
operator|->
name|pw_uid
operator|>=
operator|(
name|int
operator|)
name|cnf
operator|->
name|min_uid
operator|&&
name|pwd
operator|->
name|pw_uid
operator|<=
operator|(
name|int
operator|)
name|cnf
operator|->
name|max_uid
condition|)
name|bm_setbit
argument_list|(
operator|&
name|bm
argument_list|,
name|pwd
operator|->
name|pw_uid
operator|-
name|cnf
operator|->
name|min_uid
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
comment|/* 		 * Then apply the policy, with fallback to reuse if necessary 		 */
if|if
condition|(
name|cnf
operator|->
name|reuse_uids
operator|||
operator|(
name|uid
operator|=
call|(
name|uid_t
call|)
argument_list|(
name|bm_lastset
argument_list|(
operator|&
name|bm
argument_list|)
operator|+
name|cnf
operator|->
name|min_uid
operator|+
literal|1
argument_list|)
operator|)
operator|>
name|cnf
operator|->
name|max_uid
condition|)
name|uid
operator|=
call|(
name|uid_t
call|)
argument_list|(
name|bm_firstunset
argument_list|(
operator|&
name|bm
argument_list|)
operator|+
name|cnf
operator|->
name|min_uid
argument_list|)
expr_stmt|;
comment|/* 		 * Another sanity check 		 */
if|if
condition|(
name|uid
operator|<
name|cnf
operator|->
name|min_uid
operator|||
name|uid
operator|>
name|cnf
operator|->
name|max_uid
condition|)
name|errx
argument_list|(
name|EX_SOFTWARE
argument_list|,
literal|"unable to allocate a new uid - range fully used"
argument_list|)
expr_stmt|;
name|bm_dealloc
argument_list|(
operator|&
name|bm
argument_list|)
expr_stmt|;
block|}
return|return
name|uid
return|;
block|}
end_function

begin_function
specifier|static
name|uid_t
name|pw_gidpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|nam
parameter_list|,
name|gid_t
name|prefer
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|gid_t
name|gid
init|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
decl_stmt|;
name|struct
name|carg
modifier|*
name|a_gid
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'g'
argument_list|)
decl_stmt|;
comment|/* 	 * If no arg given, see if default can help out 	 */
if|if
condition|(
name|a_gid
operator|==
name|NULL
operator|&&
name|cnf
operator|->
name|default_group
operator|&&
operator|*
name|cnf
operator|->
name|default_group
condition|)
name|a_gid
operator|=
name|addarg
argument_list|(
name|args
argument_list|,
literal|'g'
argument_list|,
name|cnf
operator|->
name|default_group
argument_list|)
expr_stmt|;
comment|/* 	 * Check the given gid, if any 	 */
name|setgrent
argument_list|()
expr_stmt|;
if|if
condition|(
name|a_gid
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|a_gid
operator|->
name|val
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|gid
operator|=
operator|(
name|gid_t
operator|)
name|atol
argument_list|(
name|a_gid
operator|->
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gid
operator|==
literal|0
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|a_gid
operator|->
name|val
argument_list|)
operator|)
operator|||
operator|(
name|grp
operator|=
name|getgrgid
argument_list|(
name|gid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_NOUSER
argument_list|,
literal|"group `%s' is not defined"
argument_list|,
name|a_gid
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|nam
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|grp
operator|->
name|gr_mem
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
comment|/* Already created? Use it anyway... */
block|}
else|else
block|{
name|struct
name|cargs
name|grpargs
decl_stmt|;
name|char
name|tmp
index|[
literal|32
index|]
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|grpargs
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|&
name|grpargs
argument_list|,
literal|'n'
argument_list|,
name|nam
argument_list|)
expr_stmt|;
comment|/* 		 * We need to auto-create a group with the user's name. We 		 * can send all the appropriate output to our sister routine 		 * bit first see if we can create a group with gid==uid so we 		 * can keep the user and group ids in sync. We purposely do 		 * NOT check the gid range if we can force the sync. If the 		 * user's name dups an existing group, then the group add 		 * function will happily handle that case for us and exit. 		 */
if|if
condition|(
name|getgrgid
argument_list|(
name|prefer
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|prefer
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|&
name|grpargs
argument_list|,
literal|'g'
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'N'
argument_list|)
condition|)
block|{
name|addarg
argument_list|(
operator|&
name|grpargs
argument_list|,
literal|'N'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|&
name|grpargs
argument_list|,
literal|'q'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gid
operator|=
name|pw_group
argument_list|(
name|cnf
argument_list|,
name|M_NEXT
argument_list|,
operator|&
name|grpargs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pw_group
argument_list|(
name|cnf
argument_list|,
name|M_ADD
argument_list|,
operator|&
name|grpargs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|grp
operator|=
name|getgrnam
argument_list|(
name|nam
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
block|}
name|a_gid
operator|=
name|grpargs
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|a_gid
operator|!=
name|NULL
condition|)
block|{
name|struct
name|carg
modifier|*
name|t
init|=
name|a_gid
operator|->
name|list
operator|.
name|le_next
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|a_gid
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|a_gid
operator|=
name|t
expr_stmt|;
block|}
block|}
name|endgrent
argument_list|()
expr_stmt|;
return|return
name|gid
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|pw_pwdpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
block|{
name|time_t
name|result
init|=
literal|0
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|carg
modifier|*
name|arg
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'p'
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|result
operator|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|arg
operator|->
name|val
argument_list|)
operator|)
operator|==
name|now
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid date/time `%s'"
argument_list|,
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cnf
operator|->
name|password_days
operator|>
literal|0
condition|)
name|result
operator|=
name|now
operator|+
operator|(
operator|(
name|long
operator|)
name|cnf
operator|->
name|password_days
operator|*
literal|86400L
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|pw_exppolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|)
block|{
name|time_t
name|result
init|=
literal|0
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|carg
modifier|*
name|arg
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'e'
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|result
operator|=
name|parse_date
argument_list|(
name|now
argument_list|,
name|arg
operator|->
name|val
argument_list|)
operator|)
operator|==
name|now
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"invalid date/time `%s'"
argument_list|,
name|arg
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cnf
operator|->
name|expire_days
operator|>
literal|0
condition|)
name|result
operator|=
name|now
operator|+
operator|(
operator|(
name|long
operator|)
name|cnf
operator|->
name|expire_days
operator|*
literal|86400L
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pw_homepolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
specifier|const
modifier|*
name|user
parameter_list|)
block|{
name|struct
name|carg
modifier|*
name|arg
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'d'
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
condition|)
return|return
name|arg
operator|->
name|val
return|;
else|else
block|{
specifier|static
name|char
name|home
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|cnf
operator|->
name|home
operator|==
name|NULL
operator|||
operator|*
name|cnf
operator|->
name|home
operator|==
literal|'\0'
condition|)
name|errx
argument_list|(
name|EX_CONFIG
argument_list|,
literal|"no base home directory set"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|home
argument_list|,
literal|"%s/%s"
argument_list|,
name|cnf
operator|->
name|home
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
name|home
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|shell_path
parameter_list|(
name|char
specifier|const
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|shells
index|[]
parameter_list|,
name|char
modifier|*
name|sh
parameter_list|)
block|{
if|if
condition|(
name|sh
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|sh
operator|==
literal|'/'
operator|||
operator|*
name|sh
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|sh
return|;
comment|/* specified full path or forced none */
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|paths
index|[
name|_UC_MAXLINE
index|]
decl_stmt|;
comment|/* 		 * We need to search paths 		 */
name|strncpy
argument_list|(
name|paths
argument_list|,
name|path
argument_list|,
sizeof|sizeof
name|paths
argument_list|)
expr_stmt|;
name|paths
index|[
sizeof|sizeof
name|paths
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|p
operator|=
name|strtok
argument_list|(
name|paths
argument_list|,
literal|": \t\r\n"
argument_list|)
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|": \t\r\n"
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|shellpath
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|sh
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|shellpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|p
argument_list|,
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|shellpath
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|shellpath
return|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_UC_MAXSHELLS
operator|&&
name|shells
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|shellpath
argument_list|,
literal|"%s/%s"
argument_list|,
name|p
argument_list|,
name|shells
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|shellpath
argument_list|,
name|X_OK
argument_list|)
operator|==
literal|0
condition|)
return|return
name|shellpath
return|;
block|}
block|}
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_OSFILE
argument_list|,
literal|"can't find shell `%s' in shell paths"
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|EX_CONFIG
argument_list|,
literal|"no default shell available or defined"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pw_shellpolicy
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|newshell
parameter_list|)
block|{
name|char
modifier|*
name|sh
init|=
name|newshell
decl_stmt|;
name|struct
name|carg
modifier|*
name|arg
init|=
name|getarg
argument_list|(
name|args
argument_list|,
literal|'s'
argument_list|)
decl_stmt|;
if|if
condition|(
name|newshell
operator|==
name|NULL
operator|&&
name|arg
operator|!=
name|NULL
condition|)
name|sh
operator|=
name|arg
operator|->
name|val
expr_stmt|;
return|return
name|shell_path
argument_list|(
name|cnf
operator|->
name|shelldir
argument_list|,
name|cnf
operator|->
name|shells
argument_list|,
name|sh
condition|?
name|sh
else|:
name|cnf
operator|->
name|shell_default
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
specifier|const
name|chars
index|[]
init|=
literal|"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ."
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|pw_pwcrypt
parameter_list|(
name|char
modifier|*
name|password
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|salt
index|[
literal|12
index|]
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
comment|/* 	 * Calculate a salt value 	 */
if|if
condition|(
operator|!
name|randinit
condition|)
block|{
name|randinit
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|srandomdev
argument_list|()
expr_stmt|;
else|#
directive|else
name|srandom
argument_list|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
name|getpid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|salt
index|[
name|i
index|]
operator|=
name|chars
index|[
name|random
argument_list|()
operator|%
literal|63
index|]
expr_stmt|;
name|salt
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|strcpy
argument_list|(
name|buf
argument_list|,
name|crypt
argument_list|(
name|password
argument_list|,
name|salt
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_MD5RAND
argument_list|)
end_if

begin_function
name|u_char
modifier|*
name|pw_getrand
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
comment|/* cryptographically secure rng */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|u_char
name|ubuf
index|[
literal|16
index|]
decl_stmt|;
name|MD5_CTX
name|md5_ctx
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|,
name|tvo
decl_stmt|;
name|struct
name|rusage
name|ru
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|t
decl_stmt|;
name|MD5Init
argument_list|(
operator|&
name|md5_ctx
argument_list|)
expr_stmt|;
name|t
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|t
argument_list|,
sizeof|sizeof
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|getppid
argument_list|()
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|t
argument_list|,
sizeof|sizeof
name|t
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tvo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
do|do
block|{
name|getrusage
argument_list|(
name|RUSAGE_SELF
argument_list|,
operator|&
name|ru
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ru
argument_list|,
sizeof|sizeof
name|ru
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|md5_ctx
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tv
argument_list|,
sizeof|sizeof
name|tv
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|++
operator|<
literal|20
operator|||
name|tv
operator|.
name|tv_usec
operator|-
name|tvo
operator|.
name|tv_usec
operator|<
literal|100
operator|*
literal|1000
condition|)
do|;
name|MD5Final
argument_list|(
name|ubuf
argument_list|,
operator|&
name|md5_ctx
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
name|i
argument_list|,
name|ubuf
argument_list|,
name|MIN
argument_list|(
literal|16
argument_list|,
name|len
operator|-
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Portable version */
end_comment

begin_function
specifier|static
name|u_char
modifier|*
name|pw_getrand
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|val
init|=
name|random
argument_list|()
decl_stmt|;
comment|/* Use all bits in the random value */
name|buf
index|[
name|i
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|val
operator|>>
literal|24
operator|)
operator|^
operator|(
name|val
operator|>>
literal|16
operator|)
operator|^
operator|(
name|val
operator|>>
literal|8
operator|)
operator|^
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|char
modifier|*
name|pw_password
parameter_list|(
name|struct
name|userconf
modifier|*
name|cnf
parameter_list|,
name|struct
name|cargs
modifier|*
name|args
parameter_list|,
name|char
specifier|const
modifier|*
name|user
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|char
name|pwbuf
index|[
literal|32
index|]
decl_stmt|;
name|u_char
name|rndbuf
index|[
sizeof|sizeof
name|pwbuf
index|]
decl_stmt|;
switch|switch
condition|(
name|cnf
operator|->
name|default_password
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* Random password */
if|if
condition|(
operator|!
name|randinit
condition|)
block|{
name|randinit
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|srandomdev
argument_list|()
expr_stmt|;
else|#
directive|else
name|srandom
argument_list|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
operator|^
name|getpid
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|l
operator|=
operator|(
name|random
argument_list|()
operator|%
literal|8
operator|+
literal|8
operator|)
expr_stmt|;
comment|/* 8 - 16 chars */
name|pw_getrand
argument_list|(
name|rndbuf
argument_list|,
name|l
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|pwbuf
index|[
name|i
index|]
operator|=
name|chars
index|[
name|rndbuf
index|[
name|i
index|]
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|chars
argument_list|)
operator|-
literal|1
operator|)
index|]
expr_stmt|;
name|pwbuf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * We give this information back to the user 		 */
if|if
condition|(
name|getarg
argument_list|(
name|args
argument_list|,
literal|'h'
argument_list|)
operator|==
name|NULL
operator|&&
name|getarg
argument_list|(
name|args
argument_list|,
literal|'N'
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|isatty
argument_list|(
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"Password for '%s' is: "
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|pwbuf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
operator|-
literal|2
case|:
comment|/* No password at all! */
return|return
literal|""
return|;
case|case
literal|0
case|:
comment|/* No login - default */
default|default:
return|return
literal|"*"
return|;
case|case
literal|1
case|:
comment|/* user's name */
name|strncpy
argument_list|(
name|pwbuf
argument_list|,
name|user
argument_list|,
sizeof|sizeof
name|pwbuf
argument_list|)
expr_stmt|;
name|pwbuf
index|[
sizeof|sizeof
name|pwbuf
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
return|return
name|pw_pwcrypt
argument_list|(
name|pwbuf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_user
parameter_list|(
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|int
name|pretty
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pretty
condition|)
block|{
name|char
name|buf
index|[
name|_UC_MAXLINE
index|]
decl_stmt|;
name|fmtpwent
argument_list|(
name|buf
argument_list|,
name|pwd
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|group
modifier|*
name|grp
init|=
name|getgrgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
decl_stmt|;
name|char
name|uname
index|[
literal|60
index|]
init|=
literal|"User&"
decl_stmt|,
name|office
index|[
literal|60
index|]
init|=
literal|"[None]"
decl_stmt|,
name|wphone
index|[
literal|60
index|]
init|=
literal|"[None]"
decl_stmt|,
name|hphone
index|[
literal|60
index|]
init|=
literal|"[None]"
decl_stmt|;
name|char
name|acexpire
index|[
literal|32
index|]
init|=
literal|"[None]"
decl_stmt|,
name|pwexpire
index|[
literal|32
index|]
init|=
literal|"[None]"
decl_stmt|;
name|struct
name|tm
modifier|*
name|tptr
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|pwd
operator|->
name|pw_gecos
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|uname
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|uname
argument_list|)
expr_stmt|;
name|uname
index|[
sizeof|sizeof
name|uname
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|office
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|office
argument_list|)
expr_stmt|;
name|office
index|[
sizeof|sizeof
name|office
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|wphone
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|wphone
argument_list|)
expr_stmt|;
name|wphone
index|[
sizeof|sizeof
name|wphone
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|""
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|hphone
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|hphone
argument_list|)
expr_stmt|;
name|hphone
index|[
sizeof|sizeof
name|hphone
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 		 * Handle '&' in gecos field 		 */
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|uname
argument_list|,
literal|'&'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
decl_stmt|;
name|int
name|m
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|memmove
argument_list|(
name|p
operator|+
name|l
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|l
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
operator|(
name|char
operator|)
name|toupper
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pwd
operator|->
name|pw_expire
operator|>
operator|(
name|time_t
operator|)
literal|0
operator|&&
operator|(
name|tptr
operator|=
name|localtime
argument_list|(
operator|&
name|pwd
operator|->
name|pw_expire
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|strftime
argument_list|(
name|acexpire
argument_list|,
sizeof|sizeof
name|acexpire
argument_list|,
literal|"%c"
argument_list|,
name|tptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|->
name|pw_change
operator|>
operator|(
name|time_t
operator|)
literal|9
operator|&&
operator|(
name|tptr
operator|=
name|localtime
argument_list|(
operator|&
name|pwd
operator|->
name|pw_change
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|strftime
argument_list|(
name|pwexpire
argument_list|,
sizeof|sizeof
name|pwexpire
argument_list|,
literal|"%c"
argument_list|,
name|tptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Login Name: %-15s   #%-12ld Group: %-15s   #%ld\n"
literal|" Full Name: %s\n"
literal|"      Home: %-26.26s      Class: %s\n"
literal|"     Shell: %-26.26s     Office: %s\n"
literal|"Work Phone: %-26.26s Home Phone: %s\n"
literal|"Acc Expire: %-26.26s Pwd Expire: %s\n"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_uid
argument_list|,
name|grp
condition|?
name|grp
operator|->
name|gr_name
else|:
literal|"(invalid)"
argument_list|,
operator|(
name|long
operator|)
name|pwd
operator|->
name|pw_gid
argument_list|,
name|uname
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|pwd
operator|->
name|pw_class
argument_list|,
name|pwd
operator|->
name|pw_shell
argument_list|,
name|office
argument_list|,
name|wphone
argument_list|,
name|hphone
argument_list|,
name|acexpire
argument_list|,
name|pwexpire
argument_list|)
expr_stmt|;
name|setgrent
argument_list|()
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|grp
operator|=
name|getgrent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|grp
operator|->
name|gr_mem
index|[
name|i
index|]
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|j
operator|++
operator|==
literal|0
condition|?
literal|"    Groups: %s"
else|:
literal|",%s"
argument_list|,
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|i
expr_stmt|;
block|}
block|}
name|endgrent
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|j
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|pw_checkname
parameter_list|(
name|u_char
modifier|*
name|name
parameter_list|,
name|int
name|gecos
parameter_list|)
block|{
name|int
name|l
init|=
literal|0
decl_stmt|;
name|char
specifier|const
modifier|*
name|notch
init|=
name|gecos
condition|?
literal|":!@"
else|:
literal|" ,\t:+&#%$^()!@~*?<>=|\\/\""
decl_stmt|;
while|while
condition|(
name|name
index|[
name|l
index|]
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|notch
argument_list|,
name|name
index|[
name|l
index|]
argument_list|)
operator|!=
name|NULL
operator|||
name|name
index|[
name|l
index|]
operator|<
literal|' '
operator|||
name|name
index|[
name|l
index|]
operator|==
literal|127
operator|||
operator|(
operator|!
name|gecos
operator|&&
name|l
operator|==
literal|0
operator|&&
name|name
index|[
name|l
index|]
operator|==
literal|'-'
operator|)
operator|||
comment|/* leading '-' */
operator|(
operator|!
name|gecos
operator|&&
name|name
index|[
name|l
index|]
operator|&
literal|0x80
operator|)
condition|)
comment|/* 8-bit */
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
operator|(
name|name
index|[
name|l
index|]
operator|>=
literal|' '
operator|&&
name|name
index|[
name|l
index|]
operator|<
literal|127
operator|)
condition|?
literal|"invalid character `%c' in field"
else|:
literal|"invalid character 0x%02x in field"
argument_list|,
name|name
index|[
name|l
index|]
argument_list|)
expr_stmt|;
operator|++
name|l
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gecos
operator|&&
name|l
operator|>
name|LOGNAMESIZE
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"name too long `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rmat
parameter_list|(
name|uid_t
name|uid
parameter_list|)
block|{
name|DIR
modifier|*
name|d
init|=
name|opendir
argument_list|(
literal|"/var/at/jobs"
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|struct
name|dirent
modifier|*
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|e
operator|->
name|d_name
argument_list|,
literal|".lock"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
operator|&&
name|stat
argument_list|(
name|e
operator|->
name|d_name
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|&&
name|st
operator|.
name|st_uid
operator|==
name|uid
condition|)
block|{
name|char
name|tmp
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"/usr/bin/atrm %s"
argument_list|,
name|e
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rmskey
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|etcskey
index|[]
init|=
literal|"/etc/skeykeys"
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|fopen
argument_list|(
name|etcskey
argument_list|,
literal|"r+"
argument_list|)
decl_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|char
name|tmp
index|[
literal|1024
index|]
decl_stmt|;
name|off_t
name|atofs
init|=
literal|0
decl_stmt|;
name|int
name|length
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
name|tmp
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|tmp
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|&&
name|tmp
index|[
name|length
index|]
operator|==
literal|' '
condition|)
block|{
if|if
condition|(
name|fseek
argument_list|(
name|fp
argument_list|,
name|atofs
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fwrite
argument_list|(
literal|"#"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Comment username out */
block|}
break|break;
block|}
name|atofs
operator|=
name|ftell
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we got an error of any sort, don't update! 		 */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

