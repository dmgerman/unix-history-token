begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Keymap utility,   * - loads a specific national keyboard mapping into the  *   keyboard driver  * - displays the current mapping  * - sets/displays key repetition rate  * - enables/disables screensaver  *  * Contributed to 386bsd 0.1 and later versions  *  *	Copyright 1992,1993 by Holger Veit  *	May be freely used with Bill Jolitz's port of   *	386bsd and may be included in a 386bsd collection  *	as long as binary and source are available and reproduce the above  *	copyright.  *  *	You may freely modify this code and contribute improvements based  *	on this code as long as you don't claim to be the original author.  *	Commercial use of this source requires permittance of the copyright   *	holder. A general license for 386bsd will override this restriction.  *  *	Use at your own risk. The copyright holder or any person who makes  *	this code available for the public (administrators of public archives  *	for instance) are not responsible for any harm to hardware or software  *	that might happen due to wrong application or program faults.  *  * You must have the codriver driver in the same package generated  * into the 386bsd kernel, otherwise this program does not work.  *  *	@(#)keymap.c	1.1 (386bsd contribution) 24-oct-92  */
end_comment

begin_comment
comment|/* Oh, this has become a hack, this could have been done better. hv */
end_comment

begin_comment
comment|/*  * -hv- Holger Veit  *-vak- Serge Vakulenko  *  * 29/07/92 -hv- First version  * 24/10/92 -hv- fixes + screensaver  * 01/12/92-vak- -T and -a flags, new output format,  *               new keycap extensions for Meta and ShiftAltgr keys.  * 04/27/93 -hv- extensions for special function keys  *  */
end_comment

begin_comment
comment|/*	Usage:   *   *	keymap [-l] [-t+|-t-] [-d#] [-r#] [-m mapping]   *  or   *     keymap -T   *  or   *     keymap -a "keydef" keyid   *   *	-l	list the current key mapping   *	-t+	enable key repetition (typematic)   *	-t-	disable key repetion   *	-d#	set delay after which a key is repeated (includes -t+)   *	-r#	set rate of repetition of keys (includes -t+)   *	-s#	set screensaver timeout (in seconds, 0 to disable)   *	-m mapping	load a key map from the keycap file   *	-T	key testing   *   */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl_pc.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_function_decl
specifier|extern
name|int
name|kgetent
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|kgetnum
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|kgetflag
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|kgetstr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|opterr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|kbd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|kbd_ovlkey
name|kmap
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|lf
init|=
literal|0
decl_stmt|,
name|Tf
init|=
literal|0
decl_stmt|,
name|tf
init|=
literal|0
decl_stmt|,
name|af
init|=
literal|0
decl_stmt|,
name|df
init|=
literal|0
decl_stmt|,
name|delay
init|=
operator|-
literal|1
decl_stmt|,
name|rf
init|=
literal|0
decl_stmt|,
name|rate
init|=
operator|-
literal|1
decl_stmt|,
name|sf
init|=
literal|0
decl_stmt|,
name|stime
init|=
literal|0
decl_stmt|,
name|mf
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|map
decl_stmt|;
name|int
name|c
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"lTat:d:r:m:s:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'l'
case|:
name|lf
operator|++
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|Tf
operator|++
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|af
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tf
operator|=
operator|*
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|df
operator|++
expr_stmt|;
name|tf
operator|=
literal|'+'
expr_stmt|;
name|delay
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rf
operator|++
expr_stmt|;
name|tf
operator|=
literal|'+'
expr_stmt|;
name|rate
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mf
operator|++
expr_stmt|;
name|map
operator|=
name|argv
index|[
name|optind
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sf
operator|++
expr_stmt|;
name|stime
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|lf
operator|+
name|tf
operator|+
name|df
operator|+
name|rf
operator|+
name|mf
operator|+
name|sf
operator|+
name|Tf
operator|+
name|af
operator|)
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|Tf
operator|&&
operator|(
name|lf
operator|+
name|tf
operator|+
name|df
operator|+
name|rf
operator|+
name|mf
operator|+
name|sf
operator|+
name|af
operator|)
operator|!=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|af
condition|)
block|{
if|if
condition|(
operator|(
name|lf
operator|+
name|tf
operator|+
name|df
operator|+
name|rf
operator|+
name|mf
operator|+
name|sf
operator|+
name|Tf
operator|)
operator|!=
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|optind
operator|>=
name|argc
operator|-
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* we use /dev/kbd here, because this will block if the keymap 	 * command is tried from an xterm. Use xmodmap/xset for these 	 * functions 	 */
if|if
condition|(
operator|(
name|kbd
operator|=
name|open
argument_list|(
name|_PATH_KEYBOARD
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Open keyboard"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tf
condition|)
name|keynum
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|af
condition|)
name|assign
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|lf
condition|)
name|loadkmap
argument_list|()
expr_stmt|;
if|if
condition|(
name|tf
operator|||
name|df
operator|||
name|rf
condition|)
name|tpm
argument_list|(
name|tf
argument_list|,
name|delay
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|mf
condition|)
name|mapkey
argument_list|(
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
condition|)
name|saver
argument_list|(
name|stime
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|kbd
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf
condition|)
name|list
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|fatal
argument_list|(
argument|char *msg
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|char *msg
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|progname
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t%s [-l] [-t+|-t-] [-d#] [-r#] [-s#] [-m mapping]\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t  -l     list the current keyboard map\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t  -t[+-] enable/disable key repetition\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t  -d#    set key repetition delay, 0..3 * 250ms\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t  -r#    set key repetition rate, 0..31, 0 fastest\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t  -s#    set screen saver delay, in seconds\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t  -m ent remap keyboard according to the keycap(5) entry\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"or\n\t%s -T\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t         test key codes\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"or\n\t%s -a \"keydef\" keyid\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t         remap the single keyid, F1..F12, KP0..KP9, KP+..KP/, or 0xNUM\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t         with zero or one prefix: SHIFT-, CTRL-, ALTGR-, META\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* for regular keys */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|type2str
index|[]
init|=
block|{
comment|/*0*/
literal|"none    "
block|,
comment|/*1*/
literal|"shift   "
block|,
comment|/*2*/
literal|"meta    "
block|,
comment|/*3*/
literal|"numlock "
block|,
comment|/*4*/
literal|"ctrl    "
block|,
comment|/*5*/
literal|"capslock"
block|,
comment|/*6*/
literal|"ascii   "
block|,
comment|/*7*/
literal|"scroll  "
block|,
comment|/*8*/
literal|"function"
block|,
comment|/*9*/
literal|"keypad  "
block|,
comment|/*10*/
literal|"break   "
block|,
comment|/*11*/
literal|"altgr   "
block|,
comment|/*12*/
literal|"shftlock"
block|,
comment|/*13*/
literal|"altgrlck"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* convert to escseq */
end_comment

begin_function
name|char
modifier|*
name|trl
parameter_list|(
name|XCHAR
modifier|*
name|s
parameter_list|)
block|{
if|#
directive|if
name|XCHAR
operator|!=
name|u_char
name|ERROR
operator|!
name|FIX
name|ME
operator|!
endif|#
directive|endif
specifier|static
name|char
name|s1
index|[
literal|4
operator|*
literal|16
operator|+
literal|1
index|]
expr_stmt|;
specifier|static
name|char
name|s2
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|s1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|s
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|s
index|[
name|i
index|]
operator|>
literal|' '
operator|&&
name|s
index|[
name|i
index|]
operator|<
literal|0177
condition|)
block|{
name|s2
index|[
literal|0
index|]
operator|=
name|s
index|[
name|i
index|]
expr_stmt|;
name|s2
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|s
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
operator|<
literal|' '
condition|)
name|sprintf
argument_list|(
name|s2
argument_list|,
literal|"^%c"
argument_list|,
name|s
index|[
name|i
index|]
operator|+
literal|'@'
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|s2
argument_list|,
literal|"\\%03o"
argument_list|,
name|s
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
block|}
return|return
name|s1
return|;
block|}
end_function

begin_macro
name|loadkmap
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|kbd_ovlkey
modifier|*
name|ke
decl_stmt|;
comment|/* read the keys */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ke
operator|=
name|kmap
init|;
name|i
operator|<
literal|128
condition|;
name|ke
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|ke
operator|->
name|keynum
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDGCKEY
argument_list|,
name|ke
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Get kbd code"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|list
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|struct
name|kbd_ovlkey
modifier|*
name|ke
decl_stmt|;
name|int
name|has_altgr
init|=
literal|0
decl_stmt|,
name|has_shftlock
init|=
literal|0
decl_stmt|;
name|u_short
name|kt
decl_stmt|;
if|#
directive|if
name|XCHAR
operator|!=
name|u_char
name|ERROR
operator|!
name|FIX
name|ME
operator|!
endif|#
directive|endif
name|char
operator|*
name|p
expr_stmt|;
comment|/* scan the saved keys */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ke
operator|=
name|kmap
init|;
name|i
operator|<
literal|128
condition|;
name|ke
operator|++
operator|,
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|ke
operator|->
name|type
operator|&
name|KBD_MASK
condition|)
block|{
case|case
name|KBD_SHFTLOCK
case|:
name|has_shftlock
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|KBD_ALTGR
case|:
case|case
name|KBD_ALTGRLOCK
case|:
name|has_altgr
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* get the entry of key 0. This is a nonexisting key for some	 	 * reasons, so we can use it to hold the current keyboard name 	 */
if|if
condition|(
name|kmap
index|[
literal|0
index|]
operator|.
name|unshift
index|[
literal|0
index|]
condition|)
name|printf
argument_list|(
literal|"Current mapping is: %s\n"
argument_list|,
name|kmap
index|[
literal|0
index|]
operator|.
name|unshift
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  #  type  unshift    shifted      ctrl        meta"
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_altgr
condition|)
name|printf
argument_list|(
literal|"      altgr   shiftaltgr"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|ke
operator|=
operator|&
name|kmap
index|[
literal|1
index|]
init|;
name|i
operator|<
literal|128
condition|;
name|ke
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|kt
operator|=
name|ke
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|kt
condition|)
block|{
name|printf
argument_list|(
literal|"%3d%c %8s"
argument_list|,
name|i
argument_list|,
operator|(
name|kt
operator|&
name|KBD_OVERLOAD
operator|)
condition|?
literal|'*'
else|:
literal|' '
argument_list|,
name|type2str
index|[
name|kt
operator|&
name|KBD_MASK
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%-10s"
argument_list|,
operator|(
name|kt
operator|&
name|KBD_DOCAPS
operator|)
condition|?
literal|'~'
else|:
literal|' '
argument_list|,
name|trl
argument_list|(
name|ke
operator|->
name|unshift
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %-10s"
argument_list|,
name|trl
argument_list|(
name|ke
operator|->
name|shift
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ctrl
index|[
literal|0
index|]
condition|)
name|p
operator|=
name|trl
argument_list|(
name|ke
operator|->
name|ctrl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|kt
operator|&
name|KBD_MASK
operator|)
operator|==
name|KBD_ASCII
operator|||
operator|(
name|kt
operator|&
name|KBD_MASK
operator|)
operator|==
name|KBD_FUNC
condition|)
name|p
operator|=
literal|"^@"
expr_stmt|;
else|else
name|p
operator|=
literal|""
expr_stmt|;
name|printf
argument_list|(
literal|" %-10s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|meta
index|[
literal|0
index|]
condition|)
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|trl
argument_list|(
name|ke
operator|->
name|meta
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|kt
operator|&
name|KBD_MASK
operator|)
operator|==
name|KBD_ASCII
operator|||
operator|(
name|kt
operator|&
name|KBD_MASK
operator|)
operator|==
name|KBD_FUNC
condition|)
block|{
name|XCHAR
name|buf
index|[
name|KBDMAXOVLKEYSIZE
operator|+
literal|1
index|]
decl_stmt|;
name|XC_strcpy
argument_list|(
name|buf
argument_list|,
name|ke
operator|->
name|unshift
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|^=
literal|0x80
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|trl
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|has_altgr
operator|&&
name|ke
operator|->
name|altgr
index|[
literal|0
index|]
condition|)
block|{
name|printf
argument_list|(
literal|" %-10s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c%-10s"
argument_list|,
operator|(
name|kt
operator|&
name|KBD_DOALTCAPS
operator|)
condition|?
literal|'~'
else|:
literal|' '
argument_list|,
operator|(
name|char
operator|*
operator|)
name|trl
argument_list|(
name|ke
operator|->
name|altgr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|trl
argument_list|(
name|ke
operator|->
name|shiftaltgr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|tpm
argument_list|(
argument|int onoff
argument_list|,
argument|int delay
argument_list|,
argument|int rate
argument_list|)
end_macro

begin_block
block|{
name|int
name|current_tpm
decl_stmt|;
name|int
name|new_tpm
decl_stmt|;
name|int
name|tpm_sw
decl_stmt|;
if|if
condition|(
name|onoff
operator|==
literal|'-'
condition|)
block|{
name|tpm_sw
operator|=
name|KBD_REPEATOFF
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDSREPSW
argument_list|,
operator|&
name|tpm_sw
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Set key repetition OFF"
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|onoff
operator|==
literal|'+'
condition|)
block|{
name|tpm_sw
operator|=
name|KBD_REPEATON
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDSREPSW
argument_list|,
operator|&
name|tpm_sw
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Set key repetition ON"
argument_list|)
expr_stmt|;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
comment|/* do we need to set new values */
if|if
condition|(
name|delay
operator|==
operator|-
literal|1
operator|&&
name|rate
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* get current setting */
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDGTPMAT
argument_list|,
operator|&
name|current_tpm
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Get typematic value"
argument_list|)
expr_stmt|;
name|delay
operator|=
operator|(
name|delay
operator|==
operator|-
literal|1
operator|)
condition|?
operator|(
name|current_tpm
operator|&
literal|0x60
operator|)
else|:
operator|(
operator|(
name|delay
operator|&
literal|0x3
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
name|rate
operator|=
operator|(
name|rate
operator|==
operator|-
literal|1
operator|)
condition|?
operator|(
name|current_tpm
operator|&
literal|0x1F
operator|)
else|:
operator|(
name|rate
operator|&
literal|0x1F
operator|)
expr_stmt|;
name|new_tpm
operator|=
name|delay
operator||
name|rate
expr_stmt|;
comment|/* set the new setting */
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDSTPMAT
argument_list|,
operator|&
name|new_tpm
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Set typematic value"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|saver
argument_list|(
argument|int stime
argument_list|)
end_macro

begin_block
block|{
name|int
name|fv
decl_stmt|;
if|if
condition|(
operator|(
name|fv
operator|=
name|open
argument_list|(
name|_PATH_VIDEO
argument_list|,
literal|0
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Open video device"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fv
argument_list|,
name|VGASBLANK
argument_list|,
operator|&
name|stime
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"Set timeout value"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fv
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
name|keyflag
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|checkdupandset
argument_list|(
argument|k
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|keyflag
index|[
name|k
index|]
condition|)
name|error
argument_list|(
literal|"Duplicate key def"
argument_list|)
expr_stmt|;
name|keyflag
index|[
name|k
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|mapkey
argument_list|(
argument|char *map
argument_list|)
end_macro

begin_block
block|{
name|struct
name|kbd_ovlkey
name|key
decl_stmt|;
name|char
name|cap
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|setflag
decl_stmt|;
name|char
name|code
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|ap1
decl_stmt|;
name|char
name|diac
index|[
literal|9
index|]
decl_stmt|;
name|int
name|m0flag
init|=
literal|0
decl_stmt|,
name|a0flag
decl_stmt|,
name|c0flag
decl_stmt|,
name|ledflag
decl_stmt|,
name|clflag
decl_stmt|;
name|XCHAR
modifier|*
name|ap
decl_stmt|;
define|#
directive|define
name|NSTANDARD
value|7
struct|struct
block|{
name|XCHAR
modifier|*
name|addr
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|char
name|modifier
decl_stmt|;
block|}
name|standard
index|[]
init|=
block|{
literal|0
block|,
literal|'D'
block|,
name|KBD_NOEXT
block|,
operator|&
name|key
operator|.
name|unshift
index|[
literal|0
index|]
block|,
literal|'K'
block|,
name|KBD_EXT_N
block|,
operator|&
name|key
operator|.
name|shift
index|[
literal|0
index|]
block|,
literal|'S'
block|,
name|KBD_EXT_S
block|,
operator|&
name|key
operator|.
name|ctrl
index|[
literal|0
index|]
block|,
literal|'C'
block|,
name|KBD_EXT_C
block|,
operator|&
name|key
operator|.
name|meta
index|[
literal|0
index|]
block|,
literal|'M'
block|,
name|KBD_EXT_SK
block|,
operator|&
name|key
operator|.
name|altgr
index|[
literal|0
index|]
block|,
literal|'A'
block|,
name|KBD_EXT_A
block|,
operator|&
name|key
operator|.
name|shiftaltgr
index|[
literal|0
index|]
block|,
literal|'X'
block|,
name|KBD_EXT_CA
block|,     }
struct|;
define|#
directive|define
name|NSPECIAL
value|4
struct|struct
block|{
name|u_short
name|typ
decl_stmt|;
name|char
name|ch
decl_stmt|;
block|}
name|special
index|[]
init|=
block|{
name|KBD_META
block|,
literal|'m'
block|,
name|KBD_ALTGR
block|,
literal|'l'
block|,
name|KBD_SHIFT
block|,
literal|'h'
block|,
name|KBD_CTL
block|,
literal|'t'
block|}
struct|;
define|#
directive|define
name|NLOCKKEYS
value|5
struct|struct
block|{
name|char
modifier|*
name|ch
decl_stmt|;
name|u_short
name|typ
decl_stmt|;
block|}
name|lockkeys
index|[]
init|=
block|{
literal|"ca"
block|,
name|KBD_CAPS
block|,
literal|"sh"
block|,
name|KBD_SHFTLOCK
block|,
literal|"nl"
block|,
name|KBD_NUM
block|,
literal|"sc"
block|,
name|KBD_SCROLL
block|,
literal|"ag"
block|,
name|KBD_ALTGRLOCK
block|}
struct|;
comment|/* try to find the entry */
switch|switch
condition|(
name|kgetent
argument_list|(
name|cap
argument_list|,
name|map
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|"Keycap database not found"
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|error
argument_list|(
literal|"No such keymap entry"
argument_list|)
expr_stmt|;
block|}
comment|/* set default mapping */
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDDEFAULT
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot reset to default mapping"
argument_list|)
expr_stmt|;
comment|/* load fonts */
name|loadfonts
argument_list|()
expr_stmt|;
comment|/* DE flag present? */
if|if
condition|(
name|kgetflag
argument_list|(
literal|"de"
argument_list|)
condition|)
return|return;
comment|/* C0 flag */
name|c0flag
operator|=
name|kgetflag
argument_list|(
literal|"c0"
argument_list|)
expr_stmt|;
comment|/* A0 flag */
name|a0flag
operator|=
name|kgetflag
argument_list|(
literal|"a0"
argument_list|)
expr_stmt|;
comment|/* Caps LED assignments */
name|ledflag
operator|=
name|kgetnum
argument_list|(
literal|"la"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ledflag
operator|==
operator|-
literal|1
condition|)
name|ledflag
operator|=
literal|0
expr_stmt|;
name|ledflag
operator||=
name|KBD_CAPSINIT
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|keyflag
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* check for locking keys */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NLOCKKEYS
condition|;
name|k
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|code
argument_list|,
literal|"%s"
argument_list|,
name|lockkeys
index|[
name|k
index|]
operator|.
name|ch
argument_list|)
expr_stmt|;
name|n
operator|=
name|kgetnum
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|checkdupandset
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|key
operator|.
name|keynum
operator|=
name|n
expr_stmt|;
name|key
operator|.
name|type
operator|=
name|lockkeys
index|[
name|k
index|]
operator|.
name|typ
expr_stmt|;
name|key
operator|.
name|shift
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|ctrl
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|altgr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|shiftaltgr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDSCKEY
argument_list|,
operator|&
name|key
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot set lockkey"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check for special keys */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NSPECIAL
condition|;
name|k
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|code
argument_list|,
literal|"%c%d"
argument_list|,
name|special
index|[
name|k
index|]
operator|.
name|ch
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|n
operator|=
name|kgetnum
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|checkdupandset
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|key
operator|.
name|keynum
operator|=
name|n
expr_stmt|;
name|key
operator|.
name|type
operator|=
name|special
index|[
name|k
index|]
operator|.
name|typ
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDSCKEY
argument_list|,
operator|&
name|key
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot set specialkey"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* check diacritical flags */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|code
argument_list|,
literal|"p%d"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
name|kgetnum
argument_list|(
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|diac
index|[
name|i
index|]
operator|=
name|n
expr_stmt|;
else|else
name|diac
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* handle and collect standard keys */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
block|{
name|setflag
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|keynum
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDGOKEY
argument_list|,
operator|&
name|key
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot get key setting"
argument_list|)
expr_stmt|;
comment|/* XXX this will defeat the different semantic of  	 * KBD_KP, KBD_ASCII, etc. Will be corrected some day 	 */
name|key
operator|.
name|type
operator|&=
operator|~
name|KBD_MASK
expr_stmt|;
name|key
operator|.
name|type
operator||=
name|KBD_ASCII
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|9
operator|&&
name|diac
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|diac
index|[
name|k
index|]
operator|==
name|i
condition|)
block|{
name|key
operator|.
name|type
operator||=
name|KBD_DIACPFX
expr_stmt|;
break|break;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NSTANDARD
condition|;
name|k
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|code
argument_list|,
literal|"%c%d"
argument_list|,
name|standard
index|[
name|k
index|]
operator|.
name|ch
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
operator|&&
name|kgetflag
argument_list|(
name|code
argument_list|)
condition|)
block|{
comment|/* delete a key */
name|key
operator|.
name|type
operator|=
name|KBD_NONE
expr_stmt|;
name|setflag
operator|=
literal|1
expr_stmt|;
goto|goto
name|setit
goto|;
block|}
else|else
block|{
name|ap
operator|=
name|standard
index|[
name|k
index|]
operator|.
name|addr
expr_stmt|;
if|#
directive|if
name|XCHAR
operator|==
name|u_char
if|if
condition|(
name|ap1
operator|=
name|kgetstr
argument_list|(
name|code
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|ap
argument_list|)
condition|)
block|{
else|#
directive|else
name|ERROR
operator|!
name|FIX
name|ME
operator|!
endif|#
directive|endif
if|if
condition|(
name|strlen
argument_list|(
name|ap1
argument_list|)
operator|>
name|KBDMAXOVLKEYSIZE
condition|)
name|error
argument_list|(
literal|"String too long in keymap"
argument_list|)
expr_stmt|;
name|ap
operator|=
name|standard
index|[
name|k
index|]
operator|.
name|addr
expr_stmt|;
comment|/* process alphalock flag */
if|if
condition|(
operator|*
name|ap
operator|==
literal|'~'
condition|)
block|{
if|if
condition|(
name|ap
operator|==
name|key
operator|.
name|unshift
condition|)
block|{
name|XC_strcpy
argument_list|(
name|ap
argument_list|,
name|ap
operator|+
literal|1
argument_list|)
expr_stmt|;
name|key
operator|.
name|type
operator||=
name|KBD_DOCAPS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|==
name|key
operator|.
name|altgr
condition|)
block|{
name|XC_strcpy
argument_list|(
name|ap
argument_list|,
name|ap
operator|+
literal|1
argument_list|)
expr_stmt|;
name|key
operator|.
name|type
operator||=
name|KBD_DOALTCAPS
expr_stmt|;
block|}
comment|/* process special hotkeys */
block|}
elseif|else
if|if
condition|(
operator|*
name|ap
operator|==
literal|'?'
condition|)
block|{
name|int
name|modifier
decl_stmt|;
name|int
name|func
decl_stmt|;
name|struct
name|kbd_hotkey
name|s
decl_stmt|;
comment|/* get the function */
switch|switch
condition|(
name|ap
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'-'
case|:
name|func
operator|=
name|KBD_HOTKEYDELETE
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|func
operator|=
name|KBD_RESETKEY
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|func
operator|=
name|KBD_DEBUGKEY
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|func
operator|=
name|KBD_VTYDOWN
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|func
operator|=
name|KBD_VTYUP
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|func
operator|=
name|KBD_VTY11
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|func
operator|=
name|KBD_VTY10
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ap
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|ap
index|[
literal|1
index|]
operator|<=
literal|9
condition|)
name|func
operator|=
name|ap
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
else|else
continue|continue;
block|}
comment|/* convert the layer to trigger */
if|if
condition|(
name|modifier
condition|)
name|modifier
operator|=
name|standard
index|[
name|k
index|]
operator|.
name|modifier
expr_stmt|;
name|s
operator|.
name|key
operator|=
name|i
expr_stmt|;
name|s
operator|.
name|modifier
operator|=
name|modifier
expr_stmt|;
name|s
operator|.
name|function
operator|=
name|func
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDSSPECF
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"KBDSSPECF ioctl failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|setflag
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|setit
label|:
if|if
condition|(
name|setflag
condition|)
block|{
name|checkdupandset
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|key
operator|.
name|meta
index|[
literal|0
index|]
condition|)
block|{
name|key
operator|.
name|meta
index|[
literal|0
index|]
operator|=
name|key
operator|.
name|unshift
index|[
literal|0
index|]
operator|^
literal|0x80
expr_stmt|;
name|key
operator|.
name|meta
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDSCKEY
argument_list|,
operator|&
name|key
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot set stdkey"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* set the behavior for unassigned keys (clear layer) */
name|clflag
operator|=
name|a0flag
operator||
operator|(
name|c0flag
operator|<<
literal|1
operator|)
operator||
operator|(
name|m0flag
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDSCLRLYR
argument_list|,
operator|&
name|clflag
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"KBDSCLRLYR ioctl failed"
argument_list|)
expr_stmt|;
comment|/* now mark the current keyboard setting in the 0 entry */
name|key
operator|.
name|keynum
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|type
operator|=
name|KBD_NONE
expr_stmt|;
name|XC_strncpy
argument_list|(
name|key
operator|.
name|unshift
argument_list|,
name|map
argument_list|,
name|KBDMAXOVLKEYSIZE
argument_list|)
expr_stmt|;
name|key
operator|.
name|unshift
index|[
name|KBDMAXOVLKEYSIZE
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|shift
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|ctrl
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|altgr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|key
operator|.
name|shiftaltgr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDSCKEY
argument_list|,
operator|&
name|key
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot set keymap code"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDSCAPSLED
argument_list|,
operator|&
name|ledflag
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot assign LEDs"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|loadfonts
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|fp
index|[
literal|255
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|s
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|kgetstr
argument_list|(
literal|"fn0"
argument_list|,
operator|&
name|s
argument_list|)
condition|)
if|if
condition|(
name|setfont
argument_list|(
name|fp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
name|s
operator|=
name|fp
expr_stmt|;
if|if
condition|(
name|kgetstr
argument_list|(
literal|"fn1"
argument_list|,
operator|&
name|s
argument_list|)
condition|)
if|if
condition|(
name|setfont
argument_list|(
name|fp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
block|}
end_block

begin_comment
comment|/*  * simple program to test KEY NUMBERS   *  * leave this program by hitting the ESC key twice, followed by the SPACE bar  */
end_comment

begin_comment
comment|/* should be fixed on all keyboards */
end_comment

begin_define
define|#
directive|define
name|IBMKEY_ESC
value|110
end_define

begin_define
define|#
directive|define
name|IBMKEY_SPACE
value|61
end_define

begin_macro
name|keynum
argument_list|()
end_macro

begin_block
block|{
name|int
name|state
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|printf
argument_list|(
literal|"Key number test.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Press different combinations of keys.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Leave program with sequence ESC,ESC,SPACE (with release).\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|kbd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
continue|continue;
name|printf
argument_list|(
literal|"Got key %02x %s\n"
argument_list|,
name|c
operator|&
literal|0xff
argument_list|,
name|c
operator|&
literal|0x80
condition|?
literal|"(release)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
continue|continue;
name|c
operator|&=
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|IBMKEY_ESC
case|:
if|if
condition|(
name|state
operator|<
literal|2
condition|)
comment|/* ESC */
name|state
operator|++
expr_stmt|;
else|else
name|state
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IBMKEY_SPACE
case|:
if|if
condition|(
name|state
operator|==
literal|2
condition|)
return|return;
default|default:
name|state
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_define
define|#
directive|define
name|SHIFTFLAG
value|0x0100
end_define

begin_define
define|#
directive|define
name|CTRLFLAG
value|0x0200
end_define

begin_define
define|#
directive|define
name|ALTFLAG
value|0x0400
end_define

begin_define
define|#
directive|define
name|SHIFTALTFLAG
value|0x0800
end_define

begin_define
define|#
directive|define
name|METAFLAG
value|0x1000
end_define

begin_comment
comment|/* The code in codrv uses a double \0\0 to identify a NULL byte to return  * from a pressed key, but we want to have nothing for this key, and  * don't want to disable this key entirely  */
end_comment

begin_decl_stmt
specifier|static
name|XCHAR
name|notanullbyte
index|[]
init|=
block|{
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NOTANULLBYTE
value|notanullbyte
end_define

begin_function
name|char
modifier|*
name|parse_bsl
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|q
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\\'
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
else|else
block|{
comment|/* start parsing backslash */
name|p
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'n'
case|:
name|n
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|n
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|n
operator|=
literal|'\f'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|n
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|n
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|n
operator|=
literal|'\''
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|n
operator|=
literal|'\"'
expr_stmt|;
break|break;
comment|/* could add some more here */
default|default:
for|for
control|(
name|i
operator|=
name|n
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
block|{
name|n
operator|*=
literal|8
expr_stmt|;
name|n
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
break|break;
block|}
operator|--
name|p
expr_stmt|;
block|}
operator|*
name|q
operator|++
operator|=
name|n
expr_stmt|;
block|}
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_macro
name|assign
argument_list|(
argument|keydef
argument_list|,
argument|keycode
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|keydef
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|keycode
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|keynum
decl_stmt|;
name|int
name|defflag
init|=
literal|0
decl_stmt|,
name|delflag
init|=
literal|0
decl_stmt|;
name|struct
name|kbd_ovlkey
name|keynow
decl_stmt|,
name|keyorg
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|keydef
argument_list|)
operator|>
literal|15
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: String \"%s\" too long\n"
argument_list|,
name|progname
argument_list|,
name|keydef
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|keynum
operator|=
name|def2num
argument_list|(
name|keycode
argument_list|)
expr_stmt|;
if|if
condition|(
name|keynum
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: No such key: \"%s\"\n"
argument_list|,
name|progname
argument_list|,
name|keycode
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* check whether the key should be deleted or returned to default */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|keydef
argument_list|,
literal|"DEFAULT"
argument_list|)
condition|)
name|defflag
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|keydef
argument_list|,
literal|"DELETE"
argument_list|)
condition|)
name|delflag
operator|=
literal|1
expr_stmt|;
name|keydef
operator|=
name|parse_bsl
argument_list|(
name|keydef
argument_list|)
expr_stmt|;
name|keynow
operator|.
name|keynum
operator|=
name|keyorg
operator|.
name|keynum
operator|=
name|keynum
operator|&
literal|0x7F
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDGCKEY
argument_list|,
operator|&
name|keynow
argument_list|)
operator|<
literal|0
operator|||
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDGOKEY
argument_list|,
operator|&
name|keyorg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"KBDG*KEY"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|keynum
operator|&
literal|0x7F00
condition|)
block|{
case|case
name|SHIFTFLAG
case|:
if|if
condition|(
name|delflag
condition|)
name|XC_strncpy
argument_list|(
name|keynow
operator|.
name|shift
argument_list|,
name|NOTANULLBYTE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defflag
condition|)
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|shift
argument_list|,
name|keyorg
operator|.
name|shift
argument_list|)
expr_stmt|;
else|else
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|shift
argument_list|,
name|keydef
argument_list|)
expr_stmt|;
break|break;
case|case
name|METAFLAG
case|:
if|if
condition|(
name|delflag
condition|)
name|XC_strncpy
argument_list|(
name|keynow
operator|.
name|meta
argument_list|,
name|NOTANULLBYTE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defflag
condition|)
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|meta
argument_list|,
name|keyorg
operator|.
name|meta
argument_list|)
expr_stmt|;
else|else
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|meta
argument_list|,
name|keydef
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRLFLAG
case|:
if|if
condition|(
name|delflag
condition|)
name|XC_strncpy
argument_list|(
name|keynow
operator|.
name|ctrl
argument_list|,
name|NOTANULLBYTE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defflag
condition|)
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|ctrl
argument_list|,
name|keyorg
operator|.
name|ctrl
argument_list|)
expr_stmt|;
else|else
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|ctrl
argument_list|,
name|keydef
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALTFLAG
case|:
if|if
condition|(
name|delflag
condition|)
name|XC_strncpy
argument_list|(
name|keynow
operator|.
name|altgr
argument_list|,
name|NOTANULLBYTE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defflag
condition|)
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|altgr
argument_list|,
name|keyorg
operator|.
name|altgr
argument_list|)
expr_stmt|;
else|else
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|altgr
argument_list|,
name|keydef
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHIFTALTFLAG
case|:
if|if
condition|(
name|delflag
condition|)
name|XC_strncpy
argument_list|(
name|keynow
operator|.
name|shiftaltgr
argument_list|,
name|NOTANULLBYTE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defflag
condition|)
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|shiftaltgr
argument_list|,
name|keyorg
operator|.
name|shiftaltgr
argument_list|)
expr_stmt|;
else|else
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|shiftaltgr
argument_list|,
name|keydef
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|delflag
condition|)
name|XC_strncpy
argument_list|(
name|keynow
operator|.
name|unshift
argument_list|,
name|NOTANULLBYTE
argument_list|,
literal|3
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|defflag
condition|)
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|unshift
argument_list|,
name|keyorg
operator|.
name|unshift
argument_list|)
expr_stmt|;
else|else
name|XC_strcpy
argument_list|(
name|keynow
operator|.
name|unshift
argument_list|,
name|keydef
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|kbd
argument_list|,
name|KBDSCKEY
argument_list|,
operator|&
name|keynow
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"KBDSCKEY"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_struct
struct|struct
name|xlattable
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|num
decl_stmt|;
block|}
name|tbl
index|[]
init|=
block|{
comment|/* std. */
comment|/* X11 naming */
literal|"f1"
block|,
literal|112
block|,
literal|"f2"
block|,
literal|113
block|,
literal|"f3"
block|,
literal|114
block|,
literal|"f4"
block|,
literal|115
block|,
literal|"f5"
block|,
literal|116
block|,
literal|"f6"
block|,
literal|117
block|,
literal|"f7"
block|,
literal|118
block|,
literal|"f8"
block|,
literal|119
block|,
literal|"f9"
block|,
literal|120
block|,
literal|"f10"
block|,
literal|121
block|,
literal|"f11"
block|,
literal|122
block|,
literal|"f12"
block|,
literal|123
block|,
literal|"kp0"
block|,
literal|99
block|,
literal|"kp_0"
block|,
literal|99
block|,
literal|"kp1"
block|,
literal|93
block|,
literal|"kp_1"
block|,
literal|93
block|,
literal|"kp2"
block|,
literal|98
block|,
literal|"kp_2"
block|,
literal|98
block|,
literal|"kp3"
block|,
literal|103
block|,
literal|"kp_3"
block|,
literal|103
block|,
literal|"kp4"
block|,
literal|92
block|,
literal|"kp_4"
block|,
literal|92
block|,
literal|"kp5"
block|,
literal|97
block|,
literal|"kp_5"
block|,
literal|97
block|,
literal|"kp6"
block|,
literal|102
block|,
literal|"kp_6"
block|,
literal|102
block|,
literal|"kp7"
block|,
literal|91
block|,
literal|"kp_7"
block|,
literal|91
block|,
literal|"kp8"
block|,
literal|96
block|,
literal|"kp_8"
block|,
literal|96
block|,
literal|"kp9"
block|,
literal|101
block|,
literal|"kp_9"
block|,
literal|101
block|,
literal|"kp."
block|,
literal|104
block|,
literal|"kp_decimal"
block|,
literal|104
block|,
literal|"kp+"
block|,
literal|106
block|,
literal|"kp_add"
block|,
literal|106
block|,
literal|"kp-"
block|,
literal|105
block|,
literal|"kp_subtract"
block|,
literal|105
block|,
literal|"kp*"
block|,
literal|100
block|,
literal|"kp_multiply"
block|,
literal|100
block|,
literal|"kp/"
block|,
literal|95
block|,
literal|"kp_divide"
block|,
literal|95
block|,
literal|"shift"
block|,
name|SHIFTFLAG
block|,
literal|"ctrl"
block|,
name|CTRLFLAG
block|,
literal|"meta"
block|,
name|METAFLAG
block|,
literal|"altgr"
block|,
name|ALTFLAG
block|,
literal|"shiftaltgr"
block|,
name|SHIFTALTFLAG
block|,
comment|/* and some misspellings: */
literal|"sh"
block|,
name|SHIFTFLAG
block|,
literal|"ctl"
block|,
name|CTRLFLAG
block|,
literal|"^"
block|,
name|CTRLFLAG
block|,
literal|"alt"
block|,
name|ALTFLAG
block|,
literal|"shalt"
block|,
name|SHIFTALTFLAG
block|,
literal|"meta"
block|,
name|ALTFLAG
block|,
literal|"shmeta"
block|,
name|SHIFTALTFLAG
block|,
comment|/* must be last */
literal|0
block|,
literal|0
block|, }
struct|;
end_struct

begin_function
name|int
name|def2num
parameter_list|(
name|keycode
parameter_list|)
name|char
modifier|*
name|keycode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|token
decl_stmt|,
modifier|*
name|strtok
argument_list|()
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|keynum
init|=
literal|0
decl_stmt|;
name|int
name|flag1
init|=
literal|0
decl_stmt|,
name|flag2
init|=
literal|0
decl_stmt|;
comment|/* look for '-' */
name|token
operator|=
name|strtok
argument_list|(
name|keycode
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
while|while
condition|(
name|token
condition|)
block|{
name|k
operator|=
name|strtol
argument_list|(
name|token
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|token
condition|)
block|{
comment|/* got a number */
name|keynum
operator||=
name|k
expr_stmt|;
name|flag2
operator|++
expr_stmt|;
break|break;
block|}
comment|/* reserved word? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tbl
index|[
name|i
index|]
operator|.
name|str
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|keycode
argument_list|,
name|tbl
index|[
name|i
index|]
operator|.
name|str
argument_list|)
condition|)
block|{
name|keynum
operator||=
name|tbl
index|[
name|i
index|]
operator|.
name|num
expr_stmt|;
if|if
condition|(
name|tbl
index|[
name|i
index|]
operator|.
name|num
operator|<
literal|128
condition|)
name|flag2
operator|++
expr_stmt|;
else|else
name|flag1
operator|++
expr_stmt|;
block|}
block|}
name|token
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
block|}
comment|/* invalid */
if|if
condition|(
name|flag1
operator|>
literal|1
operator|||
name|flag2
operator|!=
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|keynum
operator|&
literal|0x7F
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|keynum
return|;
block|}
end_function

end_unit

