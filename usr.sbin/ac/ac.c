begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *      Copyright (c) 1994 Christopher G. Demetriou.  *      @(#)Copyright (c) 1994, Simon J. Gerraty.  *  *      This is free software.  It comes with NO WARRANTY.  *      Permission to use, modify and distribute this source code  *      is granted subject to the following conditions.  *      1/ that the above copyright notice and this notice  *      are preserved in all copies and that due credit be given  *      to the author.  *      2/ that any changes to this code are clearly commented  *      as such so that the author does not get blamed for bugs  *      other than his own.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* Not in 4.x: #include<timeconv.h> */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_comment
comment|/* Copied from /usr/include/timeconv.h in 5.x */
end_comment

begin_function_decl
name|time_t
name|_time32_to_time
parameter_list|(
name|__int32_t
name|t32
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|time_t
name|_int_to_time
parameter_list|(
name|int
name|tint
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * this is for our list of currently logged in sessions  */
end_comment

begin_struct
struct|struct
name|utmp_list
block|{
name|struct
name|utmp_list
modifier|*
name|next
decl_stmt|;
name|struct
name|utmp
name|usr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * this is for our list of users that are accumulating time.  */
end_comment

begin_struct
struct|struct
name|user_list
block|{
name|struct
name|user_list
modifier|*
name|next
decl_stmt|;
name|char
name|name
index|[
name|UT_NAMESIZE
operator|+
literal|1
index|]
decl_stmt|;
name|time_t
name|secs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * this is for chosing whether to ignore a login  */
end_comment

begin_struct
struct|struct
name|tty_list
block|{
name|struct
name|tty_list
modifier|*
name|next
decl_stmt|;
name|char
name|name
index|[
name|UT_LINESIZE
operator|+
literal|3
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|ret
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * globals - yes yuk  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONSOLE_TTY
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Console
init|=
name|CONSOLE_TTY
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|time_t
name|Total
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|FirstTime
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|user_list
modifier|*
name|Users
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tty_list
modifier|*
name|Ttys
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEW
parameter_list|(
name|type
parameter_list|)
value|(type *)malloc(sizeof (type))
end_define

begin_define
define|#
directive|define
name|AC_W
value|1
end_define

begin_comment
comment|/* not _PATH_WTMP */
end_comment

begin_define
define|#
directive|define
name|AC_D
value|2
end_define

begin_comment
comment|/* daily totals (ignore -p) */
end_comment

begin_define
define|#
directive|define
name|AC_P
value|4
end_define

begin_comment
comment|/* per-user totals */
end_comment

begin_define
define|#
directive|define
name|AC_U
value|8
end_define

begin_comment
comment|/* specified users only */
end_comment

begin_define
define|#
directive|define
name|AC_T
value|16
end_define

begin_comment
comment|/* specified ttys only */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|Debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ac
parameter_list|(
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|tty_list
modifier|*
name|add_tty
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|const
name|char
modifier|*
name|debug_pfx
parameter_list|(
specifier|const
name|struct
name|utmp
modifier|*
parameter_list|,
specifier|const
name|struct
name|utmp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|int
name|do_tty
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|FILE
modifier|*
name|file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|utmp_list
modifier|*
name|log_in
parameter_list|(
name|struct
name|utmp_list
modifier|*
parameter_list|,
name|struct
name|utmp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|utmp_list
modifier|*
name|log_out
parameter_list|(
name|struct
name|utmp_list
modifier|*
parameter_list|,
name|struct
name|utmp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|on_console
parameter_list|(
name|struct
name|utmp_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|show
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|show_today
parameter_list|(
name|struct
name|user_list
modifier|*
parameter_list|,
name|struct
name|utmp_list
modifier|*
parameter_list|,
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|show_users
parameter_list|(
name|struct
name|user_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|user_list
modifier|*
name|update_user
parameter_list|(
name|struct
name|user_list
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * open wtmp or die  */
end_comment

begin_function
name|FILE
modifier|*
name|file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* in case we want to discriminate */
if|if
condition|(
name|strcmp
argument_list|(
name|_PATH_WTMP
argument_list|,
name|name
argument_list|)
condition|)
name|Flags
operator||=
name|AC_W
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
name|struct
name|tty_list
modifier|*
name|add_tty
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|tty_list
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|rcp
decl_stmt|;
name|Flags
operator||=
name|AC_T
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|NEW
argument_list|(
expr|struct
name|tty_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|tp
operator|->
name|len
operator|=
literal|0
expr_stmt|;
comment|/* full match */
name|tp
operator|->
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* do if match */
if|if
condition|(
operator|*
name|name
operator|==
literal|'!'
condition|)
block|{
comment|/* don't do if match */
name|tp
operator|->
name|ret
operator|=
literal|0
expr_stmt|;
name|name
operator|++
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|tp
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|tp
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rcp
operator|=
name|strchr
argument_list|(
name|tp
operator|->
name|name
argument_list|,
literal|'*'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* wild card */
operator|*
name|rcp
operator|=
literal|'\0'
expr_stmt|;
name|tp
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* match len bytes only */
block|}
name|tp
operator|->
name|next
operator|=
name|Ttys
expr_stmt|;
name|Ttys
operator|=
name|tp
expr_stmt|;
return|return
name|Ttys
return|;
block|}
end_function

begin_comment
comment|/*  * should we process the named tty?  */
end_comment

begin_function
name|int
name|do_tty
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|tty_list
modifier|*
name|tp
decl_stmt|;
name|int
name|def_ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|Ttys
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|ret
operator|==
literal|0
condition|)
comment|/* specific don't */
name|def_ret
operator|=
literal|1
expr_stmt|;
comment|/* default do */
if|if
condition|(
name|tp
operator|->
name|len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|tp
operator|->
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|tp
operator|->
name|ret
return|;
block|}
else|else
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|tp
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|tp
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
name|tp
operator|->
name|ret
return|;
block|}
block|}
return|return
name|def_ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONSOLE_TTY
end_ifdef

begin_comment
comment|/*  * is someone logged in on Console?  */
end_comment

begin_function
name|int
name|on_console
parameter_list|(
name|struct
name|utmp_list
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|utmp_list
modifier|*
name|up
decl_stmt|;
for|for
control|(
name|up
operator|=
name|head
init|;
name|up
condition|;
name|up
operator|=
name|up
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|up
operator|->
name|usr
operator|.
name|ut_line
argument_list|,
name|Console
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|usr
operator|.
name|ut_line
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * update user's login time  */
end_comment

begin_function
name|struct
name|user_list
modifier|*
name|update_user
parameter_list|(
name|struct
name|user_list
modifier|*
name|head
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|time_t
name|secs
parameter_list|)
block|{
name|struct
name|user_list
modifier|*
name|up
decl_stmt|;
for|for
control|(
name|up
operator|=
name|head
init|;
name|up
operator|!=
name|NULL
condition|;
name|up
operator|=
name|up
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|up
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|UT_NAMESIZE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|up
operator|->
name|secs
operator|+=
name|secs
expr_stmt|;
name|Total
operator|+=
name|secs
expr_stmt|;
return|return
name|head
return|;
block|}
block|}
comment|/* 	 * not found so add new user unless specified users only 	 */
if|if
condition|(
name|Flags
operator|&
name|AC_U
condition|)
return|return
name|head
return|;
if|if
condition|(
operator|(
name|up
operator|=
name|NEW
argument_list|(
expr|struct
name|user_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|up
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|strlcpy
argument_list|(
name|up
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|secs
operator|=
name|secs
expr_stmt|;
name|Total
operator|+=
name|secs
expr_stmt|;
return|return
name|up
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Create a string which is the standard prefix for a debug line.  It  * includes a timestamp (perhaps with year), device-name, and user-name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|debug_pfx
parameter_list|(
specifier|const
name|struct
name|utmp
modifier|*
name|event_up
parameter_list|,
specifier|const
name|struct
name|utmp
modifier|*
name|userinf_up
parameter_list|)
block|{
specifier|static
name|char
name|str_result
index|[
literal|40
operator|+
name|UT_LINESIZE
operator|+
name|UT_NAMESIZE
index|]
decl_stmt|;
specifier|static
name|char
name|thisyear
index|[
literal|5
index|]
decl_stmt|;
name|size_t
name|maxcopy
decl_stmt|;
name|time_t
name|ut_timecopy
decl_stmt|;
if|if
condition|(
name|thisyear
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Figure out what "this year" is. */
name|time
argument_list|(
operator|&
name|ut_timecopy
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|str_result
argument_list|,
name|ctime
argument_list|(
operator|&
name|ut_timecopy
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|str_result
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|thisyear
argument_list|,
operator|&
name|str_result
index|[
literal|20
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|thisyear
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|event_up
operator|->
name|ut_time
operator|==
literal|0
condition|)
name|strlcpy
argument_list|(
name|str_result
argument_list|,
literal|"*ZeroTime* --:--:-- "
argument_list|,
sizeof|sizeof
argument_list|(
name|str_result
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		* The type of utmp.ut_time is not necessary type time_t, as 		* it is explicitly defined as type int32_t.  Copy the value 		* for platforms where sizeof(time_t) != sizeof(int32_t). 		*/
name|ut_timecopy
operator|=
name|_time32_to_time
argument_list|(
name|event_up
operator|->
name|ut_time
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|str_result
argument_list|,
name|ctime
argument_list|(
operator|&
name|ut_timecopy
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|str_result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Include the year, if it is not the same year as "now". 		 */
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|str_result
index|[
literal|20
index|]
argument_list|,
name|thisyear
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|str_result
index|[
literal|20
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
name|str_result
index|[
literal|24
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Replace a '\n' */
name|str_result
index|[
literal|25
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|userinf_up
operator|->
name|ut_line
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strlcat
argument_list|(
name|str_result
argument_list|,
literal|"NoDev"
argument_list|,
sizeof|sizeof
argument_list|(
name|str_result
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* ut_line is not necessarily null-terminated. */
name|maxcopy
operator|=
name|strlen
argument_list|(
name|str_result
argument_list|)
operator|+
name|UT_LINESIZE
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|maxcopy
operator|>
sizeof|sizeof
argument_list|(
name|str_result
argument_list|)
condition|)
name|maxcopy
operator|=
sizeof|sizeof
argument_list|(
name|str_result
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|str_result
argument_list|,
name|userinf_up
operator|->
name|ut_line
argument_list|,
name|maxcopy
argument_list|)
expr_stmt|;
block|}
name|strlcat
argument_list|(
name|str_result
argument_list|,
literal|": "
argument_list|,
sizeof|sizeof
argument_list|(
name|str_result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|userinf_up
operator|->
name|ut_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strlcat
argument_list|(
name|str_result
argument_list|,
literal|"LogOff"
argument_list|,
sizeof|sizeof
argument_list|(
name|str_result
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* ut_name is not necessarily null-terminated. */
name|maxcopy
operator|=
name|strlen
argument_list|(
name|str_result
argument_list|)
operator|+
name|UT_NAMESIZE
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|maxcopy
operator|>
sizeof|sizeof
argument_list|(
name|str_result
argument_list|)
condition|)
name|maxcopy
operator|=
sizeof|sizeof
argument_list|(
name|str_result
argument_list|)
expr_stmt|;
name|strlcat
argument_list|(
name|str_result
argument_list|,
name|userinf_up
operator|->
name|ut_name
argument_list|,
name|maxcopy
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|str_result
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|c
decl_stmt|;
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_TIME
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Dc:dpt:w:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'D'
case|:
name|Debug
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'c'
case|:
ifdef|#
directive|ifdef
name|CONSOLE_TTY
name|Console
operator|=
name|optarg
expr_stmt|;
else|#
directive|else
name|usage
argument_list|()
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
break|break;
case|case
literal|'d'
case|:
name|Flags
operator||=
name|AC_D
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|Flags
operator||=
name|AC_P
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* only do specified ttys */
name|add_tty
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|fp
operator|=
name|file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
comment|/* 		 * initialize user list 		 */
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|Users
operator|=
name|update_user
argument_list|(
name|Users
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|Flags
operator||=
name|AC_U
expr_stmt|;
comment|/* freeze user list */
block|}
if|if
condition|(
name|Flags
operator|&
name|AC_D
condition|)
name|Flags
operator|&=
operator|~
name|AC_P
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * if _PATH_WTMP does not exist, exit quietly 		 */
if|if
condition|(
name|access
argument_list|(
name|_PATH_WTMP
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|0
return|;
name|fp
operator|=
name|file
argument_list|(
name|_PATH_WTMP
argument_list|)
expr_stmt|;
block|}
name|ac
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * print login time in decimal hours  */
end_comment

begin_function
name|void
name|show
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|time_t
name|secs
parameter_list|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\t%-*s %8.2f\n"
argument_list|,
name|UT_NAMESIZE
argument_list|,
name|name
argument_list|,
operator|(
operator|(
name|double
operator|)
name|secs
operator|/
literal|3600
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|show_users
parameter_list|(
name|struct
name|user_list
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|user_list
modifier|*
name|lp
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|list
init|;
name|lp
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
name|show
argument_list|(
name|lp
operator|->
name|name
argument_list|,
name|lp
operator|->
name|secs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print total login time for 24hr period in decimal hours  */
end_comment

begin_function
name|void
name|show_today
parameter_list|(
name|struct
name|user_list
modifier|*
name|users
parameter_list|,
name|struct
name|utmp_list
modifier|*
name|logins
parameter_list|,
name|time_t
name|secs
parameter_list|)
block|{
name|struct
name|user_list
modifier|*
name|up
decl_stmt|;
name|struct
name|utmp_list
modifier|*
name|lp
decl_stmt|;
name|char
name|date
index|[
literal|64
index|]
decl_stmt|;
name|time_t
name|yesterday
init|=
name|secs
operator|-
literal|1
decl_stmt|;
specifier|static
name|int
name|d_first
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|d_first
operator|<
literal|0
condition|)
name|d_first
operator|=
operator|(
operator|*
name|nl_langinfo
argument_list|(
name|D_MD_ORDER
argument_list|)
operator|==
literal|'d'
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|strftime
argument_list|(
name|date
argument_list|,
sizeof|sizeof
argument_list|(
name|date
argument_list|)
argument_list|,
name|d_first
condition|?
literal|"%e %b  total"
else|:
literal|"%b %e  total"
argument_list|,
name|localtime
argument_list|(
operator|&
name|yesterday
argument_list|)
argument_list|)
expr_stmt|;
comment|/* restore the missing second */
name|yesterday
operator|++
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|logins
init|;
name|lp
operator|!=
name|NULL
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
block|{
name|secs
operator|=
name|yesterday
operator|-
name|lp
operator|->
name|usr
operator|.
name|ut_time
expr_stmt|;
name|Users
operator|=
name|update_user
argument_list|(
name|Users
argument_list|,
name|lp
operator|->
name|usr
operator|.
name|ut_name
argument_list|,
name|secs
argument_list|)
expr_stmt|;
name|lp
operator|->
name|usr
operator|.
name|ut_time
operator|=
name|yesterday
expr_stmt|;
comment|/* as if they just logged in */
block|}
name|secs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|up
operator|=
name|users
init|;
name|up
operator|!=
name|NULL
condition|;
name|up
operator|=
name|up
operator|->
name|next
control|)
block|{
name|secs
operator|+=
name|up
operator|->
name|secs
expr_stmt|;
name|up
operator|->
name|secs
operator|=
literal|0
expr_stmt|;
comment|/* for next day */
block|}
if|if
condition|(
name|secs
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s %11.2f\n"
argument_list|,
name|date
argument_list|,
operator|(
operator|(
name|double
operator|)
name|secs
operator|/
literal|3600
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * log a user out and update their times.  * if ut_line is "~", we log all users out as the system has  * been shut down.  */
end_comment

begin_function
name|struct
name|utmp_list
modifier|*
name|log_out
parameter_list|(
name|struct
name|utmp_list
modifier|*
name|head
parameter_list|,
name|struct
name|utmp
modifier|*
name|up
parameter_list|)
block|{
name|struct
name|utmp_list
modifier|*
name|lp
decl_stmt|,
modifier|*
name|lp2
decl_stmt|,
modifier|*
name|tlp
decl_stmt|;
name|time_t
name|secs
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|head
operator|,
name|lp2
operator|=
name|NULL
init|;
name|lp
operator|!=
name|NULL
condition|;
control|)
if|if
condition|(
operator|*
name|up
operator|->
name|ut_line
operator|==
literal|'~'
operator|||
name|strncmp
argument_list|(
name|lp
operator|->
name|usr
operator|.
name|ut_line
argument_list|,
name|up
operator|->
name|ut_line
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|ut_line
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|secs
operator|=
name|up
operator|->
name|ut_time
operator|-
name|lp
operator|->
name|usr
operator|.
name|ut_time
expr_stmt|;
name|Users
operator|=
name|update_user
argument_list|(
name|Users
argument_list|,
name|lp
operator|->
name|usr
operator|.
name|ut_name
argument_list|,
name|secs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"%s logged out (%2d:%02d:%02d)\n"
argument_list|,
name|debug_pfx
argument_list|(
name|up
argument_list|,
operator|&
name|lp
operator|->
name|usr
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|secs
operator|/
literal|3600
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|secs
operator|%
literal|3600
operator|)
operator|/
literal|60
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|secs
operator|%
literal|60
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * now lose it 			 */
name|tlp
operator|=
name|lp
expr_stmt|;
name|lp
operator|=
name|lp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tlp
operator|==
name|head
condition|)
name|head
operator|=
name|lp
expr_stmt|;
elseif|else
if|if
condition|(
name|lp2
operator|!=
name|NULL
condition|)
name|lp2
operator|->
name|next
operator|=
name|lp
expr_stmt|;
name|free
argument_list|(
name|tlp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lp2
operator|=
name|lp
expr_stmt|;
name|lp
operator|=
name|lp
operator|->
name|next
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/*  * if do_tty says ok, login a user  */
end_comment

begin_function
name|struct
name|utmp_list
modifier|*
name|log_in
parameter_list|(
name|struct
name|utmp_list
modifier|*
name|head
parameter_list|,
name|struct
name|utmp
modifier|*
name|up
parameter_list|)
block|{
name|struct
name|utmp_list
modifier|*
name|lp
decl_stmt|;
comment|/* 	 * this could be a login. if we're not dealing with 	 * the console name, say it is. 	 * 	 * If we are, and if ut_host==":0.0" we know that it 	 * isn't a real login. _But_ if we have not yet recorded 	 * someone being logged in on Console - due to the wtmp 	 * file starting after they logged in, we'll pretend they 	 * logged in, at the start of the wtmp file. 	 */
ifdef|#
directive|ifdef
name|CONSOLE_TTY
if|if
condition|(
name|up
operator|->
name|ut_host
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* 		 * SunOS 4.0.2 does not treat ":0.0" as special but we 		 * do. 		 */
if|if
condition|(
name|on_console
argument_list|(
name|head
argument_list|)
condition|)
return|return
name|head
return|;
comment|/* 		 * ok, no recorded login, so they were here when wtmp 		 * started!  Adjust ut_time! 		 */
name|up
operator|->
name|ut_time
operator|=
name|FirstTime
expr_stmt|;
comment|/* 		 * this allows us to pick the right logout 		 */
name|strlcpy
argument_list|(
name|up
operator|->
name|ut_line
argument_list|,
name|Console
argument_list|,
sizeof|sizeof
argument_list|(
name|up
operator|->
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If we are doing specified ttys only, we ignore 	 * anything else. 	 */
if|if
condition|(
name|Flags
operator|&
name|AC_T
condition|)
if|if
condition|(
operator|!
name|do_tty
argument_list|(
name|up
operator|->
name|ut_line
argument_list|)
condition|)
return|return
name|head
return|;
comment|/* 	 * go ahead and log them in 	 */
if|if
condition|(
operator|(
name|lp
operator|=
name|NEW
argument_list|(
expr|struct
name|utmp_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc failed"
argument_list|)
expr_stmt|;
name|lp
operator|->
name|next
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|lp
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|lp
operator|->
name|usr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|up
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
block|{
name|printf
argument_list|(
literal|"%s logged in"
argument_list|,
name|debug_pfx
argument_list|(
operator|&
name|lp
operator|->
name|usr
argument_list|,
name|up
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|up
operator|->
name|ut_host
condition|)
name|printf
argument_list|(
literal|" (%-.*s)"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|up
operator|->
name|ut_host
argument_list|)
argument_list|,
name|up
operator|->
name|ut_host
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|head
return|;
block|}
end_function

begin_function
name|int
name|ac
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|utmp_list
modifier|*
name|lp
decl_stmt|,
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
name|struct
name|utmp
name|usr
decl_stmt|;
name|struct
name|tm
modifier|*
name|ltm
decl_stmt|;
name|time_t
name|prev_secs
decl_stmt|,
name|secs
decl_stmt|,
name|ut_timecopy
decl_stmt|;
name|int
name|day
decl_stmt|,
name|rfound
decl_stmt|,
name|tchanged
decl_stmt|,
name|tskipped
decl_stmt|;
name|day
operator|=
operator|-
literal|1
expr_stmt|;
name|prev_secs
operator|=
literal|1
expr_stmt|;
comment|/* Minimum acceptable date == 1970 */
name|rfound
operator|=
name|tchanged
operator|=
name|tskipped
operator|=
literal|0
expr_stmt|;
name|secs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|usr
argument_list|,
sizeof|sizeof
argument_list|(
name|usr
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
operator|==
literal|1
condition|)
block|{
name|rfound
operator|++
expr_stmt|;
comment|/* 		 * The type of utmp.ut_time is not necessary type time_t, as 		 * it is explicitly defined as type int32_t.  Copy the value 		 * for platforms where sizeof(time_t) != size(int32_t). 		 */
name|ut_timecopy
operator|=
name|_time32_to_time
argument_list|(
name|usr
operator|.
name|ut_time
argument_list|)
expr_stmt|;
comment|/* 		 * With sparc64 using 64-bit time_t's, there is some system 		 * routine which sets ut_time==0 (the high-order word of a 		 * 64-bit time) instead of a 32-bit time value.  For those 		 * wtmp files, it is "more-accurate" to substitute the most- 		 * recent time found, instead of throwing away the entire 		 * record.  While it is still just a guess, it is a better 		 * guess than throwing away a log-off record and therefore 		 * counting a session as if it continued to the end of the 		 * month, or the next system-reboot. 		 */
if|if
condition|(
name|ut_timecopy
operator|==
literal|0
operator|&&
name|prev_secs
operator|>
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"%s - date changed to: %s"
argument_list|,
name|debug_pfx
argument_list|(
operator|&
name|usr
argument_list|,
operator|&
name|usr
argument_list|)
argument_list|,
name|ctime
argument_list|(
operator|&
name|prev_secs
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tchanged
operator|++
expr_stmt|;
name|usr
operator|.
name|ut_time
operator|=
name|ut_timecopy
operator|=
name|prev_secs
expr_stmt|;
block|}
comment|/* 		 * Skip records where the time goes backwards. 		 */
if|if
condition|(
name|ut_timecopy
operator|<
name|prev_secs
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|Debug
condition|)
name|printf
argument_list|(
literal|"%s - bad date, record skipped\n"
argument_list|,
name|debug_pfx
argument_list|(
operator|&
name|usr
argument_list|,
operator|&
name|usr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tskipped
operator|++
expr_stmt|;
continue|continue;
comment|/* Skip this invalid record. */
block|}
name|prev_secs
operator|=
name|ut_timecopy
expr_stmt|;
if|if
condition|(
operator|!
name|FirstTime
condition|)
name|FirstTime
operator|=
name|ut_timecopy
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|AC_D
condition|)
block|{
name|ltm
operator|=
name|localtime
argument_list|(
operator|&
name|ut_timecopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|day
operator|>=
literal|0
operator|&&
name|day
operator|!=
name|ltm
operator|->
name|tm_yday
condition|)
block|{
name|day
operator|=
name|ltm
operator|->
name|tm_yday
expr_stmt|;
comment|/* 				 * print yesterday's total 				 */
name|secs
operator|=
name|ut_timecopy
expr_stmt|;
name|secs
operator|-=
name|ltm
operator|->
name|tm_sec
expr_stmt|;
name|secs
operator|-=
literal|60
operator|*
name|ltm
operator|->
name|tm_min
expr_stmt|;
name|secs
operator|-=
literal|3600
operator|*
name|ltm
operator|->
name|tm_hour
expr_stmt|;
name|show_today
argument_list|(
name|Users
argument_list|,
name|head
argument_list|,
name|secs
argument_list|)
expr_stmt|;
block|}
else|else
name|day
operator|=
name|ltm
operator|->
name|tm_yday
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|usr
operator|.
name|ut_line
condition|)
block|{
case|case
literal|'|'
case|:
name|secs
operator|=
name|ut_timecopy
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|secs
operator|-=
name|ut_timecopy
expr_stmt|;
comment|/* 			 * adjust time for those logged in 			 */
for|for
control|(
name|lp
operator|=
name|head
init|;
name|lp
operator|!=
name|NULL
condition|;
name|lp
operator|=
name|lp
operator|->
name|next
control|)
name|lp
operator|->
name|usr
operator|.
name|ut_time
operator|-=
name|secs
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
comment|/* reboot or shutdown */
name|head
operator|=
name|log_out
argument_list|(
name|head
argument_list|,
operator|&
name|usr
argument_list|)
expr_stmt|;
name|FirstTime
operator|=
name|ut_timecopy
expr_stmt|;
comment|/* shouldn't be needed */
break|break;
default|default:
comment|/* 			 * if they came in on tty[p-sP-S]*, then it is only 			 * a login session if the ut_host field is non-empty 			 */
if|if
condition|(
operator|*
name|usr
operator|.
name|ut_name
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|usr
operator|.
name|ut_line
argument_list|,
literal|"tty"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strchr
argument_list|(
literal|"pqrsPQRS"
argument_list|,
name|usr
operator|.
name|ut_line
index|[
literal|3
index|]
argument_list|)
operator|!=
literal|0
operator|||
operator|*
name|usr
operator|.
name|ut_host
operator|!=
literal|'\0'
condition|)
name|head
operator|=
name|log_in
argument_list|(
name|head
argument_list|,
operator|&
name|usr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
elseif|else
if|if
condition|(
name|Debug
operator|>
literal|1
condition|)
comment|/* Things such as 'screen' sessions. */
name|printf
argument_list|(
literal|"%s - record ignored\n"
argument_list|,
name|debug_pfx
argument_list|(
operator|&
name|usr
argument_list|,
operator|&
name|usr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|head
operator|=
name|log_out
argument_list|(
name|head
argument_list|,
operator|&
name|usr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|Flags
operator|&
name|AC_W
operator|)
condition|)
name|usr
operator|.
name|ut_time
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|usr
operator|.
name|ut_line
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|AC_D
condition|)
block|{
name|ut_timecopy
operator|=
name|_time32_to_time
argument_list|(
name|usr
operator|.
name|ut_time
argument_list|)
expr_stmt|;
name|ltm
operator|=
name|localtime
argument_list|(
operator|&
name|ut_timecopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|day
operator|>=
literal|0
operator|&&
name|day
operator|!=
name|ltm
operator|->
name|tm_yday
condition|)
block|{
comment|/* 			 * print yesterday's total 			 */
name|secs
operator|=
name|ut_timecopy
expr_stmt|;
name|secs
operator|-=
name|ltm
operator|->
name|tm_sec
expr_stmt|;
name|secs
operator|-=
literal|60
operator|*
name|ltm
operator|->
name|tm_min
expr_stmt|;
name|secs
operator|-=
literal|3600
operator|*
name|ltm
operator|->
name|tm_hour
expr_stmt|;
name|show_today
argument_list|(
name|Users
argument_list|,
name|head
argument_list|,
name|secs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * anyone still logged in gets time up to now 	 */
name|head
operator|=
name|log_out
argument_list|(
name|head
argument_list|,
operator|&
name|usr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|AC_D
condition|)
name|show_today
argument_list|(
name|Users
argument_list|,
name|head
argument_list|,
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|Flags
operator|&
name|AC_P
condition|)
name|show_users
argument_list|(
name|Users
argument_list|)
expr_stmt|;
name|show
argument_list|(
literal|"total"
argument_list|,
name|Total
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tskipped
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"(Skipped %d of %d records due to invalid time values)\n"
argument_list|,
name|tskipped
argument_list|,
name|rfound
argument_list|)
expr_stmt|;
if|if
condition|(
name|tchanged
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"(Changed %d of %d records to have a more likely time value)\n"
argument_list|,
name|tchanged
argument_list|,
name|rfound
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
ifdef|#
directive|ifdef
name|CONSOLE_TTY
literal|"ac [-dp] [-c console] [-t tty] [-w wtmp] [users ...]\n"
argument_list|)
expr_stmt|;
else|#
directive|else
literal|"ac [-dp] [-t tty] [-w wtmp] [users ...]\n"
block|)
function|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* Copied from src/lib/libc/stdtime/time32.c in 5.x-current. */
end_comment

begin_macro
unit|time_t
name|_time32_to_time
argument_list|(
argument|__int32_t t32
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
operator|(
name|time_t
operator|)
name|t32
operator|)
return|;
block|}
end_block

begin_function
name|time_t
name|_int_to_time
parameter_list|(
name|int
name|tint
parameter_list|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|__int32_t
argument_list|)
condition|)
return|return
operator|(
name|_time32_to_time
argument_list|(
name|tint
argument_list|)
operator|)
return|;
return|return
operator|(
operator|(
name|time_t
operator|)
name|tint
operator|)
return|;
block|}
end_function

end_unit

