begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NOID
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|elsieid
index|[]
init|=
literal|"@(#)zic.c	7.96"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined NOID */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"private.h"
end_include

begin_include
include|#
directive|include
file|"tzfile.h"
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* for umask manifest constants */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* ** On some ancient hosts, predicates like `isspace(C)' are defined ** only if isascii(C) || C == EOF.  Modern hosts obey the C Standard, ** which says they are defined only if C == ((unsigned char) C) || C == EOF. ** Neither the C Standard nor Posix require that `isascii' exist. ** For portability, we check both ancient and modern requirements. ** If isascii is not defined, the isascii check succeeds trivially. */
end_comment

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|isascii
end_ifndef

begin_define
define|#
directive|define
name|isascii
parameter_list|(
name|x
parameter_list|)
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|rule
block|{
specifier|const
name|char
modifier|*
name|r_filename
decl_stmt|;
name|int
name|r_linenum
decl_stmt|;
specifier|const
name|char
modifier|*
name|r_name
decl_stmt|;
name|int
name|r_loyear
decl_stmt|;
comment|/* for example, 1986 */
name|int
name|r_hiyear
decl_stmt|;
comment|/* for example, 1986 */
specifier|const
name|char
modifier|*
name|r_yrtype
decl_stmt|;
name|int
name|r_month
decl_stmt|;
comment|/* 0..11 */
name|int
name|r_dycode
decl_stmt|;
comment|/* see below */
name|int
name|r_dayofmonth
decl_stmt|;
name|int
name|r_wday
decl_stmt|;
name|long
name|r_tod
decl_stmt|;
comment|/* time from midnight */
name|int
name|r_todisstd
decl_stmt|;
comment|/* above is standard time if TRUE */
comment|/* or wall clock time if FALSE */
name|int
name|r_todisgmt
decl_stmt|;
comment|/* above is GMT if TRUE */
comment|/* or local time if FALSE */
name|long
name|r_stdoff
decl_stmt|;
comment|/* offset from standard time */
specifier|const
name|char
modifier|*
name|r_abbrvar
decl_stmt|;
comment|/* variable part of abbreviation */
name|int
name|r_todo
decl_stmt|;
comment|/* a rule to do (used in outzone) */
name|time_t
name|r_temp
decl_stmt|;
comment|/* used in outzone */
block|}
struct|;
end_struct

begin_comment
comment|/* **	r_dycode		r_dayofmonth	r_wday */
end_comment

begin_define
define|#
directive|define
name|DC_DOM
value|0
end_define

begin_comment
comment|/* 1..31 */
end_comment

begin_comment
comment|/* unused */
end_comment

begin_define
define|#
directive|define
name|DC_DOWGEQ
value|1
end_define

begin_comment
comment|/* 1..31 */
end_comment

begin_comment
comment|/* 0..6 (Sun..Sat) */
end_comment

begin_define
define|#
directive|define
name|DC_DOWLEQ
value|2
end_define

begin_comment
comment|/* 1..31 */
end_comment

begin_comment
comment|/* 0..6 (Sun..Sat) */
end_comment

begin_struct
struct|struct
name|zone
block|{
specifier|const
name|char
modifier|*
name|z_filename
decl_stmt|;
name|int
name|z_linenum
decl_stmt|;
specifier|const
name|char
modifier|*
name|z_name
decl_stmt|;
name|long
name|z_gmtoff
decl_stmt|;
specifier|const
name|char
modifier|*
name|z_rule
decl_stmt|;
specifier|const
name|char
modifier|*
name|z_format
decl_stmt|;
name|long
name|z_stdoff
decl_stmt|;
name|struct
name|rule
modifier|*
name|z_rules
decl_stmt|;
name|int
name|z_nrules
decl_stmt|;
name|struct
name|rule
name|z_untilrule
decl_stmt|;
name|time_t
name|z_untiltime
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|addtt
name|P
argument_list|(
operator|(
name|time_t
name|starttime
operator|,
name|int
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addtype
name|P
argument_list|(
operator|(
name|long
name|gmtoff
operator|,
specifier|const
name|char
operator|*
name|abbr
operator|,
name|int
name|isdst
operator|,
name|int
name|ttisstd
operator|,
name|int
name|ttisgmt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|leapadd
name|P
argument_list|(
operator|(
name|time_t
name|t
operator|,
name|int
name|positive
operator|,
name|int
name|rolling
operator|,
name|int
name|count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adjleap
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|associate
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ciequal
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|ap
operator|,
specifier|const
name|char
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|convert
name|P
argument_list|(
operator|(
name|long
name|val
operator|,
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dolink
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|fromfile
operator|,
specifier|const
name|char
operator|*
name|tofile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|doabbr
name|P
argument_list|(
operator|(
name|char
operator|*
name|abbr
operator|,
specifier|const
name|char
operator|*
name|format
operator|,
specifier|const
name|char
operator|*
name|letters
operator|,
name|int
name|isdst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eat
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|,
name|int
name|num
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eats
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|,
name|int
name|num
operator|,
specifier|const
name|char
operator|*
name|rname
operator|,
name|int
name|rnum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|eitol
name|P
argument_list|(
operator|(
name|int
name|i
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|error
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|message
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|getfields
name|P
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|gethms
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|string
operator|,
specifier|const
name|char
operator|*
name|errstrng
operator|,
name|int
name|signable
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|infile
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|filename
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|inleap
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|fields
operator|,
name|int
name|nfields
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|inlink
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|fields
operator|,
name|int
name|nfields
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|inrule
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|fields
operator|,
name|int
name|nfields
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inzcont
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|fields
operator|,
name|int
name|nfields
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inzone
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|fields
operator|,
name|int
name|nfields
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inzsub
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
name|fields
operator|,
name|int
name|nfields
operator|,
name|int
name|iscont
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|itsabbr
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|abbr
operator|,
specifier|const
name|char
operator|*
name|word
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|itsdir
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lowerit
name|P
argument_list|(
operator|(
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|memcheck
name|P
argument_list|(
operator|(
name|char
operator|*
name|tocheck
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mkdirs
name|P
argument_list|(
operator|(
name|char
operator|*
name|filename
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|newabbr
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|abbr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|oadd
name|P
argument_list|(
operator|(
name|long
name|t1
operator|,
name|long
name|t2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|outzone
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|zone
operator|*
name|zp
operator|,
name|int
name|ntzones
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|puttzcode
name|P
argument_list|(
operator|(
name|long
name|code
operator|,
name|FILE
operator|*
name|fp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rcomp
name|P
argument_list|(
operator|(
specifier|const
name|void
operator|*
name|leftp
operator|,
specifier|const
name|void
operator|*
name|rightp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|rpytime
name|P
argument_list|(
operator|(
specifier|const
expr|struct
name|rule
operator|*
name|rp
operator|,
name|int
name|wantedy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rulesub
name|P
argument_list|(
operator|(
expr|struct
name|rule
operator|*
name|rp
operator|,
specifier|const
name|char
operator|*
name|loyearp
operator|,
specifier|const
name|char
operator|*
name|hiyearp
operator|,
specifier|const
name|char
operator|*
name|typep
operator|,
specifier|const
name|char
operator|*
name|monthp
operator|,
specifier|const
name|char
operator|*
name|dayp
operator|,
specifier|const
name|char
operator|*
name|timep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setboundaries
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setgroup
name|P
argument_list|(
operator|(
name|gid_t
operator|*
name|flag
operator|,
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setuser
name|P
argument_list|(
operator|(
name|uid_t
operator|*
name|flag
operator|,
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|tadd
name|P
argument_list|(
operator|(
name|time_t
name|t1
operator|,
name|long
name|t2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|writezone
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|yearistype
name|P
argument_list|(
operator|(
name|int
name|year
operator|,
specifier|const
name|char
operator|*
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
operator|(
name|HAVE_STRERROR
operator|-
literal|0
operator|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strerror
name|P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !(HAVE_STRERROR - 0) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|charcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|leapcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|max_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_year
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_year_representable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|min_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_year
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_year_representable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rlinenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timecnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|typecnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Line codes. */
end_comment

begin_define
define|#
directive|define
name|LC_RULE
value|0
end_define

begin_define
define|#
directive|define
name|LC_ZONE
value|1
end_define

begin_define
define|#
directive|define
name|LC_LINK
value|2
end_define

begin_define
define|#
directive|define
name|LC_LEAP
value|3
end_define

begin_comment
comment|/* ** Which fields are which on a Zone line. */
end_comment

begin_define
define|#
directive|define
name|ZF_NAME
value|1
end_define

begin_define
define|#
directive|define
name|ZF_GMTOFF
value|2
end_define

begin_define
define|#
directive|define
name|ZF_RULE
value|3
end_define

begin_define
define|#
directive|define
name|ZF_FORMAT
value|4
end_define

begin_define
define|#
directive|define
name|ZF_TILYEAR
value|5
end_define

begin_define
define|#
directive|define
name|ZF_TILMONTH
value|6
end_define

begin_define
define|#
directive|define
name|ZF_TILDAY
value|7
end_define

begin_define
define|#
directive|define
name|ZF_TILTIME
value|8
end_define

begin_define
define|#
directive|define
name|ZONE_MINFIELDS
value|5
end_define

begin_define
define|#
directive|define
name|ZONE_MAXFIELDS
value|9
end_define

begin_comment
comment|/* ** Which fields are which on a Zone continuation line. */
end_comment

begin_define
define|#
directive|define
name|ZFC_GMTOFF
value|0
end_define

begin_define
define|#
directive|define
name|ZFC_RULE
value|1
end_define

begin_define
define|#
directive|define
name|ZFC_FORMAT
value|2
end_define

begin_define
define|#
directive|define
name|ZFC_TILYEAR
value|3
end_define

begin_define
define|#
directive|define
name|ZFC_TILMONTH
value|4
end_define

begin_define
define|#
directive|define
name|ZFC_TILDAY
value|5
end_define

begin_define
define|#
directive|define
name|ZFC_TILTIME
value|6
end_define

begin_define
define|#
directive|define
name|ZONEC_MINFIELDS
value|3
end_define

begin_define
define|#
directive|define
name|ZONEC_MAXFIELDS
value|7
end_define

begin_comment
comment|/* ** Which files are which on a Rule line. */
end_comment

begin_define
define|#
directive|define
name|RF_NAME
value|1
end_define

begin_define
define|#
directive|define
name|RF_LOYEAR
value|2
end_define

begin_define
define|#
directive|define
name|RF_HIYEAR
value|3
end_define

begin_define
define|#
directive|define
name|RF_COMMAND
value|4
end_define

begin_define
define|#
directive|define
name|RF_MONTH
value|5
end_define

begin_define
define|#
directive|define
name|RF_DAY
value|6
end_define

begin_define
define|#
directive|define
name|RF_TOD
value|7
end_define

begin_define
define|#
directive|define
name|RF_STDOFF
value|8
end_define

begin_define
define|#
directive|define
name|RF_ABBRVAR
value|9
end_define

begin_define
define|#
directive|define
name|RULE_FIELDS
value|10
end_define

begin_comment
comment|/* ** Which fields are which on a Link line. */
end_comment

begin_define
define|#
directive|define
name|LF_FROM
value|1
end_define

begin_define
define|#
directive|define
name|LF_TO
value|2
end_define

begin_define
define|#
directive|define
name|LINK_FIELDS
value|3
end_define

begin_comment
comment|/* ** Which fields are which on a Leap line. */
end_comment

begin_define
define|#
directive|define
name|LP_YEAR
value|1
end_define

begin_define
define|#
directive|define
name|LP_MONTH
value|2
end_define

begin_define
define|#
directive|define
name|LP_DAY
value|3
end_define

begin_define
define|#
directive|define
name|LP_TIME
value|4
end_define

begin_define
define|#
directive|define
name|LP_CORR
value|5
end_define

begin_define
define|#
directive|define
name|LP_ROLL
value|6
end_define

begin_define
define|#
directive|define
name|LEAP_FIELDS
value|7
end_define

begin_comment
comment|/* ** Year synonyms. */
end_comment

begin_define
define|#
directive|define
name|YR_MINIMUM
value|0
end_define

begin_define
define|#
directive|define
name|YR_MAXIMUM
value|1
end_define

begin_define
define|#
directive|define
name|YR_ONLY
value|2
end_define

begin_decl_stmt
specifier|static
name|struct
name|rule
modifier|*
name|rules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nrules
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of rules */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|zone
modifier|*
name|zones
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nzones
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of zones */
end_comment

begin_struct
struct|struct
name|link
block|{
specifier|const
name|char
modifier|*
name|l_filename
decl_stmt|;
name|int
name|l_linenum
decl_stmt|;
specifier|const
name|char
modifier|*
name|l_from
decl_stmt|;
specifier|const
name|char
modifier|*
name|l_to
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|link
modifier|*
name|links
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nlinks
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|lookup
block|{
specifier|const
name|char
modifier|*
name|l_word
decl_stmt|;
specifier|const
name|int
name|l_value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
modifier|*
name|byword
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|string
operator|,
specifier|const
expr|struct
name|lookup
operator|*
name|lp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|line_codes
index|[]
init|=
block|{
block|{
literal|"Rule"
block|,
name|LC_RULE
block|}
block|,
block|{
literal|"Zone"
block|,
name|LC_ZONE
block|}
block|,
block|{
literal|"Link"
block|,
name|LC_LINK
block|}
block|,
block|{
literal|"Leap"
block|,
name|LC_LEAP
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|mon_names
index|[]
init|=
block|{
block|{
literal|"January"
block|,
name|TM_JANUARY
block|}
block|,
block|{
literal|"February"
block|,
name|TM_FEBRUARY
block|}
block|,
block|{
literal|"March"
block|,
name|TM_MARCH
block|}
block|,
block|{
literal|"April"
block|,
name|TM_APRIL
block|}
block|,
block|{
literal|"May"
block|,
name|TM_MAY
block|}
block|,
block|{
literal|"June"
block|,
name|TM_JUNE
block|}
block|,
block|{
literal|"July"
block|,
name|TM_JULY
block|}
block|,
block|{
literal|"August"
block|,
name|TM_AUGUST
block|}
block|,
block|{
literal|"September"
block|,
name|TM_SEPTEMBER
block|}
block|,
block|{
literal|"October"
block|,
name|TM_OCTOBER
block|}
block|,
block|{
literal|"November"
block|,
name|TM_NOVEMBER
block|}
block|,
block|{
literal|"December"
block|,
name|TM_DECEMBER
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|wday_names
index|[]
init|=
block|{
block|{
literal|"Sunday"
block|,
name|TM_SUNDAY
block|}
block|,
block|{
literal|"Monday"
block|,
name|TM_MONDAY
block|}
block|,
block|{
literal|"Tuesday"
block|,
name|TM_TUESDAY
block|}
block|,
block|{
literal|"Wednesday"
block|,
name|TM_WEDNESDAY
block|}
block|,
block|{
literal|"Thursday"
block|,
name|TM_THURSDAY
block|}
block|,
block|{
literal|"Friday"
block|,
name|TM_FRIDAY
block|}
block|,
block|{
literal|"Saturday"
block|,
name|TM_SATURDAY
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|lasts
index|[]
init|=
block|{
block|{
literal|"last-Sunday"
block|,
name|TM_SUNDAY
block|}
block|,
block|{
literal|"last-Monday"
block|,
name|TM_MONDAY
block|}
block|,
block|{
literal|"last-Tuesday"
block|,
name|TM_TUESDAY
block|}
block|,
block|{
literal|"last-Wednesday"
block|,
name|TM_WEDNESDAY
block|}
block|,
block|{
literal|"last-Thursday"
block|,
name|TM_THURSDAY
block|}
block|,
block|{
literal|"last-Friday"
block|,
name|TM_FRIDAY
block|}
block|,
block|{
literal|"last-Saturday"
block|,
name|TM_SATURDAY
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|begin_years
index|[]
init|=
block|{
block|{
literal|"minimum"
block|,
name|YR_MINIMUM
block|}
block|,
block|{
literal|"maximum"
block|,
name|YR_MAXIMUM
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|end_years
index|[]
init|=
block|{
block|{
literal|"minimum"
block|,
name|YR_MINIMUM
block|}
block|,
block|{
literal|"maximum"
block|,
name|YR_MAXIMUM
block|}
block|,
block|{
literal|"only"
block|,
name|YR_ONLY
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lookup
specifier|const
name|leap_types
index|[]
init|=
block|{
block|{
literal|"Rolling"
block|,
name|TRUE
block|}
block|,
block|{
literal|"Stationary"
block|,
name|FALSE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|len_months
index|[
literal|2
index|]
index|[
name|MONSPERYEAR
index|]
init|=
block|{
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|,
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|len_years
index|[
literal|2
index|]
init|=
block|{
name|DAYSPERNYEAR
block|,
name|DAYSPERLYEAR
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|attype
block|{
name|time_t
name|at
decl_stmt|;
name|unsigned
name|char
name|type
decl_stmt|;
block|}
name|attypes
index|[
name|TZ_MAX_TIMES
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|long
name|gmtoffs
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|isdsts
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|abbrinds
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ttisstds
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|ttisgmts
index|[
name|TZ_MAX_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|chars
index|[
name|TZ_MAX_CHARS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|trans
index|[
name|TZ_MAX_LEAPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|corr
index|[
name|TZ_MAX_LEAPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|roll
index|[
name|TZ_MAX_LEAPS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Memory allocation. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|memcheck
parameter_list|(
name|ptr
parameter_list|)
name|char
modifier|*
specifier|const
name|ptr
decl_stmt|;
block|{
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"memory exhausted"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_define
define|#
directive|define
name|emalloc
parameter_list|(
name|size
parameter_list|)
value|memcheck(imalloc(size))
end_define

begin_define
define|#
directive|define
name|erealloc
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
value|memcheck(irealloc((ptr), (size)))
end_define

begin_define
define|#
directive|define
name|ecpyalloc
parameter_list|(
name|ptr
parameter_list|)
value|memcheck(icpyalloc(ptr))
end_define

begin_define
define|#
directive|define
name|ecatalloc
parameter_list|(
name|oldp
parameter_list|,
name|newp
parameter_list|)
value|memcheck(icatalloc((oldp), (newp)))
end_define

begin_comment
comment|/* ** Error handling. */
end_comment

begin_if
if|#
directive|if
operator|!
operator|(
name|HAVE_STRERROR
operator|-
literal|0
operator|)
end_if

begin_function
specifier|static
name|char
modifier|*
name|strerror
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
specifier|extern
name|int
name|sys_nerr
decl_stmt|;
return|return
operator|(
name|errnum
operator|>
literal|0
operator|&&
name|errnum
operator|<=
name|sys_nerr
operator|)
condition|?
name|sys_errlist
index|[
name|errnum
index|]
else|:
name|_
argument_list|(
literal|"Unknown system error"
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !(HAVE_STRERROR - 0) */
end_comment

begin_function
specifier|static
name|void
name|eats
parameter_list|(
name|name
parameter_list|,
name|num
parameter_list|,
name|rname
parameter_list|,
name|rnum
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|num
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|rname
decl_stmt|;
specifier|const
name|int
name|rnum
decl_stmt|;
block|{
name|filename
operator|=
name|name
expr_stmt|;
name|linenum
operator|=
name|num
expr_stmt|;
name|rfilename
operator|=
name|rname
expr_stmt|;
name|rlinenum
operator|=
name|rnum
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eat
parameter_list|(
name|name
parameter_list|,
name|num
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
specifier|const
name|int
name|num
decl_stmt|;
block|{
name|eats
argument_list|(
name|name
argument_list|,
name|num
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|string
decl_stmt|;
block|{
comment|/* 	** Match the format of "cc" to allow sh users to 	**	zic ... 2>&1 | error -t "*" -v 	** on BSD systems. 	*/
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\"%s\", line %d: %s"
argument_list|)
argument_list|,
name|filename
argument_list|,
name|linenum
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|rfilename
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" (rule from \"%s\", line %d)"
argument_list|)
argument_list|,
name|rfilename
argument_list|,
name|rlinenum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|++
name|errors
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|warning
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|ecpyalloc
argument_list|(
name|_
argument_list|(
literal|"warning: "
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ecatalloc
argument_list|(
name|cp
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|--
name|errors
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|usage
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n"
argument_list|,
name|_
argument_list|(
literal|"usage: zic [-s] [-v] [-l localtime] [-p posixrules] [-d directory]"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"           [-L leapseconds] [-y yearistype] [filename ... ]"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|psxrules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lcltime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|directory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|leapsec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|yitcommand
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sflag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|Dflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uid_t
name|uflag
init|=
operator|(
name|uid_t
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|gid_t
name|gflag
init|=
operator|(
name|gid_t
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mode_t
name|mflag
init|=
operator|(
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
operator||
name|S_IWUSR
operator|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|unix
operator|(
name|void
operator|)
name|umask
argument_list|(
name|umask
argument_list|(
name|S_IWGRP
operator||
name|S_IWOTH
argument_list|)
operator||
operator|(
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined unix */
if|#
directive|if
name|HAVE_GETTEXT
operator|-
literal|0
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TZ_DOMAINDIR
operator|(
name|void
operator|)
name|bindtextdomain
argument_list|(
name|TZ_DOMAIN
argument_list|,
name|TZ_DOMAINDIR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined TEXTDOMAINDIR */
operator|(
name|void
operator|)
name|textdomain
argument_list|(
name|TZ_DOMAIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_GETTEXT - 0 */
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"Dd:g:l:m:p:L:u:vsy:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
name|usage
argument_list|()
expr_stmt|;
case|case
literal|'D'
case|:
name|Dflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|directory
operator|==
name|NULL
condition|)
name|directory
operator|=
name|optarg
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"more than one -d option specified"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|setgroup
argument_list|(
operator|&
name|gflag
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|lcltime
operator|==
name|NULL
condition|)
name|lcltime
operator|=
name|optarg
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"more than one -l option specified"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
block|{
name|void
modifier|*
name|set
init|=
name|setmode
argument_list|(
name|optarg
argument_list|)
decl_stmt|;
name|getmode
argument_list|(
name|set
argument_list|,
name|mflag
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'p'
case|:
if|if
condition|(
name|psxrules
operator|==
name|NULL
condition|)
name|psxrules
operator|=
name|optarg
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"more than one -p option specified"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|setuser
argument_list|(
operator|&
name|uflag
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
if|if
condition|(
name|yitcommand
operator|==
name|NULL
condition|)
name|yitcommand
operator|=
name|optarg
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"more than one -y option specified"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
if|if
condition|(
name|leapsec
operator|==
name|NULL
condition|)
name|leapsec
operator|=
name|optarg
expr_stmt|;
else|else
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"more than one -L option specified"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|noise
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sflag
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|1
operator|&&
name|strcmp
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
literal|"="
argument_list|)
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* usage message by request */
if|if
condition|(
name|directory
operator|==
name|NULL
condition|)
name|directory
operator|=
name|TZDIR
expr_stmt|;
if|if
condition|(
name|yitcommand
operator|==
name|NULL
condition|)
name|yitcommand
operator|=
literal|"yearistype"
expr_stmt|;
name|setboundaries
argument_list|()
expr_stmt|;
if|if
condition|(
name|optind
operator|<
name|argc
operator|&&
name|leapsec
operator|!=
name|NULL
condition|)
block|{
name|infile
argument_list|(
name|leapsec
argument_list|)
expr_stmt|;
name|adjleap
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|optind
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
name|infile
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
condition|)
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|associate
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
name|i
operator|=
name|j
control|)
block|{
comment|/* 		** Find the next non-continuation zone entry. 		*/
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nzones
operator|&&
name|zones
index|[
name|j
index|]
operator|.
name|z_name
operator|==
name|NULL
condition|;
operator|++
name|j
control|)
continue|continue;
name|outzone
argument_list|(
operator|&
name|zones
index|[
name|i
index|]
argument_list|,
name|j
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	** Make links. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlinks
condition|;
operator|++
name|i
control|)
name|dolink
argument_list|(
name|links
index|[
name|i
index|]
operator|.
name|l_from
argument_list|,
name|links
index|[
name|i
index|]
operator|.
name|l_to
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcltime
operator|!=
name|NULL
condition|)
name|dolink
argument_list|(
name|lcltime
argument_list|,
name|TZDEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|psxrules
operator|!=
name|NULL
condition|)
name|dolink
argument_list|(
name|psxrules
argument_list|,
name|TZDEFRULES
argument_list|)
expr_stmt|;
return|return
operator|(
name|errors
operator|==
literal|0
operator|)
condition|?
name|EXIT_SUCCESS
else|:
name|EXIT_FAILURE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dolink
parameter_list|(
name|fromfile
parameter_list|,
name|tofile
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|fromfile
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|tofile
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fromname
decl_stmt|;
specifier|register
name|char
modifier|*
name|toname
decl_stmt|;
if|if
condition|(
name|fromfile
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|fromname
operator|=
name|ecpyalloc
argument_list|(
name|fromfile
argument_list|)
expr_stmt|;
else|else
block|{
name|fromname
operator|=
name|ecpyalloc
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|fromname
operator|=
name|ecatalloc
argument_list|(
name|fromname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|fromname
operator|=
name|ecatalloc
argument_list|(
name|fromname
argument_list|,
name|fromfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tofile
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|toname
operator|=
name|ecpyalloc
argument_list|(
name|tofile
argument_list|)
expr_stmt|;
else|else
block|{
name|toname
operator|=
name|ecpyalloc
argument_list|(
name|directory
argument_list|)
expr_stmt|;
name|toname
operator|=
name|ecatalloc
argument_list|(
name|toname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|toname
operator|=
name|ecatalloc
argument_list|(
name|toname
argument_list|,
name|tofile
argument_list|)
expr_stmt|;
block|}
comment|/* 	** We get to be careful here since 	** there's a fair chance of root running us. 	*/
if|if
condition|(
operator|!
name|itsdir
argument_list|(
name|toname
argument_list|)
condition|)
operator|(
name|void
operator|)
name|remove
argument_list|(
name|toname
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|fromname
argument_list|,
name|toname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|mkdirs
argument_list|(
name|toname
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|result
operator|=
name|link
argument_list|(
name|fromname
argument_list|,
name|toname
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|HAVE_SYMLINK
operator|-
literal|0
operator|)
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|symlink
argument_list|(
name|fromname
argument_list|,
name|toname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"hard link failed, symbolic link used"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"can't link from %s to %s"
argument_list|)
argument_list|,
name|fromname
argument_list|,
name|toname
argument_list|)
expr_stmt|;
block|}
block|}
name|ifree
argument_list|(
name|fromname
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|toname
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|INT_MAX
end_ifndef

begin_define
define|#
directive|define
name|INT_MAX
value|((int) (((unsigned)~0)>>1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined INT_MAX */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INT_MIN
end_ifndef

begin_define
define|#
directive|define
name|INT_MIN
value|((int) ~(((unsigned)~0)>>1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined INT_MIN */
end_comment

begin_comment
comment|/* ** The tz file format currently allows at most 32-bit quantities. ** This restriction should be removed before signed 32-bit values ** wrap around in 2038, but unfortunately this will require a ** change to the tz file format. */
end_comment

begin_define
define|#
directive|define
name|MAX_BITS_IN_FILE
value|32
end_define

begin_define
define|#
directive|define
name|TIME_T_BITS_IN_FILE
value|((TYPE_BIT(time_t)< MAX_BITS_IN_FILE) ? TYPE_BIT(time_t) : MAX_BITS_IN_FILE)
end_define

begin_decl_stmt
specifier|static
name|void
name|setboundaries
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
if|if
condition|(
name|TYPE_SIGNED
argument_list|(
name|time_t
argument_list|)
condition|)
block|{
name|min_time
operator|=
operator|~
operator|(
name|time_t
operator|)
literal|0
expr_stmt|;
name|min_time
operator|<<=
name|TIME_T_BITS_IN_FILE
operator|-
literal|1
expr_stmt|;
name|max_time
operator|=
operator|~
operator|(
name|time_t
operator|)
literal|0
operator|-
name|min_time
expr_stmt|;
if|if
condition|(
name|sflag
condition|)
name|min_time
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|min_time
operator|=
literal|0
expr_stmt|;
name|max_time
operator|=
literal|2
operator|-
name|sflag
expr_stmt|;
name|max_time
operator|<<=
name|TIME_T_BITS_IN_FILE
operator|-
literal|1
expr_stmt|;
operator|--
name|max_time
expr_stmt|;
block|}
name|min_year
operator|=
name|TM_YEAR_BASE
operator|+
name|gmtime
argument_list|(
operator|&
name|min_time
argument_list|)
operator|->
name|tm_year
expr_stmt|;
name|max_year
operator|=
name|TM_YEAR_BASE
operator|+
name|gmtime
argument_list|(
operator|&
name|max_time
argument_list|)
operator|->
name|tm_year
expr_stmt|;
name|min_year_representable
operator|=
name|min_year
expr_stmt|;
name|max_year_representable
operator|=
name|max_year
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|itsdir
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|myname
decl_stmt|;
specifier|register
name|int
name|accres
decl_stmt|;
name|myname
operator|=
name|ecpyalloc
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|myname
operator|=
name|ecatalloc
argument_list|(
name|myname
argument_list|,
literal|"/."
argument_list|)
expr_stmt|;
name|accres
operator|=
name|access
argument_list|(
name|myname
argument_list|,
name|F_OK
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|myname
argument_list|)
expr_stmt|;
return|return
name|accres
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ** Associate sets of rules with zones. */
end_comment

begin_comment
comment|/* ** Sort by rule name. */
end_comment

begin_function
specifier|static
name|int
name|rcomp
parameter_list|(
name|cp1
parameter_list|,
name|cp2
parameter_list|)
specifier|const
name|void
modifier|*
name|cp1
decl_stmt|;
specifier|const
name|void
modifier|*
name|cp2
decl_stmt|;
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|(
specifier|const
expr|struct
name|rule
operator|*
operator|)
name|cp1
operator|)
operator|->
name|r_name
argument_list|,
operator|(
operator|(
specifier|const
expr|struct
name|rule
operator|*
operator|)
name|cp2
operator|)
operator|->
name|r_name
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|associate
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
specifier|register
name|struct
name|zone
modifier|*
name|zp
decl_stmt|;
specifier|register
name|struct
name|rule
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|base
decl_stmt|,
name|out
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|nrules
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rules
argument_list|,
operator|(
name|size_t
operator|)
name|nrules
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
expr|*
name|rules
argument_list|,
name|rcomp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrules
operator|-
literal|1
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rules
index|[
name|i
index|]
operator|.
name|r_name
argument_list|,
name|rules
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|r_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|rules
index|[
name|i
index|]
operator|.
name|r_filename
argument_list|,
name|rules
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|r_filename
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|eat
argument_list|(
name|rules
index|[
name|i
index|]
operator|.
name|r_filename
argument_list|,
name|rules
index|[
name|i
index|]
operator|.
name|r_linenum
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"same rule name in multiple files"
argument_list|)
argument_list|)
expr_stmt|;
name|eat
argument_list|(
name|rules
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|r_filename
argument_list|,
name|rules
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|r_linenum
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|_
argument_list|(
literal|"same rule name in multiple files"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|2
init|;
name|j
operator|<
name|nrules
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|rules
index|[
name|i
index|]
operator|.
name|r_name
argument_list|,
name|rules
index|[
name|j
index|]
operator|.
name|r_name
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|rules
index|[
name|i
index|]
operator|.
name|r_filename
argument_list|,
name|rules
index|[
name|j
index|]
operator|.
name|r_filename
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|rules
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|r_filename
argument_list|,
name|rules
index|[
name|j
index|]
operator|.
name|r_filename
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
break|break;
block|}
name|i
operator|=
name|j
operator|-
literal|1
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
block|{
name|zp
operator|=
operator|&
name|zones
index|[
name|i
index|]
expr_stmt|;
name|zp
operator|->
name|z_rules
operator|=
name|NULL
expr_stmt|;
name|zp
operator|->
name|z_nrules
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|base
operator|=
literal|0
init|;
name|base
operator|<
name|nrules
condition|;
name|base
operator|=
name|out
control|)
block|{
name|rp
operator|=
operator|&
name|rules
index|[
name|base
index|]
expr_stmt|;
for|for
control|(
name|out
operator|=
name|base
operator|+
literal|1
init|;
name|out
operator|<
name|nrules
condition|;
operator|++
name|out
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|rp
operator|->
name|r_name
argument_list|,
name|rules
index|[
name|out
index|]
operator|.
name|r_name
argument_list|)
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
block|{
name|zp
operator|=
operator|&
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|zp
operator|->
name|z_rule
argument_list|,
name|rp
operator|->
name|r_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|zp
operator|->
name|z_rules
operator|=
name|rp
expr_stmt|;
name|zp
operator|->
name|z_nrules
operator|=
name|out
operator|-
name|base
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
block|{
name|zp
operator|=
operator|&
name|zones
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_nrules
operator|==
literal|0
condition|)
block|{
comment|/* 			** Maybe we have a local standard time offset. 			*/
name|eat
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_stdoff
operator|=
name|gethms
argument_list|(
name|zp
operator|->
name|z_rule
argument_list|,
name|_
argument_list|(
literal|"unruly zone"
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 			** Note, though, that if there's no rule, 			** a '%s' in the format is a bad thing. 			*/
if|if
condition|(
name|strchr
argument_list|(
name|zp
operator|->
name|z_format
argument_list|,
literal|'%'
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"%s in ruleless zone"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errors
condition|)
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|infile
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|fields
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nfields
decl_stmt|;
specifier|register
name|int
name|wantcont
decl_stmt|;
specifier|register
name|int
name|num
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|_
argument_list|(
literal|"standard input"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|stdin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"can't open %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|wantcont
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|num
operator|=
literal|1
init|;
condition|;
operator|++
name|num
control|)
block|{
name|eat
argument_list|(
name|name
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
operator|!=
name|buf
condition|)
break|break;
name|cp
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"line too long"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|fields
operator|=
name|getfields
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|nfields
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fields
index|[
name|nfields
index|]
operator|!=
name|NULL
condition|)
block|{
specifier|static
name|char
name|nada
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fields
index|[
name|nfields
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|fields
index|[
name|nfields
index|]
operator|=
operator|&
name|nada
expr_stmt|;
operator|++
name|nfields
expr_stmt|;
block|}
if|if
condition|(
name|nfields
operator|==
literal|0
condition|)
block|{
comment|/* nothing to do */
block|}
elseif|else
if|if
condition|(
name|wantcont
condition|)
block|{
name|wantcont
operator|=
name|inzcont
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lp
operator|=
name|byword
argument_list|(
name|fields
index|[
literal|0
index|]
argument_list|,
name|line_codes
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"input line of unknown type"
argument_list|)
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|lp
operator|->
name|l_value
argument_list|)
condition|)
block|{
case|case
name|LC_RULE
case|:
name|inrule
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|wantcont
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LC_ZONE
case|:
name|wantcont
operator|=
name|inzone
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|LC_LINK
case|:
name|inlink
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|wantcont
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|LC_LEAP
case|:
if|if
condition|(
name|name
operator|!=
name|leapsec
condition|)
name|warnx
argument_list|(
name|_
argument_list|(
literal|"leap line in non leap seconds file %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|inleap
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|wantcont
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
comment|/* "cannot happen" */
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"panic: invalid l_value %d"
argument_list|)
argument_list|,
name|lp
operator|->
name|l_value
argument_list|)
expr_stmt|;
block|}
block|}
name|ifree
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"error reading %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|stdin
operator|&&
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"error closing %s"
argument_list|)
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|wantcont
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"expected continuation line not found"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Convert a string of one of the forms **	h	-h	hh:mm	-hh:mm	hh:mm:ss	-hh:mm:ss ** into a number of seconds. ** A null string maps to zero. ** Call error with errstring and return zero on errors. */
end_comment

begin_function
specifier|static
name|long
name|gethms
parameter_list|(
name|string
parameter_list|,
name|errstring
parameter_list|,
name|signable
parameter_list|)
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|errstring
decl_stmt|;
specifier|const
name|int
name|signable
decl_stmt|;
block|{
name|int
name|hh
decl_stmt|,
name|mm
decl_stmt|,
name|ss
decl_stmt|,
name|sign
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
operator|||
operator|*
name|string
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|signable
condition|)
name|sign
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|string
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
operator|++
name|string
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
name|scheck
argument_list|(
name|string
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|hh
argument_list|)
operator|==
literal|1
condition|)
name|mm
operator|=
name|ss
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
name|scheck
argument_list|(
name|string
argument_list|,
literal|"%d:%d"
argument_list|)
argument_list|,
operator|&
name|hh
argument_list|,
operator|&
name|mm
argument_list|)
operator|==
literal|2
condition|)
name|ss
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|string
argument_list|,
name|scheck
argument_list|(
name|string
argument_list|,
literal|"%d:%d:%d"
argument_list|)
argument_list|,
operator|&
name|hh
argument_list|,
operator|&
name|mm
argument_list|,
operator|&
name|ss
argument_list|)
operator|!=
literal|3
condition|)
block|{
name|error
argument_list|(
name|errstring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|hh
operator|<
literal|0
operator|||
name|hh
operator|>=
name|HOURSPERDAY
operator|||
name|mm
operator|<
literal|0
operator|||
name|mm
operator|>=
name|MINSPERHOUR
operator|||
name|ss
operator|<
literal|0
operator|||
name|ss
operator|>
name|SECSPERMIN
operator|)
operator|&&
operator|!
operator|(
name|hh
operator|==
name|HOURSPERDAY
operator|&&
name|mm
operator|==
literal|0
operator|&&
name|ss
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
name|errstring
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|eitol
argument_list|(
name|sign
argument_list|)
operator|*
operator|(
name|eitol
argument_list|(
name|hh
operator|*
name|MINSPERHOUR
operator|+
name|mm
argument_list|)
operator|*
name|eitol
argument_list|(
name|SECSPERMIN
argument_list|)
operator|+
name|eitol
argument_list|(
name|ss
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|inrule
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
block|{
specifier|static
name|struct
name|rule
name|r
decl_stmt|;
if|if
condition|(
name|nfields
operator|!=
name|RULE_FIELDS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"wrong number of fields on Rule line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
index|[
name|RF_NAME
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"nameless rule"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|.
name|r_filename
operator|=
name|filename
expr_stmt|;
name|r
operator|.
name|r_linenum
operator|=
name|linenum
expr_stmt|;
name|r
operator|.
name|r_stdoff
operator|=
name|gethms
argument_list|(
name|fields
index|[
name|RF_STDOFF
index|]
argument_list|,
name|_
argument_list|(
literal|"invalid saved time"
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rulesub
argument_list|(
operator|&
name|r
argument_list|,
name|fields
index|[
name|RF_LOYEAR
index|]
argument_list|,
name|fields
index|[
name|RF_HIYEAR
index|]
argument_list|,
name|fields
index|[
name|RF_COMMAND
index|]
argument_list|,
name|fields
index|[
name|RF_MONTH
index|]
argument_list|,
name|fields
index|[
name|RF_DAY
index|]
argument_list|,
name|fields
index|[
name|RF_TOD
index|]
argument_list|)
expr_stmt|;
name|r
operator|.
name|r_name
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|RF_NAME
index|]
argument_list|)
expr_stmt|;
name|r
operator|.
name|r_abbrvar
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|RF_ABBRVAR
index|]
argument_list|)
expr_stmt|;
name|rules
operator|=
operator|(
expr|struct
name|rule
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|erealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rules
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|nrules
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|rules
argument_list|)
argument_list|)
expr_stmt|;
name|rules
index|[
name|nrules
operator|++
index|]
operator|=
name|r
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|inzone
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|nfields
operator|<
name|ZONE_MINFIELDS
operator|||
name|nfields
operator|>
name|ZONE_MAXFIELDS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"wrong number of fields on Zone line"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|fields
index|[
name|ZF_NAME
index|]
argument_list|,
name|TZDEFAULT
argument_list|)
operator|==
literal|0
operator|&&
name|lcltime
operator|!=
name|NULL
condition|)
block|{
name|buf
operator|=
name|erealloc
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|132
operator|+
name|strlen
argument_list|(
name|TZDEFAULT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"\"Zone %s\" line and -l option are mutually exclusive"
argument_list|)
argument_list|,
name|TZDEFAULT
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|fields
index|[
name|ZF_NAME
index|]
argument_list|,
name|TZDEFRULES
argument_list|)
operator|==
literal|0
operator|&&
name|psxrules
operator|!=
name|NULL
condition|)
block|{
name|buf
operator|=
name|erealloc
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|132
operator|+
name|strlen
argument_list|(
name|TZDEFRULES
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"\"Zone %s\" line and -p option are mutually exclusive"
argument_list|)
argument_list|,
name|TZDEFRULES
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nzones
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|zones
index|[
name|i
index|]
operator|.
name|z_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|zones
index|[
name|i
index|]
operator|.
name|z_name
argument_list|,
name|fields
index|[
name|ZF_NAME
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
name|erealloc
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|132
operator|+
name|strlen
argument_list|(
name|fields
index|[
name|ZF_NAME
index|]
argument_list|)
operator|+
name|strlen
argument_list|(
name|zones
index|[
name|i
index|]
operator|.
name|z_filename
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
name|_
argument_list|(
literal|"duplicate zone name %s (file \"%s\", line %d)"
argument_list|)
argument_list|,
name|fields
index|[
name|ZF_NAME
index|]
argument_list|,
name|zones
index|[
name|i
index|]
operator|.
name|z_filename
argument_list|,
name|zones
index|[
name|i
index|]
operator|.
name|z_linenum
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|inzsub
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|inzcont
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
block|{
if|if
condition|(
name|nfields
operator|<
name|ZONEC_MINFIELDS
operator|||
name|nfields
operator|>
name|ZONEC_MAXFIELDS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"wrong number of fields on Zone continuation line"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|inzsub
argument_list|(
name|fields
argument_list|,
name|nfields
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|inzsub
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|,
name|iscont
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
specifier|const
name|int
name|iscont
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|struct
name|zone
name|z
decl_stmt|;
specifier|register
name|int
name|i_gmtoff
decl_stmt|,
name|i_rule
decl_stmt|,
name|i_format
decl_stmt|;
specifier|register
name|int
name|i_untilyear
decl_stmt|,
name|i_untilmonth
decl_stmt|;
specifier|register
name|int
name|i_untilday
decl_stmt|,
name|i_untiltime
decl_stmt|;
specifier|register
name|int
name|hasuntil
decl_stmt|;
if|if
condition|(
name|iscont
condition|)
block|{
name|i_gmtoff
operator|=
name|ZFC_GMTOFF
expr_stmt|;
name|i_rule
operator|=
name|ZFC_RULE
expr_stmt|;
name|i_format
operator|=
name|ZFC_FORMAT
expr_stmt|;
name|i_untilyear
operator|=
name|ZFC_TILYEAR
expr_stmt|;
name|i_untilmonth
operator|=
name|ZFC_TILMONTH
expr_stmt|;
name|i_untilday
operator|=
name|ZFC_TILDAY
expr_stmt|;
name|i_untiltime
operator|=
name|ZFC_TILTIME
expr_stmt|;
name|z
operator|.
name|z_name
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|i_gmtoff
operator|=
name|ZF_GMTOFF
expr_stmt|;
name|i_rule
operator|=
name|ZF_RULE
expr_stmt|;
name|i_format
operator|=
name|ZF_FORMAT
expr_stmt|;
name|i_untilyear
operator|=
name|ZF_TILYEAR
expr_stmt|;
name|i_untilmonth
operator|=
name|ZF_TILMONTH
expr_stmt|;
name|i_untilday
operator|=
name|ZF_TILDAY
expr_stmt|;
name|i_untiltime
operator|=
name|ZF_TILTIME
expr_stmt|;
name|z
operator|.
name|z_name
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|ZF_NAME
index|]
argument_list|)
expr_stmt|;
block|}
name|z
operator|.
name|z_filename
operator|=
name|filename
expr_stmt|;
name|z
operator|.
name|z_linenum
operator|=
name|linenum
expr_stmt|;
name|z
operator|.
name|z_gmtoff
operator|=
name|gethms
argument_list|(
name|fields
index|[
name|i_gmtoff
index|]
argument_list|,
name|_
argument_list|(
literal|"invalid UTC offset"
argument_list|)
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|fields
index|[
name|i_format
index|]
argument_list|,
literal|'%'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|cp
operator|!=
literal|'s'
operator|||
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'%'
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid abbreviation format"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|z
operator|.
name|z_rule
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|i_rule
index|]
argument_list|)
expr_stmt|;
name|z
operator|.
name|z_format
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|i_format
index|]
argument_list|)
expr_stmt|;
name|hasuntil
operator|=
name|nfields
operator|>
name|i_untilyear
expr_stmt|;
if|if
condition|(
name|hasuntil
condition|)
block|{
name|z
operator|.
name|z_untilrule
operator|.
name|r_filename
operator|=
name|filename
expr_stmt|;
name|z
operator|.
name|z_untilrule
operator|.
name|r_linenum
operator|=
name|linenum
expr_stmt|;
name|rulesub
argument_list|(
operator|&
name|z
operator|.
name|z_untilrule
argument_list|,
name|fields
index|[
name|i_untilyear
index|]
argument_list|,
literal|"only"
argument_list|,
literal|""
argument_list|,
operator|(
name|nfields
operator|>
name|i_untilmonth
operator|)
condition|?
name|fields
index|[
name|i_untilmonth
index|]
else|:
literal|"Jan"
argument_list|,
operator|(
name|nfields
operator|>
name|i_untilday
operator|)
condition|?
name|fields
index|[
name|i_untilday
index|]
else|:
literal|"1"
argument_list|,
operator|(
name|nfields
operator|>
name|i_untiltime
operator|)
condition|?
name|fields
index|[
name|i_untiltime
index|]
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|z
operator|.
name|z_untiltime
operator|=
name|rpytime
argument_list|(
operator|&
name|z
operator|.
name|z_untilrule
argument_list|,
name|z
operator|.
name|z_untilrule
operator|.
name|r_loyear
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscont
operator|&&
name|nzones
operator|>
literal|0
operator|&&
name|z
operator|.
name|z_untiltime
operator|>
name|min_time
operator|&&
name|z
operator|.
name|z_untiltime
operator|<
name|max_time
operator|&&
name|zones
index|[
name|nzones
operator|-
literal|1
index|]
operator|.
name|z_untiltime
operator|>
name|min_time
operator|&&
name|zones
index|[
name|nzones
operator|-
literal|1
index|]
operator|.
name|z_untiltime
operator|<
name|max_time
operator|&&
name|zones
index|[
name|nzones
operator|-
literal|1
index|]
operator|.
name|z_untiltime
operator|>=
name|z
operator|.
name|z_untiltime
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"Zone continuation line end time is not after end time of previous line"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
block|}
name|zones
operator|=
operator|(
expr|struct
name|zone
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|erealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zones
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|nzones
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|zones
argument_list|)
argument_list|)
expr_stmt|;
name|zones
index|[
name|nzones
operator|++
index|]
operator|=
name|z
expr_stmt|;
comment|/* 	** If there was an UNTIL field on this line, 	** there's more information about the zone on the next line. 	*/
return|return
name|hasuntil
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|inleap
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
block|{
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|year
decl_stmt|,
name|month
decl_stmt|,
name|day
decl_stmt|;
name|long
name|dayoff
decl_stmt|,
name|tod
decl_stmt|;
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|nfields
operator|!=
name|LEAP_FIELDS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"wrong number of fields on Leap line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|dayoff
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|fields
index|[
name|LP_YEAR
index|]
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
name|scheck
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|year
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* 			 * Leapin' Lizards! 			 */
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid leaping year"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|j
operator|=
name|EPOCH_YEAR
expr_stmt|;
while|while
condition|(
name|j
operator|!=
name|year
condition|)
block|{
if|if
condition|(
name|year
operator|>
name|j
condition|)
block|{
name|i
operator|=
name|len_years
index|[
name|isleap
argument_list|(
name|j
argument_list|)
index|]
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
else|else
block|{
operator|--
name|j
expr_stmt|;
name|i
operator|=
operator|-
name|len_years
index|[
name|isleap
argument_list|(
name|j
argument_list|)
index|]
expr_stmt|;
block|}
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|fields
index|[
name|LP_MONTH
index|]
argument_list|,
name|mon_names
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid month name"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|month
operator|=
name|lp
operator|->
name|l_value
expr_stmt|;
name|j
operator|=
name|TM_JANUARY
expr_stmt|;
while|while
condition|(
name|j
operator|!=
name|month
condition|)
block|{
name|i
operator|=
name|len_months
index|[
name|isleap
argument_list|(
name|year
argument_list|)
index|]
index|[
name|j
index|]
expr_stmt|;
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
name|cp
operator|=
name|fields
index|[
name|LP_DAY
index|]
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
name|scheck
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|day
argument_list|)
operator|!=
literal|1
operator|||
name|day
operator|<=
literal|0
operator|||
name|day
operator|>
name|len_months
index|[
name|isleap
argument_list|(
name|year
argument_list|)
index|]
index|[
name|month
index|]
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid day of month"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|day
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dayoff
operator|<
literal|0
operator|&&
operator|!
name|TYPE_SIGNED
argument_list|(
name|time_t
argument_list|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"time before zero"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
operator|(
name|time_t
operator|)
name|dayoff
operator|*
name|SECSPERDAY
expr_stmt|;
comment|/* 	** Cheap overflow check. 	*/
if|if
condition|(
name|t
operator|/
name|SECSPERDAY
operator|!=
name|dayoff
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"time overflow"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|tod
operator|=
name|gethms
argument_list|(
name|fields
index|[
name|LP_TIME
index|]
argument_list|,
name|_
argument_list|(
literal|"invalid time of day"
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|cp
operator|=
name|fields
index|[
name|LP_CORR
index|]
expr_stmt|;
block|{
specifier|register
name|int
name|positive
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* infile() turns "-" into "" */
name|positive
operator|=
name|FALSE
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"--"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|positive
operator|=
name|FALSE
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"+"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|positive
operator|=
name|TRUE
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"++"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|positive
operator|=
name|TRUE
expr_stmt|;
name|count
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"illegal CORRECTION field on Leap line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|fields
index|[
name|LP_ROLL
index|]
argument_list|,
name|leap_types
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"illegal Rolling/Stationary field on Leap line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|leapadd
argument_list|(
name|tadd
argument_list|(
name|t
argument_list|,
name|tod
argument_list|)
argument_list|,
name|positive
argument_list|,
name|lp
operator|->
name|l_value
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|inlink
parameter_list|(
name|fields
parameter_list|,
name|nfields
parameter_list|)
specifier|register
name|char
modifier|*
modifier|*
specifier|const
name|fields
decl_stmt|;
specifier|const
name|int
name|nfields
decl_stmt|;
block|{
name|struct
name|link
name|l
decl_stmt|;
if|if
condition|(
name|nfields
operator|!=
name|LINK_FIELDS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"wrong number of fields on Link line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
index|[
name|LF_FROM
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"blank FROM field on Link line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|fields
index|[
name|LF_TO
index|]
operator|==
literal|'\0'
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"blank TO field on Link line"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|.
name|l_filename
operator|=
name|filename
expr_stmt|;
name|l
operator|.
name|l_linenum
operator|=
name|linenum
expr_stmt|;
name|l
operator|.
name|l_from
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|LF_FROM
index|]
argument_list|)
expr_stmt|;
name|l
operator|.
name|l_to
operator|=
name|ecpyalloc
argument_list|(
name|fields
index|[
name|LF_TO
index|]
argument_list|)
expr_stmt|;
name|links
operator|=
operator|(
expr|struct
name|link
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|erealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|links
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|nlinks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|links
argument_list|)
argument_list|)
expr_stmt|;
name|links
index|[
name|nlinks
operator|++
index|]
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rulesub
parameter_list|(
name|rp
parameter_list|,
name|loyearp
parameter_list|,
name|hiyearp
parameter_list|,
name|typep
parameter_list|,
name|monthp
parameter_list|,
name|dayp
parameter_list|,
name|timep
parameter_list|)
specifier|register
name|struct
name|rule
modifier|*
specifier|const
name|rp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|loyearp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|hiyearp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|typep
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|monthp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|dayp
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|timep
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
name|lp
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|monthp
argument_list|,
name|mon_names
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid month name"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|rp
operator|->
name|r_month
operator|=
name|lp
operator|->
name|l_value
expr_stmt|;
name|rp
operator|->
name|r_todisstd
operator|=
name|FALSE
expr_stmt|;
name|rp
operator|->
name|r_todisgmt
operator|=
name|FALSE
expr_stmt|;
name|dp
operator|=
name|ecpyalloc
argument_list|(
name|timep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dp
operator|!=
literal|'\0'
condition|)
block|{
name|ep
operator|=
name|dp
operator|+
name|strlen
argument_list|(
name|dp
argument_list|)
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|lowerit
argument_list|(
operator|*
name|ep
argument_list|)
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* Standard */
name|rp
operator|->
name|r_todisstd
operator|=
name|TRUE
expr_stmt|;
name|rp
operator|->
name|r_todisgmt
operator|=
name|FALSE
expr_stmt|;
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* Wall */
name|rp
operator|->
name|r_todisstd
operator|=
name|FALSE
expr_stmt|;
name|rp
operator|->
name|r_todisgmt
operator|=
name|FALSE
expr_stmt|;
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* Greenwich */
case|case
literal|'u'
case|:
comment|/* Universal */
case|case
literal|'z'
case|:
comment|/* Zulu */
name|rp
operator|->
name|r_todisstd
operator|=
name|TRUE
expr_stmt|;
name|rp
operator|->
name|r_todisgmt
operator|=
name|TRUE
expr_stmt|;
operator|*
name|ep
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
name|rp
operator|->
name|r_tod
operator|=
name|gethms
argument_list|(
name|dp
argument_list|,
name|_
argument_list|(
literal|"invalid time of day"
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 	** Year work. 	*/
name|cp
operator|=
name|loyearp
expr_stmt|;
name|lp
operator|=
name|byword
argument_list|(
name|cp
argument_list|,
name|begin_years
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
switch|switch
condition|(
operator|(
name|int
operator|)
name|lp
operator|->
name|l_value
condition|)
block|{
case|case
name|YR_MINIMUM
case|:
name|rp
operator|->
name|r_loyear
operator|=
name|INT_MIN
expr_stmt|;
break|break;
case|case
name|YR_MAXIMUM
case|:
name|rp
operator|->
name|r_loyear
operator|=
name|INT_MAX
expr_stmt|;
break|break;
default|default:
comment|/* "cannot happen" */
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"panic: invalid l_value %d"
argument_list|)
argument_list|,
name|lp
operator|->
name|l_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
name|scheck
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|r_loyear
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid starting year"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|noise
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|<
name|min_year_representable
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"starting year too low to be represented"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|>
name|max_year_representable
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"starting year too high to be represented"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|hiyearp
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|cp
argument_list|,
name|end_years
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
switch|switch
condition|(
operator|(
name|int
operator|)
name|lp
operator|->
name|l_value
condition|)
block|{
case|case
name|YR_MINIMUM
case|:
name|rp
operator|->
name|r_hiyear
operator|=
name|INT_MIN
expr_stmt|;
break|break;
case|case
name|YR_MAXIMUM
case|:
name|rp
operator|->
name|r_hiyear
operator|=
name|INT_MAX
expr_stmt|;
break|break;
case|case
name|YR_ONLY
case|:
name|rp
operator|->
name|r_hiyear
operator|=
name|rp
operator|->
name|r_loyear
expr_stmt|;
break|break;
default|default:
comment|/* "cannot happen" */
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"panic: invalid l_value %d"
argument_list|)
argument_list|,
name|lp
operator|->
name|l_value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
name|scheck
argument_list|(
name|cp
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|r_hiyear
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid ending year"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|noise
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|<
name|min_year_representable
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"starting year too low to be represented"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|>
name|max_year_representable
condition|)
name|warning
argument_list|(
name|_
argument_list|(
literal|"starting year too high to be represented"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|>
name|rp
operator|->
name|r_hiyear
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"starting year greater than ending year"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|typep
operator|==
literal|'\0'
condition|)
name|rp
operator|->
name|r_yrtype
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|==
name|rp
operator|->
name|r_hiyear
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"typed single year"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|rp
operator|->
name|r_yrtype
operator|=
name|ecpyalloc
argument_list|(
name|typep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|r_loyear
operator|<
name|min_year
operator|&&
name|rp
operator|->
name|r_loyear
operator|>
literal|0
condition|)
name|min_year
operator|=
name|rp
operator|->
name|r_loyear
expr_stmt|;
comment|/* 	** Day work. 	** Accept things such as: 	**	1 	**	last-Sunday 	**	Sun<=20 	**	Sun>=7 	*/
name|dp
operator|=
name|ecpyalloc
argument_list|(
name|dayp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|dp
argument_list|,
name|lasts
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOWLEQ
expr_stmt|;
name|rp
operator|->
name|r_wday
operator|=
name|lp
operator|->
name|l_value
expr_stmt|;
name|rp
operator|->
name|r_dayofmonth
operator|=
name|len_months
index|[
literal|1
index|]
index|[
name|rp
operator|->
name|r_month
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ep
operator|=
name|strchr
argument_list|(
name|dp
argument_list|,
literal|'<'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOWLEQ
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ep
operator|=
name|strchr
argument_list|(
name|dp
argument_list|,
literal|'>'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOWGEQ
expr_stmt|;
else|else
block|{
name|ep
operator|=
name|dp
expr_stmt|;
name|rp
operator|->
name|r_dycode
operator|=
name|DC_DOM
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|!=
name|DC_DOM
condition|)
block|{
operator|*
name|ep
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|++
operator|!=
literal|'='
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid day of month"
argument_list|)
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|lp
operator|=
name|byword
argument_list|(
name|dp
argument_list|,
name|wday_names
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid weekday name"
argument_list|)
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
name|rp
operator|->
name|r_wday
operator|=
name|lp
operator|->
name|l_value
expr_stmt|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|ep
argument_list|,
name|scheck
argument_list|(
name|ep
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|r_dayofmonth
argument_list|)
operator|!=
literal|1
operator|||
name|rp
operator|->
name|r_dayofmonth
operator|<=
literal|0
operator|||
operator|(
name|rp
operator|->
name|r_dayofmonth
operator|>
name|len_months
index|[
literal|1
index|]
index|[
name|rp
operator|->
name|r_month
index|]
operator|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"invalid day of month"
argument_list|)
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ifree
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert
parameter_list|(
name|val
parameter_list|,
name|buf
parameter_list|)
specifier|const
name|long
name|val
decl_stmt|;
name|char
modifier|*
specifier|const
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|shift
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|shift
operator|=
literal|24
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
operator|,
name|shift
operator|-=
literal|8
control|)
name|buf
index|[
name|i
index|]
operator|=
name|val
operator|>>
name|shift
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|puttzcode
parameter_list|(
name|val
parameter_list|,
name|fp
parameter_list|)
specifier|const
name|long
name|val
decl_stmt|;
name|FILE
modifier|*
specifier|const
name|fp
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|convert
argument_list|(
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
name|buf
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|atcomp
parameter_list|(
name|avp
parameter_list|,
name|bvp
parameter_list|)
name|void
modifier|*
name|avp
decl_stmt|;
name|void
modifier|*
name|bvp
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|attype
operator|*
operator|)
name|avp
operator|)
operator|->
name|at
operator|<
operator|(
operator|(
expr|struct
name|attype
operator|*
operator|)
name|bvp
operator|)
operator|->
name|at
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
expr|struct
name|attype
operator|*
operator|)
name|avp
operator|)
operator|->
name|at
operator|>
operator|(
operator|(
expr|struct
name|attype
operator|*
operator|)
name|bvp
operator|)
operator|->
name|at
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|writezone
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|static
name|char
modifier|*
name|fullname
decl_stmt|;
specifier|static
name|struct
name|tzhead
name|tzh
decl_stmt|;
name|time_t
name|ats
index|[
name|TZ_MAX_TIMES
index|]
decl_stmt|;
name|unsigned
name|char
name|types
index|[
name|TZ_MAX_TIMES
index|]
decl_stmt|;
comment|/* 	** Sort. 	*/
if|if
condition|(
name|timecnt
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|qsort
argument_list|(
operator|(
name|void
operator|*
operator|)
name|attypes
argument_list|,
operator|(
name|size_t
operator|)
name|timecnt
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
expr|*
name|attypes
argument_list|,
name|atcomp
argument_list|)
expr_stmt|;
comment|/* 	** Optimize. 	*/
block|{
name|int
name|fromi
decl_stmt|;
name|int
name|toi
decl_stmt|;
name|toi
operator|=
literal|0
expr_stmt|;
name|fromi
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fromi
operator|<
name|timecnt
operator|&&
name|attypes
index|[
name|fromi
index|]
operator|.
name|at
operator|<
name|min_time
condition|)
operator|++
name|fromi
expr_stmt|;
if|if
condition|(
name|isdsts
index|[
literal|0
index|]
operator|==
literal|0
condition|)
while|while
condition|(
name|fromi
operator|<
name|timecnt
operator|&&
name|attypes
index|[
name|fromi
index|]
operator|.
name|type
operator|==
literal|0
condition|)
operator|++
name|fromi
expr_stmt|;
comment|/* handled by default rule */
for|for
control|(
init|;
name|fromi
operator|<
name|timecnt
condition|;
operator|++
name|fromi
control|)
block|{
if|if
condition|(
name|toi
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|attypes
index|[
name|fromi
index|]
operator|.
name|at
operator|+
name|gmtoffs
index|[
name|attypes
index|[
name|toi
operator|-
literal|1
index|]
operator|.
name|type
index|]
operator|)
operator|<=
operator|(
name|attypes
index|[
name|toi
operator|-
literal|1
index|]
operator|.
name|at
operator|+
name|gmtoffs
index|[
name|toi
operator|==
literal|1
condition|?
literal|0
else|:
name|attypes
index|[
name|toi
operator|-
literal|2
index|]
operator|.
name|type
index|]
operator|)
operator|)
condition|)
block|{
name|attypes
index|[
name|toi
operator|-
literal|1
index|]
operator|.
name|type
operator|=
name|attypes
index|[
name|fromi
index|]
operator|.
name|type
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|toi
operator|==
literal|0
operator|||
name|attypes
index|[
name|toi
operator|-
literal|1
index|]
operator|.
name|type
operator|!=
name|attypes
index|[
name|fromi
index|]
operator|.
name|type
condition|)
name|attypes
index|[
name|toi
operator|++
index|]
operator|=
name|attypes
index|[
name|fromi
index|]
expr_stmt|;
block|}
name|timecnt
operator|=
name|toi
expr_stmt|;
block|}
comment|/* 	** Transfer. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timecnt
condition|;
operator|++
name|i
control|)
block|{
name|ats
index|[
name|i
index|]
operator|=
name|attypes
index|[
name|i
index|]
operator|.
name|at
expr_stmt|;
name|types
index|[
name|i
index|]
operator|=
name|attypes
index|[
name|i
index|]
operator|.
name|type
expr_stmt|;
block|}
name|fullname
operator|=
name|erealloc
argument_list|(
name|fullname
argument_list|,
call|(
name|int
call|)
argument_list|(
name|strlen
argument_list|(
name|directory
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|fullname
argument_list|,
literal|"%s/%s"
argument_list|,
name|directory
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Remove old file, if any, to snap links. 	 */
if|if
condition|(
operator|!
name|itsdir
argument_list|(
name|fullname
argument_list|)
operator|&&
name|remove
argument_list|(
name|fullname
argument_list|)
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"can't remove %s"
argument_list|)
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
literal|"wb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|mkdirs
argument_list|(
name|fullname
argument_list|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|fullname
argument_list|,
literal|"wb"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"can't create %s"
argument_list|)
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
block|}
name|convert
argument_list|(
name|eitol
argument_list|(
name|typecnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_ttisgmtcnt
argument_list|)
expr_stmt|;
name|convert
argument_list|(
name|eitol
argument_list|(
name|typecnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_ttisstdcnt
argument_list|)
expr_stmt|;
name|convert
argument_list|(
name|eitol
argument_list|(
name|leapcnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_leapcnt
argument_list|)
expr_stmt|;
name|convert
argument_list|(
name|eitol
argument_list|(
name|timecnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_timecnt
argument_list|)
expr_stmt|;
name|convert
argument_list|(
name|eitol
argument_list|(
name|typecnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_typecnt
argument_list|)
expr_stmt|;
name|convert
argument_list|(
name|eitol
argument_list|(
name|charcnt
argument_list|)
argument_list|,
name|tzh
operator|.
name|tzh_charcnt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|tzh
operator|.
name|tzh_magic
argument_list|,
name|TZ_MAGIC
argument_list|,
sizeof|sizeof
name|tzh
operator|.
name|tzh_magic
argument_list|)
expr_stmt|;
define|#
directive|define
name|DO
parameter_list|(
name|field
parameter_list|)
value|(void) fwrite((void *) tzh.field, (size_t) sizeof tzh.field, (size_t) 1, fp)
name|DO
argument_list|(
name|tzh_magic
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_reserved
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_ttisgmtcnt
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_ttisstdcnt
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_leapcnt
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_timecnt
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_typecnt
argument_list|)
expr_stmt|;
name|DO
argument_list|(
name|tzh_charcnt
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|DO
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|timecnt
condition|;
operator|++
name|i
control|)
block|{
name|j
operator|=
name|leapcnt
expr_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
if|if
condition|(
name|ats
index|[
name|i
index|]
operator|>=
name|trans
index|[
name|j
index|]
condition|)
block|{
name|ats
index|[
name|i
index|]
operator|=
name|tadd
argument_list|(
name|ats
index|[
name|i
index|]
argument_list|,
name|corr
index|[
name|j
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|puttzcode
argument_list|(
operator|(
name|long
operator|)
name|ats
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timecnt
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|types
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
name|types
index|[
literal|0
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|timecnt
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
block|{
name|puttzcode
argument_list|(
operator|(
name|long
operator|)
name|gmtoffs
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|isdsts
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|abbrinds
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|charcnt
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|fwrite
argument_list|(
operator|(
name|void
operator|*
operator|)
name|chars
argument_list|,
operator|(
name|size_t
operator|)
sizeof|sizeof
name|chars
index|[
literal|0
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|charcnt
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leapcnt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|roll
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|timecnt
operator|==
literal|0
operator|||
name|trans
index|[
name|i
index|]
operator|<
name|ats
index|[
literal|0
index|]
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdsts
index|[
name|j
index|]
condition|)
if|if
condition|(
operator|++
name|j
operator|>=
name|typecnt
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|j
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|timecnt
operator|&&
name|trans
index|[
name|i
index|]
operator|>=
name|ats
index|[
name|j
index|]
condition|)
operator|++
name|j
expr_stmt|;
name|j
operator|=
name|types
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|puttzcode
argument_list|(
operator|(
name|long
operator|)
name|tadd
argument_list|(
name|trans
index|[
name|i
index|]
argument_list|,
operator|-
name|gmtoffs
index|[
name|j
index|]
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|puttzcode
argument_list|(
operator|(
name|long
operator|)
name|trans
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|puttzcode
argument_list|(
operator|(
name|long
operator|)
name|corr
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
operator|(
name|void
operator|)
name|putc
argument_list|(
name|ttisstds
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
operator|(
name|void
operator|)
name|putc
argument_list|(
name|ttisgmts
index|[
name|i
index|]
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
operator|||
name|fclose
argument_list|(
name|fp
argument_list|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"error writing %s"
argument_list|)
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|fullname
argument_list|,
name|mflag
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"cannot change mode of %s to %03o"
argument_list|)
argument_list|,
name|fullname
argument_list|,
operator|(
name|unsigned
operator|)
name|mflag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uflag
operator|!=
operator|(
name|uid_t
operator|)
operator|-
literal|1
operator|||
name|gflag
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
operator|)
operator|&&
name|chown
argument_list|(
name|fullname
argument_list|,
name|uflag
argument_list|,
name|gflag
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"cannot change ownership of %s"
argument_list|)
argument_list|,
name|fullname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|doabbr
parameter_list|(
name|abbr
parameter_list|,
name|format
parameter_list|,
name|letters
parameter_list|,
name|isdst
parameter_list|)
name|char
modifier|*
specifier|const
name|abbr
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|format
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|letters
decl_stmt|;
specifier|const
name|int
name|isdst
decl_stmt|;
block|{
if|if
condition|(
name|strchr
argument_list|(
name|format
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|letters
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|abbr
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|abbr
argument_list|,
name|format
argument_list|,
name|letters
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdst
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|abbr
argument_list|,
name|strchr
argument_list|(
name|format
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|abbr
argument_list|,
name|format
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|abbr
argument_list|,
literal|'/'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|outzone
parameter_list|(
name|zpfirst
parameter_list|,
name|zonecount
parameter_list|)
specifier|const
name|struct
name|zone
modifier|*
specifier|const
name|zpfirst
decl_stmt|;
specifier|const
name|int
name|zonecount
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|zone
modifier|*
name|zp
decl_stmt|;
specifier|register
name|struct
name|rule
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|usestart
decl_stmt|,
name|useuntil
decl_stmt|;
specifier|register
name|time_t
name|starttime
decl_stmt|,
name|untiltime
decl_stmt|;
specifier|register
name|long
name|gmtoff
decl_stmt|;
specifier|register
name|long
name|stdoff
decl_stmt|;
specifier|register
name|int
name|year
decl_stmt|;
specifier|register
name|long
name|startoff
decl_stmt|;
specifier|register
name|int
name|startttisstd
decl_stmt|;
specifier|register
name|int
name|startttisgmt
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
name|char
name|startbuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|INITIALIZE
argument_list|(
name|untiltime
argument_list|)
expr_stmt|;
name|INITIALIZE
argument_list|(
name|starttime
argument_list|)
expr_stmt|;
comment|/* 	** Now. . .finally. . .generate some useful data! 	*/
name|timecnt
operator|=
literal|0
expr_stmt|;
name|typecnt
operator|=
literal|0
expr_stmt|;
name|charcnt
operator|=
literal|0
expr_stmt|;
comment|/* 	** A guess that may well be corrected later. 	*/
name|stdoff
operator|=
literal|0
expr_stmt|;
comment|/* 	** Thanks to Earl Chew (earl@dnd.icp.nec.com.au) 	** for noting the need to unconditionally initialize startttisstd. 	*/
name|startttisstd
operator|=
name|FALSE
expr_stmt|;
name|startttisgmt
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zonecount
condition|;
operator|++
name|i
control|)
block|{
name|zp
operator|=
operator|&
name|zpfirst
index|[
name|i
index|]
expr_stmt|;
name|usestart
operator|=
name|i
operator|>
literal|0
operator|&&
operator|(
name|zp
operator|-
literal|1
operator|)
operator|->
name|z_untiltime
operator|>
name|min_time
expr_stmt|;
name|useuntil
operator|=
name|i
operator|<
operator|(
name|zonecount
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|useuntil
operator|&&
name|zp
operator|->
name|z_untiltime
operator|<=
name|min_time
condition|)
continue|continue;
name|gmtoff
operator|=
name|zp
operator|->
name|z_gmtoff
expr_stmt|;
name|eat
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|)
expr_stmt|;
operator|*
name|startbuf
operator|=
literal|'\0'
expr_stmt|;
name|startoff
operator|=
name|zp
operator|->
name|z_gmtoff
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_nrules
operator|==
literal|0
condition|)
block|{
name|stdoff
operator|=
name|zp
operator|->
name|z_stdoff
expr_stmt|;
name|doabbr
argument_list|(
name|startbuf
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|stdoff
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|addtype
argument_list|(
name|oadd
argument_list|(
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|stdoff
argument_list|)
argument_list|,
name|startbuf
argument_list|,
name|stdoff
operator|!=
literal|0
argument_list|,
name|startttisstd
argument_list|,
name|startttisgmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|usestart
condition|)
block|{
name|addtt
argument_list|(
name|starttime
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|usestart
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stdoff
operator|!=
literal|0
condition|)
name|addtt
argument_list|(
name|min_time
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|year
operator|=
name|min_year
init|;
name|year
operator|<=
name|max_year
condition|;
operator|++
name|year
control|)
block|{
if|if
condition|(
name|useuntil
operator|&&
name|year
operator|>
name|zp
operator|->
name|z_untilrule
operator|.
name|r_hiyear
condition|)
break|break;
comment|/* 			** Mark which rules to do in the current year. 			** For those to do, calculate rpytime(rp, year); 			*/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zp
operator|->
name|z_nrules
condition|;
operator|++
name|j
control|)
block|{
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|j
index|]
expr_stmt|;
name|eats
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|,
name|rp
operator|->
name|r_filename
argument_list|,
name|rp
operator|->
name|r_linenum
argument_list|)
expr_stmt|;
name|rp
operator|->
name|r_todo
operator|=
name|year
operator|>=
name|rp
operator|->
name|r_loyear
operator|&&
name|year
operator|<=
name|rp
operator|->
name|r_hiyear
operator|&&
name|yearistype
argument_list|(
name|year
argument_list|,
name|rp
operator|->
name|r_yrtype
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_todo
condition|)
name|rp
operator|->
name|r_temp
operator|=
name|rpytime
argument_list|(
name|rp
argument_list|,
name|year
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|register
name|int
name|k
decl_stmt|;
specifier|register
name|time_t
name|jtime
decl_stmt|,
name|ktime
decl_stmt|;
specifier|register
name|long
name|offset
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|INITIALIZE
argument_list|(
name|ktime
argument_list|)
expr_stmt|;
if|if
condition|(
name|useuntil
condition|)
block|{
comment|/* 					** Turn untiltime into UTC 					** assuming the current gmtoff and 					** stdoff values. 					*/
name|untiltime
operator|=
name|zp
operator|->
name|z_untiltime
expr_stmt|;
if|if
condition|(
operator|!
name|zp
operator|->
name|z_untilrule
operator|.
name|r_todisgmt
condition|)
name|untiltime
operator|=
name|tadd
argument_list|(
name|untiltime
argument_list|,
operator|-
name|gmtoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zp
operator|->
name|z_untilrule
operator|.
name|r_todisstd
condition|)
name|untiltime
operator|=
name|tadd
argument_list|(
name|untiltime
argument_list|,
operator|-
name|stdoff
argument_list|)
expr_stmt|;
block|}
comment|/* 				** Find the rule (of those to do, if any) 				** that takes effect earliest in the year. 				*/
name|k
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zp
operator|->
name|z_nrules
condition|;
operator|++
name|j
control|)
block|{
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rp
operator|->
name|r_todo
condition|)
continue|continue;
name|eats
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|,
name|rp
operator|->
name|r_filename
argument_list|,
name|rp
operator|->
name|r_linenum
argument_list|)
expr_stmt|;
name|offset
operator|=
name|rp
operator|->
name|r_todisgmt
condition|?
literal|0
else|:
name|gmtoff
expr_stmt|;
if|if
condition|(
operator|!
name|rp
operator|->
name|r_todisstd
condition|)
name|offset
operator|=
name|oadd
argument_list|(
name|offset
argument_list|,
name|stdoff
argument_list|)
expr_stmt|;
name|jtime
operator|=
name|rp
operator|->
name|r_temp
expr_stmt|;
if|if
condition|(
name|jtime
operator|==
name|min_time
operator|||
name|jtime
operator|==
name|max_time
condition|)
continue|continue;
name|jtime
operator|=
name|tadd
argument_list|(
name|jtime
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|0
operator|||
name|jtime
operator|<
name|ktime
condition|)
block|{
name|k
operator|=
name|j
expr_stmt|;
name|ktime
operator|=
name|jtime
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
operator|<
literal|0
condition|)
break|break;
comment|/* go on to next year */
name|rp
operator|=
operator|&
name|zp
operator|->
name|z_rules
index|[
name|k
index|]
expr_stmt|;
name|rp
operator|->
name|r_todo
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|useuntil
operator|&&
name|ktime
operator|>=
name|untiltime
condition|)
break|break;
name|stdoff
operator|=
name|rp
operator|->
name|r_stdoff
expr_stmt|;
if|if
condition|(
name|usestart
operator|&&
name|ktime
operator|==
name|starttime
condition|)
name|usestart
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|usestart
condition|)
block|{
if|if
condition|(
name|ktime
operator|<
name|starttime
condition|)
block|{
name|startoff
operator|=
name|oadd
argument_list|(
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|stdoff
argument_list|)
expr_stmt|;
name|doabbr
argument_list|(
name|startbuf
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
name|rp
operator|->
name|r_abbrvar
argument_list|,
name|rp
operator|->
name|r_stdoff
operator|!=
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|startbuf
operator|==
literal|'\0'
operator|&&
name|startoff
operator|==
name|oadd
argument_list|(
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|stdoff
argument_list|)
condition|)
block|{
name|doabbr
argument_list|(
name|startbuf
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
name|rp
operator|->
name|r_abbrvar
argument_list|,
name|rp
operator|->
name|r_stdoff
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|eats
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|,
name|rp
operator|->
name|r_filename
argument_list|,
name|rp
operator|->
name|r_linenum
argument_list|)
expr_stmt|;
name|doabbr
argument_list|(
name|buf
argument_list|,
name|zp
operator|->
name|z_format
argument_list|,
name|rp
operator|->
name|r_abbrvar
argument_list|,
name|rp
operator|->
name|r_stdoff
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|oadd
argument_list|(
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|rp
operator|->
name|r_stdoff
argument_list|)
expr_stmt|;
name|type
operator|=
name|addtype
argument_list|(
name|offset
argument_list|,
name|buf
argument_list|,
name|rp
operator|->
name|r_stdoff
operator|!=
literal|0
argument_list|,
name|rp
operator|->
name|r_todisstd
argument_list|,
name|rp
operator|->
name|r_todisgmt
argument_list|)
expr_stmt|;
name|addtt
argument_list|(
name|ktime
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usestart
condition|)
block|{
if|if
condition|(
operator|*
name|startbuf
operator|==
literal|'\0'
operator|&&
name|zp
operator|->
name|z_format
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
name|zp
operator|->
name|z_format
argument_list|,
literal|'%'
argument_list|)
operator|==
name|NULL
operator|&&
name|strchr
argument_list|(
name|zp
operator|->
name|z_format
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|startbuf
argument_list|,
name|zp
operator|->
name|z_format
argument_list|)
expr_stmt|;
name|eat
argument_list|(
name|zp
operator|->
name|z_filename
argument_list|,
name|zp
operator|->
name|z_linenum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|startbuf
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
name|_
argument_list|(
literal|"can't determine time zone abbreviation to use just after until time"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addtt
argument_list|(
name|starttime
argument_list|,
name|addtype
argument_list|(
name|startoff
argument_list|,
name|startbuf
argument_list|,
name|startoff
operator|!=
name|zp
operator|->
name|z_gmtoff
argument_list|,
name|startttisstd
argument_list|,
name|startttisgmt
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		** Now we may get to set starttime for the next zone line. 		*/
if|if
condition|(
name|useuntil
condition|)
block|{
name|startttisstd
operator|=
name|zp
operator|->
name|z_untilrule
operator|.
name|r_todisstd
expr_stmt|;
name|startttisgmt
operator|=
name|zp
operator|->
name|z_untilrule
operator|.
name|r_todisgmt
expr_stmt|;
name|starttime
operator|=
name|zp
operator|->
name|z_untiltime
expr_stmt|;
if|if
condition|(
operator|!
name|startttisstd
condition|)
name|starttime
operator|=
name|tadd
argument_list|(
name|starttime
argument_list|,
operator|-
name|stdoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|startttisgmt
condition|)
name|starttime
operator|=
name|tadd
argument_list|(
name|starttime
argument_list|,
operator|-
name|gmtoff
argument_list|)
expr_stmt|;
block|}
block|}
name|writezone
argument_list|(
name|zpfirst
operator|->
name|z_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addtt
parameter_list|(
name|starttime
parameter_list|,
name|type
parameter_list|)
specifier|const
name|time_t
name|starttime
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
if|if
condition|(
name|starttime
operator|<=
name|min_time
operator|||
operator|(
name|timecnt
operator|==
literal|1
operator|&&
name|attypes
index|[
literal|0
index|]
operator|.
name|at
operator|<
name|min_time
operator|)
condition|)
block|{
name|gmtoffs
index|[
literal|0
index|]
operator|=
name|gmtoffs
index|[
name|type
index|]
expr_stmt|;
name|isdsts
index|[
literal|0
index|]
operator|=
name|isdsts
index|[
name|type
index|]
expr_stmt|;
name|ttisstds
index|[
literal|0
index|]
operator|=
name|ttisstds
index|[
name|type
index|]
expr_stmt|;
name|ttisgmts
index|[
literal|0
index|]
operator|=
name|ttisgmts
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|abbrinds
index|[
name|type
index|]
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|chars
argument_list|,
operator|&
name|chars
index|[
name|abbrinds
index|[
name|type
index|]
index|]
argument_list|)
expr_stmt|;
name|abbrinds
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|charcnt
operator|=
name|strlen
argument_list|(
name|chars
argument_list|)
operator|+
literal|1
expr_stmt|;
name|typecnt
operator|=
literal|1
expr_stmt|;
name|timecnt
operator|=
literal|0
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|timecnt
operator|>=
name|TZ_MAX_TIMES
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many transitions?!"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|attypes
index|[
name|timecnt
index|]
operator|.
name|at
operator|=
name|starttime
expr_stmt|;
name|attypes
index|[
name|timecnt
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
operator|++
name|timecnt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|addtype
parameter_list|(
name|gmtoff
parameter_list|,
name|abbr
parameter_list|,
name|isdst
parameter_list|,
name|ttisstd
parameter_list|,
name|ttisgmt
parameter_list|)
specifier|const
name|long
name|gmtoff
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|abbr
decl_stmt|;
specifier|const
name|int
name|isdst
decl_stmt|;
specifier|const
name|int
name|ttisstd
decl_stmt|;
specifier|const
name|int
name|ttisgmt
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|isdst
operator|!=
name|TRUE
operator|&&
name|isdst
operator|!=
name|FALSE
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"internal error - addtype called with bad isdst"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttisstd
operator|!=
name|TRUE
operator|&&
name|ttisstd
operator|!=
name|FALSE
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"internal error - addtype called with bad ttisstd"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttisgmt
operator|!=
name|TRUE
operator|&&
name|ttisgmt
operator|!=
name|FALSE
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"internal error - addtype called with bad ttisgmt"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
comment|/* 	** See if there's already an entry for this zone type. 	** If so, just return its index. 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|typecnt
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|gmtoff
operator|==
name|gmtoffs
index|[
name|i
index|]
operator|&&
name|isdst
operator|==
name|isdsts
index|[
name|i
index|]
operator|&&
name|strcmp
argument_list|(
name|abbr
argument_list|,
operator|&
name|chars
index|[
name|abbrinds
index|[
name|i
index|]
index|]
argument_list|)
operator|==
literal|0
operator|&&
name|ttisstd
operator|==
name|ttisstds
index|[
name|i
index|]
operator|&&
name|ttisgmt
operator|==
name|ttisgmts
index|[
name|i
index|]
condition|)
return|return
name|i
return|;
block|}
comment|/* 	** There isn't one; add a new one, unless there are already too 	** many. 	*/
if|if
condition|(
name|typecnt
operator|>=
name|TZ_MAX_TYPES
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many local time types"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
name|gmtoffs
index|[
name|i
index|]
operator|=
name|gmtoff
expr_stmt|;
name|isdsts
index|[
name|i
index|]
operator|=
name|isdst
expr_stmt|;
name|ttisstds
index|[
name|i
index|]
operator|=
name|ttisstd
expr_stmt|;
name|ttisgmts
index|[
name|i
index|]
operator|=
name|ttisgmt
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|charcnt
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|chars
index|[
name|j
index|]
argument_list|,
name|abbr
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|charcnt
condition|)
name|newabbr
argument_list|(
name|abbr
argument_list|)
expr_stmt|;
name|abbrinds
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
operator|++
name|typecnt
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|leapadd
parameter_list|(
name|t
parameter_list|,
name|positive
parameter_list|,
name|rolling
parameter_list|,
name|count
parameter_list|)
specifier|const
name|time_t
name|t
decl_stmt|;
specifier|const
name|int
name|positive
decl_stmt|;
specifier|const
name|int
name|rolling
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|leapcnt
operator|+
operator|(
name|positive
condition|?
name|count
else|:
literal|1
operator|)
operator|>
name|TZ_MAX_LEAPS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many leap seconds"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leapcnt
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|t
operator|<=
name|trans
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|t
operator|==
name|trans
index|[
name|i
index|]
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"repeated leap second moment"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
do|do
block|{
for|for
control|(
name|j
operator|=
name|leapcnt
init|;
name|j
operator|>
name|i
condition|;
operator|--
name|j
control|)
block|{
name|trans
index|[
name|j
index|]
operator|=
name|trans
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|corr
index|[
name|j
index|]
operator|=
name|corr
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|roll
index|[
name|j
index|]
operator|=
name|roll
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|trans
index|[
name|i
index|]
operator|=
name|t
expr_stmt|;
name|corr
index|[
name|i
index|]
operator|=
name|positive
condition|?
literal|1L
else|:
name|eitol
argument_list|(
operator|-
name|count
argument_list|)
expr_stmt|;
name|roll
index|[
name|i
index|]
operator|=
name|rolling
expr_stmt|;
operator|++
name|leapcnt
expr_stmt|;
block|}
do|while
condition|(
name|positive
operator|&&
operator|--
name|count
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|adjleap
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|last
init|=
literal|0
decl_stmt|;
comment|/* 	** propagate leap seconds forward 	*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|leapcnt
condition|;
operator|++
name|i
control|)
block|{
name|trans
index|[
name|i
index|]
operator|=
name|tadd
argument_list|(
name|trans
index|[
name|i
index|]
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
name|corr
index|[
name|i
index|]
operator|+=
name|last
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|yearistype
parameter_list|(
name|year
parameter_list|,
name|type
parameter_list|)
specifier|const
name|int
name|year
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|const
name|type
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
operator|*
name|type
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
name|buf
operator|=
name|erealloc
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|132
operator|+
name|strlen
argument_list|(
name|yitcommand
argument_list|)
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s %d %s"
argument_list|,
name|yitcommand
argument_list|,
name|year
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|result
operator|=
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|result
operator|==
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
return|return
name|FALSE
return|;
name|error
argument_list|(
name|_
argument_list|(
literal|"wild result from command execution"
argument_list|)
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
name|_
argument_list|(
literal|"command was '%s', result was %d"
argument_list|)
argument_list|,
name|buf
argument_list|,
name|result
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lowerit
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
name|a
operator|=
operator|(
name|unsigned
name|char
operator|)
name|a
expr_stmt|;
return|return
operator|(
name|isascii
argument_list|(
name|a
argument_list|)
operator|&&
name|isupper
argument_list|(
name|a
argument_list|)
operator|)
condition|?
name|tolower
argument_list|(
name|a
argument_list|)
else|:
name|a
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ciequal
parameter_list|(
name|ap
parameter_list|,
name|bp
parameter_list|)
comment|/* case-insensitive equality */
specifier|register
specifier|const
name|char
modifier|*
name|ap
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|bp
decl_stmt|;
block|{
while|while
condition|(
name|lowerit
argument_list|(
operator|*
name|ap
argument_list|)
operator|==
name|lowerit
argument_list|(
operator|*
name|bp
operator|++
argument_list|)
condition|)
if|if
condition|(
operator|*
name|ap
operator|++
operator|==
literal|'\0'
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|itsabbr
parameter_list|(
name|abbr
parameter_list|,
name|word
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|abbr
decl_stmt|;
specifier|register
specifier|const
name|char
modifier|*
name|word
decl_stmt|;
block|{
if|if
condition|(
name|lowerit
argument_list|(
operator|*
name|abbr
argument_list|)
operator|!=
name|lowerit
argument_list|(
operator|*
name|word
argument_list|)
condition|)
return|return
name|FALSE
return|;
operator|++
name|word
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|abbr
operator|!=
literal|'\0'
condition|)
do|do
block|{
if|if
condition|(
operator|*
name|word
operator|==
literal|'\0'
condition|)
return|return
name|FALSE
return|;
block|}
do|while
condition|(
name|lowerit
argument_list|(
operator|*
name|word
operator|++
argument_list|)
operator|!=
name|lowerit
argument_list|(
operator|*
name|abbr
argument_list|)
condition|)
do|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|lookup
modifier|*
name|byword
parameter_list|(
name|word
parameter_list|,
name|table
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
specifier|const
name|word
decl_stmt|;
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
specifier|const
name|table
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
name|foundlp
decl_stmt|;
specifier|register
specifier|const
name|struct
name|lookup
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|word
operator|==
name|NULL
operator|||
name|table
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* 	** Look for exact match. 	*/
for|for
control|(
name|lp
operator|=
name|table
init|;
name|lp
operator|->
name|l_word
operator|!=
name|NULL
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|ciequal
argument_list|(
name|word
argument_list|,
name|lp
operator|->
name|l_word
argument_list|)
condition|)
return|return
name|lp
return|;
comment|/* 	** Look for inexact match. 	*/
name|foundlp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|table
init|;
name|lp
operator|->
name|l_word
operator|!=
name|NULL
condition|;
operator|++
name|lp
control|)
if|if
condition|(
name|itsabbr
argument_list|(
name|word
argument_list|,
name|lp
operator|->
name|l_word
argument_list|)
condition|)
block|{
if|if
condition|(
name|foundlp
operator|==
name|NULL
condition|)
name|foundlp
operator|=
name|lp
expr_stmt|;
else|else
return|return
name|NULL
return|;
comment|/* multiple inexact matches */
block|}
return|return
name|foundlp
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|getfields
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|array
decl_stmt|;
specifier|register
name|int
name|nsubs
decl_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|array
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|emalloc
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|nsubs
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
operator|||
operator|*
name|cp
operator|==
literal|'#'
condition|)
break|break;
name|array
index|[
name|nsubs
operator|++
index|]
operator|=
name|dp
operator|=
name|cp
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|dp
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'"'
condition|)
operator|++
name|dp
expr_stmt|;
else|else
while|while
condition|(
operator|(
operator|*
name|dp
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'"'
condition|)
if|if
condition|(
operator|*
name|dp
operator|!=
literal|'\0'
condition|)
operator|++
name|dp
expr_stmt|;
else|else
name|error
argument_list|(
name|_
argument_list|(
literal|"odd number of quotation marks"
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp
operator|!=
literal|'#'
operator|&&
operator|(
operator|!
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
operator|)
condition|)
do|;
if|if
condition|(
name|isascii
argument_list|(
operator|*
name|cp
argument_list|)
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
block|}
name|array
index|[
name|nsubs
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|array
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|oadd
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|const
name|long
name|t1
decl_stmt|;
specifier|const
name|long
name|t2
decl_stmt|;
block|{
specifier|register
name|long
name|t
decl_stmt|;
name|t
operator|=
name|t1
operator|+
name|t2
expr_stmt|;
if|if
condition|(
operator|(
name|t2
operator|>
literal|0
operator|&&
name|t
operator|<=
name|t1
operator|)
operator|||
operator|(
name|t2
operator|<
literal|0
operator|&&
name|t
operator|>=
name|t1
operator|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"time overflow"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|tadd
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|const
name|time_t
name|t1
decl_stmt|;
specifier|const
name|long
name|t2
decl_stmt|;
block|{
specifier|register
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|max_time
operator|&&
name|t2
operator|>
literal|0
condition|)
return|return
name|max_time
return|;
if|if
condition|(
name|t1
operator|==
name|min_time
operator|&&
name|t2
operator|<
literal|0
condition|)
return|return
name|min_time
return|;
name|t
operator|=
name|t1
operator|+
name|t2
expr_stmt|;
if|if
condition|(
operator|(
name|t2
operator|>
literal|0
operator|&&
name|t
operator|<=
name|t1
operator|)
operator|||
operator|(
name|t2
operator|<
literal|0
operator|&&
name|t
operator|>=
name|t1
operator|)
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"time overflow"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* ** Given a rule, and a year, compute the date - in seconds since January 1, ** 1970, 00:00 LOCAL time - in that year that the rule refers to. */
end_comment

begin_function
specifier|static
name|time_t
name|rpytime
parameter_list|(
name|rp
parameter_list|,
name|wantedy
parameter_list|)
specifier|register
specifier|const
name|struct
name|rule
modifier|*
specifier|const
name|rp
decl_stmt|;
specifier|register
specifier|const
name|int
name|wantedy
decl_stmt|;
block|{
specifier|register
name|int
name|y
decl_stmt|,
name|m
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|long
name|dayoff
decl_stmt|;
comment|/* with a nod to Margaret O. */
specifier|register
name|time_t
name|t
decl_stmt|;
if|if
condition|(
name|wantedy
operator|==
name|INT_MIN
condition|)
return|return
name|min_time
return|;
if|if
condition|(
name|wantedy
operator|==
name|INT_MAX
condition|)
return|return
name|max_time
return|;
name|dayoff
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|TM_JANUARY
expr_stmt|;
name|y
operator|=
name|EPOCH_YEAR
expr_stmt|;
while|while
condition|(
name|wantedy
operator|!=
name|y
condition|)
block|{
if|if
condition|(
name|wantedy
operator|>
name|y
condition|)
block|{
name|i
operator|=
name|len_years
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
expr_stmt|;
operator|++
name|y
expr_stmt|;
block|}
else|else
block|{
operator|--
name|y
expr_stmt|;
name|i
operator|=
operator|-
name|len_years
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
expr_stmt|;
block|}
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|m
operator|!=
name|rp
operator|->
name|r_month
condition|)
block|{
name|i
operator|=
name|len_months
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
index|[
name|m
index|]
expr_stmt|;
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|m
expr_stmt|;
block|}
name|i
operator|=
name|rp
operator|->
name|r_dayofmonth
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|TM_FEBRUARY
operator|&&
name|i
operator|==
literal|29
operator|&&
operator|!
name|isleap
argument_list|(
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWLEQ
condition|)
operator|--
name|i
expr_stmt|;
else|else
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"use of 2/29 in non leap-year"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
operator|--
name|i
expr_stmt|;
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
name|eitol
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWGEQ
operator|||
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWLEQ
condition|)
block|{
specifier|register
name|long
name|wday
decl_stmt|;
define|#
directive|define
name|LDAYSPERWEEK
value|((long) DAYSPERWEEK)
name|wday
operator|=
name|eitol
argument_list|(
name|EPOCH_WDAY
argument_list|)
expr_stmt|;
comment|/* 		** Don't trust mod of negative numbers. 		*/
if|if
condition|(
name|dayoff
operator|>=
literal|0
condition|)
name|wday
operator|=
operator|(
name|wday
operator|+
name|dayoff
operator|)
operator|%
name|LDAYSPERWEEK
expr_stmt|;
else|else
block|{
name|wday
operator|-=
operator|(
operator|(
operator|-
name|dayoff
operator|)
operator|%
name|LDAYSPERWEEK
operator|)
expr_stmt|;
if|if
condition|(
name|wday
operator|<
literal|0
condition|)
name|wday
operator|+=
name|LDAYSPERWEEK
expr_stmt|;
block|}
while|while
condition|(
name|wday
operator|!=
name|eitol
argument_list|(
name|rp
operator|->
name|r_wday
argument_list|)
condition|)
if|if
condition|(
name|rp
operator|->
name|r_dycode
operator|==
name|DC_DOWGEQ
condition|)
block|{
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
operator|(
name|long
operator|)
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wday
operator|>=
name|LDAYSPERWEEK
condition|)
name|wday
operator|=
literal|0
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
else|else
block|{
name|dayoff
operator|=
name|oadd
argument_list|(
name|dayoff
argument_list|,
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|wday
operator|<
literal|0
condition|)
name|wday
operator|=
name|LDAYSPERWEEK
operator|-
literal|1
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|len_months
index|[
name|isleap
argument_list|(
name|y
argument_list|)
index|]
index|[
name|m
index|]
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"no day in month matches rule"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dayoff
operator|<
literal|0
operator|&&
operator|!
name|TYPE_SIGNED
argument_list|(
name|time_t
argument_list|)
condition|)
return|return
name|min_time
return|;
name|t
operator|=
operator|(
name|time_t
operator|)
name|dayoff
operator|*
name|SECSPERDAY
expr_stmt|;
comment|/* 	** Cheap overflow check. 	*/
if|if
condition|(
name|t
operator|/
name|SECSPERDAY
operator|!=
name|dayoff
condition|)
return|return
operator|(
name|dayoff
operator|>
literal|0
operator|)
condition|?
name|max_time
else|:
name|min_time
return|;
return|return
name|tadd
argument_list|(
name|t
argument_list|,
name|rp
operator|->
name|r_tod
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|newabbr
parameter_list|(
name|string
parameter_list|)
specifier|const
name|char
modifier|*
specifier|const
name|string
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|charcnt
operator|+
name|i
operator|>
name|TZ_MAX_CHARS
condition|)
block|{
name|error
argument_list|(
name|_
argument_list|(
literal|"too many, or too long, time zone abbreviations"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|chars
index|[
name|charcnt
index|]
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|charcnt
operator|+=
name|eitol
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mkdirs
parameter_list|(
name|argname
parameter_list|)
name|char
modifier|*
specifier|const
name|argname
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|argname
operator|==
name|NULL
operator|||
operator|*
name|argname
operator|==
literal|'\0'
operator|||
name|Dflag
condition|)
return|return
literal|0
return|;
name|cp
operator|=
name|name
operator|=
name|ecpyalloc
argument_list|(
name|argname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|unix
comment|/* 		** DOS drive specifier? 		*/
if|if
condition|(
name|isalpha
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|name
index|[
literal|0
index|]
argument_list|)
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* !defined unix */
if|if
condition|(
operator|!
name|itsdir
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* 			** It doesn't seem to exist, so we try to create it. 			** Creation may fail because of the directory being 			** created by some other multiprocessor, so we get 			** to do extra checking. 			*/
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
operator|(
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IXUSR
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IXOTH
operator|)
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|errno
operator|!=
name|EEXIST
operator|||
operator|!
name|itsdir
argument_list|(
name|name
argument_list|)
operator|)
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"can't create directory %s"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
operator|*
name|cp
operator|=
literal|'/'
expr_stmt|;
block|}
name|ifree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|eitol
parameter_list|(
name|i
parameter_list|)
specifier|const
name|int
name|i
decl_stmt|;
block|{
name|long
name|l
decl_stmt|;
name|l
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|<
literal|0
operator|&&
name|l
operator|>=
literal|0
operator|)
operator|||
operator|(
name|i
operator|==
literal|0
operator|&&
name|l
operator|!=
literal|0
operator|)
operator|||
operator|(
name|i
operator|>
literal|0
operator|&&
name|l
operator|<=
literal|0
operator|)
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"%d did not sign extend correctly"
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|l
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_function
specifier|static
name|void
name|setgroup
parameter_list|(
name|flag
parameter_list|,
name|name
parameter_list|)
name|gid_t
modifier|*
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
if|if
condition|(
operator|*
name|flag
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"multiple -g flags specified"
argument_list|)
argument_list|)
expr_stmt|;
name|gr
operator|=
name|getgrnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|name
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|(
name|gid_t
operator|)
name|ul
operator|&&
operator|*
name|ep
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|flag
operator|=
name|ul
expr_stmt|;
return|return;
block|}
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"group `%s' not found"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|flag
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setuser
parameter_list|(
name|flag
parameter_list|,
name|name
parameter_list|)
name|uid_t
modifier|*
name|flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
if|if
condition|(
operator|*
name|flag
operator|!=
operator|(
name|gid_t
operator|)
operator|-
literal|1
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"multiple -u flags specified"
argument_list|)
argument_list|)
expr_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|long
name|ul
decl_stmt|;
name|ul
operator|=
name|strtoul
argument_list|(
name|name
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ul
operator|==
operator|(
name|unsigned
name|long
operator|)
operator|(
name|gid_t
operator|)
name|ul
operator|&&
operator|*
name|ep
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|flag
operator|=
name|ul
expr_stmt|;
return|return;
block|}
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
name|_
argument_list|(
literal|"user `%s' not found"
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|flag
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** UNIX was a registered trademark of UNIX System Laboratories in 1993. */
end_comment

end_unit

