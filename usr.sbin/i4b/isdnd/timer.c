begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 2001 Hellmuth Michaelis. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b daemon - timer/timing support routines  *	------------------------------------------  *  * $FreeBSD$  *  *      last edit-date: [Fri Jul 20 20:29:28 2001]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"isdnd.h"
end_include

begin_function_decl
specifier|static
name|int
name|hr_callgate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_reserved
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|,
name|time_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_active
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|,
name|time_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|recover_illegal
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*---------------------------------------------------------------------------*  *	recover from illegal state  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|recover_illegal
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"recover_illegal: ERROR, entry %s attempting disconnect!"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
expr_stmt|;
name|sendm_disconnect_req
argument_list|(
name|cep
argument_list|,
operator|(
name|CAUSET_I4B
operator|<<
literal|8
operator|)
operator||
name|CAUSE_I4B_NORMAL
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"recover_illegal: ERROR, entry %s - reset state/cdid!"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
name|cep
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	start the timer  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|start_timer
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|,
name|int
name|seconds
parameter_list|)
block|{
name|cep
operator|->
name|timerval
operator|=
name|cep
operator|->
name|timerremain
operator|=
name|seconds
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	stop the timer  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|stop_timer
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|cep
operator|->
name|timerval
operator|=
name|cep
operator|->
name|timerremain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	callgate for handle_recovery()  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|hr_callgate
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|tv_first
init|=
literal|1
decl_stmt|;
specifier|static
name|struct
name|timeval
name|tv_last
decl_stmt|;
name|struct
name|timeval
name|tv_now
decl_stmt|;
comment|/* there must be 1 sec minimum between calls to this section */
if|if
condition|(
name|tv_first
condition|)
block|{
name|gettimeofday
argument_list|(
operator|&
name|tv_last
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tv_first
operator|=
literal|0
expr_stmt|;
block|}
name|gettimeofday
argument_list|(
operator|&
name|tv_now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tv_now
operator|.
name|tv_sec
operator|-
name|tv_last
operator|.
name|tv_sec
operator|)
operator|<
literal|1
condition|)
block|{
name|DBGL
argument_list|(
name|DL_TIME
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"time< 1 - last %ld:%ld now %ld:%ld"
argument_list|,
name|tv_last
operator|.
name|tv_sec
argument_list|,
name|tv_last
operator|.
name|tv_usec
argument_list|,
name|tv_now
operator|.
name|tv_sec
argument_list|,
name|tv_now
operator|.
name|tv_usec
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tv_now
operator|.
name|tv_sec
operator|-
name|tv_last
operator|.
name|tv_sec
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|(
literal|1000000
operator|-
name|tv_last
operator|.
name|tv_usec
operator|)
operator|+
name|tv_now
operator|.
name|tv_usec
operator|)
operator|<
literal|900000
condition|)
block|{
name|DBGL
argument_list|(
name|DL_TIME
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"time< 900000us - last %ld:%ld now %ld:%ld"
argument_list|,
name|tv_last
operator|.
name|tv_sec
argument_list|,
name|tv_last
operator|.
name|tv_usec
argument_list|,
name|tv_now
operator|.
name|tv_sec
argument_list|,
name|tv_now
operator|.
name|tv_usec
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|DBGL
argument_list|(
name|DL_TIME
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"time OK! - last %ld:%ld now %ld:%ld"
argument_list|,
name|tv_last
operator|.
name|tv_sec
argument_list|,
name|tv_last
operator|.
name|tv_usec
argument_list|,
name|tv_now
operator|.
name|tv_sec
argument_list|,
name|tv_now
operator|.
name|tv_usec
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv_last
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	timeout, recovery and retry handling  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|handle_recovery
parameter_list|(
name|void
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|time_t
name|now
decl_stmt|;
if|if
condition|(
name|hr_callgate
argument_list|()
condition|)
comment|/* last call to handle_recovery< 1 sec ? */
return|return;
comment|/* yes, exit */
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* get current time */
comment|/* walk thru all entries, look for work to do */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
if|if
condition|(
name|cep
operator|->
name|budget_callbackperiod
operator|&&
name|cep
operator|->
name|budget_callbackncalls
condition|)
block|{
if|if
condition|(
name|cep
operator|->
name|budget_callbackperiod_time
operator|<=
name|now
condition|)
block|{
name|DBGL
argument_list|(
name|DL_BDGT
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"%s: new cback-budget-period (%d s, %d left)"
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|cep
operator|->
name|budget_callbackperiod
argument_list|,
name|cep
operator|->
name|budget_callbackncalls_cnt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cep
operator|->
name|budget_callbackperiod_time
operator|=
name|now
operator|+
name|cep
operator|->
name|budget_callbackperiod
expr_stmt|;
name|cep
operator|->
name|budget_callbackncalls_cnt
operator|=
name|cep
operator|->
name|budget_callbackncalls
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cep
operator|->
name|budget_calloutperiod
operator|&&
name|cep
operator|->
name|budget_calloutncalls
condition|)
block|{
if|if
condition|(
name|cep
operator|->
name|budget_calloutperiod_time
operator|<=
name|now
condition|)
block|{
name|DBGL
argument_list|(
name|DL_BDGT
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"%s: new cout-budget-period (%d s, %d left)"
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|cep
operator|->
name|budget_calloutperiod
argument_list|,
name|cep
operator|->
name|budget_calloutncalls_cnt
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cep
operator|->
name|budget_calloutperiod_time
operator|=
name|now
operator|+
name|cep
operator|->
name|budget_calloutperiod
expr_stmt|;
name|cep
operator|->
name|budget_calloutncalls_cnt
operator|=
name|cep
operator|->
name|budget_calloutncalls
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|cep
operator|->
name|cdid
condition|)
block|{
case|case
name|CDID_UNUSED
case|:
comment|/* entry unused */
continue|continue;
break|break;
case|case
name|CDID_RESERVED
case|:
comment|/* entry reserved */
name|handle_reserved
argument_list|(
name|cep
argument_list|,
name|now
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* entry in use */
name|handle_active
argument_list|(
name|cep
argument_list|,
name|now
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	timeout, recovery and retry handling for active entry  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|handle_active
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
switch|switch
condition|(
name|cep
operator|->
name|state
condition|)
block|{
case|case
name|ST_ACCEPTED
case|:
if|if
condition|(
name|cep
operator|->
name|timerval
operator|&&
operator|(
operator|--
operator|(
name|cep
operator|->
name|timerremain
operator|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|DBGL
argument_list|(
name|DL_RCVRY
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_active: entry %s, TIMEOUT !!!"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cep
operator|->
name|timerval
operator|=
name|cep
operator|->
name|timerremain
operator|=
literal|0
expr_stmt|;
name|next_state
argument_list|(
name|cep
argument_list|,
name|EV_TIMO
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST_ALERT
case|:
if|if
condition|(
name|cep
operator|->
name|alert_time
operator|>
literal|0
condition|)
block|{
name|cep
operator|->
name|alert_time
operator|--
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s answering: incoming call from %s to %s"
argument_list|,
name|cep
operator|->
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|cep
operator|->
name|real_phone_incoming
argument_list|,
name|cep
operator|->
name|local_phone_incoming
argument_list|)
expr_stmt|;
name|next_state
argument_list|(
name|cep
argument_list|,
name|EV_MCI
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST_ILL
case|:
name|recover_illegal
argument_list|(
name|cep
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* check hangup flag: if active, close connection */
if|if
condition|(
name|cep
operator|->
name|hangup
condition|)
block|{
name|DBGL
argument_list|(
name|DL_RCVRY
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_active: entry %s, hangup request!"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cep
operator|->
name|hangup
operator|=
literal|0
expr_stmt|;
name|next_state
argument_list|(
name|cep
argument_list|,
name|EV_DRQ
argument_list|)
expr_stmt|;
block|}
comment|/* check maximum connect time reached */
if|if
condition|(
name|cep
operator|->
name|maxconnecttime
operator|>
literal|0
operator|&&
name|cep
operator|->
name|connect_time
operator|>
literal|0
condition|)
block|{
name|int
name|connecttime
init|=
operator|(
name|int
operator|)
name|difftime
argument_list|(
name|now
argument_list|,
name|cep
operator|->
name|connect_time
argument_list|)
decl_stmt|;
if|if
condition|(
name|connecttime
operator|>
name|cep
operator|->
name|maxconnecttime
condition|)
block|{
name|DBGL
argument_list|(
name|DL_RCVRY
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_active: entry %s, maxconnecttime %d reached!"
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|cep
operator|->
name|maxconnecttime
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|next_state
argument_list|(
name|cep
argument_list|,
name|EV_DRQ
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * if shorthold mode is rates based, check if 		         * we entered a time with a new unit length 		         */
if|if
condition|(
name|cep
operator|->
name|unitlengthsrc
operator|==
name|ULSRC_RATE
condition|)
block|{
name|int
name|connecttime
init|=
operator|(
name|int
operator|)
name|difftime
argument_list|(
name|now
argument_list|,
name|cep
operator|->
name|connect_time
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|connecttime
operator|>
literal|1
operator|)
operator|&&
operator|(
name|connecttime
operator|%
literal|60
operator|)
condition|)
block|{
name|int
name|newrate
init|=
name|get_current_rate
argument_list|(
name|cep
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|newrate
operator|!=
name|cep
operator|->
name|unitlength
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_active: rates unit length updated %d -> %d"
argument_list|,
name|cep
operator|->
name|unitlength
argument_list|,
name|newrate
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cep
operator|->
name|unitlength
operator|=
name|newrate
expr_stmt|;
name|unitlen_chkupd
argument_list|(
name|cep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	timeout, recovery and retry handling for reserved entry  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|handle_reserved
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|,
name|time_t
name|now
parameter_list|)
block|{
name|time_t
name|waittime
decl_stmt|;
switch|switch
condition|(
name|cep
operator|->
name|state
condition|)
block|{
case|case
name|ST_DIALRTMRCHD
case|:
comment|/* wait for dial retry time reached */
if|if
condition|(
name|cep
operator|->
name|dialrandincr
condition|)
name|waittime
operator|=
name|cep
operator|->
name|randomtime
expr_stmt|;
else|else
name|waittime
operator|=
name|cep
operator|->
name|recoverytime
expr_stmt|;
if|if
condition|(
name|now
operator|>
operator|(
name|cep
operator|->
name|last_dial_time
operator|+
name|waittime
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_RCVRY
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_reserved: entry %s, dial retry request!"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_DIALRETRY
expr_stmt|;
if|if
condition|(
operator|(
name|cep
operator|->
name|cdid
operator|=
name|get_cdid
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"handle_reserved: dialretry get_cdid() returned 0!"
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
name|cep
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|setup_dialout
argument_list|(
name|cep
argument_list|)
operator|)
operator|==
name|GOOD
condition|)
block|{
name|sendm_connect_req
argument_list|(
name|cep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"handle_reserved: dialretry setup_dialout returned ERROR!"
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
name|cep
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|ST_ACB_WAITDIAL
case|:
comment|/* active callback wait for time between disconnect and dial */
if|if
condition|(
name|now
operator|>
operator|(
name|cep
operator|->
name|last_release_time
operator|+
name|cep
operator|->
name|callbackwait
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_RCVRY
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_reserved: entry %s, callback dial!"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_ACB_DIAL
expr_stmt|;
if|if
condition|(
operator|(
name|cep
operator|->
name|cdid
operator|=
name|get_cdid
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"handle_reserved: callback get_cdid() returned 0!"
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
name|cep
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
return|return;
block|}
name|select_first_dialno
argument_list|(
name|cep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|setup_dialout
argument_list|(
name|cep
argument_list|)
operator|)
operator|==
name|GOOD
condition|)
block|{
name|sendm_connect_req
argument_list|(
name|cep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"handle_reserved: callback setup_dialout returned ERROR!"
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
name|cep
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|ST_ACB_DIALFAIL
case|:
comment|/* callback to remote failed */
if|if
condition|(
name|cep
operator|->
name|dialrandincr
condition|)
name|waittime
operator|=
name|cep
operator|->
name|randomtime
operator|+
name|cep
operator|->
name|recoverytime
expr_stmt|;
else|else
name|waittime
operator|=
name|cep
operator|->
name|recoverytime
expr_stmt|;
if|if
condition|(
name|now
operator|>
operator|(
name|cep
operator|->
name|last_release_time
operator|+
name|waittime
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_RCVRY
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_reserved: entry %s, callback dial retry request!"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_ACB_DIAL
expr_stmt|;
if|if
condition|(
operator|(
name|cep
operator|->
name|cdid
operator|=
name|get_cdid
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"handle_reserved: callback dialretry get_cdid() returned 0!"
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
name|cep
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|setup_dialout
argument_list|(
name|cep
argument_list|)
operator|)
operator|==
name|GOOD
condition|)
block|{
name|sendm_connect_req
argument_list|(
name|cep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"handle_reserved: callback dialretry setup_dialout returned ERROR!"
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
name|cep
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
return|return;
block|}
block|}
break|break;
case|case
name|ST_PCB_WAITCALL
case|:
comment|/* wait for remote calling back */
if|if
condition|(
name|now
operator|>
operator|(
name|cep
operator|->
name|last_release_time
operator|+
name|cep
operator|->
name|calledbackwait
operator|)
condition|)
block|{
name|cep
operator|->
name|dial_count
operator|++
expr_stmt|;
if|if
condition|(
name|cep
operator|->
name|dial_count
operator|<
name|cep
operator|->
name|dialretries
condition|)
block|{
comment|/* inside normal retry cycle */
name|DBGL
argument_list|(
name|DL_RCVRY
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_reserved: entry %s, retry calledback dial #%d!"
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|cep
operator|->
name|dial_count
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_PCB_DIAL
expr_stmt|;
if|if
condition|(
operator|(
name|cep
operator|->
name|cdid
operator|=
name|get_cdid
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"handle_reserved: calledback get_cdid() returned 0!"
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
name|cep
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
return|return;
block|}
name|select_next_dialno
argument_list|(
name|cep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|setup_dialout
argument_list|(
name|cep
argument_list|)
operator|)
operator|==
name|GOOD
condition|)
block|{
name|sendm_connect_req
argument_list|(
name|cep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"handle_reserved: calledback setup_dialout returned ERROR!"
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
name|cep
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* retries exhausted */
name|DBGL
argument_list|(
name|DL_RCVRY
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_reserved: calledback dial retries exhausted"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|dialresponse
argument_list|(
name|cep
argument_list|,
name|DSTAT_TFAIL
argument_list|)
expr_stmt|;
name|cep
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
name|cep
operator|->
name|dial_count
operator|=
literal|0
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_DOWN
case|:
comment|/* interface was taken down */
if|if
condition|(
name|now
operator|>
operator|(
name|cep
operator|->
name|went_down_time
operator|+
name|cep
operator|->
name|downtime
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_RCVRY
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_reserved: taking %s%d up"
argument_list|,
name|bdrivername
argument_list|(
name|cep
operator|->
name|usrdevicename
argument_list|)
argument_list|,
name|cep
operator|->
name|usrdeviceunit
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|if_up
argument_list|(
name|cep
argument_list|)
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
name|cep
operator|->
name|cdid
operator|=
name|CDID_UNUSED
expr_stmt|;
block|}
break|break;
case|case
name|ST_ILL
case|:
comment|/* illegal state reached, recover ! */
name|recover_illegal
argument_list|(
name|cep
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* EOF */
end_comment

end_unit

