begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1999 Hellmuth Michaelis. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b daemon - misc support routines  *	----------------------------------  *  * $FreeBSD$   *  *      last edit-date: [Mon Jul  5 15:29:22 1999]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"isdnd.h"
end_include

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find an active entry by driver type and driver unit  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|find_active_entry_by_driver
parameter_list|(
name|int
name|drivertype
parameter_list|,
name|int
name|driverunit
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
if|if
condition|(
operator|!
operator|(
operator|(
name|cep
operator|->
name|usrdevicename
operator|==
name|drivertype
operator|)
operator|&&
operator|(
name|cep
operator|->
name|usrdeviceunit
operator|==
name|driverunit
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* found */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|==
name|CDID_UNUSED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_active_entry_by_driver: entry %d, cdid is CDID_UNUSED!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cep
operator|->
name|cdid
operator|==
name|CDID_RESERVED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_active_entry_by_driver: entry %d, cdid is CDID_RESERVED!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|cep
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find entry by drivertype and driverunit and setup for dialing out  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|find_by_device_for_dialout
parameter_list|(
name|int
name|drivertype
parameter_list|,
name|int
name|driverunit
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
comment|/* compare driver type and unit */
if|if
condition|(
operator|!
operator|(
operator|(
name|cep
operator|->
name|usrdevicename
operator|==
name|drivertype
operator|)
operator|&&
operator|(
name|cep
operator|->
name|usrdeviceunit
operator|==
name|driverunit
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* found, check if already reserved */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|==
name|CDID_RESERVED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialout: entry %d, cdid reserved!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* check if this entry is already in use ? */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|!=
name|CDID_UNUSED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialout: entry %d, cdid in use"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|setup_dialout
argument_list|(
name|cep
argument_list|)
operator|)
operator|==
name|GOOD
condition|)
block|{
comment|/* found an entry to be used for calling out */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialout: found entry %d!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cep
operator|)
return|;
block|}
else|else
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialout: entry %d, setup_dialout() failed!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialout: no entry found!"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find entry by drivertype and driverunit and setup for dialing out  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|find_by_device_for_dialoutnumber
parameter_list|(
name|int
name|drivertype
parameter_list|,
name|int
name|driverunit
parameter_list|,
name|int
name|cmdlen
parameter_list|,
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
comment|/* compare driver type and unit */
if|if
condition|(
operator|!
operator|(
operator|(
name|cep
operator|->
name|usrdevicename
operator|==
name|drivertype
operator|)
operator|&&
operator|(
name|cep
operator|->
name|usrdeviceunit
operator|==
name|driverunit
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* found, check if already reserved */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|==
name|CDID_RESERVED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: entry %d, cdid reserved!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* check if this entry is already in use ? */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|!=
name|CDID_UNUSED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: entry %d, cdid in use"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* check number and copy to cep->remote_numbers[] */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cmdlen
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
operator|*
operator|(
name|cmd
operator|+
name|j
operator|)
argument_list|)
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: entry %d, dial string contains non-digit at pos %d"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* fill in number to dial */
name|cep
operator|->
name|remote_numbers
index|[
literal|0
index|]
operator|.
name|number
index|[
name|j
index|]
operator|=
operator|*
operator|(
name|cmd
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|cep
operator|->
name|remote_numbers
index|[
literal|0
index|]
operator|.
name|number
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cep
operator|->
name|remote_numbers_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|setup_dialout
argument_list|(
name|cep
argument_list|)
operator|)
operator|==
name|GOOD
condition|)
block|{
comment|/* found an entry to be used for calling out */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: found entry %d!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cep
operator|)
return|;
block|}
else|else
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: entry %d, setup_dialout() failed!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: no entry found!"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find entry by drivertype and driverunit and setup for dialing out  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|setup_dialout
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
comment|/* check controller operational */
if|if
condition|(
operator|(
name|get_controller_state
argument_list|(
name|cep
operator|->
name|isdncontroller
argument_list|)
operator|)
operator|!=
name|CTRL_UP
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"setup_dialout: entry %s, controller is down"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|cep
operator|->
name|isdncontrollerused
operator|=
name|cep
operator|->
name|isdncontroller
expr_stmt|;
comment|/* check channel available */
switch|switch
condition|(
name|cep
operator|->
name|isdnchannel
condition|)
block|{
case|case
name|CHAN_B1
case|:
case|case
name|CHAN_B2
case|:
if|if
condition|(
operator|(
name|ret_channel_state
argument_list|(
name|cep
operator|->
name|isdncontroller
argument_list|,
name|cep
operator|->
name|isdnchannel
argument_list|)
operator|)
operator|!=
name|CHAN_IDLE
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"setup_dialout: entry %s, channel not free"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|cep
operator|->
name|isdnchannelused
operator|=
name|cep
operator|->
name|isdnchannel
expr_stmt|;
break|break;
case|case
name|CHAN_ANY
case|:
if|if
condition|(
operator|(
operator|(
name|ret_channel_state
argument_list|(
name|cep
operator|->
name|isdncontroller
argument_list|,
name|CHAN_B1
argument_list|)
operator|)
operator|!=
name|CHAN_IDLE
operator|)
operator|&&
operator|(
operator|(
name|ret_channel_state
argument_list|(
name|cep
operator|->
name|isdncontroller
argument_list|,
name|CHAN_B2
argument_list|)
operator|)
operator|!=
name|CHAN_IDLE
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"setup_dialout: entry %s, no channel free"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|cep
operator|->
name|isdnchannelused
operator|=
name|CHAN_ANY
expr_stmt|;
break|break;
default|default:
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"setup_dialout: entry %s, channel undefined"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
break|break;
block|}
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"setup_dialout: entry %s ok!"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* preset disconnect cause */
name|SET_CAUSE_TYPE
argument_list|(
name|cep
operator|->
name|disc_cause
argument_list|,
name|CAUSET_I4B
argument_list|)
expr_stmt|;
name|SET_CAUSE_VAL
argument_list|(
name|cep
operator|->
name|disc_cause
argument_list|,
name|CAUSE_I4B_NORMAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find entry by drivertype and driverunit  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|get_cep_by_driver
parameter_list|(
name|int
name|drivertype
parameter_list|,
name|int
name|driverunit
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
if|if
condition|(
operator|!
operator|(
operator|(
name|cep
operator|->
name|usrdevicename
operator|==
name|drivertype
operator|)
operator|&&
operator|(
name|cep
operator|->
name|usrdeviceunit
operator|==
name|driverunit
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"get_cep_by_driver: found entry %d!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cep
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find a matching entry for an incoming call  *  *	- not found/no match: log output with LL_CHD and return NULL  *	- found/match: make entry in free cep, return address  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|find_matching_entry_incoming
parameter_list|(
name|msg_connect_ind_t
modifier|*
name|mp
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* check for CW (call waiting) early */
if|if
condition|(
name|mp
operator|->
name|channel
operator|==
name|CHAN_NO
condition|)
block|{
if|if
condition|(
name|aliasing
condition|)
block|{
name|char
modifier|*
name|src_tela
init|=
literal|"ERROR-src_tela"
decl_stmt|;
name|char
modifier|*
name|dst_tela
init|=
literal|"ERROR-dst_tela"
decl_stmt|;
name|src_tela
operator|=
name|get_alias
argument_list|(
name|mp
operator|->
name|src_telno
argument_list|)
expr_stmt|;
name|dst_tela
operator|=
name|get_alias
argument_list|(
name|mp
operator|->
name|dst_telno
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d<unknown> CW from %s to %s (no channel free)"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|src_tela
argument_list|,
name|dst_tela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d<unknown> call waiting from %s to %s (no channel free)"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|,
name|mp
operator|->
name|dst_telno
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|int
name|n
decl_stmt|;
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
comment|/* check my number */
if|if
condition|(
name|strncmp
argument_list|(
name|cep
operator|->
name|local_phone_incoming
argument_list|,
name|mp
operator|->
name|dst_telno
argument_list|,
name|strlen
argument_list|(
name|cep
operator|->
name|local_phone_incoming
argument_list|)
argument_list|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, myno %s != incomingno %s"
argument_list|,
name|i
argument_list|,
name|cep
operator|->
name|local_phone_incoming
argument_list|,
name|mp
operator|->
name|dst_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check all allowed remote number's for this entry */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|cep
operator|->
name|incoming_numbers_count
condition|;
name|n
operator|++
control|)
block|{
name|incoming_number_t
modifier|*
name|in
init|=
operator|&
name|cep
operator|->
name|remote_phone_incoming
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|in
operator|->
name|number
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|in
operator|->
name|number
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|,
name|strlen
argument_list|(
name|in
operator|->
name|number
argument_list|)
argument_list|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, remno %s != incomingfromno %s"
argument_list|,
name|i
argument_list|,
name|in
operator|->
name|number
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|n
operator|>=
name|cep
operator|->
name|incoming_numbers_count
condition|)
continue|continue;
comment|/* screening indicator XXX */
switch|switch
condition|(
name|mp
operator|->
name|scr_ind
condition|)
block|{
case|case
name|SCR_NONE
case|:
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: %s - no screening indicator"
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCR_USR_NOSC
case|:
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: %s - screening user provided, not screened"
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCR_USR_PASS
case|:
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: %s - screening user provided, verified& passed"
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCR_USR_FAIL
case|:
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: %s - screening user provided, verified& failed"
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCR_NET
case|:
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: %s - screening network provided"
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: ERROR %s - invalid screening indicator!"
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* check b protocol */
if|if
condition|(
name|cep
operator|->
name|b1protocol
operator|!=
name|mp
operator|->
name|bprot
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, bprot %d != incomingprot %d"
argument_list|,
name|i
argument_list|,
name|cep
operator|->
name|b1protocol
argument_list|,
name|mp
operator|->
name|bprot
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* is this entry currently in use ? */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|!=
name|CDID_UNUSED
condition|)
block|{
if|if
condition|(
name|cep
operator|->
name|cdid
operator|==
name|CDID_RESERVED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, cdid is reserved"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cep
operator|->
name|dialin_reaction
operator|==
name|REACT_ACCEPT
operator|&&
name|cep
operator|->
name|dialouttype
operator|==
name|DIALOUT_CALLEDBACK
condition|)
block|{
comment|/* 				 * We might consider doing this even if this is 				 * not a calledback config entry - BUT: there are 				 * severe race conditions and timinig problems 				 * ex. if both sides run I4B with no callback 				 * delay - both may shutdown the outgoing call 				 * and never be able to establish a connection. 				 * In the called-back case this should not happen. 				 */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, incoming call for callback in progress (cdid %05d)"
argument_list|,
name|i
argument_list|,
name|cep
operator|->
name|cdid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* save the current call state, we're going to overwrite it with the 				 * new incoming state below... */
name|cep
operator|->
name|saved_call
operator|.
name|cdid
operator|=
name|cep
operator|->
name|cdid
expr_stmt|;
name|cep
operator|->
name|saved_call
operator|.
name|controller
operator|=
name|cep
operator|->
name|isdncontrollerused
expr_stmt|;
name|cep
operator|->
name|saved_call
operator|.
name|channel
operator|=
name|cep
operator|->
name|isdnchannelused
expr_stmt|;
block|}
else|else
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, cdid in use"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* yes, next */
block|}
block|}
comment|/* check controller value ok */
if|if
condition|(
name|mp
operator|->
name|controller
operator|>
name|ncontroller
condition|)
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call with invalid controller %d"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|mp
operator|->
name|controller
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* check controller marked up */
if|if
condition|(
operator|(
name|get_controller_state
argument_list|(
name|mp
operator|->
name|controller
argument_list|)
operator|)
operator|!=
name|CTRL_UP
condition|)
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call, controller %d DOWN!"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|mp
operator|->
name|controller
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* check channel he wants */
switch|switch
condition|(
name|mp
operator|->
name|channel
condition|)
block|{
case|case
name|CHAN_B1
case|:
case|case
name|CHAN_B2
case|:
if|if
condition|(
operator|(
name|ret_channel_state
argument_list|(
name|mp
operator|->
name|controller
argument_list|,
name|mp
operator|->
name|channel
argument_list|)
operator|)
operator|!=
name|CHAN_IDLE
condition|)
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call, channel %s not free!"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|mp
operator|->
name|channel
operator|==
name|CHAN_B1
condition|?
literal|"B1"
else|:
literal|"B2"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|CHAN_ANY
case|:
if|if
condition|(
operator|(
operator|(
name|ret_channel_state
argument_list|(
name|mp
operator|->
name|controller
argument_list|,
name|CHAN_B1
argument_list|)
operator|)
operator|!=
name|CHAN_IDLE
operator|)
operator|&&
operator|(
operator|(
name|ret_channel_state
argument_list|(
name|mp
operator|->
name|controller
argument_list|,
name|CHAN_B2
argument_list|)
operator|)
operator|!=
name|CHAN_IDLE
operator|)
condition|)
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call, no channel free!"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|CHAN_NO
case|:
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call, call waiting (no channel available)!"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
default|default:
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call, ERROR, channel undefined!"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
block|}
comment|/* found a matching entry */
name|cep
operator|->
name|cdid
operator|=
name|mp
operator|->
name|header
operator|.
name|cdid
expr_stmt|;
name|cep
operator|->
name|isdncontrollerused
operator|=
name|mp
operator|->
name|controller
expr_stmt|;
name|cep
operator|->
name|isdnchannelused
operator|=
name|mp
operator|->
name|channel
expr_stmt|;
comment|/*XXX*/
name|cep
operator|->
name|disc_cause
operator|=
literal|0
expr_stmt|;
comment|/* cp number to real one used */
name|strcpy
argument_list|(
name|cep
operator|->
name|real_phone_incoming
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
expr_stmt|;
comment|/* copy display string */
name|strcpy
argument_list|(
name|cep
operator|->
name|display
argument_list|,
name|mp
operator|->
name|display
argument_list|)
expr_stmt|;
comment|/* entry currently down ? */
if|if
condition|(
name|cep
operator|->
name|state
operator|==
name|ST_DOWN
condition|)
block|{
name|msg_updown_ind_t
name|mui
decl_stmt|;
comment|/* set interface up */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, "
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mui
operator|.
name|driver
operator|=
name|cep
operator|->
name|usrdevicename
expr_stmt|;
name|mui
operator|.
name|driver_unit
operator|=
name|cep
operator|->
name|usrdeviceunit
expr_stmt|;
name|mui
operator|.
name|updown
operator|=
name|SOFT_ENA
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_UPDOWN_IND
argument_list|,
operator|&
name|mui
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"find_matching_entry_incoming: ioctl I4B_UPDOWN_IND failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cep
operator|->
name|down_retry_count
operator|=
literal|0
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
block|}
return|return
operator|(
name|cep
operator|)
return|;
block|}
if|if
condition|(
name|aliasing
condition|)
block|{
name|char
modifier|*
name|src_tela
init|=
literal|"ERROR-src_tela"
decl_stmt|;
name|char
modifier|*
name|dst_tela
init|=
literal|"ERROR-dst_tela"
decl_stmt|;
name|src_tela
operator|=
name|get_alias
argument_list|(
name|mp
operator|->
name|src_telno
argument_list|)
expr_stmt|;
name|dst_tela
operator|=
name|get_alias
argument_list|(
name|mp
operator|->
name|dst_telno
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d Call from %s to %s"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|src_tela
argument_list|,
name|dst_tela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d<unknown> incoming call from %s to %s"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|,
name|mp
operator|->
name|dst_telno
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return address of ACTIVE config entry by controller and channel  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|get_cep_by_cc
parameter_list|(
name|int
name|ctrlr
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|chan
operator|!=
name|CHAN_B1
operator|)
operator|&&
operator|(
name|chan
operator|!=
name|CHAN_B2
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|cdid
operator|!=
name|CDID_UNUSED
operator|)
operator|&&
operator|(
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|cdid
operator|!=
name|CDID_RESERVED
operator|)
operator|&&
operator|(
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|isdnchannelused
operator|==
name|chan
operator|)
operator|&&
operator|(
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|isdncontrollerused
operator|==
name|ctrlr
operator|)
operator|&&
operator|(
operator|(
name|ret_channel_state
argument_list|(
name|ctrlr
argument_list|,
name|chan
argument_list|)
operator|)
operator|==
name|CHAN_RUN
operator|)
condition|)
block|{
return|return
operator|(
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return address of config entry identified by cdid  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|get_cep_by_cdid
parameter_list|(
name|int
name|cdid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|cdid
operator|==
name|cdid
operator|||
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|saved_call
operator|.
name|cdid
operator|==
name|cdid
condition|)
return|return
operator|(
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	get name of a controller  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|const
name|char
modifier|*
name|name_of_controller
parameter_list|(
name|int
name|ctrl_type
parameter_list|,
name|int
name|card_type
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|passive_card
index|[]
init|=
block|{
literal|"Teles S0/8"
block|,
literal|"Teles S0/16"
block|,
literal|"Teles S0/16.3"
block|,
literal|"AVM A1 or Fritz!Card"
block|,
literal|"Teles S0/16.3 PnP"
block|,
literal|"Creatix S0 PnP"
block|,
literal|"USRobotics Sportster ISDN TA"
block|,
literal|"Dr. Neuhaus NICCY Go@"
block|,
literal|"Sedlbauer win speed"
block|,
literal|"Dynalink IS64PH"
block|,
literal|"ISDN Master, MasterII or Blaster"
block|,
literal|"AVM PCMCIA Fritz!Card"
block|,
literal|"ELSA QuickStep 1000pro/ISA"
block|,
literal|"ELSA QuickStep 1000pro/PCI"
block|,
literal|"Siemens I-Talk"
block|,
literal|"ELSA MicroLink ISDN/MC"
block|,
literal|"ELSA MicroLink MCall"
block|,
literal|"ITK ix1 micro"
block|,
literal|"AVM Fritz!Card PCI"
block|,
literal|"ELSA PCC-16"
block|,
literal|"AVM Fritz!Card PnP"
block|,
literal|"Siemens I-Surf 2.0 PnP"
block|,
literal|"Asuscom ISDNlink 128K PnP"
block|}
decl_stmt|;
specifier|static
name|char
modifier|*
name|daic_card
index|[]
init|=
block|{
literal|"EICON.Diehl S"
block|,
literal|"EICON.Diehl SX/SXn"
block|,
literal|"EICON.Diehl SCOM"
block|,
literal|"EICON.Diehl QUADRO"
block|, 	}
decl_stmt|;
if|if
condition|(
name|ctrl_type
operator|==
name|CTRL_PASSIVE
condition|)
block|{
name|int
name|index
init|=
name|card_type
operator|-
name|CARD_TYPEP_8
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
operator|(
sizeof|sizeof
name|passive_card
operator|/
sizeof|sizeof
name|passive_card
index|[
literal|0
index|]
operator|)
condition|)
return|return
name|passive_card
index|[
name|index
index|]
return|;
block|}
elseif|else
if|if
condition|(
name|ctrl_type
operator|==
name|CTRL_DAIC
condition|)
block|{
name|int
name|index
init|=
name|card_type
operator|-
name|CARD_TYPEA_DAIC_S
decl_stmt|;
if|if
condition|(
name|index
operator|>=
literal|0
operator|&&
name|index
operator|<
operator|(
sizeof|sizeof
name|daic_card
operator|/
sizeof|sizeof
name|daic_card
index|[
literal|0
index|]
operator|)
condition|)
return|return
name|daic_card
index|[
name|index
index|]
return|;
block|}
elseif|else
if|if
condition|(
name|ctrl_type
operator|==
name|CTRL_TINADD
condition|)
block|{
return|return
literal|"Stollmann tina-dd"
return|;
block|}
return|return
literal|"unknown card type"
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	init controller state array  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|init_controller
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|max
init|=
literal|1
decl_stmt|;
name|msg_ctrl_info_req_t
name|mcir
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|mcir
operator|.
name|controller
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_CTRL_INFO_REQ
argument_list|,
operator|&
name|mcir
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"init_controller: ioctl I4B_CTRL_INFO_REQ failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ncontroller
operator|=
name|max
operator|=
name|mcir
operator|.
name|ncontroller
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"init_controller: no ISDN controller found!"
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mcir
operator|.
name|ctrl_type
operator|==
operator|-
literal|1
operator|||
name|mcir
operator|.
name|card_type
operator|==
operator|-
literal|1
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"init_controller: ctrl/card is invalid!"
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* init controller tab */
if|if
condition|(
operator|(
name|init_controller_state
argument_list|(
name|i
argument_list|,
name|mcir
operator|.
name|ctrl_type
argument_list|,
name|mcir
operator|.
name|card_type
argument_list|,
name|mcir
operator|.
name|tei
argument_list|)
operator|)
operator|==
name|ERROR
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"init_controller: init_controller_state for controller %d failed"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|DBGL
argument_list|(
name|DL_RCCF
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"init_controller: found %d ISDN controller(s)"
argument_list|,
name|max
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return b channel driver type name string  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|char
modifier|*
name|bdrivername
parameter_list|(
name|int
name|drivertype
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|bdtab
index|[]
init|=
block|{
literal|"rbch"
block|,
literal|"tel"
block|,
literal|"ipr"
block|,
literal|"isp"
block|,
literal|"ibc"
block|}
decl_stmt|;
if|if
condition|(
name|drivertype
operator|>=
name|BDRV_RBCH
operator|&&
name|drivertype
operator|<=
name|BDRV_IBC
condition|)
return|return
operator|(
name|bdtab
index|[
name|drivertype
index|]
operator|)
return|;
else|else
return|return
operator|(
literal|"unknown"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	process AOCD charging messages  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|handle_charge
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|cep
operator|->
name|aoc_last
operator|==
literal|0
condition|)
comment|/* no last timestamp yet ? */
block|{
name|cep
operator|->
name|aoc_last
operator|=
name|now
expr_stmt|;
comment|/* add time stamp */
block|}
elseif|else
if|if
condition|(
name|cep
operator|->
name|aoc_now
operator|==
literal|0
condition|)
comment|/* no current timestamp yet ? */
block|{
name|cep
operator|->
name|aoc_now
operator|=
name|now
expr_stmt|;
comment|/* current timestamp */
block|}
else|else
block|{
name|cep
operator|->
name|aoc_last
operator|=
name|cep
operator|->
name|aoc_now
expr_stmt|;
name|cep
operator|->
name|aoc_now
operator|=
name|now
expr_stmt|;
name|cep
operator|->
name|aoc_diff
operator|=
name|cep
operator|->
name|aoc_now
operator|-
name|cep
operator|->
name|aoc_last
expr_stmt|;
name|cep
operator|->
name|aoc_valid
operator|=
name|AOC_VALID
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|display_charge
argument_list|(
name|cep
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
if|if
condition|(
name|do_monitor
operator|&&
name|accepted
condition|)
name|monitor_evnt_charge
argument_list|(
name|cep
argument_list|,
name|cep
operator|->
name|charge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cep
operator|->
name|aoc_valid
operator|==
name|AOC_VALID
condition|)
block|{
if|if
condition|(
name|cep
operator|->
name|aoc_diff
operator|!=
name|cep
operator|->
name|unitlength
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_charge: AOCD unit length updated %d -> %d secs"
argument_list|,
name|cep
operator|->
name|unitlength
argument_list|,
name|cep
operator|->
name|aoc_diff
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cep
operator|->
name|unitlength
operator|=
name|cep
operator|->
name|aoc_diff
expr_stmt|;
name|unitlen_chkupd
argument_list|(
name|cep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NOTDEF
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_charge: AOCD unit length still %d secs"
argument_list|,
name|cep
operator|->
name|unitlength
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	update kernel idle_time, earlyhup_time and unitlen_time  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|unitlen_chkupd
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|msg_timeout_upd_t
name|tupd
decl_stmt|;
name|tupd
operator|.
name|cdid
operator|=
name|cep
operator|->
name|cdid
expr_stmt|;
comment|/* init the short hold data based on the shorthold algorithm type */
switch|switch
condition|(
name|cep
operator|->
name|shorthold_algorithm
condition|)
block|{
case|case
name|SHA_FIXU
case|:
name|tupd
operator|.
name|shorthold_data
operator|.
name|shorthold_algorithm
operator|=
name|SHA_FIXU
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|unitlen_time
operator|=
name|cep
operator|->
name|unitlength
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|idle_time
operator|=
name|cep
operator|->
name|idle_time_out
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|earlyhup_time
operator|=
name|cep
operator|->
name|earlyhangup
expr_stmt|;
break|break;
case|case
name|SHA_VARU
case|:
name|tupd
operator|.
name|shorthold_data
operator|.
name|shorthold_algorithm
operator|=
name|SHA_VARU
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|unitlen_time
operator|=
name|cep
operator|->
name|unitlength
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|idle_time
operator|=
name|cep
operator|->
name|idle_time_out
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|earlyhup_time
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"unitlen_chkupd bad shorthold_algorithm %d"
argument_list|,
name|cep
operator|->
name|shorthold_algorithm
argument_list|)
expr_stmt|;
return|return;
break|break;
block|}
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_TIMEOUT_UPD
argument_list|,
operator|&
name|tupd
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"ioctl I4B_TIMEOUT_UPD failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------*  *	this is intended to be called by do_exit and closes down all  *	active connections before the daemon exits or is reconfigured.  *--------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|close_allactive
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncontroller
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|get_controller_state
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|CTRL_UP
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ret_channel_state
argument_list|(
name|i
argument_list|,
name|CHAN_B1
argument_list|)
operator|)
operator|==
name|CHAN_RUN
condition|)
block|{
if|if
condition|(
operator|(
name|cep
operator|=
name|get_cep_by_cc
argument_list|(
name|i
argument_list|,
name|CHAN_B1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|display_disconnect
argument_list|(
name|cep
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|monitor_evnt_disconnect
argument_list|(
name|cep
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|next_state
argument_list|(
name|cep
argument_list|,
name|EV_DRQ
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|ret_channel_state
argument_list|(
name|i
argument_list|,
name|CHAN_B2
argument_list|)
operator|)
operator|==
name|CHAN_RUN
condition|)
block|{
if|if
condition|(
operator|(
name|cep
operator|=
name|get_cep_by_cc
argument_list|(
name|i
argument_list|,
name|CHAN_B2
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|display_disconnect
argument_list|(
name|cep
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|monitor_evnt_disconnect
argument_list|(
name|cep
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|next_state
argument_list|(
name|cep
argument_list|,
name|EV_DRQ
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|j
condition|)
block|{
name|log
argument_list|(
name|LL_DMN
argument_list|,
literal|"close_allactive: waiting for all connections terminated"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------*  *	set an interface up  *--------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|if_up
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|msg_updown_ind_t
name|mui
decl_stmt|;
comment|/* set interface up */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"if_up: taking %s%d up"
argument_list|,
name|bdrivername
argument_list|(
name|cep
operator|->
name|usrdevicename
argument_list|)
argument_list|,
name|cep
operator|->
name|usrdeviceunit
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mui
operator|.
name|driver
operator|=
name|cep
operator|->
name|usrdevicename
expr_stmt|;
name|mui
operator|.
name|driver_unit
operator|=
name|cep
operator|->
name|usrdeviceunit
expr_stmt|;
name|mui
operator|.
name|updown
operator|=
name|SOFT_ENA
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_UPDOWN_IND
argument_list|,
operator|&
name|mui
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"if_up: ioctl I4B_UPDOWN_IND failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cep
operator|->
name|down_retry_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|display_updown
argument_list|(
name|cep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|monitor_evnt_updown
argument_list|(
name|cep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------*  *	set an interface down  *--------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|if_down
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|msg_updown_ind_t
name|mui
decl_stmt|;
comment|/* set interface up */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"if_down: taking %s%d down"
argument_list|,
name|bdrivername
argument_list|(
name|cep
operator|->
name|usrdevicename
argument_list|)
argument_list|,
name|cep
operator|->
name|usrdeviceunit
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mui
operator|.
name|driver
operator|=
name|cep
operator|->
name|usrdevicename
expr_stmt|;
name|mui
operator|.
name|driver_unit
operator|=
name|cep
operator|->
name|usrdeviceunit
expr_stmt|;
name|mui
operator|.
name|updown
operator|=
name|SOFT_DIS
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_UPDOWN_IND
argument_list|,
operator|&
name|mui
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"if_down: ioctl I4B_UPDOWN_IND failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cep
operator|->
name|went_down_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|cep
operator|->
name|down_retry_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|display_updown
argument_list|(
name|cep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|monitor_evnt_updown
argument_list|(
name|cep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------*  *	send a dial response to (an interface in) the kernel   *--------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|dialresponse
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|,
name|int
name|dstat
parameter_list|)
block|{
name|msg_dialout_resp_t
name|mdr
decl_stmt|;
specifier|static
name|char
modifier|*
name|stattab
index|[]
init|=
block|{
literal|"normal condition"
block|,
literal|"temporary failure"
block|,
literal|"permanent failure"
block|,
literal|"dialout not allowed"
block|}
decl_stmt|;
if|if
condition|(
name|dstat
operator|<
name|DSTAT_NONE
operator|||
name|dstat
operator|>
name|DSTAT_INONLY
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"dialresponse: dstat out of range %d!"
argument_list|,
name|dstat
argument_list|)
expr_stmt|;
return|return;
block|}
name|mdr
operator|.
name|driver
operator|=
name|cep
operator|->
name|usrdevicename
expr_stmt|;
name|mdr
operator|.
name|driver_unit
operator|=
name|cep
operator|->
name|usrdeviceunit
expr_stmt|;
name|mdr
operator|.
name|stat
operator|=
name|dstat
expr_stmt|;
name|mdr
operator|.
name|cause
operator|=
name|cep
operator|->
name|disc_cause
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_DIALOUT_RESP
argument_list|,
operator|&
name|mdr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"dialresponse: ioctl I4B_DIALOUT_RESP failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DBGL
argument_list|(
name|DL_DRVR
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"dialresponse: sent [%s]"
argument_list|,
name|stattab
index|[
name|dstat
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EOF */
end_comment

end_unit

