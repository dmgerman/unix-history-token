begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 2002 Hellmuth Michaelis. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b daemon - misc support routines  *	----------------------------------  *  * $FreeBSD$  *  *      last edit-date: [Tue Mar 26 14:38:11 2002]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"isdnd.h"
end_include

begin_function_decl
specifier|static
name|int
name|isvalidtime
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find an active entry by driver type and driver unit  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|find_active_entry_by_driver
parameter_list|(
name|int
name|drivertype
parameter_list|,
name|int
name|driverunit
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
if|if
condition|(
operator|!
operator|(
operator|(
name|cep
operator|->
name|usrdevicename
operator|==
name|drivertype
operator|)
operator|&&
operator|(
name|cep
operator|->
name|usrdeviceunit
operator|==
name|driverunit
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* check time interval */
if|if
condition|(
name|isvalidtime
argument_list|(
name|cep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DBGL
argument_list|(
name|DL_VALID
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_active_entry_by_driver: entry %d, time not valid!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* found */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|==
name|CDID_UNUSED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_active_entry_by_driver: entry %d [%s%d], cdid=CDID_UNUSED !"
argument_list|,
name|i
argument_list|,
name|bdrivername
argument_list|(
name|drivertype
argument_list|)
argument_list|,
name|driverunit
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cep
operator|->
name|cdid
operator|==
name|CDID_RESERVED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_active_entry_by_driver: entry %d [%s%d], cdid=CDID_RESERVED!"
argument_list|,
name|i
argument_list|,
name|bdrivername
argument_list|(
name|drivertype
argument_list|)
argument_list|,
name|driverunit
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|cep
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find entry by drivertype and driverunit and setup for dialing out  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|find_by_device_for_dialout
parameter_list|(
name|int
name|drivertype
parameter_list|,
name|int
name|driverunit
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
comment|/* compare driver type and unit */
if|if
condition|(
operator|!
operator|(
operator|(
name|cep
operator|->
name|usrdevicename
operator|==
name|drivertype
operator|)
operator|&&
operator|(
name|cep
operator|->
name|usrdeviceunit
operator|==
name|driverunit
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* check time interval */
if|if
condition|(
name|isvalidtime
argument_list|(
name|cep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialout: entry %d, time not valid!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* found, check if already reserved */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|==
name|CDID_RESERVED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialout: entry %d, cdid reserved!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* check if this entry is already in use ? */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|!=
name|CDID_UNUSED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialout: entry %d, cdid in use"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|setup_dialout
argument_list|(
name|cep
argument_list|)
operator|)
operator|==
name|GOOD
condition|)
block|{
comment|/* found an entry to be used for calling out */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialout: found entry %d!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cep
operator|)
return|;
block|}
else|else
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialout: entry %d, setup_dialout() failed!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialout: no entry found!"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find entry by drivertype and driverunit and setup for dialing out  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|find_by_device_for_dialoutnumber
parameter_list|(
name|msg_dialoutnumber_ind_t
modifier|*
name|mp
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
comment|/* compare driver type and unit */
if|if
condition|(
operator|!
operator|(
operator|(
name|cep
operator|->
name|usrdevicename
operator|==
name|mp
operator|->
name|driver
operator|)
operator|&&
operator|(
name|cep
operator|->
name|usrdeviceunit
operator|==
name|mp
operator|->
name|driver_unit
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* check time interval */
if|if
condition|(
name|isvalidtime
argument_list|(
name|cep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: entry %d, time not valid!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* found, check if already reserved */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|==
name|CDID_RESERVED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: entry %d, cdid reserved!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* check if this entry is already in use ? */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|!=
name|CDID_UNUSED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: entry %d, cdid in use"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cep
operator|->
name|keypad
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* check number and copy to cep->remote_numbers[] */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|mp
operator|->
name|cmdlen
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
operator|*
operator|(
name|mp
operator|->
name|cmd
operator|+
name|j
operator|)
argument_list|)
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: entry %d, dial string contains non-digit at pos %d"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* fill in number to dial */
name|cep
operator|->
name|remote_numbers
index|[
literal|0
index|]
operator|.
name|number
index|[
name|j
index|]
operator|=
operator|*
operator|(
name|mp
operator|->
name|cmd
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|cep
operator|->
name|remote_numbers
index|[
literal|0
index|]
operator|.
name|number
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* XXX subaddr does not have to be a digit! isgraph() would be a better idea */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|mp
operator|->
name|subaddrlen
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|isdigit
argument_list|(
operator|*
operator|(
name|mp
operator|->
name|subaddr
operator|+
name|j
operator|)
argument_list|)
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: entry %d, subaddr string contains non-digit at pos %d"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* fill in number to dial */
name|cep
operator|->
name|remote_numbers
index|[
literal|0
index|]
operator|.
name|subaddr
index|[
name|j
index|]
operator|=
operator|*
operator|(
name|mp
operator|->
name|subaddr
operator|+
name|j
operator|)
expr_stmt|;
block|}
name|cep
operator|->
name|remote_numbers
index|[
literal|0
index|]
operator|.
name|subaddr
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cep
operator|->
name|remote_numbers_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|setup_dialout
argument_list|(
name|cep
argument_list|)
operator|)
operator|==
name|GOOD
condition|)
block|{
comment|/* found an entry to be used for calling out */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: found entry %d!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cep
operator|)
return|;
block|}
else|else
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: entry %d, setup_dialout() failed!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_dialoutnumber: no entry found!"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find entry by drivertype and driverunit and setup for send keypad  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|find_by_device_for_keypad
parameter_list|(
name|int
name|drivertype
parameter_list|,
name|int
name|driverunit
parameter_list|,
name|int
name|cmdlen
parameter_list|,
name|char
modifier|*
name|cmd
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
comment|/* compare driver type and unit */
if|if
condition|(
operator|!
operator|(
operator|(
name|cep
operator|->
name|usrdevicename
operator|==
name|drivertype
operator|)
operator|&&
operator|(
name|cep
operator|->
name|usrdeviceunit
operator|==
name|driverunit
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* check time interval */
if|if
condition|(
name|isvalidtime
argument_list|(
name|cep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_keypad: entry %d, time not valid!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* found, check if already reserved */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|==
name|CDID_RESERVED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_keypad: entry %d, cdid reserved!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* check if this entry is already in use ? */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|!=
name|CDID_UNUSED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_keypad: entry %d, cdid in use"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cep
operator|->
name|remote_numbers
index|[
literal|0
index|]
operator|.
name|number
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cep
operator|->
name|remote_numbers_count
operator|=
literal|0
expr_stmt|;
name|cep
operator|->
name|remote_phone_dialout
operator|.
name|number
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|bzero
argument_list|(
name|cep
operator|->
name|keypad
argument_list|,
name|KEYPAD_MAX
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cep
operator|->
name|keypad
argument_list|,
name|cmd
argument_list|,
name|cmdlen
argument_list|)
expr_stmt|;
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_keypad: entry %d, keypad string is %s"
argument_list|,
name|i
argument_list|,
name|cep
operator|->
name|keypad
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|setup_dialout
argument_list|(
name|cep
argument_list|)
operator|)
operator|==
name|GOOD
condition|)
block|{
comment|/* found an entry to be used for calling out */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_keypad: found entry %d!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cep
operator|)
return|;
block|}
else|else
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_keypad: entry %d, setup_dialout() failed!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_by_device_for_keypad: no entry found!"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find entry by drivertype and driverunit and setup for dialing out  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|setup_dialout
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* check controller operational */
if|if
condition|(
operator|(
name|get_controller_state
argument_list|(
name|cep
operator|->
name|isdncontroller
argument_list|)
operator|)
operator|!=
name|CTRL_UP
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"setup_dialout: entry %s, controller is down"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|cep
operator|->
name|isdncontrollerused
operator|=
name|cep
operator|->
name|isdncontroller
expr_stmt|;
comment|/* check channel available */
switch|switch
condition|(
name|cep
operator|->
name|isdnchannel
condition|)
block|{
case|case
name|CHAN_ANY
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isdn_ctrl_tab
index|[
name|cep
operator|->
name|isdncontroller
index|]
operator|.
name|nbch
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ret_channel_state
argument_list|(
name|cep
operator|->
name|isdncontroller
argument_list|,
name|i
argument_list|)
operator|==
name|CHAN_IDLE
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|isdn_ctrl_tab
index|[
name|cep
operator|->
name|isdncontroller
index|]
operator|.
name|nbch
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"setup_dialout: entry %s, no channel free"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|cep
operator|->
name|isdnchannelused
operator|=
name|CHAN_ANY
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|ret_channel_state
argument_list|(
name|cep
operator|->
name|isdncontroller
argument_list|,
name|cep
operator|->
name|isdnchannel
argument_list|)
operator|)
operator|!=
name|CHAN_IDLE
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"setup_dialout: entry %s, channel not free"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|cep
operator|->
name|isdnchannelused
operator|=
name|cep
operator|->
name|isdnchannel
expr_stmt|;
break|break;
block|}
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"setup_dialout: entry %s ok!"
argument_list|,
name|cep
operator|->
name|name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* preset disconnect cause */
name|SET_CAUSE_TYPE
argument_list|(
name|cep
operator|->
name|disc_cause
argument_list|,
name|CAUSET_I4B
argument_list|)
expr_stmt|;
name|SET_CAUSE_VAL
argument_list|(
name|cep
operator|->
name|disc_cause
argument_list|,
name|CAUSE_I4B_NORMAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|GOOD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find entry by drivertype and driverunit  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|get_cep_by_driver
parameter_list|(
name|int
name|drivertype
parameter_list|,
name|int
name|driverunit
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
if|if
condition|(
operator|!
operator|(
operator|(
name|cep
operator|->
name|usrdevicename
operator|==
name|drivertype
operator|)
operator|&&
operator|(
name|cep
operator|->
name|usrdeviceunit
operator|==
name|driverunit
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* check time interval */
if|if
condition|(
name|isvalidtime
argument_list|(
name|cep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"get_cep_by_driver: entry %d, time not valid!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"get_cep_by_driver: found entry %d!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cep
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	find a matching entry for an incoming call  *  *	- not found/no match: log output with LL_CHD and return NULL  *	- found/match: make entry in free cep, return address  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|find_matching_entry_incoming
parameter_list|(
name|msg_connect_ind_t
modifier|*
name|mp
parameter_list|)
block|{
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* check for CW (call waiting) early */
if|if
condition|(
name|mp
operator|->
name|channel
operator|==
name|CHAN_NO
condition|)
block|{
if|if
condition|(
name|aliasing
condition|)
block|{
name|char
modifier|*
name|src_tela
init|=
literal|"ERROR-src_tela"
decl_stmt|;
name|char
modifier|*
name|dst_tela
init|=
literal|"ERROR-dst_tela"
decl_stmt|;
name|src_tela
operator|=
name|get_alias
argument_list|(
name|mp
operator|->
name|src_telno
argument_list|)
expr_stmt|;
name|dst_tela
operator|=
name|get_alias
argument_list|(
name|mp
operator|->
name|dst_telno
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d<unknown> CW from %s to %s (no channel free)"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|src_tela
argument_list|,
name|dst_tela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d<unknown> call waiting from %s to %s (no channel free)"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|,
name|mp
operator|->
name|dst_telno
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
name|int
name|n
decl_stmt|;
name|cep
operator|=
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
expr_stmt|;
comment|/* ptr to config entry */
comment|/* check my number */
if|if
condition|(
name|strncmp
argument_list|(
name|cep
operator|->
name|local_phone_incoming
operator|.
name|number
argument_list|,
name|mp
operator|->
name|dst_telno
argument_list|,
name|strlen
argument_list|(
name|cep
operator|->
name|local_phone_incoming
operator|.
name|number
argument_list|)
argument_list|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, myno %s != incomingno %s"
argument_list|,
name|i
argument_list|,
name|cep
operator|->
name|local_phone_incoming
operator|.
name|number
argument_list|,
name|mp
operator|->
name|dst_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cep
operator|->
name|usesubaddr
operator|&&
name|strncmp
argument_list|(
name|cep
operator|->
name|local_phone_incoming
operator|.
name|subaddr
argument_list|,
name|mp
operator|->
name|dst_subaddr
argument_list|,
name|strlen
argument_list|(
name|cep
operator|->
name|local_phone_incoming
operator|.
name|subaddr
argument_list|)
argument_list|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, mysubno %s != incomingsubno %s"
argument_list|,
name|i
argument_list|,
name|cep
operator|->
name|local_phone_incoming
operator|.
name|subaddr
argument_list|,
name|mp
operator|->
name|dst_subaddr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check all allowed remote number's for this entry */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|cep
operator|->
name|incoming_numbers_count
condition|;
name|n
operator|++
control|)
block|{
name|incoming_number_t
modifier|*
name|in
init|=
operator|&
name|cep
operator|->
name|remote_phone_incoming
index|[
name|n
index|]
decl_stmt|;
if|if
condition|(
name|in
operator|->
name|number
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|cep
operator|->
name|usesubaddr
operator|&&
name|in
operator|->
name|subaddr
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
break|break;
if|if
condition|(
name|in
operator|->
name|number
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
operator|!
name|cep
operator|->
name|usesubaddr
condition|)
break|break;
if|if
condition|(
name|in
operator|->
name|number
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|cep
operator|->
name|usesubaddr
operator|&&
operator|!
name|strncmp
argument_list|(
name|in
operator|->
name|subaddr
argument_list|,
name|mp
operator|->
name|src_subaddr
argument_list|,
name|strlen
argument_list|(
name|in
operator|->
name|subaddr
argument_list|)
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|in
operator|->
name|number
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|,
name|strlen
argument_list|(
name|in
operator|->
name|number
argument_list|)
argument_list|)
operator|&&
operator|!
name|cep
operator|->
name|usesubaddr
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, remno %s != incomingfromno %s"
argument_list|,
name|i
argument_list|,
name|in
operator|->
name|number
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|in
operator|->
name|number
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|,
name|strlen
argument_list|(
name|in
operator|->
name|number
argument_list|)
argument_list|)
operator|&&
name|cep
operator|->
name|usesubaddr
operator|&&
name|in
operator|->
name|subaddr
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, remno %s != incomingfromno %s"
argument_list|,
name|i
argument_list|,
name|in
operator|->
name|number
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|in
operator|->
name|number
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|,
name|strlen
argument_list|(
name|in
operator|->
name|number
argument_list|)
argument_list|)
operator|&&
name|cep
operator|->
name|usesubaddr
operator|&&
name|strncmp
argument_list|(
name|in
operator|->
name|subaddr
argument_list|,
name|mp
operator|->
name|src_subaddr
argument_list|,
name|strlen
argument_list|(
name|in
operator|->
name|subaddr
argument_list|)
argument_list|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, remno %s != incomingfromno %s"
argument_list|,
name|i
argument_list|,
name|in
operator|->
name|number
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|n
operator|>=
name|cep
operator|->
name|incoming_numbers_count
condition|)
continue|continue;
comment|/* check b protocol */
if|if
condition|(
name|cep
operator|->
name|b1protocol
operator|!=
name|mp
operator|->
name|bprot
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, bprot %d != incomingprot %d"
argument_list|,
name|i
argument_list|,
name|cep
operator|->
name|b1protocol
argument_list|,
name|mp
operator|->
name|bprot
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* is this entry currently in use ? */
if|if
condition|(
name|cep
operator|->
name|cdid
operator|!=
name|CDID_UNUSED
condition|)
block|{
if|if
condition|(
name|cep
operator|->
name|cdid
operator|==
name|CDID_RESERVED
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, cdid is reserved"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cep
operator|->
name|dialin_reaction
operator|==
name|REACT_ACCEPT
operator|&&
name|cep
operator|->
name|dialouttype
operator|==
name|DIALOUT_CALLEDBACK
condition|)
block|{
comment|/* 				 * We might consider doing this even if this is 				 * not a calledback config entry - BUT: there are 				 * severe race conditions and timinig problems 				 * ex. if both sides run I4B with no callback 				 * delay - both may shutdown the outgoing call 				 * and never be able to establish a connection. 				 * In the called-back case this should not happen. 				 */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, incoming call for callback in progress (cdid %05d)"
argument_list|,
name|i
argument_list|,
name|cep
operator|->
name|cdid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* save the current call state, we're going to overwrite it with the 				 * new incoming state below... */
name|cep
operator|->
name|saved_call
operator|.
name|cdid
operator|=
name|cep
operator|->
name|cdid
expr_stmt|;
name|cep
operator|->
name|saved_call
operator|.
name|controller
operator|=
name|cep
operator|->
name|isdncontrollerused
expr_stmt|;
name|cep
operator|->
name|saved_call
operator|.
name|channel
operator|=
name|cep
operator|->
name|isdnchannelused
expr_stmt|;
block|}
else|else
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, cdid in use"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
comment|/* yes, next */
block|}
block|}
comment|/* check controller value ok */
if|if
condition|(
name|mp
operator|->
name|controller
operator|>
name|ncontroller
condition|)
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call with invalid controller %d"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|mp
operator|->
name|controller
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* check controller marked up */
if|if
condition|(
operator|(
name|get_controller_state
argument_list|(
name|mp
operator|->
name|controller
argument_list|)
operator|)
operator|!=
name|CTRL_UP
condition|)
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call, controller %d DOWN!"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|mp
operator|->
name|controller
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  		 * check controller he wants, check for any  		 * controller or specific controller  		 */
if|if
condition|(
operator|(
name|mp
operator|->
name|controller
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|mp
operator|->
name|controller
operator|!=
name|cep
operator|->
name|isdncontroller
operator|)
condition|)
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call, controller %d != incoming %d"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|cep
operator|->
name|isdncontroller
argument_list|,
name|mp
operator|->
name|controller
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check channel he wants */
switch|switch
condition|(
name|mp
operator|->
name|channel
condition|)
block|{
case|case
name|CHAN_ANY
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|isdn_ctrl_tab
index|[
name|mp
operator|->
name|controller
index|]
operator|.
name|nbch
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ret_channel_state
argument_list|(
name|mp
operator|->
name|controller
argument_list|,
name|i
argument_list|)
operator|==
name|CHAN_IDLE
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|isdn_ctrl_tab
index|[
name|mp
operator|->
name|controller
index|]
operator|.
name|nbch
condition|)
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call, no channel free!"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|CHAN_NO
case|:
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call, call waiting (no channel available)!"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
default|default:
if|if
condition|(
operator|(
name|ret_channel_state
argument_list|(
name|mp
operator|->
name|controller
argument_list|,
name|mp
operator|->
name|channel
argument_list|)
operator|)
operator|!=
name|CHAN_IDLE
condition|)
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s incoming call, channel B%d not free!"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|cep
operator|->
name|name
argument_list|,
name|mp
operator|->
name|channel
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
block|}
comment|/* check time interval */
if|if
condition|(
name|isvalidtime
argument_list|(
name|cep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, time not valid!"
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* found a matching entry */
name|cep
operator|->
name|cdid
operator|=
name|mp
operator|->
name|header
operator|.
name|cdid
expr_stmt|;
name|cep
operator|->
name|isdncontrollerused
operator|=
name|mp
operator|->
name|controller
expr_stmt|;
name|cep
operator|->
name|isdnchannelused
operator|=
name|mp
operator|->
name|channel
expr_stmt|;
comment|/*XXX*/
name|cep
operator|->
name|disc_cause
operator|=
literal|0
expr_stmt|;
comment|/* cp number to real one used */
name|strcpy
argument_list|(
name|cep
operator|->
name|real_phone_incoming
operator|.
name|number
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|)
expr_stmt|;
comment|/* copy display string */
name|strcpy
argument_list|(
name|cep
operator|->
name|display
argument_list|,
name|mp
operator|->
name|display
argument_list|)
expr_stmt|;
comment|/* entry currently down ? */
if|if
condition|(
name|cep
operator|->
name|state
operator|==
name|ST_DOWN
condition|)
block|{
name|msg_updown_ind_t
name|mui
decl_stmt|;
comment|/* set interface up */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"find_matching_entry_incoming: entry %d, "
argument_list|,
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mui
operator|.
name|driver
operator|=
name|cep
operator|->
name|usrdevicename
expr_stmt|;
name|mui
operator|.
name|driver_unit
operator|=
name|cep
operator|->
name|usrdeviceunit
expr_stmt|;
name|mui
operator|.
name|updown
operator|=
name|SOFT_ENA
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_UPDOWN_IND
argument_list|,
operator|&
name|mui
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"find_matching_entry_incoming: ioctl I4B_UPDOWN_IND failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"find_matching_entry_incoming: ioctl I4B_UPDOWN_IND failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cep
operator|->
name|down_retry_count
operator|=
literal|0
expr_stmt|;
name|cep
operator|->
name|state
operator|=
name|ST_IDLE
expr_stmt|;
block|}
return|return
operator|(
name|cep
operator|)
return|;
block|}
if|if
condition|(
name|aliasing
condition|)
block|{
name|char
modifier|*
name|src_tela
init|=
literal|"ERROR-src_tela"
decl_stmt|;
name|char
modifier|*
name|dst_tela
init|=
literal|"ERROR-dst_tela"
decl_stmt|;
name|src_tela
operator|=
name|get_alias
argument_list|(
name|mp
operator|->
name|src_telno
argument_list|)
expr_stmt|;
name|dst_tela
operator|=
name|get_alias
argument_list|(
name|mp
operator|->
name|dst_telno
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d Call from %s to %s"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|src_tela
argument_list|,
name|dst_tela
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d<unknown> incoming call from %s to %s ctrl %d"
argument_list|,
name|mp
operator|->
name|header
operator|.
name|cdid
argument_list|,
name|mp
operator|->
name|src_telno
argument_list|,
name|mp
operator|->
name|dst_telno
argument_list|,
name|mp
operator|->
name|controller
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return address of ACTIVE config entry by controller and channel  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|get_cep_by_cc
parameter_list|(
name|int
name|ctrlr
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|chan
operator|<
literal|0
operator|)
operator|||
operator|(
name|chan
operator|>=
name|isdn_ctrl_tab
index|[
name|ctrlr
index|]
operator|.
name|nbch
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|cdid
operator|!=
name|CDID_UNUSED
operator|)
operator|&&
operator|(
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|cdid
operator|!=
name|CDID_RESERVED
operator|)
operator|&&
operator|(
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|isdnchannelused
operator|==
name|chan
operator|)
operator|&&
operator|(
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|isdncontrollerused
operator|==
name|ctrlr
operator|)
operator|&&
operator|(
operator|(
name|ret_channel_state
argument_list|(
name|ctrlr
argument_list|,
name|chan
argument_list|)
operator|)
operator|==
name|CHAN_RUN
operator|)
condition|)
block|{
return|return
operator|(
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return address of config entry identified by cdid  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|cfg_entry_t
modifier|*
name|get_cep_by_cdid
parameter_list|(
name|int
name|cdid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nentries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|cdid
operator|==
name|cdid
operator|||
name|cfg_entry_tab
index|[
name|i
index|]
operator|.
name|saved_call
operator|.
name|cdid
operator|==
name|cdid
condition|)
return|return
operator|(
operator|&
name|cfg_entry_tab
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return b channel driver type name string  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|char
modifier|*
name|bdrivername
parameter_list|(
name|int
name|drivertype
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|bdtab
index|[]
init|=
block|{
literal|"rbch"
block|,
literal|"tel"
block|,
literal|"ipr"
block|,
literal|"isp"
block|,
literal|"ibc"
block|,
literal|"ing"
block|}
decl_stmt|;
if|if
condition|(
name|drivertype
operator|>=
name|BDRV_RBCH
operator|&&
name|drivertype
operator|<=
name|BDRV_ING
condition|)
return|return
operator|(
name|bdtab
index|[
name|drivertype
index|]
operator|)
return|;
else|else
return|return
operator|(
literal|"unknown"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	process AOCD charging messages  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|handle_charge
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|cep
operator|->
name|aoc_last
operator|==
literal|0
condition|)
comment|/* no last timestamp yet ? */
block|{
name|cep
operator|->
name|aoc_last
operator|=
name|now
expr_stmt|;
comment|/* add time stamp */
block|}
elseif|else
if|if
condition|(
name|cep
operator|->
name|aoc_now
operator|==
literal|0
condition|)
comment|/* no current timestamp yet ? */
block|{
name|cep
operator|->
name|aoc_now
operator|=
name|now
expr_stmt|;
comment|/* current timestamp */
block|}
else|else
block|{
name|cep
operator|->
name|aoc_last
operator|=
name|cep
operator|->
name|aoc_now
expr_stmt|;
name|cep
operator|->
name|aoc_now
operator|=
name|now
expr_stmt|;
name|cep
operator|->
name|aoc_diff
operator|=
name|cep
operator|->
name|aoc_now
operator|-
name|cep
operator|->
name|aoc_last
expr_stmt|;
name|cep
operator|->
name|aoc_valid
operator|=
name|AOC_VALID
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|display_charge
argument_list|(
name|cep
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
if|if
condition|(
name|do_monitor
operator|&&
name|accepted
condition|)
name|monitor_evnt_charge
argument_list|(
name|cep
argument_list|,
name|cep
operator|->
name|charge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cep
operator|->
name|aoc_valid
operator|==
name|AOC_VALID
condition|)
block|{
if|if
condition|(
name|cep
operator|->
name|aoc_diff
operator|!=
name|cep
operator|->
name|unitlength
condition|)
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_charge: AOCD unit length updated %d -> %d secs"
argument_list|,
name|cep
operator|->
name|unitlength
argument_list|,
name|cep
operator|->
name|aoc_diff
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cep
operator|->
name|unitlength
operator|=
name|cep
operator|->
name|aoc_diff
expr_stmt|;
name|unitlen_chkupd
argument_list|(
name|cep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NOTDEF
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"handle_charge: AOCD unit length still %d secs"
argument_list|,
name|cep
operator|->
name|unitlength
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	update kernel idle_time, earlyhup_time and unitlen_time  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|unitlen_chkupd
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|msg_timeout_upd_t
name|tupd
decl_stmt|;
name|tupd
operator|.
name|cdid
operator|=
name|cep
operator|->
name|cdid
expr_stmt|;
comment|/* init the short hold data based on the shorthold algorithm type */
switch|switch
condition|(
name|cep
operator|->
name|shorthold_algorithm
condition|)
block|{
case|case
name|SHA_FIXU
case|:
name|tupd
operator|.
name|shorthold_data
operator|.
name|shorthold_algorithm
operator|=
name|SHA_FIXU
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|unitlen_time
operator|=
name|cep
operator|->
name|unitlength
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|idle_time
operator|=
name|cep
operator|->
name|idle_time_out
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|earlyhup_time
operator|=
name|cep
operator|->
name|earlyhangup
expr_stmt|;
break|break;
case|case
name|SHA_VARU
case|:
name|tupd
operator|.
name|shorthold_data
operator|.
name|shorthold_algorithm
operator|=
name|SHA_VARU
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|unitlen_time
operator|=
name|cep
operator|->
name|unitlength
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|idle_time
operator|=
name|cep
operator|->
name|idle_time_out
expr_stmt|;
name|tupd
operator|.
name|shorthold_data
operator|.
name|earlyhup_time
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"unitlen_chkupd bad shorthold_algorithm %d"
argument_list|,
name|cep
operator|->
name|shorthold_algorithm
argument_list|)
expr_stmt|;
return|return;
break|break;
block|}
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_TIMEOUT_UPD
argument_list|,
operator|&
name|tupd
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"ioctl I4B_TIMEOUT_UPD failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"ioctl I4B_TIMEOUT_UPD failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------*  *	this is intended to be called by do_exit and closes down all  *	active connections before the daemon exits or is reconfigured.  *--------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|close_allactive
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|cfg_entry_t
modifier|*
name|cep
init|=
name|NULL
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncontroller
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|get_controller_state
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|CTRL_UP
condition|)
continue|continue;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|isdn_ctrl_tab
index|[
name|i
index|]
operator|.
name|nbch
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ret_channel_state
argument_list|(
name|i
argument_list|,
name|k
argument_list|)
operator|)
operator|==
name|CHAN_RUN
condition|)
block|{
if|if
condition|(
operator|(
name|cep
operator|=
name|get_cep_by_cc
argument_list|(
name|i
argument_list|,
name|k
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|display_disconnect
argument_list|(
name|cep
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|monitor_evnt_disconnect
argument_list|(
name|cep
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|next_state
argument_list|(
name|cep
argument_list|,
name|EV_DRQ
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|j
condition|)
block|{
name|log
argument_list|(
name|LL_DMN
argument_list|,
literal|"close_allactive: waiting for all connections terminated"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------*  *	set an interface up  *--------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|if_up
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|msg_updown_ind_t
name|mui
decl_stmt|;
comment|/* set interface up */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"if_up: taking %s%d up"
argument_list|,
name|bdrivername
argument_list|(
name|cep
operator|->
name|usrdevicename
argument_list|)
argument_list|,
name|cep
operator|->
name|usrdeviceunit
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mui
operator|.
name|driver
operator|=
name|cep
operator|->
name|usrdevicename
expr_stmt|;
name|mui
operator|.
name|driver_unit
operator|=
name|cep
operator|->
name|usrdeviceunit
expr_stmt|;
name|mui
operator|.
name|updown
operator|=
name|SOFT_ENA
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_UPDOWN_IND
argument_list|,
operator|&
name|mui
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"if_up: ioctl I4B_UPDOWN_IND failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"if_up: ioctl I4B_UPDOWN_IND failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cep
operator|->
name|down_retry_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|display_updown
argument_list|(
name|cep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|monitor_evnt_updown
argument_list|(
name|cep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------*  *	set an interface down  *--------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|if_down
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|msg_updown_ind_t
name|mui
decl_stmt|;
comment|/* set interface up */
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"if_down: taking %s%d down"
argument_list|,
name|bdrivername
argument_list|(
name|cep
operator|->
name|usrdevicename
argument_list|)
argument_list|,
name|cep
operator|->
name|usrdeviceunit
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|mui
operator|.
name|driver
operator|=
name|cep
operator|->
name|usrdevicename
expr_stmt|;
name|mui
operator|.
name|driver_unit
operator|=
name|cep
operator|->
name|usrdeviceunit
expr_stmt|;
name|mui
operator|.
name|updown
operator|=
name|SOFT_DIS
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_UPDOWN_IND
argument_list|,
operator|&
name|mui
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"if_down: ioctl I4B_UPDOWN_IND failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"if_down: ioctl I4B_UPDOWN_IND failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cep
operator|->
name|went_down_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|cep
operator|->
name|down_retry_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|display_updown
argument_list|(
name|cep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|monitor_evnt_updown
argument_list|(
name|cep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------*  *	send a dial response to (an interface in) the kernel   *--------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|dialresponse
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|,
name|int
name|dstat
parameter_list|)
block|{
name|msg_dialout_resp_t
name|mdr
decl_stmt|;
specifier|static
name|char
modifier|*
name|stattab
index|[]
init|=
block|{
literal|"normal condition"
block|,
literal|"temporary failure"
block|,
literal|"permanent failure"
block|,
literal|"dialout not allowed"
block|}
decl_stmt|;
if|if
condition|(
name|dstat
operator|<
name|DSTAT_NONE
operator|||
name|dstat
operator|>
name|DSTAT_INONLY
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"dialresponse: dstat out of range %d!"
argument_list|,
name|dstat
argument_list|)
expr_stmt|;
return|return;
block|}
name|mdr
operator|.
name|driver
operator|=
name|cep
operator|->
name|usrdevicename
expr_stmt|;
name|mdr
operator|.
name|driver_unit
operator|=
name|cep
operator|->
name|usrdeviceunit
expr_stmt|;
name|mdr
operator|.
name|stat
operator|=
name|dstat
expr_stmt|;
name|mdr
operator|.
name|cause
operator|=
name|cep
operator|->
name|disc_cause
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_DIALOUT_RESP
argument_list|,
operator|&
name|mdr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"dialresponse: ioctl I4B_DIALOUT_RESP failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"dialresponse: ioctl I4B_DIALOUT_RESP failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DBGL
argument_list|(
name|DL_DRVR
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"dialresponse: sent [%s]"
argument_list|,
name|stattab
index|[
name|dstat
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------*  *	screening/presentation indicator  *--------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|handle_scrprs
parameter_list|(
name|int
name|cdid
parameter_list|,
name|int
name|scr
parameter_list|,
name|int
name|prs
parameter_list|,
name|char
modifier|*
name|caller
parameter_list|)
block|{
comment|/* screening indicator */
if|if
condition|(
name|scr
operator|<
name|SCR_NONE
operator|||
name|scr
operator|>
name|SCR_NET
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"msg_connect_ind: invalid screening indicator value %d!"
argument_list|,
name|scr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|static
name|char
modifier|*
name|scrtab
index|[]
init|=
block|{
literal|"no screening indicator"
block|,
literal|"sreening user provided, not screened"
block|,
literal|"screening user provided, verified& passed"
block|,
literal|"screening user provided, verified& failed"
block|,
literal|"screening network provided"
block|, }
decl_stmt|;
if|if
condition|(
name|extcallattr
condition|)
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s %s"
argument_list|,
name|cdid
argument_list|,
name|caller
argument_list|,
name|scrtab
index|[
name|scr
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"%s - %s"
argument_list|,
name|caller
argument_list|,
name|scrtab
index|[
name|scr
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* presentation indicator */
if|if
condition|(
name|prs
operator|<
name|PRS_NONE
operator|||
name|prs
operator|>
name|PRS_RESERVED
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"msg_connect_ind: invalid presentation indicator value %d!"
argument_list|,
name|prs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|static
name|char
modifier|*
name|prstab
index|[]
init|=
block|{
literal|"no presentation indicator"
block|,
literal|"presentation allowed"
block|,
literal|"presentation restricted"
block|,
literal|"number not available due to interworking"
block|,
literal|"reserved presentation value"
block|}
decl_stmt|;
if|if
condition|(
name|extcallattr
condition|)
block|{
name|log
argument_list|(
name|LL_CHD
argument_list|,
literal|"%05d %s %s"
argument_list|,
name|cdid
argument_list|,
name|caller
argument_list|,
name|prstab
index|[
name|prs
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DBGL
argument_list|(
name|DL_MSG
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"%s - %s"
argument_list|,
name|caller
argument_list|,
name|prstab
index|[
name|prs
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------*  *	check if the time is valid for an entry  *--------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|isvalidtime
parameter_list|(
name|cfg_entry_t
modifier|*
name|cep
parameter_list|)
block|{
name|time_t
name|t
decl_stmt|;
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|cep
operator|->
name|day
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|cep
operator|->
name|day
operator|&
name|HD
condition|)
block|{
if|if
condition|(
name|isholiday
argument_list|(
name|tp
operator|->
name|tm_mday
argument_list|,
operator|(
name|tp
operator|->
name|tm_mon
operator|)
operator|+
literal|1
argument_list|,
operator|(
name|tp
operator|->
name|tm_year
operator|)
operator|+
literal|1900
argument_list|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_VALID
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"isvalidtime: holiday %d.%d.%d"
argument_list|,
name|tp
operator|->
name|tm_mday
argument_list|,
operator|(
name|tp
operator|->
name|tm_mon
operator|)
operator|+
literal|1
argument_list|,
operator|(
name|tp
operator|->
name|tm_year
operator|)
operator|+
literal|1900
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|dayok
goto|;
block|}
block|}
if|if
condition|(
name|cep
operator|->
name|day
operator|&
operator|(
literal|1
operator|<<
name|tp
operator|->
name|tm_wday
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_VALID
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"isvalidtime: day match"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|dayok
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|dayok
label|:
if|if
condition|(
name|cep
operator|->
name|fromhr
operator|==
literal|0
operator|&&
name|cep
operator|->
name|frommin
operator|==
literal|0
operator|&&
name|cep
operator|->
name|tohr
operator|==
literal|0
operator|&&
name|cep
operator|->
name|tomin
operator|==
literal|0
condition|)
block|{
name|DBGL
argument_list|(
name|DL_VALID
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"isvalidtime: no time specified, match!"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cep
operator|->
name|tohr
operator|<
name|cep
operator|->
name|fromhr
condition|)
block|{
comment|/* before 00:00 */
if|if
condition|(
operator|(
name|tp
operator|->
name|tm_hour
operator|>
name|cep
operator|->
name|fromhr
operator|)
operator|||
operator|(
name|tp
operator|->
name|tm_hour
operator|==
name|cep
operator|->
name|fromhr
operator|&&
name|tp
operator|->
name|tm_min
operator|>
name|cep
operator|->
name|frommin
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_VALID
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"isvalidtime: t<f-1, spec=%02d:%02d-%02d:%02d, curr=%02d:%02d, match!"
argument_list|,
name|cep
operator|->
name|fromhr
argument_list|,
name|cep
operator|->
name|frommin
argument_list|,
name|cep
operator|->
name|tohr
argument_list|,
name|cep
operator|->
name|tomin
argument_list|,
name|tp
operator|->
name|tm_hour
argument_list|,
name|tp
operator|->
name|tm_min
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* after 00:00 */
if|if
condition|(
operator|(
name|tp
operator|->
name|tm_hour
operator|<
name|cep
operator|->
name|tohr
operator|)
operator|||
operator|(
name|tp
operator|->
name|tm_hour
operator|==
name|cep
operator|->
name|tohr
operator|&&
name|tp
operator|->
name|tm_min
operator|<
name|cep
operator|->
name|tomin
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_VALID
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"isvalidtime: t<f-2, spec=%02d:%02d-%02d:%02d, curr=%02d:%02d, match!"
argument_list|,
name|cep
operator|->
name|fromhr
argument_list|,
name|cep
operator|->
name|frommin
argument_list|,
name|cep
operator|->
name|tohr
argument_list|,
name|cep
operator|->
name|tomin
argument_list|,
name|tp
operator|->
name|tm_hour
argument_list|,
name|tp
operator|->
name|tm_min
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|cep
operator|->
name|fromhr
operator|==
name|cep
operator|->
name|tohr
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|tm_min
operator|>=
name|cep
operator|->
name|frommin
operator|&&
name|tp
operator|->
name|tm_min
operator|<
name|cep
operator|->
name|tomin
condition|)
block|{
name|DBGL
argument_list|(
name|DL_VALID
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"isvalidtime: f=t, spec=%02d:%02d-%02d:%02d, curr=%02d:%02d, match!"
argument_list|,
name|cep
operator|->
name|fromhr
argument_list|,
name|cep
operator|->
name|frommin
argument_list|,
name|cep
operator|->
name|tohr
argument_list|,
name|cep
operator|->
name|tomin
argument_list|,
name|tp
operator|->
name|tm_hour
argument_list|,
name|tp
operator|->
name|tm_min
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tm_hour
operator|>
name|cep
operator|->
name|fromhr
operator|&&
name|tp
operator|->
name|tm_hour
operator|<
name|cep
operator|->
name|tohr
operator|)
operator|||
operator|(
name|tp
operator|->
name|tm_hour
operator|==
name|cep
operator|->
name|fromhr
operator|&&
name|tp
operator|->
name|tm_min
operator|>=
name|cep
operator|->
name|frommin
operator|)
operator|||
operator|(
name|tp
operator|->
name|tm_hour
operator|==
name|cep
operator|->
name|tohr
operator|&&
name|tp
operator|->
name|tm_min
operator|<
name|cep
operator|->
name|tomin
operator|)
condition|)
block|{
name|DBGL
argument_list|(
name|DL_VALID
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"isvalidtime: t>f, spec=%02d:%02d-%02d:%02d, curr=%02d:%02d, match!"
argument_list|,
name|cep
operator|->
name|fromhr
argument_list|,
name|cep
operator|->
name|frommin
argument_list|,
name|cep
operator|->
name|tohr
argument_list|,
name|cep
operator|->
name|tomin
argument_list|,
name|tp
operator|->
name|tm_hour
argument_list|,
name|tp
operator|->
name|tm_min
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|DBGL
argument_list|(
name|DL_VALID
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"isvalidtime: spec=%02d:%02d-%02d:%02d, curr=%02d:%02d, no match!"
argument_list|,
name|cep
operator|->
name|fromhr
argument_list|,
name|cep
operator|->
name|frommin
argument_list|,
name|cep
operator|->
name|tohr
argument_list|,
name|cep
operator|->
name|tomin
argument_list|,
name|tp
operator|->
name|tm_hour
argument_list|,
name|tp
operator|->
name|tm_min
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* EOF */
end_comment

end_unit

