begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 2001 Hellmuth Michaelis. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b daemon - main program entry  *	-------------------------------  *  * $FreeBSD$  *  *      last edit-date: [Tue Jun  5 17:06:20 2001]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
end_ifdef

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAIN
end_define

begin_include
include|#
directive|include
file|"isdnd.h"
end_include

begin_undef
undef|#
directive|undef
name|MAIN
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|I4B_NOTCPIP_MONITOR
end_ifdef

begin_comment
comment|/* monitor via local socket */
end_comment

begin_function_decl
specifier|static
name|void
name|mloop
parameter_list|(
name|int
name|sockfd
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* I4B_NOTCPIP_MONITOR */
end_comment

begin_comment
comment|/* monitor via local and tcp/ip socket */
end_comment

begin_function_decl
specifier|static
name|void
name|mloop
parameter_list|(
name|int
name|localsock
parameter_list|,
name|int
name|remotesock
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I4B_NOTCPIP_MONITOR */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* I4B_EXTERNAL_MONITOR */
end_comment

begin_comment
comment|/* no monitoring at all */
end_comment

begin_function_decl
specifier|static
name|void
name|mloop
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* I4B_EXTERNAL_MONITOR */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_CURSES
end_ifdef

begin_function_decl
specifier|static
name|void
name|kbdrdhdl
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|isdnrdhdl
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MSG_BUF_SIZ
value|1024
end_define

begin_comment
comment|/* message buffer size */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	usage display and exit  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"isdnd - i4b ISDN manager daemon, version %02d.%02d.%d, %s %s\n"
argument_list|,
name|VERSION
argument_list|,
name|REL
argument_list|,
name|STEP
argument_list|,
name|__DATE__
argument_list|,
name|__TIME__
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  usage: isdnd [-c file] [-d level] [-F] [-f [-r dev] [-t termtype]]\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  usage: isdnd [-c file] [-F] [-f [-r dev] [-t termtype]]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"               [-l] [-L file] [-m] [-s facility] [-u time]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -c<filename> configuration file name (def: %s)\n"
argument_list|,
name|CONFIG_FILE_DEF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -d<level>    set debug flag bits:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  general = 0x%04x, rates  = 0x%04x, timing   = 0x%04x\n"
argument_list|,
name|DL_MSG
argument_list|,
name|DL_RATES
argument_list|,
name|DL_TIME
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  state   = 0x%04x, retry  = 0x%04x, dial     = 0x%04x\n"
argument_list|,
name|DL_STATE
argument_list|,
name|DL_RCVRY
argument_list|,
name|DL_DIAL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  process = 0x%04x, kernio = 0x%04x, ctrlstat = 0x%04x\n"
argument_list|,
name|DL_PROC
argument_list|,
name|DL_DRVR
argument_list|,
name|DL_CNST
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                  rc-file = 0x%04x, budget = 0x%04x, valid    = 0x%04x\n"
argument_list|,
name|DL_RCCF
argument_list|,
name|DL_BDGT
argument_list|,
name|DL_VALID
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -dn           no debug output on fullscreen display\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -f            fullscreen status display\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -F            do not become a daemon process\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -l            use a logfile instead of syslog\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -L<file>     use file instead of %s for logging\n"
argument_list|,
name|LOG_FILE_DEF
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -P            pretty print real config to stdout and exit\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -r<device>   redirect output to other device    (for -f)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -s<facility> use facility instead of %d for syslog logging\n"
argument_list|,
name|LOG_LOCAL0
operator|>>
literal|3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -t<termtype> terminal type of redirected screen (for -f)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -u<time>     length of a charging unit in seconds\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -m            inhibit network/local monitoring (protocol %02d.%02d)\n"
argument_list|,
name|MPROT_VERSION
argument_list|,
name|MPROT_REL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	program entry  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|msg_vr_req_t
name|mvr
decl_stmt|;
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|int
name|sockfd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* local monitor socket */
ifndef|#
directive|ifndef
name|I4B_NOTCPIP_MONITOR
name|int
name|remotesockfd
init|=
operator|-
literal|1
decl_stmt|;
comment|/* tcp/ip monitor socket */
endif|#
directive|endif
endif|#
directive|endif
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"mc:d:fFlL:Pr:s:t:u:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
case|case
literal|'m'
case|:
name|inhibit_monitor
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'c'
case|:
name|configfile
operator|=
name|optarg
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
case|case
literal|'d'
case|:
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'n'
condition|)
name|debug_noscreen
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%i"
argument_list|,
operator|&
name|debug_flags
argument_list|)
operator|)
operator|==
literal|1
condition|)
name|do_debug
operator|=
literal|1
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'f'
case|:
name|do_fullscreen
operator|=
literal|1
expr_stmt|;
name|do_fork
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_CURSES
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sorry, no fullscreen mode available - daemon compiled without USE_CURSES\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'F'
case|:
name|do_fork
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|uselogfile
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|strcpy
argument_list|(
name|logfile
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|do_print
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|rdev
operator|=
name|optarg
expr_stmt|;
name|do_rdev
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|optarg
argument_list|)
condition|)
block|{
name|int
name|facility
decl_stmt|;
name|logfacility
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|facility
operator|=
name|logfacility
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|facility
operator|<
name|LOG_KERN
operator|)
operator|||
operator|(
name|facility
operator|>
name|LOG_FTP
operator|&&
name|facility
operator|<
name|LOG_LOCAL0
operator|)
operator|||
operator|(
name|facility
operator|>
name|LOG_LOCAL7
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error, option -s has invalid logging facility %d"
argument_list|,
name|logfacility
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|logfacility
operator|=
name|facility
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: option -s requires a numeric argument!\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|ttype
operator|=
name|optarg
expr_stmt|;
name|do_ttytype
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|optarg
argument_list|)
condition|)
block|{
name|unit_length
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit_length
operator|<
name|ULSRC_CMDLMIN
condition|)
name|unit_length
operator|=
name|ULSRC_CMDLMIN
expr_stmt|;
elseif|else
if|if
condition|(
name|unit_length
operator|>
name|ULSRC_CMDLMAX
condition|)
name|unit_length
operator|=
name|ULSRC_CMDLMAX
expr_stmt|;
name|got_unitlen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: option -T requires a numeric argument!\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|do_debug
condition|)
name|debug_noscreen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|do_print
condition|)
block|{
name|umask
argument_list|(
name|UMASK
argument_list|)
expr_stmt|;
comment|/* set our umask ... */
name|init_log
argument_list|()
expr_stmt|;
comment|/* initialize the logging subsystem */
block|}
name|check_pid
argument_list|()
expr_stmt|;
comment|/* check if we are already running */
if|if
condition|(
operator|!
name|do_print
condition|)
block|{
if|if
condition|(
name|do_fork
operator|||
operator|(
name|do_fullscreen
operator|&&
name|do_rdev
operator|)
condition|)
comment|/* daemon mode ? */
name|daemonize
argument_list|()
expr_stmt|;
name|write_pid
argument_list|()
expr_stmt|;
comment|/* write our pid to file */
comment|/* set signal handler(s) */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchild_handler
argument_list|)
expr_stmt|;
comment|/* process handling	*/
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|rereadconfig
argument_list|)
expr_stmt|;
comment|/* reread configuration	*/
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|reopenfiles
argument_list|)
expr_stmt|;
comment|/* reopen acct/log files*/
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* handled manually	*/
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|do_exit
argument_list|)
expr_stmt|;
comment|/* clean up on SIGINT	*/
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|do_exit
argument_list|)
expr_stmt|;
comment|/* clean up on SIGTERM	*/
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|do_exit
argument_list|)
expr_stmt|;
comment|/* clean up on SIGQUIT	*/
block|}
comment|/* open isdn device */
if|if
condition|(
operator|(
name|isdnfd
operator|=
name|open
argument_list|(
name|I4BDEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"main: cannot open %s: %s"
argument_list|,
name|I4BDEVICE
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* check kernel and userland have same version/release numbers */
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|isdnfd
argument_list|,
name|I4B_VR_REQ
argument_list|,
operator|&
name|mvr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"main: ioctl I4B_VR_REQ failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mvr
operator|.
name|version
operator|!=
name|VERSION
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"main: version mismatch, kernel %d, daemon %d"
argument_list|,
name|mvr
operator|.
name|version
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mvr
operator|.
name|release
operator|!=
name|REL
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"main: release mismatch, kernel %d, daemon %d"
argument_list|,
name|mvr
operator|.
name|release
argument_list|,
name|REL
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mvr
operator|.
name|step
operator|!=
name|STEP
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"main: step mismatch, kernel %d, daemon %d"
argument_list|,
name|mvr
operator|.
name|step
argument_list|,
name|STEP
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* init controller state array */
name|init_controller
argument_list|()
expr_stmt|;
comment|/* read runtime configuration file and configure ourselves */
name|configure
argument_list|(
name|configfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_error_flag
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"there were %d error(s) in the configuration file, terminating!"
argument_list|,
name|config_error_flag
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* set controller ISDN protocol */
name|init_controller_protocol
argument_list|()
expr_stmt|;
comment|/* init active controllers, if any */
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|init_active_controller
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchild_handler
argument_list|)
expr_stmt|;
comment|/*XXX*/
comment|/* handle the rates stuff */
if|if
condition|(
operator|(
name|i
operator|=
name|readrates
argument_list|(
name|ratesfile
argument_list|)
operator|)
operator|==
name|ERROR
condition|)
block|{
if|if
condition|(
name|rate_error
operator|!=
name|NULL
condition|)
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"%s"
argument_list|,
name|rate_error
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|GOOD
condition|)
block|{
name|got_rate
operator|=
literal|1
expr_stmt|;
comment|/* flag, ratesfile read and ok */
name|DBGL
argument_list|(
name|DL_RCCF
argument_list|,
operator|(
name|log
argument_list|(
name|LL_DBG
argument_list|,
literal|"ratesfile %s read successfully"
argument_list|,
name|ratesfile
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rate_error
operator|!=
name|NULL
condition|)
name|log
argument_list|(
name|LL_WRN
argument_list|,
literal|"%s"
argument_list|,
name|rate_error
argument_list|)
expr_stmt|;
block|}
comment|/* if writing accounting info, open file, set unbuffered */
if|if
condition|(
name|useacctfile
condition|)
block|{
if|if
condition|(
operator|(
name|acctfp
operator|=
name|fopen
argument_list|(
name|acctfile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"ERROR, can't open acctfile %s for writing, terminating!"
argument_list|,
name|acctfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setvbuf
argument_list|(
name|acctfp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* initialize alias processing */
if|if
condition|(
name|aliasing
condition|)
name|init_alias
argument_list|(
name|aliasfile
argument_list|)
expr_stmt|;
comment|/* init holidays */
name|init_holidays
argument_list|(
name|holidayfile
argument_list|)
expr_stmt|;
comment|/* init remote monitoring */
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
if|if
condition|(
name|do_monitor
condition|)
block|{
name|monitor_init
argument_list|()
expr_stmt|;
name|sockfd
operator|=
name|monitor_create_local_socket
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|I4B_NOTCPIP_MONITOR
name|remotesockfd
operator|=
name|monitor_create_remote_socket
argument_list|(
name|monitorport
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* in case fullscreendisplay, initialize */
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
block|{
name|init_screen
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* init realtime priority */
ifdef|#
directive|ifdef
name|USE_RTPRIO
if|if
condition|(
name|rt_prio
operator|!=
name|RTPRIO_NOTUSED
condition|)
block|{
name|struct
name|rtprio
name|rtp
decl_stmt|;
name|rtp
operator|.
name|type
operator|=
name|RTP_PRIO_REALTIME
expr_stmt|;
name|rtp
operator|.
name|prio
operator|=
name|rt_prio
expr_stmt|;
if|if
condition|(
operator|(
name|rtprio
argument_list|(
name|RTP_SET
argument_list|,
name|getpid
argument_list|()
argument_list|,
operator|&
name|rtp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"rtprio failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|starttime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* get starttime */
name|srandom
argument_list|(
literal|580403
argument_list|)
expr_stmt|;
comment|/* init random number gen */
name|mloop
argument_list|(
comment|/* enter loop of no return .. */
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|sockfd
ifndef|#
directive|ifndef
name|I4B_NOTCPIP_MONITOR
argument_list|,
name|remotesockfd
endif|#
directive|endif
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|do_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	program exit  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|do_exit
parameter_list|(
name|int
name|exitval
parameter_list|)
block|{
name|close_allactive
argument_list|()
expr_stmt|;
name|unlink
argument_list|(
name|PIDFILE
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LL_DMN
argument_list|,
literal|"daemon terminating, exitval = %d"
argument_list|,
name|exitval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|endwin
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|monitor_exit
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
name|exitval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	program exit  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|error_exit
parameter_list|(
name|int
name|exitval
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|close_allactive
argument_list|()
expr_stmt|;
name|unlink
argument_list|(
name|PIDFILE
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LL_DMN
argument_list|,
literal|"fatal error, daemon terminating, exitval = %d"
argument_list|,
name|exitval
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|endwin
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|monitor_exit
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mailto
index|[
literal|0
index|]
operator|&&
name|mailer
index|[
literal|0
index|]
condition|)
block|{
define|#
directive|define
name|EXITBL
value|2048
name|char
name|ebuffer
index|[
name|EXITBL
index|]
decl_stmt|;
name|char
name|sbuffer
index|[
name|EXITBL
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|ebuffer
argument_list|,
name|EXITBL
operator|-
literal|1
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* remove handler */
name|snprintf
argument_list|(
name|sbuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuffer
argument_list|)
argument_list|,
literal|"%s%s%s%s%s%s%s%s"
argument_list|,
literal|"cat<< ENDOFDATA | "
argument_list|,
name|mailer
argument_list|,
literal|" -s \"i4b isdnd: fatal error, terminating\" "
argument_list|,
name|mailto
argument_list|,
literal|"\nThe isdnd terminated because of a fatal error:\n\n"
argument_list|,
name|ebuffer
argument_list|,
literal|"\n\nYours sincerely,\n   the isdnd\n"
argument_list|,
literal|"\nENDOFDATA\n"
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|sbuffer
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|exitval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	main loop  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|mloop
parameter_list|(
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
name|int
name|localmonitor
ifndef|#
directive|ifndef
name|I4B_NOTCPIP_MONITOR
parameter_list|,
name|int
name|remotemonitor
endif|#
directive|endif
endif|#
directive|endif
parameter_list|)
block|{
name|fd_set
name|set
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|high_selfd
decl_stmt|;
comment|/* go into loop */
name|log
argument_list|(
name|LL_DMN
argument_list|,
literal|"i4b isdn daemon started (pid = %d)"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|do_fullscreen
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|FD_SET
argument_list|(
name|isdnfd
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
name|high_selfd
operator|=
name|isdnfd
expr_stmt|;
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
if|if
condition|(
name|do_monitor
condition|)
block|{
if|if
condition|(
name|localmonitor
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* always watch for new connections */
name|FD_SET
argument_list|(
name|localmonitor
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|localmonitor
operator|>
name|high_selfd
condition|)
name|high_selfd
operator|=
name|localmonitor
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|I4B_NOTCPIP_MONITOR
if|if
condition|(
name|remotemonitor
operator|!=
operator|-
literal|1
condition|)
block|{
name|FD_SET
argument_list|(
name|remotemonitor
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|remotemonitor
operator|>
name|high_selfd
condition|)
name|high_selfd
operator|=
name|remotemonitor
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* if there are client connections, let monitor module 			 * enter them into the fdset */
if|if
condition|(
name|accepted
condition|)
block|{
name|monitor_prepselect
argument_list|(
operator|&
name|set
argument_list|,
operator|&
name|high_selfd
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|timeout
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|select
argument_list|(
name|high_selfd
operator|+
literal|1
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|isdnfd
argument_list|,
operator|&
name|set
argument_list|)
condition|)
name|isdnrdhdl
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_CURSES
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|set
argument_list|)
condition|)
name|kbdrdhdl
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|I4B_EXTERNAL_MONITOR
if|if
condition|(
name|do_monitor
condition|)
block|{
if|if
condition|(
name|localmonitor
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|localmonitor
argument_list|,
operator|&
name|set
argument_list|)
condition|)
name|monitor_handle_connect
argument_list|(
name|localmonitor
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|I4B_NOTCPIP_MONITOR
if|if
condition|(
name|remotemonitor
operator|!=
operator|-
literal|1
operator|&&
name|FD_ISSET
argument_list|(
name|remotemonitor
argument_list|,
operator|&
name|set
argument_list|)
condition|)
name|monitor_handle_connect
argument_list|(
name|remotemonitor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|accepted
condition|)
name|monitor_handle_input
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"mloop: ERROR, select error on isdn device, errno = %d!"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"mloop: ERROR, select error on isdn device, errno = %d!"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* handle timeout and recovery */
name|handle_recovery
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_CURSES
end_ifdef

begin_comment
comment|/*---------------------------------------------------------------------------*  *	data from keyboard available, read and process it   *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|kbdrdhdl
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch
init|=
name|getch
argument_list|()
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|ERR
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"kbdrdhdl: ERROR, read error on controlling tty, errno = %d!"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"kbdrdhdl: ERROR, read error on controlling tty, errno = %d!"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x0c
case|:
comment|/* control L */
name|wrefresh
argument_list|(
name|curscr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
name|do_menu
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	data from /dev/isdn available, read and process them  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|isdnrdhdl
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|msg_rd_buf
index|[
name|MSG_BUF_SIZ
index|]
decl_stmt|;
name|msg_hdr_t
modifier|*
name|hp
init|=
operator|(
name|msg_hdr_t
operator|*
operator|)
operator|&
name|msg_rd_buf
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|isdnfd
argument_list|,
name|msg_rd_buf
argument_list|,
name|MSG_BUF_SIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|hp
operator|->
name|type
condition|)
block|{
case|case
name|MSG_CONNECT_IND
case|:
name|msg_connect_ind
argument_list|(
operator|(
name|msg_connect_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_CONNECT_ACTIVE_IND
case|:
name|msg_connect_active_ind
argument_list|(
operator|(
name|msg_connect_active_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_DISCONNECT_IND
case|:
name|msg_disconnect_ind
argument_list|(
operator|(
name|msg_disconnect_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_DIALOUT_IND
case|:
name|msg_dialout
argument_list|(
operator|(
name|msg_dialout_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_ACCT_IND
case|:
name|msg_accounting
argument_list|(
operator|(
name|msg_accounting_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_IDLE_TIMEOUT_IND
case|:
name|msg_idle_timeout_ind
argument_list|(
operator|(
name|msg_idle_timeout_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_CHARGING_IND
case|:
name|msg_charging_ind
argument_list|(
operator|(
name|msg_charging_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_PROCEEDING_IND
case|:
name|msg_proceeding_ind
argument_list|(
operator|(
name|msg_proceeding_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_ALERT_IND
case|:
name|msg_alert_ind
argument_list|(
operator|(
name|msg_alert_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_DRVRDISC_REQ
case|:
name|msg_drvrdisc_req
argument_list|(
operator|(
name|msg_drvrdisc_req_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_L12STAT_IND
case|:
name|msg_l12stat_ind
argument_list|(
operator|(
name|msg_l12stat_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_TEIASG_IND
case|:
name|msg_teiasg_ind
argument_list|(
operator|(
name|msg_teiasg_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_PDEACT_IND
case|:
name|msg_pdeact_ind
argument_list|(
operator|(
name|msg_pdeact_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_NEGCOMP_IND
case|:
name|msg_negcomplete_ind
argument_list|(
operator|(
name|msg_negcomplete_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_IFSTATE_CHANGED_IND
case|:
name|msg_ifstatechg_ind
argument_list|(
operator|(
name|msg_ifstatechg_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_DIALOUTNUMBER_IND
case|:
name|msg_dialoutnumber
argument_list|(
operator|(
name|msg_dialoutnumber_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_PACKET_IND
case|:
name|msg_packet_ind
argument_list|(
operator|(
name|msg_packet_ind_t
operator|*
operator|)
name|msg_rd_buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LL_WRN
argument_list|,
literal|"ERROR, unknown message received from %sisdn (0x%x)"
argument_list|,
name|_PATH_DEV
argument_list|,
name|msg_rd_buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|log
argument_list|(
name|LL_WRN
argument_list|,
literal|"ERROR, read error on isdn device, errno = %d, length = %d"
argument_list|,
name|errno
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	re-read the config file on SIGHUP or menu command  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|rereadconfig
parameter_list|(
name|int
name|dummy
parameter_list|)
block|{
specifier|extern
name|int
name|entrycount
decl_stmt|;
name|log
argument_list|(
name|LL_DMN
argument_list|,
literal|"re-reading configuration file"
argument_list|)
expr_stmt|;
name|close_allactive
argument_list|()
expr_stmt|;
if|#
directive|if
name|I4B_EXTERNAL_MONITOR
name|monitor_clear_rights
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|entrycount
operator|=
operator|-
literal|1
expr_stmt|;
name|nentries
operator|=
literal|0
expr_stmt|;
comment|/* read runtime configuration file and configure ourselves */
name|configure
argument_list|(
name|configfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_error_flag
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"rereadconfig: there were %d error(s) in the configuration file, terminating!"
argument_list|,
name|config_error_flag
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"rereadconfig: there were %d error(s) in the configuration file, terminating!"
argument_list|,
name|config_error_flag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aliasing
condition|)
block|{
comment|/* reread alias database */
name|free_aliases
argument_list|()
expr_stmt|;
name|init_alias
argument_list|(
name|aliasfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	re-open the log/acct files on SIGUSR1  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|reopenfiles
parameter_list|(
name|int
name|dummy
parameter_list|)
block|{
if|if
condition|(
name|useacctfile
condition|)
block|{
comment|/* close file */
name|fflush
argument_list|(
name|acctfp
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|acctfp
argument_list|)
expr_stmt|;
comment|/* if user specified a suffix, rename the old file */
if|if
condition|(
name|rotatesuffix
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|filename
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|acctfile
argument_list|,
name|rotatesuffix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rename
argument_list|(
name|acctfile
argument_list|,
name|filename
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"reopenfiles: acct rename failed, cause = %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"reopenfiles: acct rename failed, cause = %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|acctfp
operator|=
name|fopen
argument_list|(
name|acctfile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"ERROR, can't open acctfile %s for writing, terminating!"
argument_list|,
name|acctfile
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"ERROR, can't open acctfile %s for writing, terminating!"
argument_list|,
name|acctfile
argument_list|)
expr_stmt|;
block|}
name|setvbuf
argument_list|(
name|acctfp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uselogfile
condition|)
block|{
name|finish_log
argument_list|()
expr_stmt|;
comment|/* if user specified a suffix, rename the old file */
if|if
condition|(
name|rotatesuffix
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|filename
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|logfile
argument_list|,
name|rotatesuffix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rename
argument_list|(
name|logfile
argument_list|,
name|filename
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LL_ERR
argument_list|,
literal|"reopenfiles: log rename failed, cause = %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"reopenfiles: log rename failed, cause = %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|logfp
operator|=
name|fopen
argument_list|(
name|logfile
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR, cannot open logfile %s: %s\n"
argument_list|,
name|logfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error_exit
argument_list|(
literal|1
argument_list|,
literal|"reopenfiles: ERROR, cannot open logfile %s: %s\n"
argument_list|,
name|logfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* set unbuffered operation */
name|setvbuf
argument_list|(
name|logfp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* EOF */
end_comment

end_unit

