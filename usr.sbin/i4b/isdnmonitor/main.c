begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   Copyright (c) 1998,1999 Martin Husemann. All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *   3. Neither the name of the author nor the names of any co-contributors  *      may be used to endorse or promote products derived from this software  *      without specific prior written permission.  *   4. Altered versions must be plainly marked as such, and must not be  *      misrepresented as being the original software and/or documentation.  *     *   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  *   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  *   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  *   SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b daemon - network monitor client  *	-----------------------------------  *  *	$Id: main.c,v 1.35 2000/08/24 11:48:57 hm Exp $  *  * $FreeBSD$  *  *      last edit-date: [Mon Dec 13 21:52:11 1999]  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|getopt
parameter_list|(
name|int
name|nargc
parameter_list|,
name|char
modifier|*
specifier|const
name|nargv
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|ostr
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|close
parameter_list|(
name|f
parameter_list|)
value|closesocket(f)
end_define

begin_define
define|#
directive|define
name|sleep
parameter_list|(
name|s
parameter_list|)
value|Sleep(s*1000)
end_define

begin_define
define|#
directive|define
name|vsnprintf
value|_vsnprintf
end_define

begin_define
define|#
directive|define
name|ssize_t
value|long
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ERROR
end_ifdef

begin_undef
undef|#
directive|undef
name|ERROR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAIN
end_define

begin_include
include|#
directive|include
file|"monprivate.h"
end_include

begin_undef
undef|#
directive|undef
name|MAIN
end_undef

begin_ifndef
ifndef|#
directive|ifndef
name|AF_LOCAL
end_ifndef

begin_define
define|#
directive|define
name|AF_LOCAL
value|AF_UNIX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_comment
comment|/*  * Local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|connect_local
parameter_list|(
name|char
modifier|*
name|sockpath
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|connect_remote
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|portno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mloop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_input
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_menu
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_logevent
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|prio
parameter_list|,
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_charge
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|units
parameter_list|,
name|int
name|estimated
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_connect
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|channel
parameter_list|,
name|char
modifier|*
name|cfgname
parameter_list|,
name|char
modifier|*
name|devname
parameter_list|,
name|char
modifier|*
name|remphone
parameter_list|,
name|char
modifier|*
name|locphone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_disconnect
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_updown
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|contoller
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|isup
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_event
parameter_list|(
name|u_int8_t
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|dump_event
parameter_list|(
name|u_int8_t
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|readflag
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|ssize_t
name|sock_read
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|sock_write
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mprintf
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DBG_DUMPALL
value|0x01
end_define

begin_define
define|#
directive|define
name|DBG_PSEND
value|0x02
end_define

begin_decl_stmt
specifier|static
name|int
name|monsock
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|state
init|=
name|ST_INIT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sub_state
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sub_state_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isdn_major
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|isdn_minor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|rights
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|logfilename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|lfp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*---------------------------------------------------------------------------  *	Display usage and exit  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"isdnmonitor - version %02d.%02d.%d, %s %s (protocol %02d.%02d)\n"
argument_list|,
name|VERSION
argument_list|,
name|REL
argument_list|,
name|STEP
argument_list|,
name|__DATE__
argument_list|,
name|__TIME__
argument_list|,
name|MPROT_VERSION
argument_list|,
name|MPROT_REL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOREIGN
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  usage: isdnmonitor [-c] [-d val] [-f name] [-h host] [-p port]\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  usage: isdnmonitor [-c] [-d val] [-f name] [-h host] [-l path] [-p port]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -c        switch to curses fullscreen output\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -d<val>  debug flags (see source ...)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -dn       no debug output on fullscreen display\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -f<name> filename to log output to\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -h<host> hostname/address to connect to\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FOREIGN
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -l<path> pathname to local domain socket to connect to\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"    -p<port> portnumber to use to connect to remote host\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------  *	Parse command line, startup monitor client  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|WSADATA
name|wsCaps
decl_stmt|;
name|WSAStartup
argument_list|(
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|wsCaps
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|portno
operator|=
name|DEF_MONPORT
expr_stmt|;
name|devbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
ifndef|#
directive|ifndef
name|FOREIGN
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cd:f:h:p:l:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
else|#
directive|else
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"cd:f:h:p:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'c'
case|:
name|fullscreen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
operator|*
name|optarg
operator|==
literal|'n'
condition|)
block|{
name|debug_noscreen
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%i"
argument_list|,
operator|&
name|debug
argument_list|)
operator|)
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'f'
case|:
name|logfilename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|hostname
operator|=
name|optarg
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|FOREIGN
case|case
literal|'l'
case|:
name|sockpath
operator|=
name|optarg
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%i"
argument_list|,
operator|&
name|portno
argument_list|)
operator|)
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|FOREIGN
if|if
condition|(
name|hostname
operator|&&
name|sockpath
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: can not use local socket path on remote machine\n"
literal|"conflicting options -h and -l!\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|sockpath
condition|)
block|{
name|monsock
operator|=
name|connect_local
argument_list|(
name|sockpath
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hostname
condition|)
else|#
directive|else
if|if
condition|(
name|hostname
condition|)
endif|#
directive|endif
block|{
name|monsock
operator|=
name|connect_remote
argument_list|(
name|hostname
argument_list|,
name|portno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|monsock
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not connect to i4b isdn daemon.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|logfilename
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|lfp
operator|=
name|fopen
argument_list|(
name|logfilename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not open logfile [%s], %s\n"
argument_list|,
name|logfilename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|WIN32
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mloop
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|monsock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------  *	Connect via tcp/ip.  *	Return socket if successfull, -1 on error.  ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|connect_remote
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|int
name|portno
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|sa
decl_stmt|;
name|struct
name|hostent
modifier|*
name|h
decl_stmt|;
name|int
name|remotesockfd
decl_stmt|;
name|h
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not resolve hostname '%s'\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|remotesockfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|remotesockfd
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not create remote monitor socket: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_4
name|sa
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sa
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|portno
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sa
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|h
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|remotesockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not connect remote monitor: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|remotesockfd
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FOREIGN
end_ifndef

begin_comment
comment|/*---------------------------------------------------------------------------  *	Connect local.  *	Return socket on success, -1 on failure.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|connect_local
parameter_list|(
name|char
modifier|*
name|sockpath
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|sockaddr_un
name|sa
decl_stmt|;
comment|/* check path length */
if|if
condition|(
name|strlen
argument_list|(
name|sockpath
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|sa
operator|.
name|sun_path
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pathname to long for local socket: %s\n"
argument_list|,
name|sockpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* create and setup socket */
name|s
operator|=
name|socket
argument_list|(
name|AF_LOCAL
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not create local monitor socket:%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sun_len
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sun_family
operator|=
name|AF_LOCAL
expr_stmt|;
name|strcpy
argument_list|(
name|sa
operator|.
name|sun_path
argument_list|,
name|sockpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not connect local monitor socket [%s]: %s\n"
argument_list|,
name|sockpath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------*  *	data from keyboard available, read and process it   *---------------------------------------------------------------------------*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WIN32
end_ifndef

begin_function
specifier|static
name|void
name|kbdrdhdl
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch
init|=
name|getch
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x0c
case|:
comment|/* control L */
name|wrefresh
argument_list|(
name|curscr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
case|case
literal|'\r'
case|:
name|do_menu
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*---------------------------------------------------------------------------  *	main event loop  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|mloop
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|fd_set
name|rd
decl_stmt|,
name|wr
decl_stmt|,
name|ex
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|rd
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|wr
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|rd
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|monsock
argument_list|,
operator|&
name|rd
argument_list|)
expr_stmt|;
name|select
argument_list|(
name|monsock
operator|+
literal|1
argument_list|,
operator|&
name|rd
argument_list|,
operator|&
name|wr
argument_list|,
operator|&
name|ex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|rd
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|fullscreen
operator|&&
name|curses_ready
condition|)
name|kbdrdhdl
argument_list|()
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
operator|!
name|fullscreen
condition|)
name|handle_input
argument_list|()
expr_stmt|;
else|else
name|getchar
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|monsock
argument_list|,
operator|&
name|rd
argument_list|)
condition|)
block|{
name|u_int8_t
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|ret
decl_stmt|;
comment|/* Network transfer may deliver two or more packets concatenated. 			 * Peek at the header and read only one event at a time... */
name|bytes
operator|=
name|recv
argument_list|(
name|monsock
argument_list|,
name|buf
argument_list|,
name|I4B_MON_EVNT_HDR
argument_list|,
name|MSG_PEEK
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|monsock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|curses_ready
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
name|curses_ready
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|mprintf
argument_list|(
literal|"remote isdnd has closed our connection\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"recv error: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|monsock
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|<
name|I4B_MON_EVNT_HDR
condition|)
continue|continue;
comment|/* errh? something must be wrong... */
name|bytes
operator|=
name|I4B_GET_2B
argument_list|(
name|buf
argument_list|,
name|I4B_MON_EVNT_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mloop: socket recv buffer overflow %d!\n"
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* now we know the size, it fits, so lets read it! */
name|ret
operator|=
name|sock_read
argument_list|(
name|monsock
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|monsock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|curses_ready
condition|)
name|endwin
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|mprintf
argument_list|(
literal|"remote isdnd has closed our connection\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|mprintf
argument_list|(
literal|"error reading from isdnd: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DBG_DUMPALL
condition|)
name|dump_event
argument_list|(
name|buf
argument_list|,
name|ret
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|handle_event
argument_list|(
name|buf
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Dump a complete event packet.  */
end_comment

begin_function
specifier|static
name|void
name|dump_event
parameter_list|(
name|u_int8_t
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|read
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|read
condition|)
name|mprintf
argument_list|(
literal|"read from socket:"
argument_list|)
expr_stmt|;
else|else
name|mprintf
argument_list|(
literal|"write to socket:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|0
condition|)
name|mprintf
argument_list|(
literal|"\n%02d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"0x%02x %c  "
argument_list|,
name|msg
index|[
name|i
index|]
argument_list|,
name|isprint
argument_list|(
name|msg
index|[
name|i
index|]
argument_list|)
condition|?
name|msg
index|[
name|i
index|]
else|:
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|mprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|print_logevent
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|prio
parameter_list|,
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"log: %s prio %d what=%s msg=%s\n"
argument_list|,
name|buf
argument_list|,
name|prio
argument_list|,
name|what
argument_list|,
name|msg
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|fullscreen
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|debug_noscreen
operator|)
operator|||
operator|(
name|debug_noscreen
operator|&&
operator|(
operator|(
operator|(
name|strcmp
argument_list|(
name|what
argument_list|,
literal|"DBG"
argument_list|)
operator|)
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/*  * FreeBSD-current integrated ncurses. Since then it is no longer possible  * to write to the last column in the logfilewindow without causing an  * automatic newline to occur resulting in a blank line in that window.  */
ifdef|#
directive|ifdef
name|__FreeBSD__
include|#
directive|include
file|<osreldate.h>
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|400009
warning|#
directive|warning
literal|"FreeBSD ncurses is buggy: write to last column = auto newline!"
name|wprintw
argument_list|(
name|lower_w
argument_list|,
literal|"%s %s %-.*s\n"
argument_list|,
name|buf
argument_list|,
name|what
argument_list|,
name|COLS
operator|-
operator|(
operator|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
operator|+
operator|(
name|strlen
argument_list|(
name|what
argument_list|)
operator|)
operator|+
literal|3
operator|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|#
directive|else
name|wprintw
argument_list|(
name|lower_w
argument_list|,
literal|"%s %s %-.*s\n"
argument_list|,
name|buf
argument_list|,
name|what
argument_list|,
call|(
name|int
call|)
argument_list|(
name|COLS
operator|-
operator|(
operator|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
operator|+
operator|(
name|strlen
argument_list|(
name|what
argument_list|)
operator|)
operator|+
literal|2
operator|)
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wrefresh
argument_list|(
name|lower_w
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|print_charge
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|units
parameter_list|,
name|int
name|estimated
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"%s: controller %d, channel %d, charge = %d%s\n"
argument_list|,
name|buf
argument_list|,
name|controller
argument_list|,
name|channel
argument_list|,
name|units
argument_list|,
name|estimated
condition|?
literal|" (estimated)"
else|:
literal|""
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|fullscreen
condition|)
block|{
if|if
condition|(
name|estimated
condition|)
name|display_ccharge
argument_list|(
name|CHPOS
argument_list|(
name|controller
argument_list|,
name|channel
argument_list|)
argument_list|,
name|units
argument_list|)
expr_stmt|;
else|else
name|display_charge
argument_list|(
name|CHPOS
argument_list|(
name|controller
argument_list|,
name|channel
argument_list|)
argument_list|,
name|units
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Print a connect event.  * A real monitor would allocate state info for "channel" on this  * event.  */
end_comment

begin_function
specifier|static
name|void
name|print_connect
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
comment|/* server time of event */
name|int
name|outgoing
parameter_list|,
comment|/* 0 = incoming, 1 = outgoing */
name|int
name|controller
parameter_list|,
comment|/* controller number */
name|int
name|channel
parameter_list|,
comment|/* channel no, used to identify this connection until disconnect */
name|char
modifier|*
name|cfgname
parameter_list|,
comment|/* name of config entry/connection */
name|char
modifier|*
name|devname
parameter_list|,
comment|/* device used (e.g. isp0) */
name|char
modifier|*
name|remphone
parameter_list|,
comment|/* phone no of remote side */
name|char
modifier|*
name|locphone
parameter_list|)
comment|/* local phone no */
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|channel
operator|==
literal|0
condition|)
name|remstate
index|[
name|controller
index|]
operator|.
name|ch1state
operator|=
literal|1
expr_stmt|;
else|else
name|remstate
index|[
name|controller
index|]
operator|.
name|ch2state
operator|=
literal|1
expr_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outgoing
condition|)
name|mprintf
argument_list|(
literal|"%s: calling out to '%s' [from msn: '%s']"
argument_list|,
name|buf
argument_list|,
name|remphone
argument_list|,
name|locphone
argument_list|)
expr_stmt|;
else|else
name|mprintf
argument_list|(
literal|"%s: incoming call from '%s' [to msn: '%s']"
argument_list|,
name|buf
argument_list|,
name|remphone
argument_list|,
name|locphone
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|", controller %d, channel %d, config '%s' on device '%s'\n"
argument_list|,
name|controller
argument_list|,
name|channel
argument_list|,
name|cfgname
argument_list|,
name|devname
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|fullscreen
condition|)
name|display_connect
argument_list|(
name|CHPOS
argument_list|(
name|controller
argument_list|,
name|channel
argument_list|)
argument_list|,
name|outgoing
argument_list|,
name|cfgname
argument_list|,
name|remphone
argument_list|,
name|devname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Print a disconnect event.  * A real monitor could free the "per connection" state  * for this channel now  */
end_comment

begin_function
specifier|static
name|void
name|print_disconnect
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|channel
operator|==
literal|0
condition|)
name|remstate
index|[
name|controller
index|]
operator|.
name|ch1state
operator|=
literal|0
expr_stmt|;
else|else
name|remstate
index|[
name|controller
index|]
operator|.
name|ch2state
operator|=
literal|0
expr_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"%s: controller %d, channel %d disconnected\n"
argument_list|,
name|buf
argument_list|,
name|controller
argument_list|,
name|channel
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|fullscreen
condition|)
name|display_disconnect
argument_list|(
name|CHPOS
argument_list|(
name|controller
argument_list|,
name|channel
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Print an up- or down event  */
end_comment

begin_function
specifier|static
name|void
name|print_updown
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|isup
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"%s: channel %d is %s\n"
argument_list|,
name|buf
argument_list|,
name|channel
argument_list|,
name|isup
condition|?
literal|"up"
else|:
literal|"down"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print l1 / l2 status  */
end_comment

begin_function
specifier|static
name|void
name|print_l12stat
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|layer
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"%s: layer %d change on controller %d: %s\n"
argument_list|,
name|buf
argument_list|,
name|layer
argument_list|,
name|controller
argument_list|,
name|state
condition|?
literal|"up"
else|:
literal|"down"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|fullscreen
condition|)
name|display_l12stat
argument_list|(
name|controller
argument_list|,
name|layer
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Print TEI  */
end_comment

begin_function
specifier|static
name|void
name|print_tei
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|tei
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"%s: controller %d, TEI is %d\n"
argument_list|,
name|buf
argument_list|,
name|controller
argument_list|,
name|tei
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|fullscreen
condition|)
name|display_tei
argument_list|(
name|controller
argument_list|,
name|tei
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Print accounting information  */
end_comment

begin_function
specifier|static
name|void
name|print_acct
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|obytes
parameter_list|,
name|int
name|obps
parameter_list|,
name|int
name|ibytes
parameter_list|,
name|int
name|ibps
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"%s: controller %d, channel %d: %d obytes, %d obps, %d ibytes, %d ibps\n"
argument_list|,
name|buf
argument_list|,
name|controller
argument_list|,
name|channel
argument_list|,
name|obytes
argument_list|,
name|obps
argument_list|,
name|ibytes
argument_list|,
name|ibps
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|fullscreen
condition|)
name|display_acct
argument_list|(
name|CHPOS
argument_list|(
name|controller
argument_list|,
name|channel
argument_list|)
argument_list|,
name|obytes
argument_list|,
name|obps
argument_list|,
name|ibytes
argument_list|,
name|ibps
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|print_initialization
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|fullscreen
condition|)
block|{
if|if
condition|(
name|curses_ready
operator|==
literal|0
condition|)
name|init_screen
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|print_menu
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dispatch one message received from the daemon.  */
end_comment

begin_function
specifier|static
name|void
name|handle_event
parameter_list|(
name|u_int8_t
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_int8_t
name|cmd
index|[
name|I4B_MON_ICLIENT_SIZE
index|]
decl_stmt|;
name|int
name|local
decl_stmt|;
name|u_int32_t
name|net
decl_stmt|;
name|u_int32_t
name|mask
decl_stmt|;
name|u_int32_t
name|who
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|ST_INIT
case|:
comment|/* initial data */
name|isdn_major
operator|=
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_IDATA_VERSMAJOR
argument_list|)
expr_stmt|;
name|isdn_minor
operator|=
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_IDATA_VERSMINOR
argument_list|)
expr_stmt|;
name|nctrl
operator|=
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_IDATA_NUMCTRL
argument_list|)
expr_stmt|;
name|nentries
operator|=
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_IDATA_NUMENTR
argument_list|)
expr_stmt|;
name|rights
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_IDATA_CLACCESS
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"remote protocol version is %02d.%02d\n"
argument_list|,
name|isdn_major
argument_list|,
name|isdn_minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdn_major
operator|!=
name|MPROT_VERSION
operator|||
name|isdn_minor
operator|!=
name|MPROT_REL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ERROR, remote protocol version mismatch:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tremote major version is %02d, local major version is %02d\n"
argument_list|,
name|isdn_major
argument_list|,
name|MPROT_VERSION
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tremote minor version is %02d, local minor version is %02d\n"
argument_list|,
name|isdn_minor
argument_list|,
name|MPROT_REL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mprintf
argument_list|(
literal|"our rights = 0x%x\n"
argument_list|,
name|rights
argument_list|)
expr_stmt|;
name|sub_state
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nctrl
operator|>
literal|0
condition|)
block|{
name|state
operator|=
name|ST_ICTRL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nentries
operator|>
literal|0
condition|)
block|{
name|state
operator|=
name|ST_IDEV
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|ST_ANYEV
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|print_initialization
argument_list|()
expr_stmt|;
block|}
comment|/* set maximum event mask */
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_CCMD_SETMASK
argument_list|)
expr_stmt|;
name|I4B_PUT_2B
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_ICLIENT_VERMAJOR
argument_list|,
name|MPROT_VERSION
argument_list|)
expr_stmt|;
name|I4B_PUT_2B
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_ICLIENT_VERMINOR
argument_list|,
name|MPROT_REL
argument_list|)
expr_stmt|;
name|I4B_PUT_4B
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_ICLIENT_EVENTS
argument_list|,
operator|~
literal|0U
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DBG_DUMPALL
condition|)
name|dump_event
argument_list|(
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sock_write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sock_write failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST_ICTRL
case|:
comment|/* initial controller list */
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|mprintf
argument_list|(
literal|"%d controller(s) found:\n"
argument_list|,
name|nctrl
argument_list|)
expr_stmt|;
block|}
name|mprintf
argument_list|(
literal|"\tcontroller %d: %s\n"
argument_list|,
name|sub_state
operator|++
argument_list|,
name|msg
operator|+
name|I4B_MON_ICTRL_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_state
operator|>=
name|nctrl
condition|)
block|{
name|sub_state
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nentries
operator|>
literal|0
condition|)
block|{
name|state
operator|=
name|ST_IDEV
expr_stmt|;
comment|/* end of list reached */
block|}
else|else
block|{
name|state
operator|=
name|ST_ANYEV
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|print_initialization
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_IDEV
case|:
comment|/* initial entry devicename list */
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|mprintf
argument_list|(
literal|"%d entries found:\n"
argument_list|,
name|nentries
argument_list|)
expr_stmt|;
block|}
name|mprintf
argument_list|(
literal|"\tentry %d: device %s\n"
argument_list|,
name|sub_state
operator|++
argument_list|,
name|msg
operator|+
name|I4B_MON_IDEV_NAME
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|devbuf
argument_list|,
name|msg
operator|+
name|I4B_MON_IDEV_NAME
argument_list|)
expr_stmt|;
comment|/* strcat(devbuf, " "); */
if|if
condition|(
name|sub_state
operator|>=
name|nentries
condition|)
block|{
name|first
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|ST_ANYEV
expr_stmt|;
comment|/* end of list reached */
name|sub_state
operator|=
literal|0
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|print_initialization
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|ST_ANYEV
case|:
comment|/* any event */
switch|switch
condition|(
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_EVNT
argument_list|)
condition|)
block|{
case|case
name|I4B_MON_DRINI_CODE
case|:
name|state
operator|=
name|ST_RIGHT
expr_stmt|;
comment|/* list of rights entries will follow */
name|sub_state
operator|=
literal|0
expr_stmt|;
name|sub_state_count
operator|=
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DRINI_COUNT
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"monitor rights:\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_DCINI_CODE
case|:
name|state
operator|=
name|ST_CONNS
expr_stmt|;
name|sub_state
operator|=
literal|0
expr_stmt|;
name|sub_state_count
operator|=
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DCINI_COUNT
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"monitor connections:\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_LOGEVNT_CODE
case|:
name|print_logevent
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_LOGEVNT_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_LOGEVNT_PRIO
argument_list|)
argument_list|,
name|msg
operator|+
name|I4B_MON_LOGEVNT_WHAT
argument_list|,
name|msg
operator|+
name|I4B_MON_LOGEVNT_MSG
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_CHRG_CODE
case|:
name|print_charge
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CHRG_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CHRG_CTRL
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CHRG_CHANNEL
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CHRG_UNITS
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CHRG_ESTIMATED
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_CONNECT_CODE
case|:
name|print_connect
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CONNECT_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CONNECT_DIR
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CONNECT_CTRL
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CONNECT_CHANNEL
argument_list|)
argument_list|,
name|msg
operator|+
name|I4B_MON_CONNECT_CFGNAME
argument_list|,
name|msg
operator|+
name|I4B_MON_CONNECT_DEVNAME
argument_list|,
name|msg
operator|+
name|I4B_MON_CONNECT_REMPHONE
argument_list|,
name|msg
operator|+
name|I4B_MON_CONNECT_LOCPHONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_DISCONNECT_CODE
case|:
name|print_disconnect
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DISCONNECT_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DISCONNECT_CTRL
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DISCONNECT_CHANNEL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_UPDOWN_CODE
case|:
name|print_updown
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_UPDOWN_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_UPDOWN_CTRL
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_UPDOWN_CHANNEL
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_UPDOWN_ISUP
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_L12STAT_CODE
case|:
name|print_l12stat
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_L12STAT_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_L12STAT_CTRL
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_L12STAT_LAYER
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_L12STAT_STATE
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_TEI_CODE
case|:
name|print_tei
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_TEI_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_TEI_CTRL
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_TEI_TEI
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_ACCT_CODE
case|:
name|print_acct
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_ACCT_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_ACCT_CTRL
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_ACCT_CHAN
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_ACCT_OBYTES
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_ACCT_OBPS
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_ACCT_IBYTES
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_ACCT_IBPS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|mprintf
argument_list|(
literal|"unknown event code: %d\n"
argument_list|,
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_EVNT
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST_RIGHT
case|:
comment|/* one record in a list of monitor rights */
name|rights
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DR_RIGHTS
argument_list|)
expr_stmt|;
name|net
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DR_NET
argument_list|)
expr_stmt|;
name|mask
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DR_MASK
argument_list|)
expr_stmt|;
name|local
operator|=
name|I4B_GET_1B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DR_LOCAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
block|{
name|mprintf
argument_list|(
literal|"\tlocal: rights = %x\n"
argument_list|,
name|rights
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mprintf
argument_list|(
literal|"\tfrom: %d.%d.%d.%d, mask %d.%d.%d.%d, rights = %x\n"
argument_list|,
operator|(
name|net
operator|>>
literal|24
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|net
operator|>>
literal|16
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|net
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
argument_list|,
name|net
operator|&
literal|0x00ff
argument_list|,
operator|(
name|mask
operator|>>
literal|24
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|mask
operator|>>
literal|16
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|mask
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
argument_list|,
name|mask
operator|&
literal|0x00ff
argument_list|,
name|rights
argument_list|)
expr_stmt|;
block|}
name|sub_state
operator|++
expr_stmt|;
if|if
condition|(
name|sub_state
operator|>=
name|sub_state_count
condition|)
block|{
name|state
operator|=
name|ST_ANYEV
expr_stmt|;
name|print_initialization
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|ST_CONNS
case|:
name|who
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DC_WHO
argument_list|)
expr_stmt|;
name|rights
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DC_RIGHTS
argument_list|)
expr_stmt|;
name|mprintf
argument_list|(
literal|"\tfrom: %d.%d.%d.%d, rights = %x\n"
argument_list|,
operator|(
name|who
operator|>>
literal|24
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|who
operator|>>
literal|16
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|who
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
argument_list|,
name|who
operator|&
literal|0x00ff
argument_list|,
name|rights
argument_list|)
expr_stmt|;
name|sub_state
operator|++
expr_stmt|;
if|if
condition|(
name|sub_state
operator|>=
name|sub_state_count
condition|)
block|{
name|state
operator|=
name|ST_ANYEV
expr_stmt|;
name|print_initialization
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|mprintf
argument_list|(
literal|"unknown event from remote: local state = %d, evnt = %x, len = %d\n"
argument_list|,
name|state
argument_list|,
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_EVNT
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process input from user  */
end_comment

begin_function
specifier|static
name|void
name|handle_input
parameter_list|()
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|channel
decl_stmt|,
name|controller
decl_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|atoi
argument_list|(
name|buf
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
block|{
name|u_int8_t
name|cmd
index|[
name|I4B_MON_DUMPRIGHTS_SIZE
index|]
decl_stmt|;
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_DUMPRIGHTS_CODE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DBG_DUMPALL
condition|)
name|dump_event
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_DUMPRIGHTS_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sock_write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
name|I4B_MON_DUMPRIGHTS_SIZE
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sock_write failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|2
case|:
block|{
name|u_int8_t
name|cmd
index|[
name|I4B_MON_DUMPMCONS_SIZE
index|]
decl_stmt|;
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_DUMPMCONS_CODE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DBG_DUMPALL
condition|)
name|dump_event
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_DUMPMCONS_CODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sock_write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
name|I4B_MON_DUMPMCONS_SIZE
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sock_write failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|3
case|:
block|{
name|u_int8_t
name|cmd
index|[
name|I4B_MON_CFGREREAD_SIZE
index|]
decl_stmt|;
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_CFGREREAD_CODE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DBG_DUMPALL
condition|)
name|dump_event
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_CFGREREAD_CODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sock_write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
name|I4B_MON_CFGREREAD_SIZE
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sock_write failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|4
case|:
block|{
name|u_int8_t
name|cmd
index|[
name|I4B_MON_HANGUP_SIZE
index|]
decl_stmt|;
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_HANGUP_CODE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Which controller you wish to hangup? "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|controller
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|I4B_PUT_4B
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_HANGUP_CTRL
argument_list|,
name|controller
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Which channel do you wish to hangup? "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|channel
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|I4B_PUT_4B
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_HANGUP_CHANNEL
argument_list|,
name|channel
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DBG_DUMPALL
condition|)
name|dump_event
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_HANGUP_CHANNEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sock_write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
name|I4B_MON_HANGUP_SIZE
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sock_write failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|9
case|:
name|close
argument_list|(
name|monsock
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_menu
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|reread
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int8_t
name|cmd
index|[
name|I4B_MON_CFGREREAD_SIZE
index|]
decl_stmt|;
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_CFGREREAD_CODE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DBG_DUMPALL
condition|)
name|dump_event
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_CFGREREAD_CODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sock_write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
name|I4B_MON_CFGREREAD_SIZE
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sock_write failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|hangup
parameter_list|(
name|int
name|ctrl
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
name|u_int8_t
name|cmd
index|[
name|I4B_MON_HANGUP_SIZE
index|]
decl_stmt|;
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_HANGUP_CODE
argument_list|)
expr_stmt|;
name|I4B_PUT_4B
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_HANGUP_CTRL
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
name|I4B_PUT_4B
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_HANGUP_CHANNEL
argument_list|,
name|chan
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DBG_DUMPALL
condition|)
name|dump_event
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_HANGUP_CHANNEL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sock_write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
name|I4B_MON_HANGUP_SIZE
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sock_write failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Display menu  */
end_comment

begin_function
specifier|static
name|void
name|print_menu
parameter_list|()
block|{
if|if
condition|(
operator|!
name|fullscreen
condition|)
block|{
name|printf
argument_list|(
literal|"Menu:<1> display rights,<2> display monitor connections,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<3> reread config file,<4> hangup \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<9> quit isdnmonitor\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|sock_read
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|size_t
name|nleft
decl_stmt|;
name|ssize_t
name|nread
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
name|nleft
operator|=
name|nbytes
expr_stmt|;
while|while
condition|(
name|nleft
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nread
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|ptr
argument_list|,
name|nleft
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|nread
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|nread
operator|==
literal|0
condition|)
block|{
break|break;
comment|/* EOF */
block|}
name|nleft
operator|-=
name|nread
expr_stmt|;
name|ptr
operator|+=
name|nread
expr_stmt|;
block|}
return|return
operator|(
name|nbytes
operator|-
name|nleft
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|sock_write
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|size_t
name|nleft
decl_stmt|;
name|ssize_t
name|nwritten
decl_stmt|;
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
name|nleft
operator|=
name|nbytes
expr_stmt|;
while|while
condition|(
name|nleft
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nwritten
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|ptr
argument_list|,
name|nleft
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|nwritten
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|nleft
operator|-=
name|nwritten
expr_stmt|;
name|ptr
operator|+=
name|nwritten
expr_stmt|;
block|}
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mprintf
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
define|#
directive|define
name|PRBUFLEN
value|1024
name|char
name|buffer
index|[
name|PRBUFLEN
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buffer
argument_list|,
name|PRBUFLEN
operator|-
literal|1
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fullscreen
operator|||
operator|(
name|fullscreen
operator|&&
operator|(
operator|!
name|curses_ready
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|logfilename
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|lfp
argument_list|,
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|lfp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* EOF */
end_comment

end_unit

