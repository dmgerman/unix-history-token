begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *   Copyright (c) 1998 Martin Husemann. All rights reserved.  *  *   Redistribution and use in source and binary forms, with or without  *   modification, are permitted provided that the following conditions  *   are met:  *  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *   3. Neither the name of the author nor the names of any co-contributors  *      may be used to endorse or promote products derived from this software  *      without specific prior written permission.  *   4. Altered versions must be plainly marked as such, and must not be  *      misrepresented as being the original software and/or documentation.  *     *   THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  *   ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  *   ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  *   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  *   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  *   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  *   SUCH DAMAGE.  *  *---------------------------------------------------------------------------  *  *	i4b daemon - network monitor client  *	-----------------------------------  *  * $FreeBSD$  *  *      last edit-date: [Tue Oct 27 11:53:12 1998]  *  *	-mh	created  *	-hm	checking in  *	-hm	porting to HPUX  *	-mh	all events the fullscreen mode displays now as monitor event  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<machine/i4b_ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__hpux
end_ifdef

begin_define
define|#
directive|define
name|AF_LOCAL
value|AF_UNIX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_comment
comment|/*  * Local function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|connect_local
parameter_list|(
specifier|const
name|char
modifier|*
name|sockpath
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|connect_remote
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|int
name|portno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mloop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_input
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_menu
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_logevent
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|prio
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_charge
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|units
parameter_list|,
name|int
name|estimated
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_connect
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|dir
parameter_list|,
name|int
name|channel
parameter_list|,
specifier|const
name|char
modifier|*
name|cfgname
parameter_list|,
specifier|const
name|char
modifier|*
name|devname
parameter_list|,
specifier|const
name|char
modifier|*
name|remphone
parameter_list|,
specifier|const
name|char
modifier|*
name|locphone
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_disconnect
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_updown
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|isup
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_event
parameter_list|(
name|BYTE
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|dump_event
parameter_list|(
name|BYTE
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dumpall
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|monsock
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|state
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sub_state
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sub_state_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|major
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|minor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nctrl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|rights
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Parse command line, startup monitor client  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|sockpath
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|hostname
init|=
name|NULL
decl_stmt|;
name|int
name|portno
init|=
name|DEF_MONPORT
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"dh:p:l:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'d'
case|:
name|dumpall
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|hostname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|sockpath
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
operator|(
name|sscanf
argument_list|(
name|optarg
argument_list|,
literal|"%i"
argument_list|,
operator|&
name|portno
argument_list|)
operator|)
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|hostname
operator|&&
name|sockpath
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: can not use local socket path on remote machine\n"
literal|"conflicting options -h and -l!\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|sockpath
condition|)
block|{
name|monsock
operator|=
name|connect_local
argument_list|(
name|sockpath
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hostname
condition|)
block|{
name|monsock
operator|=
name|connect_remote
argument_list|(
name|hostname
argument_list|,
name|portno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|monsock
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not connect to i4b isdn daemon.\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|mloop
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|monsock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Display usage and exit  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:\n"
literal|"    isdnmonitor [-d] -h (host) -p (port)\n"
literal|"or\n"
literal|"    isdnmonitor [-d] -l (path)\n"
literal|"where (host) is the hostname and (port) the port number of\n"
literal|"the isdnd to be monitored and (path) is the pathname of the\n"
literal|"local domain socket used to communicate with a daemon on the\n"
literal|"local machine.\n"
literal|"Options are:\n"
literal|" -d  dump all incoming packets as hexdump\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Connect via tcp/ip.  * Return socket if successfull, -1 on error.  */
end_comment

begin_function
specifier|static
name|int
name|connect_remote
parameter_list|(
specifier|const
name|char
modifier|*
name|host
parameter_list|,
name|int
name|portno
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|sa
decl_stmt|;
name|struct
name|hostent
modifier|*
name|h
decl_stmt|;
name|int
name|remotesockfd
decl_stmt|;
name|h
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not resolve hostname '%s'\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|remotesockfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|remotesockfd
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not create remote monitor socket: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_4
name|sa
operator|.
name|sin_len
operator|=
sizeof|sizeof
name|sa
expr_stmt|;
endif|#
directive|endif
name|sa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sa
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|portno
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sa
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|h
operator|->
name|h_addr_list
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
name|sa
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|remotesockfd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not connect remote monitor: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|remotesockfd
return|;
block|}
end_function

begin_comment
comment|/*  * Connect local.  * Return socket on success, -1 on failure.  */
end_comment

begin_function
specifier|static
name|int
name|connect_local
parameter_list|(
specifier|const
name|char
modifier|*
name|sockpath
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|sockaddr_un
name|sa
decl_stmt|;
comment|/* check path length */
if|if
condition|(
name|strlen
argument_list|(
name|sockpath
argument_list|)
operator|>=
sizeof|sizeof
name|sa
operator|.
name|sun_path
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pathname to long for local socket: %s\n"
argument_list|,
name|sockpath
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* create and setup socket */
name|s
operator|=
name|socket
argument_list|(
name|AF_LOCAL
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not create local monitor socket:%s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__hpux
name|sa
operator|.
name|sun_len
operator|=
sizeof|sizeof
name|sa
expr_stmt|;
endif|#
directive|endif
name|sa
operator|.
name|sun_family
operator|=
name|AF_LOCAL
expr_stmt|;
name|strcpy
argument_list|(
name|sa
operator|.
name|sun_path
argument_list|,
name|sockpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"could not connect local monitor socket [%s]: %s\n"
argument_list|,
name|sockpath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/*  * main event loop  */
end_comment

begin_function
specifier|static
name|void
name|mloop
parameter_list|()
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|fd_set
name|rd
decl_stmt|,
name|wr
decl_stmt|,
name|ex
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|rd
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|wr
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|ex
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|rd
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|monsock
argument_list|,
operator|&
name|rd
argument_list|)
expr_stmt|;
name|select
argument_list|(
name|monsock
operator|+
literal|1
argument_list|,
operator|&
name|rd
argument_list|,
operator|&
name|wr
argument_list|,
operator|&
name|ex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|rd
argument_list|)
condition|)
block|{
name|handle_input
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|monsock
argument_list|,
operator|&
name|rd
argument_list|)
condition|)
block|{
name|BYTE
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|u_long
name|u
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|ret
decl_stmt|;
comment|/* Network transfer may deliver two or more packets concatenated. 			 * Peek at the header and read only one event at a time... */
name|ioctl
argument_list|(
name|monsock
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
operator|<
name|I4B_MON_EVNT_HDR
condition|)
continue|continue;
comment|/* not enough data there yet */
name|bytes
operator|=
name|recv
argument_list|(
name|monsock
argument_list|,
name|buf
argument_list|,
name|I4B_MON_EVNT_HDR
argument_list|,
name|MSG_PEEK
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
name|I4B_MON_EVNT_HDR
condition|)
continue|continue;
comment|/* errh? something must be wrong... */
name|bytes
operator|=
name|I4B_GET_2B
argument_list|(
name|buf
argument_list|,
name|I4B_MON_EVNT_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>=
sizeof|sizeof
name|buf
condition|)
break|break;
comment|/* now we know the size, it fits, so lets read it! */
name|ret
operator|=
name|read
argument_list|(
name|monsock
argument_list|,
name|buf
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"remote isdnd has closed our connection\n"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"error reading from isdnd: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|dumpall
condition|)
name|dump_event
argument_list|(
name|buf
argument_list|,
name|ret
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|handle_event
argument_list|(
name|buf
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Dump a complete event packet.  */
end_comment

begin_function
specifier|static
name|void
name|dump_event
parameter_list|(
name|BYTE
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"event dump:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n%02x: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x %c  "
argument_list|,
name|msg
index|[
name|i
index|]
argument_list|,
name|isprint
argument_list|(
name|msg
index|[
name|i
index|]
argument_list|)
condition|?
name|msg
index|[
name|i
index|]
else|:
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|print_logevent
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|prio
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"log: %s prio %d what=%s msg=%s\n"
argument_list|,
name|buf
argument_list|,
name|prio
argument_list|,
name|what
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_charge
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|units
parameter_list|,
name|int
name|estimated
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: channel %d, charge = %d%s\n"
argument_list|,
name|buf
argument_list|,
name|channel
argument_list|,
name|units
argument_list|,
name|estimated
condition|?
literal|" (estimated)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a connect event.  * A real monitor would allocate state info for "channel" on this  * event.  */
end_comment

begin_function
specifier|static
name|void
name|print_connect
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
comment|/* server time of event */
name|int
name|outgoing
parameter_list|,
comment|/* 0 = incoming, 1 = outgoing */
name|int
name|channel
parameter_list|,
comment|/* channel no, used to identify this connection until disconnect */
specifier|const
name|char
modifier|*
name|cfgname
parameter_list|,
comment|/* name of config entry/connection */
specifier|const
name|char
modifier|*
name|devname
parameter_list|,
comment|/* device used (e.g. isp0) */
specifier|const
name|char
modifier|*
name|remphone
parameter_list|,
comment|/* phone no of remote side */
specifier|const
name|char
modifier|*
name|locphone
parameter_list|)
comment|/* local phone no */
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|outgoing
condition|)
name|printf
argument_list|(
literal|"%s: calling out to '%s' [from msn: '%s']"
argument_list|,
name|buf
argument_list|,
name|remphone
argument_list|,
name|locphone
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s: incoming call from '%s' [to msn: '%s']"
argument_list|,
name|buf
argument_list|,
name|remphone
argument_list|,
name|locphone
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", channel %d, config '%s' on device '%s'\n"
argument_list|,
name|channel
argument_list|,
name|cfgname
argument_list|,
name|devname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a disconnect event.  * A real monitor could free the "per connection" state  * for this channel now  */
end_comment

begin_function
specifier|static
name|void
name|print_disconnect
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: channel %d disconnected\n"
argument_list|,
name|buf
argument_list|,
name|channel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print an up- or down event  */
end_comment

begin_function
specifier|static
name|void
name|print_updown
parameter_list|(
name|time_t
name|tstamp
parameter_list|,
name|int
name|channel
parameter_list|,
name|int
name|isup
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|I4B_TIME_FORMAT
argument_list|,
name|localtime
argument_list|(
operator|&
name|tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: channel %d is %s\n"
argument_list|,
name|buf
argument_list|,
name|channel
argument_list|,
name|isup
condition|?
literal|"up"
else|:
literal|"down"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch one message received from the daemon.  */
end_comment

begin_function
specifier|static
name|void
name|handle_event
parameter_list|(
name|BYTE
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|BYTE
name|cmd
index|[
name|I4B_MON_ICLIENT_SIZE
index|]
decl_stmt|;
name|int
name|local
decl_stmt|;
name|u_int32_t
name|net
decl_stmt|;
name|u_int32_t
name|mask
decl_stmt|;
name|u_int32_t
name|who
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
literal|0
case|:
comment|/* initial data */
name|major
operator|=
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_IDATA_VERSMAJOR
argument_list|)
expr_stmt|;
name|minor
operator|=
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_IDATA_VERSMINOR
argument_list|)
expr_stmt|;
name|nctrl
operator|=
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_IDATA_NUMCTRL
argument_list|)
expr_stmt|;
name|rights
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_IDATA_CLACCESS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"remote protocol version is %02d.%02d, %d controller(s) found, our rights = %x\n"
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|nctrl
argument_list|,
name|rights
argument_list|)
expr_stmt|;
if|if
condition|(
name|nctrl
operator|>
literal|0
condition|)
block|{
name|state
operator|=
literal|1
expr_stmt|;
name|sub_state
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
literal|2
expr_stmt|;
comment|/* show menu for the first time */
name|print_menu
argument_list|()
expr_stmt|;
block|}
comment|/* set maximum event mask */
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_CCMD_SETMASK
argument_list|)
expr_stmt|;
name|I4B_PUT_2B
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_ICLIENT_VERMAJOR
argument_list|,
name|MPROT_VERSION
argument_list|)
expr_stmt|;
name|I4B_PUT_2B
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_ICLIENT_VERMINOR
argument_list|,
name|MPROT_REL
argument_list|)
expr_stmt|;
name|I4B_PUT_4B
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_ICLIENT_EVENTS
argument_list|,
operator|~
literal|0U
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* initial controller list */
name|printf
argument_list|(
literal|"controller %d: %s\n"
argument_list|,
name|sub_state
operator|++
argument_list|,
name|msg
operator|+
name|I4B_MON_ICTRL_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_state
operator|>=
name|nctrl
condition|)
block|{
name|state
operator|=
literal|2
expr_stmt|;
comment|/* end of list reached */
name|sub_state
operator|=
literal|0
expr_stmt|;
comment|/* show menu for the first time */
name|print_menu
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* any event */
switch|switch
condition|(
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_EVNT
argument_list|)
condition|)
block|{
case|case
name|I4B_MON_DRINI_CODE
case|:
name|state
operator|=
literal|3
expr_stmt|;
comment|/* list of rights entries will follow */
name|sub_state
operator|=
literal|0
expr_stmt|;
name|sub_state_count
operator|=
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DRINI_COUNT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"monitor rights:\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_DCINI_CODE
case|:
name|state
operator|=
literal|4
expr_stmt|;
name|sub_state
operator|=
literal|0
expr_stmt|;
name|sub_state_count
operator|=
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DCINI_COUNT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"monitor connections:\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_LOGEVNT_CODE
case|:
name|print_logevent
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_LOGEVNT_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_LOGEVNT_PRIO
argument_list|)
argument_list|,
name|msg
operator|+
name|I4B_MON_LOGEVNT_WHAT
argument_list|,
name|msg
operator|+
name|I4B_MON_LOGEVNT_MSG
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_CHRG_CODE
case|:
name|print_charge
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CHRG_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CHRG_CHANNEL
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CHRG_UNITS
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CHRG_ESTIMATED
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_CONNECT_CODE
case|:
name|print_connect
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CONNECT_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CONNECT_DIR
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_CONNECT_CHANNEL
argument_list|)
argument_list|,
name|msg
operator|+
name|I4B_MON_CONNECT_CFGNAME
argument_list|,
name|msg
operator|+
name|I4B_MON_CONNECT_DEVNAME
argument_list|,
name|msg
operator|+
name|I4B_MON_CONNECT_REMPHONE
argument_list|,
name|msg
operator|+
name|I4B_MON_CONNECT_LOCPHONE
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_DISCONNECT_CODE
case|:
name|print_disconnect
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DISCONNECT_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DISCONNECT_CHANNEL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|I4B_MON_UPDOWN_CODE
case|:
name|print_updown
argument_list|(
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_UPDOWN_TSTAMP
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_UPDOWN_CHANNEL
argument_list|)
argument_list|,
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_UPDOWN_ISUP
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown event code: %d\n"
argument_list|,
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_EVNT
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
comment|/* one record in a list of monitor rights */
name|rights
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DR_RIGHTS
argument_list|)
expr_stmt|;
name|net
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DR_NET
argument_list|)
expr_stmt|;
name|mask
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DR_MASK
argument_list|)
expr_stmt|;
name|local
operator|=
name|I4B_GET_1B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DR_LOCAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|local
condition|)
block|{
name|printf
argument_list|(
literal|"\tlocal: rights = %x\n"
argument_list|,
name|rights
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\tfrom: %d.%d.%d.%d, mask %d.%d.%d.%d, rights = %x\n"
argument_list|,
operator|(
name|net
operator|>>
literal|24
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|net
operator|>>
literal|16
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|net
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
argument_list|,
name|net
operator|&
literal|0x00ff
argument_list|,
operator|(
name|mask
operator|>>
literal|24
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|mask
operator|>>
literal|16
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|mask
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
argument_list|,
name|mask
operator|&
literal|0x00ff
argument_list|,
name|rights
argument_list|)
expr_stmt|;
block|}
name|sub_state
operator|++
expr_stmt|;
if|if
condition|(
name|sub_state
operator|>=
name|sub_state_count
condition|)
block|{
name|state
operator|=
literal|2
expr_stmt|;
name|print_menu
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
name|who
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DC_WHO
argument_list|)
expr_stmt|;
name|rights
operator|=
name|I4B_GET_4B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_DC_RIGHTS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tfrom: %d.%d.%d.%d, rights = %x\n"
argument_list|,
operator|(
name|who
operator|>>
literal|24
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|who
operator|>>
literal|16
operator|)
operator|&
literal|0x00ff
argument_list|,
operator|(
name|who
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
argument_list|,
name|who
operator|&
literal|0x00ff
argument_list|,
name|rights
argument_list|)
expr_stmt|;
name|sub_state
operator|++
expr_stmt|;
if|if
condition|(
name|sub_state
operator|>=
name|sub_state_count
condition|)
block|{
name|state
operator|=
literal|2
expr_stmt|;
name|print_menu
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown event from remote: local state = %d, evnt = %x, len = %d\n"
argument_list|,
name|state
argument_list|,
name|I4B_GET_2B
argument_list|(
name|msg
argument_list|,
name|I4B_MON_EVNT
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process input from user  */
end_comment

begin_function
specifier|static
name|void
name|handle_input
parameter_list|()
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|channel
decl_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|atoi
argument_list|(
name|buf
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
block|{
name|BYTE
name|cmd
index|[
name|I4B_MON_DUMPRIGHTS_SIZE
index|]
decl_stmt|;
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_DUMPRIGHTS_CODE
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
name|I4B_MON_DUMPRIGHTS_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
block|{
name|BYTE
name|cmd
index|[
name|I4B_MON_DUMPMCONS_SIZE
index|]
decl_stmt|;
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_DUMPMCONS_CODE
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
name|I4B_MON_DUMPMCONS_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
block|{
name|BYTE
name|cmd
index|[
name|I4B_MON_CFGREREAD_SIZE
index|]
decl_stmt|;
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_CFGREREAD_CODE
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
name|I4B_MON_CFGREREAD_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|4
case|:
block|{
name|BYTE
name|cmd
index|[
name|I4B_MON_HANGUP_SIZE
index|]
decl_stmt|;
name|I4B_PREP_CMD
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_HANGUP_CODE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Which channel do you wish to hangup? "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|channel
operator|=
name|atoi
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|I4B_PUT_4B
argument_list|(
name|cmd
argument_list|,
name|I4B_MON_HANGUP_CHANNEL
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|monsock
argument_list|,
name|cmd
argument_list|,
name|I4B_MON_HANGUP_SIZE
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|9
case|:
name|close
argument_list|(
name|monsock
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_menu
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Display menu  */
end_comment

begin_function
specifier|static
name|void
name|print_menu
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Menu:<1> display rights,<2> display monitor connections,\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<3> reread config file,<4> hangup \n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<9> quit isdnmonitor\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

