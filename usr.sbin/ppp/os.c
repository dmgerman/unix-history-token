begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	      PPP OS Layer Interface Module  *  *	    Written by Toshiharu OHNO (tony-o@iij.ad.jp)  *  *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the Internet Initiative Japan, Inc.  The name of the  * IIJ may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * $Id: os.c,v 1.7.2.5 1997/05/19 02:02:26 brian Exp $  *  */
end_comment

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_if
if|#
directive|if
name|BSD
operator|>=
literal|199206
operator|||
name|_BSDI_VERSION
operator|>=
literal|199312
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_tun.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"os.h"
end_include

begin_include
include|#
directive|include
file|"vars.h"
end_include

begin_include
include|#
directive|include
file|"arp.h"
end_include

begin_include
include|#
directive|include
file|"systems.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|ifaliasreq
name|ifra
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ifreq
name|ifrq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|in_addr
name|oldmine
decl_stmt|,
name|oldhis
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|linkup
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|bsdi
end_ifdef

begin_function_decl
specifier|extern
name|char
modifier|*
name|inet_ntoa
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|HangupModem
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|IfDevName
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|SetIpDevice
parameter_list|(
name|myaddr
parameter_list|,
name|hisaddr
parameter_list|,
name|netmask
parameter_list|,
name|updown
parameter_list|)
name|struct
name|in_addr
name|myaddr
decl_stmt|,
name|hisaddr
decl_stmt|,
name|netmask
decl_stmt|;
name|int
name|updown
decl_stmt|;
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|changeaddr
init|=
literal|0
decl_stmt|;
name|u_long
name|mask
decl_stmt|,
name|addr
decl_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|updown
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|Enabled
argument_list|(
name|ConfProxy
argument_list|)
condition|)
name|cifproxyarp
argument_list|(
name|s
argument_list|,
name|oldhis
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldmine
operator|.
name|s_addr
operator|==
literal|0
operator|&&
name|oldhis
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|ifra
operator|.
name|ifra_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ifra
operator|.
name|ifra_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ifra
operator|.
name|ifra_broadaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ifra
operator|.
name|ifra_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ifra
operator|.
name|ifra_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|ifra
operator|.
name|ifra_addr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|logprintf
argument_list|(
literal|"DIFADDR\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCDIFADDR
argument_list|,
operator|&
name|ifra
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"SIOCDIFADDR"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|oldmine
operator|.
name|s_addr
operator|=
name|oldhis
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/*      * If given addresses are alreay set, then ignore this request.      */
if|if
condition|(
name|oldmine
operator|.
name|s_addr
operator|==
name|myaddr
operator|.
name|s_addr
operator|&&
name|oldhis
operator|.
name|s_addr
operator|==
name|hisaddr
operator|.
name|s_addr
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * If different address has been set, then delete it first.      */
if|if
condition|(
name|oldmine
operator|.
name|s_addr
operator|||
name|oldhis
operator|.
name|s_addr
condition|)
block|{
name|changeaddr
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      *  Set interface address      */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifra
operator|.
name|ifra_addr
operator|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|oldmine
operator|=
name|myaddr
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
comment|/*      *  Set destination address      */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifra
operator|.
name|ifra_broadaddr
operator|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|oldhis
operator|=
name|hisaddr
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
comment|/*      */
name|addr
operator|=
name|ntohl
argument_list|(
name|myaddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|addr
argument_list|)
condition|)
name|mask
operator|=
name|IN_CLASSA_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|addr
argument_list|)
condition|)
name|mask
operator|=
name|IN_CLASSB_NET
expr_stmt|;
else|else
name|mask
operator|=
name|IN_CLASSC_NET
expr_stmt|;
comment|/*      *  if subnet mask is given, use it instead of class mask.      */
if|if
condition|(
name|netmask
operator|.
name|s_addr
operator|&&
operator|(
name|ntohl
argument_list|(
name|netmask
operator|.
name|s_addr
argument_list|)
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
name|mask
operator|=
name|ntohl
argument_list|(
name|netmask
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifra
operator|.
name|ifra_mask
operator|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|changeaddr
condition|)
block|{
comment|/*        * Interface already exists. Just change the address.        */
name|bcopy
argument_list|(
operator|&
name|ifra
operator|.
name|ifra_addr
argument_list|,
operator|&
name|ifrq
operator|.
name|ifr_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSIFADDR
argument_list|,
operator|&
name|ifra
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"SIFADDR"
argument_list|)
expr_stmt|;
empty_stmt|;
name|bcopy
argument_list|(
operator|&
name|ifra
operator|.
name|ifra_broadaddr
argument_list|,
operator|&
name|ifrq
operator|.
name|ifr_dstaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSIFDSTADDR
argument_list|,
operator|&
name|ifrq
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"SIFDSTADDR"
argument_list|)
expr_stmt|;
empty_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|bcopy
argument_list|(
operator|&
name|ifra
operator|.
name|ifra_mask
argument_list|,
operator|&
name|ifrq
operator|.
name|ifr_broadaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSIFBRDADDR
argument_list|,
operator|&
name|ifrq
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"SIFBRDADDR"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCAIFADDR
argument_list|,
operator|&
name|ifra
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"SIOCAIFADDR"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|Enabled
argument_list|(
name|ConfProxy
argument_list|)
condition|)
name|sifproxyarp
argument_list|(
name|s
argument_list|,
name|hisaddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|OsSetIpaddress
parameter_list|(
name|myaddr
parameter_list|,
name|hisaddr
parameter_list|,
name|netmask
parameter_list|)
name|struct
name|in_addr
name|myaddr
decl_stmt|,
name|hisaddr
decl_stmt|,
name|netmask
decl_stmt|;
block|{
return|return
operator|(
name|SetIpDevice
argument_list|(
name|myaddr
argument_list|,
name|hisaddr
argument_list|,
name|netmask
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|in_addr
name|peer_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_addr
name|defaddr
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|OsLinkup
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|linkup
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|setuid
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|logprintf
argument_list|(
literal|"setuid failed\n"
argument_list|)
expr_stmt|;
name|reconnectState
operator|=
name|RECON_UNKNOWN
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|MODE_BACKGROUND
operator|&&
name|BGFiledes
index|[
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|char
name|c
init|=
name|EX_NORMAL
decl_stmt|;
if|if
condition|(
name|write
argument_list|(
name|BGFiledes
index|[
literal|1
index|]
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|LogPrintf
argument_list|(
name|LOG_PHASE_BIT
argument_list|,
literal|"Parent notified of success.\n"
argument_list|)
expr_stmt|;
else|else
name|LogPrintf
argument_list|(
name|LOG_PHASE_BIT
argument_list|,
literal|"Failed to notify parent of success.\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|BGFiledes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|BGFiledes
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|peer_addr
operator|=
name|IpcpInfo
operator|.
name|his_ipaddr
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|inet_ntoa
argument_list|(
name|peer_addr
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LOG_LINK_BIT
operator||
name|LOG_LCP_BIT
argument_list|,
literal|"OsLinkup: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|SelectSystem
argument_list|(
name|inet_ntoa
argument_list|(
name|IpcpInfo
operator|.
name|want_ipaddr
argument_list|)
argument_list|,
name|LINKFILE
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|dstsystem
condition|)
block|{
if|if
condition|(
name|SelectSystem
argument_list|(
name|dstsystem
argument_list|,
name|LINKFILE
argument_list|)
operator|<
literal|0
condition|)
name|SelectSystem
argument_list|(
literal|"MYADDR"
argument_list|,
name|LINKFILE
argument_list|)
expr_stmt|;
block|}
else|else
name|SelectSystem
argument_list|(
literal|"MYADDR"
argument_list|,
name|LINKFILE
argument_list|)
expr_stmt|;
block|}
name|linkup
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|OsLinkdown
parameter_list|()
block|{
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|linkup
condition|)
block|{
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|inet_ntoa
argument_list|(
name|peer_addr
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LOG_LINK_BIT
operator||
name|LOG_LCP_BIT
argument_list|,
literal|"OsLinkdown: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|MODE_AUTO
operator|)
condition|)
name|DeleteIfRoutes
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|linkup
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|OsInterfaceDown
parameter_list|(
name|final
parameter_list|)
name|int
name|final
decl_stmt|;
block|{
name|struct
name|in_addr
name|zeroaddr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|OsLinkdown
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|final
operator|&&
operator|(
name|mode
operator|&
name|MODE_AUTO
operator|)
condition|)
comment|/* We still want interface alive */
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ifrq
operator|.
name|ifr_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifrq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"SIOCSIFFLAGS"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|zeroaddr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|SetIpDevice
argument_list|(
name|zeroaddr
argument_list|,
name|zeroaddr
argument_list|,
name|zeroaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|OsSetInterfaceParams
parameter_list|(
name|type
parameter_list|,
name|mtu
parameter_list|,
name|speed
parameter_list|)
name|int
name|type
decl_stmt|,
name|mtu
decl_stmt|,
name|speed
decl_stmt|;
block|{
name|struct
name|tuninfo
name|info
decl_stmt|;
name|info
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|info
operator|.
name|mtu
operator|=
name|mtu
expr_stmt|;
name|info
operator|.
name|baudrate
operator|=
name|speed
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|tun_out
argument_list|,
name|TUNSIFINFO
argument_list|,
operator|&
name|info
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"TUNSIFINFO"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Open tunnel device and returns its descriptor  */
end_comment

begin_define
define|#
directive|define
name|MAX_TUN
value|256
end_define

begin_comment
comment|/* MAX_TUN is set at an arbitrarily large value  *  * as the loop aborts when it reaches the first  *  * 'Device not configured' (ENXIO), or the third *  * 'No such file or directory' (ENOENT) error.   */
end_comment

begin_function
name|int
name|OpenTunnel
parameter_list|(
name|ptun
parameter_list|)
name|int
modifier|*
name|ptun
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
specifier|static
name|char
name|devname
index|[
literal|14
index|]
decl_stmt|;
comment|/* sufficient room for "/dev/tun65535" */
name|unsigned
name|unit
decl_stmt|,
name|enoentcount
init|=
literal|0
decl_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<=
name|MAX_TUN
condition|;
name|unit
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|devname
argument_list|,
sizeof|sizeof
argument_list|(
name|devname
argument_list|)
argument_list|,
literal|"/dev/tun%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|tun_out
operator|=
name|open
argument_list|(
name|devname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|tun_out
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|errno
operator|==
name|ENXIO
condition|)
name|unit
operator|=
name|MAX_TUN
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|enoentcount
operator|++
expr_stmt|;
if|if
condition|(
name|enoentcount
operator|>
literal|2
condition|)
name|unit
operator|=
name|MAX_TUN
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unit
operator|>
name|MAX_TUN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No tunnel device is available.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|ptun
operator|=
name|unit
expr_stmt|;
if|if
condition|(
name|logptr
operator|!=
name|NULL
condition|)
name|LogClose
argument_list|()
expr_stmt|;
if|if
condition|(
name|LogOpen
argument_list|(
name|unit
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*    * At first, name the interface.    */
name|strncpy
argument_list|(
name|ifname
argument_list|,
name|devname
operator|+
literal|5
argument_list|,
name|IFNAMSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ifra
argument_list|,
sizeof|sizeof
argument_list|(
name|ifra
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ifrq
argument_list|,
sizeof|sizeof
argument_list|(
name|ifrq
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifrq
operator|.
name|ifr_name
argument_list|,
name|ifname
argument_list|,
name|IFNAMSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifra
operator|.
name|ifra_name
argument_list|,
name|ifname
argument_list|,
name|IFNAMSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*    *  Now, bring up the interface.    */
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifrq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"SIOCGIFFLAGS"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ifrq
operator|.
name|ifr_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifrq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"SIOCSIFFLAGS"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tun_in
operator|=
name|tun_out
expr_stmt|;
name|IfDevName
operator|=
name|devname
operator|+
literal|5
expr_stmt|;
if|if
condition|(
name|GetIfIndex
argument_list|(
name|IfDevName
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can't find ifindex.\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"Using interface: %s\r\n"
argument_list|,
name|IfDevName
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LOG_PHASE_BIT
argument_list|,
literal|"Using interface: %s\n"
argument_list|,
name|IfDevName
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|OsCloseLink
parameter_list|(
name|flag
parameter_list|)
name|int
name|flag
decl_stmt|;
block|{
name|HangupModem
argument_list|(
name|flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|OsAddInOctets
parameter_list|(
name|cnt
parameter_list|)
name|int
name|cnt
decl_stmt|;
block|{ }
end_function

begin_function
name|void
name|OsAddOutOctets
parameter_list|(
name|cnt
parameter_list|)
name|int
name|cnt
decl_stmt|;
block|{ }
end_function

end_unit

