begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Routines to compress and uncompess tcp packets (for transmission  * over low speed serial lines.  *  * Copyright (c) 1989 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * $Id$  *  *	Van Jacobson (van@helios.ee.lbl.gov), Dec 31, 1989:  *	- Initial distribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
specifier|const
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_decl_stmt
name|struct
name|slstat
name|slstat
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INCR
parameter_list|(
name|counter
parameter_list|)
value|slstat.counter++;
end_define

begin_define
define|#
directive|define
name|BCMP
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|n
parameter_list|)
value|bcmp((char *)(p1), (char *)(p2), (int)(n))
end_define

begin_define
define|#
directive|define
name|BCOPY
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|n
parameter_list|)
value|bcopy((char *)(p1), (char *)(p2), (int)(n))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|KERNEL
end_ifndef

begin_define
define|#
directive|define
name|ovbcopy
value|bcopy
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sl_compress_init
parameter_list|(
name|comp
parameter_list|)
name|struct
name|slcompress
modifier|*
name|comp
decl_stmt|;
block|{
specifier|register
name|u_int
name|i
decl_stmt|;
specifier|register
name|struct
name|cstate
modifier|*
name|tstate
init|=
name|comp
operator|->
name|tstate
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|comp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MAX_STATES
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|tstate
index|[
name|i
index|]
operator|.
name|cs_id
operator|=
name|i
expr_stmt|;
name|tstate
index|[
name|i
index|]
operator|.
name|cs_next
operator|=
operator|&
name|tstate
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|tstate
index|[
literal|0
index|]
operator|.
name|cs_next
operator|=
operator|&
name|tstate
index|[
name|MAX_STATES
operator|-
literal|1
index|]
expr_stmt|;
name|tstate
index|[
literal|0
index|]
operator|.
name|cs_id
operator|=
literal|0
expr_stmt|;
name|comp
operator|->
name|last_cs
operator|=
operator|&
name|tstate
index|[
literal|0
index|]
expr_stmt|;
name|comp
operator|->
name|last_recv
operator|=
literal|255
expr_stmt|;
name|comp
operator|->
name|last_xmit
operator|=
literal|255
expr_stmt|;
name|comp
operator|->
name|flags
operator|=
name|SLF_TOSS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ENCODE encodes a number that is known to be non-zero.  ENCODEZ  * checks for zero (since zero has to be encoded in the long, 3 byte  * form).  */
end_comment

begin_define
define|#
directive|define
name|ENCODE
parameter_list|(
name|n
parameter_list|)
value|{ \ 	if ((u_short)(n)>= 256) { \ 		*cp++ = 0; \ 		cp[1] = (n); \ 		cp[0] = (n)>> 8; \ 		cp += 2; \ 	} else { \ 		*cp++ = (n); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|ENCODEZ
parameter_list|(
name|n
parameter_list|)
value|{ \ 	if ((u_short)(n)>= 256 || (u_short)(n) == 0) { \ 		*cp++ = 0; \ 		cp[1] = (n); \ 		cp[0] = (n)>> 8; \ 		cp += 2; \ 	} else { \ 		*cp++ = (n); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DECODEL
parameter_list|(
name|f
parameter_list|)
value|{ \ 	if (*cp == 0) {\ 		(f) = htonl(ntohl(f) + ((cp[1]<< 8) | cp[2])); \ 		cp += 3; \ 	} else { \ 		(f) = htonl(ntohl(f) + (u_long)*cp++); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DECODES
parameter_list|(
name|f
parameter_list|)
value|{ \ 	if (*cp == 0) {\ 		(f) = htons(ntohs(f) + ((cp[1]<< 8) | cp[2])); \ 		cp += 3; \ 	} else { \ 		(f) = htons(ntohs(f) + (u_long)*cp++); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DECODEU
parameter_list|(
name|f
parameter_list|)
value|{ \ 	if (*cp == 0) {\ 		(f) = htons((cp[1]<< 8) | cp[2]); \ 		cp += 3; \ 	} else { \ 		(f) = htons((u_long)*cp++); \ 	} \ }
end_define

begin_function
name|u_char
name|sl_compress_tcp
parameter_list|(
name|m
parameter_list|,
name|ip
parameter_list|,
name|comp
parameter_list|,
name|compress_cid
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|slcompress
modifier|*
name|comp
decl_stmt|;
name|int
name|compress_cid
decl_stmt|;
block|{
specifier|register
name|struct
name|cstate
modifier|*
name|cs
init|=
name|comp
operator|->
name|last_cs
operator|->
name|cs_next
decl_stmt|;
specifier|register
name|u_int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|oth
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
specifier|register
name|u_int
name|deltaS
decl_stmt|,
name|deltaA
decl_stmt|;
specifier|register
name|u_int
name|changes
init|=
literal|0
decl_stmt|;
name|u_char
name|new_seq
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
init|=
name|new_seq
decl_stmt|;
comment|/* 	 * Bail if this is an IP fragment or if the TCP packet isn't 	 * `compressible' (i.e., ACK isn't set or some other control bit is 	 * set).  (We assume that the caller has already made sure the 	 * packet is IP proto TCP). 	 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
literal|0x3fff
argument_list|)
operator|)
operator|||
name|m
operator|->
name|cnt
operator|<
literal|40
condition|)
block|{
name|logprintf
argument_list|(
literal|"??? 1 ip_off = %x, cnt = %d\n"
argument_list|,
name|ip
operator|->
name|ip_off
argument_list|,
name|m
operator|->
name|cnt
argument_list|)
expr_stmt|;
name|DumpBp
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|TYPE_IP
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
literal|0x3fff
argument_list|)
operator|)
operator|||
name|m
operator|->
name|cnt
operator|<
literal|40
condition|)
return|return
operator|(
name|TYPE_IP
operator|)
return|;
endif|#
directive|endif
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|int
operator|*
operator|)
name|ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_RST
operator||
name|TH_ACK
operator|)
operator|)
operator|!=
name|TH_ACK
condition|)
block|{
name|logprintf
argument_list|(
literal|"??? 2 th_flags = %x\n"
argument_list|,
name|th
operator|->
name|th_flags
argument_list|)
expr_stmt|;
name|DumpBp
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|TYPE_IP
operator|)
return|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_RST
operator||
name|TH_ACK
operator|)
operator|)
operator|!=
name|TH_ACK
condition|)
return|return
operator|(
name|TYPE_IP
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * Packet is compressible -- we're going to send either a 	 * COMPRESSED_TCP or UNCOMPRESSED_TCP packet.  Either way we need 	 * to locate (or create) the connection state.  Special case the 	 * most recently used connection since it's most likely to be used 	 * again& we don't have to do any reordering if it's used. 	 */
name|INCR
argument_list|(
argument|sls_packets
argument_list|)
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_src
operator|.
name|s_addr
operator|||
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_dst
operator|.
name|s_addr
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|th
operator|!=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
index|]
condition|)
block|{
comment|/* 		 * Wasn't the first -- search for it. 		 * 		 * States are kept in a circularly linked list with 		 * last_cs pointing to the end of the list.  The 		 * list is kept in lru order by moving a state to the 		 * head of the list whenever it is referenced.  Since 		 * the list is short and, empirically, the connection 		 * we want is almost always near the front, we locate 		 * states via linear search.  If we don't find a state 		 * for the datagram, the oldest state is (re-)used. 		 */
specifier|register
name|struct
name|cstate
modifier|*
name|lcs
decl_stmt|;
specifier|register
name|struct
name|cstate
modifier|*
name|lastcs
init|=
name|comp
operator|->
name|last_cs
decl_stmt|;
do|do
block|{
name|lcs
operator|=
name|cs
expr_stmt|;
name|cs
operator|=
name|cs
operator|->
name|cs_next
expr_stmt|;
name|INCR
argument_list|(
argument|sls_searches
argument_list|)
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|cs
operator|->
name|cs_ip
operator|.
name|ip_src
operator|.
name|s_addr
operator|&&
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|cs
operator|->
name|cs_ip
operator|.
name|ip_dst
operator|.
name|s_addr
operator|&&
operator|*
operator|(
name|int
operator|*
operator|)
name|th
operator|==
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
index|]
condition|)
goto|goto
name|found
goto|;
block|}
do|while
condition|(
name|cs
operator|!=
name|lastcs
condition|)
do|;
comment|/* 		 * Didn't find it -- re-use oldest cstate.  Send an 		 * uncompressed packet that tells the other side what 		 * connection number we're using for this conversation. 		 * Note that since the state list is circular, the oldest 		 * state points to the newest and we only need to set 		 * last_cs to update the lru linkage. 		 */
name|INCR
argument_list|(
argument|sls_misses
argument_list|)
name|comp
operator|->
name|last_cs
operator|=
name|lcs
expr_stmt|;
define|#
directive|define
name|THOFFSET
parameter_list|(
name|th
parameter_list|)
value|(th->th_off)
name|hlen
operator|+=
name|th
operator|->
name|th_off
expr_stmt|;
name|hlen
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|cnt
condition|)
return|return
operator|(
name|TYPE_IP
operator|)
return|;
goto|goto
name|uncompressed
goto|;
name|found
label|:
comment|/* 		 * Found it -- move to the front on the connection list. 		 */
if|if
condition|(
name|cs
operator|==
name|lastcs
condition|)
name|comp
operator|->
name|last_cs
operator|=
name|lcs
expr_stmt|;
else|else
block|{
name|lcs
operator|->
name|cs_next
operator|=
name|cs
operator|->
name|cs_next
expr_stmt|;
name|cs
operator|->
name|cs_next
operator|=
name|lastcs
operator|->
name|cs_next
expr_stmt|;
name|lastcs
operator|->
name|cs_next
operator|=
name|cs
expr_stmt|;
block|}
block|}
comment|/* 	 * Make sure that only what we expect to change changed. The first 	 * line of the `if' checks the IP protocol version, header length& 	 * type of service.  The 2nd line checks the "Don't fragment" bit. 	 * The 3rd line checks the time-to-live and protocol (the protocol 	 * check is unnecessary but costless).  The 4th line checks the TCP 	 * header length.  The 5th line checks IP options, if any.  The 6th 	 * line checks TCP options, if any.  If any of these things are 	 * different between the previous& current datagram, we send the 	 * current datagram `uncompressed'. 	 */
name|oth
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
name|deltaS
operator|=
name|hlen
expr_stmt|;
name|hlen
operator|+=
name|th
operator|->
name|th_off
expr_stmt|;
name|hlen
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|cnt
condition|)
return|return
operator|(
name|TYPE_IP
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|u_short
operator|*
operator|)
name|ip
operator|)
index|[
literal|0
index|]
operator|!=
operator|(
operator|(
name|u_short
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
literal|0
index|]
operator|||
operator|(
operator|(
name|u_short
operator|*
operator|)
name|ip
operator|)
index|[
literal|3
index|]
operator|!=
operator|(
operator|(
name|u_short
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
literal|3
index|]
operator|||
operator|(
operator|(
name|u_short
operator|*
operator|)
name|ip
operator|)
index|[
literal|4
index|]
operator|!=
operator|(
operator|(
name|u_short
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
literal|4
index|]
operator|||
name|THOFFSET
argument_list|(
name|th
argument_list|)
operator|!=
name|THOFFSET
argument_list|(
name|oth
argument_list|)
operator|||
operator|(
name|deltaS
operator|>
literal|5
operator|&&
name|BCMP
argument_list|(
name|ip
operator|+
literal|1
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
operator|+
literal|1
argument_list|,
operator|(
name|deltaS
operator|-
literal|5
operator|)
operator|<<
literal|2
argument_list|)
operator|)
operator|||
operator|(
name|THOFFSET
argument_list|(
name|th
argument_list|)
operator|>
literal|5
operator|&&
name|BCMP
argument_list|(
name|th
operator|+
literal|1
argument_list|,
name|oth
operator|+
literal|1
argument_list|,
operator|(
name|THOFFSET
argument_list|(
name|th
argument_list|)
operator|-
literal|5
operator|)
operator|<<
literal|2
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|uncompressed
goto|;
block|}
comment|/* 	 * Figure out which of the changing fields changed.  The 	 * receiver expects changes in the order: urgent, window, 	 * ack, seq (the order minimizes the number of temporaries 	 * needed in this section of code). 	 */
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_URG
condition|)
block|{
name|deltaS
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_urp
argument_list|)
expr_stmt|;
name|ENCODEZ
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_U
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|th
operator|->
name|th_urp
operator|!=
name|oth
operator|->
name|th_urp
condition|)
block|{
comment|/* argh! URG not set but urp changed -- a sensible 		 * implementation should never do this but RFC793 		 * doesn't prohibit the change so we have to deal 		 * with it. */
goto|goto
name|uncompressed
goto|;
block|}
name|deltaS
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ntohs
argument_list|(
name|th
operator|->
name|th_win
argument_list|)
operator|-
name|ntohs
argument_list|(
name|oth
operator|->
name|th_win
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaS
condition|)
block|{
name|ENCODE
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_W
expr_stmt|;
block|}
name|deltaA
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|-
name|ntohl
argument_list|(
name|oth
operator|->
name|th_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaA
condition|)
block|{
if|if
condition|(
name|deltaA
operator|>
literal|0xffff
condition|)
block|{
goto|goto
name|uncompressed
goto|;
block|}
name|ENCODE
argument_list|(
name|deltaA
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_A
expr_stmt|;
block|}
name|deltaS
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|-
name|ntohl
argument_list|(
name|oth
operator|->
name|th_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaS
condition|)
block|{
if|if
condition|(
name|deltaS
operator|>
literal|0xffff
condition|)
block|{
goto|goto
name|uncompressed
goto|;
block|}
name|ENCODE
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_S
expr_stmt|;
block|}
switch|switch
condition|(
name|changes
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Nothing changed. If this packet contains data and the 		 * last one didn't, this is probably a data packet following 		 * an ack (normal on an interactive connection) and we send 		 * it compressed.  Otherwise it's probably a retransmit, 		 * retransmitted ack or window probe.  Send it uncompressed 		 * in case the other side missed the compressed version. 		 */
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
operator|&&
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|==
name|hlen
condition|)
break|break;
comment|/* (fall through) */
case|case
name|SPECIAL_I
case|:
case|case
name|SPECIAL_D
case|:
comment|/* 		 * actual changes match one of our special case encodings -- 		 * send packet uncompressed. 		 */
goto|goto
name|uncompressed
goto|;
case|case
name|NEW_S
operator||
name|NEW_A
case|:
if|if
condition|(
name|deltaS
operator|==
name|deltaA
operator|&&
name|deltaS
operator|==
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|hlen
condition|)
block|{
comment|/* special case for echoed terminal traffic */
name|changes
operator|=
name|SPECIAL_I
expr_stmt|;
name|cp
operator|=
name|new_seq
expr_stmt|;
block|}
break|break;
case|case
name|NEW_S
case|:
if|if
condition|(
name|deltaS
operator|==
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|hlen
condition|)
block|{
comment|/* special case for data xfer */
name|changes
operator|=
name|SPECIAL_D
expr_stmt|;
name|cp
operator|=
name|new_seq
expr_stmt|;
block|}
break|break;
block|}
name|deltaS
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
operator|-
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaS
operator|!=
literal|1
condition|)
block|{
name|ENCODEZ
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_I
expr_stmt|;
block|}
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_PUSH
condition|)
name|changes
operator||=
name|TCP_PUSH_BIT
expr_stmt|;
comment|/* 	 * Grab the cksum before we overwrite it below.  Then update our 	 * state with this packet's header. 	 */
name|deltaA
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_sum
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|ip
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
comment|/* 	 * We want to use the original packet as our compressed packet. 	 * (cp - new_seq) is the number of bytes we need for compressed 	 * sequence numbers.  In addition we need one byte for the change 	 * mask, one for the connection id and two for the tcp checksum. 	 * So, (cp - new_seq) + 4 bytes of header are needed.  hlen is how 	 * many bytes of the original packet to toss so subtract the two to 	 * get the new packet size. 	 */
name|deltaS
operator|=
name|cp
operator|-
name|new_seq
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
comment|/*          * Since fastq traffic can jump ahead of the background traffic,          * we don't know what order packets will go on the line.  In this          * case, we always send a "new" connection id so the receiver state          * stays synchronized.          */
ifdef|#
directive|ifdef
name|SL_NOFASTQ
if|if
condition|(
name|comp
operator|->
name|last_xmit
operator|==
name|cs
operator|->
name|cs_id
condition|)
block|{
name|hlen
operator|-=
name|deltaS
operator|+
literal|3
expr_stmt|;
name|cp
operator|+=
name|hlen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|changes
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|comp
operator|->
name|last_xmit
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
name|hlen
operator|-=
name|deltaS
operator|+
literal|4
expr_stmt|;
name|cp
operator|+=
name|hlen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|changes
operator||
name|NEW_C
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
block|}
name|m
operator|->
name|cnt
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|offset
operator|+=
name|hlen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|deltaA
operator|>>
literal|8
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|deltaA
expr_stmt|;
name|BCOPY
argument_list|(
name|new_seq
argument_list|,
name|cp
argument_list|,
name|deltaS
argument_list|)
expr_stmt|;
name|INCR
argument_list|(
argument|sls_compressed
argument_list|)
return|return
operator|(
name|TYPE_COMPRESSED_TCP
operator|)
return|;
comment|/* 	 * Update connection state cs& send uncompressed packet ('uncompressed' 	 * means a regular ip/tcp packet but with the 'conversation id' we hope 	 * to use on future compressed packets in the protocol field). 	 */
name|uncompressed
label|:
name|BCOPY
argument_list|(
name|ip
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
name|comp
operator|->
name|last_xmit
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
return|return
operator|(
name|TYPE_UNCOMPRESSED_TCP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sl_uncompress_tcp
parameter_list|(
name|bufp
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|,
name|comp
parameter_list|)
name|u_char
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|struct
name|slcompress
modifier|*
name|comp
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|u_int
name|hlen
decl_stmt|,
name|changes
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
specifier|register
name|struct
name|cstate
modifier|*
name|cs
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_UNCOMPRESSED_TCP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|*
name|bufp
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|>=
name|MAX_STATES
condition|)
goto|goto
name|bad
goto|;
name|cs
operator|=
operator|&
name|comp
operator|->
name|rstate
index|[
name|comp
operator|->
name|last_recv
operator|=
name|ip
operator|->
name|ip_p
index|]
expr_stmt|;
name|comp
operator|->
name|flags
operator|&=
operator|~
name|SLF_TOSS
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_TCP
expr_stmt|;
comment|/* 		 * Calculate the size of the TCP/IP header and make sure that 		 * we don't overflow the space we have available for it. 		*/
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|>
name|len
condition|)
goto|goto
name|bad
goto|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
name|hlen
operator|+=
name|THOFFSET
argument_list|(
name|th
argument_list|)
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|MAX_HDR
condition|)
goto|goto
name|bad
goto|;
name|BCOPY
argument_list|(
name|ip
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_ip
operator|.
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|cs_hlen
operator|=
name|hlen
expr_stmt|;
name|INCR
argument_list|(
argument|sls_uncompressedin
argument_list|)
return|return
operator|(
name|len
operator|)
return|;
default|default:
goto|goto
name|bad
goto|;
case|case
name|TYPE_COMPRESSED_TCP
case|:
break|break;
block|}
comment|/* We've got a compressed packet. */
name|INCR
argument_list|(
argument|sls_compressedin
argument_list|)
name|cp
operator|=
operator|*
name|bufp
expr_stmt|;
name|changes
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|logprintf
argument_list|(
literal|"compressed: changes = %02x\n"
argument_list|,
name|changes
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|changes
operator|&
name|NEW_C
condition|)
block|{
comment|/* Make sure the state index is in range, then grab the state. 		 * If we have a good state index, clear the 'discard' flag. */
if|if
condition|(
operator|*
name|cp
operator|>=
name|MAX_STATES
operator|||
name|comp
operator|->
name|last_recv
operator|==
literal|255
condition|)
goto|goto
name|bad
goto|;
name|comp
operator|->
name|flags
operator|&=
operator|~
name|SLF_TOSS
expr_stmt|;
name|comp
operator|->
name|last_recv
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* this packet has an implicit state index.  If we've 		 * had a line error since the last time we got an 		 * explicit state index, we have to toss the packet. */
if|if
condition|(
name|comp
operator|->
name|flags
operator|&
name|SLF_TOSS
condition|)
block|{
name|INCR
argument_list|(
argument|sls_tossed
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|cs
operator|=
operator|&
name|comp
operator|->
name|rstate
index|[
name|comp
operator|->
name|last_recv
index|]
expr_stmt|;
name|hlen
operator|=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|htons
argument_list|(
operator|(
operator|*
name|cp
operator|<<
literal|8
operator|)
operator||
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|TCP_PUSH_BIT
condition|)
name|th
operator|->
name|th_flags
operator||=
name|TH_PUSH
expr_stmt|;
else|else
name|th
operator|->
name|th_flags
operator|&=
operator|~
name|TH_PUSH
expr_stmt|;
switch|switch
condition|(
name|changes
operator|&
name|SPECIALS_MASK
condition|)
block|{
case|case
name|SPECIAL_I
case|:
block|{
specifier|register
name|u_int
name|i
init|=
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|cs
operator|->
name|cs_hlen
decl_stmt|;
name|th
operator|->
name|th_ack
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPECIAL_D
case|:
name|th
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|cs
operator|->
name|cs_hlen
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|changes
operator|&
name|NEW_U
condition|)
block|{
name|th
operator|->
name|th_flags
operator||=
name|TH_URG
expr_stmt|;
name|DECODEU
argument_list|(
argument|th->th_urp
argument_list|)
block|}
else|else
name|th
operator|->
name|th_flags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|NEW_W
condition|)
name|DECODES
argument_list|(
argument|th->th_win
argument_list|)
if|if
condition|(
name|changes
operator|&
name|NEW_A
condition|)
name|DECODEL
argument_list|(
argument|th->th_ack
argument_list|)
if|if
condition|(
name|changes
operator|&
name|NEW_S
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|logprintf
argument_list|(
literal|"NEW_S: %02x, %02x, %02x\r\n"
argument_list|,
operator|*
name|cp
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|,
name|cp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DECODEL
argument_list|(
argument|th->th_seq
argument_list|)
block|}
break|break;
block|}
if|if
condition|(
name|changes
operator|&
name|NEW_I
condition|)
block|{
name|DECODES
argument_list|(
argument|cs->cs_ip.ip_id
argument_list|)
block|}
else|else
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|logprintf
argument_list|(
literal|"id = %04x, seq = %08x\r\n"
argument_list|,
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
argument_list|,
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * At this point, cp points to the first byte of data in the 	 * packet.  If we're not aligned on a 4-byte boundary, copy the 	 * data down so the ip& tcp headers will be aligned.  Then back up 	 * cp by the tcp/ip header length to make room for the reconstructed 	 * header (we assume the packet we were handed has enough space to 	 * prepend 128 bytes of header).  Adjust the length to account for 	 * the new header& fill in the IP total length. 	 */
name|len
operator|-=
operator|(
name|cp
operator|-
operator|*
name|bufp
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
comment|/* we must have dropped some characters (crc should detect 		 * this but the old slip framing won't) */
goto|goto
name|bad
goto|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|3
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|ovbcopy
argument_list|(
name|cp
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|cp
operator|&
operator|~
literal|3
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|cp
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cp
operator|-=
name|cs
operator|->
name|cs_hlen
expr_stmt|;
name|len
operator|+=
name|cs
operator|->
name|cs_hlen
expr_stmt|;
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|cp
argument_list|,
name|cs
operator|->
name|cs_hlen
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|=
name|cp
expr_stmt|;
comment|/* recompute the ip header checksum */
block|{
specifier|register
name|u_short
modifier|*
name|bp
init|=
operator|(
name|u_short
operator|*
operator|)
name|cp
decl_stmt|;
for|for
control|(
name|changes
operator|=
literal|0
init|;
name|hlen
operator|>
literal|0
condition|;
name|hlen
operator|-=
literal|2
control|)
name|changes
operator|+=
operator|*
name|bp
operator|++
expr_stmt|;
name|changes
operator|=
operator|(
name|changes
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|changes
operator|>>
literal|16
operator|)
expr_stmt|;
name|changes
operator|=
operator|(
name|changes
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|changes
operator|>>
literal|16
operator|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|cp
operator|)
operator|->
name|ip_sum
operator|=
operator|~
name|changes
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
name|bad
label|:
name|comp
operator|->
name|flags
operator||=
name|SLF_TOSS
expr_stmt|;
name|INCR
argument_list|(
argument|sls_errorin
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ReportCompress
parameter_list|()
block|{
name|printf
argument_list|(
literal|"Out:  %d (compress) / %d (total)"
argument_list|,
name|slstat
operator|.
name|sls_compressed
argument_list|,
name|slstat
operator|.
name|sls_packets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %d (miss) / %d (search)\n"
argument_list|,
name|slstat
operator|.
name|sls_misses
argument_list|,
name|slstat
operator|.
name|sls_searches
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"In:  %d (compress), %d (uncompress)"
argument_list|,
name|slstat
operator|.
name|sls_compressedin
argument_list|,
name|slstat
operator|.
name|sls_uncompressedin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %d (error),  %d (tossed)\n"
argument_list|,
name|slstat
operator|.
name|sls_errorin
argument_list|,
name|slstat
operator|.
name|sls_tossed
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

