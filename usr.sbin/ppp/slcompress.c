begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Routines to compress and uncompess tcp packets (for transmission  * over low speed serial lines.  *  * Copyright (c) 1989 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * $Id: slcompress.c,v 1.14 1997/11/22 03:37:50 brian Exp $  *  *	Van Jacobson (van@helios.ee.lbl.gov), Dec 31, 1989:  *	- Initial distribution.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_include
include|#
directive|include
file|"loadalias.h"
end_include

begin_include
include|#
directive|include
file|"vars.h"
end_include

begin_struct
specifier|static
struct|struct
name|slstat
block|{
name|int
name|sls_packets
decl_stmt|;
comment|/* outbound packets */
name|int
name|sls_compressed
decl_stmt|;
comment|/* outbound compressed packets */
name|int
name|sls_searches
decl_stmt|;
comment|/* searches for connection state */
name|int
name|sls_misses
decl_stmt|;
comment|/* times couldn't find conn. state */
name|int
name|sls_uncompressedin
decl_stmt|;
comment|/* inbound uncompressed packets */
name|int
name|sls_compressedin
decl_stmt|;
comment|/* inbound compressed packets */
name|int
name|sls_errorin
decl_stmt|;
comment|/* inbound unknown type packets */
name|int
name|sls_tossed
decl_stmt|;
comment|/* inbound packets tossed because of error */
block|}
name|slstat
struct|;
end_struct

begin_define
define|#
directive|define
name|INCR
parameter_list|(
name|counter
parameter_list|)
value|slstat.counter++;
end_define

begin_function
name|void
name|sl_compress_init
parameter_list|(
name|struct
name|slcompress
modifier|*
name|comp
parameter_list|,
name|int
name|max_state
parameter_list|)
block|{
specifier|register
name|u_int
name|i
decl_stmt|;
specifier|register
name|struct
name|cstate
modifier|*
name|tstate
init|=
name|comp
operator|->
name|tstate
decl_stmt|;
name|memset
argument_list|(
name|comp
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
expr|*
name|comp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|max_state
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|tstate
index|[
name|i
index|]
operator|.
name|cs_id
operator|=
name|i
expr_stmt|;
name|tstate
index|[
name|i
index|]
operator|.
name|cs_next
operator|=
operator|&
name|tstate
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|tstate
index|[
literal|0
index|]
operator|.
name|cs_next
operator|=
operator|&
name|tstate
index|[
name|max_state
index|]
expr_stmt|;
name|tstate
index|[
literal|0
index|]
operator|.
name|cs_id
operator|=
literal|0
expr_stmt|;
name|comp
operator|->
name|last_cs
operator|=
operator|&
name|tstate
index|[
literal|0
index|]
expr_stmt|;
name|comp
operator|->
name|last_recv
operator|=
literal|255
expr_stmt|;
name|comp
operator|->
name|last_xmit
operator|=
literal|255
expr_stmt|;
name|comp
operator|->
name|flags
operator|=
name|SLF_TOSS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ENCODE encodes a number that is known to be non-zero.  ENCODEZ  * checks for zero (since zero has to be encoded in the long, 3 byte  * form).  */
end_comment

begin_define
define|#
directive|define
name|ENCODE
parameter_list|(
name|n
parameter_list|)
value|{ \ 	if ((u_short)(n)>= 256) { \ 		*cp++ = 0; \ 		cp[1] = (n); \ 		cp[0] = (n)>> 8; \ 		cp += 2; \ 	} else { \ 		*cp++ = (n); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|ENCODEZ
parameter_list|(
name|n
parameter_list|)
value|{ \ 	if ((u_short)(n)>= 256 || (u_short)(n) == 0) { \ 		*cp++ = 0; \ 		cp[1] = (n); \ 		cp[0] = (n)>> 8; \ 		cp += 2; \ 	} else { \ 		*cp++ = (n); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DECODEL
parameter_list|(
name|f
parameter_list|)
value|{ \ 	if (*cp == 0) {\ 		(f) = htonl(ntohl(f) + ((cp[1]<< 8) | cp[2])); \ 		cp += 3; \ 	} else { \ 		(f) = htonl(ntohl(f) + (u_long)*cp++); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DECODES
parameter_list|(
name|f
parameter_list|)
value|{ \ 	if (*cp == 0) {\ 		(f) = htons(ntohs(f) + ((cp[1]<< 8) | cp[2])); \ 		cp += 3; \ 	} else { \ 		(f) = htons(ntohs(f) + (u_long)*cp++); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DECODEU
parameter_list|(
name|f
parameter_list|)
value|{ \ 	if (*cp == 0) {\ 		(f) = htons((cp[1]<< 8) | cp[2]); \ 		cp += 3; \ 	} else { \ 		(f) = htons((u_long)*cp++); \ 	} \ }
end_define

begin_function
name|u_char
name|sl_compress_tcp
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|slcompress
modifier|*
name|comp
parameter_list|,
name|int
name|compress_cid
parameter_list|)
block|{
specifier|register
name|struct
name|cstate
modifier|*
name|cs
init|=
name|comp
operator|->
name|last_cs
operator|->
name|cs_next
decl_stmt|;
specifier|register
name|u_int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|oth
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
specifier|register
name|u_int
name|deltaS
decl_stmt|,
name|deltaA
decl_stmt|;
specifier|register
name|u_int
name|changes
init|=
literal|0
decl_stmt|;
name|u_char
name|new_seq
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
init|=
name|new_seq
decl_stmt|;
comment|/*    * Bail if this is an IP fragment or if the TCP packet isn't `compressible'    * (i.e., ACK isn't set or some other control bit is set).  (We assume that    * the caller has already made sure the packet is IP proto TCP).    */
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
literal|0x3fff
argument_list|)
operator|)
operator|||
name|m
operator|->
name|cnt
operator|<
literal|40
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"??? 1 ip_off = %x, cnt = %d\n"
argument_list|,
name|ip
operator|->
name|ip_off
argument_list|,
name|m
operator|->
name|cnt
argument_list|)
expr_stmt|;
name|LogDumpBp
argument_list|(
name|LogDEBUG
argument_list|,
literal|""
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|TYPE_IP
operator|)
return|;
block|}
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|int
operator|*
operator|)
name|ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_RST
operator||
name|TH_ACK
operator|)
operator|)
operator|!=
name|TH_ACK
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"??? 2 th_flags = %x\n"
argument_list|,
name|th
operator|->
name|th_flags
argument_list|)
expr_stmt|;
name|LogDumpBp
argument_list|(
name|LogDEBUG
argument_list|,
literal|""
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|TYPE_IP
operator|)
return|;
block|}
comment|/*    * Packet is compressible -- we're going to send either a COMPRESSED_TCP or    * UNCOMPRESSED_TCP packet.  Either way we need to locate (or create) the    * connection state.  Special case the most recently used connection since    * it's most likely to be used again& we don't have to do any reordering    * if it's used.    */
name|INCR
argument_list|(
argument|sls_packets
argument_list|)
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_src
operator|.
name|s_addr
operator|||
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_dst
operator|.
name|s_addr
operator|||
operator|*
operator|(
name|int
operator|*
operator|)
name|th
operator|!=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
index|]
condition|)
block|{
comment|/*      * Wasn't the first -- search for it.      *       * States are kept in a circularly linked list with last_cs pointing to the      * end of the list.  The list is kept in lru order by moving a state to      * the head of the list whenever it is referenced.  Since the list is      * short and, empirically, the connection we want is almost always near      * the front, we locate states via linear search.  If we don't find a      * state for the datagram, the oldest state is (re-)used.      */
specifier|register
name|struct
name|cstate
modifier|*
name|lcs
decl_stmt|;
specifier|register
name|struct
name|cstate
modifier|*
name|lastcs
init|=
name|comp
operator|->
name|last_cs
decl_stmt|;
do|do
block|{
name|lcs
operator|=
name|cs
expr_stmt|;
name|cs
operator|=
name|cs
operator|->
name|cs_next
expr_stmt|;
name|INCR
argument_list|(
argument|sls_searches
argument_list|)
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|cs
operator|->
name|cs_ip
operator|.
name|ip_src
operator|.
name|s_addr
operator|&&
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|cs
operator|->
name|cs_ip
operator|.
name|ip_dst
operator|.
name|s_addr
operator|&&
operator|*
operator|(
name|int
operator|*
operator|)
name|th
operator|==
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
index|]
condition|)
goto|goto
name|found
goto|;
block|}
do|while
condition|(
name|cs
operator|!=
name|lastcs
condition|)
do|;
comment|/*      * Didn't find it -- re-use oldest cstate.  Send an uncompressed packet      * that tells the other side what connection number we're using for this      * conversation. Note that since the state list is circular, the oldest      * state points to the newest and we only need to set last_cs to update      * the lru linkage.      */
name|INCR
argument_list|(
argument|sls_misses
argument_list|)
name|comp
operator|->
name|last_cs
operator|=
name|lcs
expr_stmt|;
define|#
directive|define
name|THOFFSET
parameter_list|(
name|th
parameter_list|)
value|(th->th_off)
name|hlen
operator|+=
name|th
operator|->
name|th_off
expr_stmt|;
name|hlen
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|cnt
condition|)
return|return
operator|(
name|TYPE_IP
operator|)
return|;
goto|goto
name|uncompressed
goto|;
name|found
label|:
comment|/*      * Found it -- move to the front on the connection list.      */
if|if
condition|(
name|cs
operator|==
name|lastcs
condition|)
name|comp
operator|->
name|last_cs
operator|=
name|lcs
expr_stmt|;
else|else
block|{
name|lcs
operator|->
name|cs_next
operator|=
name|cs
operator|->
name|cs_next
expr_stmt|;
name|cs
operator|->
name|cs_next
operator|=
name|lastcs
operator|->
name|cs_next
expr_stmt|;
name|lastcs
operator|->
name|cs_next
operator|=
name|cs
expr_stmt|;
block|}
block|}
comment|/*    * Make sure that only what we expect to change changed. The first line of    * the `if' checks the IP protocol version, header length& type of    * service.  The 2nd line checks the "Don't fragment" bit. The 3rd line    * checks the time-to-live and protocol (the protocol check is unnecessary    * but costless).  The 4th line checks the TCP header length.  The 5th line    * checks IP options, if any.  The 6th line checks TCP options, if any.  If    * any of these things are different between the previous& current    * datagram, we send the current datagram `uncompressed'.    */
name|oth
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
name|deltaS
operator|=
name|hlen
expr_stmt|;
name|hlen
operator|+=
name|th
operator|->
name|th_off
expr_stmt|;
name|hlen
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|cnt
condition|)
return|return
operator|(
name|TYPE_IP
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|u_short
operator|*
operator|)
name|ip
operator|)
index|[
literal|0
index|]
operator|!=
operator|(
operator|(
name|u_short
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
literal|0
index|]
operator|||
operator|(
operator|(
name|u_short
operator|*
operator|)
name|ip
operator|)
index|[
literal|3
index|]
operator|!=
operator|(
operator|(
name|u_short
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
literal|3
index|]
operator|||
operator|(
operator|(
name|u_short
operator|*
operator|)
name|ip
operator|)
index|[
literal|4
index|]
operator|!=
operator|(
operator|(
name|u_short
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
literal|4
index|]
operator|||
name|THOFFSET
argument_list|(
name|th
argument_list|)
operator|!=
name|THOFFSET
argument_list|(
name|oth
argument_list|)
operator|||
operator|(
name|deltaS
operator|>
literal|5
operator|&&
name|memcmp
argument_list|(
name|ip
operator|+
literal|1
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
operator|+
literal|1
argument_list|,
operator|(
name|deltaS
operator|-
literal|5
operator|)
operator|<<
literal|2
argument_list|)
operator|)
operator|||
operator|(
name|THOFFSET
argument_list|(
name|th
argument_list|)
operator|>
literal|5
operator|&&
name|memcmp
argument_list|(
name|th
operator|+
literal|1
argument_list|,
name|oth
operator|+
literal|1
argument_list|,
operator|(
name|THOFFSET
argument_list|(
name|th
argument_list|)
operator|-
literal|5
operator|)
operator|<<
literal|2
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|uncompressed
goto|;
block|}
comment|/*    * Figure out which of the changing fields changed.  The receiver expects    * changes in the order: urgent, window, ack, seq (the order minimizes the    * number of temporaries needed in this section of code).    */
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_URG
condition|)
block|{
name|deltaS
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_urp
argument_list|)
expr_stmt|;
name|ENCODEZ
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_U
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|th
operator|->
name|th_urp
operator|!=
name|oth
operator|->
name|th_urp
condition|)
block|{
comment|/*      * argh! URG not set but urp changed -- a sensible implementation should      * never do this but RFC793 doesn't prohibit the change so we have to      * deal with it.      */
goto|goto
name|uncompressed
goto|;
block|}
name|deltaS
operator|=
call|(
name|u_short
call|)
argument_list|(
name|ntohs
argument_list|(
name|th
operator|->
name|th_win
argument_list|)
operator|-
name|ntohs
argument_list|(
name|oth
operator|->
name|th_win
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaS
condition|)
block|{
name|ENCODE
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_W
expr_stmt|;
block|}
name|deltaA
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|-
name|ntohl
argument_list|(
name|oth
operator|->
name|th_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaA
condition|)
block|{
if|if
condition|(
name|deltaA
operator|>
literal|0xffff
condition|)
block|{
goto|goto
name|uncompressed
goto|;
block|}
name|ENCODE
argument_list|(
name|deltaA
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_A
expr_stmt|;
block|}
name|deltaS
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|-
name|ntohl
argument_list|(
name|oth
operator|->
name|th_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaS
condition|)
block|{
if|if
condition|(
name|deltaS
operator|>
literal|0xffff
condition|)
block|{
goto|goto
name|uncompressed
goto|;
block|}
name|ENCODE
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_S
expr_stmt|;
block|}
switch|switch
condition|(
name|changes
condition|)
block|{
case|case
literal|0
case|:
comment|/*      * Nothing changed. If this packet contains data and the last one didn't,      * this is probably a data packet following an ack (normal on an      * interactive connection) and we send it compressed.  Otherwise it's      * probably a retransmit, retransmitted ack or window probe.  Send it      * uncompressed in case the other side missed the compressed version.      */
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
operator|&&
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|==
name|hlen
condition|)
break|break;
comment|/* (fall through) */
case|case
name|SPECIAL_I
case|:
case|case
name|SPECIAL_D
case|:
comment|/*      * actual changes match one of our special case encodings -- send packet      * uncompressed.      */
goto|goto
name|uncompressed
goto|;
case|case
name|NEW_S
operator||
name|NEW_A
case|:
if|if
condition|(
name|deltaS
operator|==
name|deltaA
operator|&&
name|deltaS
operator|==
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|hlen
condition|)
block|{
comment|/* special case for echoed terminal traffic */
name|changes
operator|=
name|SPECIAL_I
expr_stmt|;
name|cp
operator|=
name|new_seq
expr_stmt|;
block|}
break|break;
case|case
name|NEW_S
case|:
if|if
condition|(
name|deltaS
operator|==
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|hlen
condition|)
block|{
comment|/* special case for data xfer */
name|changes
operator|=
name|SPECIAL_D
expr_stmt|;
name|cp
operator|=
name|new_seq
expr_stmt|;
block|}
break|break;
block|}
name|deltaS
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
operator|-
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaS
operator|!=
literal|1
condition|)
block|{
name|ENCODEZ
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_I
expr_stmt|;
block|}
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_PUSH
condition|)
name|changes
operator||=
name|TCP_PUSH_BIT
expr_stmt|;
comment|/*    * Grab the cksum before we overwrite it below.  Then update our state with    * this packet's header.    */
name|deltaA
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_sum
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
comment|/*    * We want to use the original packet as our compressed packet. (cp -    * new_seq) is the number of bytes we need for compressed sequence numbers.    * In addition we need one byte for the change mask, one for the connection    * id and two for the tcp checksum. So, (cp - new_seq) + 4 bytes of header    * are needed.  hlen is how many bytes of the original packet to toss so    * subtract the two to get the new packet size.    */
name|deltaS
operator|=
name|cp
operator|-
name|new_seq
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
comment|/*    * Since fastq traffic can jump ahead of the background traffic, we don't    * know what order packets will go on the line.  In this case, we always    * send a "new" connection id so the receiver state stays synchronized.    */
if|if
condition|(
name|comp
operator|->
name|last_xmit
operator|==
name|cs
operator|->
name|cs_id
operator|&&
name|compress_cid
condition|)
block|{
name|hlen
operator|-=
name|deltaS
operator|+
literal|3
expr_stmt|;
name|cp
operator|+=
name|hlen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|changes
expr_stmt|;
block|}
else|else
block|{
name|comp
operator|->
name|last_xmit
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
name|hlen
operator|-=
name|deltaS
operator|+
literal|4
expr_stmt|;
name|cp
operator|+=
name|hlen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|changes
operator||
name|NEW_C
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
block|}
name|m
operator|->
name|cnt
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|offset
operator|+=
name|hlen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|deltaA
operator|>>
literal|8
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|deltaA
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|new_seq
argument_list|,
name|deltaS
argument_list|)
expr_stmt|;
name|INCR
argument_list|(
argument|sls_compressed
argument_list|)
return|return
operator|(
name|TYPE_COMPRESSED_TCP
operator|)
return|;
comment|/*    * Update connection state cs& send uncompressed packet ('uncompressed'    * means a regular ip/tcp packet but with the 'conversation id' we hope to    * use on future compressed packets in the protocol field).    */
name|uncompressed
label|:
name|memcpy
argument_list|(
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
name|comp
operator|->
name|last_xmit
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
return|return
operator|(
name|TYPE_UNCOMPRESSED_TCP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sl_uncompress_tcp
parameter_list|(
name|u_char
modifier|*
modifier|*
name|bufp
parameter_list|,
name|int
name|len
parameter_list|,
name|u_int
name|type
parameter_list|,
name|struct
name|slcompress
modifier|*
name|comp
parameter_list|)
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|u_int
name|hlen
decl_stmt|,
name|changes
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
specifier|register
name|struct
name|cstate
modifier|*
name|cs
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_UNCOMPRESSED_TCP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|*
name|bufp
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|>=
name|MAX_STATES
condition|)
goto|goto
name|bad
goto|;
name|cs
operator|=
operator|&
name|comp
operator|->
name|rstate
index|[
name|comp
operator|->
name|last_recv
operator|=
name|ip
operator|->
name|ip_p
index|]
expr_stmt|;
name|comp
operator|->
name|flags
operator|&=
operator|~
name|SLF_TOSS
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_TCP
expr_stmt|;
comment|/*      * Calculate the size of the TCP/IP header and make sure that we don't      * overflow the space we have available for it.      */
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|>
name|len
condition|)
goto|goto
name|bad
goto|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
name|hlen
operator|+=
name|THOFFSET
argument_list|(
name|th
argument_list|)
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|MAX_HDR
condition|)
goto|goto
name|bad
goto|;
name|memcpy
argument_list|(
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_ip
operator|.
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|cs
operator|->
name|cs_hlen
operator|=
name|hlen
expr_stmt|;
name|INCR
argument_list|(
argument|sls_uncompressedin
argument_list|)
return|return
operator|(
name|len
operator|)
return|;
default|default:
goto|goto
name|bad
goto|;
case|case
name|TYPE_COMPRESSED_TCP
case|:
break|break;
block|}
comment|/* We've got a compressed packet. */
name|INCR
argument_list|(
argument|sls_compressedin
argument_list|)
name|cp
operator|=
operator|*
name|bufp
expr_stmt|;
name|changes
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"compressed: changes = %02x\n"
argument_list|,
name|changes
argument_list|)
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|NEW_C
condition|)
block|{
comment|/*      * Make sure the state index is in range, then grab the state. If we have      * a good state index, clear the 'discard' flag.      */
if|if
condition|(
operator|*
name|cp
operator|>=
name|MAX_STATES
operator|||
name|comp
operator|->
name|last_recv
operator|==
literal|255
condition|)
goto|goto
name|bad
goto|;
name|comp
operator|->
name|flags
operator|&=
operator|~
name|SLF_TOSS
expr_stmt|;
name|comp
operator|->
name|last_recv
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/*      * this packet has an implicit state index.  If we've had a line error      * since the last time we got an explicit state index, we have to toss      * the packet.      */
if|if
condition|(
name|comp
operator|->
name|flags
operator|&
name|SLF_TOSS
condition|)
block|{
name|INCR
argument_list|(
argument|sls_tossed
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|cs
operator|=
operator|&
name|comp
operator|->
name|rstate
index|[
name|comp
operator|->
name|last_recv
index|]
expr_stmt|;
name|hlen
operator|=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|htons
argument_list|(
operator|(
operator|*
name|cp
operator|<<
literal|8
operator|)
operator||
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|TCP_PUSH_BIT
condition|)
name|th
operator|->
name|th_flags
operator||=
name|TH_PUSH
expr_stmt|;
else|else
name|th
operator|->
name|th_flags
operator|&=
operator|~
name|TH_PUSH
expr_stmt|;
switch|switch
condition|(
name|changes
operator|&
name|SPECIALS_MASK
condition|)
block|{
case|case
name|SPECIAL_I
case|:
block|{
specifier|register
name|u_int
name|i
init|=
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|cs
operator|->
name|cs_hlen
decl_stmt|;
name|th
operator|->
name|th_ack
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPECIAL_D
case|:
name|th
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|cs
operator|->
name|cs_hlen
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|changes
operator|&
name|NEW_U
condition|)
block|{
name|th
operator|->
name|th_flags
operator||=
name|TH_URG
expr_stmt|;
name|DECODEU
argument_list|(
argument|th->th_urp
argument_list|)
block|}
else|else
name|th
operator|->
name|th_flags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|NEW_W
condition|)
name|DECODES
argument_list|(
argument|th->th_win
argument_list|)
if|if
condition|(
name|changes
operator|&
name|NEW_A
condition|)
name|DECODEL
argument_list|(
argument|th->th_ack
argument_list|)
if|if
condition|(
name|changes
operator|&
name|NEW_S
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"NEW_S: %02x, %02x, %02x\n"
argument_list|,
operator|*
name|cp
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|,
name|cp
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|DECODEL
argument_list|(
argument|th->th_seq
argument_list|)
block|}
break|break;
block|}
if|if
condition|(
name|changes
operator|&
name|NEW_I
condition|)
block|{
name|DECODES
argument_list|(
argument|cs->cs_ip.ip_id
argument_list|)
block|}
else|else
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Uncompress: id = %04x, seq = %08x\n"
argument_list|,
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
argument_list|,
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * At this point, cp points to the first byte of data in the packet.  If    * we're not aligned on a 4-byte boundary, copy the data down so the ip&    * tcp headers will be aligned.  Then back up cp by the tcp/ip header    * length to make room for the reconstructed header (we assume the packet    * we were handed has enough space to prepend 128 bytes of header).  Adjust    * the length to account for the new header& fill in the IP total length.    */
name|len
operator|-=
operator|(
name|cp
operator|-
operator|*
name|bufp
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
comment|/*      * we must have dropped some characters (crc should detect this but the      * old slip framing won't)      */
goto|goto
name|bad
goto|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|(
name|int
operator|)
name|cp
operator|&
literal|3
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|cp
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|cp
operator|&
operator|~
literal|3
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|cp
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cp
operator|-=
name|cs
operator|->
name|cs_hlen
expr_stmt|;
name|len
operator|+=
name|cs
operator|->
name|cs_hlen
expr_stmt|;
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|cs
operator|->
name|cs_hlen
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|=
name|cp
expr_stmt|;
comment|/* recompute the ip header checksum */
block|{
specifier|register
name|u_short
modifier|*
name|bp
init|=
operator|(
name|u_short
operator|*
operator|)
name|cp
decl_stmt|;
for|for
control|(
name|changes
operator|=
literal|0
init|;
name|hlen
operator|>
literal|0
condition|;
name|hlen
operator|-=
literal|2
control|)
name|changes
operator|+=
operator|*
name|bp
operator|++
expr_stmt|;
name|changes
operator|=
operator|(
name|changes
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|changes
operator|>>
literal|16
operator|)
expr_stmt|;
name|changes
operator|=
operator|(
name|changes
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|changes
operator|>>
literal|16
operator|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|cp
operator|)
operator|->
name|ip_sum
operator|=
operator|~
name|changes
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
name|bad
label|:
name|comp
operator|->
name|flags
operator||=
name|SLF_TOSS
expr_stmt|;
name|INCR
argument_list|(
argument|sls_errorin
argument_list|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ReportCompress
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|VarTerm
condition|)
return|return
literal|1
return|;
name|fprintf
argument_list|(
name|VarTerm
argument_list|,
literal|"Out:  %d (compress) / %d (total)"
argument_list|,
name|slstat
operator|.
name|sls_compressed
argument_list|,
name|slstat
operator|.
name|sls_packets
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|VarTerm
argument_list|,
literal|"  %d (miss) / %d (search)\n"
argument_list|,
name|slstat
operator|.
name|sls_misses
argument_list|,
name|slstat
operator|.
name|sls_searches
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|VarTerm
argument_list|,
literal|"In:  %d (compress), %d (uncompress)"
argument_list|,
name|slstat
operator|.
name|sls_compressedin
argument_list|,
name|slstat
operator|.
name|sls_uncompressedin
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|VarTerm
argument_list|,
literal|"  %d (error),  %d (tossed)\n"
argument_list|,
name|slstat
operator|.
name|sls_errorin
argument_list|,
name|slstat
operator|.
name|sls_tossed
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

