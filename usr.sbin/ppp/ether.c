begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Brian Somers<brian@Awfulhak.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netgraph.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_ether.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_pppoe.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_socket.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NOKLDLOAD
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"layer.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"lqr.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"throughput.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ccp.h"
end_include

begin_include
include|#
directive|include
file|"link.h"
end_include

begin_include
include|#
directive|include
file|"async.h"
end_include

begin_include
include|#
directive|include
file|"descriptor.h"
end_include

begin_include
include|#
directive|include
file|"physical.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_include
include|#
directive|include
file|"chat.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"cbcp.h"
end_include

begin_include
include|#
directive|include
file|"datalink.h"
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_include
include|#
directive|include
file|"iplist.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"filter.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NORADIUS
end_ifndef

begin_include
include|#
directive|include
file|"radius.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bundle.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"ether.h"
end_include

begin_define
define|#
directive|define
name|PPPOE_NODE_TYPE_LEN
value|(sizeof NG_PPPOE_NODE_TYPE - 1)
end_define

begin_comment
comment|/* "PPPoE" */
end_comment

begin_struct
struct|struct
name|etherdevice
block|{
name|struct
name|device
name|dev
decl_stmt|;
comment|/* What struct physical knows about */
name|int
name|cs
decl_stmt|;
comment|/* Control socket */
name|int
name|connected
decl_stmt|;
comment|/* Are we connected yet ? */
name|int
name|timeout
decl_stmt|;
comment|/* Seconds attempting to connect */
name|char
name|hook
index|[
sizeof|sizeof
name|TUN_NAME
operator|+
literal|11
index|]
decl_stmt|;
comment|/* Our socket node hook */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|device2ether
parameter_list|(
name|d
parameter_list|)
define|\
value|((d)->type == ETHER_DEVICE ? (struct etherdevice *)d : NULL)
end_define

begin_function
name|int
name|ether_DeviceSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|etherdevice
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|ether_Write
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|v
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|struct
name|etherdevice
modifier|*
name|dev
init|=
name|device2ether
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
return|return
name|NgSendData
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|dev
operator|->
name|hook
argument_list|,
name|v
argument_list|,
name|n
argument_list|)
operator|==
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|ether_Read
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|v
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|char
name|hook
index|[
sizeof|sizeof
name|TUN_NAME
operator|+
literal|11
index|]
decl_stmt|;
return|return
name|NgRecvData
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|v
argument_list|,
name|n
argument_list|,
name|hook
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ether_RemoveFromSet
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|,
name|fd_set
modifier|*
name|r
parameter_list|,
name|fd_set
modifier|*
name|w
parameter_list|,
name|fd_set
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|etherdevice
modifier|*
name|dev
init|=
name|device2ether
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|r
operator|&&
name|dev
operator|->
name|cs
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"%s: fdunset(ctrl) %d\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|dev
operator|->
name|cs
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|result
operator|=
literal|0
expr_stmt|;
comment|/* Careful... physical_RemoveFromSet() called us ! */
name|p
operator|->
name|handler
operator|->
name|removefromset
operator|=
name|NULL
expr_stmt|;
name|result
operator|+=
name|physical_RemoveFromSet
argument_list|(
name|p
argument_list|,
name|r
argument_list|,
name|w
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|->
name|handler
operator|->
name|removefromset
operator|=
name|ether_RemoveFromSet
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ether_Free
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|etherdevice
modifier|*
name|dev
init|=
name|device2ether
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
name|physical_SetDescriptor
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|cs
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|dev
operator|->
name|cs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ether_OpenInfo
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|etherdevice
modifier|*
name|dev
init|=
name|device2ether
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|dev
operator|->
name|connected
condition|)
block|{
case|case
name|CARRIER_PENDING
case|:
return|return
literal|"negotiating"
return|;
case|case
name|CARRIER_OK
case|:
return|return
literal|"established"
return|;
block|}
return|return
literal|"disconnected"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ether_device2iov
parameter_list|(
name|struct
name|device
modifier|*
name|d
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|int
modifier|*
name|niov
parameter_list|,
name|int
name|maxiov
parameter_list|,
name|int
modifier|*
name|auxfd
parameter_list|,
name|int
modifier|*
name|nauxfd
parameter_list|)
block|{
name|struct
name|etherdevice
modifier|*
name|dev
init|=
name|device2ether
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|int
name|sz
init|=
name|physical_MaxDeviceSize
argument_list|()
decl_stmt|;
name|iov
index|[
operator|*
name|niov
index|]
operator|.
name|iov_base
operator|=
name|realloc
argument_list|(
name|d
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|iov
index|[
operator|*
name|niov
index|]
operator|.
name|iov_base
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"Failed to allocate memory: %d\n"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|AbortProgram
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|iov
index|[
operator|*
name|niov
index|]
operator|.
name|iov_len
operator|=
name|sz
expr_stmt|;
operator|(
operator|*
name|niov
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|cs
operator|>=
literal|0
condition|)
block|{
operator|*
name|auxfd
operator|=
name|dev
operator|->
name|cs
expr_stmt|;
operator|(
operator|*
name|nauxfd
operator|)
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ether_MessageIn
parameter_list|(
name|struct
name|etherdevice
modifier|*
name|dev
parameter_list|)
block|{
name|char
name|msgbuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ngpppoe_sts
argument_list|)
index|]
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|rep
init|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|msgbuf
decl_stmt|;
name|struct
name|ngpppoe_sts
modifier|*
name|sts
init|=
operator|(
expr|struct
name|ngpppoe_sts
operator|*
operator|)
operator|(
name|msgbuf
operator|+
sizeof|sizeof
expr|*
name|rep
operator|)
decl_stmt|;
name|char
name|unknown
index|[
literal|14
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
name|fd_set
name|r
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|cs
operator|<
literal|0
condition|)
return|return;
name|FD_ZERO
argument_list|(
operator|&
name|r
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|t
operator|.
name|tv_sec
operator|=
name|t
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|dev
operator|->
name|cs
operator|+
literal|1
argument_list|,
operator|&
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|t
argument_list|)
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|NgRecvMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|rep
argument_list|,
sizeof|sizeof
name|msgbuf
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|rep
operator|->
name|header
operator|.
name|version
operator|!=
name|NG_VERSION
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Unexpected netgraph version, expected %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|rep
operator|->
name|header
operator|.
name|version
argument_list|,
operator|(
name|long
operator|)
name|NG_VERSION
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rep
operator|->
name|header
operator|.
name|typecookie
operator|!=
name|NGM_PPPOE_COOKIE
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Unexpected netgraph cookie, expected %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|rep
operator|->
name|header
operator|.
name|typecookie
argument_list|,
operator|(
name|long
operator|)
name|NGM_PPPOE_COOKIE
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|rep
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPPOE_SET_FLAG
case|:
name|msg
operator|=
literal|"SET_FLAG"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_CONNECT
case|:
name|msg
operator|=
literal|"CONNECT"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_LISTEN
case|:
name|msg
operator|=
literal|"LISTEN"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_OFFER
case|:
name|msg
operator|=
literal|"OFFER"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_SUCCESS
case|:
name|msg
operator|=
literal|"SUCCESS"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_FAIL
case|:
name|msg
operator|=
literal|"FAIL"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_CLOSE
case|:
name|msg
operator|=
literal|"CLOSE"
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_GET_STATUS
case|:
name|msg
operator|=
literal|"GET_STATUS"
expr_stmt|;
break|break;
default|default:
name|snprintf
argument_list|(
name|unknown
argument_list|,
sizeof|sizeof
name|unknown
argument_list|,
literal|"<%d>"
argument_list|,
operator|(
name|int
operator|)
name|rep
operator|->
name|header
operator|.
name|cmd
argument_list|)
expr_stmt|;
name|msg
operator|=
name|unknown
expr_stmt|;
break|break;
block|}
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Received NGM_PPPOE_%s (hook \"%s\")\n"
argument_list|,
name|msg
argument_list|,
name|sts
operator|->
name|hook
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rep
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPPOE_SUCCESS
case|:
name|dev
operator|->
name|connected
operator|=
name|CARRIER_OK
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_FAIL
case|:
case|case
name|NGM_PPPOE_CLOSE
case|:
name|dev
operator|->
name|connected
operator|=
name|CARRIER_LOST
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ether_AwaitCarrier
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|etherdevice
modifier|*
name|dev
init|=
name|device2ether
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|connected
operator|!=
name|CARRIER_OK
operator|&&
operator|!
name|dev
operator|->
name|timeout
operator|--
condition|)
name|dev
operator|->
name|connected
operator|=
name|CARRIER_LOST
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|->
name|connected
operator|==
name|CARRIER_PENDING
condition|)
name|ether_MessageIn
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|dev
operator|->
name|connected
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|device
name|baseetherdevice
init|=
block|{
name|ETHER_DEVICE
block|,
literal|"ether"
block|,
name|ether_AwaitCarrier
block|,
name|ether_RemoveFromSet
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|ether_Free
block|,
name|ether_Read
block|,
name|ether_Write
block|,
name|ether_device2iov
block|,
name|NULL
block|,
name|ether_OpenInfo
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|device
modifier|*
name|ether_iov2device
parameter_list|(
name|int
name|type
parameter_list|,
name|struct
name|physical
modifier|*
name|p
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|int
modifier|*
name|niov
parameter_list|,
name|int
name|maxiov
parameter_list|,
name|int
modifier|*
name|auxfd
parameter_list|,
name|int
modifier|*
name|nauxfd
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|ETHER_DEVICE
condition|)
block|{
name|struct
name|etherdevice
modifier|*
name|dev
init|=
operator|(
expr|struct
name|etherdevice
operator|*
operator|)
name|iov
index|[
operator|(
operator|*
name|niov
operator|)
operator|++
index|]
operator|.
name|iov_base
decl_stmt|;
name|dev
operator|=
name|realloc
argument_list|(
name|dev
argument_list|,
sizeof|sizeof
expr|*
name|dev
argument_list|)
expr_stmt|;
comment|/* Reduce to the correct size */
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"Failed to allocate memory: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
expr|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|AbortProgram
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|nauxfd
condition|)
block|{
name|dev
operator|->
name|cs
operator|=
operator|*
name|auxfd
expr_stmt|;
operator|(
operator|*
name|nauxfd
operator|)
operator|--
expr_stmt|;
block|}
else|else
name|dev
operator|->
name|cs
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Refresh function pointers etc */
name|memcpy
argument_list|(
operator|&
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|baseetherdevice
argument_list|,
sizeof|sizeof
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
name|physical_SetupStack
argument_list|(
name|p
argument_list|,
name|dev
operator|->
name|dev
operator|.
name|name
argument_list|,
name|PHYSICAL_FORCE_SYNCNOACF
argument_list|)
expr_stmt|;
return|return
operator|&
name|dev
operator|->
name|dev
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ether_UpdateSet
parameter_list|(
name|struct
name|descriptor
modifier|*
name|d
parameter_list|,
name|fd_set
modifier|*
name|r
parameter_list|,
name|fd_set
modifier|*
name|w
parameter_list|,
name|fd_set
modifier|*
name|e
parameter_list|,
name|int
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|physical
modifier|*
name|p
init|=
name|descriptor2physical
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|etherdevice
modifier|*
name|dev
init|=
name|device2ether
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|r
operator|&&
name|dev
operator|->
name|cs
operator|>=
literal|0
condition|)
block|{
name|FD_SET
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"%s(ctrl): fdset(r) %d\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|dev
operator|->
name|cs
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|result
operator|=
literal|0
expr_stmt|;
name|result
operator|+=
name|physical_doUpdateSet
argument_list|(
name|d
argument_list|,
name|r
argument_list|,
name|w
argument_list|,
name|e
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ether_IsSet
parameter_list|(
name|struct
name|descriptor
modifier|*
name|d
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|physical
modifier|*
name|p
init|=
name|descriptor2physical
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|etherdevice
modifier|*
name|dev
init|=
name|device2ether
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|dev
operator|->
name|cs
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
name|result
operator|+=
name|physical_IsSet
argument_list|(
name|d
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ether_DescriptorRead
parameter_list|(
name|struct
name|descriptor
modifier|*
name|d
parameter_list|,
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|physical
modifier|*
name|p
init|=
name|descriptor2physical
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|etherdevice
modifier|*
name|dev
init|=
name|device2ether
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|cs
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|fdset
argument_list|)
condition|)
block|{
name|ether_MessageIn
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|connected
operator|==
name|CARRIER_LOST
condition|)
block|{
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"%s: Device disconnected\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|)
expr_stmt|;
name|datalink_Down
argument_list|(
name|p
operator|->
name|dl
argument_list|,
name|CLOSE_NORMAL
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|physical_IsSet
argument_list|(
name|d
argument_list|,
name|fdset
argument_list|)
condition|)
name|physical_DescriptorRead
argument_list|(
name|d
argument_list|,
name|bundle
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|device
modifier|*
name|ether_Abandon
parameter_list|(
name|struct
name|etherdevice
modifier|*
name|dev
parameter_list|,
name|struct
name|physical
modifier|*
name|p
parameter_list|)
block|{
comment|/* Abandon our node construction */
name|close
argument_list|(
name|dev
operator|->
name|cs
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
operator|->
name|fd
argument_list|)
expr_stmt|;
name|p
operator|->
name|fd
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Nobody else need try.. */
name|free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|device
modifier|*
name|ether_Create
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|)
block|{
name|u_char
name|rbuf
index|[
literal|2048
index|]
decl_stmt|;
name|struct
name|etherdevice
modifier|*
name|dev
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
decl_stmt|;
specifier|const
name|struct
name|hooklist
modifier|*
name|hlist
decl_stmt|;
specifier|const
name|struct
name|nodeinfo
modifier|*
name|ninfo
decl_stmt|;
name|int
name|f
decl_stmt|;
name|dev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fd
operator|<
literal|0
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|p
operator|->
name|name
operator|.
name|full
argument_list|,
name|NG_PPPOE_NODE_TYPE
argument_list|,
name|PPPOE_NODE_TYPE_LEN
argument_list|)
operator|&&
name|p
operator|->
name|name
operator|.
name|full
index|[
name|PPPOE_NODE_TYPE_LEN
index|]
operator|==
literal|':'
condition|)
block|{
specifier|const
name|struct
name|linkinfo
modifier|*
name|nlink
decl_stmt|;
name|struct
name|ngpppoe_init_data
modifier|*
name|data
decl_stmt|;
name|struct
name|ngm_mkpeer
name|mkp
decl_stmt|;
name|struct
name|ngm_connect
name|ngc
decl_stmt|;
specifier|const
name|char
modifier|*
name|iface
decl_stmt|,
modifier|*
name|provider
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
name|etherid
index|[
literal|12
index|]
decl_stmt|;
name|int
name|ifacelen
decl_stmt|,
name|providerlen
decl_stmt|;
name|char
name|connectpath
index|[
sizeof|sizeof
name|dev
operator|->
name|hook
operator|+
literal|2
index|]
decl_stmt|;
comment|/* .:<hook> */
name|p
operator|->
name|fd
operator|--
expr_stmt|;
comment|/* We own the device - change fd */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NOKLDLOAD
argument_list|)
if|if
condition|(
name|modfind
argument_list|(
literal|"netgraph"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Netgraph is not built into the kernel\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|modfind
argument_list|(
literal|"ng_socket"
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|ID0kldload
argument_list|(
literal|"ng_socket"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"kldload: ng_socket: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|iface
operator|=
name|p
operator|->
name|name
operator|.
name|full
operator|+
name|PPPOE_NODE_TYPE_LEN
operator|+
literal|1
expr_stmt|;
name|provider
operator|=
name|strchr
argument_list|(
name|iface
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|provider
condition|)
block|{
name|ifacelen
operator|=
name|provider
operator|-
name|iface
expr_stmt|;
name|provider
operator|++
expr_stmt|;
name|providerlen
operator|=
name|strlen
argument_list|(
name|provider
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifacelen
operator|=
name|strlen
argument_list|(
name|iface
argument_list|)
expr_stmt|;
name|provider
operator|=
literal|""
expr_stmt|;
name|providerlen
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * We're going to do this (where tunN is our tunnel device):      *      * .---------.      * |  ether  |      * |<iface> |                         dev->cs      * `---------'                           |      *  (orphan)                     p->fd   |      *     |                           |     |      *     |                           |     |      * (ethernet)                      |     |      * .---------.                  .-----------.      * |  pppoe  |                  |  socket   |      * |<iface> |(tunN)<---->(tunN)|<unnamed> |      * `---------                   `-----------'      *   (tunX)      *     ^      *     |      *     `--->(tunX)      */
comment|/* Create a socket node */
if|if
condition|(
name|ID0NgMkSockNode
argument_list|(
name|NULL
argument_list|,
operator|&
name|dev
operator|->
name|cs
argument_list|,
operator|&
name|p
operator|->
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Cannot create netgraph socket node: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*      * Ask for a list of hooks attached to the "ether" node.  This node should      * magically exist as a way of hooking stuff onto an ethernet device      */
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|ifacelen
operator|+
literal|2
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|path
argument_list|,
literal|"%.*s:"
argument_list|,
name|ifacelen
argument_list|,
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|path
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NGM_LISTHOOKS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s Cannot send a netgraph message: %s\n"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ether_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
comment|/* Get our list back */
name|resp
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|rbuf
expr_stmt|;
if|if
condition|(
name|NgRecvMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|resp
argument_list|,
sizeof|sizeof
name|rbuf
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Cannot get netgraph response: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ether_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
name|hlist
operator|=
operator|(
specifier|const
expr|struct
name|hooklist
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|ninfo
operator|=
operator|&
name|hlist
operator|->
name|nodeinfo
expr_stmt|;
comment|/* Make sure we've got the right type of node */
if|if
condition|(
name|strncmp
argument_list|(
name|ninfo
operator|->
name|type
argument_list|,
name|NG_ETHER_NODE_TYPE
argument_list|,
sizeof|sizeof
name|NG_ETHER_NODE_TYPE
operator|-
literal|1
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s Unexpected node type ``%s'' (wanted ``"
name|NG_ETHER_NODE_TYPE
literal|"'')\n"
argument_list|,
name|path
argument_list|,
name|ninfo
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
name|ether_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"List of netgraph node ``%s'' (id %x) hooks:\n"
argument_list|,
name|path
argument_list|,
name|ninfo
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* look for a hook already attached.  */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|ninfo
operator|->
name|hooks
condition|;
name|f
operator|++
control|)
block|{
name|nlink
operator|=
operator|&
name|hlist
operator|->
name|link
index|[
name|f
index|]
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"  Found %s -> %s\n"
argument_list|,
name|nlink
operator|->
name|ourhook
argument_list|,
name|nlink
operator|->
name|peerhook
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nlink
operator|->
name|ourhook
argument_list|,
name|NG_ETHER_HOOK_ORPHAN
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|nlink
operator|->
name|ourhook
argument_list|,
name|NG_ETHER_HOOK_DIVERT
argument_list|)
condition|)
block|{
comment|/*          * Something is using the data coming out of this ``ether'' node.          * If it's a PPPoE node, we use that node, otherwise we complain that          * someone else is using the node.          */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nlink
operator|->
name|nodeinfo
operator|.
name|type
argument_list|,
name|NG_PPPOE_NODE_TYPE
argument_list|)
condition|)
comment|/* Use this PPPoE node ! */
name|snprintf
argument_list|(
name|ngc
operator|.
name|path
argument_list|,
sizeof|sizeof
name|ngc
operator|.
name|path
argument_list|,
literal|"[%x]:"
argument_list|,
name|nlink
operator|->
name|nodeinfo
operator|.
name|id
argument_list|)
expr_stmt|;
else|else
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s Node type ``%s'' is currently active\n"
argument_list|,
name|path
argument_list|,
name|nlink
operator|->
name|nodeinfo
operator|.
name|type
argument_list|)
expr_stmt|;
return|return
name|ether_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|==
name|ninfo
operator|->
name|hooks
condition|)
block|{
comment|/*        * Create a new ``PPPoE'' node connected to the ``ether'' node using        * the magic ``orphan'' and ``ethernet'' hooks        */
name|snprintf
argument_list|(
name|mkp
operator|.
name|type
argument_list|,
sizeof|sizeof
name|mkp
operator|.
name|type
argument_list|,
literal|"%s"
argument_list|,
name|NG_PPPOE_NODE_TYPE
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|mkp
operator|.
name|ourhook
argument_list|,
sizeof|sizeof
name|mkp
operator|.
name|ourhook
argument_list|,
literal|"%s"
argument_list|,
name|NG_ETHER_HOOK_ORPHAN
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|mkp
operator|.
name|peerhook
argument_list|,
sizeof|sizeof
name|mkp
operator|.
name|peerhook
argument_list|,
literal|"%s"
argument_list|,
name|NG_PPPOE_HOOK_ETHERNET
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|etherid
argument_list|,
sizeof|sizeof
name|etherid
argument_list|,
literal|"[%x]:"
argument_list|,
name|ninfo
operator|->
name|id
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Creating PPPoE netgraph node %s%s -> %s\n"
argument_list|,
name|etherid
argument_list|,
name|mkp
operator|.
name|ourhook
argument_list|,
name|mkp
operator|.
name|peerhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|etherid
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NGM_MKPEER
argument_list|,
operator|&
name|mkp
argument_list|,
sizeof|sizeof
name|mkp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s Cannot create PPPoE netgraph node: %s\n"
argument_list|,
name|etherid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ether_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
name|snprintf
argument_list|(
name|ngc
operator|.
name|path
argument_list|,
sizeof|sizeof
name|ngc
operator|.
name|path
argument_list|,
literal|"%s%s"
argument_list|,
name|path
argument_list|,
name|NG_ETHER_HOOK_ORPHAN
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|dev
operator|->
name|hook
argument_list|,
sizeof|sizeof
name|dev
operator|->
name|hook
argument_list|,
literal|"%s%d"
argument_list|,
name|TUN_NAME
argument_list|,
name|p
operator|->
name|dl
operator|->
name|bundle
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/*      * Connect the PPPoE node to our socket node.      * ngc.path has already been set up      */
name|snprintf
argument_list|(
name|ngc
operator|.
name|ourhook
argument_list|,
sizeof|sizeof
name|ngc
operator|.
name|ourhook
argument_list|,
literal|"%s"
argument_list|,
name|dev
operator|->
name|hook
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ngc
operator|.
name|peerhook
argument_list|,
name|ngc
operator|.
name|ourhook
argument_list|,
sizeof|sizeof
name|ngc
operator|.
name|peerhook
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Connecting netgraph socket .:%s -> %s:%s\n"
argument_list|,
name|ngc
operator|.
name|ourhook
argument_list|,
name|ngc
operator|.
name|path
argument_list|,
name|ngc
operator|.
name|peerhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
literal|".:"
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NGM_CONNECT
argument_list|,
operator|&
name|ngc
argument_list|,
sizeof|sizeof
name|ngc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Cannot connect PPPoE and socket netgraph "
literal|"nodes: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ether_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
comment|/* And finally, request a connection to the given provider */
name|data
operator|=
operator|(
expr|struct
name|ngpppoe_init_data
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
expr|*
name|data
operator|+
name|providerlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|data
operator|->
name|hook
argument_list|,
sizeof|sizeof
name|data
operator|->
name|hook
argument_list|,
literal|"%s"
argument_list|,
name|dev
operator|->
name|hook
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|data
operator|->
name|data
argument_list|,
name|provider
argument_list|)
expr_stmt|;
name|data
operator|->
name|data_len
operator|=
name|providerlen
expr_stmt|;
name|snprintf
argument_list|(
name|connectpath
argument_list|,
sizeof|sizeof
name|connectpath
argument_list|,
literal|".:%s"
argument_list|,
name|dev
operator|->
name|hook
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Sending PPPOE_CONNECT to %s\n"
argument_list|,
name|connectpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|connectpath
argument_list|,
name|NGM_PPPOE_COOKIE
argument_list|,
name|NGM_PPPOE_CONNECT
argument_list|,
name|data
argument_list|,
sizeof|sizeof
expr|*
name|data
operator|+
name|providerlen
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"``%s'': Cannot start netgraph node: %s\n"
argument_list|,
name|connectpath
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ether_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
name|dev
operator|->
name|timeout
operator|=
name|p
operator|->
name|cfg
operator|.
name|cd
operator|.
name|delay
expr_stmt|;
name|dev
operator|->
name|connected
operator|=
name|CARRIER_PENDING
expr_stmt|;
comment|/* Hook things up so that we monitor dev->cs */
name|p
operator|->
name|desc
operator|.
name|UpdateSet
operator|=
name|ether_UpdateSet
expr_stmt|;
name|p
operator|->
name|desc
operator|.
name|IsSet
operator|=
name|ether_IsSet
expr_stmt|;
name|p
operator|->
name|desc
operator|.
name|Read
operator|=
name|ether_DescriptorRead
expr_stmt|;
block|}
else|else
block|{
comment|/* See if we're a netgraph socket */
name|struct
name|sockaddr_ng
name|ngsock
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sock
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ngsock
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|sz
operator|=
sizeof|sizeof
name|ngsock
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|sock
argument_list|,
operator|&
name|sz
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|sock
operator|->
name|sa_family
operator|==
name|AF_NETGRAPH
condition|)
block|{
comment|/*        * It's a netgraph node... We can't determine hook names etc, so we        * stay pretty impartial....        */
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"%s: Link is a netgraph node\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Cannot allocate an ether device: %s\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dev
operator|->
name|cs
operator|=
operator|-
literal|1
expr_stmt|;
name|dev
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|connected
operator|=
name|CARRIER_OK
expr_stmt|;
operator|*
name|dev
operator|->
name|hook
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dev
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|baseetherdevice
argument_list|,
sizeof|sizeof
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
name|physical_SetupStack
argument_list|(
name|p
argument_list|,
name|dev
operator|->
name|dev
operator|.
name|name
argument_list|,
name|PHYSICAL_FORCE_SYNCNOACF
argument_list|)
expr_stmt|;
comment|/* Moan about (and fix) invalid LCP configurations */
if|if
condition|(
name|p
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|mru
operator|>
literal|1492
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Reducing MRU to 1492\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|mru
operator|=
literal|1492
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|dl
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|mtu
operator|>
literal|1492
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Reducing MTU to 1492\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|)
expr_stmt|;
name|p
operator|->
name|dl
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|mtu
operator|=
literal|1492
expr_stmt|;
block|}
return|return
operator|&
name|dev
operator|->
name|dev
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

