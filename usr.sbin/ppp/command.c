begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *		PPP User command processing module  *  *	    Written by Toshiharu OHNO (tony-o@iij.ad.jp)  *  *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the Internet Initiative Japan, Inc.  The name of the  * IIJ may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * $Id: command.c,v 1.153 1998/07/04 10:24:49 brian Exp $  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NOALIAS
end_ifndef

begin_include
include|#
directive|include
file|<alias.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"iplist.h"
end_include

begin_include
include|#
directive|include
file|"throughput.h"
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"modem.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NOALIAS
end_ifndef

begin_include
include|#
directive|include
file|"alias_cmd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"lqr.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"systems.h"
end_include

begin_include
include|#
directive|include
file|"filter.h"
end_include

begin_include
include|#
directive|include
file|"descriptor.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_include
include|#
directive|include
file|"ccp.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"async.h"
end_include

begin_include
include|#
directive|include
file|"link.h"
end_include

begin_include
include|#
directive|include
file|"physical.h"
end_include

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_include
include|#
directive|include
file|"bundle.h"
end_include

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"prompt.h"
end_include

begin_include
include|#
directive|include
file|"chat.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"datalink.h"
end_include

begin_comment
comment|/* ``set'' values */
end_comment

begin_define
define|#
directive|define
name|VAR_AUTHKEY
value|0
end_define

begin_define
define|#
directive|define
name|VAR_DIAL
value|1
end_define

begin_define
define|#
directive|define
name|VAR_LOGIN
value|2
end_define

begin_define
define|#
directive|define
name|VAR_AUTHNAME
value|3
end_define

begin_define
define|#
directive|define
name|VAR_AUTOLOAD
value|4
end_define

begin_define
define|#
directive|define
name|VAR_WINSIZE
value|5
end_define

begin_define
define|#
directive|define
name|VAR_DEVICE
value|6
end_define

begin_define
define|#
directive|define
name|VAR_ACCMAP
value|7
end_define

begin_define
define|#
directive|define
name|VAR_MRRU
value|8
end_define

begin_define
define|#
directive|define
name|VAR_MRU
value|9
end_define

begin_define
define|#
directive|define
name|VAR_MTU
value|10
end_define

begin_define
define|#
directive|define
name|VAR_OPENMODE
value|11
end_define

begin_define
define|#
directive|define
name|VAR_PHONE
value|12
end_define

begin_define
define|#
directive|define
name|VAR_HANGUP
value|13
end_define

begin_define
define|#
directive|define
name|VAR_IDLETIMEOUT
value|14
end_define

begin_define
define|#
directive|define
name|VAR_LQRPERIOD
value|15
end_define

begin_define
define|#
directive|define
name|VAR_LCPRETRY
value|16
end_define

begin_define
define|#
directive|define
name|VAR_CHAPRETRY
value|17
end_define

begin_define
define|#
directive|define
name|VAR_PAPRETRY
value|18
end_define

begin_define
define|#
directive|define
name|VAR_CCPRETRY
value|19
end_define

begin_define
define|#
directive|define
name|VAR_IPCPRETRY
value|20
end_define

begin_define
define|#
directive|define
name|VAR_DNS
value|21
end_define

begin_define
define|#
directive|define
name|VAR_NBNS
value|22
end_define

begin_define
define|#
directive|define
name|VAR_MODE
value|23
end_define

begin_comment
comment|/* ``accept|deny|disable|enable'' masks */
end_comment

begin_define
define|#
directive|define
name|NEG_HISMASK
value|(1)
end_define

begin_define
define|#
directive|define
name|NEG_MYMASK
value|(2)
end_define

begin_comment
comment|/* ``accept|deny|disable|enable'' values */
end_comment

begin_define
define|#
directive|define
name|NEG_ACFCOMP
value|40
end_define

begin_define
define|#
directive|define
name|NEG_CHAP
value|41
end_define

begin_define
define|#
directive|define
name|NEG_DEFLATE
value|42
end_define

begin_define
define|#
directive|define
name|NEG_LQR
value|43
end_define

begin_define
define|#
directive|define
name|NEG_PAP
value|44
end_define

begin_define
define|#
directive|define
name|NEG_PPPDDEFLATE
value|45
end_define

begin_define
define|#
directive|define
name|NEG_PRED1
value|46
end_define

begin_define
define|#
directive|define
name|NEG_PROTOCOMP
value|47
end_define

begin_define
define|#
directive|define
name|NEG_SHORTSEQ
value|48
end_define

begin_define
define|#
directive|define
name|NEG_VJCOMP
value|49
end_define

begin_define
define|#
directive|define
name|NEG_DNS
value|50
end_define

begin_decl_stmt
specifier|const
name|char
name|Version
index|[]
init|=
literal|"2.0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|VersionDate
index|[]
init|=
literal|"$Date: 1998/07/04 10:24:49 $"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ShowCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|TerminalCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|QuitCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|OpenCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|CloseCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|DownCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|AllowCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SetCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|LinkCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|AddCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|DeleteCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|NegotiateCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ClearCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NOALIAS
end_ifndef

begin_function_decl
specifier|static
name|int
name|AliasCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|AliasEnable
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|AliasOption
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|showcx
parameter_list|(
name|struct
name|cmdtab
specifier|const
modifier|*
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX
condition|)
return|return
literal|"(c)"
return|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX_OPT
condition|)
return|return
literal|"(o)"
return|;
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|HelpCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cmdtab
specifier|const
modifier|*
name|cmd
decl_stmt|;
name|int
name|n
decl_stmt|,
name|cmax
decl_stmt|,
name|dmax
decl_stmt|,
name|cols
decl_stmt|,
name|cxlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|cx
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|->
name|prompt
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"help: Cannot help without a prompt\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
for|for
control|(
name|cmd
operator|=
name|arg
operator|->
name|cmdtab
init|;
name|cmd
operator|->
name|name
operator|||
name|cmd
operator|->
name|alias
condition|;
name|cmd
operator|++
control|)
if|if
condition|(
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|arg
operator|->
name|prompt
operator|->
name|auth
operator|)
operator|&&
operator|(
operator|(
name|cmd
operator|->
name|name
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|cmd
operator|->
name|name
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
operator|)
operator|||
operator|(
name|cmd
operator|->
name|alias
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|cmd
operator|->
name|alias
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%s %s\n"
argument_list|,
name|cmd
operator|->
name|syntax
argument_list|,
name|showcx
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|cmax
operator|=
name|dmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cmd
operator|=
name|arg
operator|->
name|cmdtab
init|;
name|cmd
operator|->
name|func
condition|;
name|cmd
operator|++
control|)
if|if
condition|(
name|cmd
operator|->
name|name
operator|&&
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|arg
operator|->
name|prompt
operator|->
name|auth
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|cmd
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|showcx
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|)
operator|>
name|cmax
condition|)
name|cmax
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|cmd
operator|->
name|helpmes
argument_list|)
operator|)
operator|>
name|dmax
condition|)
name|dmax
operator|=
name|n
expr_stmt|;
block|}
name|cols
operator|=
literal|80
operator|/
operator|(
name|dmax
operator|+
name|cmax
operator|+
literal|3
operator|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"(o) = Optional context,"
literal|" (c) = Context required\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|cmd
operator|=
name|arg
operator|->
name|cmdtab
init|;
name|cmd
operator|->
name|func
condition|;
name|cmd
operator|++
control|)
if|if
condition|(
name|cmd
operator|->
name|name
operator|&&
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|arg
operator|->
name|prompt
operator|->
name|auth
operator|)
condition|)
block|{
name|cx
operator|=
name|showcx
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cxlen
operator|=
name|cmax
operator|-
name|strlen
argument_list|(
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" %s%-*.*s: %-*.*s"
argument_list|,
name|cmd
operator|->
name|name
argument_list|,
name|cxlen
argument_list|,
name|cxlen
argument_list|,
name|cx
argument_list|,
name|dmax
argument_list|,
name|dmax
argument_list|,
name|cmd
operator|->
name|helpmes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|n
operator|%
name|cols
operator|==
literal|0
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|%
name|cols
operator|!=
literal|0
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|CloneCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|namelist
index|[
name|LINE_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|f
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
return|return
operator|-
literal|1
return|;
name|namelist
index|[
sizeof|sizeof
name|namelist
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|f
operator|=
name|arg
operator|->
name|argn
init|;
name|f
operator|<
name|arg
operator|->
name|argc
condition|;
name|f
operator|++
control|)
block|{
name|strncpy
argument_list|(
name|namelist
argument_list|,
name|arg
operator|->
name|argv
index|[
name|f
index|]
argument_list|,
sizeof|sizeof
name|namelist
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|name
operator|=
name|strtok
argument_list|(
name|namelist
argument_list|,
literal|", "
argument_list|)
init|;
name|name
condition|;
name|name
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|", "
argument_list|)
control|)
name|bundle_DatalinkClone
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|RemoveCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|!=
name|arg
operator|->
name|argn
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|arg
operator|->
name|cx
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"remove: Cannot delete links that aren't closed\n"
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|bundle_DatalinkRemove
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|RenameCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|!=
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bundle_RenameDatalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s -> %s: target name already exists\n"
argument_list|,
name|arg
operator|->
name|cx
operator|->
name|name
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|LoadCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
name|name
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
expr_stmt|;
else|else
name|name
operator|=
literal|"default"
expr_stmt|;
if|if
condition|(
operator|!
name|system_IsValid
argument_list|(
name|name
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|phys_type
operator|.
name|all
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Label not allowed\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/*      * Set the label before& after so that `set enddisc' works and      * we handle nested `load' commands.      */
name|bundle_SetLabel
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|?
name|name
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|system_Select
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|name
argument_list|,
name|CONFFILE
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bundle_SetLabel
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: label not found.\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bundle_SetLabel
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|?
name|name
else|:
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|SaveCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"save command is not implemented (yet).\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DialCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|arg
operator|->
name|cx
operator|&&
operator|!
operator|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|type
operator|&
operator|(
name|PHYS_INTERACTIVE
operator||
name|PHYS_AUTO
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|arg
operator|->
name|cx
operator|&&
operator|(
name|arg
operator|->
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|&
operator|~
operator|(
name|PHYS_INTERACTIVE
operator||
name|PHYS_AUTO
operator|)
operator|)
operator|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Manual dial is only available for auto and"
literal|" interactive links\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|&&
operator|(
name|res
operator|=
name|LoadCommand
argument_list|(
name|arg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|res
return|;
name|bundle_Open
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
condition|?
name|arg
operator|->
name|cx
operator|->
name|name
else|:
name|NULL
argument_list|,
name|PHYS_ALL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShellCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|,
name|int
name|bg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|shell
decl_stmt|;
name|pid_t
name|shpid
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SHELL_ONLY_INTERACTIVELY
comment|/* we're only allowed to shell when we run ppp interactively */
if|if
condition|(
name|arg
operator|->
name|prompt
operator|&&
name|arg
operator|->
name|prompt
operator|->
name|owner
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Can't start a shell from a network connection\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|prompt
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Can't start an interactive shell from"
literal|" a config file\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
operator|->
name|owner
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Can't start an interactive shell from"
literal|" a socket connection\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|bg
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Can only start an interactive shell in"
literal|" the foreground mode\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
operator|(
name|shpid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|shell
operator|=
name|_PATH_BSHELL
expr_stmt|;
name|timer_TermService
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|fd
operator|=
name|arg
operator|->
name|prompt
operator|->
name|fd_out
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PATH_DEVNULL
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"Failed to open %s: %s\n"
argument_list|,
name|_PATH_DEVNULL
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|dup2
argument_list|(
name|fd
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
literal|3
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set close-on-exec flag */
name|setuid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
comment|/* substitute pseudo args */
name|argv
index|[
literal|0
index|]
operator|=
name|strdup
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|argc
operator|=
literal|1
init|;
name|argc
operator|<
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
condition|;
name|argc
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|argc
operator|+
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"HISADDR"
argument_list|)
operator|==
literal|0
condition|)
name|argv
index|[
name|argc
index|]
operator|=
name|strdup
argument_list|(
name|inet_ntoa
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|peer_ip
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|argc
operator|+
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"INTERFACE"
argument_list|)
operator|==
literal|0
condition|)
name|argv
index|[
name|argc
index|]
operator|=
name|strdup
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|ifp
operator|.
name|Name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|argc
operator|+
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"MYADDR"
argument_list|)
operator|==
literal|0
condition|)
name|argv
index|[
name|argc
index|]
operator|=
name|strdup
argument_list|(
name|inet_ntoa
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|my_ip
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|argv
index|[
name|argc
index|]
operator|=
name|strdup
argument_list|(
name|arg
operator|->
name|argv
index|[
name|argc
operator|+
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bg
condition|)
block|{
name|pid_t
name|p
decl_stmt|;
name|p
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|daemon
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"%d: daemon: %s\n"
argument_list|,
operator|(
name|int
operator|)
name|p
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|printf
argument_list|(
literal|"ppp: Pausing until %s finishes\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|printf
argument_list|(
literal|"ppp: Pausing until %s finishes\n"
argument_list|,
name|shell
argument_list|)
expr_stmt|;
name|prompt_TtyOldMode
argument_list|(
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|shell
argument_list|,
name|shell
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"exec() of %s failed\n"
argument_list|,
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|?
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
else|:
name|shell
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shpid
operator|==
operator|(
name|pid_t
operator|)
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Fork failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|status
decl_stmt|;
name|waitpid
argument_list|(
name|shpid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|->
name|prompt
operator|&&
operator|!
name|arg
operator|->
name|prompt
operator|->
name|owner
condition|)
name|prompt_TtyCommandMode
argument_list|(
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|BgShellCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ShellCommand
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FgShellCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|ShellCommand
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|Commands
index|[]
init|=
block|{
block|{
literal|"accept"
block|,
name|NULL
block|,
name|NegotiateCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"accept option request"
block|,
literal|"accept option .."
block|}
block|,
block|{
literal|"add"
block|,
name|NULL
block|,
name|AddCommand
block|,
name|LOCAL_AUTH
block|,
literal|"add route"
block|,
literal|"add dest mask gateway"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"add!"
block|,
name|AddCommand
block|,
name|LOCAL_AUTH
block|,
literal|"add or change route"
block|,
literal|"add! dest mask gateway"
block|,
operator|(
name|void
operator|*
operator|)
literal|1
block|}
block|,
ifndef|#
directive|ifndef
name|NOALIAS
block|{
literal|"alias"
block|,
name|NULL
block|,
name|AliasCommand
block|,
name|LOCAL_AUTH
block|,
literal|"alias control"
block|,
literal|"alias option [yes|no]"
block|}
block|,
endif|#
directive|endif
block|{
literal|"allow"
block|,
literal|"auth"
block|,
name|AllowCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Allow ppp access"
block|,
literal|"allow users|modes ...."
block|}
block|,
block|{
literal|"bg"
block|,
literal|"!bg"
block|,
name|BgShellCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Run a background command"
block|,
literal|"[!]bg command"
block|}
block|,
block|{
literal|"clear"
block|,
name|NULL
block|,
name|ClearCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Clear throughput statistics"
block|,
literal|"clear ipcp|modem [current|overall|peak]..."
block|}
block|,
block|{
literal|"clone"
block|,
name|NULL
block|,
name|CloneCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Clone a link"
block|,
literal|"clone newname..."
block|}
block|,
block|{
literal|"close"
block|,
name|NULL
block|,
name|CloseCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Close an FSM"
block|,
literal|"close [lcp|ccp]"
block|}
block|,
block|{
literal|"delete"
block|,
name|NULL
block|,
name|DeleteCommand
block|,
name|LOCAL_AUTH
block|,
literal|"delete route"
block|,
literal|"delete dest"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"delete!"
block|,
name|DeleteCommand
block|,
name|LOCAL_AUTH
block|,
literal|"delete a route if it exists"
block|,
literal|"delete! dest"
block|,
operator|(
name|void
operator|*
operator|)
literal|1
block|}
block|,
block|{
literal|"deny"
block|,
name|NULL
block|,
name|NegotiateCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Deny option request"
block|,
literal|"deny option .."
block|}
block|,
block|{
literal|"dial"
block|,
literal|"call"
block|,
name|DialCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Dial and login"
block|,
literal|"dial|call [remote]"
block|}
block|,
block|{
literal|"disable"
block|,
name|NULL
block|,
name|NegotiateCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Disable option"
block|,
literal|"disable option .."
block|}
block|,
block|{
literal|"down"
block|,
name|NULL
block|,
name|DownCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Generate a down event"
block|,
literal|"down"
block|}
block|,
block|{
literal|"enable"
block|,
name|NULL
block|,
name|NegotiateCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Enable option"
block|,
literal|"enable option .."
block|}
block|,
block|{
literal|"link"
block|,
literal|"datalink"
block|,
name|LinkCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Link specific commands"
block|,
literal|"link name command ..."
block|}
block|,
block|{
literal|"load"
block|,
name|NULL
block|,
name|LoadCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Load settings"
block|,
literal|"load [remote]"
block|}
block|,
block|{
literal|"open"
block|,
name|NULL
block|,
name|OpenCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Open an FSM"
block|,
literal|"open [lcp|ccp|ipcp]"
block|}
block|,
block|{
literal|"passwd"
block|,
name|NULL
block|,
name|PasswdCommand
block|,
name|LOCAL_NO_AUTH
block|,
literal|"Password for manipulation"
block|,
literal|"passwd LocalPassword"
block|}
block|,
block|{
literal|"quit"
block|,
literal|"bye"
block|,
name|QuitCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Quit PPP program"
block|,
literal|"quit|bye [all]"
block|}
block|,
block|{
literal|"remove"
block|,
literal|"rm"
block|,
name|RemoveCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Remove a link"
block|,
literal|"remove"
block|}
block|,
block|{
literal|"rename"
block|,
literal|"mv"
block|,
name|RenameCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Rename a link"
block|,
literal|"rename name"
block|}
block|,
block|{
literal|"save"
block|,
name|NULL
block|,
name|SaveCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Save settings"
block|,
literal|"save"
block|}
block|,
block|{
literal|"set"
block|,
literal|"setup"
block|,
name|SetCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Set parameters"
block|,
literal|"set[up] var value"
block|}
block|,
block|{
literal|"shell"
block|,
literal|"!"
block|,
name|FgShellCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Run a subshell"
block|,
literal|"shell|! [sh command]"
block|}
block|,
block|{
literal|"show"
block|,
name|NULL
block|,
name|ShowCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Show status and stats"
block|,
literal|"show var"
block|}
block|,
block|{
literal|"term"
block|,
name|NULL
block|,
name|TerminalCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Enter terminal mode"
block|,
literal|"term"
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Display this message"
block|,
literal|"help|? [command]"
block|,
name|Commands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ShowEscape
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
literal|32
index|]
condition|)
block|{
name|int
name|code
decl_stmt|,
name|bit
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
init|=
literal|""
decl_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|32
condition|;
name|code
operator|++
control|)
if|if
condition|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
name|code
index|]
condition|)
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
literal|8
condition|;
name|bit
operator|++
control|)
if|if
condition|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
name|code
index|]
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
condition|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%s0x%02x"
argument_list|,
name|sep
argument_list|,
operator|(
name|code
operator|<<
literal|3
operator|)
operator|+
name|bit
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShowTimerList
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|timer_Show
argument_list|(
literal|0
argument_list|,
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShowStopped
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Stopped Timer:  LCP: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Disabled"
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%ld secs"
argument_list|,
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|/
name|SECTICKS
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|", CCP: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|ccp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Disabled"
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%ld secs"
argument_list|,
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|ccp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|/
name|SECTICKS
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShowVersion
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"PPP Version %s - %s\n"
argument_list|,
name|Version
argument_list|,
name|VersionDate
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShowProtocolStats
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|link
modifier|*
name|l
init|=
name|command_ChooseLink
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%s:\n"
argument_list|,
name|l
operator|->
name|name
argument_list|)
expr_stmt|;
name|link_ReportProtocolStatus
argument_list|(
name|l
argument_list|,
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|ShowCommands
index|[]
init|=
block|{
block|{
literal|"bundle"
block|,
name|NULL
block|,
name|bundle_ShowStatus
block|,
name|LOCAL_AUTH
block|,
literal|"bundle details"
block|,
literal|"show bundle"
block|}
block|,
block|{
literal|"ccp"
block|,
name|NULL
block|,
name|ccp_ReportStatus
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"CCP status"
block|,
literal|"show cpp"
block|}
block|,
block|{
literal|"compress"
block|,
name|NULL
block|,
name|sl_Show
block|,
name|LOCAL_AUTH
block|,
literal|"VJ compression stats"
block|,
literal|"show compress"
block|}
block|,
block|{
literal|"escape"
block|,
name|NULL
block|,
name|ShowEscape
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"escape characters"
block|,
literal|"show escape"
block|}
block|,
block|{
literal|"filter"
block|,
name|NULL
block|,
name|filter_Show
block|,
name|LOCAL_AUTH
block|,
literal|"packet filters"
block|,
literal|"show filter [in|out|dial|alive]"
block|}
block|,
block|{
literal|"hdlc"
block|,
name|NULL
block|,
name|hdlc_ReportStatus
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"HDLC errors"
block|,
literal|"show hdlc"
block|}
block|,
block|{
literal|"ipcp"
block|,
name|NULL
block|,
name|ipcp_Show
block|,
name|LOCAL_AUTH
block|,
literal|"IPCP status"
block|,
literal|"show ipcp"
block|}
block|,
block|{
literal|"lcp"
block|,
name|NULL
block|,
name|lcp_ReportStatus
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"LCP status"
block|,
literal|"show lcp"
block|}
block|,
block|{
literal|"link"
block|,
literal|"datalink"
block|,
name|datalink_Show
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"(high-level) link info"
block|,
literal|"show link"
block|}
block|,
block|{
literal|"links"
block|,
name|NULL
block|,
name|bundle_ShowLinks
block|,
name|LOCAL_AUTH
block|,
literal|"available link names"
block|,
literal|"show links"
block|}
block|,
block|{
literal|"log"
block|,
name|NULL
block|,
name|log_ShowLevel
block|,
name|LOCAL_AUTH
block|,
literal|"log levels"
block|,
literal|"show log"
block|}
block|,
block|{
literal|"mem"
block|,
name|NULL
block|,
name|mbuf_Show
block|,
name|LOCAL_AUTH
block|,
literal|"mbuf allocations"
block|,
literal|"show mem"
block|}
block|,
block|{
literal|"modem"
block|,
name|NULL
block|,
name|modem_ShowStatus
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"(low-level) link info"
block|,
literal|"show modem"
block|}
block|,
block|{
literal|"mp"
block|,
literal|"multilink"
block|,
name|mp_ShowStatus
block|,
name|LOCAL_AUTH
block|,
literal|"multilink setup"
block|,
literal|"show mp"
block|}
block|,
block|{
literal|"proto"
block|,
name|NULL
block|,
name|ShowProtocolStats
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"protocol summary"
block|,
literal|"show proto"
block|}
block|,
block|{
literal|"route"
block|,
name|NULL
block|,
name|route_Show
block|,
name|LOCAL_AUTH
block|,
literal|"routing table"
block|,
literal|"show route"
block|}
block|,
block|{
literal|"stopped"
block|,
name|NULL
block|,
name|ShowStopped
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"STOPPED timeout"
block|,
literal|"show stopped"
block|}
block|,
block|{
literal|"timers"
block|,
name|NULL
block|,
name|ShowTimerList
block|,
name|LOCAL_AUTH
block|,
literal|"alarm timers"
block|,
literal|"show timers"
block|}
block|,
block|{
literal|"version"
block|,
name|NULL
block|,
name|ShowVersion
block|,
name|LOCAL_NO_AUTH
operator||
name|LOCAL_AUTH
block|,
literal|"version string"
block|,
literal|"show version"
block|}
block|,
block|{
literal|"who"
block|,
name|NULL
block|,
name|log_ShowWho
block|,
name|LOCAL_AUTH
block|,
literal|"client list"
block|,
literal|"show who"
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_NO_AUTH
operator||
name|LOCAL_AUTH
block|,
literal|"Display this message"
block|,
literal|"show help|? [command]"
block|,
name|ShowCommands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|cmdtab
specifier|const
modifier|*
name|FindCommand
parameter_list|(
name|struct
name|cmdtab
specifier|const
modifier|*
name|cmds
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|pmatch
parameter_list|)
block|{
name|int
name|nmatch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|cmdtab
specifier|const
modifier|*
name|found
decl_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|nmatch
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cmds
operator|->
name|func
condition|)
block|{
if|if
condition|(
name|cmds
operator|->
name|name
operator|&&
name|strncasecmp
argument_list|(
name|str
argument_list|,
name|cmds
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cmds
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|pmatch
operator|=
literal|1
expr_stmt|;
return|return
name|cmds
return|;
block|}
name|nmatch
operator|++
expr_stmt|;
name|found
operator|=
name|cmds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmds
operator|->
name|alias
operator|&&
name|strncasecmp
argument_list|(
name|str
argument_list|,
name|cmds
operator|->
name|alias
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cmds
operator|->
name|alias
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|pmatch
operator|=
literal|1
expr_stmt|;
return|return
name|cmds
return|;
block|}
name|nmatch
operator|++
expr_stmt|;
name|found
operator|=
name|cmds
expr_stmt|;
block|}
name|cmds
operator|++
expr_stmt|;
block|}
operator|*
name|pmatch
operator|=
name|nmatch
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mkPrefix
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|tgt
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|int
name|f
decl_stmt|,
name|tlen
decl_stmt|,
name|len
decl_stmt|;
name|tlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|argc
operator|&&
name|tlen
operator|<
name|sz
operator|-
literal|2
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|f
condition|)
name|tgt
index|[
name|tlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|f
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|sz
operator|-
name|tlen
operator|-
literal|1
condition|)
name|len
operator|=
name|sz
operator|-
name|tlen
operator|-
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|tgt
operator|+
name|tlen
argument_list|,
name|argv
index|[
name|f
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tlen
operator|+=
name|len
expr_stmt|;
block|}
name|tgt
index|[
name|tlen
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|tgt
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FindExec
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|cmdtab
specifier|const
modifier|*
name|cmds
parameter_list|,
name|int
name|argc
parameter_list|,
name|int
name|argn
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|struct
name|prompt
modifier|*
name|prompt
parameter_list|,
name|struct
name|datalink
modifier|*
name|cx
parameter_list|)
block|{
name|struct
name|cmdtab
specifier|const
modifier|*
name|cmd
decl_stmt|;
name|int
name|val
init|=
literal|1
decl_stmt|;
name|int
name|nmatch
decl_stmt|;
name|struct
name|cmdargs
name|arg
decl_stmt|;
name|char
name|prefix
index|[
literal|100
index|]
decl_stmt|;
name|cmd
operator|=
name|FindCommand
argument_list|(
name|cmds
argument_list|,
name|argv
index|[
name|argn
index|]
argument_list|,
operator|&
name|nmatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmatch
operator|>
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Ambiguous command\n"
argument_list|,
name|mkPrefix
argument_list|(
name|argn
operator|+
literal|1
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|&&
operator|(
operator|!
name|prompt
operator|||
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|prompt
operator|->
name|auth
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX
operator|)
operator|&&
operator|!
name|cx
condition|)
comment|/* We've got no context, but we require it */
name|cx
operator|=
name|bundle2datalink
argument_list|(
name|bundle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX
operator|)
operator|&&
operator|!
name|cx
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: No context (use the `link' command)\n"
argument_list|,
name|mkPrefix
argument_list|(
name|argn
operator|+
literal|1
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cx
operator|&&
operator|!
operator|(
name|cmd
operator|->
name|lauth
operator|&
operator|(
name|LOCAL_CX
operator||
name|LOCAL_CX_OPT
operator|)
operator|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Redundant context (%s) ignored\n"
argument_list|,
name|mkPrefix
argument_list|(
name|argn
operator|+
literal|1
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
name|prefix
argument_list|)
argument_list|,
name|cx
operator|->
name|name
argument_list|)
expr_stmt|;
name|cx
operator|=
name|NULL
expr_stmt|;
block|}
name|arg
operator|.
name|cmdtab
operator|=
name|cmds
expr_stmt|;
name|arg
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|arg
operator|.
name|argc
operator|=
name|argc
expr_stmt|;
name|arg
operator|.
name|argn
operator|=
name|argn
operator|+
literal|1
expr_stmt|;
name|arg
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|arg
operator|.
name|bundle
operator|=
name|bundle
expr_stmt|;
name|arg
operator|.
name|cx
operator|=
name|cx
expr_stmt|;
name|arg
operator|.
name|prompt
operator|=
name|prompt
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|cmd
operator|->
name|func
call|)
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Invalid command\n"
argument_list|,
name|mkPrefix
argument_list|(
name|argn
operator|+
literal|1
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Usage: %s\n"
argument_list|,
name|cmd
operator|->
name|syntax
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Failed %d\n"
argument_list|,
name|mkPrefix
argument_list|(
name|argn
operator|+
literal|1
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
name|prefix
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|command_Interpret
parameter_list|(
name|char
modifier|*
name|buff
parameter_list|,
name|int
name|nb
parameter_list|,
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|nb
operator|>
literal|0
condition|)
block|{
name|cp
operator|=
name|buff
operator|+
name|strcspn
argument_list|(
name|buff
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|MakeArgs
argument_list|(
name|buff
argument_list|,
name|argv
argument_list|,
name|MAXARGS
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arghidden
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* Is arg n of the given command to be hidden from the log ? */
comment|/* set authkey xxxxx */
comment|/* set key xxxxx */
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"se"
argument_list|,
literal|2
argument_list|)
operator|&&
operator|(
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"authk"
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"ke"
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* passwd xxxxx */
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"p"
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* set server port xxxxx .... */
if|if
condition|(
name|n
operator|==
literal|3
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"se"
argument_list|,
literal|2
argument_list|)
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"se"
argument_list|,
literal|2
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|command_Run
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|struct
name|prompt
modifier|*
name|prompt
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|struct
name|datalink
modifier|*
name|cx
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|log_IsKept
argument_list|(
name|LogCOMMAND
argument_list|)
condition|)
block|{
specifier|static
name|char
name|buf
index|[
name|LINE_LEN
index|]
decl_stmt|;
name|int
name|f
decl_stmt|,
name|n
decl_stmt|;
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|label
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|3
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|argc
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|<
sizeof|sizeof
name|buf
operator|-
literal|1
operator|&&
name|f
condition|)
name|buf
index|[
name|n
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|arghidden
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|f
argument_list|)
condition|)
name|strncpy
argument_list|(
name|buf
operator|+
name|n
argument_list|,
literal|"********"
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|buf
operator|+
name|n
argument_list|,
name|argv
index|[
name|f
index|]
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
name|n
operator|+=
name|strlen
argument_list|(
name|buf
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
name|log_Printf
argument_list|(
name|LogCOMMAND
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|FindExec
argument_list|(
name|bundle
argument_list|,
name|Commands
argument_list|,
name|argc
argument_list|,
literal|0
argument_list|,
name|argv
argument_list|,
name|prompt
argument_list|,
name|cx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|command_Decode
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|char
modifier|*
name|buff
parameter_list|,
name|int
name|nb
parameter_list|,
name|struct
name|prompt
modifier|*
name|prompt
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
decl_stmt|;
name|argc
operator|=
name|command_Interpret
argument_list|(
name|buff
argument_list|,
name|nb
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|command_Run
argument_list|(
name|bundle
argument_list|,
name|argc
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|,
name|prompt
argument_list|,
name|label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShowCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|prompt
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"show: Cannot show without a prompt\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|ShowCommands
argument_list|,
name|arg
operator|->
name|argc
argument_list|,
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Use ``show ?'' to get a list.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|TerminalCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|prompt
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"term: Need a prompt\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
operator|.
name|state
operator|>
name|ST_CLOSED
condition|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"LCP state is [%s]\n"
argument_list|,
name|State2Nam
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|datalink_Up
argument_list|(
name|arg
operator|->
name|cx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prompt_TtyTermMode
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|QuitCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|prompt
operator|||
name|prompt_IsController
argument_list|(
name|arg
operator|->
name|prompt
argument_list|)
operator|||
operator|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"all"
argument_list|)
operator|&&
operator|(
name|arg
operator|->
name|prompt
operator|->
name|auth
operator|&
name|LOCAL_AUTH
operator|)
operator|)
condition|)
name|Cleanup
argument_list|(
name|EX_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|prompt_Destroy
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|OpenCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
name|bundle_Open
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
condition|?
name|arg
operator|->
name|cx
operator|->
name|name
else|:
name|NULL
argument_list|,
name|PHYS_ALL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"lcp"
argument_list|)
condition|)
block|{
name|struct
name|datalink
modifier|*
name|cx
init|=
name|arg
operator|->
name|cx
condition|?
name|arg
operator|->
name|cx
else|:
name|bundle2datalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|cx
condition|)
block|{
if|if
condition|(
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|ST_OPENED
condition|)
name|fsm_Reopen
argument_list|(
operator|&
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
else|else
name|bundle_Open
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|cx
operator|->
name|name
argument_list|,
name|PHYS_ALL
argument_list|)
expr_stmt|;
block|}
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"open lcp: You must specify a link\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ccp"
argument_list|)
condition|)
block|{
name|struct
name|fsm
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
operator|&
name|command_ChooseLink
argument_list|(
name|arg
argument_list|)
operator|->
name|ccp
operator|.
name|fsm
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|link
operator|->
name|lcp
operator|.
name|fsm
operator|.
name|state
operator|!=
name|ST_OPENED
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"open: LCP must be open before opening CCP\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|state
operator|==
name|ST_OPENED
condition|)
name|fsm_Reopen
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|else
block|{
name|fp
operator|->
name|open_mode
operator|=
literal|0
expr_stmt|;
comment|/* Not passive any more */
if|if
condition|(
name|fp
operator|->
name|state
operator|==
name|ST_STOPPED
condition|)
block|{
name|fsm_Down
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fsm_Up
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fsm_Up
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fsm_Open
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ipcp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|cx
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"open ipcp: You need not specify a link\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|ST_OPENED
condition|)
name|fsm_Reopen
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
else|else
name|bundle_Open
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|NULL
argument_list|,
name|PHYS_ALL
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|CloseCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
name|bundle_Close
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
condition|?
name|arg
operator|->
name|cx
operator|->
name|name
else|:
name|NULL
argument_list|,
name|CLOSE_STAYDOWN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"lcp"
argument_list|)
condition|)
name|bundle_Close
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
condition|?
name|arg
operator|->
name|cx
operator|->
name|name
else|:
name|NULL
argument_list|,
name|CLOSE_LCP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ccp"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ccp!"
argument_list|)
condition|)
block|{
name|struct
name|fsm
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
operator|&
name|command_ChooseLink
argument_list|(
name|arg
argument_list|)
operator|->
name|ccp
operator|.
name|fsm
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|state
operator|==
name|ST_OPENED
condition|)
block|{
name|fsm_Close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
index|[
literal|3
index|]
operator|==
literal|'!'
condition|)
name|fp
operator|->
name|open_mode
operator|=
literal|0
expr_stmt|;
comment|/* Stay ST_CLOSED */
else|else
name|fp
operator|->
name|open_mode
operator|=
name|OPEN_PASSIVE
expr_stmt|;
comment|/* Wait for the peer to start */
block|}
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DownCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|cx
condition|)
name|datalink_Down
argument_list|(
name|arg
operator|->
name|cx
argument_list|,
name|CLOSE_STAYDOWN
argument_list|)
expr_stmt|;
else|else
name|bundle_Down
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|CLOSE_STAYDOWN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"lcp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|cx
condition|)
name|datalink_Down
argument_list|(
name|arg
operator|->
name|cx
argument_list|,
name|CLOSE_LCP
argument_list|)
expr_stmt|;
else|else
name|bundle_Down
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|CLOSE_LCP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ccp"
argument_list|)
condition|)
block|{
name|struct
name|fsm
modifier|*
name|fp
init|=
name|arg
operator|->
name|cx
condition|?
operator|&
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|ccp
operator|.
name|fsm
else|:
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|link
operator|.
name|ccp
operator|.
name|fsm
decl_stmt|;
name|fsm2initial
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetModemSpeed
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|long
name|speed
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|&&
operator|*
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"SetModemSpeed: Too many arguments"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"sync"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|physical_SetSync
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|end
operator|=
name|NULL
expr_stmt|;
name|speed
operator|=
name|strtol
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"SetModemSpeed: Bad argument \"%s\""
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|physical_SetSpeed
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
argument_list|,
name|speed
argument_list|)
condition|)
return|return
literal|0
return|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Invalid speed\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"SetModemSpeed: No speed specified\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetStoppedTimeout
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|link
modifier|*
name|l
init|=
operator|&
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
decl_stmt|;
name|l
operator|->
name|lcp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|=
literal|0
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|<=
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
name|l
operator|->
name|lcp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
operator|*
name|SECTICKS
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
name|l
operator|->
name|ccp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
operator|*
name|SECTICKS
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ismask
parameter_list|(
name|x
parameter_list|)
define|\
value|(*x == '0'&& strlen(x) == 4&& strspn(x+1, "0123456789.") == 3)
end_define

begin_function
specifier|static
name|int
name|SetServer
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|&&
name|arg
operator|->
name|argc
operator|<
name|arg
operator|->
name|argn
operator|+
literal|4
condition|)
block|{
specifier|const
name|char
modifier|*
name|port
decl_stmt|,
modifier|*
name|passwd
decl_stmt|,
modifier|*
name|mask
decl_stmt|;
comment|/* What's what ? */
name|port
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
block|{
name|passwd
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
expr_stmt|;
name|mask
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|3
condition|)
block|{
name|passwd
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
expr_stmt|;
name|mask
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ismask
argument_list|(
name|mask
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|port
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|server_Close
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
condition|)
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Disabled server port.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
name|strncpy
argument_list|(
name|server
operator|.
name|passwd
argument_list|,
name|passwd
argument_list|,
sizeof|sizeof
name|server
operator|.
name|passwd
operator|-
literal|1
argument_list|)
expr_stmt|;
name|server
operator|.
name|passwd
index|[
sizeof|sizeof
name|server
operator|.
name|passwd
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|port
operator|==
literal|'/'
condition|)
block|{
name|mode_t
name|imask
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
name|name
index|[
name|LINE_LEN
operator|+
literal|12
index|]
decl_stmt|;
if|if
condition|(
name|mask
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|m
decl_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|mask
argument_list|,
literal|"%o"
argument_list|,
operator|&
name|m
argument_list|)
operator|==
literal|1
condition|)
name|imask
operator|=
name|m
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
name|imask
operator|=
operator|(
name|mode_t
operator|)
operator|-
literal|1
expr_stmt|;
name|ptr
operator|=
name|strstr
argument_list|(
name|port
argument_list|,
literal|"%d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|"%.*s%d%s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|port
argument_list|)
argument_list|,
name|port
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|unit
argument_list|,
name|ptr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|port
operator|=
name|name
expr_stmt|;
block|}
name|res
operator|=
name|server_LocalOpen
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|port
argument_list|,
name|imask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|iport
decl_stmt|,
name|add
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mask
operator|!=
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|port
operator|==
literal|'+'
condition|)
block|{
name|port
operator|++
expr_stmt|;
name|add
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strspn
argument_list|(
name|port
argument_list|,
literal|"0123456789"
argument_list|)
operator|!=
name|strlen
argument_list|(
name|port
argument_list|)
condition|)
block|{
name|struct
name|servent
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|getservbyname
argument_list|(
name|port
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|iport
operator|=
literal|0
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Invalid port or service\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
name|iport
operator|=
name|ntohs
argument_list|(
name|s
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
else|else
name|iport
operator|=
name|atoi
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|iport
condition|)
block|{
if|if
condition|(
name|add
condition|)
name|iport
operator|+=
name|arg
operator|->
name|bundle
operator|->
name|unit
expr_stmt|;
name|res
operator|=
name|server_TcpOpen
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|iport
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetModemParity
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|?
name|modem_SetParity
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetEscape
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|int
name|argc
init|=
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|argv
init|=
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
decl_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|33
condition|;
name|code
operator|++
control|)
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
name|code
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
block|{
name|sscanf
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
name|code
operator|&=
literal|0xff
expr_stmt|;
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
name|code
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|code
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
literal|32
index|]
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|in_addr
name|GetIpAddr
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|in_addr
name|ipaddr
decl_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|cp
argument_list|,
operator|&
name|ipaddr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|&&
name|hp
operator|->
name|h_addrtype
operator|==
name|AF_INET
condition|)
name|memcpy
argument_list|(
operator|&
name|ipaddr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
else|else
name|ipaddr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ipaddr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetInterfaceAddr
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ipcp
modifier|*
name|ipcp
init|=
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|hisaddr
decl_stmt|;
name|hisaddr
operator|=
name|NULL
expr_stmt|;
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|ipaddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|ipcp
operator|->
name|cfg
operator|.
name|peer_range
operator|.
name|ipaddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|4
condition|)
return|return
operator|-
literal|1
return|;
name|ipcp
operator|->
name|cfg
operator|.
name|HaveTriggerAddress
operator|=
literal|0
expr_stmt|;
name|ipcp
operator|->
name|cfg
operator|.
name|netmask
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|iplist_reset
argument_list|(
operator|&
name|ipcp
operator|->
name|cfg
operator|.
name|peer_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
if|if
condition|(
operator|!
name|ParseAddr
argument_list|(
name|ipcp
argument_list|,
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|,
operator|&
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|ipaddr
argument_list|,
operator|&
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|mask
argument_list|,
operator|&
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|width
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
name|hisaddr
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
block|{
name|ipcp
operator|->
name|cfg
operator|.
name|netmask
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|3
condition|)
block|{
name|ipcp
operator|->
name|cfg
operator|.
name|TriggerAddress
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|ipcp
operator|->
name|cfg
operator|.
name|HaveTriggerAddress
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*    * For backwards compatibility, 0.0.0.0 means any address.    */
if|if
condition|(
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|ipaddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|mask
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|width
operator|=
literal|0
expr_stmt|;
block|}
name|ipcp
operator|->
name|my_ip
operator|.
name|s_addr
operator|=
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|ipaddr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|ipcp
operator|->
name|cfg
operator|.
name|peer_range
operator|.
name|ipaddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|ipcp
operator|->
name|cfg
operator|.
name|peer_range
operator|.
name|mask
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|ipcp
operator|->
name|cfg
operator|.
name|peer_range
operator|.
name|width
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hisaddr
operator|&&
operator|!
name|ipcp_UseHisaddr
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|hisaddr
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|&
name|PHYS_AUTO
argument_list|)
condition|)
return|return
literal|4
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetVariable
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|long
name|long_val
decl_stmt|,
name|param
init|=
operator|(
name|long
operator|)
name|arg
operator|->
name|cmd
operator|->
name|args
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|dummyint
decl_stmt|;
specifier|const
name|char
modifier|*
name|argp
decl_stmt|;
name|struct
name|datalink
modifier|*
name|cx
init|=
name|arg
operator|->
name|cx
decl_stmt|;
comment|/* LOCAL_CX uses this */
specifier|const
name|char
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
name|struct
name|link
modifier|*
name|l
init|=
name|command_ChooseLink
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* LOCAL_CX_OPT uses this */
name|struct
name|in_addr
name|dummyaddr
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
name|argp
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
expr_stmt|;
else|else
name|argp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|->
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX
operator|)
operator|&&
operator|!
name|cx
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"set %s: No context (use the `link' command)\n"
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|cx
operator|&&
operator|!
operator|(
name|arg
operator|->
name|cmd
operator|->
name|lauth
operator|&
operator|(
name|LOCAL_CX
operator||
name|LOCAL_CX_OPT
operator|)
operator|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"set %s: Redundant context (%s) ignored\n"
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|name
argument_list|,
name|cx
operator|->
name|name
argument_list|)
expr_stmt|;
name|cx
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|VAR_AUTHKEY
case|:
if|if
condition|(
name|bundle_Phase
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
operator|==
name|PHASE_DEAD
condition|)
block|{
name|strncpy
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|key
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|key
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|key
index|[
sizeof|sizeof
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|key
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|"set authkey: Only available at phase DEAD\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_AUTHNAME
case|:
if|if
condition|(
name|bundle_Phase
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
operator|==
name|PHASE_DEAD
condition|)
block|{
name|strncpy
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
index|[
sizeof|sizeof
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|"set authname: Only available at phase DEAD\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_AUTOLOAD
case|:
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|2
operator|||
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|4
condition|)
block|{
name|arg
operator|->
name|bundle
operator|->
name|autoload
operator|.
name|running
operator|=
literal|1
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|.
name|timeout
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|.
name|packets
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|4
condition|)
block|{
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|timeout
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|packets
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|packets
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|err
operator|=
literal|"Set autoload requires two or four arguments\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_DIAL
case|:
name|strncpy
argument_list|(
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|dial
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|dial
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|dial
index|[
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|dial
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|VAR_LOGIN
case|:
name|strncpy
argument_list|(
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|login
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|login
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|login
index|[
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|login
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|VAR_WINSIZE
case|:
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|out
operator|.
name|winsize
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|out
operator|.
name|winsize
operator|<
literal|8
operator|||
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|out
operator|.
name|winsize
operator|>
literal|15
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%d: Invalid outgoing window size\n"
argument_list|,
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|out
operator|.
name|winsize
argument_list|)
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|out
operator|.
name|winsize
operator|=
literal|15
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
operator|<
literal|8
operator|||
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
operator|>
literal|15
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%d: Invalid incoming window size\n"
argument_list|,
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
argument_list|)
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
operator|=
literal|15
expr_stmt|;
block|}
block|}
else|else
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|"No window size specified\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_DEVICE
case|:
name|physical_SetDeviceList
argument_list|(
name|cx
operator|->
name|physical
argument_list|,
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_ACCMAP
case|:
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
name|u_long
name|ulong_val
decl_stmt|;
name|sscanf
argument_list|(
name|argp
argument_list|,
literal|"%lx"
argument_list|,
operator|&
name|ulong_val
argument_list|)
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|accmap
operator|=
operator|(
name|u_int32_t
operator|)
name|ulong_val
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|"No accmap specified\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_MODE
case|:
name|mode
operator|=
name|Nam2mode
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|PHYS_NONE
operator|||
name|mode
operator|==
name|PHYS_ALL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Invalid mode\n"
argument_list|,
name|argp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bundle_SetMode
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|cx
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_MRRU
case|:
if|if
condition|(
name|bundle_Phase
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
operator|!=
name|PHASE_DEAD
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"mrru: Only changable at phase DEAD\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|&&
name|long_val
operator|<
name|MIN_MRU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MRRU %ld: too small - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_MRU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|long_val
operator|>
name|MAX_MRU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MRRU %ld: too big - max %d\n"
argument_list|,
name|long_val
argument_list|,
name|MAX_MRU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|mrru
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_MRU
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|==
literal|0
condition|)
name|l
operator|->
name|lcp
operator|.
name|cfg
operator|.
name|mru
operator|=
name|DEF_MRU
expr_stmt|;
elseif|else
if|if
condition|(
name|long_val
operator|<
name|MIN_MRU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MRU %ld: too small - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_MRU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|long_val
operator|>
name|MAX_MRU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MRU %ld: too big - max %d\n"
argument_list|,
name|long_val
argument_list|,
name|MAX_MRU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|l
operator|->
name|lcp
operator|.
name|cfg
operator|.
name|mru
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_MTU
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|&&
name|long_val
operator|<
name|MIN_MTU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MTU %ld: too small - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_MTU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|long_val
operator|>
name|MAX_MTU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MTU %ld: too big - max %d\n"
argument_list|,
name|long_val
argument_list|,
name|MAX_MTU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|mtu
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_OPENMODE
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|argp
argument_list|,
literal|"active"
argument_list|)
operator|==
literal|0
condition|)
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|openmode
operator|=
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|?
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
else|:
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|argp
argument_list|,
literal|"passive"
argument_list|)
operator|==
literal|0
condition|)
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|openmode
operator|=
name|OPEN_PASSIVE
expr_stmt|;
else|else
block|{
name|err
operator|=
literal|"%s: Invalid openmode\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|,
name|argp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_PHONE
case|:
name|strncpy
argument_list|(
name|cx
operator|->
name|cfg
operator|.
name|phone
operator|.
name|list
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|phone
operator|.
name|list
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|phone
operator|.
name|list
index|[
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|phone
operator|.
name|list
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|VAR_HANGUP
case|:
name|strncpy
argument_list|(
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|hangup
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|hangup
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|hangup
index|[
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|hangup
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|VAR_IDLETIMEOUT
case|:
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
name|err
operator|=
literal|"Too many idle timeout values\n"
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
name|bundle_SetIdleTimer
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|atoi
argument_list|(
name|argp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_LQRPERIOD
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|<
name|MIN_LQRPERIOD
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Invalid lqr period - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_LQRPERIOD
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|l
operator|->
name|lcp
operator|.
name|cfg
operator|.
name|lqrperiod
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_LCPRETRY
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|<
name|MIN_FSMRETRY
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Invalid LCP FSM retry period - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_FSMRETRY
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|fsmretry
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_CHAPRETRY
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|<
name|MIN_FSMRETRY
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Invalid CHAP FSM retry period - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_FSMRETRY
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|cx
operator|->
name|chap
operator|.
name|auth
operator|.
name|cfg
operator|.
name|fsmretry
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_PAPRETRY
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|<
name|MIN_FSMRETRY
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Invalid PAP FSM retry period - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_FSMRETRY
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|cx
operator|->
name|pap
operator|.
name|cfg
operator|.
name|fsmretry
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_CCPRETRY
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|<
name|MIN_FSMRETRY
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Invalid CCP FSM retry period - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_FSMRETRY
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|fsmretry
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_IPCPRETRY
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|<
name|MIN_FSMRETRY
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Invalid IPCP FSM retry period - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_FSMRETRY
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|fsmretry
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_NBNS
case|:
case|case
name|VAR_DNS
case|:
if|if
condition|(
name|param
operator|==
name|VAR_DNS
condition|)
name|addr
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|ns
operator|.
name|dns
expr_stmt|;
else|else
name|addr
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|ns
operator|.
name|nbns
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|.
name|s_addr
operator|=
name|addr
index|[
literal|1
index|]
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
name|ParseAddr
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
literal|1
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|,
name|addr
argument_list|,
operator|&
name|dummyaddr
argument_list|,
operator|&
name|dummyint
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
name|ParseAddr
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
literal|1
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
operator|+
literal|1
argument_list|,
name|addr
operator|+
literal|1
argument_list|,
operator|&
name|dummyaddr
argument_list|,
operator|&
name|dummyint
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
index|[
literal|1
index|]
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|addr
index|[
literal|1
index|]
operator|.
name|s_addr
operator|=
name|addr
index|[
literal|0
index|]
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|addr
index|[
literal|0
index|]
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|addr
index|[
literal|0
index|]
operator|.
name|s_addr
operator|=
name|addr
index|[
literal|1
index|]
operator|.
name|s_addr
expr_stmt|;
block|}
break|break;
block|}
return|return
name|err
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetCtsRts
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|physical_SetRtsCts
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|physical_SetRtsCts
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|SetCommands
index|[]
init|=
block|{
block|{
literal|"accmap"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"accmap value"
block|,
literal|"set accmap hex-value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_ACCMAP
block|}
block|,
block|{
literal|"authkey"
block|,
literal|"key"
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"authentication key"
block|,
literal|"set authkey|key key"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_AUTHKEY
block|}
block|,
block|{
literal|"authname"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"authentication name"
block|,
literal|"set authname name"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_AUTHNAME
block|}
block|,
block|{
literal|"autoload"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"auto link [de]activation"
block|,
literal|"set autoload maxtime maxload mintime minload"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_AUTOLOAD
block|}
block|,
block|{
literal|"ccpretry"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"FSM retry period"
block|,
literal|"set ccpretry value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_CCPRETRY
block|}
block|,
block|{
literal|"chapretry"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"CHAP retry period"
block|,
literal|"set chapretry value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_CHAPRETRY
block|}
block|,
block|{
literal|"ctsrts"
block|,
literal|"crtscts"
block|,
name|SetCtsRts
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Use hardware flow control"
block|,
literal|"set ctsrts [on|off]"
block|}
block|,
block|{
literal|"deflate"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"deflate window sizes"
block|,
literal|"set deflate out-winsize in-winsize"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_WINSIZE
block|}
block|,
block|{
literal|"device"
block|,
literal|"line"
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"modem device name"
block|,
literal|"set device|line device-name[,device-name]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_DEVICE
block|}
block|,
block|{
literal|"dial"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"dialing script"
block|,
literal|"set dial chat-script"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_DIAL
block|}
block|,
block|{
literal|"dns"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"Domain Name Server"
block|,
literal|"set dns pri-addr [sec-addr]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_DNS
block|}
block|,
block|{
literal|"enddisc"
block|,
name|NULL
block|,
name|mp_SetEnddisc
block|,
name|LOCAL_AUTH
block|,
literal|"Endpoint Discriminator"
block|,
literal|"set enddisc [IP|magic|label|psn value]"
block|}
block|,
block|{
literal|"escape"
block|,
name|NULL
block|,
name|SetEscape
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"escape characters"
block|,
literal|"set escape hex-digit ..."
block|}
block|,
block|{
literal|"filter"
block|,
name|NULL
block|,
name|filter_Set
block|,
name|LOCAL_AUTH
block|,
literal|"packet filters"
block|,
literal|"set filter alive|dial|in|out rule-no permit|deny "
literal|"[src_addr[/width]] [dst_addr[/width]] [tcp|udp|icmp [src [lt|eq|gt port]] "
literal|"[dst [lt|eq|gt port]] [estab] [syn] [finrst]]"
block|}
block|,
block|{
literal|"hangup"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"hangup script"
block|,
literal|"set hangup chat-script"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_HANGUP
block|}
block|,
block|{
literal|"ifaddr"
block|,
name|NULL
block|,
name|SetInterfaceAddr
block|,
name|LOCAL_AUTH
block|,
literal|"destination address"
block|,
literal|"set ifaddr [src-addr [dst-addr [netmask [trg-addr]]]]"
block|}
block|,
block|{
literal|"ipcpretry"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"FSM retry period"
block|,
literal|"set ipcpretry value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_IPCPRETRY
block|}
block|,
block|{
literal|"lcpretry"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"FSM retry period"
block|,
literal|"set lcpretry value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_LCPRETRY
block|}
block|,
block|{
literal|"log"
block|,
name|NULL
block|,
name|log_SetLevel
block|,
name|LOCAL_AUTH
block|,
literal|"log level"
block|,
literal|"set log [local] [+|-]async|ccp|chat|command|connect|debug|hdlc|id0|ipcp|"
literal|"lcp|lqm|phase|tcp/ip|timer|tun..."
block|}
block|,
block|{
literal|"login"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"login script"
block|,
literal|"set login chat-script"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_LOGIN
block|}
block|,
block|{
literal|"lqrperiod"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"LQR period"
block|,
literal|"set lqrperiod value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_LQRPERIOD
block|}
block|,
block|{
literal|"mode"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"mode value"
block|,
literal|"set mode interactive|auto|ddial|background"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_MODE
block|}
block|,
block|{
literal|"mrru"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"MRRU value"
block|,
literal|"set mrru value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_MRRU
block|}
block|,
block|{
literal|"mru"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"MRU value"
block|,
literal|"set mru value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_MRU
block|}
block|,
block|{
literal|"mtu"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"interface MTU value"
block|,
literal|"set mtu value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_MTU
block|}
block|,
block|{
literal|"nbns"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"NetBIOS Name Server"
block|,
literal|"set nbns pri-addr [sec-addr]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_NBNS
block|}
block|,
block|{
literal|"openmode"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"open mode"
block|,
literal|"set openmode active|passive [secs]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_OPENMODE
block|}
block|,
block|{
literal|"papretry"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"PAP retry period"
block|,
literal|"set papretry value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_PAPRETRY
block|}
block|,
block|{
literal|"parity"
block|,
name|NULL
block|,
name|SetModemParity
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"modem parity"
block|,
literal|"set parity [odd|even|none]"
block|}
block|,
block|{
literal|"phone"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"telephone number(s)"
block|,
literal|"set phone phone1[:phone2[...]]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_PHONE
block|}
block|,
block|{
literal|"reconnect"
block|,
name|NULL
block|,
name|datalink_SetReconnect
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Reconnect timeout"
block|,
literal|"set reconnect value ntries"
block|}
block|,
block|{
literal|"redial"
block|,
name|NULL
block|,
name|datalink_SetRedial
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Redial timeout"
block|,
literal|"set redial value|random[.value|random] [attempts]"
block|}
block|,
block|{
literal|"server"
block|,
literal|"socket"
block|,
name|SetServer
block|,
name|LOCAL_AUTH
block|,
literal|"server port"
block|,
literal|"set server|socket TcpPort|LocalName|none password [mask]"
block|}
block|,
block|{
literal|"speed"
block|,
name|NULL
block|,
name|SetModemSpeed
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"modem speed"
block|,
literal|"set speed value"
block|}
block|,
block|{
literal|"stopped"
block|,
name|NULL
block|,
name|SetStoppedTimeout
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"STOPPED timeouts"
block|,
literal|"set stopped [LCPseconds [CCPseconds]]"
block|}
block|,
block|{
literal|"timeout"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"Idle timeout"
block|,
literal|"set timeout idletime"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_IDLETIMEOUT
block|}
block|,
block|{
literal|"vj"
block|,
name|NULL
block|,
name|ipcp_vjset
block|,
name|LOCAL_AUTH
block|,
literal|"vj values"
block|,
literal|"set vj slots|slotcomp [value]"
block|}
block|,
block|{
literal|"weight"
block|,
name|NULL
block|,
name|mp_SetDatalinkWeight
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"datalink weighting"
block|,
literal|"set weight n"
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Display this message"
block|,
literal|"set help|? [command]"
block|,
name|SetCommands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|SetCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|SetCommands
argument_list|,
name|arg
operator|->
name|argc
argument_list|,
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Use `set ?' to get a list or `set ?<var>' for"
literal|" syntax help.\n"
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"set command must have arguments\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|AddCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|in_addr
name|dest
decl_stmt|,
name|gateway
decl_stmt|,
name|netmask
decl_stmt|;
name|int
name|gw
decl_stmt|,
name|addrs
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|!=
name|arg
operator|->
name|argn
operator|+
literal|3
operator|&&
name|arg
operator|->
name|argc
operator|!=
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
return|return
operator|-
literal|1
return|;
name|addrs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"default"
argument_list|)
condition|)
name|dest
operator|.
name|s_addr
operator|=
name|netmask
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
else|else
block|{
name|int
name|width
decl_stmt|;
if|if
condition|(
operator|!
name|ParseAddr
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
literal|1
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|,
operator|&
name|dest
argument_list|,
operator|&
name|netmask
argument_list|,
operator|&
name|width
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"MYADDR"
argument_list|,
literal|6
argument_list|)
condition|)
name|addrs
operator|=
name|ROUTE_DSTMYADDR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"HISADDR"
argument_list|,
literal|7
argument_list|)
condition|)
name|addrs
operator|=
name|ROUTE_DSTHISADDR
expr_stmt|;
block|}
name|gw
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"MYADDR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addrs
operator|=
name|ROUTE_DSTMYADDR
expr_stmt|;
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|my_ip
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"HISADDR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addrs
operator|=
name|ROUTE_DSTHISADDR
expr_stmt|;
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|peer_ip
expr_stmt|;
block|}
else|else
name|dest
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
name|netmask
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|gw
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
name|gw
index|]
argument_list|,
literal|"HISADDR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gateway
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|peer_ip
expr_stmt|;
name|addrs
operator||=
name|ROUTE_GWHISADDR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
name|gw
index|]
argument_list|,
literal|"INTERFACE"
argument_list|)
operator|==
literal|0
condition|)
name|gateway
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
else|else
name|gateway
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
name|gw
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle_SetRoute
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|RTM_ADD
argument_list|,
name|dest
argument_list|,
name|gateway
argument_list|,
name|netmask
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|args
condition|?
literal|1
else|:
literal|0
argument_list|)
condition|)
name|route_Add
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|route
argument_list|,
name|addrs
argument_list|,
name|dest
argument_list|,
name|netmask
argument_list|,
name|gateway
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DeleteCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|in_addr
name|dest
decl_stmt|,
name|none
decl_stmt|;
name|int
name|addrs
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|route_IfDelete
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|route_DeleteAll
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|route
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addrs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"MYADDR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|my_ip
expr_stmt|;
name|addrs
operator|=
name|ROUTE_DSTMYADDR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"HISADDR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|peer_ip
expr_stmt|;
name|addrs
operator|=
name|ROUTE_DSTHISADDR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
name|dest
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
else|else
name|dest
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
name|addrs
operator|=
name|ROUTE_STATIC
expr_stmt|;
block|}
name|none
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|bundle_SetRoute
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|RTM_DELETE
argument_list|,
name|dest
argument_list|,
name|none
argument_list|,
name|none
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|args
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|route_Delete
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|route
argument_list|,
name|addrs
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NOALIAS
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|AliasCommands
index|[]
init|=
block|{
block|{
literal|"addr"
block|,
name|NULL
block|,
name|alias_RedirectAddr
block|,
name|LOCAL_AUTH
block|,
literal|"static address translation"
block|,
literal|"alias addr [addr_local addr_alias]"
block|}
block|,
block|{
literal|"deny_incoming"
block|,
name|NULL
block|,
name|AliasOption
block|,
name|LOCAL_AUTH
block|,
literal|"stop incoming connections"
block|,
literal|"alias deny_incoming [yes|no]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|PKT_ALIAS_DENY_INCOMING
block|}
block|,
block|{
literal|"enable"
block|,
name|NULL
block|,
name|AliasEnable
block|,
name|LOCAL_AUTH
block|,
literal|"enable IP aliasing"
block|,
literal|"alias enable [yes|no]"
block|}
block|,
block|{
literal|"log"
block|,
name|NULL
block|,
name|AliasOption
block|,
name|LOCAL_AUTH
block|,
literal|"log aliasing link creation"
block|,
literal|"alias log [yes|no]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|PKT_ALIAS_LOG
block|}
block|,
block|{
literal|"port"
block|,
name|NULL
block|,
name|alias_RedirectPort
block|,
name|LOCAL_AUTH
block|,
literal|"port redirection"
block|,
literal|"alias port [proto addr_local:port_local  port_alias]"
block|}
block|,
block|{
literal|"same_ports"
block|,
name|NULL
block|,
name|AliasOption
block|,
name|LOCAL_AUTH
block|,
literal|"try to leave port numbers unchanged"
block|,
literal|"alias same_ports [yes|no]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|PKT_ALIAS_SAME_PORTS
block|}
block|,
block|{
literal|"unregistered_only"
block|,
name|NULL
block|,
name|AliasOption
block|,
name|LOCAL_AUTH
block|,
literal|"alias unregistered (private) IP address space only"
block|,
literal|"alias unregistered_only [yes|no]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|PKT_ALIAS_UNREGISTERED_ONLY
block|}
block|,
block|{
literal|"use_sockets"
block|,
name|NULL
block|,
name|AliasOption
block|,
name|LOCAL_AUTH
block|,
literal|"allocate host sockets"
block|,
literal|"alias use_sockets [yes|no]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|PKT_ALIAS_USE_SOCKETS
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Display this message"
block|,
literal|"alias help|? [command]"
block|,
name|AliasCommands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|AliasCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|AliasCommands
argument_list|,
name|arg
operator|->
name|argc
argument_list|,
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Use `alias help' to get a list or `alias help"
literal|"<option>' for syntax help.\n"
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"alias command must have arguments\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|AliasEnable
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arg
operator|->
name|bundle
operator|->
name|AliasEnabled
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arg
operator|->
name|bundle
operator|->
name|AliasEnabled
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|AliasOption
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|param
init|=
operator|(
name|unsigned
operator|)
name|arg
operator|->
name|cmd
operator|->
name|args
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|AliasEnabled
condition|)
block|{
name|PacketAliasSetMode
argument_list|(
name|param
argument_list|,
name|param
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"alias not enabled\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|AliasEnabled
condition|)
block|{
name|PacketAliasSetMode
argument_list|(
literal|0
argument_list|,
name|param
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"alias not enabled\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifndef NOALIAS */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|AllowCommands
index|[]
init|=
block|{
block|{
literal|"modes"
block|,
literal|"mode"
block|,
name|AllowModes
block|,
name|LOCAL_AUTH
block|,
literal|"Only allow certain ppp modes"
block|,
literal|"allow modes mode..."
block|}
block|,
block|{
literal|"users"
block|,
literal|"user"
block|,
name|AllowUsers
block|,
name|LOCAL_AUTH
block|,
literal|"Allow users access to ppp"
block|,
literal|"allow users logname..."
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Display this message"
block|,
literal|"allow help|? [command]"
block|,
name|AllowCommands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|AllowCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
comment|/* arg->bundle may be NULL (see system_IsValid()) ! */
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|AllowCommands
argument_list|,
name|arg
operator|->
name|argc
argument_list|,
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Use `allow ?' to get a list or `allow ?<cmd>'"
literal|" for syntax help.\n"
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"allow command must have arguments\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|LinkCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
name|char
name|namelist
index|[
name|LINE_LEN
index|]
decl_stmt|;
name|struct
name|datalink
modifier|*
name|cx
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"*"
argument_list|)
condition|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|cx
operator|=
name|arg
operator|->
name|bundle
operator|->
name|links
expr_stmt|;
while|while
condition|(
name|cx
condition|)
block|{
comment|/* Watch it, the command could be a ``remove'' */
name|dl
operator|=
name|cx
operator|->
name|next
expr_stmt|;
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|Commands
argument_list|,
name|arg
operator|->
name|argc
argument_list|,
name|arg
operator|->
name|argn
operator|+
literal|1
argument_list|,
name|arg
operator|->
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|cx
argument_list|)
expr_stmt|;
for|for
control|(
name|cx
operator|=
name|arg
operator|->
name|bundle
operator|->
name|links
init|;
name|cx
condition|;
name|cx
operator|=
name|cx
operator|->
name|next
control|)
if|if
condition|(
name|cx
operator|==
name|dl
condition|)
break|break;
comment|/* Pointer's still valid ! */
block|}
block|}
else|else
block|{
name|strncpy
argument_list|(
name|namelist
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
sizeof|sizeof
name|namelist
operator|-
literal|1
argument_list|)
expr_stmt|;
name|namelist
index|[
sizeof|sizeof
name|namelist
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|name
operator|=
name|strtok
argument_list|(
name|namelist
argument_list|,
literal|", "
argument_list|)
init|;
name|name
condition|;
name|name
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|", "
argument_list|)
control|)
if|if
condition|(
operator|!
name|bundle2datalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"link: %s: Invalid link name\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|strncpy
argument_list|(
name|namelist
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
sizeof|sizeof
name|namelist
operator|-
literal|1
argument_list|)
expr_stmt|;
name|namelist
index|[
sizeof|sizeof
name|namelist
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|name
operator|=
name|strtok
argument_list|(
name|namelist
argument_list|,
literal|", "
argument_list|)
init|;
name|name
condition|;
name|name
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|", "
argument_list|)
control|)
block|{
name|cx
operator|=
name|bundle2datalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx
condition|)
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|Commands
argument_list|,
name|arg
operator|->
name|argc
argument_list|,
name|arg
operator|->
name|argn
operator|+
literal|1
argument_list|,
name|arg
operator|->
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|cx
argument_list|)
expr_stmt|;
else|else
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"link: %s: Invalidated link name !\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|result
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Usage: %s\n"
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|syntax
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_function
name|struct
name|link
modifier|*
name|command_ChooseLink
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|cx
condition|)
return|return
operator|&
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
return|;
elseif|else
if|if
condition|(
operator|!
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|mrru
condition|)
block|{
name|struct
name|datalink
modifier|*
name|dl
init|=
name|bundle2datalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|dl
condition|)
return|return
operator|&
name|dl
operator|->
name|physical
operator|->
name|link
return|;
block|}
return|return
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|link
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ident_cmd
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|unsigned
modifier|*
name|keep
parameter_list|,
name|unsigned
modifier|*
name|add
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
name|result
operator|=
literal|"accept"
expr_stmt|;
operator|*
name|keep
operator|=
name|NEG_MYMASK
expr_stmt|;
operator|*
name|add
operator|=
name|NEG_ACCEPTED
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
switch|switch
condition|(
name|cmd
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|result
operator|=
literal|"deny"
expr_stmt|;
operator|*
name|keep
operator|=
name|NEG_MYMASK
expr_stmt|;
operator|*
name|add
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'i'
case|:
name|result
operator|=
literal|"disable"
expr_stmt|;
operator|*
name|keep
operator|=
name|NEG_HISMASK
expr_stmt|;
operator|*
name|add
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|result
operator|=
literal|"enable"
expr_stmt|;
operator|*
name|keep
operator|=
name|NEG_HISMASK
expr_stmt|;
operator|*
name|add
operator|=
name|NEG_ENABLED
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|OptSet
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|bit
init|=
operator|(
name|long
operator|)
name|arg
operator|->
name|cmd
operator|->
name|args
condition|?
literal|1
else|:
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
name|unsigned
name|keep
decl_stmt|;
comment|/* Keep these bits */
name|unsigned
name|add
decl_stmt|;
comment|/* Add these bits */
if|if
condition|(
operator|(
name|cmd
operator|=
name|ident_cmd
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|-
literal|2
index|]
argument_list|,
operator|&
name|keep
argument_list|,
operator|&
name|add
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|add
condition|)
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|opt
operator||=
name|bit
expr_stmt|;
else|else
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|opt
operator|&=
operator|~
name|bit
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|NegotiateSet
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|long
name|param
init|=
operator|(
name|long
operator|)
name|arg
operator|->
name|cmd
operator|->
name|args
decl_stmt|;
name|struct
name|link
modifier|*
name|l
init|=
name|command_ChooseLink
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* LOCAL_CX_OPT uses this */
name|struct
name|datalink
modifier|*
name|cx
init|=
name|arg
operator|->
name|cx
decl_stmt|;
comment|/* LOCAL_CX uses this */
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
name|unsigned
name|keep
decl_stmt|;
comment|/* Keep these bits */
name|unsigned
name|add
decl_stmt|;
comment|/* Add these bits */
if|if
condition|(
operator|(
name|cmd
operator|=
name|ident_cmd
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|-
literal|2
index|]
argument_list|,
operator|&
name|keep
argument_list|,
operator|&
name|add
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|arg
operator|->
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX
operator|)
operator|&&
operator|!
name|cx
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s %s: No context (use the `link' command)\n"
argument_list|,
name|cmd
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|cx
operator|&&
operator|!
operator|(
name|arg
operator|->
name|cmd
operator|->
name|lauth
operator|&
operator|(
name|LOCAL_CX
operator||
name|LOCAL_CX_OPT
operator|)
operator|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s %s: Redundant context (%s) ignored\n"
argument_list|,
name|cmd
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|name
argument_list|,
name|cx
operator|->
name|name
argument_list|)
expr_stmt|;
name|cx
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|NEG_ACFCOMP
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|acfcomp
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|acfcomp
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_CHAP
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|chap
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|chap
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_DEFLATE
case|:
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_DEFLATE
index|]
operator|&=
name|keep
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_DEFLATE
index|]
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_DNS
case|:
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|ns
operator|.
name|dns_neg
operator|&=
name|keep
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|ns
operator|.
name|dns_neg
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_LQR
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|lqr
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|lqr
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_PAP
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|pap
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|pap
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_PPPDDEFLATE
case|:
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_DEFLATE24
index|]
operator|&=
name|keep
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_DEFLATE24
index|]
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_PRED1
case|:
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_PRED1
index|]
operator|&=
name|keep
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_PRED1
index|]
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_PROTOCOMP
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|protocomp
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|protocomp
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_SHORTSEQ
case|:
if|if
condition|(
name|bundle_Phase
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
operator|!=
name|PHASE_DEAD
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"shortseq: Only changable at phase DEAD\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|shortseq
operator|&=
name|keep
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|shortseq
operator||=
name|add
expr_stmt|;
block|}
break|break;
case|case
name|NEG_VJCOMP
case|:
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|vj
operator|.
name|neg
operator|&=
name|keep
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|vj
operator|.
name|neg
operator||=
name|add
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|NegotiateCommands
index|[]
init|=
block|{
block|{
literal|"idcheck"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Check FSM reply ids"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_IDCHECK
block|}
block|,
block|{
literal|"loopback"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Loop packets for local iface"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_LOOPBACK
block|}
block|,
block|{
literal|"passwdauth"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Use passwd file"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_PASSWDAUTH
block|}
block|,
block|{
literal|"proxy"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Create proxy ARP entry"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_PROXY
block|}
block|,
block|{
literal|"sroutes"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Use sticky routes"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_SROUTES
block|}
block|,
block|{
literal|"throughput"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Rolling throughput"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_THROUGHPUT
block|}
block|,
block|{
literal|"utmp"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Log connections in utmp"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_UTMP
block|}
block|,
define|#
directive|define
name|OPT_MAX
value|7
comment|/* accept/deny allowed below and not above */
block|{
literal|"acfcomp"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Address& Control field compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_ACFCOMP
block|}
block|,
block|{
literal|"chap"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Challenge Handshake Authentication Protocol"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_CHAP
block|}
block|,
block|{
literal|"deflate"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Deflate compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_DEFLATE
block|}
block|,
block|{
literal|"deflate24"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Deflate (type 24) compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_PPPDDEFLATE
block|}
block|,
block|{
literal|"dns"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
block|,
literal|"DNS specification"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_DNS
block|}
block|,
block|{
literal|"lqr"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Link Quality Reports"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_LQR
block|}
block|,
block|{
literal|"pap"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Password Authentication protocol"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_PAP
block|}
block|,
block|{
literal|"pred1"
block|,
literal|"predictor1"
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Predictor 1 compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_PRED1
block|}
block|,
block|{
literal|"protocomp"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Protocol field compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_PROTOCOMP
block|}
block|,
block|{
literal|"shortseq"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
block|,
literal|"MP Short Sequence Numbers"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_SHORTSEQ
block|}
block|,
block|{
literal|"vjcomp"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
block|,
literal|"Van Jacobson header compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_VJCOMP
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Display this message"
block|,
literal|"accept|deny|disable|enable help|? [value]"
block|,
name|NegotiateCommands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|NegotiateCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
name|char
specifier|const
modifier|*
name|argv
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|keep
decl_stmt|,
name|add
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|argv
index|[
literal|0
index|]
operator|=
name|ident_cmd
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|-
literal|1
index|]
argument_list|,
operator|&
name|keep
argument_list|,
operator|&
name|add
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|argv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|n
operator|=
name|arg
operator|->
name|argn
init|;
name|n
operator|<
name|arg
operator|->
name|argc
condition|;
name|n
operator|++
control|)
block|{
name|argv
index|[
literal|1
index|]
operator|=
name|arg
operator|->
name|argv
index|[
name|n
index|]
expr_stmt|;
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|NegotiateCommands
operator|+
operator|(
name|keep
operator|==
name|NEG_HISMASK
condition|?
literal|0
else|:
name|OPT_MAX
operator|)
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Use `%s ?' to get a list.\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s command must have arguments\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|command_ShowNegval
parameter_list|(
name|unsigned
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|val
operator|&
literal|3
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"disabled& accepted"
return|;
case|case
literal|2
case|:
return|return
literal|"enabled& denied"
return|;
case|case
literal|3
case|:
return|return
literal|"enabled& accepted"
return|;
block|}
return|return
literal|"disabled& denied"
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ClearCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pppThroughput
modifier|*
name|t
decl_stmt|;
name|struct
name|datalink
modifier|*
name|cx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|clear_type
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|<
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"modem"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cx
operator|=
name|arg
operator|->
name|cx
expr_stmt|;
if|if
condition|(
operator|!
name|cx
condition|)
name|cx
operator|=
name|bundle2datalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cx
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"A link must be specified for ``clear modem''\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|=
operator|&
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|throughput
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ipcp"
argument_list|)
operator|==
literal|0
condition|)
name|t
operator|=
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|throughput
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
name|clear_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|arg
operator|->
name|argn
operator|+
literal|1
init|;
name|i
operator|<
name|arg
operator|->
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|i
index|]
argument_list|,
literal|"overall"
argument_list|)
operator|==
literal|0
condition|)
name|clear_type
operator||=
name|THROUGHPUT_OVERALL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|i
index|]
argument_list|,
literal|"current"
argument_list|)
operator|==
literal|0
condition|)
name|clear_type
operator||=
name|THROUGHPUT_CURRENT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|i
index|]
argument_list|,
literal|"peak"
argument_list|)
operator|==
literal|0
condition|)
name|clear_type
operator||=
name|THROUGHPUT_PEAK
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
name|clear_type
operator|=
name|THROUGHPUT_ALL
expr_stmt|;
name|throughput_clear
argument_list|(
name|t
argument_list|,
name|clear_type
argument_list|,
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

