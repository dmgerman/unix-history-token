begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *		PPP User command processing module  *  *	    Written by Toshiharu OHNO (tony-o@iij.ad.jp)  *  *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the Internet Initiative Japan, Inc.  The name of the  * IIJ may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NONAT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|LOCALNAT
end_ifdef

begin_include
include|#
directive|include
file|"alias.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<alias.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"layer.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"iplist.h"
end_include

begin_include
include|#
directive|include
file|"throughput.h"
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_include
include|#
directive|include
file|"lqr.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NONAT
end_ifndef

begin_include
include|#
directive|include
file|"nat_cmd.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"systems.h"
end_include

begin_include
include|#
directive|include
file|"filter.h"
end_include

begin_include
include|#
directive|include
file|"descriptor.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_include
include|#
directive|include
file|"ccp.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"async.h"
end_include

begin_include
include|#
directive|include
file|"link.h"
end_include

begin_include
include|#
directive|include
file|"physical.h"
end_include

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NORADIUS
end_ifndef

begin_include
include|#
directive|include
file|"radius.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bundle.h"
end_include

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"prompt.h"
end_include

begin_include
include|#
directive|include
file|"chat.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"cbcp.h"
end_include

begin_include
include|#
directive|include
file|"datalink.h"
end_include

begin_include
include|#
directive|include
file|"iface.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_comment
comment|/* ``set'' values */
end_comment

begin_define
define|#
directive|define
name|VAR_AUTHKEY
value|0
end_define

begin_define
define|#
directive|define
name|VAR_DIAL
value|1
end_define

begin_define
define|#
directive|define
name|VAR_LOGIN
value|2
end_define

begin_define
define|#
directive|define
name|VAR_AUTHNAME
value|3
end_define

begin_define
define|#
directive|define
name|VAR_AUTOLOAD
value|4
end_define

begin_define
define|#
directive|define
name|VAR_WINSIZE
value|5
end_define

begin_define
define|#
directive|define
name|VAR_DEVICE
value|6
end_define

begin_define
define|#
directive|define
name|VAR_ACCMAP
value|7
end_define

begin_define
define|#
directive|define
name|VAR_MRRU
value|8
end_define

begin_define
define|#
directive|define
name|VAR_MRU
value|9
end_define

begin_define
define|#
directive|define
name|VAR_MTU
value|10
end_define

begin_define
define|#
directive|define
name|VAR_OPENMODE
value|11
end_define

begin_define
define|#
directive|define
name|VAR_PHONE
value|12
end_define

begin_define
define|#
directive|define
name|VAR_HANGUP
value|13
end_define

begin_define
define|#
directive|define
name|VAR_IDLETIMEOUT
value|14
end_define

begin_define
define|#
directive|define
name|VAR_LQRPERIOD
value|15
end_define

begin_define
define|#
directive|define
name|VAR_LCPRETRY
value|16
end_define

begin_define
define|#
directive|define
name|VAR_CHAPRETRY
value|17
end_define

begin_define
define|#
directive|define
name|VAR_PAPRETRY
value|18
end_define

begin_define
define|#
directive|define
name|VAR_CCPRETRY
value|19
end_define

begin_define
define|#
directive|define
name|VAR_IPCPRETRY
value|20
end_define

begin_define
define|#
directive|define
name|VAR_DNS
value|21
end_define

begin_define
define|#
directive|define
name|VAR_NBNS
value|22
end_define

begin_define
define|#
directive|define
name|VAR_MODE
value|23
end_define

begin_define
define|#
directive|define
name|VAR_CALLBACK
value|24
end_define

begin_define
define|#
directive|define
name|VAR_CBCP
value|25
end_define

begin_define
define|#
directive|define
name|VAR_CHOKED
value|26
end_define

begin_define
define|#
directive|define
name|VAR_SENDPIPE
value|27
end_define

begin_define
define|#
directive|define
name|VAR_RECVPIPE
value|28
end_define

begin_define
define|#
directive|define
name|VAR_RADIUS
value|29
end_define

begin_define
define|#
directive|define
name|VAR_CD
value|30
end_define

begin_define
define|#
directive|define
name|VAR_PARITY
value|31
end_define

begin_define
define|#
directive|define
name|VAR_CRTSCTS
value|32
end_define

begin_define
define|#
directive|define
name|VAR_URGENTPORTS
value|33
end_define

begin_define
define|#
directive|define
name|VAR_LOGOUT
value|34
end_define

begin_comment
comment|/* ``accept|deny|disable|enable'' masks */
end_comment

begin_define
define|#
directive|define
name|NEG_HISMASK
value|(1)
end_define

begin_define
define|#
directive|define
name|NEG_MYMASK
value|(2)
end_define

begin_comment
comment|/* ``accept|deny|disable|enable'' values */
end_comment

begin_define
define|#
directive|define
name|NEG_ACFCOMP
value|40
end_define

begin_define
define|#
directive|define
name|NEG_CHAP05
value|41
end_define

begin_define
define|#
directive|define
name|NEG_CHAP80
value|42
end_define

begin_define
define|#
directive|define
name|NEG_CHAP80LM
value|43
end_define

begin_define
define|#
directive|define
name|NEG_DEFLATE
value|44
end_define

begin_define
define|#
directive|define
name|NEG_DNS
value|45
end_define

begin_define
define|#
directive|define
name|NEG_ENDDISC
value|46
end_define

begin_define
define|#
directive|define
name|NEG_LQR
value|47
end_define

begin_define
define|#
directive|define
name|NEG_PAP
value|48
end_define

begin_define
define|#
directive|define
name|NEG_PPPDDEFLATE
value|49
end_define

begin_define
define|#
directive|define
name|NEG_PRED1
value|50
end_define

begin_define
define|#
directive|define
name|NEG_PROTOCOMP
value|51
end_define

begin_define
define|#
directive|define
name|NEG_SHORTSEQ
value|52
end_define

begin_define
define|#
directive|define
name|NEG_VJCOMP
value|53
end_define

begin_decl_stmt
specifier|const
name|char
name|Version
index|[]
init|=
literal|"2.26"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ShowCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|TerminalCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|QuitCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|OpenCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|CloseCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|DownCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SetCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|LinkCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|AddCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|DeleteCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|NegotiateCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ClearCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|RunListCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IfaceAddCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IfaceDeleteCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|IfaceClearCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|SetProcTitle
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NONAT
end_ifndef

begin_function_decl
specifier|static
name|int
name|AliasEnable
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|AliasOption
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|showcx
parameter_list|(
name|struct
name|cmdtab
specifier|const
modifier|*
name|cmd
parameter_list|)
block|{
if|if
condition|(
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX
condition|)
return|return
literal|"(c)"
return|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX_OPT
condition|)
return|return
literal|"(o)"
return|;
return|return
literal|""
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|HelpCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|cmdtab
specifier|const
modifier|*
name|cmd
decl_stmt|;
name|int
name|n
decl_stmt|,
name|cmax
decl_stmt|,
name|dmax
decl_stmt|,
name|cols
decl_stmt|,
name|cxlen
decl_stmt|;
specifier|const
name|char
modifier|*
name|cx
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|->
name|prompt
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"help: Cannot help without a prompt\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
for|for
control|(
name|cmd
operator|=
name|arg
operator|->
name|cmdtab
init|;
name|cmd
operator|->
name|name
operator|||
name|cmd
operator|->
name|alias
condition|;
name|cmd
operator|++
control|)
if|if
condition|(
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|arg
operator|->
name|prompt
operator|->
name|auth
operator|)
operator|&&
operator|(
operator|(
name|cmd
operator|->
name|name
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|cmd
operator|->
name|name
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
operator|)
operator|||
operator|(
name|cmd
operator|->
name|alias
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|cmd
operator|->
name|alias
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%s %s\n"
argument_list|,
name|cmd
operator|->
name|syntax
argument_list|,
name|showcx
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
name|cmax
operator|=
name|dmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cmd
operator|=
name|arg
operator|->
name|cmdtab
init|;
name|cmd
operator|->
name|func
condition|;
name|cmd
operator|++
control|)
if|if
condition|(
name|cmd
operator|->
name|name
operator|&&
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|arg
operator|->
name|prompt
operator|->
name|auth
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|cmd
operator|->
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|showcx
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|)
operator|>
name|cmax
condition|)
name|cmax
operator|=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|cmd
operator|->
name|helpmes
argument_list|)
operator|)
operator|>
name|dmax
condition|)
name|dmax
operator|=
name|n
expr_stmt|;
block|}
name|cols
operator|=
literal|80
operator|/
operator|(
name|dmax
operator|+
name|cmax
operator|+
literal|3
operator|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"(o) = Optional context,"
literal|" (c) = Context required\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|cmd
operator|=
name|arg
operator|->
name|cmdtab
init|;
name|cmd
operator|->
name|func
condition|;
name|cmd
operator|++
control|)
if|if
condition|(
name|cmd
operator|->
name|name
operator|&&
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|arg
operator|->
name|prompt
operator|->
name|auth
operator|)
condition|)
block|{
name|cx
operator|=
name|showcx
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cxlen
operator|=
name|cmax
operator|-
name|strlen
argument_list|(
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|%
name|cols
operator|!=
literal|0
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%s%-*.*s: %-*.*s"
argument_list|,
name|cmd
operator|->
name|name
argument_list|,
name|cxlen
argument_list|,
name|cxlen
argument_list|,
name|cx
argument_list|,
name|dmax
argument_list|,
name|dmax
argument_list|,
name|cmd
operator|->
name|helpmes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|n
operator|%
name|cols
operator|==
literal|0
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|%
name|cols
operator|!=
literal|0
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|CloneCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|namelist
index|[
name|LINE_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|f
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
return|return
operator|-
literal|1
return|;
name|namelist
index|[
sizeof|sizeof
name|namelist
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|f
operator|=
name|arg
operator|->
name|argn
init|;
name|f
operator|<
name|arg
operator|->
name|argc
condition|;
name|f
operator|++
control|)
block|{
name|strncpy
argument_list|(
name|namelist
argument_list|,
name|arg
operator|->
name|argv
index|[
name|f
index|]
argument_list|,
sizeof|sizeof
name|namelist
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|name
operator|=
name|strtok
argument_list|(
name|namelist
argument_list|,
literal|", "
argument_list|)
init|;
name|name
condition|;
name|name
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|", "
argument_list|)
control|)
name|bundle_DatalinkClone
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|RemoveCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|!=
name|arg
operator|->
name|argn
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|arg
operator|->
name|cx
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"remove: Cannot delete links that aren't closed\n"
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
name|bundle_DatalinkRemove
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|RenameCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|!=
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|bundle_RenameDatalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s -> %s: target name already exists\n"
argument_list|,
name|arg
operator|->
name|cx
operator|->
name|name
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|LoadCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|err
decl_stmt|;
name|int
name|n
decl_stmt|,
name|mode
decl_stmt|;
name|mode
operator|=
name|arg
operator|->
name|bundle
operator|->
name|phys_type
operator|.
name|all
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argn
operator|<
name|arg
operator|->
name|argc
condition|)
block|{
for|for
control|(
name|n
operator|=
name|arg
operator|->
name|argn
init|;
name|n
operator|<
name|arg
operator|->
name|argc
condition|;
name|n
operator|++
control|)
if|if
condition|(
operator|(
name|err
operator|=
name|system_IsValid
argument_list|(
name|arg
operator|->
name|argv
index|[
name|n
index|]
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|n
index|]
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|n
operator|=
name|arg
operator|->
name|argn
init|;
name|n
operator|<
name|arg
operator|->
name|argc
condition|;
name|n
operator|++
control|)
block|{
name|bundle_SetLabel
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|system_Select
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|argv
index|[
name|n
index|]
argument_list|,
name|CONFFILE
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
block|}
name|bundle_SetLabel
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argc
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|err
operator|=
name|system_IsValid
argument_list|(
literal|"default"
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"default: %s\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|bundle_SetLabel
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
name|system_Select
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
literal|"default"
argument_list|,
name|CONFFILE
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
name|bundle_SetLabel
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|SaveCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"save command is not implemented (yet).\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DialCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|arg
operator|->
name|cx
operator|&&
operator|!
operator|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|type
operator|&
operator|(
name|PHYS_INTERACTIVE
operator||
name|PHYS_AUTO
operator|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|arg
operator|->
name|cx
operator|&&
operator|(
name|arg
operator|->
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|&
operator|~
operator|(
name|PHYS_INTERACTIVE
operator||
name|PHYS_AUTO
operator|)
operator|)
operator|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Manual dial is only available for auto and"
literal|" interactive links\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|&&
operator|(
name|res
operator|=
name|LoadCommand
argument_list|(
name|arg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|res
return|;
name|bundle_Open
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
condition|?
name|arg
operator|->
name|cx
operator|->
name|name
else|:
name|NULL
argument_list|,
name|PHYS_ALL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|isinword
parameter_list|(
name|ch
parameter_list|)
value|(isalnum(ch) || (ch) == '_')
end_define

begin_function
specifier|static
name|char
modifier|*
name|strstrword
parameter_list|(
name|char
modifier|*
name|big
parameter_list|,
specifier|const
name|char
modifier|*
name|little
parameter_list|)
block|{
comment|/* Get the first occurance of the word ``little'' in ``big'' */
name|char
modifier|*
name|pos
decl_stmt|;
name|int
name|len
decl_stmt|;
name|pos
operator|=
name|big
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|little
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pos
operator|=
name|strstr
argument_list|(
name|pos
argument_list|,
name|little
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|pos
operator|!=
name|big
operator|&&
name|isinword
argument_list|(
name|pos
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|||
name|isinword
argument_list|(
name|pos
index|[
name|len
index|]
argument_list|)
condition|)
name|pos
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|pos
operator|!=
name|big
operator|&&
name|pos
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|memmove
argument_list|(
name|pos
operator|-
literal|1
argument_list|,
name|pos
argument_list|,
name|strlen
argument_list|(
name|pos
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
break|break;
return|return
name|pos
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|subst
parameter_list|(
name|char
modifier|*
name|tgt
parameter_list|,
specifier|const
name|char
modifier|*
name|oldstr
parameter_list|,
specifier|const
name|char
modifier|*
name|newstr
parameter_list|)
block|{
comment|/* tgt is a malloc()d area... realloc() as necessary */
name|char
modifier|*
name|word
decl_stmt|,
modifier|*
name|ntgt
decl_stmt|;
name|int
name|ltgt
decl_stmt|,
name|loldstr
decl_stmt|,
name|lnewstr
decl_stmt|,
name|pos
decl_stmt|;
if|if
condition|(
operator|(
name|word
operator|=
name|strstrword
argument_list|(
name|tgt
argument_list|,
name|oldstr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|tgt
return|;
name|ltgt
operator|=
name|strlen
argument_list|(
name|tgt
argument_list|)
operator|+
literal|1
expr_stmt|;
name|loldstr
operator|=
name|strlen
argument_list|(
name|oldstr
argument_list|)
expr_stmt|;
name|lnewstr
operator|=
name|strlen
argument_list|(
name|newstr
argument_list|)
expr_stmt|;
do|do
block|{
name|pos
operator|=
name|word
operator|-
name|tgt
expr_stmt|;
if|if
condition|(
name|loldstr
operator|>
name|lnewstr
condition|)
name|bcopy
argument_list|(
name|word
operator|+
name|loldstr
argument_list|,
name|word
operator|+
name|lnewstr
argument_list|,
name|ltgt
operator|-
name|pos
operator|-
name|loldstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|loldstr
operator|!=
name|lnewstr
condition|)
block|{
name|ntgt
operator|=
name|realloc
argument_list|(
name|tgt
argument_list|,
name|ltgt
operator|+=
name|lnewstr
operator|-
name|loldstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntgt
operator|==
name|NULL
condition|)
break|break;
comment|/* Oh wonderful ! */
name|word
operator|=
name|ntgt
operator|+
name|pos
expr_stmt|;
name|tgt
operator|=
name|ntgt
expr_stmt|;
block|}
if|if
condition|(
name|lnewstr
operator|>
name|loldstr
condition|)
name|bcopy
argument_list|(
name|word
operator|+
name|loldstr
argument_list|,
name|word
operator|+
name|lnewstr
argument_list|,
name|ltgt
operator|-
name|pos
operator|-
name|loldstr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|newstr
argument_list|,
name|word
argument_list|,
name|lnewstr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|word
operator|=
name|strstrword
argument_list|(
name|word
argument_list|,
name|oldstr
argument_list|)
operator|)
condition|)
do|;
return|return
name|tgt
return|;
block|}
end_function

begin_function
name|void
name|command_Expand
parameter_list|(
name|char
modifier|*
modifier|*
name|nargv
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|oargv
parameter_list|,
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|inc0
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|int
name|arg
decl_stmt|;
name|char
name|pidstr
index|[
literal|12
index|]
decl_stmt|;
if|if
condition|(
name|inc0
condition|)
name|arg
operator|=
literal|0
expr_stmt|;
comment|/* Start at arg 0 */
else|else
block|{
name|nargv
index|[
literal|0
index|]
operator|=
name|strdup
argument_list|(
name|oargv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|arg
operator|=
literal|1
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|pidstr
argument_list|,
sizeof|sizeof
name|pidstr
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|pid
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|arg
operator|<
name|argc
condition|;
name|arg
operator|++
control|)
block|{
name|nargv
index|[
name|arg
index|]
operator|=
name|strdup
argument_list|(
name|oargv
index|[
name|arg
index|]
argument_list|)
expr_stmt|;
name|nargv
index|[
name|arg
index|]
operator|=
name|subst
argument_list|(
name|nargv
index|[
name|arg
index|]
argument_list|,
literal|"HISADDR"
argument_list|,
name|inet_ntoa
argument_list|(
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|peer_ip
argument_list|)
argument_list|)
expr_stmt|;
name|nargv
index|[
name|arg
index|]
operator|=
name|subst
argument_list|(
name|nargv
index|[
name|arg
index|]
argument_list|,
literal|"AUTHNAME"
argument_list|,
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
argument_list|)
expr_stmt|;
name|nargv
index|[
name|arg
index|]
operator|=
name|subst
argument_list|(
name|nargv
index|[
name|arg
index|]
argument_list|,
literal|"INTERFACE"
argument_list|,
name|bundle
operator|->
name|iface
operator|->
name|name
argument_list|)
expr_stmt|;
name|nargv
index|[
name|arg
index|]
operator|=
name|subst
argument_list|(
name|nargv
index|[
name|arg
index|]
argument_list|,
literal|"MYADDR"
argument_list|,
name|inet_ntoa
argument_list|(
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|my_ip
argument_list|)
argument_list|)
expr_stmt|;
name|nargv
index|[
name|arg
index|]
operator|=
name|subst
argument_list|(
name|nargv
index|[
name|arg
index|]
argument_list|,
literal|"USER"
argument_list|,
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|peer
operator|.
name|authname
argument_list|)
expr_stmt|;
name|nargv
index|[
name|arg
index|]
operator|=
name|subst
argument_list|(
name|nargv
index|[
name|arg
index|]
argument_list|,
literal|"PEER_ENDDISC"
argument_list|,
name|mp_Enddisc
argument_list|(
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|peer
operator|.
name|enddisc
operator|.
name|class
argument_list|,
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|peer
operator|.
name|enddisc
operator|.
name|address
argument_list|,
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|peer
operator|.
name|enddisc
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nargv
index|[
name|arg
index|]
operator|=
name|subst
argument_list|(
name|nargv
index|[
name|arg
index|]
argument_list|,
literal|"ENDDISC"
argument_list|,
name|mp_Enddisc
argument_list|(
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|enddisc
operator|.
name|class
argument_list|,
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|enddisc
operator|.
name|address
argument_list|,
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|enddisc
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|nargv
index|[
name|arg
index|]
operator|=
name|subst
argument_list|(
name|nargv
index|[
name|arg
index|]
argument_list|,
literal|"PROCESSID"
argument_list|,
name|pidstr
argument_list|)
expr_stmt|;
name|nargv
index|[
name|arg
index|]
operator|=
name|subst
argument_list|(
name|nargv
index|[
name|arg
index|]
argument_list|,
literal|"LABEL"
argument_list|,
name|bundle_GetLabel
argument_list|(
name|bundle
argument_list|)
argument_list|)
expr_stmt|;
name|nargv
index|[
name|arg
index|]
operator|=
name|subst
argument_list|(
name|nargv
index|[
name|arg
index|]
argument_list|,
literal|"DNS0"
argument_list|,
name|inet_ntoa
argument_list|(
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|ns
operator|.
name|dns
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|nargv
index|[
name|arg
index|]
operator|=
name|subst
argument_list|(
name|nargv
index|[
name|arg
index|]
argument_list|,
literal|"DNS1"
argument_list|,
name|inet_ntoa
argument_list|(
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|ns
operator|.
name|dns
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nargv
index|[
name|arg
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShellCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|,
name|int
name|bg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|shell
decl_stmt|;
name|pid_t
name|shpid
decl_stmt|,
name|pid
decl_stmt|;
ifdef|#
directive|ifdef
name|SHELL_ONLY_INTERACTIVELY
comment|/* we're only allowed to shell when we run ppp interactively */
if|if
condition|(
name|arg
operator|->
name|prompt
operator|&&
name|arg
operator|->
name|prompt
operator|->
name|owner
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Can't start a shell from a network connection\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|prompt
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Can't start an interactive shell from"
literal|" a config file\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
operator|->
name|owner
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Can't start an interactive shell from"
literal|" a socket connection\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|bg
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Can only start an interactive shell in"
literal|" the foreground mode\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|shpid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|shell
operator|=
name|_PATH_BSHELL
expr_stmt|;
name|timer_TermService
argument_list|()
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|fd
operator|=
name|arg
operator|->
name|prompt
operator|->
name|fd_out
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PATH_DEVNULL
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"Failed to open %s: %s\n"
argument_list|,
name|_PATH_DEVNULL
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fd
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|getdtablesize
argument_list|()
init|;
name|i
operator|>
name|STDERR_FILENO
condition|;
name|i
operator|--
control|)
name|fcntl
argument_list|(
name|i
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|ID0realuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
comment|/* substitute pseudo args */
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
decl_stmt|;
name|int
name|argc
init|=
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
decl_stmt|;
if|if
condition|(
name|argc
operator|>=
sizeof|sizeof
name|argv
operator|/
sizeof|sizeof
name|argv
index|[
literal|0
index|]
condition|)
block|{
name|argc
operator|=
sizeof|sizeof
name|argv
operator|/
sizeof|sizeof
name|argv
index|[
literal|0
index|]
operator|-
literal|1
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Truncating shell command to %d args\n"
argument_list|,
name|argc
argument_list|)
expr_stmt|;
block|}
name|command_Expand
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|bundle
argument_list|,
literal|0
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bg
condition|)
block|{
name|pid_t
name|p
decl_stmt|;
name|p
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|daemon
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"%d: daemon: %s\n"
argument_list|,
operator|(
name|int
operator|)
name|p
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|printf
argument_list|(
literal|"ppp: Pausing until %s finishes\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|printf
argument_list|(
literal|"ppp: Pausing until %s finishes\n"
argument_list|,
name|shell
argument_list|)
expr_stmt|;
name|prompt_TtyOldMode
argument_list|(
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
name|execl
argument_list|(
name|shell
argument_list|,
name|shell
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"exec() of %s failed: %s\n"
argument_list|,
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|?
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
else|:
name|shell
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|255
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|shpid
operator|==
operator|(
name|pid_t
operator|)
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Fork failed: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|status
decl_stmt|;
name|waitpid
argument_list|(
name|shpid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|->
name|prompt
operator|&&
operator|!
name|arg
operator|->
name|prompt
operator|->
name|owner
condition|)
name|prompt_TtyCommandMode
argument_list|(
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|BgShellCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ShellCommand
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FgShellCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|ShellCommand
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ResolvCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"reload"
argument_list|)
condition|)
name|ipcp_LoadDNS
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"restore"
argument_list|)
condition|)
name|ipcp_RestoreDNS
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"rewrite"
argument_list|)
condition|)
name|ipcp_WriteDNS
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"readonly"
argument_list|)
condition|)
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|ns
operator|.
name|writable
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"writable"
argument_list|)
condition|)
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|ns
operator|.
name|writable
operator|=
literal|1
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NONAT
end_ifndef

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|AliasCommands
index|[]
init|=
block|{
block|{
literal|"addr"
block|,
name|NULL
block|,
name|nat_RedirectAddr
block|,
name|LOCAL_AUTH
block|,
literal|"static address translation"
block|,
literal|"nat addr [addr_local addr_alias]"
block|}
block|,
block|{
literal|"deny_incoming"
block|,
name|NULL
block|,
name|AliasOption
block|,
name|LOCAL_AUTH
block|,
literal|"stop incoming connections"
block|,
literal|"nat deny_incoming yes|no"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|PKT_ALIAS_DENY_INCOMING
block|}
block|,
block|{
literal|"enable"
block|,
name|NULL
block|,
name|AliasEnable
block|,
name|LOCAL_AUTH
block|,
literal|"enable NAT"
block|,
literal|"nat enable yes|no"
block|}
block|,
block|{
literal|"log"
block|,
name|NULL
block|,
name|AliasOption
block|,
name|LOCAL_AUTH
block|,
literal|"log NAT link creation"
block|,
literal|"nat log yes|no"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|PKT_ALIAS_LOG
block|}
block|,
block|{
literal|"port"
block|,
name|NULL
block|,
name|nat_RedirectPort
block|,
name|LOCAL_AUTH
block|,
literal|"port redirection"
block|,
literal|"nat port proto localaddr:port[-port] aliasport[-aliasport]"
block|}
block|,
block|{
literal|"pptp"
block|,
name|NULL
block|,
name|nat_Pptp
block|,
name|LOCAL_AUTH
block|,
literal|"Set the PPTP address"
block|,
literal|"nat pptp IP"
block|}
block|,
block|{
literal|"proxy"
block|,
name|NULL
block|,
name|nat_ProxyRule
block|,
name|LOCAL_AUTH
block|,
literal|"proxy control"
block|,
literal|"nat proxy server host[:port] ..."
block|}
block|,
block|{
literal|"same_ports"
block|,
name|NULL
block|,
name|AliasOption
block|,
name|LOCAL_AUTH
block|,
literal|"try to leave port numbers unchanged"
block|,
literal|"nat same_ports yes|no"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|PKT_ALIAS_SAME_PORTS
block|}
block|,
block|{
literal|"unregistered_only"
block|,
name|NULL
block|,
name|AliasOption
block|,
name|LOCAL_AUTH
block|,
literal|"translate unregistered (private) IP address space only"
block|,
literal|"nat unregistered_only yes|no"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|PKT_ALIAS_UNREGISTERED_ONLY
block|}
block|,
block|{
literal|"use_sockets"
block|,
name|NULL
block|,
name|AliasOption
block|,
name|LOCAL_AUTH
block|,
literal|"allocate host sockets"
block|,
literal|"nat use_sockets yes|no"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|PKT_ALIAS_USE_SOCKETS
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Display this message"
block|,
literal|"nat help|? [command]"
block|,
name|AliasCommands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|AllowCommands
index|[]
init|=
block|{
block|{
literal|"modes"
block|,
literal|"mode"
block|,
name|AllowModes
block|,
name|LOCAL_AUTH
block|,
literal|"Only allow certain ppp modes"
block|,
literal|"allow modes mode..."
block|}
block|,
block|{
literal|"users"
block|,
literal|"user"
block|,
name|AllowUsers
block|,
name|LOCAL_AUTH
block|,
literal|"Only allow ppp access to certain users"
block|,
literal|"allow users logname..."
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Display this message"
block|,
literal|"allow help|? [command]"
block|,
name|AllowCommands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|IfaceCommands
index|[]
init|=
block|{
block|{
literal|"add"
block|,
name|NULL
block|,
name|IfaceAddCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Add iface address"
block|,
literal|"iface add addr[/bits| mask] peer"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"add!"
block|,
name|IfaceAddCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Add or change an iface address"
block|,
literal|"iface add! addr[/bits| mask] peer"
block|,
operator|(
name|void
operator|*
operator|)
literal|1
block|}
block|,
block|{
literal|"clear"
block|,
name|NULL
block|,
name|IfaceClearCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Clear iface address(es)"
block|,
literal|"iface clear"
block|}
block|,
block|{
literal|"delete"
block|,
literal|"rm"
block|,
name|IfaceDeleteCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Delete iface address"
block|,
literal|"iface delete addr"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"rm!"
block|,
name|IfaceDeleteCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Delete iface address"
block|,
literal|"iface delete addr"
block|,
operator|(
name|void
operator|*
operator|)
literal|1
block|}
block|,
block|{
name|NULL
block|,
literal|"delete!"
block|,
name|IfaceDeleteCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Delete iface address"
block|,
literal|"iface delete addr"
block|,
operator|(
name|void
operator|*
operator|)
literal|1
block|}
block|,
block|{
literal|"show"
block|,
name|NULL
block|,
name|iface_Show
block|,
name|LOCAL_AUTH
block|,
literal|"Show iface address(es)"
block|,
literal|"iface show"
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Display this message"
block|,
literal|"nat help|? [command]"
block|,
name|IfaceCommands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|Commands
index|[]
init|=
block|{
block|{
literal|"accept"
block|,
name|NULL
block|,
name|NegotiateCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"accept option request"
block|,
literal|"accept option .."
block|}
block|,
block|{
literal|"add"
block|,
name|NULL
block|,
name|AddCommand
block|,
name|LOCAL_AUTH
block|,
literal|"add route"
block|,
literal|"add dest mask gateway"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"add!"
block|,
name|AddCommand
block|,
name|LOCAL_AUTH
block|,
literal|"add or change route"
block|,
literal|"add! dest mask gateway"
block|,
operator|(
name|void
operator|*
operator|)
literal|1
block|}
block|,
block|{
literal|"allow"
block|,
literal|"auth"
block|,
name|RunListCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Allow ppp access"
block|,
literal|"allow users|modes ...."
block|,
name|AllowCommands
block|}
block|,
block|{
literal|"bg"
block|,
literal|"!bg"
block|,
name|BgShellCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Run a background command"
block|,
literal|"[!]bg command"
block|}
block|,
block|{
literal|"clear"
block|,
name|NULL
block|,
name|ClearCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Clear throughput statistics"
block|,
literal|"clear ipcp|physical [current|overall|peak]..."
block|}
block|,
block|{
literal|"clone"
block|,
name|NULL
block|,
name|CloneCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Clone a link"
block|,
literal|"clone newname..."
block|}
block|,
block|{
literal|"close"
block|,
name|NULL
block|,
name|CloseCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Close an FSM"
block|,
literal|"close [lcp|ccp]"
block|}
block|,
block|{
literal|"delete"
block|,
name|NULL
block|,
name|DeleteCommand
block|,
name|LOCAL_AUTH
block|,
literal|"delete route"
block|,
literal|"delete dest"
block|,
name|NULL
block|}
block|,
block|{
name|NULL
block|,
literal|"delete!"
block|,
name|DeleteCommand
block|,
name|LOCAL_AUTH
block|,
literal|"delete a route if it exists"
block|,
literal|"delete! dest"
block|,
operator|(
name|void
operator|*
operator|)
literal|1
block|}
block|,
block|{
literal|"deny"
block|,
name|NULL
block|,
name|NegotiateCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Deny option request"
block|,
literal|"deny option .."
block|}
block|,
block|{
literal|"dial"
block|,
literal|"call"
block|,
name|DialCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Dial and login"
block|,
literal|"dial|call [system ...]"
block|,
name|NULL
block|}
block|,
block|{
literal|"disable"
block|,
name|NULL
block|,
name|NegotiateCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Disable option"
block|,
literal|"disable option .."
block|}
block|,
block|{
literal|"down"
block|,
name|NULL
block|,
name|DownCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Generate a down event"
block|,
literal|"down [ccp|lcp]"
block|}
block|,
block|{
literal|"enable"
block|,
name|NULL
block|,
name|NegotiateCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Enable option"
block|,
literal|"enable option .."
block|}
block|,
block|{
literal|"iface"
block|,
literal|"interface"
block|,
name|RunListCommand
block|,
name|LOCAL_AUTH
block|,
literal|"interface control"
block|,
literal|"iface option ..."
block|,
name|IfaceCommands
block|}
block|,
block|{
literal|"link"
block|,
literal|"datalink"
block|,
name|LinkCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Link specific commands"
block|,
literal|"link name command ..."
block|}
block|,
block|{
literal|"load"
block|,
name|NULL
block|,
name|LoadCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Load settings"
block|,
literal|"load [system ...]"
block|}
block|,
ifndef|#
directive|ifndef
name|NONAT
block|{
literal|"nat"
block|,
literal|"alias"
block|,
name|RunListCommand
block|,
name|LOCAL_AUTH
block|,
literal|"NAT control"
block|,
literal|"nat option yes|no"
block|,
name|AliasCommands
block|}
block|,
endif|#
directive|endif
block|{
literal|"open"
block|,
name|NULL
block|,
name|OpenCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Open an FSM"
block|,
literal|"open! [lcp|ccp|ipcp]"
block|,
operator|(
name|void
operator|*
operator|)
literal|1
block|}
block|,
block|{
literal|"passwd"
block|,
name|NULL
block|,
name|PasswdCommand
block|,
name|LOCAL_NO_AUTH
block|,
literal|"Password for manipulation"
block|,
literal|"passwd LocalPassword"
block|}
block|,
block|{
literal|"quit"
block|,
literal|"bye"
block|,
name|QuitCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Quit PPP program"
block|,
literal|"quit|bye [all]"
block|}
block|,
block|{
literal|"remove"
block|,
literal|"rm"
block|,
name|RemoveCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Remove a link"
block|,
literal|"remove"
block|}
block|,
block|{
literal|"rename"
block|,
literal|"mv"
block|,
name|RenameCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Rename a link"
block|,
literal|"rename name"
block|}
block|,
block|{
literal|"resolv"
block|,
name|NULL
block|,
name|ResolvCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Manipulate resolv.conf"
block|,
literal|"resolv readonly|reload|restore|rewrite|writable"
block|}
block|,
block|{
literal|"save"
block|,
name|NULL
block|,
name|SaveCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Save settings"
block|,
literal|"save"
block|}
block|,
block|{
literal|"set"
block|,
literal|"setup"
block|,
name|SetCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Set parameters"
block|,
literal|"set[up] var value"
block|}
block|,
block|{
literal|"shell"
block|,
literal|"!"
block|,
name|FgShellCommand
block|,
name|LOCAL_AUTH
block|,
literal|"Run a subshell"
block|,
literal|"shell|! [sh command]"
block|}
block|,
block|{
literal|"show"
block|,
name|NULL
block|,
name|ShowCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Show status and stats"
block|,
literal|"show var"
block|}
block|,
block|{
literal|"term"
block|,
name|NULL
block|,
name|TerminalCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Enter terminal mode"
block|,
literal|"term"
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Display this message"
block|,
literal|"help|? [command]"
block|,
name|Commands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ShowEscape
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
literal|32
index|]
condition|)
block|{
name|int
name|code
decl_stmt|,
name|bit
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
init|=
literal|""
decl_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|32
condition|;
name|code
operator|++
control|)
if|if
condition|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
name|code
index|]
condition|)
for|for
control|(
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
literal|8
condition|;
name|bit
operator|++
control|)
if|if
condition|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
name|code
index|]
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
condition|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%s0x%02x"
argument_list|,
name|sep
argument_list|,
operator|(
name|code
operator|<<
literal|3
operator|)
operator|+
name|bit
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShowTimerList
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|timer_Show
argument_list|(
literal|0
argument_list|,
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShowStopped
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Stopped Timer:  LCP: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Disabled"
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%ld secs"
argument_list|,
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|/
name|SECTICKS
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|", CCP: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|ccp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Disabled"
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%ld secs"
argument_list|,
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|ccp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|/
name|SECTICKS
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShowVersion
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"PPP Version %s - %s\n"
argument_list|,
name|Version
argument_list|,
name|__DATE__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShowProtocolStats
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|link
modifier|*
name|l
init|=
name|command_ChooseLink
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%s:\n"
argument_list|,
name|l
operator|->
name|name
argument_list|)
expr_stmt|;
name|link_ReportProtocolStatus
argument_list|(
name|l
argument_list|,
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|ShowCommands
index|[]
init|=
block|{
block|{
literal|"bundle"
block|,
name|NULL
block|,
name|bundle_ShowStatus
block|,
name|LOCAL_AUTH
block|,
literal|"bundle details"
block|,
literal|"show bundle"
block|}
block|,
block|{
literal|"ccp"
block|,
name|NULL
block|,
name|ccp_ReportStatus
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"CCP status"
block|,
literal|"show cpp"
block|}
block|,
block|{
literal|"compress"
block|,
name|NULL
block|,
name|sl_Show
block|,
name|LOCAL_AUTH
block|,
literal|"VJ compression stats"
block|,
literal|"show compress"
block|}
block|,
block|{
literal|"escape"
block|,
name|NULL
block|,
name|ShowEscape
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"escape characters"
block|,
literal|"show escape"
block|}
block|,
block|{
literal|"filter"
block|,
name|NULL
block|,
name|filter_Show
block|,
name|LOCAL_AUTH
block|,
literal|"packet filters"
block|,
literal|"show filter [in|out|dial|alive]"
block|}
block|,
block|{
literal|"hdlc"
block|,
name|NULL
block|,
name|hdlc_ReportStatus
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"HDLC errors"
block|,
literal|"show hdlc"
block|}
block|,
block|{
literal|"iface"
block|,
literal|"interface"
block|,
name|iface_Show
block|,
name|LOCAL_AUTH
block|,
literal|"Interface status"
block|,
literal|"show iface"
block|}
block|,
block|{
literal|"ipcp"
block|,
name|NULL
block|,
name|ipcp_Show
block|,
name|LOCAL_AUTH
block|,
literal|"IPCP status"
block|,
literal|"show ipcp"
block|}
block|,
block|{
literal|"layers"
block|,
name|NULL
block|,
name|link_ShowLayers
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Protocol layers"
block|,
literal|"show layers"
block|}
block|,
block|{
literal|"lcp"
block|,
name|NULL
block|,
name|lcp_ReportStatus
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"LCP status"
block|,
literal|"show lcp"
block|}
block|,
block|{
literal|"link"
block|,
literal|"datalink"
block|,
name|datalink_Show
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"(high-level) link info"
block|,
literal|"show link"
block|}
block|,
block|{
literal|"links"
block|,
name|NULL
block|,
name|bundle_ShowLinks
block|,
name|LOCAL_AUTH
block|,
literal|"available link names"
block|,
literal|"show links"
block|}
block|,
block|{
literal|"log"
block|,
name|NULL
block|,
name|log_ShowLevel
block|,
name|LOCAL_AUTH
block|,
literal|"log levels"
block|,
literal|"show log"
block|}
block|,
block|{
literal|"mem"
block|,
name|NULL
block|,
name|mbuf_Show
block|,
name|LOCAL_AUTH
block|,
literal|"mbuf allocations"
block|,
literal|"show mem"
block|}
block|,
block|{
literal|"physical"
block|,
name|NULL
block|,
name|physical_ShowStatus
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"(low-level) link info"
block|,
literal|"show physical"
block|}
block|,
block|{
literal|"mp"
block|,
literal|"multilink"
block|,
name|mp_ShowStatus
block|,
name|LOCAL_AUTH
block|,
literal|"multilink setup"
block|,
literal|"show mp"
block|}
block|,
block|{
literal|"proto"
block|,
name|NULL
block|,
name|ShowProtocolStats
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"protocol summary"
block|,
literal|"show proto"
block|}
block|,
block|{
literal|"route"
block|,
name|NULL
block|,
name|route_Show
block|,
name|LOCAL_AUTH
block|,
literal|"routing table"
block|,
literal|"show route"
block|}
block|,
block|{
literal|"stopped"
block|,
name|NULL
block|,
name|ShowStopped
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"STOPPED timeout"
block|,
literal|"show stopped"
block|}
block|,
block|{
literal|"timers"
block|,
name|NULL
block|,
name|ShowTimerList
block|,
name|LOCAL_AUTH
block|,
literal|"alarm timers"
block|,
literal|"show timers"
block|}
block|,
block|{
literal|"version"
block|,
name|NULL
block|,
name|ShowVersion
block|,
name|LOCAL_NO_AUTH
operator||
name|LOCAL_AUTH
block|,
literal|"version string"
block|,
literal|"show version"
block|}
block|,
block|{
literal|"who"
block|,
name|NULL
block|,
name|log_ShowWho
block|,
name|LOCAL_AUTH
block|,
literal|"client list"
block|,
literal|"show who"
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_NO_AUTH
operator||
name|LOCAL_AUTH
block|,
literal|"Display this message"
block|,
literal|"show help|? [command]"
block|,
name|ShowCommands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|cmdtab
specifier|const
modifier|*
name|FindCommand
parameter_list|(
name|struct
name|cmdtab
specifier|const
modifier|*
name|cmds
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|pmatch
parameter_list|)
block|{
name|int
name|nmatch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|cmdtab
specifier|const
modifier|*
name|found
decl_stmt|;
name|found
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|nmatch
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cmds
operator|->
name|func
condition|)
block|{
if|if
condition|(
name|cmds
operator|->
name|name
operator|&&
name|strncasecmp
argument_list|(
name|str
argument_list|,
name|cmds
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cmds
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|pmatch
operator|=
literal|1
expr_stmt|;
return|return
name|cmds
return|;
block|}
name|nmatch
operator|++
expr_stmt|;
name|found
operator|=
name|cmds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmds
operator|->
name|alias
operator|&&
name|strncasecmp
argument_list|(
name|str
argument_list|,
name|cmds
operator|->
name|alias
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cmds
operator|->
name|alias
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|pmatch
operator|=
literal|1
expr_stmt|;
return|return
name|cmds
return|;
block|}
name|nmatch
operator|++
expr_stmt|;
name|found
operator|=
name|cmds
expr_stmt|;
block|}
name|cmds
operator|++
expr_stmt|;
block|}
operator|*
name|pmatch
operator|=
name|nmatch
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mkPrefix
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|char
modifier|*
name|tgt
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|int
name|f
decl_stmt|,
name|tlen
decl_stmt|,
name|len
decl_stmt|;
name|tlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|argc
operator|&&
name|tlen
operator|<
name|sz
operator|-
literal|2
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|f
condition|)
name|tgt
index|[
name|tlen
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|f
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|sz
operator|-
name|tlen
operator|-
literal|1
condition|)
name|len
operator|=
name|sz
operator|-
name|tlen
operator|-
literal|1
expr_stmt|;
name|strncpy
argument_list|(
name|tgt
operator|+
name|tlen
argument_list|,
name|argv
index|[
name|f
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tlen
operator|+=
name|len
expr_stmt|;
block|}
name|tgt
index|[
name|tlen
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|tgt
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|FindExec
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|cmdtab
specifier|const
modifier|*
name|cmds
parameter_list|,
name|int
name|argc
parameter_list|,
name|int
name|argn
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|struct
name|prompt
modifier|*
name|prompt
parameter_list|,
name|struct
name|datalink
modifier|*
name|cx
parameter_list|)
block|{
name|struct
name|cmdtab
specifier|const
modifier|*
name|cmd
decl_stmt|;
name|int
name|val
init|=
literal|1
decl_stmt|;
name|int
name|nmatch
decl_stmt|;
name|struct
name|cmdargs
name|arg
decl_stmt|;
name|char
name|prefix
index|[
literal|100
index|]
decl_stmt|;
name|cmd
operator|=
name|FindCommand
argument_list|(
name|cmds
argument_list|,
name|argv
index|[
name|argn
index|]
argument_list|,
operator|&
name|nmatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmatch
operator|>
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Ambiguous command\n"
argument_list|,
name|mkPrefix
argument_list|(
name|argn
operator|+
literal|1
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|&&
operator|(
operator|!
name|prompt
operator|||
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|prompt
operator|->
name|auth
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX
operator|)
operator|&&
operator|!
name|cx
condition|)
comment|/* We've got no context, but we require it */
name|cx
operator|=
name|bundle2datalink
argument_list|(
name|bundle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX
operator|)
operator|&&
operator|!
name|cx
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: No context (use the `link' command)\n"
argument_list|,
name|mkPrefix
argument_list|(
name|argn
operator|+
literal|1
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cx
operator|&&
operator|!
operator|(
name|cmd
operator|->
name|lauth
operator|&
operator|(
name|LOCAL_CX
operator||
name|LOCAL_CX_OPT
operator|)
operator|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Redundant context (%s) ignored\n"
argument_list|,
name|mkPrefix
argument_list|(
name|argn
operator|+
literal|1
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
name|prefix
argument_list|)
argument_list|,
name|cx
operator|->
name|name
argument_list|)
expr_stmt|;
name|cx
operator|=
name|NULL
expr_stmt|;
block|}
name|arg
operator|.
name|cmdtab
operator|=
name|cmds
expr_stmt|;
name|arg
operator|.
name|cmd
operator|=
name|cmd
expr_stmt|;
name|arg
operator|.
name|argc
operator|=
name|argc
expr_stmt|;
name|arg
operator|.
name|argn
operator|=
name|argn
operator|+
literal|1
expr_stmt|;
name|arg
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|arg
operator|.
name|bundle
operator|=
name|bundle
expr_stmt|;
name|arg
operator|.
name|cx
operator|=
name|cx
expr_stmt|;
name|arg
operator|.
name|prompt
operator|=
name|prompt
expr_stmt|;
name|val
operator|=
call|(
modifier|*
name|cmd
operator|->
name|func
call|)
argument_list|(
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Invalid command\n"
argument_list|,
name|mkPrefix
argument_list|(
name|argn
operator|+
literal|1
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Usage: %s\n"
argument_list|,
name|cmd
operator|->
name|syntax
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Failed %d\n"
argument_list|,
name|mkPrefix
argument_list|(
name|argn
operator|+
literal|1
argument_list|,
name|argv
argument_list|,
name|prefix
argument_list|,
sizeof|sizeof
name|prefix
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|command_Expand_Interpret
parameter_list|(
name|char
modifier|*
name|buff
parameter_list|,
name|int
name|nb
parameter_list|,
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|char
name|buff2
index|[
name|LINE_LEN
operator|-
name|offset
index|]
decl_stmt|;
name|InterpretArg
argument_list|(
name|buff
argument_list|,
name|buff2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buff
argument_list|,
name|buff2
argument_list|,
name|LINE_LEN
operator|-
name|offset
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buff
index|[
name|LINE_LEN
operator|-
name|offset
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|command_Interpret
argument_list|(
name|buff
argument_list|,
name|nb
argument_list|,
name|argv
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|command_Interpret
parameter_list|(
name|char
modifier|*
name|buff
parameter_list|,
name|int
name|nb
parameter_list|,
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|nb
operator|>
literal|0
condition|)
block|{
name|cp
operator|=
name|buff
operator|+
name|strcspn
argument_list|(
name|buff
argument_list|,
literal|"\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|MakeArgs
argument_list|(
name|buff
argument_list|,
name|argv
argument_list|,
name|MAXARGS
argument_list|,
name|PARSE_REDUCE
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arghidden
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* Is arg n of the given command to be hidden from the log ? */
comment|/* set authkey xxxxx */
comment|/* set key xxxxx */
if|if
condition|(
name|n
operator|==
literal|2
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"se"
argument_list|,
literal|2
argument_list|)
operator|&&
operator|(
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"authk"
argument_list|,
literal|5
argument_list|)
operator|||
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"ke"
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* passwd xxxxx */
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"p"
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* set server port xxxxx .... */
if|if
condition|(
name|n
operator|==
literal|3
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"se"
argument_list|,
literal|2
argument_list|)
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"se"
argument_list|,
literal|2
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|command_Run
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|argc
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|struct
name|prompt
modifier|*
name|prompt
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|struct
name|datalink
modifier|*
name|cx
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|log_IsKept
argument_list|(
name|LogCOMMAND
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
name|LINE_LEN
index|]
decl_stmt|;
name|int
name|f
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|label
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|label
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|3
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
name|buf
index|[
sizeof|sizeof
name|buf
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* In case we run out of room in buf */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|argc
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|n
operator|<
sizeof|sizeof
name|buf
operator|-
literal|1
operator|&&
name|f
condition|)
name|buf
index|[
name|n
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|arghidden
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|f
argument_list|)
condition|)
name|strncpy
argument_list|(
name|buf
operator|+
name|n
argument_list|,
literal|"********"
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|buf
operator|+
name|n
argument_list|,
name|argv
index|[
name|f
index|]
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
name|n
operator|+=
name|strlen
argument_list|(
name|buf
operator|+
name|n
argument_list|)
expr_stmt|;
block|}
name|log_Printf
argument_list|(
name|LogCOMMAND
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|FindExec
argument_list|(
name|bundle
argument_list|,
name|Commands
argument_list|,
name|argc
argument_list|,
literal|0
argument_list|,
name|argv
argument_list|,
name|prompt
argument_list|,
name|cx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|command_Decode
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|char
modifier|*
name|buff
parameter_list|,
name|int
name|nb
parameter_list|,
name|struct
name|prompt
modifier|*
name|prompt
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|=
name|command_Expand_Interpret
argument_list|(
name|buff
argument_list|,
name|nb
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|command_Run
argument_list|(
name|bundle
argument_list|,
name|argc
argument_list|,
operator|(
name|char
specifier|const
operator|*
specifier|const
operator|*
operator|)
name|argv
argument_list|,
name|prompt
argument_list|,
name|label
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ShowCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|prompt
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"show: Cannot show without a prompt\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|ShowCommands
argument_list|,
name|arg
operator|->
name|argc
argument_list|,
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Use ``show ?'' to get a list.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|TerminalCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|prompt
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"term: Need a prompt\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
operator|.
name|state
operator|>
name|ST_CLOSED
condition|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"LCP state is [%s]\n"
argument_list|,
name|State2Nam
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|datalink_Up
argument_list|(
name|arg
operator|->
name|cx
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prompt_TtyTermMode
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|QuitCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|prompt
operator|||
name|prompt_IsController
argument_list|(
name|arg
operator|->
name|prompt
argument_list|)
operator|||
operator|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"all"
argument_list|)
operator|&&
operator|(
name|arg
operator|->
name|prompt
operator|->
name|auth
operator|&
name|LOCAL_AUTH
operator|)
operator|)
condition|)
name|Cleanup
argument_list|(
name|EX_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|prompt_Destroy
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|OpenCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
name|bundle_Open
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
condition|?
name|arg
operator|->
name|cx
operator|->
name|name
else|:
name|NULL
argument_list|,
name|PHYS_ALL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"lcp"
argument_list|)
condition|)
block|{
name|struct
name|datalink
modifier|*
name|cx
init|=
name|arg
operator|->
name|cx
condition|?
name|arg
operator|->
name|cx
else|:
name|bundle2datalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|cx
condition|)
block|{
if|if
condition|(
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|ST_OPENED
condition|)
name|fsm_Reopen
argument_list|(
operator|&
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
else|else
name|bundle_Open
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|cx
operator|->
name|name
argument_list|,
name|PHYS_ALL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"open lcp: You must specify a link\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ccp"
argument_list|)
condition|)
block|{
name|struct
name|fsm
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
operator|&
name|command_ChooseLink
argument_list|(
name|arg
argument_list|)
operator|->
name|ccp
operator|.
name|fsm
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|link
operator|->
name|lcp
operator|.
name|fsm
operator|.
name|state
operator|!=
name|ST_OPENED
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"open: LCP must be open before opening CCP\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|state
operator|==
name|ST_OPENED
condition|)
name|fsm_Reopen
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|else
block|{
name|fp
operator|->
name|open_mode
operator|=
literal|0
expr_stmt|;
comment|/* Not passive any more */
if|if
condition|(
name|fp
operator|->
name|state
operator|==
name|ST_STOPPED
condition|)
block|{
name|fsm_Down
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fsm_Up
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fsm_Up
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fsm_Open
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ipcp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|cx
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"open ipcp: You need not specify a link\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|ST_OPENED
condition|)
name|fsm_Reopen
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
else|else
name|bundle_Open
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|NULL
argument_list|,
name|PHYS_ALL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|CloseCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
name|bundle_Close
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
condition|?
name|arg
operator|->
name|cx
operator|->
name|name
else|:
name|NULL
argument_list|,
name|CLOSE_STAYDOWN
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"lcp"
argument_list|)
condition|)
name|bundle_Close
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cx
condition|?
name|arg
operator|->
name|cx
operator|->
name|name
else|:
name|NULL
argument_list|,
name|CLOSE_LCP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ccp"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ccp!"
argument_list|)
condition|)
block|{
name|struct
name|fsm
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
operator|&
name|command_ChooseLink
argument_list|(
name|arg
argument_list|)
operator|->
name|ccp
operator|.
name|fsm
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|state
operator|==
name|ST_OPENED
condition|)
block|{
name|fsm_Close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
index|[
literal|3
index|]
operator|==
literal|'!'
condition|)
name|fp
operator|->
name|open_mode
operator|=
literal|0
expr_stmt|;
comment|/* Stay ST_CLOSED */
else|else
name|fp
operator|->
name|open_mode
operator|=
name|OPEN_PASSIVE
expr_stmt|;
comment|/* Wait for the peer to start */
block|}
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DownCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|cx
condition|)
name|datalink_Down
argument_list|(
name|arg
operator|->
name|cx
argument_list|,
name|CLOSE_STAYDOWN
argument_list|)
expr_stmt|;
else|else
name|bundle_Down
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|CLOSE_STAYDOWN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"lcp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|cx
condition|)
name|datalink_Down
argument_list|(
name|arg
operator|->
name|cx
argument_list|,
name|CLOSE_LCP
argument_list|)
expr_stmt|;
else|else
name|bundle_Down
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|CLOSE_LCP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ccp"
argument_list|)
condition|)
block|{
name|struct
name|fsm
modifier|*
name|fp
init|=
name|arg
operator|->
name|cx
condition|?
operator|&
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|ccp
operator|.
name|fsm
else|:
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|link
operator|.
name|ccp
operator|.
name|fsm
decl_stmt|;
name|fsm2initial
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetModemSpeed
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|long
name|speed
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|&&
operator|*
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"SetModemSpeed: Too many arguments\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"sync"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|physical_SetSync
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|end
operator|=
name|NULL
expr_stmt|;
name|speed
operator|=
name|strtol
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"SetModemSpeed: Bad argument \"%s\""
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|physical_SetSpeed
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
argument_list|,
name|speed
argument_list|)
condition|)
return|return
literal|0
return|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Invalid speed\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"SetModemSpeed: No speed specified\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetStoppedTimeout
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|link
modifier|*
name|l
init|=
operator|&
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
decl_stmt|;
name|l
operator|->
name|lcp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|=
literal|0
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|<=
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
name|l
operator|->
name|lcp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
operator|*
name|SECTICKS
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
name|l
operator|->
name|ccp
operator|.
name|fsm
operator|.
name|StoppedTimer
operator|.
name|load
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
operator|*
name|SECTICKS
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetServer
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|&&
name|arg
operator|->
name|argc
operator|<
name|arg
operator|->
name|argn
operator|+
literal|4
condition|)
block|{
specifier|const
name|char
modifier|*
name|port
decl_stmt|,
modifier|*
name|passwd
decl_stmt|,
modifier|*
name|mask
decl_stmt|;
name|int
name|mlen
decl_stmt|;
comment|/* What's what ? */
name|port
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
block|{
name|passwd
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
expr_stmt|;
name|mask
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|3
condition|)
block|{
name|passwd
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
expr_stmt|;
name|mask
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|2
index|]
expr_stmt|;
name|mlen
operator|=
name|strlen
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|==
literal|0
operator|||
name|mlen
operator|>
literal|4
operator|||
name|strspn
argument_list|(
name|mask
argument_list|,
literal|"01234567"
argument_list|)
operator|!=
name|mlen
operator|||
operator|(
name|mlen
operator|==
literal|4
operator|&&
operator|*
name|mask
operator|!=
literal|'0'
operator|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s %s: %s: Invalid mask\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|-
literal|2
index|]
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|-
literal|1
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|port
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|server_Close
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
condition|)
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Disabled server port.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
name|strncpy
argument_list|(
name|server
operator|.
name|passwd
argument_list|,
name|passwd
argument_list|,
sizeof|sizeof
name|server
operator|.
name|passwd
operator|-
literal|1
argument_list|)
expr_stmt|;
name|server
operator|.
name|passwd
index|[
sizeof|sizeof
name|server
operator|.
name|passwd
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|port
operator|==
literal|'/'
condition|)
block|{
name|mode_t
name|imask
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
name|name
index|[
name|LINE_LEN
operator|+
literal|12
index|]
decl_stmt|;
if|if
condition|(
name|mask
operator|==
name|NULL
condition|)
name|imask
operator|=
operator|(
name|mode_t
operator|)
operator|-
literal|1
expr_stmt|;
else|else
for|for
control|(
name|imask
operator|=
name|mlen
operator|=
literal|0
init|;
name|mask
index|[
name|mlen
index|]
condition|;
name|mlen
operator|++
control|)
name|imask
operator|=
operator|(
name|imask
operator|*
literal|8
operator|)
operator|+
name|mask
index|[
name|mlen
index|]
operator|-
literal|'0'
expr_stmt|;
name|ptr
operator|=
name|strstr
argument_list|(
name|port
argument_list|,
literal|"%d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|"%.*s%d%s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|port
argument_list|)
argument_list|,
name|port
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|unit
argument_list|,
name|ptr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|port
operator|=
name|name
expr_stmt|;
block|}
name|res
operator|=
name|server_LocalOpen
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|port
argument_list|,
name|imask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|iport
decl_stmt|,
name|add
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mask
operator|!=
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|port
operator|==
literal|'+'
condition|)
block|{
name|port
operator|++
expr_stmt|;
name|add
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strspn
argument_list|(
name|port
argument_list|,
literal|"0123456789"
argument_list|)
operator|!=
name|strlen
argument_list|(
name|port
argument_list|)
condition|)
block|{
name|struct
name|servent
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|getservbyname
argument_list|(
name|port
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|iport
operator|=
literal|0
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Invalid port or service\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
name|iport
operator|=
name|ntohs
argument_list|(
name|s
operator|->
name|s_port
argument_list|)
expr_stmt|;
block|}
else|else
name|iport
operator|=
name|atoi
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|iport
condition|)
block|{
if|if
condition|(
name|add
condition|)
name|iport
operator|+=
name|arg
operator|->
name|bundle
operator|->
name|unit
expr_stmt|;
name|res
operator|=
name|server_TcpOpen
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|iport
argument_list|)
expr_stmt|;
block|}
else|else
name|res
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetEscape
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
name|int
name|argc
init|=
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
decl_stmt|;
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|argv
init|=
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
decl_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|33
condition|;
name|code
operator|++
control|)
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
name|code
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
block|{
name|sscanf
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|code
argument_list|)
expr_stmt|;
name|code
operator|&=
literal|0xff
expr_stmt|;
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
name|code
operator|>>
literal|3
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|code
operator|&
literal|7
operator|)
operator|)
expr_stmt|;
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|async
operator|.
name|cfg
operator|.
name|EscMap
index|[
literal|32
index|]
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetInterfaceAddr
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ipcp
modifier|*
name|ipcp
init|=
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|hisaddr
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|4
condition|)
return|return
operator|-
literal|1
return|;
name|hisaddr
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ipcp
operator|->
name|cfg
operator|.
name|peer_range
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|ipcp
operator|->
name|cfg
operator|.
name|peer_range
argument_list|)
expr_stmt|;
name|ipcp
operator|->
name|cfg
operator|.
name|HaveTriggerAddress
operator|=
literal|0
expr_stmt|;
name|ipcp
operator|->
name|cfg
operator|.
name|netmask
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|iplist_reset
argument_list|(
operator|&
name|ipcp
operator|->
name|cfg
operator|.
name|peer_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
if|if
condition|(
operator|!
name|ParseAddr
argument_list|(
name|ipcp
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
operator|&
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|ipaddr
argument_list|,
operator|&
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|mask
argument_list|,
operator|&
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|width
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
name|hisaddr
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
block|{
name|ipcp
operator|->
name|ifmask
operator|=
name|ipcp
operator|->
name|cfg
operator|.
name|netmask
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|3
condition|)
block|{
name|ipcp
operator|->
name|cfg
operator|.
name|TriggerAddress
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|ipcp
operator|->
name|cfg
operator|.
name|HaveTriggerAddress
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 0.0.0.0 means any address (0 bits) */
if|if
condition|(
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|ipaddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|mask
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|width
operator|=
literal|0
expr_stmt|;
block|}
name|ipcp
operator|->
name|my_ip
operator|.
name|s_addr
operator|=
name|ipcp
operator|->
name|cfg
operator|.
name|my_range
operator|.
name|ipaddr
operator|.
name|s_addr
expr_stmt|;
name|bundle_AdjustFilters
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
operator|&
name|ipcp
operator|->
name|my_ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hisaddr
operator|&&
operator|!
name|ipcp_UseHisaddr
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|hisaddr
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|&
name|PHYS_AUTO
argument_list|)
condition|)
return|return
literal|4
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetRetry
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
specifier|const
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|,
name|u_int
modifier|*
name|timeout
parameter_list|,
name|u_int
modifier|*
name|maxreq
parameter_list|,
name|u_int
modifier|*
name|maxtrm
parameter_list|,
name|int
name|def
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
operator|*
name|timeout
operator|=
name|DEF_FSMRETRY
expr_stmt|;
operator|*
name|maxreq
operator|=
name|def
expr_stmt|;
if|if
condition|(
name|maxtrm
operator|!=
name|NULL
condition|)
operator|*
name|maxtrm
operator|=
name|def
expr_stmt|;
block|}
else|else
block|{
name|long
name|l
init|=
name|atol
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|l
operator|<
name|MIN_FSMRETRY
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Invalid FSM retry period - min %d\n"
argument_list|,
name|l
argument_list|,
name|MIN_FSMRETRY
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
operator|*
name|timeout
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|l
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Invalid FSM REQ tries - changed to 1\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|maxreq
operator|=
name|l
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
operator|&&
name|maxtrm
operator|!=
name|NULL
condition|)
block|{
name|l
operator|=
name|atol
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Invalid FSM TRM tries - changed to 1\n"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|maxtrm
operator|=
name|l
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetVariable
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|long
name|long_val
decl_stmt|,
name|param
init|=
operator|(
name|long
operator|)
name|arg
operator|->
name|cmd
operator|->
name|args
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|dummyint
decl_stmt|,
name|f
decl_stmt|,
name|first
decl_stmt|;
specifier|const
name|char
modifier|*
name|argp
decl_stmt|;
name|struct
name|datalink
modifier|*
name|cx
init|=
name|arg
operator|->
name|cx
decl_stmt|;
comment|/* LOCAL_CX uses this */
specifier|const
name|char
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
name|struct
name|link
modifier|*
name|l
init|=
name|command_ChooseLink
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* LOCAL_CX_OPT uses this */
name|struct
name|in_addr
name|dummyaddr
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
name|argp
operator|=
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
expr_stmt|;
else|else
name|argp
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|arg
operator|->
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX
operator|)
operator|&&
operator|!
name|cx
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"set %s: No context (use the `link' command)\n"
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|cx
operator|&&
operator|!
operator|(
name|arg
operator|->
name|cmd
operator|->
name|lauth
operator|&
operator|(
name|LOCAL_CX
operator||
name|LOCAL_CX_OPT
operator|)
operator|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"set %s: Redundant context (%s) ignored\n"
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|name
argument_list|,
name|cx
operator|->
name|name
argument_list|)
expr_stmt|;
name|cx
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|VAR_AUTHKEY
case|:
name|strncpy
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|key
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|key
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|key
index|[
sizeof|sizeof
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|key
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|VAR_AUTHNAME
case|:
switch|switch
condition|(
name|bundle_Phase
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
condition|)
block|{
case|case
name|PHASE_DEAD
case|:
case|case
name|PHASE_ESTABLISH
case|:
name|strncpy
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
index|[
sizeof|sizeof
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|err
operator|=
literal|"set authname: Only available at phase DEAD/ESTABLISH\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|VAR_AUTOLOAD
case|:
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|3
condition|)
block|{
name|int
name|v1
decl_stmt|,
name|v2
decl_stmt|,
name|v3
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|v1
operator|=
name|strtol
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v1
operator|<
literal|0
operator|||
operator|*
name|end
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"autoload: %s: Invalid min percentage\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|v2
operator|=
name|strtol
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2
operator|<
literal|0
operator|||
operator|*
name|end
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"autoload: %s: Invalid max percentage\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|v2
operator|<
name|v1
condition|)
block|{
name|v3
operator|=
name|v1
expr_stmt|;
name|v1
operator|=
name|v2
expr_stmt|;
name|v2
operator|=
name|v3
expr_stmt|;
block|}
name|v3
operator|=
name|strtol
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|2
index|]
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v3
operator|<=
literal|0
operator|||
operator|*
name|end
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"autoload: %s: Invalid throughput period\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|=
name|v1
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|=
name|v2
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|autoload
operator|.
name|period
operator|=
name|v3
expr_stmt|;
name|mp_RestartAutoloadTimer
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|"Set autoload requires three arguments\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_DIAL
case|:
name|strncpy
argument_list|(
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|dial
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|dial
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|dial
index|[
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|dial
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|VAR_LOGIN
case|:
name|strncpy
argument_list|(
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|login
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|login
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|login
index|[
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|login
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|VAR_WINSIZE
case|:
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|out
operator|.
name|winsize
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|out
operator|.
name|winsize
operator|<
literal|8
operator|||
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|out
operator|.
name|winsize
operator|>
literal|15
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%d: Invalid outgoing window size\n"
argument_list|,
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|out
operator|.
name|winsize
argument_list|)
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|out
operator|.
name|winsize
operator|=
literal|15
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
operator|<
literal|8
operator|||
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
operator|>
literal|15
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%d: Invalid incoming window size\n"
argument_list|,
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
argument_list|)
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
operator|=
literal|15
expr_stmt|;
block|}
block|}
else|else
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|deflate
operator|.
name|in
operator|.
name|winsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|"No window size specified\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_DEVICE
case|:
name|physical_SetDeviceList
argument_list|(
name|cx
operator|->
name|physical
argument_list|,
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_ACCMAP
case|:
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
name|u_long
name|ulong_val
decl_stmt|;
name|sscanf
argument_list|(
name|argp
argument_list|,
literal|"%lx"
argument_list|,
operator|&
name|ulong_val
argument_list|)
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|accmap
operator|=
operator|(
name|u_int32_t
operator|)
name|ulong_val
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
literal|"No accmap specified\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_MODE
case|:
name|mode
operator|=
name|Nam2mode
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|PHYS_NONE
operator|||
name|mode
operator|==
name|PHYS_ALL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Invalid mode\n"
argument_list|,
name|argp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|bundle_SetMode
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|cx
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_MRRU
case|:
switch|switch
condition|(
name|bundle_Phase
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
condition|)
block|{
case|case
name|PHASE_DEAD
case|:
break|break;
case|case
name|PHASE_ESTABLISH
case|:
comment|/* Make sure none of our links are DATALINK_LCP or greater */
if|if
condition|(
name|bundle_HighestState
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
operator|>=
name|DATALINK_LCP
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"mrru: Only changable before LCP negotiations\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
default|default:
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"mrru: Only changable at phase DEAD/ESTABLISH\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|&&
name|long_val
operator|<
name|MIN_MRU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MRRU %ld: too small - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_MRU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|long_val
operator|>
name|MAX_MRU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MRRU %ld: too big - max %d\n"
argument_list|,
name|long_val
argument_list|,
name|MAX_MRU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|mrru
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_MRU
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|==
literal|0
condition|)
name|l
operator|->
name|lcp
operator|.
name|cfg
operator|.
name|mru
operator|=
name|DEF_MRU
expr_stmt|;
elseif|else
if|if
condition|(
name|long_val
operator|<
name|MIN_MRU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MRU %ld: too small - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_MRU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|long_val
operator|>
name|MAX_MRU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MRU %ld: too big - max %d\n"
argument_list|,
name|long_val
argument_list|,
name|MAX_MRU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|l
operator|->
name|lcp
operator|.
name|cfg
operator|.
name|mru
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_MTU
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|&&
name|long_val
operator|<
name|MIN_MTU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MTU %ld: too small - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_MTU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|long_val
operator|>
name|MAX_MTU
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MTU %ld: too big - max %d\n"
argument_list|,
name|long_val
argument_list|,
name|MAX_MTU
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|mtu
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_OPENMODE
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|argp
argument_list|,
literal|"active"
argument_list|)
operator|==
literal|0
condition|)
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|openmode
operator|=
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|?
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
else|:
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|argp
argument_list|,
literal|"passive"
argument_list|)
operator|==
literal|0
condition|)
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|openmode
operator|=
name|OPEN_PASSIVE
expr_stmt|;
else|else
block|{
name|err
operator|=
literal|"%s: Invalid openmode\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|,
name|argp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_PHONE
case|:
name|strncpy
argument_list|(
name|cx
operator|->
name|cfg
operator|.
name|phone
operator|.
name|list
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|phone
operator|.
name|list
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|phone
operator|.
name|list
index|[
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|phone
operator|.
name|list
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cx
operator|->
name|phone
operator|.
name|alt
operator|=
name|cx
operator|->
name|phone
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|VAR_HANGUP
case|:
name|strncpy
argument_list|(
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|hangup
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|hangup
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|hangup
index|[
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|hangup
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|VAR_LOGOUT
case|:
name|strncpy
argument_list|(
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|logout
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|logout
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|logout
index|[
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|script
operator|.
name|logout
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|VAR_IDLETIMEOUT
case|:
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
name|err
operator|=
literal|"Too many idle timeout values\n"
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
name|err
operator|=
literal|"Too few idle timeout values\n"
expr_stmt|;
else|else
block|{
name|int
name|timeout
decl_stmt|,
name|min
decl_stmt|;
name|timeout
operator|=
name|atoi
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|min
operator|=
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|2
condition|?
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
name|bundle_SetIdleTimer
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|timeout
argument_list|,
name|min
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
case|case
name|VAR_LQRPERIOD
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|<
name|MIN_LQRPERIOD
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Invalid lqr period - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_LQRPERIOD
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|l
operator|->
name|lcp
operator|.
name|cfg
operator|.
name|lqrperiod
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_LCPRETRY
case|:
return|return
name|SetRetry
argument_list|(
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|,
operator|&
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|timeout
argument_list|,
operator|&
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|maxreq
argument_list|,
operator|&
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|maxtrm
argument_list|,
name|DEF_FSMTRIES
argument_list|)
return|;
break|break;
case|case
name|VAR_CHAPRETRY
case|:
return|return
name|SetRetry
argument_list|(
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|,
operator|&
name|cx
operator|->
name|chap
operator|.
name|auth
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|timeout
argument_list|,
operator|&
name|cx
operator|->
name|chap
operator|.
name|auth
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|maxreq
argument_list|,
name|NULL
argument_list|,
name|DEF_FSMAUTHTRIES
argument_list|)
return|;
break|break;
case|case
name|VAR_PAPRETRY
case|:
return|return
name|SetRetry
argument_list|(
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|,
operator|&
name|cx
operator|->
name|pap
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|timeout
argument_list|,
operator|&
name|cx
operator|->
name|pap
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|maxreq
argument_list|,
name|NULL
argument_list|,
name|DEF_FSMAUTHTRIES
argument_list|)
return|;
break|break;
case|case
name|VAR_CCPRETRY
case|:
return|return
name|SetRetry
argument_list|(
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|,
operator|&
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|timeout
argument_list|,
operator|&
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|maxreq
argument_list|,
operator|&
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|maxtrm
argument_list|,
name|DEF_FSMTRIES
argument_list|)
return|;
break|break;
case|case
name|VAR_IPCPRETRY
case|:
return|return
name|SetRetry
argument_list|(
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|,
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|timeout
argument_list|,
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|maxreq
argument_list|,
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|fsm
operator|.
name|maxtrm
argument_list|,
name|DEF_FSMTRIES
argument_list|)
return|;
break|break;
case|case
name|VAR_NBNS
case|:
case|case
name|VAR_DNS
case|:
if|if
condition|(
name|param
operator|==
name|VAR_DNS
condition|)
block|{
name|addr
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|ns
operator|.
name|dns
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|.
name|s_addr
operator|=
name|addr
index|[
literal|1
index|]
operator|.
name|s_addr
operator|=
name|INADDR_NONE
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|ns
operator|.
name|nbns
expr_stmt|;
name|addr
index|[
literal|0
index|]
operator|.
name|s_addr
operator|=
name|addr
index|[
literal|1
index|]
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
name|ParseAddr
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
name|addr
argument_list|,
operator|&
name|dummyaddr
argument_list|,
operator|&
name|dummyint
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
name|ParseAddr
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|,
name|addr
operator|+
literal|1
argument_list|,
operator|&
name|dummyaddr
argument_list|,
operator|&
name|dummyint
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
index|[
literal|0
index|]
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|addr
index|[
literal|0
index|]
operator|.
name|s_addr
operator|=
name|addr
index|[
literal|1
index|]
operator|.
name|s_addr
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
if|if
condition|(
name|addr
index|[
literal|0
index|]
operator|.
name|s_addr
operator|==
name|INADDR_NONE
condition|)
block|{
name|addr
index|[
literal|0
index|]
operator|.
name|s_addr
operator|=
name|addr
index|[
literal|1
index|]
operator|.
name|s_addr
expr_stmt|;
name|addr
index|[
literal|1
index|]
operator|.
name|s_addr
operator|=
name|INADDR_NONE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|VAR_CALLBACK
case|:
name|cx
operator|->
name|cfg
operator|.
name|callback
operator|.
name|opmask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dummyint
operator|=
name|arg
operator|->
name|argn
init|;
name|dummyint
operator|<
name|arg
operator|->
name|argc
condition|;
name|dummyint
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|dummyint
index|]
argument_list|,
literal|"auth"
argument_list|)
condition|)
name|cx
operator|->
name|cfg
operator|.
name|callback
operator|.
name|opmask
operator||=
name|CALLBACK_BIT
argument_list|(
name|CALLBACK_AUTH
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|dummyint
index|]
argument_list|,
literal|"cbcp"
argument_list|)
condition|)
name|cx
operator|->
name|cfg
operator|.
name|callback
operator|.
name|opmask
operator||=
name|CALLBACK_BIT
argument_list|(
name|CALLBACK_CBCP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|dummyint
index|]
argument_list|,
literal|"e.164"
argument_list|)
condition|)
block|{
if|if
condition|(
name|dummyint
operator|==
name|arg
operator|->
name|argc
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"No E.164 arg (E.164 ignored) !\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|cx
operator|->
name|cfg
operator|.
name|callback
operator|.
name|opmask
operator||=
name|CALLBACK_BIT
argument_list|(
name|CALLBACK_E164
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cx
operator|->
name|cfg
operator|.
name|callback
operator|.
name|msg
argument_list|,
name|arg
operator|->
name|argv
index|[
operator|++
name|dummyint
index|]
argument_list|,
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|callback
operator|.
name|msg
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|callback
operator|.
name|msg
index|[
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|callback
operator|.
name|msg
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|dummyint
index|]
argument_list|,
literal|"none"
argument_list|)
condition|)
name|cx
operator|->
name|cfg
operator|.
name|callback
operator|.
name|opmask
operator||=
name|CALLBACK_BIT
argument_list|(
name|CALLBACK_NONE
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|cx
operator|->
name|cfg
operator|.
name|callback
operator|.
name|opmask
operator|==
name|CALLBACK_BIT
argument_list|(
name|CALLBACK_NONE
argument_list|)
condition|)
name|cx
operator|->
name|cfg
operator|.
name|callback
operator|.
name|opmask
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VAR_CBCP
case|:
name|cx
operator|->
name|cfg
operator|.
name|cbcp
operator|.
name|delay
operator|=
literal|0
expr_stmt|;
operator|*
name|cx
operator|->
name|cfg
operator|.
name|cbcp
operator|.
name|phone
operator|=
literal|'\0'
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|cbcp
operator|.
name|fsmretry
operator|=
name|DEF_FSMRETRY
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
name|strncpy
argument_list|(
name|cx
operator|->
name|cfg
operator|.
name|cbcp
operator|.
name|phone
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|cbcp
operator|.
name|phone
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cx
operator|->
name|cfg
operator|.
name|cbcp
operator|.
name|phone
index|[
sizeof|sizeof
name|cx
operator|->
name|cfg
operator|.
name|cbcp
operator|.
name|phone
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
name|cx
operator|->
name|cfg
operator|.
name|cbcp
operator|.
name|delay
operator|=
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
block|{
name|long_val
operator|=
name|atol
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|<
name|MIN_FSMRETRY
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%ld: Invalid CBCP FSM retry period - min %d\n"
argument_list|,
name|long_val
argument_list|,
name|MIN_FSMRETRY
argument_list|)
expr_stmt|;
else|else
name|cx
operator|->
name|cfg
operator|.
name|cbcp
operator|.
name|fsmretry
operator|=
name|long_val
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|VAR_CHOKED
case|:
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|choked
operator|.
name|timeout
operator|=
name|atoi
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|choked
operator|.
name|timeout
operator|<=
literal|0
condition|)
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|choked
operator|.
name|timeout
operator|=
name|CHOKED_TIMEOUT
expr_stmt|;
break|break;
case|case
name|VAR_SENDPIPE
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|sendpipe
operator|=
name|long_val
expr_stmt|;
break|break;
case|case
name|VAR_RECVPIPE
case|:
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|recvpipe
operator|=
name|long_val
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NORADIUS
case|case
name|VAR_RADIUS
case|:
if|if
condition|(
operator|!
operator|*
name|argp
condition|)
operator|*
name|arg
operator|->
name|bundle
operator|->
name|radius
operator|.
name|cfg
operator|.
name|file
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|access
argument_list|(
name|argp
argument_list|,
name|R_OK
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|argp
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|radius
operator|.
name|cfg
operator|.
name|file
argument_list|,
name|argp
argument_list|,
sizeof|sizeof
name|arg
operator|->
name|bundle
operator|->
name|radius
operator|.
name|cfg
operator|.
name|file
operator|-
literal|1
argument_list|)
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|radius
operator|.
name|cfg
operator|.
name|file
index|[
sizeof|sizeof
name|arg
operator|->
name|bundle
operator|->
name|radius
operator|.
name|cfg
operator|.
name|file
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|VAR_CD
case|:
if|if
condition|(
operator|*
name|argp
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|argp
argument_list|,
literal|"off"
argument_list|)
condition|)
block|{
name|long_val
operator|=
name|atol
argument_list|(
name|argp
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_val
operator|<
literal|0
condition|)
name|long_val
operator|=
literal|0
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|cfg
operator|.
name|cd
operator|.
name|delay
operator|=
name|long_val
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|cfg
operator|.
name|cd
operator|.
name|necessity
operator|=
name|argp
index|[
name|strlen
argument_list|(
name|argp
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'!'
condition|?
name|CD_REQUIRED
else|:
name|CD_VARIABLE
expr_stmt|;
block|}
else|else
name|cx
operator|->
name|physical
operator|->
name|cfg
operator|.
name|cd
operator|.
name|necessity
operator|=
name|CD_NOTREQUIRED
expr_stmt|;
block|}
else|else
block|{
name|cx
operator|->
name|physical
operator|->
name|cfg
operator|.
name|cd
operator|.
name|delay
operator|=
literal|0
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|cfg
operator|.
name|cd
operator|.
name|necessity
operator|=
name|CD_DEFAULT
expr_stmt|;
block|}
break|break;
case|case
name|VAR_PARITY
case|:
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
return|return
name|physical_SetParity
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
argument_list|,
name|argp
argument_list|)
return|;
else|else
block|{
name|err
operator|=
literal|"Parity value must be odd, even or none\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_CRTSCTS
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|argp
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|physical_SetRtsCts
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|argp
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|physical_SetRtsCts
argument_list|(
name|arg
operator|->
name|cx
operator|->
name|physical
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|err
operator|=
literal|"RTS/CTS value must be on or off\n"
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|VAR_URGENTPORTS
case|:
if|if
condition|(
name|arg
operator|->
name|argn
operator|==
name|arg
operator|->
name|argc
condition|)
block|{
name|ipcp_ClearUrgentTcpPorts
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
name|ipcp_ClearUrgentUdpPorts
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"udp"
argument_list|)
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|argn
operator|==
name|arg
operator|->
name|argc
operator|-
literal|1
condition|)
name|ipcp_ClearUrgentUdpPorts
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|f
operator|=
name|arg
operator|->
name|argn
operator|+
literal|1
init|;
name|f
operator|<
name|arg
operator|->
name|argc
condition|;
name|f
operator|++
control|)
if|if
condition|(
operator|*
name|arg
operator|->
name|argv
index|[
name|f
index|]
operator|==
literal|'+'
condition|)
name|ipcp_AddUrgentUdpPort
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|f
index|]
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|arg
operator|->
name|argv
index|[
name|f
index|]
operator|==
literal|'-'
condition|)
name|ipcp_RemoveUrgentUdpPort
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|f
index|]
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|f
operator|==
name|arg
operator|->
name|argn
condition|)
name|ipcp_ClearUrgentUdpPorts
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
name|ipcp_AddUrgentUdpPort
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|f
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|first
operator|=
name|arg
operator|->
name|argn
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|first
index|]
argument_list|,
literal|"tcp"
argument_list|)
operator|&&
operator|++
name|first
operator|==
name|arg
operator|->
name|argc
condition|)
name|ipcp_ClearUrgentTcpPorts
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|first
init|;
name|f
operator|<
name|arg
operator|->
name|argc
condition|;
name|f
operator|++
control|)
if|if
condition|(
operator|*
name|arg
operator|->
name|argv
index|[
name|f
index|]
operator|==
literal|'+'
condition|)
name|ipcp_AddUrgentTcpPort
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|f
index|]
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|arg
operator|->
name|argv
index|[
name|f
index|]
operator|==
literal|'-'
condition|)
name|ipcp_RemoveUrgentTcpPort
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|f
index|]
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|f
operator|==
name|first
condition|)
name|ipcp_ClearUrgentTcpPorts
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
name|ipcp_AddUrgentTcpPort
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
name|atoi
argument_list|(
name|arg
operator|->
name|argv
index|[
name|f
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
return|return
name|err
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|SetCommands
index|[]
init|=
block|{
block|{
literal|"accmap"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"accmap value"
block|,
literal|"set accmap hex-value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_ACCMAP
block|}
block|,
block|{
literal|"authkey"
block|,
literal|"key"
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"authentication key"
block|,
literal|"set authkey|key key"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_AUTHKEY
block|}
block|,
block|{
literal|"authname"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"authentication name"
block|,
literal|"set authname name"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_AUTHNAME
block|}
block|,
block|{
literal|"autoload"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"auto link [de]activation"
block|,
literal|"set autoload maxtime maxload mintime minload"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_AUTOLOAD
block|}
block|,
block|{
literal|"bandwidth"
block|,
name|NULL
block|,
name|mp_SetDatalinkBandwidth
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"datalink bandwidth"
block|,
literal|"set bandwidth value"
block|}
block|,
block|{
literal|"callback"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"callback control"
block|,
literal|"set callback [none|auth|cbcp|"
literal|"E.164 *|number[,number]...]..."
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_CALLBACK
block|}
block|,
block|{
literal|"cbcp"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"CBCP control"
block|,
literal|"set cbcp [*|phone[,phone...] [delay [timeout]]]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_CBCP
block|}
block|,
block|{
literal|"ccpretry"
block|,
literal|"ccpretries"
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"CCP retries"
block|,
literal|"set ccpretry value [attempts]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_CCPRETRY
block|}
block|,
block|{
literal|"cd"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Carrier delay requirement"
block|,
literal|"set cd value[!]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_CD
block|}
block|,
block|{
literal|"chapretry"
block|,
literal|"chapretries"
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"CHAP retries"
block|,
literal|"set chapretry value [attempts]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_CHAPRETRY
block|}
block|,
block|{
literal|"choked"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"choked timeout"
block|,
literal|"set choked [secs]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_CHOKED
block|}
block|,
block|{
literal|"ctsrts"
block|,
literal|"crtscts"
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Use hardware flow control"
block|,
literal|"set ctsrts [on|off]"
block|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|VAR_CRTSCTS
block|}
block|,
block|{
literal|"deflate"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"deflate window sizes"
block|,
literal|"set deflate out-winsize in-winsize"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_WINSIZE
block|}
block|,
block|{
literal|"device"
block|,
literal|"line"
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"physical device name"
block|,
literal|"set device|line device-name[,device-name]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_DEVICE
block|}
block|,
block|{
literal|"dial"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"dialing script"
block|,
literal|"set dial chat-script"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_DIAL
block|}
block|,
block|{
literal|"dns"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"Domain Name Server"
block|,
literal|"set dns pri-addr [sec-addr]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_DNS
block|}
block|,
block|{
literal|"enddisc"
block|,
name|NULL
block|,
name|mp_SetEnddisc
block|,
name|LOCAL_AUTH
block|,
literal|"Endpoint Discriminator"
block|,
literal|"set enddisc [IP|magic|label|psn value]"
block|}
block|,
block|{
literal|"escape"
block|,
name|NULL
block|,
name|SetEscape
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"escape characters"
block|,
literal|"set escape hex-digit ..."
block|}
block|,
block|{
literal|"filter"
block|,
name|NULL
block|,
name|filter_Set
block|,
name|LOCAL_AUTH
block|,
literal|"packet filters"
block|,
literal|"set filter alive|dial|in|out rule-no permit|deny "
literal|"[src_addr[/width]] [dst_addr[/width]] [tcp|udp|icmp|ospf|igmp "
literal|"[src [lt|eq|gt port]] [dst [lt|eq|gt port]] [estab] [syn] [finrst]]"
block|}
block|,
block|{
literal|"hangup"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"hangup script"
block|,
literal|"set hangup chat-script"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_HANGUP
block|}
block|,
block|{
literal|"ifaddr"
block|,
name|NULL
block|,
name|SetInterfaceAddr
block|,
name|LOCAL_AUTH
block|,
literal|"destination address"
block|,
literal|"set ifaddr [src-addr [dst-addr [netmask [trg-addr]]]]"
block|}
block|,
block|{
literal|"ipcpretry"
block|,
literal|"ipcpretries"
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"IPCP retries"
block|,
literal|"set ipcpretry value [attempts]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_IPCPRETRY
block|}
block|,
block|{
literal|"lcpretry"
block|,
literal|"lcpretries"
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"LCP retries"
block|,
literal|"set lcpretry value [attempts]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_LCPRETRY
block|}
block|,
block|{
literal|"log"
block|,
name|NULL
block|,
name|log_SetLevel
block|,
name|LOCAL_AUTH
block|,
literal|"log level"
block|,
literal|"set log [local] [+|-]async|cbcp|ccp|chat|command|connect|debug|dns|hdlc|"
literal|"id0|ipcp|lcp|lqm|phase|physical|sync|tcp/ip|timer|tun..."
block|}
block|,
block|{
literal|"login"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"login script"
block|,
literal|"set login chat-script"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_LOGIN
block|}
block|,
block|{
literal|"logout"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"logout script"
block|,
literal|"set logout chat-script"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_LOGOUT
block|}
block|,
block|{
literal|"lqrperiod"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"LQR period"
block|,
literal|"set lqrperiod value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_LQRPERIOD
block|}
block|,
block|{
literal|"mode"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"mode value"
block|,
literal|"set mode interactive|auto|ddial|background"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_MODE
block|}
block|,
block|{
literal|"mrru"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"MRRU value"
block|,
literal|"set mrru value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_MRRU
block|}
block|,
block|{
literal|"mru"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"MRU value"
block|,
literal|"set mru value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_MRU
block|}
block|,
block|{
literal|"mtu"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"interface MTU value"
block|,
literal|"set mtu value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_MTU
block|}
block|,
block|{
literal|"nbns"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"NetBIOS Name Server"
block|,
literal|"set nbns pri-addr [sec-addr]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_NBNS
block|}
block|,
block|{
literal|"openmode"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"open mode"
block|,
literal|"set openmode active|passive [secs]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_OPENMODE
block|}
block|,
block|{
literal|"papretry"
block|,
literal|"papretries"
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"PAP retries"
block|,
literal|"set papretry value [attempts]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_PAPRETRY
block|}
block|,
block|{
literal|"parity"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"serial parity"
block|,
literal|"set parity [odd|even|none]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_PARITY
block|}
block|,
block|{
literal|"phone"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"telephone number(s)"
block|,
literal|"set phone phone1[:phone2[...]]"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_PHONE
block|}
block|,
block|{
literal|"proctitle"
block|,
literal|"title"
block|,
name|SetProcTitle
block|,
name|LOCAL_AUTH
block|,
literal|"Process title"
block|,
literal|"set proctitle [value]"
block|}
block|,
ifndef|#
directive|ifndef
name|NORADIUS
block|{
literal|"radius"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"RADIUS Config"
block|,
literal|"set radius cfgfile"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_RADIUS
block|}
block|,
endif|#
directive|endif
block|{
literal|"reconnect"
block|,
name|NULL
block|,
name|datalink_SetReconnect
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Reconnect timeout"
block|,
literal|"set reconnect value ntries"
block|}
block|,
block|{
literal|"recvpipe"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"RECVPIPE value"
block|,
literal|"set recvpipe value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_RECVPIPE
block|}
block|,
block|{
literal|"redial"
block|,
name|NULL
block|,
name|datalink_SetRedial
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Redial timeout"
block|,
literal|"set redial secs[+inc[-incmax]][.next] [attempts]"
block|}
block|,
block|{
literal|"sendpipe"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"SENDPIPE value"
block|,
literal|"set sendpipe value"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_SENDPIPE
block|}
block|,
block|{
literal|"server"
block|,
literal|"socket"
block|,
name|SetServer
block|,
name|LOCAL_AUTH
block|,
literal|"server port"
block|,
literal|"set server|socket TcpPort|LocalName|none password [mask]"
block|}
block|,
block|{
literal|"speed"
block|,
name|NULL
block|,
name|SetModemSpeed
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"physical speed"
block|,
literal|"set speed value|sync"
block|}
block|,
block|{
literal|"stopped"
block|,
name|NULL
block|,
name|SetStoppedTimeout
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"STOPPED timeouts"
block|,
literal|"set stopped [LCPseconds [CCPseconds]]"
block|}
block|,
block|{
literal|"timeout"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"Idle timeout"
block|,
literal|"set timeout idletime"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_IDLETIMEOUT
block|}
block|,
block|{
literal|"urgent"
block|,
name|NULL
block|,
name|SetVariable
block|,
name|LOCAL_AUTH
block|,
literal|"urgent ports"
block|,
literal|"set urgent [tcp|udp] [+|-]port..."
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|VAR_URGENTPORTS
block|}
block|,
block|{
literal|"vj"
block|,
name|NULL
block|,
name|ipcp_vjset
block|,
name|LOCAL_AUTH
block|,
literal|"vj values"
block|,
literal|"set vj slots|slotcomp [value]"
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Display this message"
block|,
literal|"set help|? [command]"
block|,
name|SetCommands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|SetCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|SetCommands
argument_list|,
name|arg
operator|->
name|argc
argument_list|,
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Use `set ?' to get a list or `set ?<var>' for"
literal|" syntax help.\n"
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"set command must have arguments\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|AddCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|in_addr
name|dest
decl_stmt|,
name|gateway
decl_stmt|,
name|netmask
decl_stmt|;
name|int
name|gw
decl_stmt|,
name|addrs
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|!=
name|arg
operator|->
name|argn
operator|+
literal|3
operator|&&
name|arg
operator|->
name|argc
operator|!=
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
return|return
operator|-
literal|1
return|;
name|addrs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"default"
argument_list|)
condition|)
name|dest
operator|.
name|s_addr
operator|=
name|netmask
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
else|else
block|{
name|int
name|width
decl_stmt|;
if|if
condition|(
operator|!
name|ParseAddr
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
operator|&
name|dest
argument_list|,
operator|&
name|netmask
argument_list|,
operator|&
name|width
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"MYADDR"
argument_list|,
literal|6
argument_list|)
condition|)
name|addrs
operator|=
name|ROUTE_DSTMYADDR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"HISADDR"
argument_list|,
literal|7
argument_list|)
condition|)
name|addrs
operator|=
name|ROUTE_DSTHISADDR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"DNS0"
argument_list|,
literal|4
argument_list|)
condition|)
name|addrs
operator|=
name|ROUTE_DSTDNS0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"DNS1"
argument_list|,
literal|4
argument_list|)
condition|)
name|addrs
operator|=
name|ROUTE_DSTDNS1
expr_stmt|;
block|}
name|gw
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"MYADDR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addrs
operator|=
name|ROUTE_DSTMYADDR
expr_stmt|;
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|my_ip
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"HISADDR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addrs
operator|=
name|ROUTE_DSTHISADDR
expr_stmt|;
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|peer_ip
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"DNS0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addrs
operator|=
name|ROUTE_DSTDNS0
expr_stmt|;
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|ns
operator|.
name|dns
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"DNS1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|addrs
operator|=
name|ROUTE_DSTDNS1
expr_stmt|;
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|ns
operator|.
name|dns
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
name|dest
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
name|netmask
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|gw
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
name|gw
index|]
argument_list|,
literal|"HISADDR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gateway
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|peer_ip
expr_stmt|;
name|addrs
operator||=
name|ROUTE_GWHISADDR
expr_stmt|;
block|}
else|else
name|gateway
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
name|gw
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle_SetRoute
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|RTM_ADD
argument_list|,
name|dest
argument_list|,
name|gateway
argument_list|,
name|netmask
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|args
condition|?
literal|1
else|:
literal|0
argument_list|,
operator|(
name|addrs
operator|&
name|ROUTE_GWHISADDR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
operator|&&
name|addrs
operator|!=
name|ROUTE_STATIC
condition|)
name|route_Add
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|route
argument_list|,
name|addrs
argument_list|,
name|dest
argument_list|,
name|netmask
argument_list|,
name|gateway
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|DeleteCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|in_addr
name|dest
decl_stmt|,
name|none
decl_stmt|;
name|int
name|addrs
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|route_IfDelete
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|route_DeleteAll
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|route
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addrs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"MYADDR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|my_ip
expr_stmt|;
name|addrs
operator|=
name|ROUTE_DSTMYADDR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"HISADDR"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|peer_ip
expr_stmt|;
name|addrs
operator|=
name|ROUTE_DSTHISADDR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"DNS0"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|ns
operator|.
name|dns
index|[
literal|0
index|]
expr_stmt|;
name|addrs
operator|=
name|ROUTE_DSTDNS0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"DNS1"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dest
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|ns
operator|.
name|dns
index|[
literal|1
index|]
expr_stmt|;
name|addrs
operator|=
name|ROUTE_DSTDNS1
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|=
name|GetIpAddr
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|.
name|s_addr
operator|==
name|INADDR_NONE
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Invalid IP address\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|addrs
operator|=
name|ROUTE_STATIC
expr_stmt|;
block|}
name|none
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|bundle_SetRoute
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|RTM_DELETE
argument_list|,
name|dest
argument_list|,
name|none
argument_list|,
name|none
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|args
condition|?
literal|1
else|:
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|route_Delete
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|route
argument_list|,
name|addrs
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NONAT
end_ifndef

begin_function
specifier|static
name|int
name|AliasEnable
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arg
operator|->
name|bundle
operator|->
name|NatEnabled
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|ST_OPENED
condition|)
name|PacketAliasSetAddress
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|my_ip
argument_list|)
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|NatEnabled
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arg
operator|->
name|bundle
operator|->
name|NatEnabled
operator|=
literal|0
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|opt
operator|&=
operator|~
name|OPT_IFACEALIAS
expr_stmt|;
comment|/* Don't iface_Clear() - there may be manually configured addresses */
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|AliasOption
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|long
name|param
init|=
operator|(
name|long
operator|)
name|arg
operator|->
name|cmd
operator|->
name|args
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|NatEnabled
condition|)
block|{
name|PacketAliasSetMode
argument_list|(
name|param
argument_list|,
name|param
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"nat not enabled\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|NatEnabled
condition|)
block|{
name|PacketAliasSetMode
argument_list|(
literal|0
argument_list|,
name|param
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"nat not enabled\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifndef NONAT */
end_comment

begin_function
specifier|static
name|int
name|LinkCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
name|char
name|namelist
index|[
name|LINE_LEN
index|]
decl_stmt|;
name|struct
name|datalink
modifier|*
name|cx
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"*"
argument_list|)
condition|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|cx
operator|=
name|arg
operator|->
name|bundle
operator|->
name|links
expr_stmt|;
while|while
condition|(
name|cx
condition|)
block|{
comment|/* Watch it, the command could be a ``remove'' */
name|dl
operator|=
name|cx
operator|->
name|next
expr_stmt|;
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|Commands
argument_list|,
name|arg
operator|->
name|argc
argument_list|,
name|arg
operator|->
name|argn
operator|+
literal|1
argument_list|,
name|arg
operator|->
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|cx
argument_list|)
expr_stmt|;
for|for
control|(
name|cx
operator|=
name|arg
operator|->
name|bundle
operator|->
name|links
init|;
name|cx
condition|;
name|cx
operator|=
name|cx
operator|->
name|next
control|)
if|if
condition|(
name|cx
operator|==
name|dl
condition|)
break|break;
comment|/* Pointer's still valid ! */
block|}
block|}
else|else
block|{
name|strncpy
argument_list|(
name|namelist
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
sizeof|sizeof
name|namelist
operator|-
literal|1
argument_list|)
expr_stmt|;
name|namelist
index|[
sizeof|sizeof
name|namelist
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|name
operator|=
name|strtok
argument_list|(
name|namelist
argument_list|,
literal|", "
argument_list|)
init|;
name|name
condition|;
name|name
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|", "
argument_list|)
control|)
if|if
condition|(
operator|!
name|bundle2datalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"link: %s: Invalid link name\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|strncpy
argument_list|(
name|namelist
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
sizeof|sizeof
name|namelist
operator|-
literal|1
argument_list|)
expr_stmt|;
name|namelist
index|[
sizeof|sizeof
name|namelist
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|name
operator|=
name|strtok
argument_list|(
name|namelist
argument_list|,
literal|", "
argument_list|)
init|;
name|name
condition|;
name|name
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|", "
argument_list|)
control|)
block|{
name|cx
operator|=
name|bundle2datalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cx
condition|)
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|Commands
argument_list|,
name|arg
operator|->
name|argc
argument_list|,
name|arg
operator|->
name|argn
operator|+
literal|1
argument_list|,
name|arg
operator|->
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|cx
argument_list|)
expr_stmt|;
else|else
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"link: %s: Invalidated link name !\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|result
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|result
return|;
block|}
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Usage: %s\n"
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|syntax
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_function
name|struct
name|link
modifier|*
name|command_ChooseLink
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|cx
condition|)
return|return
operator|&
name|arg
operator|->
name|cx
operator|->
name|physical
operator|->
name|link
return|;
elseif|else
if|if
condition|(
operator|!
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|mrru
condition|)
block|{
name|struct
name|datalink
modifier|*
name|dl
init|=
name|bundle2datalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|dl
condition|)
return|return
operator|&
name|dl
operator|->
name|physical
operator|->
name|link
return|;
block|}
return|return
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|link
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ident_cmd
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|unsigned
modifier|*
name|keep
parameter_list|,
name|unsigned
modifier|*
name|add
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
switch|switch
condition|(
operator|*
name|cmd
condition|)
block|{
case|case
literal|'A'
case|:
case|case
literal|'a'
case|:
name|result
operator|=
literal|"accept"
expr_stmt|;
operator|*
name|keep
operator|=
name|NEG_MYMASK
expr_stmt|;
operator|*
name|add
operator|=
name|NEG_ACCEPTED
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'d'
case|:
switch|switch
condition|(
name|cmd
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|result
operator|=
literal|"deny"
expr_stmt|;
operator|*
name|keep
operator|=
name|NEG_MYMASK
expr_stmt|;
operator|*
name|add
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
case|case
literal|'i'
case|:
name|result
operator|=
literal|"disable"
expr_stmt|;
operator|*
name|keep
operator|=
name|NEG_HISMASK
expr_stmt|;
operator|*
name|add
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|result
operator|=
literal|"enable"
expr_stmt|;
operator|*
name|keep
operator|=
name|NEG_HISMASK
expr_stmt|;
operator|*
name|add
operator|=
name|NEG_ENABLED
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|OptSet
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|bit
init|=
operator|(
name|int
operator|)
operator|(
name|long
operator|)
name|arg
operator|->
name|cmd
operator|->
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
name|unsigned
name|keep
decl_stmt|;
comment|/* Keep these bits */
name|unsigned
name|add
decl_stmt|;
comment|/* Add these bits */
if|if
condition|(
operator|(
name|cmd
operator|=
name|ident_cmd
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|-
literal|2
index|]
argument_list|,
operator|&
name|keep
argument_list|,
operator|&
name|add
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|add
condition|)
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|opt
operator||=
name|bit
expr_stmt|;
else|else
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|opt
operator|&=
operator|~
name|bit
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IfaceAliasOptSet
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|save
init|=
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|opt
decl_stmt|;
name|int
name|result
init|=
name|OptSet
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|==
literal|0
condition|)
if|if
condition|(
name|Enabled
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_IFACEALIAS
argument_list|)
operator|&&
operator|!
name|arg
operator|->
name|bundle
operator|->
name|NatEnabled
condition|)
block|{
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|opt
operator|=
name|save
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Cannot enable iface-alias without NAT\n"
argument_list|)
expr_stmt|;
name|result
operator|=
literal|2
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|NegotiateSet
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|long
name|param
init|=
operator|(
name|long
operator|)
name|arg
operator|->
name|cmd
operator|->
name|args
decl_stmt|;
name|struct
name|link
modifier|*
name|l
init|=
name|command_ChooseLink
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* LOCAL_CX_OPT uses this */
name|struct
name|datalink
modifier|*
name|cx
init|=
name|arg
operator|->
name|cx
decl_stmt|;
comment|/* LOCAL_CX uses this */
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
name|unsigned
name|keep
decl_stmt|;
comment|/* Keep these bits */
name|unsigned
name|add
decl_stmt|;
comment|/* Add these bits */
if|if
condition|(
operator|(
name|cmd
operator|=
name|ident_cmd
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|-
literal|2
index|]
argument_list|,
operator|&
name|keep
argument_list|,
operator|&
name|add
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|arg
operator|->
name|cmd
operator|->
name|lauth
operator|&
name|LOCAL_CX
operator|)
operator|&&
operator|!
name|cx
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s %s: No context (use the `link' command)\n"
argument_list|,
name|cmd
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
elseif|else
if|if
condition|(
name|cx
operator|&&
operator|!
operator|(
name|arg
operator|->
name|cmd
operator|->
name|lauth
operator|&
operator|(
name|LOCAL_CX
operator||
name|LOCAL_CX_OPT
operator|)
operator|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s %s: Redundant context (%s) ignored\n"
argument_list|,
name|cmd
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|name
argument_list|,
name|cx
operator|->
name|name
argument_list|)
expr_stmt|;
name|cx
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|param
condition|)
block|{
case|case
name|NEG_ACFCOMP
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|acfcomp
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|acfcomp
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_CHAP05
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|chap05
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|chap05
operator||=
name|add
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_DES
case|case
name|NEG_CHAP80
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|chap80nt
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|chap80nt
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_CHAP80LM
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|chap80lm
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|chap80lm
operator||=
name|add
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|NEG_DEFLATE
case|:
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_DEFLATE
index|]
operator|&=
name|keep
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_DEFLATE
index|]
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_DNS
case|:
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|ns
operator|.
name|dns_neg
operator|&=
name|keep
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|ns
operator|.
name|dns_neg
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_ENDDISC
case|:
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|negenddisc
operator|&=
name|keep
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|negenddisc
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_LQR
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|lqr
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|lqr
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_PAP
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|pap
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|pap
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_PPPDDEFLATE
case|:
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_DEFLATE24
index|]
operator|&=
name|keep
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_DEFLATE24
index|]
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_PRED1
case|:
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_PRED1
index|]
operator|&=
name|keep
expr_stmt|;
name|l
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|neg
index|[
name|CCP_NEG_PRED1
index|]
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_PROTOCOMP
case|:
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|protocomp
operator|&=
name|keep
expr_stmt|;
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|cfg
operator|.
name|protocomp
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_SHORTSEQ
case|:
switch|switch
condition|(
name|bundle_Phase
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
condition|)
block|{
case|case
name|PHASE_DEAD
case|:
break|break;
case|case
name|PHASE_ESTABLISH
case|:
comment|/* Make sure none of our links are DATALINK_LCP or greater */
if|if
condition|(
name|bundle_HighestState
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
operator|>=
name|DATALINK_LCP
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"shortseq: Only changable before"
literal|" LCP negotiations\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
default|default:
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"shortseq: Only changable at phase"
literal|" DEAD/ESTABLISH\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|shortseq
operator|&=
name|keep
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|cfg
operator|.
name|shortseq
operator||=
name|add
expr_stmt|;
break|break;
case|case
name|NEG_VJCOMP
case|:
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|vj
operator|.
name|neg
operator|&=
name|keep
expr_stmt|;
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|vj
operator|.
name|neg
operator||=
name|add
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cmdtab
specifier|const
name|NegotiateCommands
index|[]
init|=
block|{
block|{
literal|"idcheck"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Check FSM reply ids"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_IDCHECK
block|}
block|,
block|{
literal|"iface-alias"
block|,
name|NULL
block|,
name|IfaceAliasOptSet
block|,
name|LOCAL_AUTH
block|,
literal|"retain interface addresses"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_IFACEALIAS
block|}
block|,
block|{
literal|"keep-session"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Retain device session leader"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_KEEPSESSION
block|}
block|,
block|{
literal|"loopback"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Loop packets for local iface"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_LOOPBACK
block|}
block|,
block|{
literal|"passwdauth"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Use passwd file"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_PASSWDAUTH
block|}
block|,
block|{
literal|"proxy"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Create a proxy ARP entry"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_PROXY
block|}
block|,
block|{
literal|"proxyall"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Proxy ARP for all remote hosts"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_PROXYALL
block|}
block|,
block|{
literal|"sroutes"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Use sticky routes"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_SROUTES
block|}
block|,
block|{
literal|"throughput"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Rolling throughput"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_THROUGHPUT
block|}
block|,
block|{
literal|"utmp"
block|,
name|NULL
block|,
name|OptSet
block|,
name|LOCAL_AUTH
block|,
literal|"Log connections in utmp"
block|,
literal|"disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|OPT_UTMP
block|}
block|,
define|#
directive|define
name|OPT_MAX
value|10
comment|/* accept/deny allowed below and not above */
block|{
literal|"acfcomp"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Address& Control field compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_ACFCOMP
block|}
block|,
block|{
literal|"chap"
block|,
literal|"chap05"
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Challenge Handshake Authentication Protocol"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_CHAP05
block|}
block|,
ifdef|#
directive|ifdef
name|HAVE_DES
block|{
literal|"mschap"
block|,
literal|"chap80nt"
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Microsoft (NT) CHAP"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_CHAP80
block|}
block|,
block|{
literal|"LANMan"
block|,
literal|"chap80lm"
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Microsoft (NT) CHAP"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_CHAP80LM
block|}
block|,
endif|#
directive|endif
block|{
literal|"deflate"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Deflate compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_DEFLATE
block|}
block|,
block|{
literal|"deflate24"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Deflate (type 24) compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_PPPDDEFLATE
block|}
block|,
block|{
literal|"dns"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
block|,
literal|"DNS specification"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_DNS
block|}
block|,
block|{
literal|"enddisc"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
block|,
literal|"ENDDISC negotiation"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_ENDDISC
block|}
block|,
block|{
literal|"lqr"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Link Quality Reports"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_LQR
block|}
block|,
block|{
literal|"pap"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Password Authentication protocol"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_PAP
block|}
block|,
block|{
literal|"pred1"
block|,
literal|"predictor1"
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX_OPT
block|,
literal|"Predictor 1 compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_PRED1
block|}
block|,
block|{
literal|"protocomp"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_CX
block|,
literal|"Protocol field compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_PROTOCOMP
block|}
block|,
block|{
literal|"shortseq"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
block|,
literal|"MP Short Sequence Numbers"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_SHORTSEQ
block|}
block|,
block|{
literal|"vjcomp"
block|,
name|NULL
block|,
name|NegotiateSet
block|,
name|LOCAL_AUTH
block|,
literal|"Van Jacobson header compression"
block|,
literal|"accept|deny|disable|enable"
block|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|NEG_VJCOMP
block|}
block|,
block|{
literal|"help"
block|,
literal|"?"
block|,
name|HelpCommand
block|,
name|LOCAL_AUTH
operator||
name|LOCAL_NO_AUTH
block|,
literal|"Display this message"
block|,
literal|"accept|deny|disable|enable help|? [value]"
block|,
name|NegotiateCommands
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|NegotiateCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
block|{
name|char
specifier|const
modifier|*
name|argv
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|keep
decl_stmt|,
name|add
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|argv
index|[
literal|0
index|]
operator|=
name|ident_cmd
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|-
literal|1
index|]
argument_list|,
operator|&
name|keep
argument_list|,
operator|&
name|add
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|argv
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|n
operator|=
name|arg
operator|->
name|argn
init|;
name|n
operator|<
name|arg
operator|->
name|argc
condition|;
name|n
operator|++
control|)
block|{
name|argv
index|[
literal|1
index|]
operator|=
name|arg
operator|->
name|argv
index|[
name|n
index|]
expr_stmt|;
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|NegotiateCommands
operator|+
operator|(
name|keep
operator|==
name|NEG_HISMASK
condition|?
literal|0
else|:
name|OPT_MAX
operator|)
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Use `%s ?' to get a list.\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s command must have arguments\n"
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|command_ShowNegval
parameter_list|(
name|unsigned
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|val
operator|&
literal|3
condition|)
block|{
case|case
literal|1
case|:
return|return
literal|"disabled& accepted"
return|;
case|case
literal|2
case|:
return|return
literal|"enabled& denied"
return|;
case|case
literal|3
case|:
return|return
literal|"enabled& accepted"
return|;
block|}
return|return
literal|"disabled& denied"
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ClearCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pppThroughput
modifier|*
name|t
decl_stmt|;
name|struct
name|datalink
modifier|*
name|cx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|clear_type
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|<
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"physical"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cx
operator|=
name|arg
operator|->
name|cx
expr_stmt|;
if|if
condition|(
operator|!
name|cx
condition|)
name|cx
operator|=
name|bundle2datalink
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cx
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"A link must be specified for ``clear physical''\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|t
operator|=
operator|&
name|cx
operator|->
name|physical
operator|->
name|link
operator|.
name|throughput
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
literal|"ipcp"
argument_list|)
operator|==
literal|0
condition|)
name|t
operator|=
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|throughput
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
name|clear_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|arg
operator|->
name|argn
operator|+
literal|1
init|;
name|i
operator|<
name|arg
operator|->
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|i
index|]
argument_list|,
literal|"overall"
argument_list|)
operator|==
literal|0
condition|)
name|clear_type
operator||=
name|THROUGHPUT_OVERALL
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|i
index|]
argument_list|,
literal|"current"
argument_list|)
operator|==
literal|0
condition|)
name|clear_type
operator||=
name|THROUGHPUT_CURRENT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|arg
operator|->
name|argv
index|[
name|i
index|]
argument_list|,
literal|"peak"
argument_list|)
operator|==
literal|0
condition|)
name|clear_type
operator||=
name|THROUGHPUT_PEAK
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
else|else
name|clear_type
operator|=
name|THROUGHPUT_ALL
expr_stmt|;
name|throughput_clear
argument_list|(
name|t
argument_list|,
name|clear_type
argument_list|,
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|RunListCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cmd
init|=
name|arg
operator|->
name|argc
condition|?
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argc
operator|-
literal|1
index|]
else|:
literal|"???"
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|>
name|arg
operator|->
name|argn
condition|)
name|FindExec
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|arg
operator|->
name|cmd
operator|->
name|args
argument_list|,
name|arg
operator|->
name|argc
argument_list|,
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|argv
argument_list|,
name|arg
operator|->
name|prompt
argument_list|,
name|arg
operator|->
name|cx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Use `%s help' to get a list or `%s help"
literal|"<option>' for syntax help.\n"
argument_list|,
name|cmd
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s command must have arguments\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IfaceAddCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|bits
decl_stmt|,
name|n
decl_stmt|,
name|how
decl_stmt|;
name|struct
name|in_addr
name|ifa
decl_stmt|,
name|mask
decl_stmt|,
name|brd
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ParseAddr
argument_list|(
name|NULL
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
operator|&
name|ifa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|mask
operator|.
name|s_addr
operator|=
name|brd
operator|.
name|s_addr
operator|=
name|INADDR_BROADCAST
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|ParseAddr
argument_list|(
name|NULL
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
operator|&
name|ifa
argument_list|,
operator|&
name|mask
argument_list|,
operator|&
name|bits
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|n
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
operator|+
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|ParseAddr
argument_list|(
name|NULL
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
operator|&
name|ifa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|ParseAddr
argument_list|(
name|NULL
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
literal|1
index|]
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|n
operator|=
literal|2
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|ParseAddr
argument_list|(
name|NULL
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
operator|+
name|n
index|]
argument_list|,
operator|&
name|brd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|how
operator|=
name|IFACE_ADD_LAST
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|cmd
operator|->
name|args
condition|)
name|how
operator||=
name|IFACE_FORCE_ADD
expr_stmt|;
return|return
operator|!
name|iface_inAdd
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|iface
argument_list|,
name|ifa
argument_list|,
name|mask
argument_list|,
name|brd
argument_list|,
name|how
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IfaceDeleteCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|in_addr
name|ifa
decl_stmt|;
name|int
name|ok
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|!=
name|arg
operator|->
name|argn
operator|+
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|ParseAddr
argument_list|(
name|NULL
argument_list|,
name|arg
operator|->
name|argv
index|[
name|arg
operator|->
name|argn
index|]
argument_list|,
operator|&
name|ifa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|ST_OPENED
operator|&&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|my_ip
operator|.
name|s_addr
operator|==
name|ifa
operator|.
name|s_addr
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Cannot remove active interface address\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|ifa
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ok
operator|=
name|iface_inDelete
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|iface
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|cmd
operator|->
name|args
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|arg
operator|->
name|prompt
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%s: No such address\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|ifa
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: No such address\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|ifa
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|!
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|IfaceClearCommand
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|how
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|!=
name|arg
operator|->
name|argn
condition|)
return|return
operator|-
literal|1
return|;
name|how
operator|=
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|ST_OPENED
operator|||
name|arg
operator|->
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|&
name|PHYS_AUTO
condition|?
name|IFACE_CLEAR_ALIASES
else|:
name|IFACE_CLEAR_ALL
expr_stmt|;
name|iface_Clear
argument_list|(
name|arg
operator|->
name|bundle
operator|->
name|iface
argument_list|,
name|how
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetProcTitle
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
specifier|static
name|char
name|title
index|[
name|LINE_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|remaining
decl_stmt|,
name|f
decl_stmt|,
name|argc
init|=
name|arg
operator|->
name|argc
operator|-
name|arg
operator|->
name|argn
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|argc
operator|==
name|arg
operator|->
name|argn
condition|)
block|{
name|ID0setproctitle
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|argc
operator|>=
sizeof|sizeof
name|argv
operator|/
sizeof|sizeof
name|argv
index|[
literal|0
index|]
condition|)
block|{
name|argc
operator|=
sizeof|sizeof
name|argv
operator|/
sizeof|sizeof
name|argv
index|[
literal|0
index|]
operator|-
literal|1
expr_stmt|;
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Truncating proc title to %d args\n"
argument_list|,
name|argc
argument_list|)
expr_stmt|;
block|}
name|command_Expand
argument_list|(
name|argv
argument_list|,
name|argc
argument_list|,
name|arg
operator|->
name|argv
operator|+
name|arg
operator|->
name|argn
argument_list|,
name|arg
operator|->
name|bundle
argument_list|,
literal|1
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|title
expr_stmt|;
name|remaining
operator|=
sizeof|sizeof
name|title
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|argc
operator|&&
name|remaining
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|f
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|' '
expr_stmt|;
name|remaining
operator|--
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|f
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|remaining
condition|)
name|len
operator|=
name|remaining
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|argv
index|[
name|f
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|remaining
operator|-=
name|len
expr_stmt|;
name|ptr
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
name|ID0setproctitle
argument_list|(
name|title
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

