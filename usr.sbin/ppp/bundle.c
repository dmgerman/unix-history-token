begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Brian Somers<brian@Awfulhak.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NOALIAS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_include
include|#
directive|include
file|"alias.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<alias.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"iplist.h"
end_include

begin_include
include|#
directive|include
file|"lqr.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"throughput.h"
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"filter.h"
end_include

begin_include
include|#
directive|include
file|"descriptor.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ccp.h"
end_include

begin_include
include|#
directive|include
file|"link.h"
end_include

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_include
include|#
directive|include
file|"bundle.h"
end_include

begin_include
include|#
directive|include
file|"async.h"
end_include

begin_include
include|#
directive|include
file|"physical.h"
end_include

begin_include
include|#
directive|include
file|"modem.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"lcpproto.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"tun.h"
end_include

begin_include
include|#
directive|include
file|"prompt.h"
end_include

begin_include
include|#
directive|include
file|"chat.h"
end_include

begin_include
include|#
directive|include
file|"cbcp.h"
end_include

begin_include
include|#
directive|include
file|"datalink.h"
end_include

begin_include
include|#
directive|include
file|"ip.h"
end_include

begin_include
include|#
directive|include
file|"iface.h"
end_include

begin_define
define|#
directive|define
name|SCATTER_SEGMENTS
value|4
end_define

begin_comment
comment|/* version, datalink, name, physical */
end_comment

begin_define
define|#
directive|define
name|SOCKET_OVERHEAD
value|100
end_define

begin_comment
comment|/* additional buffer space for large */
end_comment

begin_comment
comment|/* {recv,send}msg() calls            */
end_comment

begin_function_decl
specifier|static
name|int
name|bundle_RemainingIdleTime
parameter_list|(
name|struct
name|bundle
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bundle_RemainingAutoLoadTime
parameter_list|(
name|struct
name|bundle
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|PhaseNames
index|[]
init|=
block|{
literal|"Dead"
block|,
literal|"Establish"
block|,
literal|"Authenticate"
block|,
literal|"Network"
block|,
literal|"Terminate"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|bundle_PhaseName
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
return|return
name|bundle
operator|->
name|phase
operator|<=
name|PHASE_TERMINATE
condition|?
name|PhaseNames
index|[
name|bundle
operator|->
name|phase
index|]
else|:
literal|"unknown"
return|;
block|}
end_function

begin_function
name|void
name|bundle_NewPhase
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|u_int
name|new
parameter_list|)
block|{
if|if
condition|(
name|new
operator|==
name|bundle
operator|->
name|phase
condition|)
return|return;
if|if
condition|(
name|new
operator|<=
name|PHASE_TERMINATE
condition|)
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"bundle: %s\n"
argument_list|,
name|PhaseNames
index|[
name|new
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|new
condition|)
block|{
case|case
name|PHASE_DEAD
case|:
name|log_DisplayPrompts
argument_list|()
expr_stmt|;
name|bundle
operator|->
name|phase
operator|=
name|new
expr_stmt|;
break|break;
case|case
name|PHASE_ESTABLISH
case|:
name|bundle
operator|->
name|phase
operator|=
name|new
expr_stmt|;
break|break;
case|case
name|PHASE_AUTHENTICATE
case|:
name|bundle
operator|->
name|phase
operator|=
name|new
expr_stmt|;
name|log_DisplayPrompts
argument_list|()
expr_stmt|;
break|break;
case|case
name|PHASE_NETWORK
case|:
name|ipcp_Setup
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
name|fsm_Up
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
name|fsm_Open
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|phase
operator|=
name|new
expr_stmt|;
name|log_DisplayPrompts
argument_list|()
expr_stmt|;
break|break;
case|case
name|PHASE_TERMINATE
case|:
name|bundle
operator|->
name|phase
operator|=
name|new
expr_stmt|;
name|mp_Down
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
name|log_DisplayPrompts
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_LayerStart
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/* The given FSM is about to start up ! */
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_Notify
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|bundle
operator|->
name|notify
operator|.
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|bundle
operator|->
name|notify
operator|.
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|==
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Parent notified of success.\n"
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Failed to notify parent of success.\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bundle
operator|->
name|notify
operator|.
name|fd
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|notify
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_ClearQueues
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|bundle
modifier|*
name|bundle
init|=
operator|(
expr|struct
name|bundle
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Clearing choked output queue\n"
argument_list|)
expr_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|choked
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/*    * Emergency time:    *    * We've had a full queue for PACKET_DEL_SECS seconds without being    * able to get rid of any of the packets.  We've probably given up    * on the redials at this point, and the queued data has almost    * definitely been timed out by the layer above.  As this is preventing    * us from reading the TUN_NAME device (we don't want to buffer stuff    * indefinitely), we may as well nuke this data and start with a clean    * slate !    *    * Unfortunately, this has the side effect of shafting any compression    * dictionaries in use (causing the relevant RESET_REQ/RESET_ACK).    */
name|ip_DeleteQueue
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
name|mp_DeleteQueue
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|physical_DeleteQueue
argument_list|(
name|dl
operator|->
name|physical
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_AutoLoadTimeout
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|bundle
modifier|*
name|bundle
init|=
operator|(
expr|struct
name|bundle
operator|*
operator|)
name|v
decl_stmt|;
if|if
condition|(
name|bundle
operator|->
name|autoload
operator|.
name|comingup
condition|)
block|{
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"autoload: Another link is required\n"
argument_list|)
expr_stmt|;
comment|/* bundle_Open() stops the timer */
name|bundle_Open
argument_list|(
name|bundle
argument_list|,
name|NULL
argument_list|,
name|PHYS_AUTO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|autoload
operator|.
name|timer
argument_list|)
expr_stmt|;
for|for
control|(
name|last
operator|=
name|NULL
operator|,
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|physical
operator|->
name|type
operator|==
name|PHYS_AUTO
operator|&&
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
name|last
operator|=
name|dl
expr_stmt|;
if|if
condition|(
name|last
condition|)
name|datalink_Close
argument_list|(
name|last
argument_list|,
name|CLOSE_STAYDOWN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_StartAutoLoadTimer
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|up
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|autoload
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|comingup
operator|=
name|up
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|bundle
operator|->
name|CleaningUp
operator|||
name|bundle
operator|->
name|phase
operator|!=
name|PHASE_NETWORK
condition|)
block|{
name|dl
operator|=
name|NULL
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|running
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|up
condition|)
block|{
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_CLOSED
operator|&&
name|dl
operator|->
name|physical
operator|->
name|type
operator|==
name|PHYS_AUTO
condition|)
block|{
if|if
condition|(
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|.
name|timeout
condition|)
block|{
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|func
operator|=
name|bundle_AutoLoadTimeout
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|name
operator|=
literal|"autoload up"
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|load
operator|=
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|.
name|timeout
operator|*
name|SECTICKS
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|arg
operator|=
name|bundle
expr_stmt|;
name|timer_Start
argument_list|(
operator|&
name|bundle
operator|->
name|autoload
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|done
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|+
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|.
name|timeout
expr_stmt|;
block|}
else|else
name|bundle_AutoLoadTimeout
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
break|break;
block|}
name|bundle
operator|->
name|autoload
operator|.
name|running
operator|=
operator|(
name|dl
operator|||
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|timeout
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|nlinks
decl_stmt|;
name|struct
name|datalink
modifier|*
name|adl
decl_stmt|;
for|for
control|(
name|nlinks
operator|=
literal|0
operator|,
name|adl
operator|=
name|NULL
operator|,
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
block|{
if|if
condition|(
name|dl
operator|->
name|physical
operator|->
name|type
operator|==
name|PHYS_AUTO
condition|)
name|adl
operator|=
name|dl
expr_stmt|;
if|if
condition|(
operator|++
name|nlinks
operator|>
literal|1
operator|&&
name|adl
condition|)
block|{
if|if
condition|(
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|timeout
condition|)
block|{
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|func
operator|=
name|bundle_AutoLoadTimeout
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|name
operator|=
literal|"autoload down"
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|load
operator|=
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|timeout
operator|*
name|SECTICKS
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|arg
operator|=
name|bundle
expr_stmt|;
name|timer_Start
argument_list|(
operator|&
name|bundle
operator|->
name|autoload
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|done
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|+
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|timeout
expr_stmt|;
block|}
break|break;
block|}
block|}
name|bundle
operator|->
name|autoload
operator|.
name|running
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_StopAutoLoadTimer
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|autoload
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bundle_RemainingAutoLoadTime
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
if|if
condition|(
name|bundle
operator|->
name|autoload
operator|.
name|done
condition|)
return|return
name|bundle
operator|->
name|autoload
operator|.
name|done
operator|-
name|time
argument_list|(
name|NULL
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_LinkAdded
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|)
block|{
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator||=
name|dl
operator|->
name|physical
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator||=
name|dl
operator|->
name|physical
operator|->
name|type
expr_stmt|;
comment|/* Note: We only re-add links that are DATALINK_OPEN */
if|if
condition|(
name|dl
operator|->
name|physical
operator|->
name|type
operator|==
name|PHYS_AUTO
operator|&&
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|state
operator|==
name|TIMER_STOPPED
operator|&&
name|dl
operator|->
name|state
operator|!=
name|DATALINK_OPEN
operator|&&
name|bundle
operator|->
name|phase
operator|==
name|PHASE_NETWORK
condition|)
name|bundle
operator|->
name|autoload
operator|.
name|running
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|&
operator|(
name|PHYS_DEDICATED
operator||
name|PHYS_DDIAL
operator|)
operator|)
operator|!=
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|&&
name|bundle
operator|->
name|idle
operator|.
name|timer
operator|.
name|state
operator|==
name|TIMER_STOPPED
condition|)
comment|/* We may need to start our idle timer */
name|bundle_StartIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_LinksRemoved
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|=
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|bundle_LinkAdded
argument_list|(
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|&
operator|(
name|PHYS_DEDICATED
operator||
name|PHYS_DDIAL
operator|)
operator|)
operator|==
name|bundle
operator|->
name|phys_type
operator|.
name|open
condition|)
name|bundle_StopIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_LayerUp
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/*    * The given fsm is now up    * If it's an LCP, adjust our phys_mode.open value.    * If it's an LCP set our mtu (if we're multilink, add up the link    * speeds and set the MRRU) and start our autoload timer.    * If it's an NCP, tell our -background parent to go away.    * If it's the first NCP, start the idle timer.    */
name|struct
name|bundle
modifier|*
name|bundle
init|=
operator|(
expr|struct
name|bundle
operator|*
operator|)
name|v
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_LCP
condition|)
block|{
name|struct
name|physical
modifier|*
name|p
init|=
name|link2physical
argument_list|(
name|fp
operator|->
name|link
argument_list|)
decl_stmt|;
name|bundle_LinkAdded
argument_list|(
name|bundle
argument_list|,
name|p
operator|->
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|active
condition|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|bundle
operator|->
name|ifSpeed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
name|bundle
operator|->
name|ifSpeed
operator|+=
name|modem_Speed
argument_list|(
name|dl
operator|->
name|physical
argument_list|)
expr_stmt|;
name|tun_configure
argument_list|(
name|bundle
argument_list|,
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|peer_mrru
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|running
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|bundle
operator|->
name|ifSpeed
operator|=
name|modem_Speed
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tun_configure
argument_list|(
name|bundle
argument_list|,
name|fsm2lcp
argument_list|(
name|fp
argument_list|)
operator|->
name|his_mru
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_IPCP
condition|)
block|{
name|bundle_StartIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|bundle_Notify
argument_list|(
name|bundle
argument_list|,
name|EX_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_LayerDown
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/*    * The given FSM has been told to come down.    * If it's our last NCP, stop the idle timer.    * If it's an LCP, adjust our phys_type.open value and any timers.    * If it's an LCP and we're in multilink mode, adjust our tun    * speed and make sure our minimum sequence number is adjusted.    */
name|struct
name|bundle
modifier|*
name|bundle
init|=
operator|(
expr|struct
name|bundle
operator|*
operator|)
name|v
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_IPCP
condition|)
name|bundle_StopIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_LCP
condition|)
block|{
name|bundle_LinksRemoved
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
comment|/* adjust timers& phys_type values */
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|active
condition|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|struct
name|datalink
modifier|*
name|lost
decl_stmt|;
name|bundle
operator|->
name|ifSpeed
operator|=
literal|0
expr_stmt|;
name|lost
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|fp
operator|==
operator|&
name|dl
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
condition|)
name|lost
operator|=
name|dl
expr_stmt|;
elseif|else
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
name|bundle
operator|->
name|ifSpeed
operator|+=
name|modem_Speed
argument_list|(
name|dl
operator|->
name|physical
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|->
name|ifSpeed
condition|)
comment|/* Don't configure down to a speed of 0 */
name|tun_configure
argument_list|(
name|bundle
argument_list|,
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|link
operator|.
name|lcp
operator|.
name|his_mru
argument_list|)
expr_stmt|;
if|if
condition|(
name|lost
condition|)
name|mp_LinkLost
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|,
name|lost
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"Oops, lost an unrecognised datalink (%s) !\n"
argument_list|,
name|fp
operator|->
name|link
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_LayerFinish
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/* The given fsm is now down (fp cannot be NULL)    *    * If it's the last LCP, fsm_Down all NCPs    * If it's the last NCP, fsm_Close all LCPs    */
name|struct
name|bundle
modifier|*
name|bundle
init|=
operator|(
expr|struct
name|bundle
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_IPCP
condition|)
block|{
if|if
condition|(
name|bundle_Phase
argument_list|(
name|bundle
argument_list|)
operator|!=
name|PHASE_DEAD
condition|)
name|bundle_NewPhase
argument_list|(
name|bundle
argument_list|,
name|PHASE_TERMINATE
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|datalink_Close
argument_list|(
name|dl
argument_list|,
name|CLOSE_NORMAL
argument_list|)
expr_stmt|;
name|fsm2initial
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_LCP
condition|)
block|{
name|int
name|others_active
decl_stmt|;
name|others_active
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|fp
operator|!=
operator|&
name|dl
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
operator|&&
name|dl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
operator|&&
name|dl
operator|->
name|state
operator|!=
name|DATALINK_HANGUP
condition|)
name|others_active
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|others_active
condition|)
name|fsm2initial
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|bundle_LinkIsUp
parameter_list|(
specifier|const
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
return|return
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|ST_OPENED
return|;
block|}
end_function

begin_function
name|void
name|bundle_Close
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|how
parameter_list|)
block|{
comment|/*    * Please close the given datalink.    * If name == NULL or name is the last datalink, fsm_Close all NCPs    * (except our MP)    * If it isn't the last datalink, just Close that datalink.    */
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|,
modifier|*
name|this_dl
decl_stmt|;
name|int
name|others_active
decl_stmt|;
name|others_active
operator|=
literal|0
expr_stmt|;
name|this_dl
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|name
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|dl
operator|->
name|name
argument_list|)
condition|)
name|this_dl
operator|=
name|dl
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|this_dl
operator|==
name|dl
condition|)
block|{
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|CLOSE_LCP
case|:
name|datalink_DontHangup
argument_list|(
name|dl
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|CLOSE_STAYDOWN
case|:
name|datalink_StayDown
argument_list|(
name|dl
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|dl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
operator|&&
name|dl
operator|->
name|state
operator|!=
name|DATALINK_HANGUP
condition|)
name|others_active
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|&&
name|this_dl
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Invalid datalink name\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|others_active
condition|)
block|{
name|bundle_StopIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|bundle_StopAutoLoadTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
operator|.
name|state
operator|>
name|ST_CLOSED
operator|||
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|ST_STARTING
condition|)
name|fsm_Close
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
else|else
block|{
name|fsm2initial
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|datalink_Close
argument_list|(
name|dl
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|this_dl
operator|&&
name|this_dl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
operator|&&
name|this_dl
operator|->
name|state
operator|!=
name|DATALINK_HANGUP
condition|)
name|datalink_Close
argument_list|(
name|this_dl
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_Down
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|datalink_Down
argument_list|(
name|dl
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bundle_UpdateSet
parameter_list|(
name|struct
name|descriptor
modifier|*
name|d
parameter_list|,
name|fd_set
modifier|*
name|r
parameter_list|,
name|fd_set
modifier|*
name|w
parameter_list|,
name|fd_set
modifier|*
name|e
parameter_list|,
name|int
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|bundle
modifier|*
name|bundle
init|=
name|descriptor2bundle
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|int
name|result
decl_stmt|,
name|want
decl_stmt|,
name|queued
decl_stmt|,
name|nlinks
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
comment|/* If there are aren't many packets queued, look for some more. */
for|for
control|(
name|nlinks
operator|=
literal|0
operator|,
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|nlinks
operator|++
expr_stmt|;
if|if
condition|(
name|nlinks
condition|)
block|{
name|queued
operator|=
name|r
condition|?
name|bundle_FillQueues
argument_list|(
name|bundle
argument_list|)
else|:
name|ip_QueueLen
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|->
name|autoload
operator|.
name|running
condition|)
block|{
if|if
condition|(
name|queued
operator|<
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|.
name|packets
condition|)
block|{
if|if
condition|(
name|queued
operator|>
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|packets
condition|)
name|bundle_StopAutoLoadTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|state
operator|!=
name|TIMER_RUNNING
operator|||
name|bundle
operator|->
name|autoload
operator|.
name|comingup
condition|)
name|bundle_StartAutoLoadTimer
argument_list|(
name|bundle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bundle_Phase
argument_list|(
name|bundle
argument_list|)
operator|==
name|PHASE_NETWORK
operator|||
name|queued
operator|)
operator|&&
operator|(
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|state
operator|!=
name|TIMER_RUNNING
operator|||
operator|!
name|bundle
operator|->
name|autoload
operator|.
name|comingup
operator|)
condition|)
name|bundle_StartAutoLoadTimer
argument_list|(
name|bundle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|&&
operator|(
name|bundle
operator|->
name|phase
operator|==
name|PHASE_NETWORK
operator|||
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|&
name|PHYS_AUTO
operator|)
condition|)
block|{
comment|/* enough surplus so that we can tell if we're getting swamped */
name|want
operator|=
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|.
name|packets
operator|+
name|nlinks
operator|*
literal|2
expr_stmt|;
comment|/* but at least 20 packets ! */
if|if
condition|(
name|want
operator|<
literal|20
condition|)
name|want
operator|=
literal|20
expr_stmt|;
if|if
condition|(
name|queued
operator|<
name|want
condition|)
block|{
comment|/* Not enough - select() for more */
if|if
condition|(
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|state
operator|==
name|TIMER_RUNNING
condition|)
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|choked
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* Not needed any more */
name|FD_SET
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|n
operator|<
name|bundle
operator|->
name|dev
operator|.
name|fd
operator|+
literal|1
condition|)
operator|*
name|n
operator|=
name|bundle
operator|->
name|dev
operator|.
name|fd
operator|+
literal|1
expr_stmt|;
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"%s: fdset(r) %d\n"
argument_list|,
name|TUN_NAME
argument_list|,
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
name|result
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|state
operator|==
name|TIMER_STOPPED
condition|)
block|{
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|func
operator|=
name|bundle_ClearQueues
expr_stmt|;
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|name
operator|=
literal|"output choke"
expr_stmt|;
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|load
operator|=
name|bundle
operator|->
name|cfg
operator|.
name|choked
operator|.
name|timeout
operator|*
name|SECTICKS
expr_stmt|;
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|arg
operator|=
name|bundle
expr_stmt|;
name|timer_Start
argument_list|(
operator|&
name|bundle
operator|->
name|choked
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Which links need a select() ? */
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|result
operator|+=
name|descriptor_UpdateSet
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|r
argument_list|,
name|w
argument_list|,
name|e
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/*    * This *MUST* be called after the datalink UpdateSet()s as it    * might be ``holding'' one of the datalinks (death-row) and    * wants to be able to de-select() it from the descriptor set.    */
name|result
operator|+=
name|descriptor_UpdateSet
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|r
argument_list|,
name|w
argument_list|,
name|e
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bundle_IsSet
parameter_list|(
name|struct
name|descriptor
modifier|*
name|d
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|bundle
modifier|*
name|bundle
init|=
name|descriptor2bundle
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|FD_ISSET
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|,
name|fdset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_DescriptorRead
parameter_list|(
name|struct
name|descriptor
modifier|*
name|d
parameter_list|,
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
name|descriptor_Read
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|bundle
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
name|descriptor_Read
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|bundle
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|,
name|fdset
argument_list|)
condition|)
block|{
name|struct
name|tun_data
name|tun
decl_stmt|;
name|int
name|n
decl_stmt|,
name|pri
decl_stmt|;
comment|/* something to read from tun */
name|n
operator|=
name|read
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|,
operator|&
name|tun
argument_list|,
sizeof|sizeof
name|tun
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"read from %s: %s\n"
argument_list|,
name|TUN_NAME
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|-=
sizeof|sizeof
name|tun
operator|-
sizeof|sizeof
name|tun
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"read from %s: Only %d bytes read ?\n"
argument_list|,
name|TUN_NAME
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|tun_check_header
argument_list|(
name|tun
argument_list|,
name|AF_INET
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|tun
operator|.
name|data
operator|)
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|my_ip
operator|.
name|s_addr
condition|)
block|{
comment|/* we've been asked to send something addressed *to* us :( */
if|if
condition|(
name|Enabled
argument_list|(
name|bundle
argument_list|,
name|OPT_LOOPBACK
argument_list|)
condition|)
block|{
name|pri
operator|=
name|PacketCheck
argument_list|(
name|bundle
argument_list|,
name|tun
operator|.
name|data
argument_list|,
name|n
argument_list|,
operator|&
name|bundle
operator|->
name|filter
operator|.
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|>=
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|mbuf_Alloc
argument_list|(
name|n
argument_list|,
name|MB_IPIN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|MBUF_CTOP
argument_list|(
name|bp
argument_list|)
argument_list|,
name|tun
operator|.
name|data
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ip_Input
argument_list|(
name|bundle
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Looped back packet addressed to myself\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Oops - forwarding packet addressed to myself\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Process on-demand dialup. Output packets are queued within tunnel      * device until IPCP is opened.      */
if|if
condition|(
name|bundle_Phase
argument_list|(
name|bundle
argument_list|)
operator|==
name|PHASE_DEAD
condition|)
block|{
comment|/*        * Note, we must be in AUTO mode :-/ otherwise our interface should        * *not* be UP and we can't receive data        */
if|if
condition|(
operator|(
name|pri
operator|=
name|PacketCheck
argument_list|(
name|bundle
argument_list|,
name|tun
operator|.
name|data
argument_list|,
name|n
argument_list|,
operator|&
name|bundle
operator|->
name|filter
operator|.
name|dial
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|bundle_Open
argument_list|(
name|bundle
argument_list|,
name|NULL
argument_list|,
name|PHYS_AUTO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/*          * Drop the packet.  If we were to queue it, we'd just end up with          * a pile of timed-out data in our output queue by the time we get          * around to actually dialing.  We'd also prematurely reach the           * threshold at which we stop select()ing to read() the tun          * device - breaking auto-dial.          */
return|return;
block|}
name|pri
operator|=
name|PacketCheck
argument_list|(
name|bundle
argument_list|,
name|tun
operator|.
name|data
argument_list|,
name|n
argument_list|,
operator|&
name|bundle
operator|->
name|filter
operator|.
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|>=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|NOALIAS
if|if
condition|(
name|bundle
operator|->
name|AliasEnabled
condition|)
block|{
name|PacketAliasOut
argument_list|(
name|tun
operator|.
name|data
argument_list|,
sizeof|sizeof
name|tun
operator|.
name|data
argument_list|)
expr_stmt|;
name|n
operator|=
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|tun
operator|.
name|data
operator|)
operator|->
name|ip_len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ip_Enqueue
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
name|pri
argument_list|,
name|tun
operator|.
name|data
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bundle_DescriptorWrite
parameter_list|(
name|struct
name|descriptor
modifier|*
name|d
parameter_list|,
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* This is not actually necessary as struct mpserver doesn't Write() */
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
name|descriptor_Write
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|bundle
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
name|result
operator|+=
name|descriptor_Write
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|bundle
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|bundle_LockTun
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|FILE
modifier|*
name|lockfile
decl_stmt|;
name|char
name|pidfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|pidfile
argument_list|,
sizeof|sizeof
name|pidfile
argument_list|,
literal|"%stun%d.pid"
argument_list|,
name|_PATH_VARRUN
argument_list|,
name|bundle
operator|->
name|unit
argument_list|)
expr_stmt|;
name|lockfile
operator|=
name|ID0fopen
argument_list|(
name|pidfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockfile
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|lockfile
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|RELEASE_CRUNCH
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Warning: Can't create %s: %s\n"
argument_list|,
name|pidfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_UnlockTun
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|char
name|pidfile
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|pidfile
argument_list|,
sizeof|sizeof
name|pidfile
argument_list|,
literal|"%stun%d.pid"
argument_list|,
name|_PATH_VARRUN
argument_list|,
name|bundle
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ID0unlink
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|bundle
modifier|*
name|bundle_Create
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|enoentcount
decl_stmt|,
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|ifname
decl_stmt|;
name|struct
name|ifreq
name|ifrq
decl_stmt|;
specifier|static
name|struct
name|bundle
name|bundle
decl_stmt|;
comment|/* there can be only one */
if|if
condition|(
name|bundle
operator|.
name|iface
operator|!=
name|NULL
condition|)
block|{
comment|/* Already allocated ! */
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"bundle_Create:  There's only one BUNDLE !\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|err
operator|=
name|ENOENT
expr_stmt|;
name|enoentcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bundle
operator|.
name|unit
operator|=
literal|0
init|;
condition|;
name|bundle
operator|.
name|unit
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|Name
argument_list|,
sizeof|sizeof
name|bundle
operator|.
name|dev
operator|.
name|Name
argument_list|,
literal|"%s%d"
argument_list|,
name|prefix
argument_list|,
name|bundle
operator|.
name|unit
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|dev
operator|.
name|fd
operator|=
name|ID0open
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|Name
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|.
name|dev
operator|.
name|fd
operator|>=
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENXIO
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
operator|++
name|enoentcount
operator|>
literal|2
condition|)
break|break;
block|}
else|else
name|err
operator|=
name|errno
expr_stmt|;
block|}
if|if
condition|(
name|bundle
operator|.
name|dev
operator|.
name|fd
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"No available tunnel devices found (%s).\n"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|log_SetTun
argument_list|(
name|bundle
operator|.
name|unit
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|argv
operator|=
name|argv
expr_stmt|;
name|bundle
operator|.
name|argv0
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|bundle
operator|.
name|argv1
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_Create: socket(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ifname
operator|=
name|strrchr
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|Name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifname
operator|==
name|NULL
condition|)
name|ifname
operator|=
name|bundle
operator|.
name|dev
operator|.
name|Name
expr_stmt|;
else|else
name|ifname
operator|++
expr_stmt|;
name|bundle
operator|.
name|iface
operator|=
name|iface_Create
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|.
name|iface
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*    * Now, bring up the interface.    */
name|memset
argument_list|(
operator|&
name|ifrq
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|ifrq
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifrq
operator|.
name|ifr_name
argument_list|,
name|ifname
argument_list|,
sizeof|sizeof
name|ifrq
operator|.
name|ifr_name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifrq
operator|.
name|ifr_name
index|[
sizeof|sizeof
name|ifrq
operator|.
name|ifr_name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ID0ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifrq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_Create: ioctl(SIOCGIFFLAGS): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|iface_Destroy
argument_list|(
name|bundle
operator|.
name|iface
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|iface
operator|=
name|NULL
expr_stmt|;
name|close
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ifrq
operator|.
name|ifr_flags
operator||=
name|IFF_UP
expr_stmt|;
if|if
condition|(
name|ID0ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifrq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_Create: ioctl(SIOCSIFFLAGS): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|iface_Destroy
argument_list|(
name|bundle
operator|.
name|iface
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|iface
operator|=
name|NULL
expr_stmt|;
name|close
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Using interface: %s\n"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|ifSpeed
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|routing_seq
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|phase
operator|=
name|PHASE_DEAD
expr_stmt|;
name|bundle
operator|.
name|CleaningUp
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|AliasEnabled
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|fsm
operator|.
name|LayerStart
operator|=
name|bundle_LayerStart
expr_stmt|;
name|bundle
operator|.
name|fsm
operator|.
name|LayerUp
operator|=
name|bundle_LayerUp
expr_stmt|;
name|bundle
operator|.
name|fsm
operator|.
name|LayerDown
operator|=
name|bundle_LayerDown
expr_stmt|;
name|bundle
operator|.
name|fsm
operator|.
name|LayerFinish
operator|=
name|bundle_LayerFinish
expr_stmt|;
name|bundle
operator|.
name|fsm
operator|.
name|object
operator|=
operator|&
name|bundle
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|idle_timeout
operator|=
name|NCP_IDLE_TIMEOUT
expr_stmt|;
operator|*
name|bundle
operator|.
name|cfg
operator|.
name|auth
operator|.
name|name
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|bundle
operator|.
name|cfg
operator|.
name|auth
operator|.
name|key
operator|=
literal|'\0'
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|opt
operator|=
name|OPT_SROUTES
operator||
name|OPT_IDCHECK
operator||
name|OPT_LOOPBACK
operator||
name|OPT_THROUGHPUT
operator||
name|OPT_UTMP
expr_stmt|;
operator|*
name|bundle
operator|.
name|cfg
operator|.
name|label
operator|=
literal|'\0'
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|mtu
operator|=
name|DEF_MTU
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|.
name|packets
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|packets
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|choked
operator|.
name|timeout
operator|=
name|CHOKED_TIMEOUT
expr_stmt|;
name|bundle
operator|.
name|phys_type
operator|.
name|all
operator|=
name|type
expr_stmt|;
name|bundle
operator|.
name|phys_type
operator|.
name|open
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|links
operator|=
name|datalink_Create
argument_list|(
literal|"deflink"
argument_list|,
operator|&
name|bundle
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|.
name|links
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"Cannot create data link: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|iface_Destroy
argument_list|(
name|bundle
operator|.
name|iface
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|iface
operator|=
name|NULL
expr_stmt|;
name|close
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bundle
operator|.
name|desc
operator|.
name|type
operator|=
name|BUNDLE_DESCRIPTOR
expr_stmt|;
name|bundle
operator|.
name|desc
operator|.
name|UpdateSet
operator|=
name|bundle_UpdateSet
expr_stmt|;
name|bundle
operator|.
name|desc
operator|.
name|IsSet
operator|=
name|bundle_IsSet
expr_stmt|;
name|bundle
operator|.
name|desc
operator|.
name|Read
operator|=
name|bundle_DescriptorRead
expr_stmt|;
name|bundle
operator|.
name|desc
operator|.
name|Write
operator|=
name|bundle_DescriptorWrite
expr_stmt|;
name|mp_Init
argument_list|(
operator|&
name|bundle
operator|.
name|ncp
operator|.
name|mp
argument_list|,
operator|&
name|bundle
argument_list|)
expr_stmt|;
comment|/* Send over the first physical link by default */
name|ipcp_Init
argument_list|(
operator|&
name|bundle
operator|.
name|ncp
operator|.
name|ipcp
argument_list|,
operator|&
name|bundle
argument_list|,
operator|&
name|bundle
operator|.
name|links
operator|->
name|physical
operator|->
name|link
argument_list|,
operator|&
name|bundle
operator|.
name|fsm
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|bundle
operator|.
name|filter
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|bundle
operator|.
name|filter
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|in
operator|.
name|fragok
operator|=
name|bundle
operator|.
name|filter
operator|.
name|in
operator|.
name|logok
operator|=
literal|1
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|in
operator|.
name|name
operator|=
literal|"IN"
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|out
operator|.
name|fragok
operator|=
name|bundle
operator|.
name|filter
operator|.
name|out
operator|.
name|logok
operator|=
literal|1
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|out
operator|.
name|name
operator|=
literal|"OUT"
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|dial
operator|.
name|name
operator|=
literal|"DIAL"
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|dial
operator|.
name|logok
operator|=
literal|1
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|alive
operator|.
name|name
operator|=
literal|"ALIVE"
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|alive
operator|.
name|logok
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|bundle
operator|.
name|idle
operator|.
name|timer
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|bundle
operator|.
name|idle
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|idle
operator|.
name|done
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|notify
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|bundle
operator|.
name|autoload
operator|.
name|timer
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|bundle
operator|.
name|autoload
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|autoload
operator|.
name|done
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|autoload
operator|.
name|running
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|bundle
operator|.
name|choked
operator|.
name|timer
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|bundle
operator|.
name|choked
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* Clean out any leftover crud */
name|iface_Clear
argument_list|(
name|bundle
operator|.
name|iface
argument_list|,
name|IFACE_CLEAR_ALL
argument_list|)
expr_stmt|;
name|bundle_LockTun
argument_list|(
operator|&
name|bundle
argument_list|)
expr_stmt|;
return|return
operator|&
name|bundle
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_DownInterface
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|struct
name|ifreq
name|ifrq
decl_stmt|;
name|int
name|s
decl_stmt|;
name|route_IfDelete
argument_list|(
name|bundle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|ID0socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_DownInterface: socket: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
operator|&
name|ifrq
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|ifrq
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ifrq
operator|.
name|ifr_name
argument_list|,
name|bundle
operator|->
name|iface
operator|->
name|name
argument_list|,
sizeof|sizeof
name|ifrq
operator|.
name|ifr_name
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ifrq
operator|.
name|ifr_name
index|[
sizeof|sizeof
name|ifrq
operator|.
name|ifr_name
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ID0ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|&
name|ifrq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_DownInterface: ioctl(SIOCGIFFLAGS): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifrq
operator|.
name|ifr_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
if|if
condition|(
name|ID0ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|&
name|ifrq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_DownInterface: ioctl(SIOCSIFFLAGS): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_Destroy
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
comment|/*    * Clean up the interface.  We don't need to timer_Stop()s, mp_Down(),    * ipcp_CleanInterface() and bundle_DownInterface() unless we're getting    * out under exceptional conditions such as a descriptor exception.    */
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|idle
operator|.
name|timer
argument_list|)
expr_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|choked
operator|.
name|timer
argument_list|)
expr_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|autoload
operator|.
name|timer
argument_list|)
expr_stmt|;
name|mp_Down
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
name|ipcp_CleanInterface
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
name|bundle_DownInterface
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
comment|/* Again, these are all DATALINK_CLOSED unless we're abending */
name|dl
operator|=
name|bundle
operator|->
name|links
expr_stmt|;
while|while
condition|(
name|dl
condition|)
name|dl
operator|=
name|datalink_Destroy
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
name|bundle_UnlockTun
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
comment|/* In case we never made PHASE_NETWORK */
name|bundle_Notify
argument_list|(
name|bundle
argument_list|,
name|EX_ERRDEAD
argument_list|)
expr_stmt|;
name|iface_Destroy
argument_list|(
name|bundle
operator|->
name|iface
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|iface
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|rtmsg
block|{
name|struct
name|rt_msghdr
name|m_rtm
decl_stmt|;
name|char
name|m_space
index|[
literal|64
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|bundle_SetRoute
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|cmd
parameter_list|,
name|struct
name|in_addr
name|dst
parameter_list|,
name|struct
name|in_addr
name|gateway
parameter_list|,
name|struct
name|in_addr
name|mask
parameter_list|,
name|int
name|bang
parameter_list|,
name|int
name|ssh
parameter_list|)
block|{
name|struct
name|rtmsg
name|rtmes
decl_stmt|;
name|int
name|s
decl_stmt|,
name|nb
decl_stmt|,
name|wb
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmdstr
decl_stmt|;
name|struct
name|sockaddr_in
name|rtdata
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|bang
condition|)
name|cmdstr
operator|=
operator|(
name|cmd
operator|==
name|RTM_ADD
condition|?
literal|"Add!"
else|:
literal|"Delete!"
operator|)
expr_stmt|;
else|else
name|cmdstr
operator|=
operator|(
name|cmd
operator|==
name|RTM_ADD
condition|?
literal|"Add"
else|:
literal|"Delete"
operator|)
expr_stmt|;
name|s
operator|=
name|ID0socket
argument_list|(
name|PF_ROUTE
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_SetRoute: socket(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
name|memset
argument_list|(
operator|&
name|rtmes
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|rtmes
argument_list|)
expr_stmt|;
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_version
operator|=
name|RTM_VERSION
expr_stmt|;
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_type
operator|=
name|cmd
expr_stmt|;
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_addrs
operator|=
name|RTA_DST
expr_stmt|;
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_seq
operator|=
operator|++
name|bundle
operator|->
name|routing_seq
expr_stmt|;
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_flags
operator|=
name|RTF_UP
operator||
name|RTF_GATEWAY
operator||
name|RTF_STATIC
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|RTM_ADD
operator|||
name|cmd
operator|==
name|RTM_CHANGE
condition|)
block|{
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|sendpipe
operator|>
literal|0
condition|)
block|{
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_rmx
operator|.
name|rmx_sendpipe
operator|=
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|sendpipe
expr_stmt|;
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_inits
operator||=
name|RTV_SPIPE
expr_stmt|;
block|}
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|recvpipe
operator|>
literal|0
condition|)
block|{
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_rmx
operator|.
name|rmx_recvpipe
operator|=
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|recvpipe
expr_stmt|;
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_inits
operator||=
name|RTV_RPIPE
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|&
name|rtdata
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|rtdata
argument_list|)
expr_stmt|;
name|rtdata
operator|.
name|sin_len
operator|=
sizeof|sizeof
name|rtdata
expr_stmt|;
name|rtdata
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|rtdata
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
name|rtdata
operator|.
name|sin_addr
operator|=
name|dst
expr_stmt|;
name|cp
operator|=
name|rtmes
operator|.
name|m_space
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
operator|&
name|rtdata
argument_list|,
name|rtdata
operator|.
name|sin_len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rtdata
operator|.
name|sin_len
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|RTM_ADD
condition|)
block|{
if|if
condition|(
name|gateway
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
if|if
condition|(
operator|!
name|ssh
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_SetRoute: Cannot add a route with"
literal|" destination 0.0.0.0\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
name|rtdata
operator|.
name|sin_addr
operator|=
name|gateway
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
operator|&
name|rtdata
argument_list|,
name|rtdata
operator|.
name|sin_len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rtdata
operator|.
name|sin_len
expr_stmt|;
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_addrs
operator||=
name|RTA_GATEWAY
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dst
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|mask
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|RTM_ADD
operator|||
name|dst
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|rtdata
operator|.
name|sin_addr
operator|=
name|mask
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
operator|&
name|rtdata
argument_list|,
name|rtdata
operator|.
name|sin_len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rtdata
operator|.
name|sin_len
expr_stmt|;
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_addrs
operator||=
name|RTA_NETMASK
expr_stmt|;
block|}
name|nb
operator|=
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|rtmes
expr_stmt|;
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_msglen
operator|=
name|nb
expr_stmt|;
name|wb
operator|=
name|ID0write
argument_list|(
name|s
argument_list|,
operator|&
name|rtmes
argument_list|,
name|nb
argument_list|)
expr_stmt|;
if|if
condition|(
name|wb
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogTCPIP
argument_list|,
literal|"bundle_SetRoute failure:\n"
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogTCPIP
argument_list|,
literal|"bundle_SetRoute:  Cmd = %s\n"
argument_list|,
name|cmdstr
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogTCPIP
argument_list|,
literal|"bundle_SetRoute:  Dst = %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogTCPIP
argument_list|,
literal|"bundle_SetRoute:  Gateway = %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|gateway
argument_list|)
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogTCPIP
argument_list|,
literal|"bundle_SetRoute:  Mask = %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|mask
argument_list|)
argument_list|)
expr_stmt|;
name|failed
label|:
if|if
condition|(
name|cmd
operator|==
name|RTM_ADD
operator|&&
operator|(
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_errno
operator|==
name|EEXIST
operator|||
operator|(
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_errno
operator|==
literal|0
operator|&&
name|errno
operator|==
name|EEXIST
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|bang
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Add route failed: %s already exists\n"
argument_list|,
name|dst
operator|.
name|s_addr
operator|==
literal|0
condition|?
literal|"default"
else|:
name|inet_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
comment|/* Don't add to our dynamic list */
block|}
else|else
block|{
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_type
operator|=
name|cmd
operator|=
name|RTM_CHANGE
expr_stmt|;
if|if
condition|(
operator|(
name|wb
operator|=
name|ID0write
argument_list|(
name|s
argument_list|,
operator|&
name|rtmes
argument_list|,
name|nb
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|failed
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|RTM_DELETE
operator|&&
operator|(
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_errno
operator|==
name|ESRCH
operator|||
operator|(
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_errno
operator|==
literal|0
operator|&&
name|errno
operator|==
name|ESRCH
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|bang
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Del route failed: %s: Non-existent\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_errno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|ssh
operator|||
name|errno
operator|!=
name|ENETUNREACH
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s route failed: %s: errno: %s\n"
argument_list|,
name|cmdstr
argument_list|,
name|inet_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s route failed: %s: %s\n"
argument_list|,
name|cmdstr
argument_list|,
name|inet_ntoa
argument_list|(
name|dst
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|rtmes
operator|.
name|m_rtm
operator|.
name|rtm_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"wrote %d: cmd = %s, dst = %x, gateway = %x\n"
argument_list|,
name|wb
argument_list|,
name|cmdstr
argument_list|,
operator|(
name|unsigned
operator|)
name|dst
operator|.
name|s_addr
argument_list|,
operator|(
name|unsigned
operator|)
name|gateway
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|bundle_LinkClosed
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|)
block|{
comment|/*    * Our datalink has closed.    * CleanDatalinks() (called from DoLoop()) will remove closed    * BACKGROUND and DIRECT links.    * If it's the last data link, enter phase DEAD.    *    * NOTE: dl may not be in our list (bundle_SendDatalink()) !    */
name|struct
name|datalink
modifier|*
name|odl
decl_stmt|;
name|int
name|other_links
decl_stmt|;
name|log_SetTtyCommandMode
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|other_links
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|odl
operator|=
name|bundle
operator|->
name|links
init|;
name|odl
condition|;
name|odl
operator|=
name|odl
operator|->
name|next
control|)
if|if
condition|(
name|odl
operator|!=
name|dl
operator|&&
name|odl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
condition|)
name|other_links
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|other_links
condition|)
block|{
if|if
condition|(
name|dl
operator|->
name|physical
operator|->
name|type
operator|!=
name|PHYS_AUTO
condition|)
comment|/* Not in -auto mode */
name|bundle_DownInterface
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|fsm2initial
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
name|bundle_NewPhase
argument_list|(
name|bundle
argument_list|,
name|PHASE_DEAD
argument_list|)
expr_stmt|;
name|bundle_StopIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|bundle_StopAutoLoadTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|autoload
operator|.
name|running
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|bundle
operator|->
name|autoload
operator|.
name|running
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_Open
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mask
parameter_list|,
name|int
name|force
parameter_list|)
block|{
comment|/*    * Please open the given datalink, or all if name == NULL    */
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|autoload
operator|.
name|timer
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|!
name|strcasecmp
argument_list|(
name|dl
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
name|dl
operator|->
name|physical
operator|->
name|type
operator|)
operator|&&
operator|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_CLOSED
operator|||
operator|(
name|force
operator|&&
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPENING
operator|&&
name|dl
operator|->
name|dial_timer
operator|.
name|state
operator|==
name|TIMER_RUNNING
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|force
condition|)
name|timer_Stop
argument_list|(
operator|&
name|dl
operator|->
name|dial_timer
argument_list|)
expr_stmt|;
name|datalink_Up
argument_list|(
name|dl
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
name|PHYS_AUTO
condition|)
comment|/* Only one AUTO link at a time (see the AutoLoad timer) */
break|break;
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
end_function

begin_function
name|struct
name|datalink
modifier|*
name|bundle2datalink
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dl
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|dl
return|;
block|}
elseif|else
if|if
condition|(
name|bundle
operator|->
name|links
operator|&&
operator|!
name|bundle
operator|->
name|links
operator|->
name|next
condition|)
return|return
name|bundle
operator|->
name|links
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|bundle_FillQueues
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|int
name|total
decl_stmt|;
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|active
condition|)
name|total
operator|=
name|mp_FillQueues
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|int
name|add
decl_stmt|;
for|for
control|(
name|total
operator|=
literal|0
operator|,
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
block|{
name|add
operator|=
name|link_QueueLen
argument_list|(
operator|&
name|dl
operator|->
name|physical
operator|->
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
operator|==
literal|0
operator|&&
name|dl
operator|->
name|physical
operator|->
name|out
operator|==
name|NULL
condition|)
name|add
operator|=
name|ip_FlushPacket
argument_list|(
operator|&
name|dl
operator|->
name|physical
operator|->
name|link
argument_list|,
name|bundle
argument_list|)
expr_stmt|;
name|total
operator|+=
name|add
expr_stmt|;
block|}
block|}
return|return
name|total
operator|+
name|ip_QueueLen
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|bundle_ShowLinks
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
for|for
control|(
name|dl
operator|=
name|arg
operator|->
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Name: %s [%s, %s]"
argument_list|,
name|dl
operator|->
name|name
argument_list|,
name|mode2Nam
argument_list|(
name|dl
operator|->
name|physical
operator|->
name|type
argument_list|)
argument_list|,
name|datalink_State
argument_list|(
name|dl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|physical
operator|->
name|link
operator|.
name|throughput
operator|.
name|rolling
operator|&&
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" weight %d, %d bytes/sec"
argument_list|,
name|dl
operator|->
name|mp
operator|.
name|weight
argument_list|,
name|dl
operator|->
name|physical
operator|->
name|link
operator|.
name|throughput
operator|.
name|OctetsPerSecond
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|optval
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
return|return
operator|(
name|bundle
operator|->
name|cfg
operator|.
name|opt
operator|&
name|bit
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
return|;
block|}
end_function

begin_function
name|int
name|bundle_ShowStatus
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|remaining
decl_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Phase %s\n"
argument_list|,
name|bundle_PhaseName
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Title:         %s\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Device:        %s\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|dev
operator|.
name|Name
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Interface:     %s @ %lubps\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|iface
operator|->
name|name
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|ifSpeed
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\nDefaults:\n"
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Label:         %s\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|label
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Auth name:     %s\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Auto Load:     Up after %ds of>= %d packets\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|.
name|timeout
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|max
operator|.
name|packets
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"                Down after %ds of<= %d"
literal|" packets\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|timeout
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|autoload
operator|.
name|min
operator|.
name|packets
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|autoload
operator|.
name|timer
operator|.
name|state
operator|==
name|TIMER_RUNNING
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"                %ds remaining 'till "
literal|"a link comes %s\n"
argument_list|,
name|bundle_RemainingAutoLoadTime
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|autoload
operator|.
name|comingup
condition|?
literal|"up"
else|:
literal|"down"
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"                %srunning with %d"
literal|" packets queued\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|autoload
operator|.
name|running
condition|?
literal|""
else|:
literal|"not "
argument_list|,
name|ip_QueueLen
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Choked Timer:  %ds\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|choked
operator|.
name|timeout
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Idle Timer:    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|idle_timeout
condition|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%ds"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|idle_timeout
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|bundle_RemainingIdleTime
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
expr_stmt|;
if|if
condition|(
name|remaining
operator|!=
operator|-
literal|1
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" (%ds remaining)"
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"disabled\n"
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" MTU:           "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|mtu
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%d\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|mtu
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"unspecified\n"
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" sendpipe:      "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|sendpipe
operator|>
literal|0
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%ld\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|sendpipe
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"unspecified\n"
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" recvpipe:      "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|recvpipe
operator|>
literal|0
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%ld\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|recvpipe
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"unspecified\n"
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Sticky Routes: %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_SROUTES
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" ID check:      %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_IDCHECK
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Loopback:      %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_LOOPBACK
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" PasswdAuth:    %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_PASSWDAUTH
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Proxy:         %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_PROXY
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Proxyall:      %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_PROXYALL
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Throughput:    %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_THROUGHPUT
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Utmp Logging:  %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_UTMP
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Iface-Alias:   %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_IFACEALIAS
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_IdleTimeout
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|bundle
modifier|*
name|bundle
init|=
operator|(
expr|struct
name|bundle
operator|*
operator|)
name|v
decl_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Idle timer expired.\n"
argument_list|)
expr_stmt|;
name|bundle_StopIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|bundle_Close
argument_list|(
name|bundle
argument_list|,
name|NULL
argument_list|,
name|CLOSE_STAYDOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Start Idle timer. If timeout is reached, we call bundle_Close() to  *  close LCP and link.  */
end_comment

begin_function
name|void
name|bundle_StartIdleTimer
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|idle
operator|.
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|&
operator|(
name|PHYS_DEDICATED
operator||
name|PHYS_DDIAL
operator|)
operator|)
operator|!=
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|&&
name|bundle
operator|->
name|cfg
operator|.
name|idle_timeout
condition|)
block|{
name|bundle
operator|->
name|idle
operator|.
name|timer
operator|.
name|func
operator|=
name|bundle_IdleTimeout
expr_stmt|;
name|bundle
operator|->
name|idle
operator|.
name|timer
operator|.
name|name
operator|=
literal|"idle"
expr_stmt|;
name|bundle
operator|->
name|idle
operator|.
name|timer
operator|.
name|load
operator|=
name|bundle
operator|->
name|cfg
operator|.
name|idle_timeout
operator|*
name|SECTICKS
expr_stmt|;
name|bundle
operator|->
name|idle
operator|.
name|timer
operator|.
name|arg
operator|=
name|bundle
expr_stmt|;
name|timer_Start
argument_list|(
operator|&
name|bundle
operator|->
name|idle
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|idle
operator|.
name|done
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|+
name|bundle
operator|->
name|cfg
operator|.
name|idle_timeout
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bundle_SetIdleTimer
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|bundle
operator|->
name|cfg
operator|.
name|idle_timeout
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|bundle_LinkIsUp
argument_list|(
name|bundle
argument_list|)
condition|)
name|bundle_StartIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_StopIdleTimer
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|idle
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|idle
operator|.
name|done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bundle_RemainingIdleTime
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
if|if
condition|(
name|bundle
operator|->
name|idle
operator|.
name|done
condition|)
return|return
name|bundle
operator|->
name|idle
operator|.
name|done
operator|-
name|time
argument_list|(
name|NULL
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|bundle_IsDead
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
return|return
operator|!
name|bundle
operator|->
name|links
operator|||
operator|(
name|bundle
operator|->
name|phase
operator|==
name|PHASE_DEAD
operator|&&
name|bundle
operator|->
name|CleaningUp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|datalink
modifier|*
name|bundle_DatalinkLinkout
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
modifier|*
name|dlp
decl_stmt|;
for|for
control|(
name|dlp
operator|=
operator|&
name|bundle
operator|->
name|links
init|;
operator|*
name|dlp
condition|;
name|dlp
operator|=
operator|&
operator|(
operator|*
name|dlp
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|*
name|dlp
operator|==
name|dl
condition|)
block|{
operator|*
name|dlp
operator|=
name|dl
operator|->
name|next
expr_stmt|;
name|dl
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|bundle_LinksRemoved
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
return|return
name|dl
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_DatalinkLinkin
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
modifier|*
name|dlp
init|=
operator|&
name|bundle
operator|->
name|links
decl_stmt|;
while|while
condition|(
operator|*
name|dlp
condition|)
name|dlp
operator|=
operator|&
operator|(
operator|*
name|dlp
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|dlp
operator|=
name|dl
expr_stmt|;
name|dl
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|bundle_LinkAdded
argument_list|(
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_CleanDatalinks
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
modifier|*
name|dlp
init|=
operator|&
name|bundle
operator|->
name|links
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|dlp
condition|)
if|if
condition|(
operator|(
operator|*
name|dlp
operator|)
operator|->
name|state
operator|==
name|DATALINK_CLOSED
operator|&&
operator|(
operator|*
name|dlp
operator|)
operator|->
name|physical
operator|->
name|type
operator|&
operator|(
name|PHYS_DIRECT
operator||
name|PHYS_BACKGROUND
operator|)
condition|)
block|{
operator|*
name|dlp
operator|=
name|datalink_Destroy
argument_list|(
operator|*
name|dlp
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
else|else
name|dlp
operator|=
operator|&
operator|(
operator|*
name|dlp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|found
condition|)
name|bundle_LinksRemoved
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bundle_DatalinkClone
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|bundle2datalink
argument_list|(
name|bundle
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Clone: %s: name already exists\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bundle_DatalinkLinkin
argument_list|(
name|bundle
argument_list|,
name|datalink_Clone
argument_list|(
name|dl
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|bundle_DatalinkRemove
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|)
block|{
name|dl
operator|=
name|bundle_DatalinkLinkout
argument_list|(
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
condition|)
name|datalink_Destroy
argument_list|(
name|dl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_SetLabel
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
if|if
condition|(
name|label
condition|)
name|strncpy
argument_list|(
name|bundle
operator|->
name|cfg
operator|.
name|label
argument_list|,
name|label
argument_list|,
sizeof|sizeof
name|bundle
operator|->
name|cfg
operator|.
name|label
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|bundle
operator|->
name|cfg
operator|.
name|label
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|bundle_GetLabel
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
return|return
operator|*
name|bundle
operator|->
name|cfg
operator|.
name|label
condition|?
name|bundle
operator|->
name|cfg
operator|.
name|label
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|bundle_ReceiveDatalink
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|s
parameter_list|,
name|struct
name|sockaddr_un
modifier|*
name|sun
parameter_list|)
block|{
name|char
name|cmsgbuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|cmsghdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmsg
init|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|cmsgbuf
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
name|SCATTER_SEGMENTS
index|]
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|int
name|niov
decl_stmt|,
name|link_fd
decl_stmt|,
name|expect
decl_stmt|,
name|f
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Receiving datalink\n"
argument_list|)
expr_stmt|;
comment|/* Create our scatter/gather array */
name|niov
operator|=
literal|1
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|Version
argument_list|)
operator|+
literal|1
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalink2iov
argument_list|(
name|NULL
argument_list|,
name|iov
argument_list|,
operator|&
name|niov
argument_list|,
sizeof|sizeof
name|iov
operator|/
sizeof|sizeof
expr|*
name|iov
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|write
argument_list|(
name|s
argument_list|,
operator|&
name|pid
argument_list|,
sizeof|sizeof
name|pid
argument_list|)
expr_stmt|;
for|for
control|(
name|f
operator|=
name|expect
operator|=
literal|0
init|;
name|f
operator|<
name|niov
condition|;
name|f
operator|++
control|)
name|expect
operator|+=
name|iov
index|[
name|f
index|]
operator|.
name|iov_len
expr_stmt|;
comment|/* Set up our message */
name|cmsg
operator|->
name|cmsg_len
operator|=
sizeof|sizeof
name|cmsgbuf
expr_stmt|;
name|cmsg
operator|->
name|cmsg_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|cmsg
operator|->
name|cmsg_type
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_name
operator|=
operator|(
name|caddr_t
operator|)
name|sun
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
sizeof|sizeof
expr|*
name|sun
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
name|niov
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|cmsgbuf
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
name|cmsgbuf
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Expecting %d scatter/gather bytes\n"
argument_list|,
name|expect
argument_list|)
expr_stmt|;
name|f
operator|=
name|expect
operator|+
literal|100
expr_stmt|;
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|f
argument_list|,
sizeof|sizeof
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|recvmsg
argument_list|(
name|s
argument_list|,
operator|&
name|msg
argument_list|,
name|MSG_WAITALL
argument_list|)
operator|)
operator|!=
name|expect
condition|)
block|{
if|if
condition|(
name|f
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed recvmsg: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed recvmsg: Got %d, not %d\n"
argument_list|,
name|f
argument_list|,
name|expect
argument_list|)
expr_stmt|;
while|while
condition|(
name|niov
operator|--
condition|)
name|free
argument_list|(
name|iov
index|[
name|niov
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|write
argument_list|(
name|s
argument_list|,
literal|"!"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* ACK */
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmsg
operator|->
name|cmsg_type
operator|!=
name|SCM_RIGHTS
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Recvmsg: no descriptor received !\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|niov
operator|--
condition|)
name|free
argument_list|(
name|iov
index|[
name|niov
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We've successfully received an open file descriptor through our socket */
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Receiving device descriptor\n"
argument_list|)
expr_stmt|;
name|link_fd
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|Version
argument_list|,
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Cannot receive datalink, incorrect version"
literal|" (\"%.*s\", not \"%s\")\n"
argument_list|,
operator|(
name|int
operator|)
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|,
operator|(
name|char
operator|*
operator|)
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
name|Version
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|link_fd
argument_list|)
expr_stmt|;
while|while
condition|(
name|niov
operator|--
condition|)
name|free
argument_list|(
name|iov
index|[
name|niov
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
return|return;
block|}
name|niov
operator|=
literal|1
expr_stmt|;
name|dl
operator|=
name|iov2datalink
argument_list|(
name|bundle
argument_list|,
name|iov
argument_list|,
operator|&
name|niov
argument_list|,
sizeof|sizeof
name|iov
operator|/
sizeof|sizeof
expr|*
name|iov
argument_list|,
name|link_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
condition|)
block|{
name|bundle_DatalinkLinkin
argument_list|(
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
name|datalink_AuthOk
argument_list|(
name|dl
argument_list|)
expr_stmt|;
block|}
else|else
name|close
argument_list|(
name|link_fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_SendDatalink
parameter_list|(
name|struct
name|datalink
modifier|*
name|dl
parameter_list|,
name|int
name|s
parameter_list|,
name|struct
name|sockaddr_un
modifier|*
name|sun
parameter_list|)
block|{
name|char
name|cmsgbuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|cmsghdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|,
name|ack
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmsg
init|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|cmsgbuf
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
name|SCATTER_SEGMENTS
index|]
decl_stmt|;
name|int
name|niov
decl_stmt|,
name|link_fd
decl_stmt|,
name|f
decl_stmt|,
name|expect
decl_stmt|,
name|newsid
decl_stmt|;
name|pid_t
name|newpid
decl_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Transmitting datalink %s\n"
argument_list|,
name|dl
operator|->
name|name
argument_list|)
expr_stmt|;
name|bundle_LinkClosed
argument_list|(
name|dl
operator|->
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
name|bundle_DatalinkLinkout
argument_list|(
name|dl
operator|->
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
comment|/* Build our scatter/gather array */
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|Version
argument_list|)
operator|+
literal|1
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|strdup
argument_list|(
name|Version
argument_list|)
expr_stmt|;
name|niov
operator|=
literal|1
expr_stmt|;
name|read
argument_list|(
name|s
argument_list|,
operator|&
name|newpid
argument_list|,
sizeof|sizeof
name|newpid
argument_list|)
expr_stmt|;
name|link_fd
operator|=
name|datalink2iov
argument_list|(
name|dl
argument_list|,
name|iov
argument_list|,
operator|&
name|niov
argument_list|,
sizeof|sizeof
name|iov
operator|/
sizeof|sizeof
expr|*
name|iov
argument_list|,
name|newpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|link_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_name
operator|=
operator|(
name|caddr_t
operator|)
name|sun
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
sizeof|sizeof
expr|*
name|sun
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
name|niov
expr_stmt|;
name|cmsg
operator|->
name|cmsg_len
operator|=
sizeof|sizeof
name|cmsgbuf
expr_stmt|;
name|cmsg
operator|->
name|cmsg_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|cmsg
operator|->
name|cmsg_type
operator|=
name|SCM_RIGHTS
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsg
argument_list|)
operator|=
name|link_fd
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|cmsgbuf
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
name|cmsgbuf
expr_stmt|;
for|for
control|(
name|f
operator|=
name|expect
operator|=
literal|0
init|;
name|f
operator|<
name|niov
condition|;
name|f
operator|++
control|)
name|expect
operator|+=
name|iov
index|[
name|f
index|]
operator|.
name|iov_len
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Sending %d bytes in scatter/gather array\n"
argument_list|,
name|expect
argument_list|)
expr_stmt|;
name|f
operator|=
name|expect
operator|+
name|SOCKET_OVERHEAD
expr_stmt|;
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|&
name|f
argument_list|,
sizeof|sizeof
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendmsg
argument_list|(
name|s
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed sendmsg: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We must get the ACK before closing the descriptor ! */
name|read
argument_list|(
name|s
argument_list|,
operator|&
name|ack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newsid
operator|=
name|tcgetpgrp
argument_list|(
name|link_fd
argument_list|)
operator|==
name|getpgrp
argument_list|()
expr_stmt|;
name|close
argument_list|(
name|link_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsid
condition|)
name|bundle_setsid
argument_list|(
name|dl
operator|->
name|bundle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|niov
operator|--
condition|)
name|free
argument_list|(
name|iov
index|[
name|niov
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bundle_RenameDatalink
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|ndl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|ndl
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dl
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
name|datalink_Rename
argument_list|(
name|ndl
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|bundle_SetMode
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|omode
decl_stmt|;
name|omode
operator|=
name|dl
operator|->
name|physical
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|omode
operator|==
name|mode
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|mode
operator|==
name|PHYS_AUTO
operator|&&
operator|!
operator|(
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|&
name|PHYS_AUTO
operator|)
condition|)
comment|/* First auto link */
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|peer_ip
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"You must `set ifaddr' or `open' before"
literal|" changing mode to %s\n"
argument_list|,
name|mode2Nam
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|datalink_SetMode
argument_list|(
name|dl
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|==
name|PHYS_AUTO
operator|&&
operator|!
operator|(
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|&
name|PHYS_AUTO
operator|)
operator|&&
name|bundle
operator|->
name|phase
operator|!=
name|PHASE_NETWORK
condition|)
comment|/* First auto link, we need an interface */
name|ipcp_InterfaceUp
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
comment|/* Regenerate phys_type and adjust autoload& idle timers */
name|bundle_LinksRemoved
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|bundle_setsid
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|holdsession
parameter_list|)
block|{
comment|/*    * Lose the current session.  This means getting rid of our pid    * too so that the tty device will really go away, and any getty    * etc will be allowed to restart.    */
name|pid_t
name|pid
decl_stmt|,
name|orig
decl_stmt|;
name|int
name|fds
index|[
literal|2
index|]
decl_stmt|;
name|char
name|done
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|orig
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fds
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"pipe: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"fork: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|,
operator|&
name|done
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* uu_locks are mine ! */
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fds
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"pipe(2): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"fork(2): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bundle_LockTun
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
comment|/* update pid */
name|read
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|,
operator|&
name|done
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* uu_locks are mine ! */
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|setsid
argument_list|()
expr_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"%d -> %d: %s session control\n"
argument_list|,
operator|(
name|int
operator|)
name|orig
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|holdsession
condition|?
literal|"Passed"
else|:
literal|"Dropped"
argument_list|)
expr_stmt|;
name|timer_InitService
argument_list|()
expr_stmt|;
break|break;
default|default:
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Give away all our modem locks (to the final process) */
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
condition|)
name|modem_ChangedPid
argument_list|(
name|dl
operator|->
name|physical
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|,
literal|"!"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* done */
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Give away all our modem locks (to the intermediate process) */
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
condition|)
name|modem_ChangedPid
argument_list|(
name|dl
operator|->
name|physical
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|,
literal|"!"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* done */
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|holdsession
condition|)
block|{
name|int
name|fd
decl_stmt|,
name|status
decl_stmt|;
name|timer_TermService
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
name|getdtablesize
argument_list|()
init|;
name|fd
operator|>=
literal|0
condition|;
name|fd
operator|--
control|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
comment|/*          * Reap the intermediate process.  As we're not exiting but the          * intermediate is, we don't want it to become defunct.          */
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Tweak our process arguments.... */
name|bundle
operator|->
name|argv
index|[
literal|0
index|]
operator|=
literal|"session owner"
expr_stmt|;
name|bundle
operator|->
name|argv
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
comment|/*          * Hang around for a HUP.  This should happen as soon as the          * ppp that we passed our ctty descriptor to closes it.          * NOTE: If this process dies, the passed descriptor becomes          *       invalid and will give a select() error by setting one          *       of the error fds, aborting the other ppp.  We don't          *       want that to happen !          */
name|pause
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|bundle_HighestState
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|int
name|result
init|=
name|DATALINK_CLOSED
decl_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|result
operator|<
name|dl
operator|->
name|state
condition|)
name|result
operator|=
name|dl
operator|->
name|state
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|bundle_Exception
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|physical
operator|->
name|fd
operator|==
name|fd
condition|)
block|{
name|datalink_Down
argument_list|(
name|dl
argument_list|,
name|CLOSE_NORMAL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

