begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Brian Somers<brian@Awfulhak.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_tun.h>
end_include

begin_comment
comment|/* For TUNS* ioctls */
end_comment

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NOKLDLOAD
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|NOSUID
end_ifdef

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"layer.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"iplist.h"
end_include

begin_include
include|#
directive|include
file|"lqr.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"throughput.h"
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"filter.h"
end_include

begin_include
include|#
directive|include
file|"descriptor.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ccp.h"
end_include

begin_include
include|#
directive|include
file|"link.h"
end_include

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NORADIUS
end_ifndef

begin_include
include|#
directive|include
file|"radius.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bundle.h"
end_include

begin_include
include|#
directive|include
file|"async.h"
end_include

begin_include
include|#
directive|include
file|"physical.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"tun.h"
end_include

begin_include
include|#
directive|include
file|"prompt.h"
end_include

begin_include
include|#
directive|include
file|"chat.h"
end_include

begin_include
include|#
directive|include
file|"cbcp.h"
end_include

begin_include
include|#
directive|include
file|"datalink.h"
end_include

begin_include
include|#
directive|include
file|"ip.h"
end_include

begin_include
include|#
directive|include
file|"iface.h"
end_include

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DES
end_ifdef

begin_include
include|#
directive|include
file|"mppe.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SCATTER_SEGMENTS
value|7
end_define

begin_comment
comment|/* version, datalink, name, physical,                                throughput, throughput, device       */
end_comment

begin_define
define|#
directive|define
name|SEND_MAXFD
value|3
end_define

begin_comment
comment|/* Max file descriptors passed through                                the local domain socket              */
end_comment

begin_function_decl
specifier|static
name|int
name|bundle_RemainingIdleTime
parameter_list|(
name|struct
name|bundle
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|PhaseNames
index|[]
init|=
block|{
literal|"Dead"
block|,
literal|"Establish"
block|,
literal|"Authenticate"
block|,
literal|"Network"
block|,
literal|"Terminate"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|bundle_PhaseName
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
return|return
name|bundle
operator|->
name|phase
operator|<=
name|PHASE_TERMINATE
condition|?
name|PhaseNames
index|[
name|bundle
operator|->
name|phase
index|]
else|:
literal|"unknown"
return|;
block|}
end_function

begin_function
name|void
name|bundle_NewPhase
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|u_int
name|new
parameter_list|)
block|{
if|if
condition|(
name|new
operator|==
name|bundle
operator|->
name|phase
condition|)
return|return;
if|if
condition|(
name|new
operator|<=
name|PHASE_TERMINATE
condition|)
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"bundle: %s\n"
argument_list|,
name|PhaseNames
index|[
name|new
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|new
condition|)
block|{
case|case
name|PHASE_DEAD
case|:
name|bundle
operator|->
name|phase
operator|=
name|new
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DES
name|MPPE_MasterKeyValid
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|log_DisplayPrompts
argument_list|()
expr_stmt|;
break|break;
case|case
name|PHASE_ESTABLISH
case|:
name|bundle
operator|->
name|phase
operator|=
name|new
expr_stmt|;
break|break;
case|case
name|PHASE_AUTHENTICATE
case|:
name|bundle
operator|->
name|phase
operator|=
name|new
expr_stmt|;
name|log_DisplayPrompts
argument_list|()
expr_stmt|;
break|break;
case|case
name|PHASE_NETWORK
case|:
name|fsm_Up
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
name|fsm_Open
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|phase
operator|=
name|new
expr_stmt|;
name|log_DisplayPrompts
argument_list|()
expr_stmt|;
break|break;
case|case
name|PHASE_TERMINATE
case|:
name|bundle
operator|->
name|phase
operator|=
name|new
expr_stmt|;
name|mp_Down
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
name|log_DisplayPrompts
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_LayerStart
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/* The given FSM is about to start up ! */
block|}
end_function

begin_function
name|void
name|bundle_Notify
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
name|bundle
operator|->
name|notify
operator|.
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|bundle
operator|->
name|notify
operator|.
name|fd
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EX_REDIAL
operator|&&
name|c
operator|!=
name|EX_RECONNECT
condition|)
block|{
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Parent notified of %s\n"
argument_list|,
name|c
operator|==
name|EX_NORMAL
condition|?
literal|"success"
else|:
literal|"failure"
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed to notify parent of success\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bundle
operator|->
name|notify
operator|.
name|fd
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|notify
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Parent notified of %s\n"
argument_list|,
name|ex_desc
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed to notify parent of %s\n"
argument_list|,
name|ex_desc
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_ClearQueues
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|bundle
modifier|*
name|bundle
init|=
operator|(
expr|struct
name|bundle
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Clearing choked output queue\n"
argument_list|)
expr_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|choked
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/*    * Emergency time:    *    * We've had a full queue for PACKET_DEL_SECS seconds without being    * able to get rid of any of the packets.  We've probably given up    * on the redials at this point, and the queued data has almost    * definitely been timed out by the layer above.  As this is preventing    * us from reading the TUN_NAME device (we don't want to buffer stuff    * indefinitely), we may as well nuke this data and start with a clean    * slate !    *    * Unfortunately, this has the side effect of shafting any compression    * dictionaries in use (causing the relevant RESET_REQ/RESET_ACK).    */
name|ip_DeleteQueue
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
name|mp_DeleteQueue
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|physical_DeleteQueue
argument_list|(
name|dl
operator|->
name|physical
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_LinkAdded
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|)
block|{
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator||=
name|dl
operator|->
name|physical
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator||=
name|dl
operator|->
name|physical
operator|->
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|&
operator|(
name|PHYS_DEDICATED
operator||
name|PHYS_DDIAL
operator|)
operator|)
operator|!=
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|&&
name|bundle
operator|->
name|idle
operator|.
name|timer
operator|.
name|state
operator|==
name|TIMER_STOPPED
condition|)
comment|/* We may need to start our idle timer */
name|bundle_StartIdleTimer
argument_list|(
name|bundle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_LinksRemoved
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|=
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|bundle_LinkAdded
argument_list|(
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
name|bundle_CalculateBandwidth
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|mp_CheckAutoloadTimer
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|&
operator|(
name|PHYS_DEDICATED
operator||
name|PHYS_DDIAL
operator|)
operator|)
operator|==
name|bundle
operator|->
name|phys_type
operator|.
name|open
condition|)
name|bundle_StopIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_LayerUp
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/*    * The given fsm is now up    * If it's an LCP, adjust our phys_mode.open value and check the    * autoload timer.    * If it's the first NCP, calculate our bandwidth    * If it's the first NCP, set our ``upat'' time    * If it's the first NCP, start the idle timer.    * If it's an NCP, tell our -background parent to go away.    * If it's the first NCP, start the autoload timer    */
name|struct
name|bundle
modifier|*
name|bundle
init|=
operator|(
expr|struct
name|bundle
operator|*
operator|)
name|v
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_LCP
condition|)
block|{
name|struct
name|physical
modifier|*
name|p
init|=
name|link2physical
argument_list|(
name|fp
operator|->
name|link
argument_list|)
decl_stmt|;
name|bundle_LinkAdded
argument_list|(
name|bundle
argument_list|,
name|p
operator|->
name|dl
argument_list|)
expr_stmt|;
name|mp_CheckAutoloadTimer
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_IPCP
condition|)
block|{
name|bundle_CalculateBandwidth
argument_list|(
name|fp
operator|->
name|bundle
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|bundle
operator|->
name|upat
argument_list|)
expr_stmt|;
name|bundle_StartIdleTimer
argument_list|(
name|bundle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bundle_Notify
argument_list|(
name|bundle
argument_list|,
name|EX_NORMAL
argument_list|)
expr_stmt|;
name|mp_CheckAutoloadTimer
argument_list|(
operator|&
name|fp
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_CCP
condition|)
name|bundle_CalculateBandwidth
argument_list|(
name|fp
operator|->
name|bundle
argument_list|)
expr_stmt|;
comment|/* Against ccp_MTUOverhead */
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_LayerDown
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/*    * The given FSM has been told to come down.    * If it's our last NCP, stop the idle timer.    * If it's our last NCP, clear our ``upat'' value.    * If it's our last NCP, stop the autoload timer    * If it's an LCP, adjust our phys_type.open value and any timers.    * If it's an LCP and we're in multilink mode, adjust our tun    * If it's the last LCP, down all NCPs    * speed and make sure our minimum sequence number is adjusted.    */
name|struct
name|bundle
modifier|*
name|bundle
init|=
operator|(
expr|struct
name|bundle
operator|*
operator|)
name|v
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_IPCP
condition|)
block|{
name|bundle_StopIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|upat
operator|=
literal|0
expr_stmt|;
name|mp_StopAutoloadTimer
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_LCP
condition|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|struct
name|datalink
modifier|*
name|lost
decl_stmt|;
name|int
name|others_active
decl_stmt|;
name|bundle_LinksRemoved
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
comment|/* adjust timers& phys_type values */
name|lost
operator|=
name|NULL
expr_stmt|;
name|others_active
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|fp
operator|==
operator|&
name|dl
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|fsm
condition|)
name|lost
operator|=
name|dl
expr_stmt|;
elseif|else
if|if
condition|(
name|dl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
operator|&&
name|dl
operator|->
name|state
operator|!=
name|DATALINK_HANGUP
condition|)
name|others_active
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|active
condition|)
block|{
name|bundle_CalculateBandwidth
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
if|if
condition|(
name|lost
condition|)
name|mp_LinkLost
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|,
name|lost
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"Oops, lost an unrecognised datalink (%s) !\n"
argument_list|,
name|fp
operator|->
name|link
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|others_active
condition|)
comment|/* Down the NCPs.  We don't expect to get fsm_Close()d ourself ! */
name|fsm2initial
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_LayerFinish
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/* The given fsm is now down (fp cannot be NULL)    *    * If it's the last NCP, fsm_Close all LCPs    */
name|struct
name|bundle
modifier|*
name|bundle
init|=
operator|(
expr|struct
name|bundle
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|proto
operator|==
name|PROTO_IPCP
condition|)
block|{
if|if
condition|(
name|bundle_Phase
argument_list|(
name|bundle
argument_list|)
operator|!=
name|PHASE_DEAD
condition|)
name|bundle_NewPhase
argument_list|(
name|bundle
argument_list|,
name|PHASE_TERMINATE
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
name|datalink_Close
argument_list|(
name|dl
argument_list|,
name|CLOSE_STAYDOWN
argument_list|)
expr_stmt|;
name|fsm2initial
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|bundle_LinkIsUp
parameter_list|(
specifier|const
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
return|return
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|ST_OPENED
return|;
block|}
end_function

begin_function
name|void
name|bundle_Close
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|how
parameter_list|)
block|{
comment|/*    * Please close the given datalink.    * If name == NULL or name is the last datalink, fsm_Close all NCPs    * (except our MP)    * If it isn't the last datalink, just Close that datalink.    */
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|,
modifier|*
name|this_dl
decl_stmt|;
name|int
name|others_active
decl_stmt|;
name|others_active
operator|=
literal|0
expr_stmt|;
name|this_dl
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|name
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|dl
operator|->
name|name
argument_list|)
condition|)
name|this_dl
operator|=
name|dl
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
name|this_dl
operator|==
name|dl
condition|)
block|{
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|CLOSE_LCP
case|:
name|datalink_DontHangup
argument_list|(
name|dl
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLOSE_STAYDOWN
case|:
name|datalink_StayDown
argument_list|(
name|dl
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|dl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
operator|&&
name|dl
operator|->
name|state
operator|!=
name|DATALINK_HANGUP
condition|)
name|others_active
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|&&
name|this_dl
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Invalid datalink name\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|others_active
condition|)
block|{
name|bundle_StopIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
operator|.
name|state
operator|>
name|ST_CLOSED
operator|||
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|ST_STARTING
condition|)
name|fsm_Close
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
else|else
block|{
name|fsm2initial
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|datalink_Close
argument_list|(
name|dl
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|this_dl
operator|&&
name|this_dl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
operator|&&
name|this_dl
operator|->
name|state
operator|!=
name|DATALINK_HANGUP
condition|)
name|datalink_Close
argument_list|(
name|this_dl
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_Down
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|datalink_Down
argument_list|(
name|dl
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|bundle_FillQueues
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|size_t
name|total
decl_stmt|;
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|active
condition|)
name|total
operator|=
name|mp_FillQueues
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|size_t
name|add
decl_stmt|;
for|for
control|(
name|total
operator|=
literal|0
operator|,
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
block|{
name|add
operator|=
name|link_QueueLen
argument_list|(
operator|&
name|dl
operator|->
name|physical
operator|->
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|add
operator|==
literal|0
operator|&&
name|dl
operator|->
name|physical
operator|->
name|out
operator|==
name|NULL
condition|)
name|add
operator|=
name|ip_PushPacket
argument_list|(
operator|&
name|dl
operator|->
name|physical
operator|->
name|link
argument_list|,
name|bundle
argument_list|)
expr_stmt|;
name|total
operator|+=
name|add
expr_stmt|;
block|}
block|}
return|return
name|total
operator|+
name|ip_QueueLen
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bundle_UpdateSet
parameter_list|(
name|struct
name|fdescriptor
modifier|*
name|d
parameter_list|,
name|fd_set
modifier|*
name|r
parameter_list|,
name|fd_set
modifier|*
name|w
parameter_list|,
name|fd_set
modifier|*
name|e
parameter_list|,
name|int
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|bundle
modifier|*
name|bundle
init|=
name|descriptor2bundle
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|int
name|result
decl_stmt|,
name|nlinks
decl_stmt|;
name|u_short
name|ifqueue
decl_stmt|;
name|size_t
name|queued
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
comment|/* If there are aren't many packets queued, look for some more. */
for|for
control|(
name|nlinks
operator|=
literal|0
operator|,
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|nlinks
operator|++
expr_stmt|;
if|if
condition|(
name|nlinks
condition|)
block|{
name|queued
operator|=
name|r
condition|?
name|bundle_FillQueues
argument_list|(
name|bundle
argument_list|)
else|:
name|ip_QueueLen
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&&
operator|(
name|bundle
operator|->
name|phase
operator|==
name|PHASE_NETWORK
operator|||
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|&
name|PHYS_AUTO
operator|)
condition|)
block|{
comment|/* enough surplus so that we can tell if we're getting swamped */
name|ifqueue
operator|=
name|nlinks
operator|>
name|bundle
operator|->
name|cfg
operator|.
name|ifqueue
condition|?
name|nlinks
else|:
name|bundle
operator|->
name|cfg
operator|.
name|ifqueue
expr_stmt|;
if|if
condition|(
name|queued
operator|<
name|ifqueue
condition|)
block|{
comment|/* Not enough - select() for more */
if|if
condition|(
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|state
operator|==
name|TIMER_RUNNING
condition|)
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|choked
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* Not needed any more */
name|FD_SET
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|n
operator|<
name|bundle
operator|->
name|dev
operator|.
name|fd
operator|+
literal|1
condition|)
operator|*
name|n
operator|=
name|bundle
operator|->
name|dev
operator|.
name|fd
operator|+
literal|1
expr_stmt|;
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"%s: fdset(r) %d\n"
argument_list|,
name|TUN_NAME
argument_list|,
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
name|result
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|state
operator|==
name|TIMER_STOPPED
condition|)
block|{
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|func
operator|=
name|bundle_ClearQueues
expr_stmt|;
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|name
operator|=
literal|"output choke"
expr_stmt|;
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|load
operator|=
name|bundle
operator|->
name|cfg
operator|.
name|choked
operator|.
name|timeout
operator|*
name|SECTICKS
expr_stmt|;
name|bundle
operator|->
name|choked
operator|.
name|timer
operator|.
name|arg
operator|=
name|bundle
expr_stmt|;
name|timer_Start
argument_list|(
operator|&
name|bundle
operator|->
name|choked
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifndef|#
directive|ifndef
name|NORADIUS
name|result
operator|+=
name|descriptor_UpdateSet
argument_list|(
operator|&
name|bundle
operator|->
name|radius
operator|.
name|desc
argument_list|,
name|r
argument_list|,
name|w
argument_list|,
name|e
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Which links need a select() ? */
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
name|result
operator|+=
name|descriptor_UpdateSet
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|r
argument_list|,
name|w
argument_list|,
name|e
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/*    * This *MUST* be called after the datalink UpdateSet()s as it    * might be ``holding'' one of the datalinks (death-row) and    * wants to be able to de-select() it from the descriptor set.    */
name|result
operator|+=
name|descriptor_UpdateSet
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|r
argument_list|,
name|w
argument_list|,
name|e
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bundle_IsSet
parameter_list|(
name|struct
name|fdescriptor
modifier|*
name|d
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|bundle
modifier|*
name|bundle
init|=
name|descriptor2bundle
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
return|return
literal|1
return|;
ifndef|#
directive|ifndef
name|NORADIUS
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|bundle
operator|->
name|radius
operator|.
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
name|FD_ISSET
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|,
name|fdset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_DescriptorRead
parameter_list|(
name|struct
name|fdescriptor
modifier|*
name|d
parameter_list|,
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|unsigned
name|secs
decl_stmt|;
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
name|descriptor_Read
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|bundle
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
name|descriptor_Read
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|bundle
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NORADIUS
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|bundle
operator|->
name|radius
operator|.
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
name|descriptor_Read
argument_list|(
operator|&
name|bundle
operator|->
name|radius
operator|.
name|desc
argument_list|,
name|bundle
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|FD_ISSET
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|,
name|fdset
argument_list|)
condition|)
block|{
name|struct
name|tun_data
name|tun
decl_stmt|;
name|int
name|n
decl_stmt|,
name|pri
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
if|if
condition|(
name|bundle
operator|->
name|dev
operator|.
name|header
condition|)
block|{
name|data
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|tun
expr_stmt|;
name|sz
operator|=
sizeof|sizeof
name|tun
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|tun
operator|.
name|data
expr_stmt|;
name|sz
operator|=
sizeof|sizeof
name|tun
operator|.
name|data
expr_stmt|;
block|}
comment|/* something to read from tun */
name|n
operator|=
name|read
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|,
name|data
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: read: %s\n"
argument_list|,
name|bundle
operator|->
name|dev
operator|.
name|Name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bundle
operator|->
name|dev
operator|.
name|header
condition|)
block|{
name|n
operator|-=
name|sz
operator|-
sizeof|sizeof
name|tun
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"%s: read: Got only %d bytes of data !\n"
argument_list|,
name|bundle
operator|->
name|dev
operator|.
name|Name
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|tun
operator|.
name|header
operator|.
name|family
argument_list|)
operator|!=
name|AF_INET
condition|)
comment|/* XXX: Should be maintaining drop/family counts ! */
return|return;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|tun
operator|.
name|data
operator|)
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|my_ip
operator|.
name|s_addr
condition|)
block|{
comment|/* we've been asked to send something addressed *to* us :( */
if|if
condition|(
name|Enabled
argument_list|(
name|bundle
argument_list|,
name|OPT_LOOPBACK
argument_list|)
condition|)
block|{
name|pri
operator|=
name|PacketCheck
argument_list|(
name|bundle
argument_list|,
name|tun
operator|.
name|data
argument_list|,
name|n
argument_list|,
operator|&
name|bundle
operator|->
name|filter
operator|.
name|in
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|>=
literal|0
condition|)
block|{
name|n
operator|+=
name|sz
operator|-
sizeof|sizeof
name|tun
operator|.
name|data
expr_stmt|;
name|write
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|,
name|data
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Looped back packet addressed to myself\n"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
else|else
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Oops - forwarding packet addressed to myself\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Process on-demand dialup. Output packets are queued within tunnel      * device until IPCP is opened.      */
if|if
condition|(
name|bundle_Phase
argument_list|(
name|bundle
argument_list|)
operator|==
name|PHASE_DEAD
condition|)
block|{
comment|/*        * Note, we must be in AUTO mode :-/ otherwise our interface should        * *not* be UP and we can't receive data        */
name|pri
operator|=
name|PacketCheck
argument_list|(
name|bundle
argument_list|,
name|tun
operator|.
name|data
argument_list|,
name|n
argument_list|,
operator|&
name|bundle
operator|->
name|filter
operator|.
name|dial
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|>=
literal|0
condition|)
name|bundle_Open
argument_list|(
name|bundle
argument_list|,
name|NULL
argument_list|,
name|PHYS_AUTO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/*          * Drop the packet.  If we were to queue it, we'd just end up with          * a pile of timed-out data in our output queue by the time we get          * around to actually dialing.  We'd also prematurely reach the           * threshold at which we stop select()ing to read() the tun          * device - breaking auto-dial.          */
return|return;
block|}
name|secs
operator|=
literal|0
expr_stmt|;
name|pri
operator|=
name|PacketCheck
argument_list|(
name|bundle
argument_list|,
name|tun
operator|.
name|data
argument_list|,
name|n
argument_list|,
operator|&
name|bundle
operator|->
name|filter
operator|.
name|out
argument_list|,
name|NULL
argument_list|,
operator|&
name|secs
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|>=
literal|0
condition|)
block|{
comment|/* Prepend the number of seconds timeout given in the filter */
name|tun
operator|.
name|header
operator|.
name|timeout
operator|=
name|secs
expr_stmt|;
name|ip_Enqueue
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|,
name|pri
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tun
argument_list|,
name|n
operator|+
sizeof|sizeof
name|tun
operator|.
name|header
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bundle_DescriptorWrite
parameter_list|(
name|struct
name|fdescriptor
modifier|*
name|d
parameter_list|,
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
comment|/* This is not actually necessary as struct mpserver doesn't Write() */
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
name|descriptor_Write
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|server
operator|.
name|desc
argument_list|,
name|bundle
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|descriptor_IsSet
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|fdset
argument_list|)
condition|)
name|result
operator|+=
name|descriptor_Write
argument_list|(
operator|&
name|dl
operator|->
name|desc
argument_list|,
name|bundle
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|bundle_LockTun
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|FILE
modifier|*
name|lockfile
decl_stmt|;
name|char
name|pidfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|pidfile
argument_list|,
sizeof|sizeof
name|pidfile
argument_list|,
literal|"%stun%d.pid"
argument_list|,
name|_PATH_VARRUN
argument_list|,
name|bundle
operator|->
name|unit
argument_list|)
expr_stmt|;
name|lockfile
operator|=
name|ID0fopen
argument_list|(
name|pidfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockfile
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|lockfile
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|RELEASE_CRUNCH
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Warning: Can't create %s: %s\n"
argument_list|,
name|pidfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_UnlockTun
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|char
name|pidfile
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|pidfile
argument_list|,
sizeof|sizeof
name|pidfile
argument_list|,
literal|"%stun%d.pid"
argument_list|,
name|_PATH_VARRUN
argument_list|,
name|bundle
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ID0unlink
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|bundle
modifier|*
name|bundle_Create
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
specifier|static
name|struct
name|bundle
name|bundle
decl_stmt|;
comment|/* there can be only one */
name|int
name|enoentcount
decl_stmt|,
name|err
decl_stmt|,
name|minunit
decl_stmt|,
name|maxunit
decl_stmt|;
specifier|const
name|char
modifier|*
name|ifname
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NOKLDLOAD
argument_list|)
name|int
name|kldtried
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|TUNSIFMODE
argument_list|)
operator|||
name|defined
argument_list|(
name|TUNSLMODE
argument_list|)
operator|||
name|defined
argument_list|(
name|TUNSIFHEAD
argument_list|)
name|int
name|iff
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bundle
operator|.
name|iface
operator|!=
name|NULL
condition|)
block|{
comment|/* Already allocated ! */
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"bundle_Create:  There's only one BUNDLE !\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
condition|)
block|{
name|minunit
operator|=
literal|0
expr_stmt|;
name|maxunit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|minunit
operator|=
name|unit
expr_stmt|;
name|maxunit
operator|=
name|unit
operator|+
literal|1
expr_stmt|;
block|}
name|err
operator|=
name|ENOENT
expr_stmt|;
name|enoentcount
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NOKLDLOAD
argument_list|)
name|kldtried
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|bundle
operator|.
name|unit
operator|=
name|minunit
init|;
name|bundle
operator|.
name|unit
operator|!=
name|maxunit
condition|;
name|bundle
operator|.
name|unit
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|Name
argument_list|,
sizeof|sizeof
name|bundle
operator|.
name|dev
operator|.
name|Name
argument_list|,
literal|"%s%d"
argument_list|,
name|prefix
argument_list|,
name|bundle
operator|.
name|unit
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|dev
operator|.
name|fd
operator|=
name|ID0open
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|Name
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|.
name|dev
operator|.
name|fd
operator|>=
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|errno
operator|==
name|ENXIO
operator|||
name|errno
operator|==
name|ENOENT
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NOKLDLOAD
argument_list|)
if|if
condition|(
name|bundle
operator|.
name|unit
operator|==
name|minunit
operator|&&
operator|!
name|kldtried
operator|++
condition|)
block|{
comment|/* 	 * Attempt to load the tunnel interface KLD if it isn't loaded 	 * already.          */
if|if
condition|(
name|modfind
argument_list|(
literal|"if_tun"
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ID0kldload
argument_list|(
literal|"if_tun"
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|bundle
operator|.
name|unit
operator|--
expr_stmt|;
continue|continue;
block|}
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"kldload: if_tun: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|||
operator|++
name|enoentcount
operator|>
literal|2
condition|)
block|{
name|err
operator|=
name|errno
expr_stmt|;
break|break;
block|}
block|}
else|else
name|err
operator|=
name|errno
expr_stmt|;
block|}
if|if
condition|(
name|bundle
operator|.
name|dev
operator|.
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|unit
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"No available tunnel devices found (%s)\n"
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s%d: %s\n"
argument_list|,
name|prefix
argument_list|,
name|unit
argument_list|,
name|strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|log_SetTun
argument_list|(
name|bundle
operator|.
name|unit
argument_list|)
expr_stmt|;
name|ifname
operator|=
name|strrchr
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|Name
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifname
operator|==
name|NULL
condition|)
name|ifname
operator|=
name|bundle
operator|.
name|dev
operator|.
name|Name
expr_stmt|;
else|else
name|ifname
operator|++
expr_stmt|;
name|bundle
operator|.
name|iface
operator|=
name|iface_Create
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|.
name|iface
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|TUNSIFMODE
comment|/* Make sure we're POINTOPOINT */
name|iff
operator|=
name|IFF_POINTOPOINT
expr_stmt|;
if|if
condition|(
name|ID0ioctl
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|fd
argument_list|,
name|TUNSIFMODE
argument_list|,
operator|&
name|iff
argument_list|)
operator|<
literal|0
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_Create: ioctl(TUNSIFMODE): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TUNSLMODE
comment|/* Make sure we're not prepending sockaddrs */
name|iff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ID0ioctl
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|fd
argument_list|,
name|TUNSLMODE
argument_list|,
operator|&
name|iff
argument_list|)
operator|<
literal|0
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_Create: ioctl(TUNSLMODE): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TUNSIFHEAD
comment|/* We want the address family please ! */
name|iff
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ID0ioctl
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|fd
argument_list|,
name|TUNSIFHEAD
argument_list|,
operator|&
name|iff
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_Create: ioctl(TUNSIFHEAD): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|dev
operator|.
name|header
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|bundle
operator|.
name|dev
operator|.
name|header
operator|=
literal|1
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|__OpenBSD__
comment|/* Always present for OpenBSD */
name|bundle
operator|.
name|dev
operator|.
name|header
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/*    * If TUNSIFHEAD isn't available and we're not OpenBSD, assume    * everything's AF_INET (hopefully the tun device won't pass us    * anything else !).    */
name|bundle
operator|.
name|dev
operator|.
name|header
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
operator|!
name|iface_SetFlags
argument_list|(
name|bundle
operator|.
name|iface
operator|->
name|name
argument_list|,
name|IFF_UP
argument_list|)
condition|)
block|{
name|iface_Destroy
argument_list|(
name|bundle
operator|.
name|iface
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|iface
operator|=
name|NULL
expr_stmt|;
name|close
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Using interface: %s\n"
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|bandwidth
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|routing_seq
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|phase
operator|=
name|PHASE_DEAD
expr_stmt|;
name|bundle
operator|.
name|CleaningUp
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|NatEnabled
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|fsm
operator|.
name|LayerStart
operator|=
name|bundle_LayerStart
expr_stmt|;
name|bundle
operator|.
name|fsm
operator|.
name|LayerUp
operator|=
name|bundle_LayerUp
expr_stmt|;
name|bundle
operator|.
name|fsm
operator|.
name|LayerDown
operator|=
name|bundle_LayerDown
expr_stmt|;
name|bundle
operator|.
name|fsm
operator|.
name|LayerFinish
operator|=
name|bundle_LayerFinish
expr_stmt|;
name|bundle
operator|.
name|fsm
operator|.
name|object
operator|=
operator|&
name|bundle
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|idle
operator|.
name|timeout
operator|=
name|NCP_IDLE_TIMEOUT
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|idle
operator|.
name|min_timeout
operator|=
literal|0
expr_stmt|;
operator|*
name|bundle
operator|.
name|cfg
operator|.
name|auth
operator|.
name|name
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|bundle
operator|.
name|cfg
operator|.
name|auth
operator|.
name|key
operator|=
literal|'\0'
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|opt
operator|=
name|OPT_SROUTES
operator||
name|OPT_IDCHECK
operator||
name|OPT_LOOPBACK
operator||
name|OPT_TCPMSSFIXUP
operator||
name|OPT_THROUGHPUT
operator||
name|OPT_UTMP
expr_stmt|;
operator|*
name|bundle
operator|.
name|cfg
operator|.
name|label
operator|=
literal|'\0'
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|ifqueue
operator|=
name|DEF_IFQUEUE
expr_stmt|;
name|bundle
operator|.
name|cfg
operator|.
name|choked
operator|.
name|timeout
operator|=
name|CHOKED_TIMEOUT
expr_stmt|;
name|bundle
operator|.
name|phys_type
operator|.
name|all
operator|=
name|type
expr_stmt|;
name|bundle
operator|.
name|phys_type
operator|.
name|open
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|upat
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|links
operator|=
name|datalink_Create
argument_list|(
literal|"deflink"
argument_list|,
operator|&
name|bundle
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|.
name|links
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"Cannot create data link: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|iface_Destroy
argument_list|(
name|bundle
operator|.
name|iface
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|iface
operator|=
name|NULL
expr_stmt|;
name|close
argument_list|(
name|bundle
operator|.
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bundle
operator|.
name|desc
operator|.
name|type
operator|=
name|BUNDLE_DESCRIPTOR
expr_stmt|;
name|bundle
operator|.
name|desc
operator|.
name|UpdateSet
operator|=
name|bundle_UpdateSet
expr_stmt|;
name|bundle
operator|.
name|desc
operator|.
name|IsSet
operator|=
name|bundle_IsSet
expr_stmt|;
name|bundle
operator|.
name|desc
operator|.
name|Read
operator|=
name|bundle_DescriptorRead
expr_stmt|;
name|bundle
operator|.
name|desc
operator|.
name|Write
operator|=
name|bundle_DescriptorWrite
expr_stmt|;
name|mp_Init
argument_list|(
operator|&
name|bundle
operator|.
name|ncp
operator|.
name|mp
argument_list|,
operator|&
name|bundle
argument_list|)
expr_stmt|;
comment|/* Send over the first physical link by default */
name|ipcp_Init
argument_list|(
operator|&
name|bundle
operator|.
name|ncp
operator|.
name|ipcp
argument_list|,
operator|&
name|bundle
argument_list|,
operator|&
name|bundle
operator|.
name|links
operator|->
name|physical
operator|->
name|link
argument_list|,
operator|&
name|bundle
operator|.
name|fsm
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|bundle
operator|.
name|filter
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|bundle
operator|.
name|filter
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|in
operator|.
name|fragok
operator|=
name|bundle
operator|.
name|filter
operator|.
name|in
operator|.
name|logok
operator|=
literal|1
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|in
operator|.
name|name
operator|=
literal|"IN"
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|out
operator|.
name|fragok
operator|=
name|bundle
operator|.
name|filter
operator|.
name|out
operator|.
name|logok
operator|=
literal|1
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|out
operator|.
name|name
operator|=
literal|"OUT"
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|dial
operator|.
name|name
operator|=
literal|"DIAL"
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|dial
operator|.
name|logok
operator|=
literal|1
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|alive
operator|.
name|name
operator|=
literal|"ALIVE"
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|alive
operator|.
name|logok
operator|=
literal|1
expr_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXFILTERS
condition|;
name|i
operator|++
control|)
block|{
name|bundle
operator|.
name|filter
operator|.
name|in
operator|.
name|rule
index|[
name|i
index|]
operator|.
name|f_action
operator|=
name|A_NONE
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|out
operator|.
name|rule
index|[
name|i
index|]
operator|.
name|f_action
operator|=
name|A_NONE
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|dial
operator|.
name|rule
index|[
name|i
index|]
operator|.
name|f_action
operator|=
name|A_NONE
expr_stmt|;
name|bundle
operator|.
name|filter
operator|.
name|alive
operator|.
name|rule
index|[
name|i
index|]
operator|.
name|f_action
operator|=
name|A_NONE
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|&
name|bundle
operator|.
name|idle
operator|.
name|timer
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|bundle
operator|.
name|idle
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bundle
operator|.
name|idle
operator|.
name|done
operator|=
literal|0
expr_stmt|;
name|bundle
operator|.
name|notify
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|bundle
operator|.
name|choked
operator|.
name|timer
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|bundle
operator|.
name|choked
operator|.
name|timer
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NORADIUS
name|radius_Init
argument_list|(
operator|&
name|bundle
operator|.
name|radius
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Clean out any leftover crud */
name|iface_Clear
argument_list|(
name|bundle
operator|.
name|iface
argument_list|,
name|IFACE_CLEAR_ALL
argument_list|)
expr_stmt|;
name|bundle_LockTun
argument_list|(
operator|&
name|bundle
argument_list|)
expr_stmt|;
return|return
operator|&
name|bundle
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_DownInterface
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|route_IfDelete
argument_list|(
name|bundle
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|iface_ClearFlags
argument_list|(
name|bundle
operator|->
name|iface
operator|->
name|name
argument_list|,
name|IFF_UP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_Destroy
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
comment|/*    * Clean up the interface.  We don't need to timer_Stop()s, mp_Down(),    * ipcp_CleanInterface() and bundle_DownInterface() unless we're getting    * out under exceptional conditions such as a descriptor exception.    */
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|idle
operator|.
name|timer
argument_list|)
expr_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|choked
operator|.
name|timer
argument_list|)
expr_stmt|;
name|mp_Down
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
name|ipcp_CleanInterface
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
name|bundle_DownInterface
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NORADIUS
comment|/* Tell the radius server the bad news */
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Radius: Destroy called from bundle_Destroy\n"
argument_list|)
expr_stmt|;
name|radius_Destroy
argument_list|(
operator|&
name|bundle
operator|->
name|radius
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Again, these are all DATALINK_CLOSED unless we're abending */
name|dl
operator|=
name|bundle
operator|->
name|links
expr_stmt|;
while|while
condition|(
name|dl
condition|)
name|dl
operator|=
name|datalink_Destroy
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|ipcp_Destroy
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|)
expr_stmt|;
name|bundle_UnlockTun
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
comment|/* In case we never made PHASE_NETWORK */
name|bundle_Notify
argument_list|(
name|bundle
argument_list|,
name|EX_ERRDEAD
argument_list|)
expr_stmt|;
name|iface_Destroy
argument_list|(
name|bundle
operator|->
name|iface
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|iface
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_LinkClosed
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|)
block|{
comment|/*    * Our datalink has closed.    * CleanDatalinks() (called from DoLoop()) will remove closed    * BACKGROUND, FOREGROUND and DIRECT links.    * If it's the last data link, enter phase DEAD.    *    * NOTE: dl may not be in our list (bundle_SendDatalink()) !    */
name|struct
name|datalink
modifier|*
name|odl
decl_stmt|;
name|int
name|other_links
decl_stmt|;
name|log_SetTtyCommandMode
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|other_links
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|odl
operator|=
name|bundle
operator|->
name|links
init|;
name|odl
condition|;
name|odl
operator|=
name|odl
operator|->
name|next
control|)
if|if
condition|(
name|odl
operator|!=
name|dl
operator|&&
name|odl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
condition|)
name|other_links
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|other_links
condition|)
block|{
if|if
condition|(
name|dl
operator|->
name|physical
operator|->
name|type
operator|!=
name|PHYS_AUTO
condition|)
comment|/* Not in -auto mode */
name|bundle_DownInterface
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|fsm2initial
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|fsm
argument_list|)
expr_stmt|;
name|bundle_NewPhase
argument_list|(
name|bundle
argument_list|,
name|PHASE_DEAD
argument_list|)
expr_stmt|;
name|bundle_StopIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bundle_Open
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mask
parameter_list|,
name|int
name|force
parameter_list|)
block|{
comment|/*    * Please open the given datalink, or all if name == NULL    */
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|!
name|strcasecmp
argument_list|(
name|dl
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|mask
operator|&
name|dl
operator|->
name|physical
operator|->
name|type
operator|)
operator|&&
operator|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_CLOSED
operator|||
operator|(
name|force
operator|&&
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPENING
operator|&&
name|dl
operator|->
name|dial
operator|.
name|timer
operator|.
name|state
operator|==
name|TIMER_RUNNING
operator|)
operator|||
name|dl
operator|->
name|state
operator|==
name|DATALINK_READY
operator|)
condition|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|dl
operator|->
name|dial
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* We're finished with this */
name|datalink_Up
argument_list|(
name|dl
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|PHYS_AUTO
condition|)
break|break;
comment|/* Only one AUTO link at a time */
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
end_function

begin_function
name|struct
name|datalink
modifier|*
name|bundle2datalink
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dl
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|dl
return|;
block|}
elseif|else
if|if
condition|(
name|bundle
operator|->
name|links
operator|&&
operator|!
name|bundle
operator|->
name|links
operator|->
name|next
condition|)
return|return
name|bundle
operator|->
name|links
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|bundle_ShowLinks
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|struct
name|pppThroughput
modifier|*
name|t
decl_stmt|;
name|unsigned
name|long
name|long
name|octets
decl_stmt|;
name|int
name|secs
decl_stmt|;
for|for
control|(
name|dl
operator|=
name|arg
operator|->
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
name|octets
operator|=
name|MAX
argument_list|(
name|dl
operator|->
name|physical
operator|->
name|link
operator|.
name|stats
operator|.
name|total
operator|.
name|in
operator|.
name|OctetsPerSecond
argument_list|,
name|dl
operator|->
name|physical
operator|->
name|link
operator|.
name|stats
operator|.
name|total
operator|.
name|out
operator|.
name|OctetsPerSecond
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Name: %s [%s, %s]"
argument_list|,
name|dl
operator|->
name|name
argument_list|,
name|mode2Nam
argument_list|(
name|dl
operator|->
name|physical
operator|->
name|type
argument_list|)
argument_list|,
name|datalink_State
argument_list|(
name|dl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|physical
operator|->
name|link
operator|.
name|stats
operator|.
name|total
operator|.
name|rolling
operator|&&
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" bandwidth %d, %llu bps (%llu bytes/sec)"
argument_list|,
name|dl
operator|->
name|mp
operator|.
name|bandwidth
condition|?
name|dl
operator|->
name|mp
operator|.
name|bandwidth
else|:
name|physical_GetSpeed
argument_list|(
name|dl
operator|->
name|physical
argument_list|)
argument_list|,
name|octets
operator|*
literal|8
argument_list|,
name|octets
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|link
operator|.
name|stats
operator|.
name|total
expr_stmt|;
name|octets
operator|=
name|MAX
argument_list|(
name|t
operator|->
name|in
operator|.
name|OctetsPerSecond
argument_list|,
name|t
operator|->
name|out
operator|.
name|OctetsPerSecond
argument_list|)
expr_stmt|;
name|secs
operator|=
name|t
operator|->
name|downtime
condition|?
literal|0
else|:
name|throughput_uptime
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|secs
operator|>
name|t
operator|->
name|SamplePeriod
condition|)
name|secs
operator|=
name|t
operator|->
name|SamplePeriod
expr_stmt|;
if|if
condition|(
name|secs
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Currently averaging %llu bps (%llu bytes/sec)"
literal|" over the last %d secs\n"
argument_list|,
name|octets
operator|*
literal|8
argument_list|,
name|octets
argument_list|,
name|secs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|optval
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
return|return
operator|(
name|bundle
operator|->
name|cfg
operator|.
name|opt
operator|&
name|bit
operator|)
condition|?
literal|"enabled"
else|:
literal|"disabled"
return|;
block|}
end_function

begin_function
name|int
name|bundle_ShowStatus
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|remaining
decl_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"Phase %s\n"
argument_list|,
name|bundle_PhaseName
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Device:        %s\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|dev
operator|.
name|Name
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Interface:     %s @ %lubps"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|iface
operator|->
name|name
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|bandwidth
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|upat
condition|)
block|{
name|int
name|secs
init|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|-
name|arg
operator|->
name|bundle
operator|->
name|upat
decl_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|", up time %d:%02d:%02d"
argument_list|,
name|secs
operator|/
literal|3600
argument_list|,
operator|(
name|secs
operator|/
literal|60
operator|)
operator|%
literal|60
argument_list|,
name|secs
operator|%
literal|60
argument_list|)
expr_stmt|;
block|}
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n Queued:        %lu of %u\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ip_QueueLen
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|ifqueue
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\nDefaults:\n"
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Label:             %s\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|label
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Auth name:         %s\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Diagnostic socket: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|server
operator|.
name|cfg
operator|.
name|sockname
operator|!=
literal|'\0'
condition|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%s"
argument_list|,
name|server
operator|.
name|cfg
operator|.
name|sockname
argument_list|)
expr_stmt|;
if|if
condition|(
name|server
operator|.
name|cfg
operator|.
name|mask
operator|!=
operator|(
name|mode_t
operator|)
operator|-
literal|1
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|", mask 0%03o"
argument_list|,
operator|(
name|int
operator|)
name|server
operator|.
name|cfg
operator|.
name|mask
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%s\n"
argument_list|,
name|server
operator|.
name|fd
operator|==
operator|-
literal|1
condition|?
literal|" (not open)"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|server
operator|.
name|cfg
operator|.
name|port
operator|!=
literal|0
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"TCP port %d%s\n"
argument_list|,
name|server
operator|.
name|cfg
operator|.
name|port
argument_list|,
name|server
operator|.
name|fd
operator|==
operator|-
literal|1
condition|?
literal|" (not open)"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"none\n"
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Choked Timer:      %ds\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|choked
operator|.
name|timeout
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NORADIUS
name|radius_Show
argument_list|(
operator|&
name|arg
operator|->
name|bundle
operator|->
name|radius
argument_list|,
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Idle Timer:        "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|idle
operator|.
name|timeout
condition|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%ds"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|idle
operator|.
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|idle
operator|.
name|min_timeout
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|", min %ds"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|idle
operator|.
name|min_timeout
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|bundle_RemainingIdleTime
argument_list|(
name|arg
operator|->
name|bundle
argument_list|)
expr_stmt|;
if|if
condition|(
name|remaining
operator|!=
operator|-
literal|1
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" (%ds remaining)"
argument_list|,
name|remaining
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"disabled\n"
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" sendpipe:          "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|sendpipe
operator|>
literal|0
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%-20ld"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|sendpipe
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"unspecified         "
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" recvpipe:      "
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|recvpipe
operator|>
literal|0
condition|)
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%ld\n"
argument_list|,
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|cfg
operator|.
name|recvpipe
argument_list|)
expr_stmt|;
else|else
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"unspecified\n"
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Sticky Routes:     %-20.20s"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_SROUTES
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Filter Decap:      %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_FILTERDECAP
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" ID check:          %-20.20s"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_IDCHECK
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Keep-Session:      %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_KEEPSESSION
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Loopback:          %-20.20s"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_LOOPBACK
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" PasswdAuth:        %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_PASSWDAUTH
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Proxy:             %-20.20s"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_PROXY
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Proxyall:          %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_PROXYALL
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" TCPMSS Fixup:      %-20.20s"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_TCPMSSFIXUP
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Throughput:        %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_THROUGHPUT
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Utmp Logging:      %-20.20s"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_UTMP
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Iface-Alias:       %s\n"
argument_list|,
name|optval
argument_list|(
name|arg
operator|->
name|bundle
argument_list|,
name|OPT_IFACEALIAS
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_IdleTimeout
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|bundle
modifier|*
name|bundle
init|=
operator|(
expr|struct
name|bundle
operator|*
operator|)
name|v
decl_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Idle timer expired\n"
argument_list|)
expr_stmt|;
name|bundle_StopIdleTimer
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|bundle_Close
argument_list|(
name|bundle
argument_list|,
name|NULL
argument_list|,
name|CLOSE_STAYDOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Start Idle timer. If timeout is reached, we call bundle_Close() to  *  close LCP and link.  */
end_comment

begin_function
name|void
name|bundle_StartIdleTimer
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|unsigned
name|secs
parameter_list|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|idle
operator|.
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|&
operator|(
name|PHYS_DEDICATED
operator||
name|PHYS_DDIAL
operator|)
operator|)
operator|!=
name|bundle
operator|->
name|phys_type
operator|.
name|open
operator|&&
name|bundle
operator|->
name|cfg
operator|.
name|idle
operator|.
name|timeout
condition|)
block|{
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|secs
operator|==
literal|0
condition|)
name|secs
operator|=
name|bundle
operator|->
name|cfg
operator|.
name|idle
operator|.
name|timeout
expr_stmt|;
comment|/* We want at least `secs' */
if|if
condition|(
name|bundle
operator|->
name|cfg
operator|.
name|idle
operator|.
name|min_timeout
operator|>
name|secs
operator|&&
name|bundle
operator|->
name|upat
condition|)
block|{
name|int
name|up
init|=
name|now
operator|-
name|bundle
operator|->
name|upat
decl_stmt|;
if|if
condition|(
operator|(
name|long
name|long
operator|)
name|bundle
operator|->
name|cfg
operator|.
name|idle
operator|.
name|min_timeout
operator|-
name|up
operator|>
operator|(
name|long
name|long
operator|)
name|secs
condition|)
comment|/* Only increase from the current `remaining' value */
name|secs
operator|=
name|bundle
operator|->
name|cfg
operator|.
name|idle
operator|.
name|min_timeout
operator|-
name|up
expr_stmt|;
block|}
name|bundle
operator|->
name|idle
operator|.
name|timer
operator|.
name|func
operator|=
name|bundle_IdleTimeout
expr_stmt|;
name|bundle
operator|->
name|idle
operator|.
name|timer
operator|.
name|name
operator|=
literal|"idle"
expr_stmt|;
name|bundle
operator|->
name|idle
operator|.
name|timer
operator|.
name|load
operator|=
name|secs
operator|*
name|SECTICKS
expr_stmt|;
name|bundle
operator|->
name|idle
operator|.
name|timer
operator|.
name|arg
operator|=
name|bundle
expr_stmt|;
name|timer_Start
argument_list|(
operator|&
name|bundle
operator|->
name|idle
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|idle
operator|.
name|done
operator|=
name|now
operator|+
name|secs
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bundle_SetIdleTimer
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|min_timeout
parameter_list|)
block|{
name|bundle
operator|->
name|cfg
operator|.
name|idle
operator|.
name|timeout
operator|=
name|timeout
expr_stmt|;
if|if
condition|(
name|min_timeout
operator|>=
literal|0
condition|)
name|bundle
operator|->
name|cfg
operator|.
name|idle
operator|.
name|min_timeout
operator|=
name|min_timeout
expr_stmt|;
if|if
condition|(
name|bundle_LinkIsUp
argument_list|(
name|bundle
argument_list|)
condition|)
name|bundle_StartIdleTimer
argument_list|(
name|bundle
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_StopIdleTimer
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|bundle
operator|->
name|idle
operator|.
name|timer
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|idle
operator|.
name|done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bundle_RemainingIdleTime
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
if|if
condition|(
name|bundle
operator|->
name|idle
operator|.
name|done
condition|)
return|return
name|bundle
operator|->
name|idle
operator|.
name|done
operator|-
name|time
argument_list|(
name|NULL
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|bundle_IsDead
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
return|return
operator|!
name|bundle
operator|->
name|links
operator|||
operator|(
name|bundle
operator|->
name|phase
operator|==
name|PHASE_DEAD
operator|&&
name|bundle
operator|->
name|CleaningUp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|datalink
modifier|*
name|bundle_DatalinkLinkout
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
modifier|*
name|dlp
decl_stmt|;
for|for
control|(
name|dlp
operator|=
operator|&
name|bundle
operator|->
name|links
init|;
operator|*
name|dlp
condition|;
name|dlp
operator|=
operator|&
operator|(
operator|*
name|dlp
operator|)
operator|->
name|next
control|)
if|if
condition|(
operator|*
name|dlp
operator|==
name|dl
condition|)
block|{
operator|*
name|dlp
operator|=
name|dl
operator|->
name|next
expr_stmt|;
name|dl
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|bundle_LinksRemoved
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
return|return
name|dl
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bundle_DatalinkLinkin
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
modifier|*
name|dlp
init|=
operator|&
name|bundle
operator|->
name|links
decl_stmt|;
while|while
condition|(
operator|*
name|dlp
condition|)
name|dlp
operator|=
operator|&
operator|(
operator|*
name|dlp
operator|)
operator|->
name|next
expr_stmt|;
operator|*
name|dlp
operator|=
name|dl
expr_stmt|;
name|dl
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|bundle_LinkAdded
argument_list|(
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
name|mp_CheckAutoloadTimer
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_CleanDatalinks
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
modifier|*
name|dlp
init|=
operator|&
name|bundle
operator|->
name|links
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|dlp
condition|)
if|if
condition|(
operator|(
operator|*
name|dlp
operator|)
operator|->
name|state
operator|==
name|DATALINK_CLOSED
operator|&&
operator|(
operator|*
name|dlp
operator|)
operator|->
name|physical
operator|->
name|type
operator|&
operator|(
name|PHYS_DIRECT
operator||
name|PHYS_BACKGROUND
operator||
name|PHYS_FOREGROUND
operator|)
condition|)
block|{
operator|*
name|dlp
operator|=
name|datalink_Destroy
argument_list|(
operator|*
name|dlp
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
else|else
name|dlp
operator|=
operator|&
operator|(
operator|*
name|dlp
operator|)
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|found
condition|)
name|bundle_LinksRemoved
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bundle_DatalinkClone
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|bundle2datalink
argument_list|(
name|bundle
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Clone: %s: name already exists\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bundle_DatalinkLinkin
argument_list|(
name|bundle
argument_list|,
name|datalink_Clone
argument_list|(
name|dl
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|bundle_DatalinkRemove
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|)
block|{
name|dl
operator|=
name|bundle_DatalinkLinkout
argument_list|(
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
condition|)
name|datalink_Destroy
argument_list|(
name|dl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_SetLabel
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|char
modifier|*
name|label
parameter_list|)
block|{
if|if
condition|(
name|label
condition|)
name|strncpy
argument_list|(
name|bundle
operator|->
name|cfg
operator|.
name|label
argument_list|,
name|label
argument_list|,
sizeof|sizeof
name|bundle
operator|->
name|cfg
operator|.
name|label
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|bundle
operator|->
name|cfg
operator|.
name|label
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|bundle_GetLabel
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
return|return
operator|*
name|bundle
operator|->
name|cfg
operator|.
name|label
condition|?
name|bundle
operator|->
name|cfg
operator|.
name|label
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|bundle_LinkSize
parameter_list|()
block|{
name|struct
name|iovec
name|iov
index|[
name|SCATTER_SEGMENTS
index|]
decl_stmt|;
name|int
name|niov
decl_stmt|,
name|expect
decl_stmt|,
name|f
decl_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|Version
argument_list|)
operator|+
literal|1
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|NULL
expr_stmt|;
name|niov
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|datalink2iov
argument_list|(
name|NULL
argument_list|,
name|iov
argument_list|,
operator|&
name|niov
argument_list|,
name|SCATTER_SEGMENTS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Cannot determine space required for link\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|f
operator|=
name|expect
operator|=
literal|0
init|;
name|f
operator|<
name|niov
condition|;
name|f
operator|++
control|)
name|expect
operator|+=
name|iov
index|[
name|f
index|]
operator|.
name|iov_len
expr_stmt|;
return|return
name|expect
return|;
block|}
end_function

begin_function
name|void
name|bundle_ReceiveDatalink
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|s
parameter_list|)
block|{
name|char
name|cmsgbuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|cmsghdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|SEND_MAXFD
index|]
decl_stmt|;
name|int
name|niov
decl_stmt|,
name|expect
decl_stmt|,
name|f
decl_stmt|,
modifier|*
name|fd
decl_stmt|,
name|nfd
decl_stmt|,
name|onfd
decl_stmt|,
name|got
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
name|SCATTER_SEGMENTS
index|]
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmsg
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Receiving datalink\n"
argument_list|)
expr_stmt|;
comment|/*    * Create our scatter/gather array - passing NULL gets the space    * allocation requirement rather than actually flattening the    * structures.    */
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|Version
argument_list|)
operator|+
literal|1
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|NULL
expr_stmt|;
name|niov
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|datalink2iov
argument_list|(
name|NULL
argument_list|,
name|iov
argument_list|,
operator|&
name|niov
argument_list|,
name|SCATTER_SEGMENTS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Cannot determine space required for link\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Allocate the scatter/gather array for recvmsg() */
for|for
control|(
name|f
operator|=
name|expect
operator|=
literal|0
init|;
name|f
operator|<
name|niov
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|iov
index|[
name|f
index|]
operator|.
name|iov_base
operator|=
name|malloc
argument_list|(
name|iov
index|[
name|f
index|]
operator|.
name|iov_len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Cannot allocate space to receive link\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|f
condition|)
name|expect
operator|+=
name|iov
index|[
name|f
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
comment|/* Set up our message */
name|cmsg
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|cmsgbuf
expr_stmt|;
name|cmsg
operator|->
name|cmsg_len
operator|=
sizeof|sizeof
name|cmsgbuf
expr_stmt|;
name|cmsg
operator|->
name|cmsg_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|cmsg
operator|->
name|cmsg_type
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_name
operator|=
name|NULL
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
comment|/* Only send the version at the first pass */
name|msg
operator|.
name|msg_control
operator|=
name|cmsgbuf
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
name|cmsgbuf
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Expecting %u scatter/gather bytes\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|got
operator|=
name|recvmsg
argument_list|(
name|s
argument_list|,
operator|&
name|msg
argument_list|,
name|MSG_WAITALL
argument_list|)
operator|)
operator|!=
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
condition|)
block|{
if|if
condition|(
name|got
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed recvmsg: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed recvmsg: Got %d, not %u\n"
argument_list|,
name|got
argument_list|,
operator|(
name|unsigned
operator|)
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
while|while
condition|(
name|niov
operator|--
condition|)
name|free
argument_list|(
name|iov
index|[
name|niov
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cmsg
operator|->
name|cmsg_level
operator|!=
name|SOL_SOCKET
operator|||
name|cmsg
operator|->
name|cmsg_type
operator|!=
name|SCM_RIGHTS
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Recvmsg: no descriptors received !\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|niov
operator|--
condition|)
name|free
argument_list|(
name|iov
index|[
name|niov
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
return|return;
block|}
name|fd
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
name|cmsg
operator|+
literal|1
operator|)
expr_stmt|;
name|nfd
operator|=
operator|(
name|cmsg
operator|->
name|cmsg_len
operator|-
sizeof|sizeof
expr|*
name|cmsg
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfd
operator|<
literal|2
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Recvmsg: %d descriptor%s received (too few) !\n"
argument_list|,
name|nfd
argument_list|,
name|nfd
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
while|while
condition|(
name|nfd
operator|--
condition|)
name|close
argument_list|(
name|fd
index|[
name|nfd
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|niov
operator|--
condition|)
name|free
argument_list|(
name|iov
index|[
name|niov
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * We've successfully received two or more open file descriptors    * through our socket, plus a version string.  Make sure it's the    * correct version, and drop the connection if it's not.    */
if|if
condition|(
name|strncmp
argument_list|(
name|Version
argument_list|,
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Cannot receive datalink, incorrect version"
literal|" (\"%.*s\", not \"%s\")\n"
argument_list|,
operator|(
name|int
operator|)
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|,
operator|(
name|char
operator|*
operator|)
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|,
name|Version
argument_list|)
expr_stmt|;
while|while
condition|(
name|nfd
operator|--
condition|)
name|close
argument_list|(
name|fd
index|[
name|nfd
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|niov
operator|--
condition|)
name|free
argument_list|(
name|iov
index|[
name|niov
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * Everything looks good.  Send the other side our process id so that    * they can transfer lock ownership, and wait for them to send the    * actual link data.    */
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|got
operator|=
name|write
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
operator|&
name|pid
argument_list|,
sizeof|sizeof
name|pid
argument_list|)
operator|)
operator|!=
sizeof|sizeof
name|pid
condition|)
block|{
if|if
condition|(
name|got
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed write: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed write: Got %d, not %d\n"
argument_list|,
name|got
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
name|pid
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nfd
operator|--
condition|)
name|close
argument_list|(
name|fd
index|[
name|nfd
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|niov
operator|--
condition|)
name|free
argument_list|(
name|iov
index|[
name|niov
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|got
operator|=
name|readv
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|,
name|iov
operator|+
literal|1
argument_list|,
name|niov
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|expect
condition|)
block|{
if|if
condition|(
name|got
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed write: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed write: Got %d, not %d\n"
argument_list|,
name|got
argument_list|,
name|expect
argument_list|)
expr_stmt|;
while|while
condition|(
name|nfd
operator|--
condition|)
name|close
argument_list|(
name|fd
index|[
name|nfd
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|niov
operator|--
condition|)
name|free
argument_list|(
name|iov
index|[
name|niov
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
return|return;
block|}
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|onfd
operator|=
name|nfd
expr_stmt|;
comment|/* We've got this many in our array */
name|nfd
operator|-=
literal|2
expr_stmt|;
comment|/* Don't include p->fd and our reply descriptor */
name|niov
operator|=
literal|1
expr_stmt|;
comment|/* Skip the version id */
name|dl
operator|=
name|iov2datalink
argument_list|(
name|bundle
argument_list|,
name|iov
argument_list|,
operator|&
name|niov
argument_list|,
sizeof|sizeof
name|iov
operator|/
sizeof|sizeof
expr|*
name|iov
argument_list|,
name|fd
index|[
literal|0
index|]
argument_list|,
name|fd
operator|+
literal|2
argument_list|,
operator|&
name|nfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
condition|)
block|{
if|if
condition|(
name|nfd
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"bundle_ReceiveDatalink: Failed to handle %d "
literal|"auxiliary file descriptors (%d remain)\n"
argument_list|,
name|onfd
argument_list|,
name|nfd
argument_list|)
expr_stmt|;
name|datalink_Destroy
argument_list|(
name|dl
argument_list|)
expr_stmt|;
while|while
condition|(
name|nfd
operator|--
condition|)
name|close
argument_list|(
name|fd
index|[
name|onfd
operator|--
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bundle_DatalinkLinkin
argument_list|(
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
name|datalink_AuthOk
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|bundle_CalculateBandwidth
argument_list|(
name|dl
operator|->
name|bundle
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|nfd
operator|--
condition|)
name|close
argument_list|(
name|fd
index|[
name|onfd
operator|--
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_SendDatalink
parameter_list|(
name|struct
name|datalink
modifier|*
name|dl
parameter_list|,
name|int
name|s
parameter_list|,
name|struct
name|sockaddr_un
modifier|*
name|sun
parameter_list|)
block|{
name|char
name|cmsgbuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|cmsghdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|SEND_MAXFD
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|constlock
decl_stmt|;
name|char
modifier|*
name|lock
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmsg
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
name|SCATTER_SEGMENTS
index|]
decl_stmt|;
name|int
name|niov
decl_stmt|,
name|f
decl_stmt|,
name|expect
decl_stmt|,
name|newsid
decl_stmt|,
name|fd
index|[
name|SEND_MAXFD
index|]
decl_stmt|,
name|nfd
decl_stmt|,
name|reply
index|[
literal|2
index|]
decl_stmt|,
name|got
decl_stmt|;
name|pid_t
name|newpid
decl_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Transmitting datalink %s\n"
argument_list|,
name|dl
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Record the base device name for a lock transfer later */
name|constlock
operator|=
name|physical_LockedDevice
argument_list|(
name|dl
operator|->
name|physical
argument_list|)
expr_stmt|;
if|if
condition|(
name|constlock
condition|)
block|{
name|lock
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|constlock
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lock
argument_list|,
name|constlock
argument_list|)
expr_stmt|;
block|}
else|else
name|lock
operator|=
name|NULL
expr_stmt|;
name|bundle_LinkClosed
argument_list|(
name|dl
operator|->
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
name|bundle_DatalinkLinkout
argument_list|(
name|dl
operator|->
name|bundle
argument_list|,
name|dl
argument_list|)
expr_stmt|;
comment|/* Build our scatter/gather array */
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|Version
argument_list|)
operator|+
literal|1
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|strdup
argument_list|(
name|Version
argument_list|)
expr_stmt|;
name|niov
operator|=
literal|1
expr_stmt|;
name|nfd
operator|=
literal|0
expr_stmt|;
name|fd
index|[
literal|0
index|]
operator|=
name|datalink2iov
argument_list|(
name|dl
argument_list|,
name|iov
argument_list|,
operator|&
name|niov
argument_list|,
name|SCATTER_SEGMENTS
argument_list|,
name|fd
operator|+
literal|2
argument_list|,
operator|&
name|nfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
index|[
literal|0
index|]
operator|!=
operator|-
literal|1
operator|&&
name|socketpair
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
name|PF_UNSPEC
argument_list|,
name|reply
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/*      * fd[1] is used to get the peer process id back, then to confirm that      * we've transferred any device locks to that process id.      */
name|fd
index|[
literal|1
index|]
operator|=
name|reply
index|[
literal|1
index|]
expr_stmt|;
name|nfd
operator|+=
literal|2
expr_stmt|;
comment|/* Include fd[0] and fd[1] */
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_name
operator|=
name|NULL
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
literal|0
expr_stmt|;
comment|/*      * Only send the version to start...  We used to send the whole lot, but      * this caused problems with our RECVBUF size as a single link is about      * 22k !  This way, we should bump into no limits.      */
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|cmsgbuf
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
expr|*
name|cmsg
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|nfd
expr_stmt|;
name|msg
operator|.
name|msg_flags
operator|=
literal|0
expr_stmt|;
name|cmsg
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|cmsgbuf
expr_stmt|;
name|cmsg
operator|->
name|cmsg_len
operator|=
name|msg
operator|.
name|msg_controllen
expr_stmt|;
name|cmsg
operator|->
name|cmsg_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|cmsg
operator|->
name|cmsg_type
operator|=
name|SCM_RIGHTS
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|nfd
condition|;
name|f
operator|++
control|)
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
name|cmsg
operator|+
literal|1
operator|)
operator|+
name|f
operator|)
operator|=
name|fd
index|[
name|f
index|]
expr_stmt|;
for|for
control|(
name|f
operator|=
literal|1
operator|,
name|expect
operator|=
literal|0
init|;
name|f
operator|<
name|niov
condition|;
name|f
operator|++
control|)
name|expect
operator|+=
name|iov
index|[
name|f
index|]
operator|.
name|iov_len
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|reply
index|[
literal|0
index|]
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|&
name|expect
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"setsockopt(SO_RCVBUF, %d): %s\n"
argument_list|,
name|expect
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|reply
index|[
literal|1
index|]
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|&
name|expect
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"setsockopt(SO_RCVBUF, %d): %s\n"
argument_list|,
name|expect
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Sending %d descriptor%s and %u bytes in scatter"
literal|"/gather array\n"
argument_list|,
name|nfd
argument_list|,
name|nfd
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
operator|(
name|unsigned
operator|)
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|got
operator|=
name|sendmsg
argument_list|(
name|s
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Failed sendmsg: %s: %s\n"
argument_list|,
name|sun
operator|->
name|sun_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|got
operator|!=
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"%s: Failed initial sendmsg: Only sent %d of %u\n"
argument_list|,
name|sun
operator|->
name|sun_path
argument_list|,
name|got
argument_list|,
operator|(
name|unsigned
operator|)
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We must get the ACK before closing the descriptor ! */
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|got
operator|=
name|read
argument_list|(
name|reply
index|[
literal|0
index|]
argument_list|,
operator|&
name|newpid
argument_list|,
sizeof|sizeof
name|newpid
argument_list|)
operator|)
operator|==
sizeof|sizeof
name|newpid
condition|)
block|{
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Received confirmation from pid %d\n"
argument_list|,
operator|(
name|int
operator|)
name|newpid
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|&&
operator|(
name|res
operator|=
name|ID0uu_lock_txfr
argument_list|(
name|lock
argument_list|,
name|newpid
argument_list|)
operator|)
operator|!=
name|UU_LOCK_OK
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"uu_lock_txfr: %s\n"
argument_list|,
name|uu_lockerr
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Transmitting link (%d bytes)\n"
argument_list|,
name|expect
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|got
operator|=
name|writev
argument_list|(
name|reply
index|[
literal|0
index|]
argument_list|,
name|iov
operator|+
literal|1
argument_list|,
name|niov
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|expect
condition|)
block|{
if|if
condition|(
name|got
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"%s: Failed writev: %s\n"
argument_list|,
name|sun
operator|->
name|sun_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"%s: Failed writev: Wrote %d of %d\n"
argument_list|,
name|sun
operator|->
name|sun_path
argument_list|,
name|got
argument_list|,
name|expect
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|got
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"%s: Failed socketpair read: %s\n"
argument_list|,
name|sun
operator|->
name|sun_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"%s: Failed socketpair read: Got %d of %d\n"
argument_list|,
name|sun
operator|->
name|sun_path
argument_list|,
name|got
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
name|newpid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|reply
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|reply
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|newsid
operator|=
name|Enabled
argument_list|(
name|dl
operator|->
name|bundle
argument_list|,
name|OPT_KEEPSESSION
argument_list|)
operator|||
name|tcgetpgrp
argument_list|(
name|fd
index|[
literal|0
index|]
argument_list|)
operator|==
name|getpgrp
argument_list|()
expr_stmt|;
while|while
condition|(
name|nfd
condition|)
name|close
argument_list|(
name|fd
index|[
operator|--
name|nfd
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsid
condition|)
name|bundle_setsid
argument_list|(
name|dl
operator|->
name|bundle
argument_list|,
name|got
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
name|niov
operator|--
condition|)
name|free
argument_list|(
name|iov
index|[
name|niov
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bundle_RenameDatalink
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|ndl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|ndl
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|dl
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
name|datalink_Rename
argument_list|(
name|ndl
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|bundle_SetMode
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|datalink
modifier|*
name|dl
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|omode
decl_stmt|;
name|omode
operator|=
name|dl
operator|->
name|physical
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|omode
operator|==
name|mode
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|mode
operator|==
name|PHYS_AUTO
operator|&&
operator|!
operator|(
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|&
name|PHYS_AUTO
operator|)
condition|)
comment|/* First auto link */
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
operator|.
name|peer_ip
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"You must `set ifaddr' or `open' before"
literal|" changing mode to %s\n"
argument_list|,
name|mode2Nam
argument_list|(
name|mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|datalink_SetMode
argument_list|(
name|dl
argument_list|,
name|mode
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mode
operator|==
name|PHYS_AUTO
operator|&&
operator|!
operator|(
name|bundle
operator|->
name|phys_type
operator|.
name|all
operator|&
name|PHYS_AUTO
operator|)
operator|&&
name|bundle
operator|->
name|phase
operator|!=
name|PHASE_NETWORK
condition|)
comment|/* First auto link, we need an interface */
name|ipcp_InterfaceUp
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipcp
argument_list|)
expr_stmt|;
comment|/* Regenerate phys_type and adjust idle timer */
name|bundle_LinksRemoved
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|bundle_setsid
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|holdsession
parameter_list|)
block|{
comment|/*    * Lose the current session.  This means getting rid of our pid    * too so that the tty device will really go away, and any getty    * etc will be allowed to restart.    */
name|pid_t
name|pid
decl_stmt|,
name|orig
decl_stmt|;
name|int
name|fds
index|[
literal|2
index|]
decl_stmt|;
name|char
name|done
decl_stmt|;
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
operator|!
name|holdsession
operator|&&
name|bundle_IsDead
argument_list|(
name|bundle
argument_list|)
condition|)
block|{
comment|/*      * No need to lose our session after all... we're going away anyway      *      * We should really stop the timer and pause if holdsession is set and      * the bundle's dead, but that leaves other resources lying about :-(      */
return|return;
block|}
name|orig
operator|=
name|getpid
argument_list|()
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fds
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"pipe: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"fork: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|read
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|,
operator|&
name|done
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* uu_locks are mine ! */
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fds
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"pipe(2): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"fork(2): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
literal|0
case|:
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|bundle_LockTun
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
comment|/* update pid */
name|read
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|,
operator|&
name|done
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* uu_locks are mine ! */
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|setsid
argument_list|()
expr_stmt|;
name|bundle_ChangedPID
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"%d -> %d: %s session control\n"
argument_list|,
operator|(
name|int
operator|)
name|orig
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|,
name|holdsession
condition|?
literal|"Passed"
else|:
literal|"Dropped"
argument_list|)
expr_stmt|;
name|timer_InitService
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Start the Timer Service */
break|break;
default|default:
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Give away all our physical locks (to the final process) */
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
condition|)
name|physical_ChangedPid
argument_list|(
name|dl
operator|->
name|physical
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|,
literal|"!"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* done */
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Give away all our physical locks (to the intermediate process) */
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|state
operator|!=
name|DATALINK_CLOSED
condition|)
name|physical_ChangedPid
argument_list|(
name|dl
operator|->
name|physical
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|,
literal|"!"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* done */
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|holdsession
condition|)
block|{
name|int
name|fd
decl_stmt|,
name|status
decl_stmt|;
name|timer_TermService
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
for|for
control|(
name|fd
operator|=
name|getdtablesize
argument_list|()
init|;
name|fd
operator|>=
literal|0
condition|;
name|fd
operator|--
control|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/*          * Reap the intermediate process.  As we're not exiting but the          * intermediate is, we don't want it to become defunct.          */
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Tweak our process arguments.... */
name|SetTitle
argument_list|(
literal|"session owner"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOSUID
name|setuid
argument_list|(
name|ID0realuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*          * Hang around for a HUP.  This should happen as soon as the          * ppp that we passed our ctty descriptor to closes it.          * NOTE: If this process dies, the passed descriptor becomes          *       invalid and will give a select() error by setting one          *       of the error fds, aborting the other ppp.  We don't          *       want that to happen !          */
name|pause
argument_list|()
expr_stmt|;
block|}
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|bundle_HighestState
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|int
name|result
init|=
name|DATALINK_CLOSED
decl_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|result
operator|<
name|dl
operator|->
name|state
condition|)
name|result
operator|=
name|dl
operator|->
name|state
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|bundle_Exception
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|physical
operator|->
name|fd
operator|==
name|fd
condition|)
block|{
name|datalink_Down
argument_list|(
name|dl
argument_list|,
name|CLOSE_NORMAL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bundle_AdjustFilters
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|in_addr
modifier|*
name|my_ip
parameter_list|,
name|struct
name|in_addr
modifier|*
name|peer_ip
parameter_list|)
block|{
name|filter_AdjustAddr
argument_list|(
operator|&
name|bundle
operator|->
name|filter
operator|.
name|in
argument_list|,
name|my_ip
argument_list|,
name|peer_ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|filter_AdjustAddr
argument_list|(
operator|&
name|bundle
operator|->
name|filter
operator|.
name|out
argument_list|,
name|my_ip
argument_list|,
name|peer_ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|filter_AdjustAddr
argument_list|(
operator|&
name|bundle
operator|->
name|filter
operator|.
name|dial
argument_list|,
name|my_ip
argument_list|,
name|peer_ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|filter_AdjustAddr
argument_list|(
operator|&
name|bundle
operator|->
name|filter
operator|.
name|alive
argument_list|,
name|my_ip
argument_list|,
name|peer_ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_AdjustDNS
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|in_addr
name|dns
index|[
literal|2
index|]
parameter_list|)
block|{
name|filter_AdjustAddr
argument_list|(
operator|&
name|bundle
operator|->
name|filter
operator|.
name|in
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dns
argument_list|)
expr_stmt|;
name|filter_AdjustAddr
argument_list|(
operator|&
name|bundle
operator|->
name|filter
operator|.
name|out
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dns
argument_list|)
expr_stmt|;
name|filter_AdjustAddr
argument_list|(
operator|&
name|bundle
operator|->
name|filter
operator|.
name|dial
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dns
argument_list|)
expr_stmt|;
name|filter_AdjustAddr
argument_list|(
operator|&
name|bundle
operator|->
name|filter
operator|.
name|alive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dns
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_CalculateBandwidth
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|int
name|sp
decl_stmt|,
name|overhead
decl_stmt|,
name|maxoverhead
decl_stmt|;
name|bundle
operator|->
name|bandwidth
operator|=
literal|0
expr_stmt|;
name|bundle
operator|->
name|iface
operator|->
name|mtu
operator|=
literal|0
expr_stmt|;
name|maxoverhead
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
block|{
name|overhead
operator|=
name|ccp_MTUOverhead
argument_list|(
operator|&
name|dl
operator|->
name|physical
operator|->
name|link
operator|.
name|ccp
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxoverhead
operator|<
name|overhead
condition|)
name|maxoverhead
operator|=
name|overhead
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|=
name|dl
operator|->
name|mp
operator|.
name|bandwidth
operator|)
operator|==
literal|0
operator|&&
operator|(
name|sp
operator|=
name|physical_GetSpeed
argument_list|(
name|dl
operator|->
name|physical
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"%s: %s: Cannot determine bandwidth\n"
argument_list|,
name|dl
operator|->
name|name
argument_list|,
name|dl
operator|->
name|physical
operator|->
name|name
operator|.
name|full
argument_list|)
expr_stmt|;
else|else
name|bundle
operator|->
name|bandwidth
operator|+=
name|sp
expr_stmt|;
if|if
condition|(
operator|!
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|active
condition|)
block|{
name|bundle
operator|->
name|iface
operator|->
name|mtu
operator|=
name|dl
operator|->
name|physical
operator|->
name|link
operator|.
name|lcp
operator|.
name|his_mru
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|bundle
operator|->
name|bandwidth
operator|==
literal|0
condition|)
name|bundle
operator|->
name|bandwidth
operator|=
literal|115200
expr_stmt|;
comment|/* Shrug */
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|active
condition|)
block|{
name|bundle
operator|->
name|iface
operator|->
name|mtu
operator|=
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|peer_mrru
expr_stmt|;
name|overhead
operator|=
name|ccp_MTUOverhead
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
operator|.
name|link
operator|.
name|ccp
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxoverhead
operator|<
name|overhead
condition|)
name|maxoverhead
operator|=
name|overhead
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bundle
operator|->
name|iface
operator|->
name|mtu
condition|)
name|bundle
operator|->
name|iface
operator|->
name|mtu
operator|=
name|DEF_MRU
expr_stmt|;
ifndef|#
directive|ifndef
name|NORADIUS
if|if
condition|(
name|bundle
operator|->
name|radius
operator|.
name|valid
operator|&&
name|bundle
operator|->
name|radius
operator|.
name|mtu
operator|&&
name|bundle
operator|->
name|radius
operator|.
name|mtu
operator|<
name|bundle
operator|->
name|iface
operator|->
name|mtu
condition|)
block|{
name|log_Printf
argument_list|(
name|LogLCP
argument_list|,
literal|"Reducing MTU to radius value %lu\n"
argument_list|,
name|bundle
operator|->
name|radius
operator|.
name|mtu
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|iface
operator|->
name|mtu
operator|=
name|bundle
operator|->
name|radius
operator|.
name|mtu
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|maxoverhead
condition|)
block|{
name|log_Printf
argument_list|(
name|LogLCP
argument_list|,
literal|"Reducing MTU from %d to %d (CCP requirement)\n"
argument_list|,
name|bundle
operator|->
name|iface
operator|->
name|mtu
argument_list|,
name|bundle
operator|->
name|iface
operator|->
name|mtu
operator|-
name|maxoverhead
argument_list|)
expr_stmt|;
name|bundle
operator|->
name|iface
operator|->
name|mtu
operator|-=
name|maxoverhead
expr_stmt|;
block|}
name|tun_configure
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
name|route_UpdateMTU
argument_list|(
name|bundle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bundle_AutoAdjust
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|int
name|percent
parameter_list|,
name|int
name|what
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|,
modifier|*
name|choice
decl_stmt|,
modifier|*
name|otherlinkup
decl_stmt|;
name|choice
operator|=
name|otherlinkup
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|physical
operator|->
name|type
operator|==
name|PHYS_AUTO
condition|)
block|{
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
block|{
if|if
condition|(
name|what
operator|==
name|AUTO_DOWN
condition|)
block|{
if|if
condition|(
name|choice
condition|)
name|otherlinkup
operator|=
name|choice
expr_stmt|;
name|choice
operator|=
name|dl
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_CLOSED
condition|)
block|{
if|if
condition|(
name|what
operator|==
name|AUTO_UP
condition|)
block|{
name|choice
operator|=
name|dl
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* An auto link in an intermediate state - forget it for the moment */
name|choice
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
operator|&&
name|what
operator|==
name|AUTO_DOWN
condition|)
name|otherlinkup
operator|=
name|dl
expr_stmt|;
if|if
condition|(
name|choice
condition|)
block|{
if|if
condition|(
name|what
operator|==
name|AUTO_UP
condition|)
block|{
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"%d%% saturation -> Opening link ``%s''\n"
argument_list|,
name|percent
argument_list|,
name|choice
operator|->
name|name
argument_list|)
expr_stmt|;
name|datalink_Up
argument_list|(
name|choice
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mp_CheckAutoloadTimer
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|otherlinkup
condition|)
block|{
comment|/* Only bring the second-last link down */
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"%d%% saturation -> Closing link ``%s''\n"
argument_list|,
name|percent
argument_list|,
name|choice
operator|->
name|name
argument_list|)
expr_stmt|;
name|datalink_Close
argument_list|(
name|choice
argument_list|,
name|CLOSE_STAYDOWN
argument_list|)
expr_stmt|;
name|mp_CheckAutoloadTimer
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|bundle_WantAutoloadTimer
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
name|struct
name|datalink
modifier|*
name|dl
decl_stmt|;
name|int
name|autolink
decl_stmt|,
name|opened
decl_stmt|;
if|if
condition|(
name|bundle
operator|->
name|phase
operator|==
name|PHASE_NETWORK
condition|)
block|{
for|for
control|(
name|autolink
operator|=
name|opened
operator|=
literal|0
operator|,
name|dl
operator|=
name|bundle
operator|->
name|links
init|;
name|dl
condition|;
name|dl
operator|=
name|dl
operator|->
name|next
control|)
if|if
condition|(
name|dl
operator|->
name|physical
operator|->
name|type
operator|==
name|PHYS_AUTO
condition|)
block|{
if|if
condition|(
operator|++
name|autolink
operator|==
literal|2
operator|||
operator|(
name|autolink
operator|==
literal|1
operator|&&
name|opened
operator|)
condition|)
comment|/* Two auto links or one auto and one open in NETWORK phase */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|dl
operator|->
name|state
operator|==
name|DATALINK_OPEN
condition|)
block|{
name|opened
operator|++
expr_stmt|;
if|if
condition|(
name|autolink
condition|)
comment|/* One auto and one open link in NETWORK phase */
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|bundle_ChangedPID
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TUNSIFPID
name|ioctl
argument_list|(
name|bundle
operator|->
name|dev
operator|.
name|fd
argument_list|,
name|TUNSIFPID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

