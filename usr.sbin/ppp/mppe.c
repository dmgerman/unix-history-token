begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Semen Ustimenko<semenu@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sha.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<openssl/sha.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<openssl/rc4.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lqr.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ccp.h"
end_include

begin_include
include|#
directive|include
file|"throughput.h"
end_include

begin_include
include|#
directive|include
file|"layer.h"
end_include

begin_include
include|#
directive|include
file|"link.h"
end_include

begin_include
include|#
directive|include
file|"chap_ms.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_include
include|#
directive|include
file|"mppe.h"
end_include

begin_include
include|#
directive|include
file|"ua.h"
end_include

begin_comment
comment|/*  * Documentation:  *  * draft-ietf-pppext-mppe-04.txt  * draft-ietf-pppext-mppe-keys-02.txt  */
end_comment

begin_define
define|#
directive|define
name|MPPE_OPT_STATELESS
value|0x1000000
end_define

begin_define
define|#
directive|define
name|MPPE_OPT_COMPRESSED
value|0x01
end_define

begin_define
define|#
directive|define
name|MPPE_OPT_40BIT
value|0x20
end_define

begin_define
define|#
directive|define
name|MPPE_OPT_56BIT
value|0x80
end_define

begin_define
define|#
directive|define
name|MPPE_OPT_128BIT
value|0x40
end_define

begin_define
define|#
directive|define
name|MPPE_OPT_BITMASK
value|0xe0
end_define

begin_define
define|#
directive|define
name|MPPE_OPT_MASK
value|(MPPE_OPT_STATELESS | MPPE_OPT_BITMASK)
end_define

begin_define
define|#
directive|define
name|MPPE_FLUSHED
value|0x8000
end_define

begin_define
define|#
directive|define
name|MPPE_ENCRYPTED
value|0x1000
end_define

begin_define
define|#
directive|define
name|MPPE_HEADER_BITMASK
value|0xf000
end_define

begin_define
define|#
directive|define
name|MPPE_HEADER_FLAG
value|0x00ff
end_define

begin_define
define|#
directive|define
name|MPPE_HEADER_FLAGMASK
value|0x00ff
end_define

begin_define
define|#
directive|define
name|MPPE_HEADER_FLAGSHIFT
value|8
end_define

begin_define
define|#
directive|define
name|MPPE_HEADER_STATEFUL_KEYCHANGES
value|16
end_define

begin_struct
struct|struct
name|mppe_state
block|{
name|unsigned
name|stateless
range|:
literal|1
decl_stmt|;
name|unsigned
name|flushnext
range|:
literal|1
decl_stmt|;
name|unsigned
name|flushrequired
range|:
literal|1
decl_stmt|;
name|int
name|cohnum
decl_stmt|;
name|int
name|keylen
decl_stmt|;
comment|/* 8 or 16 bytes */
name|int
name|keybits
decl_stmt|;
comment|/* 40, 56 or 128 bits */
name|char
name|sesskey
index|[
name|MPPE_KEY_LEN
index|]
decl_stmt|;
name|char
name|mastkey
index|[
name|MPPE_KEY_LEN
index|]
decl_stmt|;
name|RC4_KEY
name|rc4key
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|MPPE_MasterKeyValid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|MPPE_IsServer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|MPPE_MasterKey
index|[
name|MPPE_KEY_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The peer has missed a packet.  Mark the next output frame to be FLUSHED  */
end_comment

begin_function
specifier|static
name|int
name|MPPEResetOutput
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|mppe_state
modifier|*
name|mop
init|=
operator|(
expr|struct
name|mppe_state
operator|*
operator|)
name|v
decl_stmt|;
if|if
condition|(
name|mop
operator|->
name|stateless
condition|)
name|log_Printf
argument_list|(
name|LogCCP
argument_list|,
literal|"MPPE: Unexpected output channel reset\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|log_Printf
argument_list|(
name|LogCCP
argument_list|,
literal|"MPPE: Output channel reset\n"
argument_list|)
expr_stmt|;
name|mop
operator|->
name|flushnext
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* Ask FSM not to ACK */
block|}
end_function

begin_function
specifier|static
name|void
name|MPPEReduceSessionKey
parameter_list|(
name|struct
name|mppe_state
modifier|*
name|mp
parameter_list|)
block|{
switch|switch
condition|(
name|mp
operator|->
name|keybits
condition|)
block|{
case|case
literal|40
case|:
name|mp
operator|->
name|sesskey
index|[
literal|2
index|]
operator|=
literal|0x9e
expr_stmt|;
name|mp
operator|->
name|sesskey
index|[
literal|1
index|]
operator|=
literal|0x26
expr_stmt|;
case|case
literal|56
case|:
name|mp
operator|->
name|sesskey
index|[
literal|0
index|]
operator|=
literal|0xd1
expr_stmt|;
case|case
literal|128
case|:
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|MPPEKeyChange
parameter_list|(
name|struct
name|mppe_state
modifier|*
name|mp
parameter_list|)
block|{
name|char
name|InterimKey
index|[
name|MPPE_KEY_LEN
index|]
decl_stmt|;
name|RC4_KEY
name|RC4Key
decl_stmt|;
name|GetNewKeyFromSHA
argument_list|(
name|mp
operator|->
name|mastkey
argument_list|,
name|mp
operator|->
name|sesskey
argument_list|,
name|mp
operator|->
name|keylen
argument_list|,
name|InterimKey
argument_list|)
expr_stmt|;
name|RC4_set_key
argument_list|(
operator|&
name|RC4Key
argument_list|,
name|mp
operator|->
name|keylen
argument_list|,
name|InterimKey
argument_list|)
expr_stmt|;
name|RC4
argument_list|(
operator|&
name|RC4Key
argument_list|,
name|mp
operator|->
name|keylen
argument_list|,
name|InterimKey
argument_list|,
name|mp
operator|->
name|sesskey
argument_list|)
expr_stmt|;
name|MPPEReduceSessionKey
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|MPPEOutput
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|ccp
modifier|*
name|ccp
parameter_list|,
name|struct
name|link
modifier|*
name|l
parameter_list|,
name|int
name|pri
parameter_list|,
name|u_short
modifier|*
name|proto
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mppe_state
modifier|*
name|mop
init|=
operator|(
expr|struct
name|mppe_state
operator|*
operator|)
name|v
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mo
decl_stmt|;
name|u_short
name|nproto
decl_stmt|,
name|prefix
decl_stmt|;
name|int
name|dictinit
decl_stmt|,
name|ilen
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|;
name|ilen
operator|=
name|m_length
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|dictinit
operator|=
literal|0
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPE: Output: Proto %02x (%d bytes)\n"
argument_list|,
operator|*
name|proto
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|proto
operator|<
literal|0x21
operator|&&
operator|*
name|proto
operator|>
literal|0xFA
condition|)
block|{
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPE: Output: Not encrypting\n"
argument_list|)
expr_stmt|;
name|ccp
operator|->
name|compout
operator|+=
name|ilen
expr_stmt|;
name|ccp
operator|->
name|uncompout
operator|+=
name|ilen
expr_stmt|;
return|return
name|mp
return|;
block|}
name|log_DumpBp
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPE: Output: Encrypt packet:"
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/* Get mbuf for prefixes */
name|mo
operator|=
name|m_get
argument_list|(
literal|4
argument_list|,
name|MB_CCPOUT
argument_list|)
expr_stmt|;
name|mo
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
name|rp
operator|=
name|MBUF_CTOP
argument_list|(
name|mo
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|MPPE_ENCRYPTED
operator||
name|mop
operator|->
name|cohnum
expr_stmt|;
if|if
condition|(
name|mop
operator|->
name|stateless
operator|||
operator|(
name|mop
operator|->
name|cohnum
operator|&
name|MPPE_HEADER_FLAGMASK
operator|)
operator|==
name|MPPE_HEADER_FLAG
condition|)
block|{
comment|/* Change our key */
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPEOutput: Key changed [%d]\n"
argument_list|,
name|mop
operator|->
name|cohnum
argument_list|)
expr_stmt|;
name|MPPEKeyChange
argument_list|(
name|mop
argument_list|)
expr_stmt|;
name|dictinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mop
operator|->
name|stateless
operator|||
name|mop
operator|->
name|flushnext
condition|)
block|{
name|prefix
operator||=
name|MPPE_FLUSHED
expr_stmt|;
name|dictinit
operator|=
literal|1
expr_stmt|;
name|mop
operator|->
name|flushnext
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dictinit
condition|)
block|{
comment|/* Initialise our dictionary */
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPEOutput: Dictionary initialised [%d]\n"
argument_list|,
name|mop
operator|->
name|cohnum
argument_list|)
expr_stmt|;
name|RC4_set_key
argument_list|(
operator|&
name|mop
operator|->
name|rc4key
argument_list|,
name|mop
operator|->
name|keylen
argument_list|,
name|mop
operator|->
name|sesskey
argument_list|)
expr_stmt|;
block|}
comment|/* Set MPPE packet prefix */
name|ua_htons
argument_list|(
operator|&
name|prefix
argument_list|,
name|rp
argument_list|)
expr_stmt|;
comment|/* Save encrypted protocol number */
name|nproto
operator|=
name|htons
argument_list|(
operator|*
name|proto
argument_list|)
expr_stmt|;
name|RC4
argument_list|(
operator|&
name|mop
operator|->
name|rc4key
argument_list|,
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nproto
argument_list|,
name|rp
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Encrypt main packet */
name|rp
operator|=
name|MBUF_CTOP
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|RC4
argument_list|(
operator|&
name|mop
operator|->
name|rc4key
argument_list|,
name|ilen
argument_list|,
name|rp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|mop
operator|->
name|cohnum
operator|++
expr_stmt|;
name|mop
operator|->
name|cohnum
operator|&=
operator|~
name|MPPE_HEADER_BITMASK
expr_stmt|;
comment|/* Set the protocol number */
operator|*
name|proto
operator|=
name|ccp_Proto
argument_list|(
name|ccp
argument_list|)
expr_stmt|;
name|len
operator|=
name|m_length
argument_list|(
name|mo
argument_list|)
expr_stmt|;
name|ccp
operator|->
name|uncompout
operator|+=
name|ilen
expr_stmt|;
name|ccp
operator|->
name|compout
operator|+=
name|len
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPE: Output: Encrypted: Proto %02x (%d bytes)\n"
argument_list|,
operator|*
name|proto
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|mo
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|MPPEResetInput
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|log_Printf
argument_list|(
name|LogCCP
argument_list|,
literal|"MPPE: Unexpected input channel ack\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|MPPEInput
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|ccp
modifier|*
name|ccp
parameter_list|,
name|u_short
modifier|*
name|proto
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mppe_state
modifier|*
name|mip
init|=
operator|(
expr|struct
name|mppe_state
operator|*
operator|)
name|v
decl_stmt|;
name|u_short
name|prefix
decl_stmt|;
name|char
modifier|*
name|rp
decl_stmt|;
name|int
name|dictinit
decl_stmt|,
name|flushed
decl_stmt|,
name|ilen
decl_stmt|,
name|len
decl_stmt|,
name|n
decl_stmt|;
name|ilen
operator|=
name|m_length
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|dictinit
operator|=
literal|0
expr_stmt|;
name|ccp
operator|->
name|compin
operator|+=
name|ilen
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPE: Input: Proto %02x (%d bytes)\n"
argument_list|,
operator|*
name|proto
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|log_DumpBp
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPE: Input: Packet:"
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|=
name|mbuf_Read
argument_list|(
name|mp
argument_list|,
operator|&
name|prefix
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|ntohs
argument_list|(
name|prefix
argument_list|)
expr_stmt|;
name|flushed
operator|=
name|prefix
operator|&
name|MPPE_FLUSHED
expr_stmt|;
name|prefix
operator|&=
operator|~
name|flushed
expr_stmt|;
if|if
condition|(
operator|(
name|prefix
operator|&
name|MPPE_HEADER_BITMASK
operator|)
operator|!=
name|MPPE_ENCRYPTED
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"MPPE: Input: Invalid packet (flags = 0x%x)\n"
argument_list|,
operator|(
name|prefix
operator|&
name|MPPE_HEADER_BITMASK
operator|)
operator||
name|flushed
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|prefix
operator|&=
operator|~
name|MPPE_HEADER_BITMASK
expr_stmt|;
if|if
condition|(
operator|!
name|flushed
operator|&&
name|mip
operator|->
name|stateless
condition|)
block|{
name|log_Printf
argument_list|(
name|LogCCP
argument_list|,
literal|"MPPEInput: Packet without MPPE_FLUSHED set"
literal|" in stateless mode\n"
argument_list|)
expr_stmt|;
name|flushed
operator|=
name|MPPE_FLUSHED
expr_stmt|;
comment|/* Should we really continue ? */
block|}
if|if
condition|(
name|mip
operator|->
name|stateless
condition|)
block|{
comment|/* Change our key for each missed packet in stateless mode */
while|while
condition|(
name|prefix
operator|!=
name|mip
operator|->
name|cohnum
condition|)
block|{
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPEInput: Key changed [%u]\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|MPPEKeyChange
argument_list|(
name|mip
argument_list|)
expr_stmt|;
comment|/*        * mip->cohnum contains what we received last time in stateless        * mode.        */
name|mip
operator|->
name|cohnum
operator|++
expr_stmt|;
name|mip
operator|->
name|cohnum
operator|&=
operator|~
name|MPPE_HEADER_BITMASK
expr_stmt|;
block|}
name|dictinit
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|flushed
condition|)
block|{
comment|/*        * We can always process a flushed packet.        * Catch up on any outstanding key changes.        */
name|n
operator|=
operator|(
name|prefix
operator|>>
name|MPPE_HEADER_FLAGSHIFT
operator|)
operator|-
operator|(
name|mip
operator|->
name|cohnum
operator|>>
name|MPPE_HEADER_FLAGSHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|n
operator|+=
name|MPPE_HEADER_STATEFUL_KEYCHANGES
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPEInput: Key changed during catchup [%u]\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|MPPEKeyChange
argument_list|(
name|mip
argument_list|)
expr_stmt|;
block|}
name|mip
operator|->
name|flushrequired
operator|=
literal|0
expr_stmt|;
name|mip
operator|->
name|cohnum
operator|=
name|prefix
expr_stmt|;
name|dictinit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mip
operator|->
name|flushrequired
condition|)
block|{
comment|/*        * Perhaps we should be lenient if        * (prefix& MPPE_HEADER_FLAGMASK) == MPPE_HEADER_FLAG        * The spec says that we shouldn't be though....        */
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPE: Not flushed - discarded\n"
argument_list|)
expr_stmt|;
name|fsm_Output
argument_list|(
operator|&
name|ccp
operator|->
name|fsm
argument_list|,
name|CODE_RESETREQ
argument_list|,
name|ccp
operator|->
name|fsm
operator|.
name|reqid
operator|++
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|MB_CCPOUT
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|prefix
operator|!=
name|mip
operator|->
name|cohnum
condition|)
block|{
comment|/*        * We're in stateful mode and didn't receive the expected        * packet.  Send a reset request, but don't tell the CCP layer        * about it as we don't expect to receive a Reset ACK !        * Guess what... M$ invented this !        */
name|log_Printf
argument_list|(
name|LogCCP
argument_list|,
literal|"MPPE: Input: Got seq %u, not %u\n"
argument_list|,
name|prefix
argument_list|,
name|mip
operator|->
name|cohnum
argument_list|)
expr_stmt|;
name|fsm_Output
argument_list|(
operator|&
name|ccp
operator|->
name|fsm
argument_list|,
name|CODE_RESETREQ
argument_list|,
name|ccp
operator|->
name|fsm
operator|.
name|reqid
operator|++
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|MB_CCPOUT
argument_list|)
expr_stmt|;
name|mip
operator|->
name|flushrequired
operator|=
literal|1
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|prefix
operator|&
name|MPPE_HEADER_FLAGMASK
operator|)
operator|==
name|MPPE_HEADER_FLAG
condition|)
block|{
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPEInput: Key changed [%u]\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|MPPEKeyChange
argument_list|(
name|mip
argument_list|)
expr_stmt|;
name|dictinit
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flushed
condition|)
name|dictinit
operator|=
literal|1
expr_stmt|;
comment|/*      * mip->cohnum contains what we expect to receive next time in stateful      * mode.      */
name|mip
operator|->
name|cohnum
operator|++
expr_stmt|;
name|mip
operator|->
name|cohnum
operator|&=
operator|~
name|MPPE_HEADER_BITMASK
expr_stmt|;
block|}
if|if
condition|(
name|dictinit
condition|)
block|{
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPEInput: Dictionary initialised [%u]\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|RC4_set_key
argument_list|(
operator|&
name|mip
operator|->
name|rc4key
argument_list|,
name|mip
operator|->
name|keylen
argument_list|,
name|mip
operator|->
name|sesskey
argument_list|)
expr_stmt|;
block|}
name|mp
operator|=
name|mbuf_Read
argument_list|(
name|mp
argument_list|,
name|proto
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|RC4
argument_list|(
operator|&
name|mip
operator|->
name|rc4key
argument_list|,
literal|2
argument_list|,
operator|(
name|char
operator|*
operator|)
name|proto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|proto
argument_list|)
expr_stmt|;
operator|*
name|proto
operator|=
name|ntohs
argument_list|(
operator|*
name|proto
argument_list|)
expr_stmt|;
name|rp
operator|=
name|MBUF_CTOP
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|len
operator|=
name|m_length
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|RC4
argument_list|(
operator|&
name|mip
operator|->
name|rc4key
argument_list|,
name|len
argument_list|,
name|rp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPEInput: Decrypted: Proto %02x (%d bytes)\n"
argument_list|,
operator|*
name|proto
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|log_DumpBp
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPEInput: Decrypted: Packet:"
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ccp
operator|->
name|uncompin
operator|+=
name|len
expr_stmt|;
return|return
name|mp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|MPPEDictSetup
parameter_list|(
name|void
modifier|*
name|v
parameter_list|,
name|struct
name|ccp
modifier|*
name|ccp
parameter_list|,
name|u_short
name|proto
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mi
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|MPPEDispOpts
parameter_list|(
name|struct
name|lcp_opt
modifier|*
name|o
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|70
index|]
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|,
name|n
decl_stmt|;
name|ua_ntohl
argument_list|(
name|o
operator|->
name|data
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
literal|"value 0x%08x "
argument_list|,
operator|(
name|unsigned
operator|)
name|val
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|len
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|MPPE_OPT_BITMASK
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|len
argument_list|,
literal|"(0"
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|len
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
literal|'('
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MPPE_OPT_128BIT
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|len
argument_list|,
literal|"%c128"
argument_list|,
name|ch
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|len
operator|+=
name|n
expr_stmt|;
name|ch
operator|=
literal|'/'
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|MPPE_OPT_56BIT
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|len
argument_list|,
literal|"%c56"
argument_list|,
name|ch
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|len
operator|+=
name|n
expr_stmt|;
name|ch
operator|=
literal|'/'
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|&
name|MPPE_OPT_40BIT
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|len
argument_list|,
literal|"%c40"
argument_list|,
name|ch
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|len
operator|+=
name|n
expr_stmt|;
name|ch
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|len
argument_list|,
literal|" bits, state%s"
argument_list|,
operator|(
name|val
operator|&
name|MPPE_OPT_STATELESS
operator|)
condition|?
literal|"less"
else|:
literal|"ful"
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|len
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|MPPE_OPT_COMPRESSED
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|len
argument_list|,
literal|", compressed"
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|len
operator|+=
name|n
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
operator|+
name|len
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|len
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MPPEUsable
parameter_list|(
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|lcp
modifier|*
name|lcp
decl_stmt|;
name|int
name|ok
decl_stmt|;
name|lcp
operator|=
operator|&
name|fp
operator|->
name|link
operator|->
name|lcp
expr_stmt|;
name|ok
operator|=
operator|(
name|lcp
operator|->
name|want_auth
operator|==
name|PROTO_CHAP
operator|&&
name|lcp
operator|->
name|want_authtype
operator|==
literal|0x81
operator|)
operator|||
operator|(
name|lcp
operator|->
name|his_auth
operator|==
name|PROTO_CHAP
operator|&&
name|lcp
operator|->
name|his_authtype
operator|==
literal|0x81
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|log_Printf
argument_list|(
name|LogCCP
argument_list|,
literal|"MPPE: Not usable without CHAP81\n"
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MPPERequired
parameter_list|(
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
return|return
name|fp
operator|->
name|link
operator|->
name|ccp
operator|.
name|cfg
operator|.
name|mppe
operator|.
name|required
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|MPPE_ConfigVal
parameter_list|(
specifier|const
name|struct
name|ccp_config
modifier|*
name|cfg
parameter_list|)
block|{
name|u_int32_t
name|val
decl_stmt|;
name|val
operator|=
name|cfg
operator|->
name|mppe
operator|.
name|state
operator|==
name|MPPE_STATELESS
condition|?
name|MPPE_OPT_STATELESS
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|cfg
operator|->
name|mppe
operator|.
name|keybits
condition|)
block|{
case|case
literal|128
case|:
name|val
operator||=
name|MPPE_OPT_128BIT
expr_stmt|;
break|break;
case|case
literal|56
case|:
name|val
operator||=
name|MPPE_OPT_56BIT
expr_stmt|;
break|break;
case|case
literal|40
case|:
name|val
operator||=
name|MPPE_OPT_40BIT
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|val
operator||=
name|MPPE_OPT_128BIT
operator||
name|MPPE_OPT_56BIT
operator||
name|MPPE_OPT_40BIT
expr_stmt|;
break|break;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * What options should we use for our first configure request  */
end_comment

begin_function
specifier|static
name|void
name|MPPEInitOptsOutput
parameter_list|(
name|struct
name|lcp_opt
modifier|*
name|o
parameter_list|,
specifier|const
name|struct
name|ccp_config
modifier|*
name|cfg
parameter_list|)
block|{
name|u_int32_t
name|mval
decl_stmt|;
name|o
operator|->
name|len
operator|=
literal|6
expr_stmt|;
if|if
condition|(
operator|!
name|MPPE_MasterKeyValid
condition|)
block|{
name|log_Printf
argument_list|(
name|LogCCP
argument_list|,
literal|"MPPE: MasterKey is invalid,"
literal|" MPPE is available only with CHAP81 authentication\n"
argument_list|)
expr_stmt|;
name|ua_htonl
argument_list|(
literal|0x0
argument_list|,
name|o
operator|->
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
name|mval
operator|=
name|MPPE_ConfigVal
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
name|ua_htonl
argument_list|(
operator|&
name|mval
argument_list|,
name|o
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Our CCP request was NAK'd with the given options  */
end_comment

begin_function
specifier|static
name|int
name|MPPESetOptsOutput
parameter_list|(
name|struct
name|lcp_opt
modifier|*
name|o
parameter_list|,
specifier|const
name|struct
name|ccp_config
modifier|*
name|cfg
parameter_list|)
block|{
name|u_int32_t
name|mval
decl_stmt|,
name|peer
decl_stmt|;
name|ua_ntohl
argument_list|(
name|o
operator|->
name|data
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MPPE_MasterKeyValid
condition|)
comment|/* Treat their NAK as a REJ */
return|return
name|MODE_NAK
return|;
name|mval
operator|=
name|MPPE_ConfigVal
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
comment|/*    * If we haven't been configured with a specific number of keybits, allow    * whatever the peer asks for.    */
if|if
condition|(
operator|!
name|cfg
operator|->
name|mppe
operator|.
name|keybits
condition|)
block|{
name|mval
operator|&=
operator|~
name|MPPE_OPT_BITMASK
expr_stmt|;
name|mval
operator||=
operator|(
name|peer
operator|&
name|MPPE_OPT_BITMASK
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mval
operator|&
name|MPPE_OPT_BITMASK
operator|)
condition|)
name|mval
operator||=
name|MPPE_OPT_128BIT
expr_stmt|;
block|}
comment|/* Adjust our statelessness */
if|if
condition|(
name|cfg
operator|->
name|mppe
operator|.
name|state
operator|==
name|MPPE_ANYSTATE
condition|)
block|{
name|mval
operator|&=
operator|~
name|MPPE_OPT_STATELESS
expr_stmt|;
name|mval
operator||=
operator|(
name|peer
operator|&
name|MPPE_OPT_STATELESS
operator|)
expr_stmt|;
block|}
name|ua_htonl
argument_list|(
operator|&
name|mval
argument_list|,
name|o
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|MODE_ACK
return|;
block|}
end_function

begin_comment
comment|/*  * The peer has requested the given options  */
end_comment

begin_function
specifier|static
name|int
name|MPPESetOptsInput
parameter_list|(
name|struct
name|lcp_opt
modifier|*
name|o
parameter_list|,
specifier|const
name|struct
name|ccp_config
modifier|*
name|cfg
parameter_list|)
block|{
name|u_int32_t
name|mval
decl_stmt|,
name|peer
decl_stmt|;
name|int
name|res
init|=
name|MODE_ACK
decl_stmt|;
name|ua_ntohl
argument_list|(
name|o
operator|->
name|data
argument_list|,
operator|&
name|peer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MPPE_MasterKeyValid
condition|)
block|{
if|if
condition|(
name|peer
operator|!=
literal|0
condition|)
block|{
name|peer
operator|=
literal|0
expr_stmt|;
name|ua_htonl
argument_list|(
operator|&
name|peer
argument_list|,
name|o
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|MODE_NAK
return|;
block|}
else|else
return|return
name|MODE_ACK
return|;
block|}
name|mval
operator|=
name|MPPE_ConfigVal
argument_list|(
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|peer
operator|&
operator|~
name|MPPE_OPT_MASK
condition|)
comment|/* He's asking for bits we don't know about */
name|res
operator|=
name|MODE_NAK
expr_stmt|;
if|if
condition|(
name|peer
operator|&
name|MPPE_OPT_STATELESS
condition|)
block|{
if|if
condition|(
name|cfg
operator|->
name|mppe
operator|.
name|state
operator|==
name|MPPE_STATEFUL
condition|)
comment|/* Peer can't have stateless */
name|res
operator|=
name|MODE_NAK
expr_stmt|;
else|else
comment|/* Peer wants stateless, that's ok */
name|mval
operator||=
name|MPPE_OPT_STATELESS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cfg
operator|->
name|mppe
operator|.
name|state
operator|==
name|MPPE_STATELESS
condition|)
comment|/* Peer must have stateless */
name|res
operator|=
name|MODE_NAK
expr_stmt|;
else|else
comment|/* Peer doesn't want stateless, that's ok */
name|mval
operator|&=
operator|~
name|MPPE_OPT_STATELESS
expr_stmt|;
block|}
comment|/* If we've got a configured number of keybits - the peer must use that */
if|if
condition|(
name|cfg
operator|->
name|mppe
operator|.
name|keybits
condition|)
block|{
name|ua_htonl
argument_list|(
operator|&
name|mval
argument_list|,
name|o
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|peer
operator|==
name|mval
condition|?
name|res
else|:
name|MODE_NAK
return|;
block|}
comment|/* If a specific number of bits hasn't been requested, we'll need to NAK */
switch|switch
condition|(
name|peer
operator|&
name|MPPE_OPT_BITMASK
condition|)
block|{
case|case
name|MPPE_OPT_128BIT
case|:
case|case
name|MPPE_OPT_56BIT
case|:
case|case
name|MPPE_OPT_40BIT
case|:
break|break;
default|default:
name|res
operator|=
name|MODE_NAK
expr_stmt|;
block|}
comment|/* Suggest the best number of bits */
name|mval
operator|&=
operator|~
name|MPPE_OPT_BITMASK
expr_stmt|;
if|if
condition|(
name|peer
operator|&
name|MPPE_OPT_128BIT
condition|)
name|mval
operator||=
name|MPPE_OPT_128BIT
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|&
name|MPPE_OPT_56BIT
condition|)
name|mval
operator||=
name|MPPE_OPT_56BIT
expr_stmt|;
elseif|else
if|if
condition|(
name|peer
operator|&
name|MPPE_OPT_40BIT
condition|)
name|mval
operator||=
name|MPPE_OPT_40BIT
expr_stmt|;
else|else
name|mval
operator||=
name|MPPE_OPT_128BIT
expr_stmt|;
name|ua_htonl
argument_list|(
operator|&
name|mval
argument_list|,
name|o
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mppe_state
modifier|*
name|MPPE_InitState
parameter_list|(
name|struct
name|lcp_opt
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|mppe_state
modifier|*
name|mp
decl_stmt|;
name|u_int32_t
name|val
decl_stmt|;
if|if
condition|(
operator|(
name|mp
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
expr|*
name|mp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ua_ntohl
argument_list|(
name|o
operator|->
name|data
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|val
operator|&
name|MPPE_OPT_BITMASK
condition|)
block|{
case|case
name|MPPE_OPT_128BIT
case|:
name|mp
operator|->
name|keylen
operator|=
literal|16
expr_stmt|;
name|mp
operator|->
name|keybits
operator|=
literal|128
expr_stmt|;
break|break;
case|case
name|MPPE_OPT_56BIT
case|:
name|mp
operator|->
name|keylen
operator|=
literal|8
expr_stmt|;
name|mp
operator|->
name|keybits
operator|=
literal|56
expr_stmt|;
break|break;
case|case
name|MPPE_OPT_40BIT
case|:
name|mp
operator|->
name|keylen
operator|=
literal|8
expr_stmt|;
name|mp
operator|->
name|keybits
operator|=
literal|40
expr_stmt|;
break|break;
default|default:
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Unexpected MPPE options 0x%08x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mp
operator|->
name|stateless
operator|=
operator|!
operator|!
operator|(
name|val
operator|&
name|MPPE_OPT_STATELESS
operator|)
expr_stmt|;
block|}
return|return
name|mp
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|MPPEInitInput
parameter_list|(
name|struct
name|lcp_opt
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|mppe_state
modifier|*
name|mip
decl_stmt|;
if|if
condition|(
operator|!
name|MPPE_MasterKeyValid
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MPPE: Cannot initialise without CHAP81\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|mip
operator|=
name|MPPE_InitState
argument_list|(
name|o
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MPPEInput: Cannot initialise - unexpected options\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPE: InitInput: %d-bits\n"
argument_list|,
name|mip
operator|->
name|keybits
argument_list|)
expr_stmt|;
name|GetAsymetricStartKey
argument_list|(
name|MPPE_MasterKey
argument_list|,
name|mip
operator|->
name|mastkey
argument_list|,
name|mip
operator|->
name|keylen
argument_list|,
literal|0
argument_list|,
name|MPPE_IsServer
argument_list|)
expr_stmt|;
name|GetNewKeyFromSHA
argument_list|(
name|mip
operator|->
name|mastkey
argument_list|,
name|mip
operator|->
name|mastkey
argument_list|,
name|mip
operator|->
name|keylen
argument_list|,
name|mip
operator|->
name|sesskey
argument_list|)
expr_stmt|;
name|MPPEReduceSessionKey
argument_list|(
name|mip
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogCCP
argument_list|,
literal|"MPPE: Input channel initiated\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mip
operator|->
name|stateless
condition|)
block|{
comment|/*      * We need to initialise our dictionary here as the first packet we      * receive is unlikely to have the FLUSHED bit set.      */
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPEInitInput: Dictionary initialised [%d]\n"
argument_list|,
name|mip
operator|->
name|cohnum
argument_list|)
expr_stmt|;
name|RC4_set_key
argument_list|(
operator|&
name|mip
operator|->
name|rc4key
argument_list|,
name|mip
operator|->
name|keylen
argument_list|,
name|mip
operator|->
name|sesskey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*      * We do the first key change here as the first packet is expected      * to have a sequence number of 0 and we'll therefore not expect      * to have to change the key at that point.      */
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPEInitInput: Key changed [%d]\n"
argument_list|,
name|mip
operator|->
name|cohnum
argument_list|)
expr_stmt|;
name|MPPEKeyChange
argument_list|(
name|mip
argument_list|)
expr_stmt|;
block|}
return|return
name|mip
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|MPPEInitOutput
parameter_list|(
name|struct
name|lcp_opt
modifier|*
name|o
parameter_list|)
block|{
name|struct
name|mppe_state
modifier|*
name|mop
decl_stmt|;
if|if
condition|(
operator|!
name|MPPE_MasterKeyValid
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MPPE: Cannot initialise without CHAP81\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|mop
operator|=
name|MPPE_InitState
argument_list|(
name|o
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"MPPEOutput: Cannot initialise - unexpected options\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPE: InitOutput: %d-bits\n"
argument_list|,
name|mop
operator|->
name|keybits
argument_list|)
expr_stmt|;
name|GetAsymetricStartKey
argument_list|(
name|MPPE_MasterKey
argument_list|,
name|mop
operator|->
name|mastkey
argument_list|,
name|mop
operator|->
name|keylen
argument_list|,
literal|1
argument_list|,
name|MPPE_IsServer
argument_list|)
expr_stmt|;
name|GetNewKeyFromSHA
argument_list|(
name|mop
operator|->
name|mastkey
argument_list|,
name|mop
operator|->
name|mastkey
argument_list|,
name|mop
operator|->
name|keylen
argument_list|,
name|mop
operator|->
name|sesskey
argument_list|)
expr_stmt|;
name|MPPEReduceSessionKey
argument_list|(
name|mop
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogCCP
argument_list|,
literal|"MPPE: Output channel initiated\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mop
operator|->
name|stateless
condition|)
block|{
comment|/*      * We need to initialise our dictionary now as the first packet we      * send won't have the FLUSHED bit set.      */
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"MPPEInitOutput: Dictionary initialised [%d]\n"
argument_list|,
name|mop
operator|->
name|cohnum
argument_list|)
expr_stmt|;
name|RC4_set_key
argument_list|(
operator|&
name|mop
operator|->
name|rc4key
argument_list|,
name|mop
operator|->
name|keylen
argument_list|,
name|mop
operator|->
name|sesskey
argument_list|)
expr_stmt|;
block|}
return|return
name|mop
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|MPPETermInput
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|MPPETermOutput
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|free
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ccp_algorithm
name|MPPEAlgorithm
init|=
block|{
name|TY_MPPE
block|,
name|CCP_NEG_MPPE
block|,
name|MPPEDispOpts
block|,
name|MPPEUsable
block|,
name|MPPERequired
block|,
block|{
name|MPPESetOptsInput
block|,
name|MPPEInitInput
block|,
name|MPPETermInput
block|,
name|MPPEResetInput
block|,
name|MPPEInput
block|,
name|MPPEDictSetup
block|}
block|,
block|{
literal|2
block|,
name|MPPEInitOptsOutput
block|,
name|MPPESetOptsOutput
block|,
name|MPPEInitOutput
block|,
name|MPPETermOutput
block|,
name|MPPEResetOutput
block|,
name|MPPEOutput
block|}
block|, }
decl_stmt|;
end_decl_stmt

end_unit

