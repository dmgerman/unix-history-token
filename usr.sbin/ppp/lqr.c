begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	      PPP Line Quality Monitoring (LQM) Module  *  *	    Written by Toshiharu OHNO (tony-o@iij.ad.jp)  *  *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the Internet Initiative Japan, Inc.  The name of the  * IIJ may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * $Id: lqr.c,v 1.18 1997/08/31 22:59:35 brian Exp $  *  *	o LQR based on RFC1333  *  * TODO:  *	o LQM policy  *	o Allow user to configure LQM method and interval.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcpproto.h"
end_include

begin_include
include|#
directive|include
file|"lqr.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"loadalias.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"vars.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_decl_stmt
name|struct
name|pppTimer
name|LqrTimer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|lastpeerin
init|=
operator|(
name|u_long
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lqmmethod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|echoseq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gotseq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lqrsendcnt
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|echolqr
block|{
name|u_long
name|magic
decl_stmt|;
name|u_long
name|signature
decl_stmt|;
name|u_long
name|sequence
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIGNATURE
value|0x594e4f54
end_define

begin_function
specifier|static
name|void
name|SendEchoReq
parameter_list|()
block|{
name|struct
name|fsm
modifier|*
name|fp
init|=
operator|&
name|LcpFsm
decl_stmt|;
name|struct
name|echolqr
modifier|*
name|lqr
decl_stmt|,
name|lqrdata
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|state
operator|==
name|ST_OPENED
condition|)
block|{
name|lqr
operator|=
operator|&
name|lqrdata
expr_stmt|;
name|lqr
operator|->
name|magic
operator|=
name|htonl
argument_list|(
name|LcpInfo
operator|.
name|want_magic
argument_list|)
expr_stmt|;
name|lqr
operator|->
name|signature
operator|=
name|htonl
argument_list|(
name|SIGNATURE
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"Send echo LQR [%d]\n"
argument_list|,
name|echoseq
argument_list|)
expr_stmt|;
name|lqr
operator|->
name|sequence
operator|=
name|htonl
argument_list|(
name|echoseq
operator|++
argument_list|)
expr_stmt|;
name|FsmOutput
argument_list|(
name|fp
argument_list|,
name|CODE_ECHOREQ
argument_list|,
name|fp
operator|->
name|reqid
operator|++
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|lqr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|echolqr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|RecvEchoLqr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|echolqr
modifier|*
name|lqr
decl_stmt|;
name|u_long
name|seq
decl_stmt|;
if|if
condition|(
name|plength
argument_list|(
name|bp
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|echolqr
argument_list|)
condition|)
block|{
name|lqr
operator|=
operator|(
expr|struct
name|echolqr
operator|*
operator|)
name|MBUF_CTOP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|htonl
argument_list|(
name|lqr
operator|->
name|signature
argument_list|)
operator|==
name|SIGNATURE
condition|)
block|{
name|seq
operator|=
name|ntohl
argument_list|(
name|lqr
operator|->
name|sequence
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"Got echo LQR [%d]\n"
argument_list|,
name|ntohl
argument_list|(
name|lqr
operator|->
name|sequence
argument_list|)
argument_list|)
expr_stmt|;
name|gotseq
operator|=
name|seq
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|LqrChangeOrder
parameter_list|(
name|struct
name|lqrdata
modifier|*
name|src
parameter_list|,
name|struct
name|lqrdata
modifier|*
name|dst
parameter_list|)
block|{
name|u_long
modifier|*
name|sp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|sp
operator|=
operator|(
name|u_long
operator|*
operator|)
name|src
expr_stmt|;
name|dp
operator|=
operator|(
name|u_long
operator|*
operator|)
name|dst
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|lqrdata
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|;
name|n
operator|++
control|)
operator|*
name|dp
operator|++
operator|=
name|ntohl
argument_list|(
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|SendLqrReport
parameter_list|()
block|{
name|struct
name|mbuf
modifier|*
name|bp
decl_stmt|;
name|StopTimer
argument_list|(
operator|&
name|LqrTimer
argument_list|)
expr_stmt|;
if|if
condition|(
name|lqmmethod
operator|&
name|LQM_LQR
condition|)
block|{
if|if
condition|(
name|lqrsendcnt
operator|>
literal|5
condition|)
block|{
comment|/*        * XXX: Should implement LQM strategy        */
name|LogPrintf
argument_list|(
name|LogPHASE
argument_list|,
literal|"** 1 Too many ECHO packets are lost. **\n"
argument_list|)
expr_stmt|;
name|lqmmethod
operator|=
literal|0
expr_stmt|;
comment|/* Prevent rcursion via LcpClose() */
name|reconnect
argument_list|(
name|RECON_TRUE
argument_list|)
expr_stmt|;
name|LcpClose
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
name|mballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lqrdata
argument_list|)
argument_list|,
name|MB_LQR
argument_list|)
expr_stmt|;
name|HdlcOutput
argument_list|(
name|PRI_LINK
argument_list|,
name|PROTO_LQR
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|lqrsendcnt
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lqmmethod
operator|&
name|LQM_ECHO
condition|)
block|{
if|if
condition|(
name|echoseq
operator|-
name|gotseq
operator|>
literal|5
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogPHASE
argument_list|,
literal|"** 2 Too many ECHO packets are lost. **\n"
argument_list|)
expr_stmt|;
name|lqmmethod
operator|=
literal|0
expr_stmt|;
comment|/* Prevent rcursion via LcpClose() */
name|reconnect
argument_list|(
name|RECON_TRUE
argument_list|)
expr_stmt|;
name|LcpClose
argument_list|()
expr_stmt|;
block|}
else|else
name|SendEchoReq
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|lqmmethod
operator|&&
name|Enabled
argument_list|(
name|ConfLqr
argument_list|)
condition|)
name|StartTimer
argument_list|(
operator|&
name|LqrTimer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|LqrInput
parameter_list|(
name|struct
name|mbuf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|struct
name|lqrdata
modifier|*
name|lqr
decl_stmt|;
name|len
operator|=
name|plength
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|lqrdata
argument_list|)
condition|)
block|{
name|pfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|Acceptable
argument_list|(
name|ConfLqr
argument_list|)
condition|)
block|{
name|bp
operator|->
name|offset
operator|-=
literal|2
expr_stmt|;
name|bp
operator|->
name|cnt
operator|+=
literal|2
expr_stmt|;
name|cp
operator|=
name|MBUF_CTOP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LcpSendProtoRej
argument_list|(
name|cp
argument_list|,
name|bp
operator|->
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|MBUF_CTOP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|lqr
operator|=
operator|(
expr|struct
name|lqrdata
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|lqr
operator|->
name|MagicNumber
argument_list|)
operator|!=
name|LcpInfo
operator|.
name|his_magic
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogERROR
argument_list|,
literal|"LqrInput: magic %x != expecting %x\n"
argument_list|,
name|ntohl
argument_list|(
name|lqr
operator|->
name|MagicNumber
argument_list|)
argument_list|,
name|LcpInfo
operator|.
name|his_magic
argument_list|)
expr_stmt|;
name|pfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Convert byte order and save into our strage      */
name|LqrChangeOrder
argument_list|(
name|lqr
argument_list|,
operator|&
name|HisLqrData
argument_list|)
expr_stmt|;
name|LqrDump
argument_list|(
literal|"LqrInput"
argument_list|,
operator|&
name|HisLqrData
argument_list|)
expr_stmt|;
name|lqrsendcnt
operator|=
literal|0
expr_stmt|;
comment|/* we have received LQR from peer */
comment|/*      * Generate LQR responce to peer, if i) We are not running LQR timer. ii)      * Two successive LQR's PeerInLQRs are same.      */
if|if
condition|(
name|LqrTimer
operator|.
name|load
operator|==
literal|0
operator|||
name|lastpeerin
operator|==
name|HisLqrData
operator|.
name|PeerInLQRs
condition|)
block|{
name|lqmmethod
operator||=
name|LQM_LQR
expr_stmt|;
name|SendLqrReport
argument_list|()
expr_stmt|;
block|}
name|lastpeerin
operator|=
name|HisLqrData
operator|.
name|PeerInLQRs
expr_stmt|;
block|}
name|pfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  When LCP is reached to opened state, We'll start LQM activity.  */
end_comment

begin_function
name|void
name|StartLqm
parameter_list|()
block|{
name|struct
name|lcpstate
modifier|*
name|lcp
init|=
operator|&
name|LcpInfo
decl_stmt|;
name|int
name|period
decl_stmt|;
name|lqrsendcnt
operator|=
literal|0
expr_stmt|;
comment|/* start waiting all over for ECHOs */
name|echoseq
operator|=
literal|0
expr_stmt|;
name|gotseq
operator|=
literal|0
expr_stmt|;
name|lqmmethod
operator|=
name|LQM_ECHO
expr_stmt|;
if|if
condition|(
name|Enabled
argument_list|(
name|ConfLqr
argument_list|)
condition|)
name|lqmmethod
operator||=
name|LQM_LQR
expr_stmt|;
name|StopTimer
argument_list|(
operator|&
name|LqrTimer
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"LQM method = %d\n"
argument_list|,
name|lqmmethod
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcp
operator|->
name|his_lqrperiod
operator|||
name|lcp
operator|->
name|want_lqrperiod
condition|)
block|{
comment|/*      * We need to run timer. Let's figure out period.      */
name|period
operator|=
name|lcp
operator|->
name|his_lqrperiod
condition|?
name|lcp
operator|->
name|his_lqrperiod
else|:
name|lcp
operator|->
name|want_lqrperiod
expr_stmt|;
name|StopTimer
argument_list|(
operator|&
name|LqrTimer
argument_list|)
expr_stmt|;
name|LqrTimer
operator|.
name|state
operator|=
name|TIMER_STOPPED
expr_stmt|;
name|LqrTimer
operator|.
name|load
operator|=
name|period
operator|*
name|SECTICKS
operator|/
literal|100
expr_stmt|;
name|LqrTimer
operator|.
name|func
operator|=
name|SendLqrReport
expr_stmt|;
name|SendLqrReport
argument_list|()
expr_stmt|;
name|StartTimer
argument_list|(
operator|&
name|LqrTimer
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"Will send LQR every %d.%d secs\n"
argument_list|,
name|period
operator|/
literal|100
argument_list|,
name|period
operator|%
literal|100
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"LQR is not activated.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|StopLqrTimer
parameter_list|()
block|{
name|StopTimer
argument_list|(
operator|&
name|LqrTimer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|StopLqr
parameter_list|(
name|int
name|method
parameter_list|)
block|{
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"StopLqr method = %x\n"
argument_list|,
name|method
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|==
name|LQM_LQR
condition|)
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"Stop sending LQR, Use LCP ECHO instead.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|method
operator|==
name|LQM_ECHO
condition|)
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"Stop sending LCP ECHO.\n"
argument_list|)
expr_stmt|;
name|lqmmethod
operator|&=
operator|~
name|method
expr_stmt|;
if|if
condition|(
name|lqmmethod
condition|)
name|SendLqrReport
argument_list|()
expr_stmt|;
else|else
name|StopTimer
argument_list|(
operator|&
name|LqrTimer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|LqrDump
parameter_list|(
name|char
modifier|*
name|message
parameter_list|,
name|struct
name|lqrdata
modifier|*
name|lqr
parameter_list|)
block|{
if|if
condition|(
name|LogIsKept
argument_list|(
name|LogLQM
argument_list|)
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"%s:\n"
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"  Magic:          %08x   LastOutLQRs:    %08x\n"
argument_list|,
name|lqr
operator|->
name|MagicNumber
argument_list|,
name|lqr
operator|->
name|LastOutLQRs
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"  LastOutPackets: %08x   LastOutOctets:  %08x\n"
argument_list|,
name|lqr
operator|->
name|LastOutPackets
argument_list|,
name|lqr
operator|->
name|LastOutOctets
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"  PeerInLQRs:     %08x   PeerInPackets:  %08x\n"
argument_list|,
name|lqr
operator|->
name|PeerInLQRs
argument_list|,
name|lqr
operator|->
name|PeerInPackets
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"  PeerInDiscards: %08x   PeerInErrors:   %08x\n"
argument_list|,
name|lqr
operator|->
name|PeerInDiscards
argument_list|,
name|lqr
operator|->
name|PeerInErrors
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"  PeerInOctets:   %08x   PeerOutLQRs:    %08x\n"
argument_list|,
name|lqr
operator|->
name|PeerInOctets
argument_list|,
name|lqr
operator|->
name|PeerOutLQRs
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogLQM
argument_list|,
literal|"  PeerOutPackets: %08x   PeerOutOctets:  %08x\n"
argument_list|,
name|lqr
operator|->
name|PeerOutPackets
argument_list|,
name|lqr
operator|->
name|PeerOutOctets
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

