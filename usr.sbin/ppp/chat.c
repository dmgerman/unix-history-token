begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Brian Somers<brian@Awfulhak.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: chat.c,v 1.51 1998/08/07 18:42:47 brian Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"lqr.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"throughput.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ccp.h"
end_include

begin_include
include|#
directive|include
file|"link.h"
end_include

begin_include
include|#
directive|include
file|"async.h"
end_include

begin_include
include|#
directive|include
file|"descriptor.h"
end_include

begin_include
include|#
directive|include
file|"physical.h"
end_include

begin_include
include|#
directive|include
file|"chat.h"
end_include

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_include
include|#
directive|include
file|"iplist.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"filter.h"
end_include

begin_include
include|#
directive|include
file|"cbcp.h"
end_include

begin_include
include|#
directive|include
file|"datalink.h"
end_include

begin_include
include|#
directive|include
file|"bundle.h"
end_include

begin_define
define|#
directive|define
name|BUFLEFT
parameter_list|(
name|c
parameter_list|)
value|(sizeof (c)->buf - ((c)->bufend - (c)->buf))
end_define

begin_define
define|#
directive|define
name|issep
parameter_list|(
name|c
parameter_list|)
value|((c) == '\t' || (c) == ' ')
end_define

begin_function_decl
specifier|static
name|void
name|ExecStr
parameter_list|(
name|struct
name|physical
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|ExpandString
parameter_list|(
name|struct
name|chat
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|chat_PauseTimer
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|chat
modifier|*
name|c
init|=
operator|(
expr|struct
name|chat
operator|*
operator|)
name|v
decl_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|c
operator|->
name|pause
argument_list|)
expr_stmt|;
name|c
operator|->
name|pause
operator|.
name|load
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chat_Pause
parameter_list|(
name|struct
name|chat
modifier|*
name|c
parameter_list|,
name|u_long
name|load
parameter_list|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|c
operator|->
name|pause
argument_list|)
expr_stmt|;
name|c
operator|->
name|pause
operator|.
name|load
operator|+=
name|load
expr_stmt|;
name|c
operator|->
name|pause
operator|.
name|func
operator|=
name|chat_PauseTimer
expr_stmt|;
name|c
operator|->
name|pause
operator|.
name|name
operator|=
literal|"chat pause"
expr_stmt|;
name|c
operator|->
name|pause
operator|.
name|arg
operator|=
name|c
expr_stmt|;
name|timer_Start
argument_list|(
operator|&
name|c
operator|->
name|pause
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chat_TimeoutTimer
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|chat
modifier|*
name|c
init|=
operator|(
expr|struct
name|chat
operator|*
operator|)
name|v
decl_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|c
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|c
operator|->
name|TimedOut
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chat_SetTimeout
parameter_list|(
name|struct
name|chat
modifier|*
name|c
parameter_list|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|c
operator|->
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|TimeoutSec
operator|>
literal|0
condition|)
block|{
name|c
operator|->
name|timeout
operator|.
name|load
operator|=
name|SECTICKS
operator|*
name|c
operator|->
name|TimeoutSec
expr_stmt|;
name|c
operator|->
name|timeout
operator|.
name|func
operator|=
name|chat_TimeoutTimer
expr_stmt|;
name|c
operator|->
name|timeout
operator|.
name|name
operator|=
literal|"chat timeout"
expr_stmt|;
name|c
operator|->
name|timeout
operator|.
name|arg
operator|=
name|c
expr_stmt|;
name|timer_Start
argument_list|(
operator|&
name|c
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|chat_NextChar
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|char
name|ch
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
if|if
condition|(
operator|*
name|ptr
operator|==
name|ch
condition|)
return|return
name|ptr
return|;
elseif|else
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\\'
condition|)
if|if
condition|(
operator|*
operator|++
name|ptr
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chat_UpdateSet
parameter_list|(
name|struct
name|descriptor
modifier|*
name|d
parameter_list|,
name|fd_set
modifier|*
name|r
parameter_list|,
name|fd_set
modifier|*
name|w
parameter_list|,
name|fd_set
modifier|*
name|e
parameter_list|,
name|int
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|chat
modifier|*
name|c
init|=
name|descriptor2chat
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|int
name|special
decl_stmt|,
name|gotabort
decl_stmt|,
name|gottimeout
decl_stmt|,
name|needcr
decl_stmt|;
name|int
name|TimedOut
init|=
name|c
operator|->
name|TimedOut
decl_stmt|;
specifier|static
name|char
name|arg_term
decl_stmt|;
comment|/* An empty string */
if|if
condition|(
name|c
operator|->
name|pause
operator|.
name|state
operator|==
name|TIMER_RUNNING
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TimedOut
condition|)
block|{
name|log_Printf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Expect timeout\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|nargptr
operator|==
name|NULL
condition|)
name|c
operator|->
name|state
operator|=
name|CHAT_FAILED
expr_stmt|;
else|else
block|{
comment|/* c->state = CHAT_EXPECT; */
name|c
operator|->
name|argptr
operator|=
operator|&
name|arg_term
expr_stmt|;
block|}
name|c
operator|->
name|TimedOut
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|state
operator|!=
name|CHAT_EXPECT
operator|&&
name|c
operator|->
name|state
operator|!=
name|CHAT_SEND
condition|)
return|return
literal|0
return|;
name|gottimeout
operator|=
name|gotabort
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|arg
operator|<
name|c
operator|->
name|argc
operator|&&
operator|(
name|c
operator|->
name|arg
operator|<
literal|0
operator|||
operator|*
name|c
operator|->
name|argptr
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* Go get the next string */
if|if
condition|(
name|c
operator|->
name|arg
operator|<
literal|0
operator|||
name|c
operator|->
name|state
operator|==
name|CHAT_SEND
condition|)
name|c
operator|->
name|state
operator|=
name|CHAT_EXPECT
expr_stmt|;
else|else
name|c
operator|->
name|state
operator|=
name|CHAT_SEND
expr_stmt|;
name|special
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|special
operator|&&
operator|(
name|c
operator|->
name|nargptr
operator|||
name|c
operator|->
name|arg
operator|<
name|c
operator|->
name|argc
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|arg
operator|<
literal|0
operator|||
operator|(
operator|!
name|TimedOut
operator|&&
name|c
operator|->
name|state
operator|==
name|CHAT_SEND
operator|)
condition|)
name|c
operator|->
name|nargptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|nargptr
operator|!=
name|NULL
condition|)
block|{
comment|/* We're doing expect-send-expect.... */
name|c
operator|->
name|argptr
operator|=
name|c
operator|->
name|nargptr
expr_stmt|;
comment|/* Put the '-' back in case we ever want to rerun our script */
name|c
operator|->
name|nargptr
index|[
operator|-
literal|1
index|]
operator|=
literal|'-'
expr_stmt|;
name|c
operator|->
name|nargptr
operator|=
name|chat_NextChar
argument_list|(
name|c
operator|->
name|nargptr
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|nargptr
operator|!=
name|NULL
condition|)
operator|*
name|c
operator|->
name|nargptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|int
name|minus
decl_stmt|;
name|c
operator|->
name|argptr
operator|=
name|c
operator|->
name|argv
index|[
operator|++
name|c
operator|->
name|arg
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|state
operator|==
name|CHAT_EXPECT
condition|)
block|{
comment|/* Look for expect-send-expect sequence */
name|c
operator|->
name|nargptr
operator|=
name|c
operator|->
name|argptr
expr_stmt|;
name|minus
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|->
name|nargptr
operator|=
name|chat_NextChar
argument_list|(
name|c
operator|->
name|nargptr
argument_list|,
literal|'-'
argument_list|)
operator|)
condition|)
block|{
name|c
operator|->
name|nargptr
operator|++
expr_stmt|;
name|minus
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|minus
operator|%
literal|2
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"chat_UpdateSet: \"%s\": Uneven number of"
literal|" '-' chars, all ignored\n"
argument_list|,
name|c
operator|->
name|argptr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|minus
condition|)
block|{
name|c
operator|->
name|nargptr
operator|=
name|chat_NextChar
argument_list|(
name|c
operator|->
name|argptr
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
operator|*
name|c
operator|->
name|nargptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
comment|/*        * c->argptr now temporarily points into c->script (via c->argv)        * If it's an expect-send-expect sequence, we've just got the correct        * portion of that sequence.        */
name|needcr
operator|=
name|c
operator|->
name|state
operator|==
name|CHAT_SEND
operator|&&
operator|*
name|c
operator|->
name|argptr
operator|!=
literal|'!'
expr_stmt|;
comment|/* We leave room for a potential HDLC header in the target string */
name|ExpandString
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|argptr
argument_list|,
name|c
operator|->
name|exp
operator|+
literal|2
argument_list|,
sizeof|sizeof
name|c
operator|->
name|exp
operator|-
literal|2
argument_list|,
name|needcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotabort
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|abort
operator|.
name|num
operator|<
name|MAXABORTS
condition|)
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|c
operator|->
name|exp
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|abort
operator|.
name|num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|len
operator|>
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|i
index|]
operator|.
name|len
condition|)
block|{
name|int
name|last
decl_stmt|;
for|for
control|(
name|last
operator|=
name|c
operator|->
name|abort
operator|.
name|num
init|;
name|last
operator|>
name|i
condition|;
name|last
operator|--
control|)
block|{
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|last
index|]
operator|.
name|data
operator|=
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|last
operator|-
literal|1
index|]
operator|.
name|data
expr_stmt|;
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|last
index|]
operator|.
name|len
operator|=
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|last
operator|-
literal|1
index|]
operator|.
name|len
expr_stmt|;
block|}
break|break;
block|}
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|i
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|i
index|]
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|c
operator|->
name|exp
operator|+
literal|2
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|abort
operator|.
name|num
operator|++
expr_stmt|;
block|}
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"chat_UpdateSet: too many abort strings\n"
argument_list|)
expr_stmt|;
name|gotabort
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gottimeout
condition|)
block|{
name|c
operator|->
name|TimeoutSec
operator|=
name|atoi
argument_list|(
name|c
operator|->
name|exp
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|TimeoutSec
operator|<=
literal|0
condition|)
name|c
operator|->
name|TimeoutSec
operator|=
literal|30
expr_stmt|;
name|gottimeout
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|nargptr
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|c
operator|->
name|exp
operator|+
literal|2
argument_list|,
literal|"ABORT"
argument_list|)
condition|)
name|gotabort
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|nargptr
operator|==
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|c
operator|->
name|exp
operator|+
literal|2
argument_list|,
literal|"TIMEOUT"
argument_list|)
condition|)
name|gottimeout
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|->
name|exp
index|[
literal|2
index|]
operator|==
literal|'!'
condition|)
name|ExecStr
argument_list|(
name|c
operator|->
name|physical
argument_list|,
name|c
operator|->
name|exp
operator|+
literal|3
argument_list|,
name|c
operator|->
name|exp
operator|+
literal|2
argument_list|,
sizeof|sizeof
name|c
operator|->
name|exp
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|exp
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Empty string, reparse (this may be better as a `goto start') */
name|c
operator|->
name|argptr
operator|=
operator|&
name|arg_term
expr_stmt|;
return|return
name|chat_UpdateSet
argument_list|(
name|d
argument_list|,
name|r
argument_list|,
name|w
argument_list|,
name|e
argument_list|,
name|n
argument_list|)
return|;
block|}
name|special
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|special
condition|)
block|{
if|if
condition|(
name|gottimeout
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"chat_UpdateSet: TIMEOUT: Argument expected\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gotabort
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"chat_UpdateSet: ABORT: Argument expected\n"
argument_list|)
expr_stmt|;
comment|/* End of script - all ok */
name|c
operator|->
name|state
operator|=
name|CHAT_DONE
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* set c->argptr to point in the right place */
name|c
operator|->
name|argptr
operator|=
name|c
operator|->
name|exp
operator|+
literal|2
expr_stmt|;
name|c
operator|->
name|arglen
operator|=
name|strlen
argument_list|(
name|c
operator|->
name|argptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|state
operator|==
name|CHAT_EXPECT
condition|)
block|{
comment|/* We must check to see if the string's already been found ! */
name|char
modifier|*
name|begin
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|end
operator|=
name|c
operator|->
name|bufend
operator|-
name|c
operator|->
name|arglen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|c
operator|->
name|bufstart
condition|)
name|end
operator|=
name|c
operator|->
name|bufstart
expr_stmt|;
for|for
control|(
name|begin
operator|=
name|c
operator|->
name|bufstart
init|;
name|begin
operator|<
name|end
condition|;
name|begin
operator|++
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|begin
argument_list|,
name|c
operator|->
name|argptr
argument_list|,
name|c
operator|->
name|arglen
argument_list|)
condition|)
block|{
name|c
operator|->
name|bufstart
operator|=
name|begin
operator|+
name|c
operator|->
name|arglen
expr_stmt|;
name|c
operator|->
name|argptr
operator|+=
name|c
operator|->
name|arglen
expr_stmt|;
name|c
operator|->
name|arglen
operator|=
literal|0
expr_stmt|;
comment|/* Continue - we've already read our expect string */
return|return
name|chat_UpdateSet
argument_list|(
name|d
argument_list|,
name|r
argument_list|,
name|w
argument_list|,
name|e
argument_list|,
name|n
argument_list|)
return|;
block|}
name|log_Printf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Expect(%d): %s\n"
argument_list|,
name|c
operator|->
name|TimeoutSec
argument_list|,
name|c
operator|->
name|argptr
argument_list|)
expr_stmt|;
name|chat_SetTimeout
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*    * We now have c->argptr pointing at what we want to expect/send and    * c->state saying what we want to do... we now know what to put in    * the fd_set :-)    */
if|if
condition|(
name|c
operator|->
name|state
operator|==
name|CHAT_EXPECT
condition|)
return|return
name|physical_UpdateSet
argument_list|(
operator|&
name|c
operator|->
name|physical
operator|->
name|desc
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|e
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
return|;
else|else
return|return
name|physical_UpdateSet
argument_list|(
operator|&
name|c
operator|->
name|physical
operator|->
name|desc
argument_list|,
name|NULL
argument_list|,
name|w
argument_list|,
name|e
argument_list|,
name|n
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|chat_IsSet
parameter_list|(
name|struct
name|descriptor
modifier|*
name|d
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|chat
modifier|*
name|c
init|=
name|descriptor2chat
argument_list|(
name|d
argument_list|)
decl_stmt|;
return|return
name|physical_IsSet
argument_list|(
operator|&
name|c
operator|->
name|physical
operator|->
name|desc
argument_list|,
name|fdset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chat_UpdateLog
parameter_list|(
name|struct
name|chat
modifier|*
name|c
parameter_list|,
name|int
name|in
parameter_list|)
block|{
if|if
condition|(
name|log_IsKept
argument_list|(
name|LogCHAT
argument_list|)
operator|||
name|log_IsKept
argument_list|(
name|LogCONNECT
argument_list|)
condition|)
block|{
comment|/*      * If a linefeed appears in the last `in' characters of `c's input      * buffer, output from there, all the way back to the last linefeed.      * This is called for every read of `in' bytes.      */
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|stop
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|level
decl_stmt|;
name|level
operator|=
name|log_IsKept
argument_list|(
name|LogCHAT
argument_list|)
condition|?
name|LogCHAT
else|:
name|LogCONNECT
expr_stmt|;
if|if
condition|(
name|in
operator|==
operator|-
literal|1
condition|)
name|end
operator|=
name|ptr
operator|=
name|c
operator|->
name|bufend
expr_stmt|;
else|else
block|{
name|ptr
operator|=
name|c
operator|->
name|bufend
operator|-
name|in
expr_stmt|;
for|for
control|(
name|end
operator|=
name|c
operator|->
name|bufend
operator|-
literal|1
init|;
name|end
operator|>=
name|ptr
condition|;
name|end
operator|--
control|)
if|if
condition|(
operator|*
name|end
operator|==
literal|'\n'
condition|)
break|break;
block|}
if|if
condition|(
name|end
operator|>=
name|ptr
condition|)
block|{
for|for
control|(
name|ptr
operator|=
name|c
operator|->
name|bufend
operator|-
operator|(
name|in
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
name|in
operator|+
literal|1
operator|)
init|;
name|ptr
operator|>=
name|c
operator|->
name|bufstart
condition|;
name|ptr
operator|--
control|)
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'\n'
condition|)
break|break;
name|ptr
operator|++
expr_stmt|;
name|stop
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|stop
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|(
name|stop
operator|=
name|memchr
argument_list|(
name|ptr
argument_list|,
literal|'\n'
argument_list|,
name|end
operator|-
name|ptr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|stop
operator|=
name|end
expr_stmt|;
name|ch
operator|=
operator|*
name|stop
expr_stmt|;
operator|*
name|stop
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|LogCHAT
operator|||
name|strstr
argument_list|(
name|ptr
argument_list|,
literal|"CONNECT"
argument_list|)
condition|)
name|log_Printf
argument_list|(
name|level
argument_list|,
literal|"Received: %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|stop
operator|=
name|ch
expr_stmt|;
name|ptr
operator|=
name|stop
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|chat_Read
parameter_list|(
name|struct
name|descriptor
modifier|*
name|d
parameter_list|,
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|chat
modifier|*
name|c
init|=
name|descriptor2chat
argument_list|(
name|d
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|state
operator|==
name|CHAT_EXPECT
condition|)
block|{
name|ssize_t
name|in
decl_stmt|;
name|char
modifier|*
name|abegin
decl_stmt|,
modifier|*
name|ebegin
decl_stmt|,
modifier|*
name|begin
decl_stmt|,
modifier|*
name|aend
decl_stmt|,
modifier|*
name|eend
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/*      * XXX - should this read only 1 byte to guarantee that we don't      * swallow any ppp talk from the peer ?      */
name|in
operator|=
name|BUFLEFT
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|>
sizeof|sizeof
name|c
operator|->
name|buf
operator|/
literal|2
condition|)
name|in
operator|=
sizeof|sizeof
name|c
operator|->
name|buf
operator|/
literal|2
expr_stmt|;
name|in
operator|=
name|physical_Read
argument_list|(
name|c
operator|->
name|physical
argument_list|,
name|c
operator|->
name|bufend
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|<=
literal|0
condition|)
return|return;
comment|/* `begin' and `end' delimit where we're going to strncmp() from */
name|ebegin
operator|=
name|c
operator|->
name|bufend
operator|-
name|c
operator|->
name|arglen
operator|+
literal|1
expr_stmt|;
name|eend
operator|=
name|ebegin
operator|+
name|in
expr_stmt|;
if|if
condition|(
name|ebegin
operator|<
name|c
operator|->
name|bufstart
condition|)
name|ebegin
operator|=
name|c
operator|->
name|bufstart
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|abort
operator|.
name|num
condition|)
block|{
name|abegin
operator|=
name|c
operator|->
name|bufend
operator|-
name|c
operator|->
name|abort
operator|.
name|string
index|[
literal|0
index|]
operator|.
name|len
operator|+
literal|1
expr_stmt|;
name|aend
operator|=
name|c
operator|->
name|bufend
operator|-
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|c
operator|->
name|abort
operator|.
name|num
operator|-
literal|1
index|]
operator|.
name|len
operator|+
name|in
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|abegin
operator|<
name|c
operator|->
name|bufstart
condition|)
name|abegin
operator|=
name|c
operator|->
name|bufstart
expr_stmt|;
block|}
else|else
block|{
name|abegin
operator|=
name|ebegin
expr_stmt|;
name|aend
operator|=
name|eend
expr_stmt|;
block|}
name|begin
operator|=
name|abegin
operator|<
name|ebegin
condition|?
name|abegin
else|:
name|ebegin
expr_stmt|;
name|end
operator|=
name|aend
operator|<
name|eend
condition|?
name|eend
else|:
name|aend
expr_stmt|;
name|c
operator|->
name|bufend
operator|+=
name|in
expr_stmt|;
name|chat_UpdateLog
argument_list|(
name|c
argument_list|,
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|bufend
operator|>
name|c
operator|->
name|buf
operator|+
sizeof|sizeof
name|c
operator|->
name|buf
operator|/
literal|2
condition|)
block|{
comment|/* Shuffle our receive buffer back a bit */
name|int
name|chop
decl_stmt|;
for|for
control|(
name|chop
operator|=
name|begin
operator|-
name|c
operator|->
name|buf
init|;
name|chop
condition|;
name|chop
operator|--
control|)
if|if
condition|(
name|c
operator|->
name|buf
index|[
name|chop
index|]
operator|==
literal|'\n'
condition|)
comment|/* found some already-logged garbage to remove :-) */
break|break;
if|if
condition|(
operator|!
name|chop
condition|)
name|chop
operator|=
name|begin
operator|-
name|c
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|chop
condition|)
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|to
operator|=
name|c
operator|->
name|buf
expr_stmt|;
name|from
operator|=
name|to
operator|+
name|chop
expr_stmt|;
while|while
condition|(
name|from
operator|<
name|c
operator|->
name|bufend
condition|)
operator|*
name|to
operator|++
operator|=
operator|*
name|from
operator|++
expr_stmt|;
name|c
operator|->
name|bufstart
operator|-=
name|chop
expr_stmt|;
name|c
operator|->
name|bufend
operator|-=
name|chop
expr_stmt|;
name|begin
operator|-=
name|chop
expr_stmt|;
name|end
operator|-=
name|chop
expr_stmt|;
name|abegin
operator|-=
name|chop
expr_stmt|;
name|aend
operator|-=
name|chop
expr_stmt|;
name|ebegin
operator|-=
name|chop
expr_stmt|;
name|eend
operator|-=
name|chop
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|begin
operator|<
name|end
condition|;
name|begin
operator|++
control|)
if|if
condition|(
name|begin
operator|>=
name|ebegin
operator|&&
name|begin
operator|<
name|eend
operator|&&
operator|!
name|strncmp
argument_list|(
name|begin
argument_list|,
name|c
operator|->
name|argptr
argument_list|,
name|c
operator|->
name|arglen
argument_list|)
condition|)
block|{
comment|/* Got it ! */
name|timer_Stop
argument_list|(
operator|&
name|c
operator|->
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|memchr
argument_list|(
name|begin
operator|+
name|c
operator|->
name|arglen
operator|-
literal|1
argument_list|,
literal|'\n'
argument_list|,
name|c
operator|->
name|bufend
operator|-
name|begin
operator|-
name|c
operator|->
name|arglen
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* force it into the log */
name|end
operator|=
name|c
operator|->
name|bufend
expr_stmt|;
name|c
operator|->
name|bufend
operator|=
name|begin
operator|+
name|c
operator|->
name|arglen
expr_stmt|;
name|chat_UpdateLog
argument_list|(
name|c
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|bufend
operator|=
name|end
expr_stmt|;
block|}
name|c
operator|->
name|bufstart
operator|=
name|begin
operator|+
name|c
operator|->
name|arglen
expr_stmt|;
name|c
operator|->
name|argptr
operator|+=
name|c
operator|->
name|arglen
expr_stmt|;
name|c
operator|->
name|arglen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|begin
operator|>=
name|abegin
operator|&&
name|begin
operator|<
name|aend
condition|)
block|{
for|for
control|(
name|n
operator|=
name|c
operator|->
name|abort
operator|.
name|num
operator|-
literal|1
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
block|{
if|if
condition|(
name|begin
operator|+
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|n
index|]
operator|.
name|len
operator|>
name|c
operator|->
name|bufend
condition|)
break|break;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|begin
argument_list|,
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|n
index|]
operator|.
name|data
argument_list|,
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|n
index|]
operator|.
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|memchr
argument_list|(
name|begin
operator|+
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|n
index|]
operator|.
name|len
operator|-
literal|1
argument_list|,
literal|'\n'
argument_list|,
name|c
operator|->
name|bufend
operator|-
name|begin
operator|-
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|n
index|]
operator|.
name|len
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* force it into the log */
name|end
operator|=
name|c
operator|->
name|bufend
expr_stmt|;
name|c
operator|->
name|bufend
operator|=
name|begin
operator|+
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|n
index|]
operator|.
name|len
expr_stmt|;
name|chat_UpdateLog
argument_list|(
name|c
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|bufend
operator|=
name|end
expr_stmt|;
block|}
name|c
operator|->
name|bufstart
operator|=
name|begin
operator|+
name|c
operator|->
name|abort
operator|.
name|string
index|[
name|n
index|]
operator|.
name|len
expr_stmt|;
name|c
operator|->
name|state
operator|=
name|CHAT_FAILED
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|chat_Write
parameter_list|(
name|struct
name|descriptor
modifier|*
name|d
parameter_list|,
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|chat
modifier|*
name|c
init|=
name|descriptor2chat
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|state
operator|==
name|CHAT_SEND
condition|)
block|{
name|int
name|wrote
decl_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|c
operator|->
name|argv
index|[
name|c
operator|->
name|arg
index|]
argument_list|,
literal|"\\P"
argument_list|)
condition|)
comment|/* Don't log the password */
name|log_Printf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Send: %s\n"
argument_list|,
name|c
operator|->
name|argv
index|[
name|c
operator|->
name|arg
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|sz
decl_stmt|;
name|sz
operator|=
name|c
operator|->
name|arglen
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|sz
operator|>=
literal|0
operator|&&
name|c
operator|->
name|argptr
index|[
name|sz
index|]
operator|==
literal|'\n'
condition|)
name|sz
operator|--
expr_stmt|;
name|log_Printf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Send: %.*s\n"
argument_list|,
name|sz
operator|+
literal|1
argument_list|,
name|c
operator|->
name|argptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|physical_IsSync
argument_list|(
name|c
operator|->
name|physical
argument_list|)
condition|)
block|{
comment|/* There's always room for the HDLC header */
name|c
operator|->
name|argptr
operator|-=
literal|2
expr_stmt|;
name|c
operator|->
name|arglen
operator|+=
literal|2
expr_stmt|;
name|memcpy
argument_list|(
name|c
operator|->
name|argptr
argument_list|,
literal|"\377\003"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Prepend HDLC header */
block|}
name|wrote
operator|=
name|physical_Write
argument_list|(
name|c
operator|->
name|physical
argument_list|,
name|c
operator|->
name|argptr
argument_list|,
name|c
operator|->
name|arglen
argument_list|)
expr_stmt|;
name|result
operator|=
name|wrote
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|wrote
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"chat_Write: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|physical_IsSync
argument_list|(
name|c
operator|->
name|physical
argument_list|)
condition|)
block|{
name|c
operator|->
name|argptr
operator|+=
literal|2
expr_stmt|;
name|c
operator|->
name|arglen
operator|-=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|wrote
operator|<
literal|2
operator|&&
name|physical_IsSync
argument_list|(
name|c
operator|->
name|physical
argument_list|)
condition|)
block|{
comment|/* Oops - didn't even write our HDLC header ! */
name|c
operator|->
name|argptr
operator|+=
literal|2
expr_stmt|;
name|c
operator|->
name|arglen
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|c
operator|->
name|argptr
operator|+=
name|wrote
expr_stmt|;
name|c
operator|->
name|arglen
operator|-=
name|wrote
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|chat_Init
parameter_list|(
name|struct
name|chat
modifier|*
name|c
parameter_list|,
name|struct
name|physical
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|emptybuf
parameter_list|,
specifier|const
name|char
modifier|*
name|phone
parameter_list|)
block|{
name|c
operator|->
name|desc
operator|.
name|type
operator|=
name|CHAT_DESCRIPTOR
expr_stmt|;
name|c
operator|->
name|desc
operator|.
name|UpdateSet
operator|=
name|chat_UpdateSet
expr_stmt|;
name|c
operator|->
name|desc
operator|.
name|IsSet
operator|=
name|chat_IsSet
expr_stmt|;
name|c
operator|->
name|desc
operator|.
name|Read
operator|=
name|chat_Read
expr_stmt|;
name|c
operator|->
name|desc
operator|.
name|Write
operator|=
name|chat_Write
expr_stmt|;
name|c
operator|->
name|physical
operator|=
name|p
expr_stmt|;
name|c
operator|->
name|state
operator|=
name|CHAT_EXPECT
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
operator|*
name|c
operator|->
name|script
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|->
name|argc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|c
operator|->
name|script
argument_list|,
name|data
argument_list|,
sizeof|sizeof
name|c
operator|->
name|script
operator|-
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|script
index|[
sizeof|sizeof
name|c
operator|->
name|script
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|c
operator|->
name|argc
operator|=
name|MakeArgs
argument_list|(
name|c
operator|->
name|script
argument_list|,
name|c
operator|->
name|argv
argument_list|,
name|VECSIZE
argument_list|(
name|c
operator|->
name|argv
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|arg
operator|=
operator|-
literal|1
expr_stmt|;
name|c
operator|->
name|argptr
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|nargptr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|emptybuf
condition|)
name|c
operator|->
name|bufstart
operator|=
name|c
operator|->
name|bufend
operator|=
name|c
operator|->
name|buf
expr_stmt|;
name|c
operator|->
name|TimeoutSec
operator|=
literal|30
expr_stmt|;
name|c
operator|->
name|TimedOut
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|phone
operator|=
name|phone
expr_stmt|;
name|c
operator|->
name|abort
operator|.
name|num
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|c
operator|->
name|pause
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|c
operator|->
name|pause
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|c
operator|->
name|timeout
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|c
operator|->
name|timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|chat_Destroy
parameter_list|(
name|struct
name|chat
modifier|*
name|c
parameter_list|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|c
operator|->
name|pause
argument_list|)
expr_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|c
operator|->
name|timeout
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|->
name|abort
operator|.
name|num
condition|)
name|free
argument_list|(
name|c
operator|->
name|abort
operator|.
name|string
index|[
operator|--
name|c
operator|->
name|abort
operator|.
name|num
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|c
operator|->
name|abort
operator|.
name|num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|findblank
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|instring
parameter_list|)
block|{
if|if
condition|(
name|instring
condition|)
block|{
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|issep
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|int
name|MakeArgs
parameter_list|(
name|char
modifier|*
name|script
parameter_list|,
name|char
modifier|*
modifier|*
name|pvect
parameter_list|,
name|int
name|maxargs
parameter_list|)
block|{
name|int
name|nargs
decl_stmt|,
name|nb
decl_stmt|;
name|int
name|instring
decl_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|script
condition|)
block|{
name|nb
operator|=
name|strspn
argument_list|(
name|script
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|script
operator|+=
name|nb
expr_stmt|;
if|if
condition|(
operator|*
name|script
condition|)
block|{
if|if
condition|(
operator|*
name|script
operator|==
literal|'"'
condition|)
block|{
name|instring
operator|=
literal|1
expr_stmt|;
name|script
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|script
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Shouldn't return here. Need to null 				 * terminate below */
block|}
else|else
name|instring
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nargs
operator|>=
name|maxargs
operator|-
literal|1
condition|)
break|break;
operator|*
name|pvect
operator|++
operator|=
name|script
expr_stmt|;
name|nargs
operator|++
expr_stmt|;
name|script
operator|=
name|findblank
argument_list|(
name|script
argument_list|,
name|instring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|script
condition|)
operator|*
name|script
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
operator|*
name|pvect
operator|=
name|NULL
expr_stmt|;
return|return
name|nargs
return|;
block|}
end_function

begin_comment
comment|/*  *  \c	don't add a cr  *  \d  Sleep a little (delay 2 seconds  *  \n  Line feed character  *  \P  Auth Key password  *  \p  pause 0.25 sec  *  \r	Carrige return character  *  \s  Space character  *  \T  Telephone number(s) (defined via `set phone')  *  \t  Tab character  *  \U  Auth User  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ExpandString
parameter_list|(
name|struct
name|chat
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
name|result
parameter_list|,
name|int
name|reslen
parameter_list|,
name|int
name|sendmode
parameter_list|)
block|{
name|int
name|addcr
init|=
literal|0
decl_stmt|;
name|result
index|[
operator|--
name|reslen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sendmode
condition|)
name|addcr
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|&&
name|reslen
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'\\'
case|:
name|str
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
name|sendmode
condition|)
name|addcr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Delay 2 seconds */
name|chat_Pause
argument_list|(
name|c
argument_list|,
literal|2
operator|*
name|SECTICKS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|chat_Pause
argument_list|(
name|c
argument_list|,
name|SECTICKS
operator|/
literal|4
argument_list|)
expr_stmt|;
break|break;
comment|/* Pause 0.25 sec */
case|case
literal|'n'
case|:
operator|*
name|result
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|result
operator|++
operator|=
literal|'\r'
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|*
name|result
operator|++
operator|=
literal|' '
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|result
operator|++
operator|=
literal|'\t'
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|strncpy
argument_list|(
name|result
argument_list|,
name|c
operator|->
name|physical
operator|->
name|dl
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|key
argument_list|,
name|reslen
argument_list|)
expr_stmt|;
name|reslen
operator|-=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|+=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|c
operator|->
name|phone
condition|)
block|{
name|strncpy
argument_list|(
name|result
argument_list|,
name|c
operator|->
name|phone
argument_list|,
name|reslen
argument_list|)
expr_stmt|;
name|reslen
operator|-=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|+=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'U'
case|:
name|strncpy
argument_list|(
name|result
argument_list|,
name|c
operator|->
name|physical
operator|->
name|dl
operator|->
name|bundle
operator|->
name|cfg
operator|.
name|auth
operator|.
name|name
argument_list|,
name|reslen
argument_list|)
expr_stmt|;
name|reslen
operator|-=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|+=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
break|break;
default|default:
name|reslen
operator|--
expr_stmt|;
operator|*
name|result
operator|++
operator|=
operator|*
name|str
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|str
condition|)
name|str
operator|++
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
condition|)
block|{
operator|*
name|result
operator|++
operator|=
operator|*
name|str
operator|++
operator|&
literal|0x1f
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
block|}
break|break;
default|default:
operator|*
name|result
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|--
name|reslen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|addcr
condition|)
operator|*
name|result
operator|++
operator|=
literal|'\r'
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|reslen
operator|>
literal|0
condition|)
operator|*
name|result
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ExecStr
parameter_list|(
name|struct
name|physical
modifier|*
name|physical
parameter_list|,
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
name|out
parameter_list|,
name|int
name|olen
parameter_list|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|fids
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|vector
index|[
name|MAXARGS
index|]
decl_stmt|,
modifier|*
name|startout
decl_stmt|,
modifier|*
name|endout
decl_stmt|;
name|int
name|stat
decl_stmt|,
name|nb
decl_stmt|;
name|log_Printf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Exec: %s\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|MakeArgs
argument_list|(
name|command
argument_list|,
name|vector
argument_list|,
name|VECSIZE
argument_list|(
name|vector
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fids
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Unable to create pipe in ExecStr: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|close
argument_list|(
name|fids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|timer_TermService
argument_list|()
expr_stmt|;
name|fids
index|[
literal|1
index|]
operator|=
name|fcntl
argument_list|(
name|fids
index|[
literal|1
index|]
argument_list|,
name|F_DUPFD
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|physical_GetFD
argument_list|(
name|physical
argument_list|)
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|STDIN_FILENO
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fids
index|[
literal|1
index|]
argument_list|,
name|STDERR_FILENO
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
name|_PATH_TTY
argument_list|,
name|O_RDWR
argument_list|)
operator|==
literal|3
condition|)
name|fcntl
argument_list|(
literal|3
argument_list|,
name|F_SETFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear close-on-exec flag */
else|else
name|fcntl
argument_list|(
literal|3
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set close-on-exec flag */
name|setuid
argument_list|(
name|geteuid
argument_list|()
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|vector
index|[
literal|0
index|]
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"execvp failed: %s: %s\n"
argument_list|,
name|vector
index|[
literal|0
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|name
init|=
name|strdup
argument_list|(
name|vector
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|close
argument_list|(
name|fids
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|endout
operator|=
name|out
operator|+
name|olen
operator|-
literal|1
expr_stmt|;
name|startout
operator|=
name|out
expr_stmt|;
while|while
condition|(
name|out
operator|<
name|endout
condition|)
block|{
name|nb
operator|=
name|read
argument_list|(
name|fids
index|[
literal|0
index|]
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|<=
literal|0
condition|)
break|break;
name|out
operator|++
expr_stmt|;
block|}
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
name|close
argument_list|(
name|fids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fids
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|stat
argument_list|,
name|WNOHANG
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|stat
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: signal %d\n"
argument_list|,
name|name
argument_list|,
name|WTERMSIG
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|WIFEXITED
argument_list|(
name|stat
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|WEXITSTATUS
argument_list|(
name|stat
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|127
case|:
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|name
argument_list|,
name|startout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
return|return;
break|break;
default|default:
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: exit %d\n"
argument_list|,
name|name
argument_list|,
name|WEXITSTATUS
argument_list|(
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
return|return;
break|break;
block|}
block|}
else|else
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Unexpected exit result\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

end_unit

