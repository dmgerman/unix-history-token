begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	    Written by Toshiharu OHNO (tony-o@iij.ad.jp)  *  *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.  *  *  Most of codes are derived from chat.c by Karl Fox (karl@MorningStar.Com).  *  *	Chat -- a program for automatic session establishment (i.e. dial  *		the phone and log in).  *  *	This software is in the public domain.  *  *	Please send all bug reports, requests for information, etc. to:  *  *		Karl Fox<karl@MorningStar.Com>  *		Morning Star Technologies, Inc.  *		1760 Zollinger Road  *		Columbus, OH  43221  *		(614)451-1883  *  * $Id: chat.c,v 1.33 1997/08/31 22:59:15 brian Exp $  *  *  TODO:  *	o Support more UUCP compatible control sequences.  *	o Dialing shoud not block monitor process.  *	o Reading modem by select should be unified into main.c  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|isblank
end_ifndef

begin_define
define|#
directive|define
name|isblank
parameter_list|(
name|c
parameter_list|)
value|((c) == '\t' || (c) == ' ')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"timeout.h"
end_include

begin_include
include|#
directive|include
file|"loadalias.h"
end_include

begin_include
include|#
directive|include
file|"vars.h"
end_include

begin_include
include|#
directive|include
file|"chat.h"
end_include

begin_include
include|#
directive|include
file|"sig.h"
end_include

begin_include
include|#
directive|include
file|"chat.h"
end_include

begin_define
define|#
directive|define
name|IBSIZE
value|200
end_define

begin_decl_stmt
specifier|static
name|int
name|TimeoutSec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|abort_next
decl_stmt|,
name|timeout_next
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numaborts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|AbortStrings
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|inbuff
index|[
name|IBSIZE
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|ChangeParity
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MATCH
value|1
end_define

begin_define
define|#
directive|define
name|NOMATCH
value|0
end_define

begin_define
define|#
directive|define
name|ABORT
value|-1
end_define

begin_function
specifier|static
name|char
modifier|*
name|findblank
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|instring
parameter_list|)
block|{
if|if
condition|(
name|instring
condition|)
block|{
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|p
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|p
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
name|int
name|MakeArgs
parameter_list|(
name|char
modifier|*
name|script
parameter_list|,
name|char
modifier|*
modifier|*
name|pvect
parameter_list|,
name|int
name|maxargs
parameter_list|)
block|{
name|int
name|nargs
decl_stmt|,
name|nb
decl_stmt|;
name|int
name|instring
decl_stmt|;
name|nargs
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|script
condition|)
block|{
name|nb
operator|=
name|strspn
argument_list|(
name|script
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|script
operator|+=
name|nb
expr_stmt|;
if|if
condition|(
operator|*
name|script
condition|)
block|{
if|if
condition|(
operator|*
name|script
operator|==
literal|'"'
condition|)
block|{
name|instring
operator|=
literal|1
expr_stmt|;
name|script
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|script
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Shouldn't return here. Need to null 				 * terminate below */
block|}
else|else
name|instring
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nargs
operator|>=
name|maxargs
operator|-
literal|1
condition|)
break|break;
operator|*
name|pvect
operator|++
operator|=
name|script
expr_stmt|;
name|nargs
operator|++
expr_stmt|;
name|script
operator|=
name|findblank
argument_list|(
name|script
argument_list|,
name|instring
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|script
condition|)
operator|*
name|script
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
operator|*
name|pvect
operator|=
name|NULL
expr_stmt|;
return|return
name|nargs
return|;
block|}
end_function

begin_comment
comment|/*  *  \c	don't add a cr  *  \d  Sleep a little (delay 2 seconds  *  \n  Line feed character  *  \P  Auth Key password  *  \p  pause 0.25 sec  *  \r	Carrige return character  *  \s  Space character  *  \T  Telephone number(s) (defined via `set phone')  *  \t  Tab character  *  \U  Auth User  */
end_comment

begin_function
name|char
modifier|*
name|ExpandString
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
name|result
parameter_list|,
name|int
name|reslen
parameter_list|,
name|int
name|sendmode
parameter_list|)
block|{
name|int
name|addcr
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|phone
decl_stmt|;
name|result
index|[
operator|--
name|reslen
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sendmode
condition|)
name|addcr
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|str
operator|&&
name|reslen
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'\\'
case|:
name|str
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
name|sendmode
condition|)
name|addcr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* Delay 2 seconds */
name|nointr_sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|nointr_usleep
argument_list|(
literal|250000
argument_list|)
expr_stmt|;
break|break;
comment|/* Pause 0.25 sec */
case|case
literal|'n'
case|:
operator|*
name|result
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|result
operator|++
operator|=
literal|'\r'
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|*
name|result
operator|++
operator|=
literal|' '
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|result
operator|++
operator|=
literal|'\t'
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|strncpy
argument_list|(
name|result
argument_list|,
name|VarAuthKey
argument_list|,
name|reslen
argument_list|)
expr_stmt|;
name|reslen
operator|-=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|+=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
name|VarAltPhone
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|VarNextPhone
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|VarPhoneCopy
argument_list|,
name|VarPhoneList
argument_list|)
expr_stmt|;
name|VarNextPhone
operator|=
name|VarPhoneCopy
expr_stmt|;
block|}
name|VarAltPhone
operator|=
name|strsep
argument_list|(
operator|&
name|VarNextPhone
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
name|phone
operator|=
name|strsep
argument_list|(
operator|&
name|VarAltPhone
argument_list|,
literal|"|"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|result
argument_list|,
name|phone
argument_list|,
name|reslen
argument_list|)
expr_stmt|;
name|reslen
operator|-=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|+=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|VarTerm
condition|)
name|fprintf
argument_list|(
name|VarTerm
argument_list|,
literal|"Phone: %s\n"
argument_list|,
name|phone
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Phone: %s\n"
argument_list|,
name|phone
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|strncpy
argument_list|(
name|result
argument_list|,
name|VarAuthName
argument_list|,
name|reslen
argument_list|)
expr_stmt|;
name|reslen
operator|-=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|+=
name|strlen
argument_list|(
name|result
argument_list|)
expr_stmt|;
break|break;
default|default:
name|reslen
operator|--
expr_stmt|;
operator|*
name|result
operator|++
operator|=
operator|*
name|str
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|str
condition|)
name|str
operator|++
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|str
condition|)
block|{
operator|*
name|result
operator|++
operator|=
operator|*
name|str
operator|++
operator|&
literal|0x1f
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
block|}
break|break;
default|default:
operator|*
name|result
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
name|reslen
operator|--
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|--
name|reslen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|addcr
condition|)
operator|*
name|result
operator|++
operator|=
literal|'\r'
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|reslen
operator|>
literal|0
condition|)
operator|*
name|result
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXLOGBUFF
value|200
end_define

begin_decl_stmt
specifier|static
name|char
name|logbuff
index|[
name|MAXLOGBUFF
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|loglen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|clear_log
parameter_list|()
block|{
name|memset
argument_list|(
name|logbuff
argument_list|,
literal|0
argument_list|,
name|MAXLOGBUFF
argument_list|)
expr_stmt|;
name|loglen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_log
parameter_list|()
block|{
if|if
condition|(
name|LogIsKept
argument_list|(
name|LogCONNECT
argument_list|)
condition|)
name|LogPrintf
argument_list|(
name|LogCONNECT
argument_list|,
literal|"%s\n"
argument_list|,
name|logbuff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|LogIsKept
argument_list|(
name|LogCARRIER
argument_list|)
operator|&&
name|strstr
argument_list|(
name|logbuff
argument_list|,
literal|"CARRIER"
argument_list|)
condition|)
name|LogPrintf
argument_list|(
name|LogCARRIER
argument_list|,
literal|"%s\n"
argument_list|,
name|logbuff
argument_list|)
expr_stmt|;
name|clear_log
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|connect_log
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|int
name|single_p
parameter_list|)
block|{
name|int
name|space
init|=
name|MAXLOGBUFF
operator|-
name|loglen
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|space
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'\n'
condition|)
block|{
name|flush_log
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|logbuff
index|[
name|loglen
operator|++
index|]
operator|=
operator|*
name|str
expr_stmt|;
block|}
if|if
condition|(
name|single_p
operator|||
operator|!
operator|*
operator|++
name|str
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|space
condition|)
name|flush_log
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|WaitforString
parameter_list|(
name|char
modifier|*
name|estr
parameter_list|)
block|{
name|struct
name|timeval
name|timeout
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|str
decl_stmt|,
name|ch
decl_stmt|;
name|char
modifier|*
name|inp
decl_stmt|;
name|fd_set
name|rfds
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nfds
decl_stmt|,
name|nb
decl_stmt|;
name|char
name|buff
index|[
name|IBSIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|SIGALRM
name|int
name|omask
decl_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clear_log
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ExpandString
argument_list|(
name|estr
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Wait for (%d): %s --> %s\n"
argument_list|,
name|TimeoutSec
argument_list|,
name|estr
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|str
operator|=
name|buff
expr_stmt|;
name|inp
operator|=
name|inbuff
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|>=
name|IBSIZE
condition|)
block|{
name|str
index|[
name|IBSIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Truncating String to %d character: %s\n"
argument_list|,
name|IBSIZE
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|nfds
operator|=
name|modem
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|str
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_ZERO
argument_list|(
operator|&
name|rfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|modem
argument_list|,
operator|&
name|rfds
argument_list|)
expr_stmt|;
comment|/*      * Because it is not clear whether select() modifies timeout value, it is      * better to initialize timeout values everytime.      */
name|timeout
operator|.
name|tv_sec
operator|=
name|TimeoutSec
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|select
argument_list|(
name|nfds
argument_list|,
operator|&
name|rfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|TimerService
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGALRM
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LogPrintf
argument_list|(
name|LogERROR
argument_list|,
literal|"WaitForString: select(): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|inp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NOMATCH
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* Timeout reached! */
operator|*
name|inp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|inbuff
condition|)
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Got: %s\n"
argument_list|,
name|inbuff
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Can't get (%d).\n"
argument_list|,
name|timeout
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGALRM
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NOMATCH
operator|)
return|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|modem
argument_list|,
operator|&
name|rfds
argument_list|)
condition|)
block|{
comment|/* got something */
if|if
condition|(
name|DEV_IS_SYNC
condition|)
block|{
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|(
name|length
operator|=
name|strlen
argument_list|(
name|inbuff
argument_list|)
operator|)
operator|>
name|IBSIZE
condition|)
block|{
name|bcopy
argument_list|(
operator|&
operator|(
name|inbuff
index|[
name|IBSIZE
index|]
operator|)
argument_list|,
name|inbuff
argument_list|,
name|IBSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* shuffle down next 							 * part */
name|length
operator|=
name|strlen
argument_list|(
name|inbuff
argument_list|)
expr_stmt|;
block|}
name|nb
operator|=
name|read
argument_list|(
name|modem
argument_list|,
operator|&
operator|(
name|inbuff
index|[
name|length
index|]
operator|)
argument_list|,
name|IBSIZE
argument_list|)
expr_stmt|;
name|inbuff
index|[
name|nb
operator|+
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|connect_log
argument_list|(
name|inbuff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|inbuff
argument_list|,
name|str
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGALRM
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flush_log
argument_list|()
expr_stmt|;
return|return
operator|(
name|MATCH
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numaborts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|inbuff
argument_list|,
name|AbortStrings
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Abort: %s\n"
argument_list|,
name|AbortStrings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGALRM
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flush_log
argument_list|()
expr_stmt|;
return|return
operator|(
name|ABORT
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|read
argument_list|(
name|modem
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogERROR
argument_list|,
literal|"read error: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|inp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|NOMATCH
operator|)
return|;
block|}
name|connect_log
argument_list|(
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|inp
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|*
name|s
condition|)
block|{
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
ifdef|#
directive|ifdef
name|SIGALRM
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|inp
operator|=
literal|0
expr_stmt|;
name|flush_log
argument_list|()
expr_stmt|;
return|return
operator|(
name|MATCH
operator|)
return|;
block|}
block|}
else|else
name|s
operator|=
name|str
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|inbuff
operator|+
name|IBSIZE
condition|)
block|{
name|bcopy
argument_list|(
name|inp
operator|-
literal|100
argument_list|,
name|inbuff
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|inp
operator|=
name|inbuff
operator|+
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|str
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numaborts
condition|;
name|i
operator|++
control|)
block|{
comment|/* Look for Abort strings */
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|s1
decl_stmt|;
name|s1
operator|=
name|AbortStrings
index|[
name|i
index|]
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|<=
name|inp
operator|-
name|inbuff
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|inp
operator|-
name|len
argument_list|,
name|s1
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Abort: %s\n"
argument_list|,
name|s1
argument_list|)
expr_stmt|;
operator|*
name|inp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGALRM
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flush_log
argument_list|()
expr_stmt|;
return|return
operator|(
name|ABORT
operator|)
return|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|ExecStr
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|char
modifier|*
name|out
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|int
name|fids
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|vector
index|[
literal|20
index|]
decl_stmt|;
name|int
name|stat
decl_stmt|,
name|nb
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|tmp
index|[
literal|300
index|]
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
name|cp
operator|=
name|inbuff
operator|+
name|strlen
argument_list|(
name|inbuff
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|cp
operator|>
name|inbuff
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|<
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
break|break;
block|}
name|cp
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|snprintf
argument_list|(
name|tmp
argument_list|,
sizeof|sizeof
name|tmp
argument_list|,
literal|"%s %s"
argument_list|,
name|command
argument_list|,
name|cp
argument_list|)
operator|>=
sizeof|sizeof
name|tmp
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Too long string to ExecStr: \"%s\"\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|MakeArgs
argument_list|(
name|tmp
argument_list|,
name|vector
argument_list|,
name|VECSIZE
argument_list|(
name|vector
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fids
argument_list|)
operator|<
literal|0
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Unable to create pipe in ExecStr: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|TermTimerService
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|fids
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"dup2(fids[1], 1) in ExecStr: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|close
argument_list|(
name|fids
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|nb
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup2
argument_list|(
name|nb
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"dup2(nb, 0) in ExecStr: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"exec: %s\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* switch back to original privileges */
if|if
condition|(
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"setgid: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"setuid: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|execvp
argument_list|(
name|command
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"execvp failed for (%d/%d): %s\n"
argument_list|,
name|pid
argument_list|,
name|errno
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
name|fids
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|nb
operator|=
name|read
argument_list|(
name|fids
index|[
literal|0
index|]
argument_list|,
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nb
operator|<=
literal|0
condition|)
break|break;
name|out
operator|++
expr_stmt|;
block|}
operator|*
name|out
operator|=
literal|'\0'
expr_stmt|;
name|close
argument_list|(
name|fids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fids
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|stat
argument_list|,
name|WNOHANG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|SendString
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|on
decl_stmt|;
name|char
name|buff
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
name|abort_next
condition|)
block|{
name|abort_next
operator|=
literal|0
expr_stmt|;
name|ExpandString
argument_list|(
name|str
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AbortStrings
index|[
name|numaborts
operator|++
index|]
operator|=
name|strdup
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeout_next
condition|)
block|{
name|timeout_next
operator|=
literal|0
expr_stmt|;
name|TimeoutSec
operator|=
name|atoi
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|TimeoutSec
operator|<=
literal|0
condition|)
name|TimeoutSec
operator|=
literal|30
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|'!'
condition|)
block|{
operator|(
name|void
operator|)
name|ExpandString
argument_list|(
name|str
operator|+
literal|1
argument_list|,
name|buff
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
operator|-
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ExecStr
argument_list|(
name|buff
operator|+
literal|2
argument_list|,
name|buff
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|ExpandString
argument_list|(
name|str
argument_list|,
name|buff
operator|+
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|buff
argument_list|)
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|str
argument_list|,
literal|"\\P"
argument_list|)
condition|)
comment|/* Do not log the password itself. */
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"sending: %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"sending: %s\n"
argument_list|,
name|buff
operator|+
literal|2
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buff
expr_stmt|;
if|if
condition|(
name|DEV_IS_SYNC
condition|)
name|bcopy
argument_list|(
literal|"\377\003"
argument_list|,
name|buff
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Prepend HDLC header */
else|else
name|cp
operator|+=
literal|2
expr_stmt|;
name|on
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|modem
argument_list|,
name|cp
argument_list|,
name|on
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ExpectString
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|minus
decl_stmt|;
name|int
name|state
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"ABORT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|abort_next
expr_stmt|;
return|return
operator|(
name|MATCH
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
literal|"TIMEOUT"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|timeout_next
expr_stmt|;
return|return
operator|(
name|MATCH
operator|)
return|;
block|}
name|LogPrintf
argument_list|(
name|LogCHAT
argument_list|,
literal|"Expecting %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
comment|/*      * Check whether if string contains sub-send-expect.      */
for|for
control|(
name|minus
operator|=
name|str
init|;
operator|*
name|minus
condition|;
name|minus
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|minus
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|minus
operator|==
name|str
operator|||
name|minus
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|minus
operator|==
literal|'-'
condition|)
block|{
comment|/* We have sub-send-expect. */
operator|*
name|minus
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|state
operator|=
name|WaitforString
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|NOMATCH
condition|)
return|return
operator|(
name|state
operator|)
return|;
comment|/*        * Can't get expect string. Sendout send part.        */
name|str
operator|=
name|minus
expr_stmt|;
for|for
control|(
name|minus
operator|=
name|str
init|;
operator|*
name|minus
condition|;
name|minus
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|minus
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|minus
operator|==
name|str
operator|||
name|minus
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|minus
operator|==
literal|'-'
condition|)
block|{
operator|*
name|minus
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|SendString
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|minus
expr_stmt|;
block|}
else|else
block|{
name|SendString
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|MATCH
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/*        * Simple case. Wait for string.        */
return|return
operator|(
name|WaitforString
argument_list|(
name|str
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|MATCH
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|jmp_buf
name|ChatEnv
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|oint
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|StopDial
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|LogPrintf
argument_list|(
name|LogPHASE
argument_list|,
literal|"DoChat: Caught signal %d, abort connect\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|ChatEnv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|DoChat
parameter_list|(
name|char
modifier|*
name|script
parameter_list|)
block|{
name|char
modifier|*
name|vector
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|n
decl_stmt|,
name|state
decl_stmt|;
if|if
condition|(
operator|!
name|script
operator|||
operator|!
operator|*
name|script
condition|)
return|return
name|MATCH
return|;
comment|/* While we're chatting, we want an INT to fail us */
if|if
condition|(
name|setjmp
argument_list|(
name|ChatEnv
argument_list|)
condition|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oint
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|oint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|StopDial
argument_list|)
expr_stmt|;
name|timeout_next
operator|=
name|abort_next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|AbortStrings
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
block|{
name|free
argument_list|(
name|AbortStrings
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|AbortStrings
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|numaborts
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|vector
argument_list|,
sizeof|sizeof
argument_list|(
name|vector
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|MakeArgs
argument_list|(
name|script
argument_list|,
name|vector
argument_list|,
name|VECSIZE
argument_list|(
name|vector
argument_list|)
argument_list|)
expr_stmt|;
name|argc
operator|=
name|n
expr_stmt|;
name|argv
operator|=
name|vector
expr_stmt|;
name|TimeoutSec
operator|=
literal|30
expr_stmt|;
while|while
condition|(
operator|*
name|argv
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"P_ZERO"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"P_ODD"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"P_EVEN"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ChangeParity
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|state
operator|=
name|ExpectString
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|MATCH
case|:
if|if
condition|(
operator|*
name|argv
condition|)
name|SendString
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
break|break;
case|case
name|ABORT
case|:
ifdef|#
directive|ifdef
name|notdef
name|HangupModem
argument_list|()
expr_stmt|;
endif|#
directive|endif
case|case
name|NOMATCH
case|:
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oint
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOMATCH
operator|)
return|;
block|}
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|oint
argument_list|)
expr_stmt|;
return|return
operator|(
name|MATCH
operator|)
return|;
block|}
end_function

end_unit

