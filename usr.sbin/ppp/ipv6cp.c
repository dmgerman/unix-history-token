begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Brian Somers<brian@Awfulhak.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_include
include|#
directive|include
file|"layer.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"iplist.h"
end_include

begin_include
include|#
directive|include
file|"throughput.h"
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_include
include|#
directive|include
file|"lqr.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ncpaddr.h"
end_include

begin_include
include|#
directive|include
file|"ip.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"ipv6cp.h"
end_include

begin_include
include|#
directive|include
file|"filter.h"
end_include

begin_include
include|#
directive|include
file|"descriptor.h"
end_include

begin_include
include|#
directive|include
file|"ccp.h"
end_include

begin_include
include|#
directive|include
file|"link.h"
end_include

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NORADIUS
end_ifndef

begin_include
include|#
directive|include
file|"radius.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ncp.h"
end_include

begin_include
include|#
directive|include
file|"bundle.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_include
include|#
directive|include
file|"iface.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"prompt.h"
end_include

begin_include
include|#
directive|include
file|"async.h"
end_include

begin_include
include|#
directive|include
file|"physical.h"
end_include

begin_include
include|#
directive|include
file|"probe.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NOINET6
end_ifndef

begin_define
define|#
directive|define
name|IN6ADDR_LINKLOCAL_MCAST_INIT
define|\
value|{{{ 0xff, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \ 	    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }}}
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|in6_addr
name|in6addr_linklocal_mcast
init|=
name|IN6ADDR_LINKLOCAL_MCAST_INIT
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ipv6cp_LayerUp
parameter_list|(
name|struct
name|fsm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_LayerDown
parameter_list|(
name|struct
name|fsm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_LayerStart
parameter_list|(
name|struct
name|fsm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_LayerFinish
parameter_list|(
name|struct
name|fsm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_InitRestartCounter
parameter_list|(
name|struct
name|fsm
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_SendConfigReq
parameter_list|(
name|struct
name|fsm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_SentTerminateReq
parameter_list|(
name|struct
name|fsm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_SendTerminateAck
parameter_list|(
name|struct
name|fsm
modifier|*
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_DecodeConfig
parameter_list|(
name|struct
name|fsm
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|fsm_decode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|fsm_callbacks
name|ipv6cp_Callbacks
init|=
block|{
name|ipv6cp_LayerUp
block|,
name|ipv6cp_LayerDown
block|,
name|ipv6cp_LayerStart
block|,
name|ipv6cp_LayerFinish
block|,
name|ipv6cp_InitRestartCounter
block|,
name|ipv6cp_SendConfigReq
block|,
name|ipv6cp_SentTerminateReq
block|,
name|ipv6cp_SendTerminateAck
block|,
name|ipv6cp_DecodeConfig
block|,
name|fsm_NullRecvResetReq
block|,
name|fsm_NullRecvResetAck
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|SetInterfaceID
parameter_list|(
name|u_char
modifier|*
name|ifid
parameter_list|,
name|int
name|userandom
parameter_list|)
block|{
name|struct
name|ifaddrs
modifier|*
name|ifa
decl_stmt|,
modifier|*
name|ifap
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
specifier|const
name|u_long
name|i32_max
init|=
literal|0xffffffff
decl_stmt|;
name|u_long
name|r1
decl_stmt|,
name|r2
decl_stmt|;
comment|/* configure an interface ID based on Section 4.1 of RFC 2472 */
name|memset
argument_list|(
name|ifid
argument_list|,
literal|0
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
expr_stmt|;
comment|/*    * 1) If an IEEE global identifier (EUI-48 or EUI-64) is    * available anywhere on the node, it should be used to construct    * the tentative Interface-Identifier due to its uniqueness    * properties.    */
if|if
condition|(
name|userandom
condition|)
goto|goto
name|randomid
goto|;
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifap
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|randomid
goto|;
for|for
control|(
name|ifa
operator|=
name|ifap
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|sdl
operator|->
name|sdl_alen
operator|<
literal|6
condition|)
continue|continue;
comment|/* we're only interested in IEEE hardware addresses */
switch|switch
condition|(
name|sdl
operator|->
name|sdl_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_FDDI
case|:
comment|/* XXX need more cases? */
break|break;
default|default:
continue|continue;
block|}
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sdl
operator|->
name|sdl_data
operator|+
name|sdl
operator|->
name|sdl_nlen
operator|)
expr_stmt|;
name|ifid
index|[
literal|0
index|]
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|ifid
index|[
literal|0
index|]
operator|^=
literal|0x02
expr_stmt|;
comment|/* reverse the u/l bit*/
name|ifid
index|[
literal|1
index|]
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|ifid
index|[
literal|2
index|]
operator|=
name|cp
index|[
literal|2
index|]
expr_stmt|;
name|ifid
index|[
literal|3
index|]
operator|=
literal|0xff
expr_stmt|;
name|ifid
index|[
literal|4
index|]
operator|=
literal|0xfe
expr_stmt|;
name|ifid
index|[
literal|5
index|]
operator|=
name|cp
index|[
literal|3
index|]
expr_stmt|;
name|ifid
index|[
literal|6
index|]
operator|=
name|cp
index|[
literal|4
index|]
expr_stmt|;
name|ifid
index|[
literal|7
index|]
operator|=
name|cp
index|[
literal|5
index|]
expr_stmt|;
name|freeifaddrs
argument_list|(
name|ifap
argument_list|)
expr_stmt|;
return|return;
block|}
name|freeifaddrs
argument_list|(
name|ifap
argument_list|)
expr_stmt|;
comment|/*    * 2) If an IEEE global identifier is not available a different source    * of uniqueness should be used.    * XXX: we skip this case.    */
comment|/*    * 3) If a good source of uniqueness cannot be found, it is    * recommended that a random number be generated.  In this case the    * "u" bit of the interface identifier MUST be set to zero (0).    */
name|randomid
label|:
name|randinit
argument_list|()
expr_stmt|;
name|r1
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|random
argument_list|()
operator|)
operator|%
name|i32_max
operator|)
operator|+
literal|1
expr_stmt|;
name|r2
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|random
argument_list|()
operator|)
operator|%
name|i32_max
operator|)
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|ifid
argument_list|,
operator|&
name|r1
argument_list|,
sizeof|sizeof
argument_list|(
name|r1
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ifid
operator|+
literal|4
argument_list|,
operator|&
name|r2
argument_list|,
sizeof|sizeof
argument_list|(
name|r2
argument_list|)
argument_list|)
expr_stmt|;
name|ifid
index|[
literal|0
index|]
operator|&=
literal|0xfd
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ipcp_SetIPv6address
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|,
name|u_char
modifier|*
name|myifid
parameter_list|,
name|u_char
modifier|*
name|hisifid
parameter_list|)
block|{
name|struct
name|bundle
modifier|*
name|bundle
init|=
name|ipv6cp
operator|->
name|fsm
operator|.
name|bundle
decl_stmt|;
name|struct
name|in6_addr
name|myaddr
decl_stmt|,
name|hisaddr
decl_stmt|;
name|struct
name|ncprange
name|myrange
decl_stmt|,
name|range
decl_stmt|;
name|struct
name|ncpaddr
name|addr
decl_stmt|;
name|struct
name|sockaddr_storage
name|ssdst
decl_stmt|,
name|ssgw
decl_stmt|,
name|ssmask
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sadst
decl_stmt|,
modifier|*
name|sagw
decl_stmt|,
modifier|*
name|samask
decl_stmt|;
name|sadst
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ssdst
expr_stmt|;
name|sagw
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ssgw
expr_stmt|;
name|samask
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ssmask
expr_stmt|;
name|memset
argument_list|(
operator|&
name|myaddr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|myaddr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hisaddr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|hisaddr
argument_list|)
expr_stmt|;
name|myaddr
operator|.
name|s6_addr
index|[
literal|0
index|]
operator|=
literal|0xfe
expr_stmt|;
name|myaddr
operator|.
name|s6_addr
index|[
literal|1
index|]
operator|=
literal|0x80
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|myaddr
operator|.
name|s6_addr
index|[
literal|8
index|]
argument_list|,
name|myifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|myaddr.s6_addr[8] |= 0x02;
comment|/* set 'universal' bit */
endif|#
directive|endif
name|hisaddr
operator|.
name|s6_addr
index|[
literal|0
index|]
operator|=
literal|0xfe
expr_stmt|;
name|hisaddr
operator|.
name|s6_addr
index|[
literal|1
index|]
operator|=
literal|0x80
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|hisaddr
operator|.
name|s6_addr
index|[
literal|8
index|]
argument_list|,
name|hisifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|hisaddr.s6_addr[8] |= 0x02;
comment|/* set 'universal' bit */
endif|#
directive|endif
name|ncpaddr_setip6
argument_list|(
operator|&
name|ipv6cp
operator|->
name|myaddr
argument_list|,
operator|&
name|myaddr
argument_list|)
expr_stmt|;
name|ncpaddr_setip6
argument_list|(
operator|&
name|ipv6cp
operator|->
name|hisaddr
argument_list|,
operator|&
name|hisaddr
argument_list|)
expr_stmt|;
name|ncprange_set
argument_list|(
operator|&
name|myrange
argument_list|,
operator|&
name|ipv6cp
operator|->
name|myaddr
argument_list|,
literal|64
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iface_Add
argument_list|(
name|bundle
operator|->
name|iface
argument_list|,
operator|&
name|bundle
operator|->
name|ncp
argument_list|,
operator|&
name|myrange
argument_list|,
operator|&
name|ipv6cp
operator|->
name|hisaddr
argument_list|,
name|IFACE_ADD_FIRST
operator||
name|IFACE_FORCE_ADD
operator||
name|IFACE_SYSTEM
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|Enabled
argument_list|(
name|bundle
argument_list|,
name|OPT_IFACEALIAS
argument_list|)
condition|)
name|iface_Clear
argument_list|(
name|bundle
operator|->
name|iface
argument_list|,
operator|&
name|bundle
operator|->
name|ncp
argument_list|,
name|AF_INET6
argument_list|,
name|IFACE_CLEAR_ALIASES
operator||
name|IFACE_SYSTEM
argument_list|)
expr_stmt|;
name|ncpaddr_setip6
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|in6addr_linklocal_mcast
argument_list|)
expr_stmt|;
name|ncprange_set
argument_list|(
operator|&
name|range
argument_list|,
operator|&
name|addr
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|rt_Set
argument_list|(
name|bundle
argument_list|,
name|RTM_ADD
argument_list|,
operator|&
name|range
argument_list|,
operator|&
name|ipv6cp
operator|->
name|myaddr
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle
operator|->
name|ncp
operator|.
name|cfg
operator|.
name|sendpipe
operator|>
literal|0
operator|||
name|bundle
operator|->
name|ncp
operator|.
name|cfg
operator|.
name|recvpipe
operator|>
literal|0
condition|)
block|{
name|ncprange_getsa
argument_list|(
operator|&
name|myrange
argument_list|,
operator|&
name|ssgw
argument_list|,
operator|&
name|ssmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncpaddr_isset
argument_list|(
operator|&
name|ipv6cp
operator|->
name|hisaddr
argument_list|)
condition|)
name|ncpaddr_getsa
argument_list|(
operator|&
name|ipv6cp
operator|->
name|hisaddr
argument_list|,
operator|&
name|ssdst
argument_list|)
expr_stmt|;
else|else
name|sadst
operator|=
name|NULL
expr_stmt|;
name|rt_Update
argument_list|(
name|bundle
argument_list|,
name|sadst
argument_list|,
name|sagw
argument_list|,
name|samask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Enabled
argument_list|(
name|bundle
argument_list|,
name|OPT_SROUTES
argument_list|)
condition|)
name|route_Change
argument_list|(
name|bundle
argument_list|,
name|bundle
operator|->
name|ncp
operator|.
name|route
argument_list|,
operator|&
name|ipv6cp
operator|->
name|myaddr
argument_list|,
operator|&
name|ipv6cp
operator|->
name|hisaddr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NORADIUS
if|if
condition|(
name|bundle
operator|->
name|radius
operator|.
name|valid
condition|)
name|route_Change
argument_list|(
name|bundle
argument_list|,
name|bundle
operator|->
name|radius
operator|.
name|routes
argument_list|,
operator|&
name|ipv6cp
operator|->
name|myaddr
argument_list|,
operator|&
name|ipv6cp
operator|->
name|hisaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
comment|/* Ok */
block|}
end_function

begin_function
name|void
name|ipv6cp_Init
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|,
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|link
modifier|*
name|l
parameter_list|,
specifier|const
name|struct
name|fsm_parent
modifier|*
name|parent
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|timer_names
index|[]
init|=
block|{
literal|"IPV6CP restart"
block|,
literal|"IPV6CP openmode"
block|,
literal|"IPV6CP stopped"
block|}
decl_stmt|;
name|int
name|n
decl_stmt|;
name|fsm_Init
argument_list|(
operator|&
name|ipv6cp
operator|->
name|fsm
argument_list|,
literal|"IPV6CP"
argument_list|,
name|PROTO_IPV6CP
argument_list|,
literal|1
argument_list|,
name|IPV6CP_MAXCODE
argument_list|,
name|LogIPV6CP
argument_list|,
name|bundle
argument_list|,
name|l
argument_list|,
name|parent
argument_list|,
operator|&
name|ipv6cp_Callbacks
argument_list|,
name|timer_names
argument_list|)
expr_stmt|;
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|timeout
operator|=
name|DEF_FSMRETRY
expr_stmt|;
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|maxreq
operator|=
name|DEF_FSMTRIES
expr_stmt|;
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|maxtrm
operator|=
name|DEF_FSMTRIES
expr_stmt|;
name|SetInterfaceID
argument_list|(
name|ipv6cp
operator|->
name|my_ifid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
name|SetInterfaceID
argument_list|(
name|ipv6cp
operator|->
name|his_ifid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|memcmp
argument_list|(
name|ipv6cp
operator|->
name|his_ifid
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|probe
operator|.
name|ipv6_available
condition|)
block|{
name|n
operator|=
literal|100
expr_stmt|;
while|while
condition|(
name|n
operator|&&
operator|!
name|ipcp_SetIPv6address
argument_list|(
name|ipv6cp
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
argument_list|,
name|ipv6cp
operator|->
name|his_ifid
argument_list|)
condition|)
block|{
do|do
block|{
name|n
operator|--
expr_stmt|;
name|SetInterfaceID
argument_list|(
name|ipv6cp
operator|->
name|my_ifid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|&&
name|memcmp
argument_list|(
name|ipv6cp
operator|->
name|his_ifid
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
operator|==
literal|0
condition|)
do|;
block|}
block|}
name|throughput_init
argument_list|(
operator|&
name|ipv6cp
operator|->
name|throughput
argument_list|,
name|SAMPLE_PERIOD
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ipv6cp
operator|->
name|Queue
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|ipv6cp
operator|->
name|Queue
argument_list|)
expr_stmt|;
name|ipv6cp_Setup
argument_list|(
name|ipv6cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipv6cp_Destroy
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|)
block|{
name|throughput_destroy
argument_list|(
operator|&
name|ipv6cp
operator|->
name|throughput
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipv6cp_Setup
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|)
block|{
name|ncpaddr_init
argument_list|(
operator|&
name|ipv6cp
operator|->
name|myaddr
argument_list|)
expr_stmt|;
name|ncpaddr_init
argument_list|(
operator|&
name|ipv6cp
operator|->
name|hisaddr
argument_list|)
expr_stmt|;
name|ipv6cp
operator|->
name|his_reject
operator|=
literal|0
expr_stmt|;
name|ipv6cp
operator|->
name|my_reject
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipv6cp_SetLink
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|,
name|struct
name|link
modifier|*
name|l
parameter_list|)
block|{
name|ipv6cp
operator|->
name|fsm
operator|.
name|link
operator|=
name|l
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ipv6cp_Show
parameter_list|(
name|struct
name|cmdargs
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
init|=
operator|&
name|arg
operator|->
name|bundle
operator|->
name|ncp
operator|.
name|ipv6cp
decl_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"%s [%s]\n"
argument_list|,
name|ipv6cp
operator|->
name|fsm
operator|.
name|name
argument_list|,
name|State2Nam
argument_list|(
name|ipv6cp
operator|->
name|fsm
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipv6cp
operator|->
name|fsm
operator|.
name|state
operator|==
name|ST_OPENED
condition|)
block|{
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" His side:        %s\n"
argument_list|,
name|ncpaddr_ntoa
argument_list|(
operator|&
name|ipv6cp
operator|->
name|hisaddr
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" My side:         %s\n"
argument_list|,
name|ncpaddr_ntoa
argument_list|(
operator|&
name|ipv6cp
operator|->
name|myaddr
argument_list|)
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|" Queued packets:  %lu\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ipv6cp_QueueLen
argument_list|(
name|ipv6cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"\nDefaults:\n"
argument_list|)
expr_stmt|;
name|prompt_Printf
argument_list|(
name|arg
operator|->
name|prompt
argument_list|,
literal|"  FSM retry = %us, max %u Config"
literal|" REQ%s, %u Term REQ%s\n\n"
argument_list|,
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|timeout
argument_list|,
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|maxreq
argument_list|,
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|maxreq
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|maxtrm
argument_list|,
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|maxtrm
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|throughput_disp
argument_list|(
operator|&
name|ipv6cp
operator|->
name|throughput
argument_list|,
name|arg
operator|->
name|prompt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|ipv6cp_Input
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|link
modifier|*
name|l
parameter_list|,
name|struct
name|mbuf
modifier|*
name|bp
parameter_list|)
block|{
comment|/* Got PROTO_IPV6CP from link */
name|m_settype
argument_list|(
name|bp
argument_list|,
name|MB_IPV6CPIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bundle_Phase
argument_list|(
name|bundle
argument_list|)
operator|==
name|PHASE_NETWORK
condition|)
name|fsm_Input
argument_list|(
operator|&
name|bundle
operator|->
name|ncp
operator|.
name|ipv6cp
operator|.
name|fsm
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|bundle_Phase
argument_list|(
name|bundle
argument_list|)
operator|<
name|PHASE_NETWORK
condition|)
name|log_Printf
argument_list|(
name|LogIPV6CP
argument_list|,
literal|"%s: Error: Unexpected IPV6CP in phase %s"
literal|" (ignored)\n"
argument_list|,
name|l
operator|->
name|name
argument_list|,
name|bundle_PhaseName
argument_list|(
name|bundle
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ipv6cp_AddInOctets
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|throughput_addin
argument_list|(
operator|&
name|ipv6cp
operator|->
name|throughput
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipv6cp_AddOutOctets
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|throughput_addout
argument_list|(
operator|&
name|ipv6cp
operator|->
name|throughput
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipv6cp_IfaceAddrAdded
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|,
specifier|const
name|struct
name|iface_addr
modifier|*
name|addr
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ipv6cp_IfaceAddrDeleted
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|,
specifier|const
name|struct
name|iface_addr
modifier|*
name|addr
parameter_list|)
block|{ }
end_function

begin_function
name|int
name|ipv6cp_InterfaceUp
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ipcp_SetIPv6address
argument_list|(
name|ipv6cp
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
argument_list|,
name|ipv6cp
operator|->
name|his_ifid
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"ipv6cp_InterfaceUp: unable to set ipv6 address\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|iface_SetFlags
argument_list|(
name|ipv6cp
operator|->
name|fsm
operator|.
name|bundle
operator|->
name|iface
operator|->
name|name
argument_list|,
name|IFF_UP
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"ipv6cp_InterfaceUp: Can't set the IFF_UP"
literal|" flag on %s\n"
argument_list|,
name|ipv6cp
operator|->
name|fsm
operator|.
name|bundle
operator|->
name|iface
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|size_t
name|ipv6cp_QueueLen
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|)
block|{
name|struct
name|mqueue
modifier|*
name|q
decl_stmt|;
name|size_t
name|result
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|ipv6cp
operator|->
name|Queue
init|;
name|q
operator|<
name|ipv6cp
operator|->
name|Queue
operator|+
name|IPV6CP_QUEUES
argument_list|(
name|ipv6cp
argument_list|)
condition|;
name|q
operator|++
control|)
name|result
operator|+=
name|q
operator|->
name|len
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|ipv6cp_PushPacket
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|,
name|struct
name|link
modifier|*
name|l
parameter_list|)
block|{
name|struct
name|bundle
modifier|*
name|bundle
init|=
name|ipv6cp
operator|->
name|fsm
operator|.
name|bundle
decl_stmt|;
name|struct
name|mqueue
modifier|*
name|queue
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|bp
decl_stmt|;
name|int
name|m_len
decl_stmt|;
name|u_int32_t
name|secs
init|=
literal|0
decl_stmt|;
name|unsigned
name|alivesecs
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ipv6cp
operator|->
name|fsm
operator|.
name|state
operator|!=
name|ST_OPENED
condition|)
return|return
literal|0
return|;
comment|/*    * If ccp is not open but is required, do nothing.    */
if|if
condition|(
name|l
operator|->
name|ccp
operator|.
name|fsm
operator|.
name|state
operator|!=
name|ST_OPENED
operator|&&
name|ccp_Required
argument_list|(
operator|&
name|l
operator|->
name|ccp
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"%s: Not transmitting... waiting for CCP\n"
argument_list|,
name|l
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|queue
operator|=
name|ipv6cp
operator|->
name|Queue
operator|+
name|IPV6CP_QUEUES
argument_list|(
name|ipv6cp
argument_list|)
operator|-
literal|1
expr_stmt|;
do|do
block|{
if|if
condition|(
name|queue
operator|->
name|top
condition|)
block|{
name|bp
operator|=
name|m_dequeue
argument_list|(
name|queue
argument_list|)
expr_stmt|;
name|bp
operator|=
name|mbuf_Read
argument_list|(
name|bp
argument_list|,
operator|&
name|secs
argument_list|,
sizeof|sizeof
name|secs
argument_list|)
expr_stmt|;
name|bp
operator|=
name|m_pullup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|m_len
operator|=
name|m_length
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FilterCheck
argument_list|(
name|MBUF_CTOP
argument_list|(
name|bp
argument_list|)
argument_list|,
name|AF_INET6
argument_list|,
operator|&
name|bundle
operator|->
name|filter
operator|.
name|alive
argument_list|,
operator|&
name|alivesecs
argument_list|)
condition|)
block|{
if|if
condition|(
name|secs
operator|==
literal|0
condition|)
name|secs
operator|=
name|alivesecs
expr_stmt|;
name|bundle_StartIdleTimer
argument_list|(
name|bundle
argument_list|,
name|secs
argument_list|)
expr_stmt|;
block|}
name|link_PushPacket
argument_list|(
name|l
argument_list|,
name|bp
argument_list|,
name|bundle
argument_list|,
literal|0
argument_list|,
name|PROTO_IPV6
argument_list|)
expr_stmt|;
name|ipv6cp_AddOutOctets
argument_list|(
name|ipv6cp
argument_list|,
name|m_len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
do|while
condition|(
name|queue
operator|--
operator|!=
name|ipv6cp
operator|->
name|Queue
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ipv6cp_LayerUp
parameter_list|(
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/* We're now up */
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
init|=
name|fsm2ipv6cp
argument_list|(
name|fp
argument_list|)
decl_stmt|;
name|char
name|tbuff
index|[
literal|40
index|]
decl_stmt|;
name|log_Printf
argument_list|(
name|LogIPV6CP
argument_list|,
literal|"%s: LayerUp.\n"
argument_list|,
name|fp
operator|->
name|link
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ipv6cp_InterfaceUp
argument_list|(
name|ipv6cp
argument_list|)
condition|)
return|return
literal|0
return|;
name|snprintf
argument_list|(
name|tbuff
argument_list|,
sizeof|sizeof
name|tbuff
argument_list|,
literal|"%s"
argument_list|,
name|ncpaddr_ntoa
argument_list|(
operator|&
name|ipv6cp
operator|->
name|myaddr
argument_list|)
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogIPV6CP
argument_list|,
literal|"myaddr %s hisaddr = %s\n"
argument_list|,
name|tbuff
argument_list|,
name|ncpaddr_ntoa
argument_list|(
operator|&
name|ipv6cp
operator|->
name|hisaddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX: Call radius_Account() */
if|if
condition|(
operator|!
name|Enabled
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
name|OPT_IPCP
argument_list|)
condition|)
block|{
comment|/*      * XXX this stuff should really live in the FSM.  Our config should      * associate executable sections in files with events.      */
if|if
condition|(
name|system_Select
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
name|tbuff
argument_list|,
name|LINKUPFILE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bundle_GetLabel
argument_list|(
name|fp
operator|->
name|bundle
argument_list|)
condition|)
block|{
if|if
condition|(
name|system_Select
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
name|bundle_GetLabel
argument_list|(
name|fp
operator|->
name|bundle
argument_list|)
argument_list|,
name|LINKUPFILE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|system_Select
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
literal|"MYADDR6"
argument_list|,
name|LINKUPFILE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|system_Select
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
literal|"MYADDR6"
argument_list|,
name|LINKUPFILE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|fp
operator|->
name|more
operator|.
name|reqs
operator|=
name|fp
operator|->
name|more
operator|.
name|naks
operator|=
name|fp
operator|->
name|more
operator|.
name|rejs
operator|=
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|maxreq
operator|*
literal|3
expr_stmt|;
name|log_DisplayPrompts
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipv6cp_LayerDown
parameter_list|(
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/* About to come down */
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
init|=
name|fsm2ipv6cp
argument_list|(
name|fp
argument_list|)
decl_stmt|;
specifier|static
name|int
name|recursing
decl_stmt|;
name|char
name|addr
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|recursing
operator|++
condition|)
block|{
name|snprintf
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
name|addr
argument_list|,
literal|"%s"
argument_list|,
name|ncpaddr_ntoa
argument_list|(
operator|&
name|ipv6cp
operator|->
name|myaddr
argument_list|)
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogIPV6CP
argument_list|,
literal|"%s: LayerDown: %s\n"
argument_list|,
name|fp
operator|->
name|link
operator|->
name|name
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* XXX: Call radius_Account() */
if|if
condition|(
operator|!
name|Enabled
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
name|OPT_IPCP
argument_list|)
condition|)
block|{
comment|/*        * XXX this stuff should really live in the FSM.  Our config should        * associate executable sections in files with events.        */
if|if
condition|(
name|system_Select
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
name|addr
argument_list|,
name|LINKDOWNFILE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bundle_GetLabel
argument_list|(
name|fp
operator|->
name|bundle
argument_list|)
condition|)
block|{
if|if
condition|(
name|system_Select
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
name|bundle_GetLabel
argument_list|(
name|fp
operator|->
name|bundle
argument_list|)
argument_list|,
name|LINKDOWNFILE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|system_Select
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
literal|"MYADDR6"
argument_list|,
name|LINKDOWNFILE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|system_Select
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
literal|"MYADDR6"
argument_list|,
name|LINKDOWNFILE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|ipv6cp_Setup
argument_list|(
name|ipv6cp
argument_list|)
expr_stmt|;
block|}
name|recursing
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipv6cp_LayerStart
parameter_list|(
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/* We're about to start up ! */
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
init|=
name|fsm2ipv6cp
argument_list|(
name|fp
argument_list|)
decl_stmt|;
name|log_Printf
argument_list|(
name|LogIPV6CP
argument_list|,
literal|"%s: LayerStart.\n"
argument_list|,
name|fp
operator|->
name|link
operator|->
name|name
argument_list|)
expr_stmt|;
name|throughput_start
argument_list|(
operator|&
name|ipv6cp
operator|->
name|throughput
argument_list|,
literal|"IPV6CP throughput"
argument_list|,
name|Enabled
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
name|OPT_THROUGHPUT
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|more
operator|.
name|reqs
operator|=
name|fp
operator|->
name|more
operator|.
name|naks
operator|=
name|fp
operator|->
name|more
operator|.
name|rejs
operator|=
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|maxreq
operator|*
literal|3
expr_stmt|;
name|ipv6cp
operator|->
name|peer_tokenreq
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipv6cp_LayerFinish
parameter_list|(
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/* We're now down */
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
init|=
name|fsm2ipv6cp
argument_list|(
name|fp
argument_list|)
decl_stmt|;
name|log_Printf
argument_list|(
name|LogIPV6CP
argument_list|,
literal|"%s: LayerFinish.\n"
argument_list|,
name|fp
operator|->
name|link
operator|->
name|name
argument_list|)
expr_stmt|;
name|throughput_stop
argument_list|(
operator|&
name|ipv6cp
operator|->
name|throughput
argument_list|)
expr_stmt|;
name|throughput_log
argument_list|(
operator|&
name|ipv6cp
operator|->
name|throughput
argument_list|,
name|LogIPV6CP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipv6cp_InitRestartCounter
parameter_list|(
name|struct
name|fsm
modifier|*
name|fp
parameter_list|,
name|int
name|what
parameter_list|)
block|{
comment|/* Set fsm timer load */
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
init|=
name|fsm2ipv6cp
argument_list|(
name|fp
argument_list|)
decl_stmt|;
name|fp
operator|->
name|FsmTimer
operator|.
name|load
operator|=
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|timeout
operator|*
name|SECTICKS
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|FSM_REQ_TIMER
case|:
name|fp
operator|->
name|restart
operator|=
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|maxreq
expr_stmt|;
break|break;
case|case
name|FSM_TRM_TIMER
case|:
name|fp
operator|->
name|restart
operator|=
name|ipv6cp
operator|->
name|cfg
operator|.
name|fsm
operator|.
name|maxtrm
expr_stmt|;
break|break;
default|default:
name|fp
operator|->
name|restart
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ipv6cp_SendConfigReq
parameter_list|(
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/* Send config REQ please */
name|struct
name|physical
modifier|*
name|p
init|=
name|link2physical
argument_list|(
name|fp
operator|->
name|link
argument_list|)
decl_stmt|;
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
init|=
name|fsm2ipv6cp
argument_list|(
name|fp
argument_list|)
decl_stmt|;
name|u_char
name|buff
index|[
name|IPV6CP_IFIDLEN
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|fsm_opt
modifier|*
name|o
decl_stmt|;
name|o
operator|=
operator|(
expr|struct
name|fsm_opt
operator|*
operator|)
name|buff
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|&&
operator|!
name|physical_IsSync
argument_list|(
name|p
argument_list|)
operator|)
operator|||
operator|!
name|REJECTED
argument_list|(
name|ipv6cp
argument_list|,
name|TY_TOKEN
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|o
operator|->
name|data
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
expr_stmt|;
name|INC_FSM_OPT
argument_list|(
name|TY_TOKEN
argument_list|,
name|IPV6CP_IFIDLEN
operator|+
literal|2
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
name|fsm_Output
argument_list|(
name|fp
argument_list|,
name|CODE_CONFIGREQ
argument_list|,
name|fp
operator|->
name|reqid
argument_list|,
name|buff
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|o
operator|-
name|buff
argument_list|,
name|MB_IPV6CPOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipv6cp_SentTerminateReq
parameter_list|(
name|struct
name|fsm
modifier|*
name|fp
parameter_list|)
block|{
comment|/* Term REQ just sent by FSM */
block|}
end_function

begin_function
specifier|static
name|void
name|ipv6cp_SendTerminateAck
parameter_list|(
name|struct
name|fsm
modifier|*
name|fp
parameter_list|,
name|u_char
name|id
parameter_list|)
block|{
comment|/* Send Term ACK please */
name|fsm_Output
argument_list|(
name|fp
argument_list|,
name|CODE_TERMACK
argument_list|,
name|id
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|MB_IPV6CPOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|protoname
parameter_list|(
name|int
name|proto
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|cftypes
index|[]
init|=
block|{
literal|"IFACEID"
block|,
literal|"COMPPROTO"
block|}
decl_stmt|;
if|if
condition|(
name|proto
operator|>
literal|0
operator|&&
name|proto
operator|<=
sizeof|sizeof
name|cftypes
operator|/
sizeof|sizeof
expr|*
name|cftypes
condition|)
return|return
name|cftypes
index|[
name|proto
operator|-
literal|1
index|]
return|;
return|return
name|NumStr
argument_list|(
name|proto
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipv6cp_ValidateInterfaceID
parameter_list|(
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
parameter_list|,
name|u_char
modifier|*
name|ifid
parameter_list|,
name|struct
name|fsm_decode
modifier|*
name|dec
parameter_list|)
block|{
name|struct
name|fsm_opt
name|opt
decl_stmt|;
name|u_char
name|zero
index|[
name|IPV6CP_IFIDLEN
index|]
decl_stmt|;
name|memset
argument_list|(
name|zero
argument_list|,
literal|0
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|ifid
argument_list|,
name|zero
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
operator|!=
literal|0
operator|&&
name|memcmp
argument_list|(
name|ifid
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|ipv6cp
operator|->
name|his_ifid
argument_list|,
name|ifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
expr_stmt|;
name|opt
operator|.
name|hdr
operator|.
name|id
operator|=
name|TY_TOKEN
expr_stmt|;
name|opt
operator|.
name|hdr
operator|.
name|len
operator|=
name|IPV6CP_IFIDLEN
operator|+
literal|2
expr_stmt|;
name|memcpy
argument_list|(
name|opt
operator|.
name|data
argument_list|,
operator|&
name|ipv6cp
operator|->
name|his_ifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|ifid
argument_list|,
name|ipv6cp
operator|->
name|his_ifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
operator|==
literal|0
condition|)
name|fsm_ack
argument_list|(
name|dec
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
else|else
name|fsm_nak
argument_list|(
name|dec
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipv6cp_DecodeConfig
parameter_list|(
name|struct
name|fsm
modifier|*
name|fp
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_char
modifier|*
name|end
parameter_list|,
name|int
name|mode_type
parameter_list|,
name|struct
name|fsm_decode
modifier|*
name|dec
parameter_list|)
block|{
comment|/* Deal with incoming PROTO_IPV6CP */
name|struct
name|ipv6cp
modifier|*
name|ipv6cp
init|=
name|fsm2ipv6cp
argument_list|(
name|fp
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|tbuff
index|[
literal|100
index|]
decl_stmt|;
name|u_char
name|ifid
index|[
name|IPV6CP_IFIDLEN
index|]
decl_stmt|,
name|zero
index|[
name|IPV6CP_IFIDLEN
index|]
decl_stmt|;
name|struct
name|fsm_opt
modifier|*
name|opt
decl_stmt|;
name|memset
argument_list|(
name|zero
argument_list|,
literal|0
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
expr_stmt|;
while|while
condition|(
name|end
operator|-
name|cp
operator|>=
sizeof|sizeof
argument_list|(
name|opt
operator|->
name|hdr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|opt
operator|=
name|fsm_readopt
argument_list|(
operator|&
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|snprintf
argument_list|(
name|tbuff
argument_list|,
sizeof|sizeof
name|tbuff
argument_list|,
literal|" %s[%d]"
argument_list|,
name|protoname
argument_list|(
name|opt
operator|->
name|hdr
operator|.
name|id
argument_list|)
argument_list|,
name|opt
operator|->
name|hdr
operator|.
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opt
operator|->
name|hdr
operator|.
name|id
condition|)
block|{
case|case
name|TY_TOKEN
case|:
name|memcpy
argument_list|(
name|ifid
argument_list|,
name|opt
operator|->
name|data
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogIPV6CP
argument_list|,
literal|"%s 0x%02x%02x%02x%02x%02x%02x%02x%02x\n"
argument_list|,
name|tbuff
argument_list|,
name|ifid
index|[
literal|0
index|]
argument_list|,
name|ifid
index|[
literal|1
index|]
argument_list|,
name|ifid
index|[
literal|2
index|]
argument_list|,
name|ifid
index|[
literal|3
index|]
argument_list|,
name|ifid
index|[
literal|4
index|]
argument_list|,
name|ifid
index|[
literal|5
index|]
argument_list|,
name|ifid
index|[
literal|6
index|]
argument_list|,
name|ifid
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode_type
condition|)
block|{
case|case
name|MODE_REQ
case|:
name|ipv6cp
operator|->
name|peer_tokenreq
operator|=
literal|1
expr_stmt|;
name|ipv6cp_ValidateInterfaceID
argument_list|(
name|ipv6cp
argument_list|,
name|ifid
argument_list|,
name|dec
argument_list|)
expr_stmt|;
break|break;
case|case
name|MODE_NAK
case|:
if|if
condition|(
name|memcmp
argument_list|(
name|ifid
argument_list|,
name|zero
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|log_IsKept
argument_list|(
name|LogIPV6CP
argument_list|)
condition|?
name|LogIPV6CP
else|:
name|LogPHASE
argument_list|,
literal|"0x0000000000000000: Unacceptable IntefaceID!\n"
argument_list|)
expr_stmt|;
name|fsm_Close
argument_list|(
operator|&
name|ipv6cp
operator|->
name|fsm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|ifid
argument_list|,
name|ipv6cp
operator|->
name|his_ifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|log_IsKept
argument_list|(
name|LogIPV6CP
argument_list|)
condition|?
name|LogIPV6CP
else|:
name|LogPHASE
argument_list|,
literal|"0x%02x%02x%02x%02x%02x%02x%02x%02x: "
literal|"Unacceptable IntefaceID!\n"
argument_list|,
name|ifid
index|[
literal|0
index|]
argument_list|,
name|ifid
index|[
literal|1
index|]
argument_list|,
name|ifid
index|[
literal|2
index|]
argument_list|,
name|ifid
index|[
literal|3
index|]
argument_list|,
name|ifid
index|[
literal|4
index|]
argument_list|,
name|ifid
index|[
literal|5
index|]
argument_list|,
name|ifid
index|[
literal|6
index|]
argument_list|,
name|ifid
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|ifid
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|n
operator|=
literal|100
expr_stmt|;
while|while
condition|(
name|n
operator|&&
operator|!
name|ipcp_SetIPv6address
argument_list|(
name|ipv6cp
argument_list|,
name|ifid
argument_list|,
name|ipv6cp
operator|->
name|his_ifid
argument_list|)
condition|)
block|{
do|do
block|{
name|n
operator|--
expr_stmt|;
name|SetInterfaceID
argument_list|(
name|ifid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|&&
name|memcmp
argument_list|(
name|ifid
argument_list|,
name|ipv6cp
operator|->
name|his_ifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
operator|==
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|log_IsKept
argument_list|(
name|LogIPV6CP
argument_list|)
condition|?
name|LogIPV6CP
else|:
name|LogPHASE
argument_list|,
literal|"0x0000000000000000: Unacceptable IntefaceID!\n"
argument_list|)
expr_stmt|;
name|fsm_Close
argument_list|(
operator|&
name|ipv6cp
operator|->
name|fsm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_Printf
argument_list|(
name|LogIPV6CP
argument_list|,
literal|"%s changing IntefaceID: "
literal|"0x%02x%02x%02x%02x%02x%02x%02x%02x "
literal|"--> 0x%02x%02x%02x%02x%02x%02x%02x%02x\n"
argument_list|,
name|tbuff
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
index|[
literal|0
index|]
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
index|[
literal|1
index|]
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
index|[
literal|2
index|]
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
index|[
literal|3
index|]
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
index|[
literal|4
index|]
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
index|[
literal|5
index|]
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
index|[
literal|6
index|]
argument_list|,
name|ipv6cp
operator|->
name|my_ifid
index|[
literal|7
index|]
argument_list|,
name|ifid
index|[
literal|0
index|]
argument_list|,
name|ifid
index|[
literal|1
index|]
argument_list|,
name|ifid
index|[
literal|2
index|]
argument_list|,
name|ifid
index|[
literal|3
index|]
argument_list|,
name|ifid
index|[
literal|4
index|]
argument_list|,
name|ifid
index|[
literal|5
index|]
argument_list|,
name|ifid
index|[
literal|6
index|]
argument_list|,
name|ifid
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ipv6cp
operator|->
name|my_ifid
argument_list|,
name|ifid
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
expr_stmt|;
name|bundle_AdjustFilters
argument_list|(
name|fp
operator|->
name|bundle
argument_list|,
operator|&
name|ipv6cp
operator|->
name|myaddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MODE_REJ
case|:
name|ipv6cp
operator|->
name|his_reject
operator||=
operator|(
literal|1
operator|<<
name|opt
operator|->
name|hdr
operator|.
name|id
operator|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
if|if
condition|(
name|mode_type
operator|!=
name|MODE_NOP
condition|)
block|{
name|ipv6cp
operator|->
name|my_reject
operator||=
operator|(
literal|1
operator|<<
name|opt
operator|->
name|hdr
operator|.
name|id
operator|)
expr_stmt|;
name|fsm_rej
argument_list|(
name|dec
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|mode_type
operator|!=
name|MODE_NOP
condition|)
block|{
if|if
condition|(
name|mode_type
operator|==
name|MODE_REQ
operator|&&
operator|!
name|ipv6cp
operator|->
name|peer_tokenreq
condition|)
block|{
if|if
condition|(
name|dec
operator|->
name|rejend
operator|==
name|dec
operator|->
name|rej
operator|&&
name|dec
operator|->
name|nakend
operator|==
name|dec
operator|->
name|nak
condition|)
block|{
comment|/*          * Pretend the peer has requested a TOKEN.          * We do this to ensure that we only send one NAK if the only          * reason for the NAK is because the peer isn't sending a          * TY_TOKEN REQ.  This stops us from repeatedly trying to tell          * the peer that we have to have an IP address on their end.          */
name|ipv6cp
operator|->
name|peer_tokenreq
operator|=
literal|1
expr_stmt|;
block|}
name|memset
argument_list|(
name|ifid
argument_list|,
literal|0
argument_list|,
name|IPV6CP_IFIDLEN
argument_list|)
expr_stmt|;
name|ipv6cp_ValidateInterfaceID
argument_list|(
name|ipv6cp
argument_list|,
name|ifid
argument_list|,
name|dec
argument_list|)
expr_stmt|;
block|}
name|fsm_opt_normalise
argument_list|(
name|dec
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

