begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Brian Somers<brian@Awfulhak.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|"layer.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"descriptor.h"
end_include

begin_include
include|#
directive|include
file|"lqr.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"throughput.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ccp.h"
end_include

begin_include
include|#
directive|include
file|"link.h"
end_include

begin_include
include|#
directive|include
file|"async.h"
end_include

begin_include
include|#
directive|include
file|"physical.h"
end_include

begin_include
include|#
directive|include
file|"proto.h"
end_include

begin_include
include|#
directive|include
file|"cbcp.h"
end_include

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_include
include|#
directive|include
file|"chat.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"datalink.h"
end_include

begin_function
name|void
name|cbcp_Init
parameter_list|(
name|struct
name|cbcp
modifier|*
name|cbcp
parameter_list|,
name|struct
name|physical
modifier|*
name|p
parameter_list|)
block|{
name|cbcp
operator|->
name|required
operator|=
literal|0
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|state
operator|=
name|CBCP_CLOSED
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|delay
operator|=
literal|0
expr_stmt|;
operator|*
name|cbcp
operator|->
name|fsm
operator|.
name|phone
operator|=
literal|'\0'
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cbcp
operator|->
name|fsm
operator|.
name|timer
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
name|cbcp
operator|->
name|fsm
operator|.
name|timer
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|p
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|cbcp_SendReq
parameter_list|(
name|struct
name|cbcp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cbcp_SendResponse
parameter_list|(
name|struct
name|cbcp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cbcp_SendAck
parameter_list|(
name|struct
name|cbcp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|cbcp_Timeout
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|cbcp
modifier|*
name|cbcp
init|=
operator|(
expr|struct
name|cbcp
operator|*
operator|)
name|v
decl_stmt|;
name|timer_Stop
argument_list|(
operator|&
name|cbcp
operator|->
name|fsm
operator|.
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|restart
condition|)
block|{
switch|switch
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
condition|)
block|{
case|case
name|CBCP_CLOSED
case|:
case|case
name|CBCP_STOPPED
case|:
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: Urk - unexpected CBCP timeout !\n"
argument_list|,
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CBCP_REQSENT
case|:
name|cbcp_SendReq
argument_list|(
name|cbcp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CBCP_RESPSENT
case|:
name|cbcp_SendResponse
argument_list|(
name|cbcp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CBCP_ACKSENT
case|:
name|cbcp_SendAck
argument_list|(
name|cbcp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|missed
decl_stmt|;
switch|switch
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
condition|)
block|{
case|case
name|CBCP_STOPPED
case|:
name|missed
operator|=
literal|"REQ"
expr_stmt|;
break|break;
case|case
name|CBCP_REQSENT
case|:
name|missed
operator|=
literal|"RESPONSE"
expr_stmt|;
break|break;
case|case
name|CBCP_RESPSENT
case|:
name|missed
operator|=
literal|"ACK"
expr_stmt|;
break|break;
case|case
name|CBCP_ACKSENT
case|:
name|missed
operator|=
literal|"Terminate REQ"
expr_stmt|;
break|break;
default|default:
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: Urk - unexpected CBCP timeout !\n"
argument_list|,
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|name
argument_list|)
expr_stmt|;
name|missed
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|missed
condition|)
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: Timeout waiting for peer %s\n"
argument_list|,
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|name
argument_list|,
name|missed
argument_list|)
expr_stmt|;
name|datalink_CBCPFailed
argument_list|(
name|cbcp
operator|->
name|p
operator|->
name|dl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cbcp_StartTimer
parameter_list|(
name|struct
name|cbcp
modifier|*
name|cbcp
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|cbcp
operator|->
name|fsm
operator|.
name|timer
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|timer
operator|.
name|func
operator|=
name|cbcp_Timeout
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|timer
operator|.
name|name
operator|=
literal|"cbcp"
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|timer
operator|.
name|load
operator|=
name|timeout
operator|*
name|SECTICKS
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|timer
operator|.
name|arg
operator|=
name|cbcp
expr_stmt|;
name|timer_Start
argument_list|(
operator|&
name|cbcp
operator|->
name|fsm
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CBCP_CLOSED
value|(0)
end_define

begin_comment
comment|/* Not in use */
end_comment

begin_define
define|#
directive|define
name|CBCP_STOPPED
value|(1)
end_define

begin_comment
comment|/* Waiting for a REQ */
end_comment

begin_define
define|#
directive|define
name|CBCP_REQSENT
value|(2)
end_define

begin_comment
comment|/* Waiting for a RESP */
end_comment

begin_define
define|#
directive|define
name|CBCP_RESPSENT
value|(3)
end_define

begin_comment
comment|/* Waiting for an ACK */
end_comment

begin_define
define|#
directive|define
name|CBCP_ACKSENT
value|(4)
end_define

begin_comment
comment|/* Waiting for an LCP Term REQ */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|cbcpname
index|[]
init|=
block|{
literal|"closed"
block|,
literal|"stopped"
block|,
literal|"req-sent"
block|,
literal|"resp-sent"
block|,
literal|"ack-sent"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cbcpstate
parameter_list|(
name|int
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|<
sizeof|sizeof
name|cbcpname
operator|/
sizeof|sizeof
name|cbcpname
index|[
literal|0
index|]
condition|)
return|return
name|cbcpname
index|[
name|s
index|]
return|;
return|return
name|HexStr
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cbcp_NewPhase
parameter_list|(
name|struct
name|cbcp
modifier|*
name|cbcp
parameter_list|,
name|int
name|new
parameter_list|)
block|{
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
operator|!=
name|new
condition|)
block|{
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: State change %s --> %s\n"
argument_list|,
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|name
argument_list|,
name|cbcpstate
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
argument_list|)
argument_list|,
name|cbcpstate
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|state
operator|=
name|new
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|cbcp_header
block|{
name|u_char
name|code
decl_stmt|;
name|u_char
name|id
decl_stmt|;
name|u_int16_t
name|length
decl_stmt|;
comment|/* Network byte order */
block|}
struct|;
end_struct

begin_comment
comment|/* cbcp_header::code values */
end_comment

begin_define
define|#
directive|define
name|CBCP_REQ
value|(1)
end_define

begin_define
define|#
directive|define
name|CBCP_RESPONSE
value|(2)
end_define

begin_define
define|#
directive|define
name|CBCP_ACK
value|(3)
end_define

begin_struct
struct|struct
name|cbcp_data
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|length
decl_stmt|;
name|u_char
name|delay
decl_stmt|;
name|char
name|addr_start
index|[
literal|253
index|]
decl_stmt|;
comment|/* max cbcp_data length 255 + 1 for NULL */
block|}
struct|;
end_struct

begin_comment
comment|/* cbcp_data::type values */
end_comment

begin_define
define|#
directive|define
name|CBCP_NONUM
value|(1)
end_define

begin_define
define|#
directive|define
name|CBCP_CLIENTNUM
value|(2)
end_define

begin_define
define|#
directive|define
name|CBCP_SERVERNUM
value|(3)
end_define

begin_define
define|#
directive|define
name|CBCP_LISTNUM
value|(4)
end_define

begin_function
specifier|static
name|void
name|cbcp_Output
parameter_list|(
name|struct
name|cbcp
modifier|*
name|cbcp
parameter_list|,
name|u_char
name|code
parameter_list|,
name|struct
name|cbcp_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|cbcp_header
modifier|*
name|head
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|m_get
argument_list|(
sizeof|sizeof
expr|*
name|head
operator|+
name|data
operator|->
name|length
argument_list|,
name|MB_CBCPOUT
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
expr|struct
name|cbcp_header
operator|*
operator|)
name|MBUF_CTOP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|head
operator|->
name|code
operator|=
name|code
expr_stmt|;
name|head
operator|->
name|id
operator|=
name|cbcp
operator|->
name|fsm
operator|.
name|id
expr_stmt|;
name|head
operator|->
name|length
operator|=
name|htons
argument_list|(
sizeof|sizeof
expr|*
name|head
operator|+
name|data
operator|->
name|length
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|MBUF_CTOP
argument_list|(
name|bp
argument_list|)
operator|+
sizeof|sizeof
expr|*
name|head
argument_list|,
name|data
argument_list|,
name|data
operator|->
name|length
argument_list|)
expr_stmt|;
name|log_DumpBp
argument_list|(
name|LogDEBUG
argument_list|,
literal|"cbcp_Output"
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|link_PushPacket
argument_list|(
operator|&
name|cbcp
operator|->
name|p
operator|->
name|link
argument_list|,
name|bp
argument_list|,
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|bundle
argument_list|,
name|LINK_QUEUES
argument_list|(
operator|&
name|cbcp
operator|->
name|p
operator|->
name|link
argument_list|)
operator|-
literal|1
argument_list|,
name|PROTO_CBCP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cbcp_data_Type
parameter_list|(
name|int
name|type
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|types
index|[]
init|=
block|{
literal|"No callback"
block|,
literal|"User-spec"
block|,
literal|"Server-spec"
block|,
literal|"list"
block|}
decl_stmt|;
if|if
condition|(
name|type
operator|<
literal|1
operator|||
name|type
operator|>
sizeof|sizeof
name|types
operator|/
sizeof|sizeof
name|types
index|[
literal|0
index|]
condition|)
return|return
name|HexStr
argument_list|(
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|types
index|[
name|type
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_struct
struct|struct
name|cbcp_addr
block|{
name|u_char
name|type
decl_stmt|;
name|char
name|addr
index|[
literal|1
index|]
decl_stmt|;
comment|/* Really ASCIIZ */
block|}
struct|;
end_struct

begin_comment
comment|/* cbcp_data::type values */
end_comment

begin_define
define|#
directive|define
name|CBCP_ADDR_PSTN
value|(1)
end_define

begin_function
specifier|static
name|void
name|cbcp_data_Show
parameter_list|(
name|struct
name|cbcp_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|cbcp_addr
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
name|data
operator|->
name|addr_start
expr_stmt|;
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|data
operator|->
name|length
expr_stmt|;
operator|*
name|end
operator|=
literal|'\0'
expr_stmt|;
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|" TYPE %s\n"
argument_list|,
name|cbcp_data_Type
argument_list|(
name|data
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|char
operator|*
operator|)
operator|&
name|data
operator|->
name|delay
operator|<
name|end
condition|)
block|{
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|" DELAY %d\n"
argument_list|,
name|data
operator|->
name|delay
argument_list|)
expr_stmt|;
while|while
condition|(
name|addr
operator|->
name|addr
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|addr
operator|->
name|type
operator|==
name|CBCP_ADDR_PSTN
condition|)
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|" ADDR %s\n"
argument_list|,
name|addr
operator|->
name|addr
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|" ADDR type %d ??\n"
argument_list|,
operator|(
name|int
operator|)
name|addr
operator|->
name|type
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
operator|(
name|addr
operator|->
name|addr
operator|+
name|strlen
argument_list|(
name|addr
operator|->
name|addr
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cbcp_SendReq
parameter_list|(
name|struct
name|cbcp
modifier|*
name|cbcp
parameter_list|)
block|{
name|struct
name|cbcp_data
name|data
decl_stmt|;
name|struct
name|cbcp_addr
modifier|*
name|addr
decl_stmt|;
name|char
name|list
index|[
sizeof|sizeof
name|cbcp
operator|->
name|fsm
operator|.
name|phone
index|]
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|len
decl_stmt|,
name|max
decl_stmt|;
comment|/* Only callees send REQs */
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: SendReq(%d) state = %s\n"
argument_list|,
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|name
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|id
argument_list|,
name|cbcpstate
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|type
operator|=
name|cbcp
operator|->
name|fsm
operator|.
name|type
expr_stmt|;
name|data
operator|.
name|delay
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|list
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
sizeof|sizeof
name|list
operator|-
literal|1
argument_list|)
expr_stmt|;
name|list
index|[
sizeof|sizeof
name|list
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|data
operator|.
name|type
condition|)
block|{
case|case
name|CBCP_CLIENTNUM
case|:
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
name|data
operator|.
name|addr_start
expr_stmt|;
name|addr
operator|->
name|type
operator|=
name|CBCP_ADDR_PSTN
expr_stmt|;
operator|*
name|addr
operator|->
name|addr
operator|=
literal|'\0'
expr_stmt|;
name|data
operator|.
name|length
operator|=
name|addr
operator|->
name|addr
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|data
expr_stmt|;
break|break;
case|case
name|CBCP_LISTNUM
case|:
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
name|data
operator|.
name|addr_start
expr_stmt|;
for|for
control|(
name|next
operator|=
name|strtok
argument_list|(
name|list
argument_list|,
literal|","
argument_list|)
init|;
name|next
condition|;
name|next
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|max
operator|=
name|data
operator|.
name|addr_start
operator|+
sizeof|sizeof
name|data
operator|.
name|addr_start
operator|-
name|addr
operator|->
name|addr
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|max
condition|)
block|{
name|addr
operator|->
name|type
operator|=
name|CBCP_ADDR_PSTN
expr_stmt|;
name|strcpy
argument_list|(
name|addr
operator|->
name|addr
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
name|len
operator|+
literal|2
operator|)
expr_stmt|;
block|}
else|else
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"CBCP ADDR \"%s\" skipped - packet too large\n"
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|data
operator|.
name|length
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|data
expr_stmt|;
break|break;
case|case
name|CBCP_SERVERNUM
case|:
name|data
operator|.
name|length
operator|=
name|data
operator|.
name|addr_start
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|data
expr_stmt|;
break|break;
default|default:
name|data
operator|.
name|length
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
operator|.
name|delay
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|data
expr_stmt|;
break|break;
block|}
name|cbcp_data_Show
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|cbcp_Output
argument_list|(
name|cbcp
argument_list|,
name|CBCP_REQ
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|restart
operator|--
expr_stmt|;
name|cbcp_StartTimer
argument_list|(
name|cbcp
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|delay
argument_list|)
expr_stmt|;
name|cbcp_NewPhase
argument_list|(
name|cbcp
argument_list|,
name|CBCP_REQSENT
argument_list|)
expr_stmt|;
comment|/* Wait for a RESPONSE */
block|}
end_function

begin_function
name|void
name|cbcp_Up
parameter_list|(
name|struct
name|cbcp
modifier|*
name|cbcp
parameter_list|)
block|{
name|struct
name|lcp
modifier|*
name|lcp
init|=
operator|&
name|cbcp
operator|->
name|p
operator|->
name|link
operator|.
name|lcp
decl_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|delay
operator|=
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|cfg
operator|.
name|cbcp
operator|.
name|delay
expr_stmt|;
if|if
condition|(
operator|*
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|peer
operator|.
name|authname
operator|==
literal|'\0'
operator|||
operator|!
name|auth_SetPhoneList
argument_list|(
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|peer
operator|.
name|authname
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
sizeof|sizeof
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|cfg
operator|.
name|cbcp
operator|.
name|phone
argument_list|,
sizeof|sizeof
name|cbcp
operator|->
name|fsm
operator|.
name|phone
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|phone
index|[
sizeof|sizeof
name|cbcp
operator|->
name|fsm
operator|.
name|phone
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|lcp
operator|->
name|want_callback
operator|.
name|opmask
condition|)
block|{
if|if
condition|(
operator|*
name|cbcp
operator|->
name|fsm
operator|.
name|phone
operator|==
literal|'\0'
condition|)
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|=
name|CBCP_NONUM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
literal|"*"
argument_list|)
condition|)
block|{
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|=
name|CBCP_SERVERNUM
expr_stmt|;
operator|*
name|cbcp
operator|->
name|fsm
operator|.
name|phone
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|=
name|CBCP_CLIENTNUM
expr_stmt|;
name|cbcp_NewPhase
argument_list|(
name|cbcp
argument_list|,
name|CBCP_STOPPED
argument_list|)
expr_stmt|;
comment|/* Wait for a REQ */
name|cbcp_StartTimer
argument_list|(
name|cbcp
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|delay
operator|*
name|DEF_FSMTRIES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|cbcp
operator|->
name|fsm
operator|.
name|phone
operator|==
literal|'\0'
condition|)
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|=
name|CBCP_NONUM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
literal|"*"
argument_list|)
condition|)
block|{
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|=
name|CBCP_CLIENTNUM
expr_stmt|;
operator|*
name|cbcp
operator|->
name|fsm
operator|.
name|phone
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
literal|','
argument_list|)
condition|)
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|=
name|CBCP_LISTNUM
expr_stmt|;
else|else
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|=
name|CBCP_SERVERNUM
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|restart
operator|=
name|DEF_FSMTRIES
expr_stmt|;
name|cbcp_SendReq
argument_list|(
name|cbcp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cbcp_AdjustResponse
parameter_list|(
name|struct
name|cbcp
modifier|*
name|cbcp
parameter_list|,
name|struct
name|cbcp_data
modifier|*
name|data
parameter_list|)
block|{
comment|/*    * We've received a REQ (data).  Adjust our reponse (cbcp->fsm.*)    * so that we (hopefully) agree with the peer    */
name|struct
name|cbcp_addr
modifier|*
name|addr
decl_stmt|;
switch|switch
condition|(
name|data
operator|->
name|type
condition|)
block|{
case|case
name|CBCP_NONUM
case|:
if|if
condition|(
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|cfg
operator|.
name|callback
operator|.
name|opmask
operator|&
name|CALLBACK_BIT
argument_list|(
name|CALLBACK_NONE
argument_list|)
condition|)
comment|/*          * if ``none'' is a configured callback possibility          * (ie, ``set callback cbcp none''), go along with the callees          * request          */
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|=
name|CBCP_NONUM
expr_stmt|;
comment|/*        * Otherwise, we send our desired response anyway.  This seems to be        * what Win95 does - although I can't find this behaviour documented        * in the CBCP spec....        */
return|return
literal|1
return|;
case|case
name|CBCP_CLIENTNUM
case|:
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|==
name|CBCP_CLIENTNUM
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|length
operator|>
name|data
operator|->
name|addr_start
operator|-
operator|(
name|char
operator|*
operator|)
name|data
condition|)
block|{
comment|/*            * The peer has given us an address type spec - make sure we            * understand !            */
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
name|data
operator|->
name|addr_start
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|type
operator|!=
name|CBCP_ADDR_PSTN
condition|)
block|{
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"CBCP: Unrecognised address type %d !\n"
argument_list|,
operator|(
name|int
operator|)
name|addr
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* we accept the REQ even if the peer didn't specify an addr->type */
name|ptr
operator|=
name|strchr
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* Just use the first number in our list */
return|return
literal|1
return|;
block|}
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"CBCP: no number to pass to the peer !\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CBCP_SERVERNUM
case|:
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|==
name|CBCP_SERVERNUM
condition|)
block|{
operator|*
name|cbcp
operator|->
name|fsm
operator|.
name|phone
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|data
operator|->
name|length
operator|>
name|data
operator|->
name|addr_start
operator|-
operator|(
name|char
operator|*
operator|)
name|data
condition|)
block|{
comment|/*          * This violates the spec, but if the peer has told us the          * number it wants to call back, take advantage of this fact          * and allow things to proceed if we've specified the same          * number          */
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
name|data
operator|->
name|addr_start
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|type
operator|!=
name|CBCP_ADDR_PSTN
condition|)
block|{
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"CBCP: Unrecognised address type %d !\n"
argument_list|,
operator|(
name|int
operator|)
name|addr
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|==
name|CBCP_CLIENTNUM
condition|)
block|{
comment|/*            * If the peer's insisting on deciding the number, make sure            * it's one of the ones in our list.  If it is, let the peer            * think it's in control :-)            */
name|char
name|list
index|[
sizeof|sizeof
name|cbcp
operator|->
name|fsm
operator|.
name|phone
index|]
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|strncpy
argument_list|(
name|list
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
sizeof|sizeof
name|list
operator|-
literal|1
argument_list|)
expr_stmt|;
name|list
index|[
sizeof|sizeof
name|list
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|next
operator|=
name|strtok
argument_list|(
name|list
argument_list|,
literal|","
argument_list|)
init|;
name|next
condition|;
name|next
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|next
argument_list|,
name|addr
operator|->
name|addr
argument_list|)
condition|)
block|{
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|=
name|CBCP_SERVERNUM
expr_stmt|;
name|strcpy
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"CBCP: Peer won't allow local decision !\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CBCP_LISTNUM
case|:
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|==
name|CBCP_CLIENTNUM
operator|||
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|==
name|CBCP_LISTNUM
condition|)
block|{
comment|/*          * Search through ``data''s addresses and see if cbcp->fsm.phone          * contains any of them          */
name|char
name|list
index|[
sizeof|sizeof
name|cbcp
operator|->
name|fsm
operator|.
name|phone
index|]
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
name|data
operator|->
name|addr_start
expr_stmt|;
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|data
operator|->
name|length
expr_stmt|;
while|while
condition|(
name|addr
operator|->
name|addr
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|addr
operator|->
name|type
operator|==
name|CBCP_ADDR_PSTN
condition|)
block|{
name|strncpy
argument_list|(
name|list
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
sizeof|sizeof
name|list
operator|-
literal|1
argument_list|)
expr_stmt|;
name|list
index|[
sizeof|sizeof
name|list
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|next
operator|=
name|strtok
argument_list|(
name|list
argument_list|,
literal|","
argument_list|)
init|;
name|next
condition|;
name|next
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|next
argument_list|,
name|addr
operator|->
name|addr
argument_list|)
condition|)
block|{
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|=
name|CBCP_LISTNUM
expr_stmt|;
name|strcpy
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"Warning: Unrecognised address type %d !\n"
argument_list|,
operator|(
name|int
operator|)
name|addr
operator|->
name|type
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
operator|(
name|addr
operator|->
name|addr
operator|+
name|strlen
argument_list|(
name|addr
operator|->
name|addr
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"CBCP: no good number to pass to the peer !\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"Unrecognised REQ type %d !\n"
argument_list|,
operator|(
name|int
operator|)
name|data
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cbcp_SendResponse
parameter_list|(
name|struct
name|cbcp
modifier|*
name|cbcp
parameter_list|)
block|{
name|struct
name|cbcp_data
name|data
decl_stmt|;
name|struct
name|cbcp_addr
modifier|*
name|addr
decl_stmt|;
comment|/* Only callers send RESPONSEs */
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: SendResponse(%d) state = %s\n"
argument_list|,
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|name
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|id
argument_list|,
name|cbcpstate
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|type
operator|=
name|cbcp
operator|->
name|fsm
operator|.
name|type
expr_stmt|;
name|data
operator|.
name|delay
operator|=
name|cbcp
operator|->
name|fsm
operator|.
name|delay
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
name|data
operator|.
name|addr_start
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|type
operator|==
name|CBCP_NONUM
condition|)
name|data
operator|.
name|length
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
operator|.
name|delay
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|data
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cbcp
operator|->
name|fsm
operator|.
name|phone
condition|)
block|{
name|addr
operator|->
name|type
operator|=
name|CBCP_ADDR_PSTN
expr_stmt|;
name|strcpy
argument_list|(
name|addr
operator|->
name|addr
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|)
expr_stmt|;
name|data
operator|.
name|length
operator|=
operator|(
name|addr
operator|->
name|addr
operator|+
name|strlen
argument_list|(
name|addr
operator|->
name|addr
argument_list|)
operator|+
literal|1
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|data
expr_stmt|;
block|}
else|else
name|data
operator|.
name|length
operator|=
name|data
operator|.
name|addr_start
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|data
expr_stmt|;
name|cbcp_data_Show
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|cbcp_Output
argument_list|(
name|cbcp
argument_list|,
name|CBCP_RESPONSE
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|restart
operator|--
expr_stmt|;
name|cbcp_StartTimer
argument_list|(
name|cbcp
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|delay
argument_list|)
expr_stmt|;
name|cbcp_NewPhase
argument_list|(
name|cbcp
argument_list|,
name|CBCP_RESPSENT
argument_list|)
expr_stmt|;
comment|/* Wait for an ACK */
block|}
end_function

begin_comment
comment|/* What to do after checking an incoming response */
end_comment

begin_define
define|#
directive|define
name|CBCP_ACTION_DOWN
value|(0)
end_define

begin_define
define|#
directive|define
name|CBCP_ACTION_REQ
value|(1)
end_define

begin_define
define|#
directive|define
name|CBCP_ACTION_ACK
value|(2)
end_define

begin_function
specifier|static
name|int
name|cbcp_CheckResponse
parameter_list|(
name|struct
name|cbcp
modifier|*
name|cbcp
parameter_list|,
name|struct
name|cbcp_data
modifier|*
name|data
parameter_list|)
block|{
comment|/*    * We've received a RESPONSE (data).  Check if it agrees with    * our REQ (cbcp->fsm)    */
name|struct
name|cbcp_addr
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
name|data
operator|->
name|addr_start
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|type
operator|==
name|cbcp
operator|->
name|fsm
operator|.
name|type
condition|)
block|{
switch|switch
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|type
condition|)
block|{
case|case
name|CBCP_NONUM
case|:
return|return
name|CBCP_ACTION_ACK
return|;
case|case
name|CBCP_CLIENTNUM
case|:
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|data
operator|->
name|length
operator|<=
name|addr
operator|->
name|addr
condition|)
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"CBCP: peer didn't respond with a number !\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|->
name|type
operator|!=
name|CBCP_ADDR_PSTN
condition|)
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"CBCP: Unrecognised address type %d !\n"
argument_list|,
name|addr
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
name|addr
operator|->
name|addr
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|delay
operator|=
name|data
operator|->
name|delay
expr_stmt|;
return|return
name|CBCP_ACTION_ACK
return|;
block|}
return|return
name|CBCP_ACTION_DOWN
return|;
case|case
name|CBCP_SERVERNUM
case|:
name|cbcp
operator|->
name|fsm
operator|.
name|delay
operator|=
name|data
operator|->
name|delay
expr_stmt|;
return|return
name|CBCP_ACTION_ACK
return|;
case|case
name|CBCP_LISTNUM
case|:
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|data
operator|->
name|length
operator|<=
name|addr
operator|->
name|addr
condition|)
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"CBCP: peer didn't respond with a number !\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|->
name|type
operator|!=
name|CBCP_ADDR_PSTN
condition|)
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"CBCP: Unrecognised address type %d !\n"
argument_list|,
name|addr
operator|->
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|list
index|[
sizeof|sizeof
name|cbcp
operator|->
name|fsm
operator|.
name|phone
index|]
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|strncpy
argument_list|(
name|list
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
sizeof|sizeof
name|list
operator|-
literal|1
argument_list|)
expr_stmt|;
name|list
index|[
sizeof|sizeof
name|list
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|next
operator|=
name|strtok
argument_list|(
name|list
argument_list|,
literal|","
argument_list|)
init|;
name|next
condition|;
name|next
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|addr
operator|->
name|addr
argument_list|,
name|next
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|delay
operator|=
name|data
operator|->
name|delay
expr_stmt|;
return|return
name|CBCP_ACTION_ACK
return|;
block|}
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"CBCP: peer didn't respond with a "
literal|"valid number !\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|CBCP_ACTION_DOWN
return|;
block|}
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"Internal CBCP error - agreed on %d ??!?\n"
argument_list|,
operator|(
name|int
operator|)
name|cbcp
operator|->
name|fsm
operator|.
name|type
argument_list|)
expr_stmt|;
return|return
name|CBCP_ACTION_DOWN
return|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|type
operator|==
name|CBCP_NONUM
operator|&&
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|==
name|CBCP_CLIENTNUM
condition|)
block|{
comment|/*      * Client doesn't want CBCP after all....      * We only allow this when ``set cbcp *'' has been specified.      */
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|=
name|CBCP_NONUM
expr_stmt|;
return|return
name|CBCP_ACTION_ACK
return|;
block|}
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"Invalid peer RESPONSE\n"
argument_list|)
expr_stmt|;
return|return
name|CBCP_ACTION_REQ
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cbcp_SendAck
parameter_list|(
name|struct
name|cbcp
modifier|*
name|cbcp
parameter_list|)
block|{
name|struct
name|cbcp_data
name|data
decl_stmt|;
name|struct
name|cbcp_addr
modifier|*
name|addr
decl_stmt|;
comment|/* Only callees send ACKs */
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: SendAck(%d) state = %s\n"
argument_list|,
name|cbcp
operator|->
name|p
operator|->
name|dl
operator|->
name|name
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|id
argument_list|,
name|cbcpstate
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|type
operator|=
name|cbcp
operator|->
name|fsm
operator|.
name|type
expr_stmt|;
switch|switch
condition|(
name|data
operator|.
name|type
condition|)
block|{
case|case
name|CBCP_NONUM
case|:
name|data
operator|.
name|length
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
operator|.
name|delay
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|data
expr_stmt|;
break|break;
case|case
name|CBCP_CLIENTNUM
case|:
name|addr
operator|=
operator|(
expr|struct
name|cbcp_addr
operator|*
operator|)
name|data
operator|.
name|addr_start
expr_stmt|;
name|addr
operator|->
name|type
operator|=
name|CBCP_ADDR_PSTN
expr_stmt|;
name|strcpy
argument_list|(
name|addr
operator|->
name|addr
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|phone
argument_list|)
expr_stmt|;
name|data
operator|.
name|delay
operator|=
name|cbcp
operator|->
name|fsm
operator|.
name|delay
expr_stmt|;
name|data
operator|.
name|length
operator|=
name|addr
operator|->
name|addr
operator|+
name|strlen
argument_list|(
name|addr
operator|->
name|addr
argument_list|)
operator|+
literal|1
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|data
expr_stmt|;
break|break;
default|default:
name|data
operator|.
name|delay
operator|=
name|cbcp
operator|->
name|fsm
operator|.
name|delay
expr_stmt|;
name|data
operator|.
name|length
operator|=
name|data
operator|.
name|addr_start
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|data
expr_stmt|;
break|break;
block|}
name|cbcp_data_Show
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|cbcp_Output
argument_list|(
name|cbcp
argument_list|,
name|CBCP_ACK
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|restart
operator|--
expr_stmt|;
name|cbcp_StartTimer
argument_list|(
name|cbcp
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|delay
argument_list|)
expr_stmt|;
name|cbcp_NewPhase
argument_list|(
name|cbcp
argument_list|,
name|CBCP_ACKSENT
argument_list|)
expr_stmt|;
comment|/* Wait for an ACK */
block|}
end_function

begin_function
specifier|extern
name|struct
name|mbuf
modifier|*
name|cbcp_Input
parameter_list|(
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
name|struct
name|link
modifier|*
name|l
parameter_list|,
name|struct
name|mbuf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|physical
modifier|*
name|p
init|=
name|link2physical
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|struct
name|cbcp_header
modifier|*
name|head
decl_stmt|;
name|struct
name|cbcp_data
modifier|*
name|data
decl_stmt|;
name|struct
name|cbcp
modifier|*
name|cbcp
init|=
operator|&
name|p
operator|->
name|dl
operator|->
name|cbcp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"cbcp_Input: Not a physical link - dropped\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bp
operator|=
name|m_pullup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|len
operator|=
name|m_length
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|cbcp_header
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|head
operator|=
operator|(
expr|struct
name|cbcp_header
operator|*
operator|)
name|MBUF_CTOP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|head
operator|->
name|length
argument_list|)
operator|!=
name|len
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Corrupt CBCP packet (code %d, length %d not %d)"
literal|" - ignored\n"
argument_list|,
name|head
operator|->
name|code
argument_list|,
name|ntohs
argument_list|(
name|head
operator|->
name|length
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|m_settype
argument_list|(
name|bp
argument_list|,
name|MB_CBCPIN
argument_list|)
expr_stmt|;
comment|/* XXX check the id */
name|bp
operator|->
name|m_offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cbcp_header
argument_list|)
expr_stmt|;
name|bp
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|cbcp_header
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|cbcp_data
operator|*
operator|)
name|MBUF_CTOP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|head
operator|->
name|code
condition|)
block|{
case|case
name|CBCP_REQ
case|:
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: RecvReq(%d) state = %s\n"
argument_list|,
name|p
operator|->
name|dl
operator|->
name|name
argument_list|,
name|head
operator|->
name|id
argument_list|,
name|cbcpstate
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|cbcp_data_Show
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
operator|==
name|CBCP_STOPPED
operator|||
name|cbcp
operator|->
name|fsm
operator|.
name|state
operator|==
name|CBCP_RESPSENT
condition|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|cbcp
operator|->
name|fsm
operator|.
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbcp_AdjustResponse
argument_list|(
name|cbcp
argument_list|,
name|data
argument_list|)
condition|)
block|{
name|cbcp
operator|->
name|fsm
operator|.
name|restart
operator|=
name|DEF_FSMTRIES
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|id
operator|=
name|head
operator|->
name|id
expr_stmt|;
name|cbcp_SendResponse
argument_list|(
name|cbcp
argument_list|)
expr_stmt|;
block|}
else|else
name|datalink_CBCPFailed
argument_list|(
name|cbcp
operator|->
name|p
operator|->
name|dl
argument_list|)
expr_stmt|;
block|}
else|else
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: unexpected REQ dropped\n"
argument_list|,
name|p
operator|->
name|dl
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CBCP_RESPONSE
case|:
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: RecvResponse(%d) state = %s\n"
argument_list|,
name|p
operator|->
name|dl
operator|->
name|name
argument_list|,
name|head
operator|->
name|id
argument_list|,
name|cbcpstate
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|cbcp_data_Show
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|id
operator|!=
name|head
operator|->
name|id
condition|)
block|{
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"Warning: Expected id was %d, not %d\n"
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|id
argument_list|,
name|head
operator|->
name|id
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|id
operator|=
name|head
operator|->
name|id
expr_stmt|;
block|}
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
operator|==
name|CBCP_REQSENT
operator|||
name|cbcp
operator|->
name|fsm
operator|.
name|state
operator|==
name|CBCP_ACKSENT
condition|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|cbcp
operator|->
name|fsm
operator|.
name|timer
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cbcp_CheckResponse
argument_list|(
name|cbcp
argument_list|,
name|data
argument_list|)
condition|)
block|{
case|case
name|CBCP_ACTION_REQ
case|:
name|cbcp_SendReq
argument_list|(
name|cbcp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CBCP_ACTION_ACK
case|:
name|cbcp
operator|->
name|fsm
operator|.
name|restart
operator|=
name|DEF_FSMTRIES
expr_stmt|;
name|cbcp_SendAck
argument_list|(
name|cbcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|==
name|CBCP_NONUM
condition|)
block|{
comment|/*                * Don't change state in case the peer doesn't get our ACK,                * just bring the layer up.                */
name|timer_Stop
argument_list|(
operator|&
name|cbcp
operator|->
name|fsm
operator|.
name|timer
argument_list|)
expr_stmt|;
name|datalink_NCPUp
argument_list|(
name|cbcp
operator|->
name|p
operator|->
name|dl
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|datalink_CBCPFailed
argument_list|(
name|cbcp
operator|->
name|p
operator|->
name|dl
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: unexpected RESPONSE dropped\n"
argument_list|,
name|p
operator|->
name|dl
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|CBCP_ACK
case|:
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: RecvAck(%d) state = %s\n"
argument_list|,
name|p
operator|->
name|dl
operator|->
name|name
argument_list|,
name|head
operator|->
name|id
argument_list|,
name|cbcpstate
argument_list|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|cbcp_data_Show
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|id
operator|!=
name|head
operator|->
name|id
condition|)
block|{
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"Warning: Expected id was %d, not %d\n"
argument_list|,
name|cbcp
operator|->
name|fsm
operator|.
name|id
argument_list|,
name|head
operator|->
name|id
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|fsm
operator|.
name|id
operator|=
name|head
operator|->
name|id
expr_stmt|;
block|}
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|type
operator|==
name|CBCP_NONUM
condition|)
block|{
comment|/*          * Don't change state in case the peer doesn't get our ACK,          * just bring the layer up.          */
name|timer_Stop
argument_list|(
operator|&
name|cbcp
operator|->
name|fsm
operator|.
name|timer
argument_list|)
expr_stmt|;
name|datalink_NCPUp
argument_list|(
name|cbcp
operator|->
name|p
operator|->
name|dl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbcp
operator|->
name|fsm
operator|.
name|state
operator|==
name|CBCP_RESPSENT
condition|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|cbcp
operator|->
name|fsm
operator|.
name|timer
argument_list|)
expr_stmt|;
name|datalink_CBCPComplete
argument_list|(
name|cbcp
operator|->
name|p
operator|->
name|dl
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"%s: CBCP: Peer will dial back\n"
argument_list|,
name|p
operator|->
name|dl
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
name|log_Printf
argument_list|(
name|LogCBCP
argument_list|,
literal|"%s: unexpected ACK dropped\n"
argument_list|,
name|p
operator|->
name|dl
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Unrecognised CBCP packet (code %d, length %d)\n"
argument_list|,
name|head
operator|->
name|code
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
block|}
name|m_freem
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|cbcp_Down
parameter_list|(
name|struct
name|cbcp
modifier|*
name|cbcp
parameter_list|)
block|{
name|timer_Stop
argument_list|(
operator|&
name|cbcp
operator|->
name|fsm
operator|.
name|timer
argument_list|)
expr_stmt|;
name|cbcp_NewPhase
argument_list|(
name|cbcp
argument_list|,
name|CBCP_CLOSED
argument_list|)
expr_stmt|;
name|cbcp
operator|->
name|required
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cbcp_ReceiveTerminateReq
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|dl
operator|->
name|cbcp
operator|.
name|fsm
operator|.
name|state
operator|==
name|CBCP_ACKSENT
condition|)
block|{
comment|/* Don't change our state in case the peer doesn't get the ACK */
name|p
operator|->
name|dl
operator|->
name|cbcp
operator|.
name|required
operator|=
literal|1
expr_stmt|;
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"%s: CBCP: Will dial back on %s\n"
argument_list|,
name|p
operator|->
name|dl
operator|->
name|name
argument_list|,
name|p
operator|->
name|dl
operator|->
name|cbcp
operator|.
name|fsm
operator|.
name|phone
argument_list|)
expr_stmt|;
block|}
else|else
name|cbcp_NewPhase
argument_list|(
operator|&
name|p
operator|->
name|dl
operator|->
name|cbcp
argument_list|,
name|CBCP_CLOSED
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

