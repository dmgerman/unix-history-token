begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *		PPP Timer Processing Module  *  *	    Written by Toshiharu OHNO (tony-o@iij.ad.jp)  *  *   Copyright (C) 1993, Internet Initiative Japan, Inc. All rights reserverd.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the Internet Initiative Japan, Inc.  The name of the  * IIJ may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * $Id: timer.c,v 1.32 1998/12/14 19:24:29 brian Exp $  *  *  TODO:  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"sig.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"descriptor.h"
end_include

begin_include
include|#
directive|include
file|"prompt.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|pppTimer
modifier|*
name|TimerList
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|StopTimerNoBlock
parameter_list|(
name|struct
name|pppTimer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tState2Nam
parameter_list|(
name|u_int
name|state
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|StateNames
index|[]
init|=
block|{
literal|"stopped"
block|,
literal|"running"
block|,
literal|"expired"
block|}
decl_stmt|;
if|if
condition|(
name|state
operator|>=
sizeof|sizeof
name|StateNames
operator|/
sizeof|sizeof
name|StateNames
index|[
literal|0
index|]
condition|)
return|return
literal|"unknown"
return|;
return|return
name|StateNames
index|[
name|state
index|]
return|;
block|}
end_function

begin_function
name|void
name|timer_Stop
parameter_list|(
name|struct
name|pppTimer
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|omask
decl_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
argument_list|)
expr_stmt|;
name|StopTimerNoBlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|timer_Start
parameter_list|(
name|struct
name|pppTimer
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|pppTimer
modifier|*
name|t
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
name|u_long
name|ticks
init|=
literal|0
decl_stmt|;
name|int
name|omask
decl_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|state
operator|!=
name|TIMER_STOPPED
condition|)
name|StopTimerNoBlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|load
operator|==
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"%s timer[%p] has 0 load!\n"
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
return|return;
block|}
name|pt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TimerList
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ticks
operator|+
name|t
operator|->
name|rest
operator|>=
name|tp
operator|->
name|load
condition|)
break|break;
name|ticks
operator|+=
name|t
operator|->
name|rest
expr_stmt|;
name|pt
operator|=
name|t
expr_stmt|;
block|}
name|tp
operator|->
name|state
operator|=
name|TIMER_RUNNING
expr_stmt|;
name|tp
operator|->
name|rest
operator|=
name|tp
operator|->
name|load
operator|-
name|ticks
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"timer_Start: Inserting %s timer[%p] before %s "
literal|"timer[%p], delta = %ld\n"
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|tp
argument_list|,
name|t
operator|->
name|name
argument_list|,
name|t
argument_list|,
name|tp
operator|->
name|rest
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"timer_Start: Inserting %s timer[%p]\n"
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* Insert given *tp just before *t */
name|tp
operator|->
name|next
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|pt
condition|)
block|{
name|pt
operator|->
name|next
operator|=
name|tp
expr_stmt|;
block|}
else|else
block|{
name|TimerList
operator|=
name|tp
expr_stmt|;
name|timer_InitService
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Start the Timer Service */
block|}
if|if
condition|(
name|t
condition|)
name|t
operator|->
name|rest
operator|-=
name|tp
operator|->
name|rest
expr_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|StopTimerNoBlock
parameter_list|(
name|struct
name|pppTimer
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|pppTimer
modifier|*
name|t
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
comment|/*    * A RUNNING timer must be removed from TimerList (->next list).    * A STOPPED timer isn't in any list, but may have a bogus [e]next field.    * An EXPIRED timer is in the ->enext list.    */
if|if
condition|(
name|tp
operator|->
name|state
operator|!=
name|TIMER_RUNNING
condition|)
block|{
name|tp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|state
operator|=
name|TIMER_STOPPED
expr_stmt|;
return|return;
block|}
name|pt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TimerList
init|;
name|t
operator|!=
name|tp
operator|&&
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
name|pt
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|pt
condition|)
block|{
name|pt
operator|->
name|next
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|TimerList
operator|=
name|t
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|TimerList
operator|==
name|NULL
condition|)
comment|/* Last one ? */
name|timer_TermService
argument_list|()
expr_stmt|;
comment|/* Terminate Timer Service */
block|}
if|if
condition|(
name|t
operator|->
name|next
condition|)
name|t
operator|->
name|next
operator|->
name|rest
operator|+=
name|tp
operator|->
name|rest
expr_stmt|;
block|}
else|else
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Oops, %s timer not found!!\n"
argument_list|,
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
name|tp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|state
operator|=
name|TIMER_STOPPED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|TimerService
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pppTimer
modifier|*
name|tp
decl_stmt|,
modifier|*
name|exp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|log_IsKept
argument_list|(
name|LogTIMER
argument_list|)
condition|)
block|{
specifier|static
name|time_t
name|t
decl_stmt|;
comment|/* Only show timers globally every second */
name|time_t
name|n
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|t
condition|)
name|timer_Show
argument_list|(
name|LogTIMER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|n
expr_stmt|;
block|}
name|tp
operator|=
name|TimerList
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
name|tp
operator|->
name|rest
operator|=
literal|0
expr_stmt|;
comment|/* Multiple timers might expire at once. Create a list of expired timers */
name|exp
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|tp
operator|->
name|state
operator|=
name|TIMER_EXPIRED
expr_stmt|;
name|next
operator|=
name|tp
operator|->
name|next
expr_stmt|;
name|tp
operator|->
name|enext
operator|=
name|exp
expr_stmt|;
name|exp
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|tp
operator|&&
name|tp
operator|->
name|rest
operator|==
literal|0
condition|)
do|;
name|TimerList
operator|=
name|tp
expr_stmt|;
if|if
condition|(
name|TimerList
operator|!=
name|NULL
condition|)
comment|/* Any timers remaining ? */
name|timer_InitService
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Restart the Timer Service */
else|else
name|timer_TermService
argument_list|()
expr_stmt|;
comment|/* Stop the Timer Service */
comment|/* Process all expired timers */
while|while
condition|(
name|exp
condition|)
block|{
name|next
operator|=
name|exp
operator|->
name|enext
expr_stmt|;
name|exp
operator|->
name|enext
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|func
condition|)
call|(
modifier|*
name|exp
operator|->
name|func
call|)
argument_list|(
name|exp
operator|->
name|arg
argument_list|)
expr_stmt|;
name|exp
operator|=
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|timer_Show
parameter_list|(
name|int
name|LogLevel
parameter_list|,
name|struct
name|prompt
modifier|*
name|prompt
parameter_list|)
block|{
name|struct
name|itimerval
name|itimer
decl_stmt|;
name|struct
name|pppTimer
modifier|*
name|pt
decl_stmt|;
name|u_long
name|rest
init|=
literal|0
decl_stmt|;
comment|/* Adjust our first delta so that it reflects what's really happening */
if|if
condition|(
name|TimerList
operator|&&
name|getitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|)
operator|==
literal|0
condition|)
name|TimerList
operator|->
name|rest
operator|=
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|*
name|SECTICKS
operator|+
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|/
name|TICKUNIT
expr_stmt|;
define|#
directive|define
name|SECS
parameter_list|(
name|val
parameter_list|)
value|((val) / SECTICKS)
define|#
directive|define
name|HSECS
parameter_list|(
name|val
parameter_list|)
value|(((val) % SECTICKS) * 100 / SECTICKS)
define|#
directive|define
name|DISP
define|\
value|"%s timer[%p]: freq = %ld.%02lds, next = %lu.%02lus, state = %s\n",	\   pt->name, pt, SECS(pt->load), HSECS(pt->load), SECS(rest),		\   HSECS(rest), tState2Nam(pt->state)
if|if
condition|(
operator|!
name|prompt
condition|)
name|log_Printf
argument_list|(
name|LogLevel
argument_list|,
literal|"---- Begin of Timer Service List---\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|pt
operator|=
name|TimerList
init|;
name|pt
condition|;
name|pt
operator|=
name|pt
operator|->
name|next
control|)
block|{
name|rest
operator|+=
name|pt
operator|->
name|rest
expr_stmt|;
if|if
condition|(
name|prompt
condition|)
name|prompt_Printf
argument_list|(
name|prompt
argument_list|,
name|DISP
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogLevel
argument_list|,
name|DISP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prompt
condition|)
name|log_Printf
argument_list|(
name|LogLevel
argument_list|,
literal|"---- End of Timer Service List ---\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|timer_InitService
parameter_list|(
name|int
name|restart
parameter_list|)
block|{
name|struct
name|itimerval
name|itimer
decl_stmt|;
if|if
condition|(
name|TimerList
condition|)
block|{
if|if
condition|(
operator|!
name|restart
condition|)
name|sig_signal
argument_list|(
name|SIGALRM
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|TimerService
argument_list|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|TimerList
operator|->
name|rest
operator|/
name|SECTICKS
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
operator|(
name|TimerList
operator|->
name|rest
operator|%
name|SECTICKS
operator|)
operator|*
name|TICKUNIT
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Unable to set itimer (%s)\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|timer_TermService
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|itimerval
name|itimer
decl_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Unable to set itimer (%s)\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sig_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

