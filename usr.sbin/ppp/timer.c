begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996 - 2001 Brian Somers<brian@Awfulhak.org>  *          based on work by Toshiharu OHNO<tony-o@iij.ad.jp>  *                           Internet Initiative Japan, Inc (IIJ)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"sig.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"descriptor.h"
end_include

begin_include
include|#
directive|include
file|"prompt.h"
end_include

begin_define
define|#
directive|define
name|RESTVAL
parameter_list|(
name|t
parameter_list|)
define|\
value|((t).it_value.tv_sec * SECTICKS + (t).it_value.tv_usec / TICKUNIT + \      ((((t).it_value.tv_usec % TICKUNIT)>= (TICKUNIT>> 1)) ? 1 : 0))
end_define

begin_decl_stmt
specifier|static
name|struct
name|pppTimer
modifier|*
name|TimerList
init|=
name|NULL
decl_stmt|,
modifier|*
name|ExpiredList
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|StopTimerNoBlock
parameter_list|(
name|struct
name|pppTimer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tState2Nam
parameter_list|(
name|u_int
name|state
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|StateNames
index|[]
init|=
block|{
literal|"stopped"
block|,
literal|"running"
block|,
literal|"expired"
block|}
decl_stmt|;
if|if
condition|(
name|state
operator|>=
sizeof|sizeof
name|StateNames
operator|/
sizeof|sizeof
name|StateNames
index|[
literal|0
index|]
condition|)
return|return
literal|"unknown"
return|;
return|return
name|StateNames
index|[
name|state
index|]
return|;
block|}
end_function

begin_function
name|void
name|timer_Stop
parameter_list|(
name|struct
name|pppTimer
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|omask
decl_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
argument_list|)
expr_stmt|;
name|StopTimerNoBlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|timer_Start
parameter_list|(
name|struct
name|pppTimer
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|itimerval
name|itimer
decl_stmt|;
name|struct
name|pppTimer
modifier|*
name|t
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
name|u_long
name|ticks
init|=
literal|0
decl_stmt|;
name|int
name|omask
decl_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGALRM
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|state
operator|!=
name|TIMER_STOPPED
condition|)
name|StopTimerNoBlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|load
operator|==
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"%s timer[%p] has 0 load!\n"
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Adjust our first delta so that it reflects what's really happening */
if|if
condition|(
name|TimerList
operator|&&
name|getitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|)
operator|==
literal|0
condition|)
name|TimerList
operator|->
name|rest
operator|=
name|RESTVAL
argument_list|(
name|itimer
argument_list|)
expr_stmt|;
name|pt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TimerList
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ticks
operator|+
name|t
operator|->
name|rest
operator|>=
name|tp
operator|->
name|load
condition|)
break|break;
name|ticks
operator|+=
name|t
operator|->
name|rest
expr_stmt|;
name|pt
operator|=
name|t
expr_stmt|;
block|}
name|tp
operator|->
name|state
operator|=
name|TIMER_RUNNING
expr_stmt|;
name|tp
operator|->
name|rest
operator|=
name|tp
operator|->
name|load
operator|-
name|ticks
expr_stmt|;
if|if
condition|(
name|t
condition|)
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"timer_Start: Inserting %s timer[%p] before %s "
literal|"timer[%p], delta = %ld\n"
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|tp
argument_list|,
name|t
operator|->
name|name
argument_list|,
name|t
argument_list|,
name|tp
operator|->
name|rest
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"timer_Start: Inserting %s timer[%p]\n"
argument_list|,
name|tp
operator|->
name|name
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* Insert given *tp just before *t */
name|tp
operator|->
name|next
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|pt
condition|)
block|{
name|pt
operator|->
name|next
operator|=
name|tp
expr_stmt|;
block|}
else|else
block|{
name|TimerList
operator|=
name|tp
expr_stmt|;
name|timer_InitService
argument_list|(
name|t
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* [re]Start the Timer Service */
block|}
if|if
condition|(
name|t
condition|)
name|t
operator|->
name|rest
operator|-=
name|tp
operator|->
name|rest
expr_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|StopTimerNoBlock
parameter_list|(
name|struct
name|pppTimer
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|pppTimer
modifier|*
name|t
decl_stmt|,
modifier|*
name|pt
decl_stmt|;
comment|/*    * A RUNNING timer must be removed from TimerList (->next list).    * A STOPPED timer isn't in any list, but may have a bogus [e]next field.    * An EXPIRED timer is in the ->enext list.    */
if|if
condition|(
name|tp
operator|->
name|state
operator|==
name|TIMER_STOPPED
condition|)
return|return;
name|pt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
name|TimerList
init|;
name|t
operator|!=
name|tp
operator|&&
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
name|pt
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|pt
condition|)
name|pt
operator|->
name|next
operator|=
name|t
operator|->
name|next
expr_stmt|;
else|else
block|{
name|TimerList
operator|=
name|t
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|TimerList
operator|==
name|NULL
condition|)
comment|/* Last one ? */
name|timer_TermService
argument_list|()
expr_stmt|;
comment|/* Terminate Timer Service */
block|}
if|if
condition|(
name|t
operator|->
name|next
condition|)
block|{
if|if
condition|(
operator|!
name|pt
condition|)
block|{
comment|/* t (tp) was the first in the list */
name|struct
name|itimerval
name|itimer
decl_stmt|;
if|if
condition|(
name|getitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|)
operator|==
literal|0
condition|)
name|t
operator|->
name|rest
operator|=
name|RESTVAL
argument_list|(
name|itimer
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|next
operator|->
name|rest
operator|+=
name|t
operator|->
name|rest
expr_stmt|;
if|if
condition|(
operator|!
name|pt
condition|)
comment|/* t->next is now the first in the list */
name|timer_InitService
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Search for any pending expired timers */
name|pt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
name|ExpiredList
init|;
name|t
operator|!=
name|tp
operator|&&
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|enext
control|)
name|pt
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
if|if
condition|(
name|pt
condition|)
name|pt
operator|->
name|enext
operator|=
name|t
operator|->
name|enext
expr_stmt|;
else|else
name|ExpiredList
operator|=
name|t
operator|->
name|enext
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|state
operator|==
name|TIMER_RUNNING
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Oops, %s timer not found!!\n"
argument_list|,
name|tp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|next
operator|=
name|tp
operator|->
name|enext
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|state
operator|=
name|TIMER_STOPPED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|TimerService
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pppTimer
modifier|*
name|tp
decl_stmt|,
modifier|*
name|exp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|log_IsKept
argument_list|(
name|LogTIMER
argument_list|)
condition|)
block|{
specifier|static
name|time_t
name|t
decl_stmt|;
comment|/* Only show timers globally every second */
name|time_t
name|n
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|t
condition|)
name|timer_Show
argument_list|(
name|LogTIMER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|t
operator|=
name|n
expr_stmt|;
block|}
name|tp
operator|=
name|TimerList
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
name|tp
operator|->
name|rest
operator|=
literal|0
expr_stmt|;
comment|/* Multiple timers might expire at once. Create a list of expired timers */
name|exp
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|tp
operator|->
name|state
operator|=
name|TIMER_EXPIRED
expr_stmt|;
name|next
operator|=
name|tp
operator|->
name|next
expr_stmt|;
name|tp
operator|->
name|enext
operator|=
name|exp
expr_stmt|;
name|exp
operator|=
name|tp
expr_stmt|;
name|tp
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|tp
operator|&&
name|tp
operator|->
name|rest
operator|==
literal|0
condition|)
do|;
name|TimerList
operator|=
name|tp
expr_stmt|;
if|if
condition|(
name|TimerList
operator|!=
name|NULL
condition|)
comment|/* Any timers remaining ? */
name|timer_InitService
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Restart the Timer Service */
else|else
name|timer_TermService
argument_list|()
expr_stmt|;
comment|/* Stop the Timer Service */
comment|/* Process all expired timers */
while|while
condition|(
name|exp
condition|)
block|{
name|ExpiredList
operator|=
name|exp
operator|->
name|enext
expr_stmt|;
name|exp
operator|->
name|enext
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|func
condition|)
call|(
modifier|*
name|exp
operator|->
name|func
call|)
argument_list|(
name|exp
operator|->
name|arg
argument_list|)
expr_stmt|;
name|exp
operator|=
name|ExpiredList
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|timer_Show
parameter_list|(
name|int
name|LogLevel
parameter_list|,
name|struct
name|prompt
modifier|*
name|prompt
parameter_list|)
block|{
name|struct
name|itimerval
name|itimer
decl_stmt|;
name|struct
name|pppTimer
modifier|*
name|pt
decl_stmt|;
name|u_long
name|rest
init|=
literal|0
decl_stmt|;
comment|/* Adjust our first delta so that it reflects what's really happening */
if|if
condition|(
name|TimerList
operator|&&
name|getitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|)
operator|==
literal|0
condition|)
name|TimerList
operator|->
name|rest
operator|=
name|RESTVAL
argument_list|(
name|itimer
argument_list|)
expr_stmt|;
define|#
directive|define
name|SECS
parameter_list|(
name|val
parameter_list|)
value|((val) / SECTICKS)
define|#
directive|define
name|HSECS
parameter_list|(
name|val
parameter_list|)
value|(((val) % SECTICKS) * 100 / SECTICKS)
define|#
directive|define
name|DISP
define|\
value|"%s timer[%p]: freq = %ld.%02lds, next = %lu.%02lus, state = %s\n",	\   pt->name, pt, SECS(pt->load), HSECS(pt->load), SECS(rest),		\   HSECS(rest), tState2Nam(pt->state)
if|if
condition|(
operator|!
name|prompt
condition|)
name|log_Printf
argument_list|(
name|LogLevel
argument_list|,
literal|"---- Begin of Timer Service List---\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|pt
operator|=
name|TimerList
init|;
name|pt
condition|;
name|pt
operator|=
name|pt
operator|->
name|next
control|)
block|{
name|rest
operator|+=
name|pt
operator|->
name|rest
expr_stmt|;
if|if
condition|(
name|prompt
condition|)
name|prompt_Printf
argument_list|(
name|prompt
argument_list|,
name|DISP
argument_list|)
expr_stmt|;
else|else
name|log_Printf
argument_list|(
name|LogLevel
argument_list|,
name|DISP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prompt
condition|)
name|log_Printf
argument_list|(
name|LogLevel
argument_list|,
literal|"---- End of Timer Service List ---\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|timer_InitService
parameter_list|(
name|int
name|restart
parameter_list|)
block|{
name|struct
name|itimerval
name|itimer
decl_stmt|;
if|if
condition|(
name|TimerList
condition|)
block|{
if|if
condition|(
operator|!
name|restart
condition|)
name|sig_signal
argument_list|(
name|SIGALRM
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|TimerService
argument_list|)
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|TimerList
operator|->
name|rest
operator|/
name|SECTICKS
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
operator|(
name|TimerList
operator|->
name|rest
operator|%
name|SECTICKS
operator|)
operator|*
name|TICKUNIT
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Unable to set itimer (%s)\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|timer_TermService
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|itimerval
name|itimer
decl_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itimer
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"Unable to set itimer (%s)\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sig_signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

