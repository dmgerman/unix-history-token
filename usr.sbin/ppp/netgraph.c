begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Brian Somers<brian@Awfulhak.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netgraph.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_ether.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_socket.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"layer.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"log.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"lqr.h"
end_include

begin_include
include|#
directive|include
file|"hdlc.h"
end_include

begin_include
include|#
directive|include
file|"throughput.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ccp.h"
end_include

begin_include
include|#
directive|include
file|"link.h"
end_include

begin_include
include|#
directive|include
file|"async.h"
end_include

begin_include
include|#
directive|include
file|"descriptor.h"
end_include

begin_include
include|#
directive|include
file|"physical.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"mp.h"
end_include

begin_include
include|#
directive|include
file|"chat.h"
end_include

begin_include
include|#
directive|include
file|"auth.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"cbcp.h"
end_include

begin_include
include|#
directive|include
file|"datalink.h"
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_include
include|#
directive|include
file|"iplist.h"
end_include

begin_include
include|#
directive|include
file|"ncpaddr.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"ipv6cp.h"
end_include

begin_include
include|#
directive|include
file|"ncp.h"
end_include

begin_include
include|#
directive|include
file|"filter.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NORADIUS
end_ifndef

begin_include
include|#
directive|include
file|"radius.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bundle.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"netgraph.h"
end_include

begin_struct
struct|struct
name|ngdevice
block|{
name|struct
name|device
name|dev
decl_stmt|;
comment|/* What struct physical knows about */
name|int
name|cs
decl_stmt|;
comment|/* Control socket */
name|char
name|hook
index|[
name|NG_HOOKLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Our socket node hook */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|device2ng
parameter_list|(
name|d
parameter_list|)
value|((d)->type == NG_DEVICE ? (struct ngdevice *)d : NULL)
end_define

begin_define
define|#
directive|define
name|NG_MSGBUFSZ
value|4096
end_define

begin_define
define|#
directive|define
name|NETGRAPH_PREFIX
value|"netgraph:"
end_define

begin_function
name|int
name|ng_DeviceSize
parameter_list|(
name|void
parameter_list|)
block|{
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|ngdevice
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_MessageOut
parameter_list|(
name|struct
name|ngdevice
modifier|*
name|dev
parameter_list|,
name|struct
name|physical
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|char
name|path
index|[
name|NG_PATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|pos
decl_stmt|,
name|dpos
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/*    * We expect a node path, one or more spaces, a command, one or more    * spaces and an ascii netgraph structure.    */
name|data
operator|+=
name|strspn
argument_list|(
name|data
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|data
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
name|path
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: %.*s: Node path too long\n"
argument_list|,
name|dev
operator|->
name|dev
operator|.
name|name
argument_list|,
name|len
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
name|path
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|data
operator|+=
name|len
expr_stmt|;
name|data
operator|+=
name|strspn
argument_list|(
name|data
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|data
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
for|for
control|(
name|pos
operator|=
name|len
init|;
name|pos
operator|>=
literal|0
condition|;
name|pos
operator|--
control|)
if|if
condition|(
name|data
index|[
name|pos
index|]
operator|==
literal|'%'
condition|)
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|fmt
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: alloca(%d) failure... %s\n"
argument_list|,
name|dev
operator|->
name|dev
operator|.
name|name
argument_list|,
name|len
operator|+
literal|4
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * This is probably a waste of time, but we really don't want to end    * up stuffing unexpected % escapes into the kernel....    */
for|for
control|(
name|pos
operator|=
name|dpos
operator|=
literal|0
init|;
name|pos
operator|<
name|len
condition|;
control|)
block|{
if|if
condition|(
name|data
index|[
name|dpos
index|]
operator|==
literal|'%'
condition|)
name|fmt
index|[
name|pos
operator|++
index|]
operator|=
literal|'%'
expr_stmt|;
name|fmt
index|[
name|pos
operator|++
index|]
operator|=
name|data
index|[
name|dpos
operator|++
index|]
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|fmt
operator|+
name|pos
argument_list|,
literal|" %s"
argument_list|)
expr_stmt|;
name|data
operator|+=
name|dpos
expr_stmt|;
name|data
operator|+=
name|strspn
argument_list|(
name|data
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendAsciiMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|path
argument_list|,
name|fmt
argument_list|,
name|data
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"%s: NgSendAsciiMsg (to %s): \"%s\", \"%s\": %s\n"
argument_list|,
name|dev
operator|->
name|dev
operator|.
name|name
argument_list|,
name|path
argument_list|,
name|fmt
argument_list|,
name|data
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Get a netgraph message  */
end_comment

begin_function
specifier|static
name|ssize_t
name|ng_MessageIn
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|char
name|msgbuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|*
literal|2
operator|+
name|NG_MSGBUFSZ
index|]
decl_stmt|;
name|struct
name|ngdevice
modifier|*
name|dev
init|=
name|device2ng
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|rep
init|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|msgbuf
decl_stmt|;
name|char
name|path
index|[
name|NG_PATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_SELECT
name|struct
name|timeval
name|t
decl_stmt|;
name|fd_set
modifier|*
name|r
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|cs
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|r
operator|=
name|mkfdset
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogERROR
argument_list|,
literal|"DoLoop: Cannot create fd_set\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|zerofdset
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|t
operator|.
name|tv_sec
operator|=
name|t
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|select
argument_list|(
name|dev
operator|->
name|cs
operator|+
literal|1
argument_list|,
name|r
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|NgRecvAsciiMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|rep
argument_list|,
sizeof|sizeof
name|msgbuf
argument_list|,
name|path
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: NgRecvAsciiMsg: %s\n"
argument_list|,
name|dev
operator|->
name|dev
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* XXX: Should we check rep->header.version ? */
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Unexpected message: %s\n"
argument_list|,
name|dev
operator|->
name|dev
operator|.
name|name
argument_list|,
name|rep
operator|->
name|header
operator|.
name|cmdstr
argument_list|)
expr_stmt|;
else|else
block|{
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"%s: Received message: %s\n"
argument_list|,
name|dev
operator|->
name|dev
operator|.
name|name
argument_list|,
name|rep
operator|->
name|header
operator|.
name|cmdstr
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|rep
operator|->
name|header
operator|.
name|cmdstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|len
condition|)
name|sz
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|rep
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
return|return
name|sz
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|ng_Write
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|v
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|struct
name|ngdevice
modifier|*
name|dev
init|=
name|device2ng
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|dl
operator|->
name|state
condition|)
block|{
case|case
name|DATALINK_DIAL
case|:
case|case
name|DATALINK_LOGIN
case|:
return|return
name|ng_MessageOut
argument_list|(
name|dev
argument_list|,
name|p
argument_list|,
name|v
argument_list|)
condition|?
name|n
else|:
operator|-
literal|1
return|;
block|}
return|return
name|NgSendData
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|dev
operator|->
name|hook
argument_list|,
name|v
argument_list|,
name|n
argument_list|)
operator|==
operator|-
literal|1
condition|?
operator|-
literal|1
else|:
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|ng_Read
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|v
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|char
name|hook
index|[
name|NG_HOOKLEN
operator|+
literal|1
index|]
decl_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"ng_Read\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|dl
operator|->
name|state
condition|)
block|{
case|case
name|DATALINK_DIAL
case|:
case|case
name|DATALINK_LOGIN
case|:
return|return
name|ng_MessageIn
argument_list|(
name|p
argument_list|,
name|v
argument_list|,
name|n
argument_list|)
return|;
block|}
return|return
name|NgRecvData
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|v
argument_list|,
name|n
argument_list|,
name|hook
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_RemoveFromSet
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|,
name|fd_set
modifier|*
name|r
parameter_list|,
name|fd_set
modifier|*
name|w
parameter_list|,
name|fd_set
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|ngdevice
modifier|*
name|dev
init|=
name|device2ng
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
if|if
condition|(
name|r
operator|&&
name|dev
operator|->
name|cs
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|FD_CLR
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"%s: fdunset(ctrl) %d\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|dev
operator|->
name|cs
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|result
operator|=
literal|0
expr_stmt|;
comment|/* Careful... physical_RemoveFromSet() called us ! */
name|p
operator|->
name|handler
operator|->
name|removefromset
operator|=
name|NULL
expr_stmt|;
name|result
operator|+=
name|physical_RemoveFromSet
argument_list|(
name|p
argument_list|,
name|r
argument_list|,
name|w
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|p
operator|->
name|handler
operator|->
name|removefromset
operator|=
name|ng_RemoveFromSet
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ng_Free
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngdevice
modifier|*
name|dev
init|=
name|device2ng
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
name|physical_SetDescriptor
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|cs
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|dev
operator|->
name|cs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ng_device2iov
parameter_list|(
name|struct
name|device
modifier|*
name|d
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|int
modifier|*
name|niov
parameter_list|,
name|int
name|maxiov
parameter_list|,
name|int
modifier|*
name|auxfd
parameter_list|,
name|int
modifier|*
name|nauxfd
parameter_list|)
block|{
name|struct
name|ngdevice
modifier|*
name|dev
init|=
name|device2ng
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|int
name|sz
init|=
name|physical_MaxDeviceSize
argument_list|()
decl_stmt|;
name|iov
index|[
operator|*
name|niov
index|]
operator|.
name|iov_base
operator|=
name|realloc
argument_list|(
name|d
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|iov
index|[
operator|*
name|niov
index|]
operator|.
name|iov_base
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"Failed to allocate memory: %d\n"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|AbortProgram
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
name|iov
index|[
operator|*
name|niov
index|]
operator|.
name|iov_len
operator|=
name|sz
expr_stmt|;
operator|(
operator|*
name|niov
operator|)
operator|++
expr_stmt|;
operator|*
name|auxfd
operator|=
name|dev
operator|->
name|cs
expr_stmt|;
operator|(
operator|*
name|nauxfd
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|device
name|basengdevice
init|=
block|{
name|NG_DEVICE
block|,
literal|"netgraph"
block|,
literal|0
block|,
block|{
name|CD_REQUIRED
block|,
name|DEF_NGCDDELAY
block|}
block|,
name|NULL
block|,
name|ng_RemoveFromSet
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_Free
block|,
name|ng_Read
block|,
name|ng_Write
block|,
name|ng_device2iov
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|device
modifier|*
name|ng_iov2device
parameter_list|(
name|int
name|type
parameter_list|,
name|struct
name|physical
modifier|*
name|p
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|int
modifier|*
name|niov
parameter_list|,
name|int
name|maxiov
parameter_list|,
name|int
modifier|*
name|auxfd
parameter_list|,
name|int
modifier|*
name|nauxfd
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NG_DEVICE
condition|)
block|{
name|struct
name|ngdevice
modifier|*
name|dev
init|=
operator|(
expr|struct
name|ngdevice
operator|*
operator|)
name|iov
index|[
operator|(
operator|*
name|niov
operator|)
operator|++
index|]
operator|.
name|iov_base
decl_stmt|;
name|dev
operator|=
name|realloc
argument_list|(
name|dev
argument_list|,
sizeof|sizeof
expr|*
name|dev
argument_list|)
expr_stmt|;
comment|/* Reduce to the correct size */
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogALERT
argument_list|,
literal|"Failed to allocate memory: %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
expr|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|AbortProgram
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|nauxfd
condition|)
block|{
name|dev
operator|->
name|cs
operator|=
operator|*
name|auxfd
expr_stmt|;
operator|(
operator|*
name|nauxfd
operator|)
operator|--
expr_stmt|;
block|}
else|else
name|dev
operator|->
name|cs
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Refresh function pointers etc */
name|memcpy
argument_list|(
operator|&
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|basengdevice
argument_list|,
sizeof|sizeof
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* XXX: Are netgraph always synchronous ? */
name|physical_SetupStack
argument_list|(
name|p
argument_list|,
name|dev
operator|->
name|dev
operator|.
name|name
argument_list|,
name|PHYSICAL_FORCE_SYNCNOACF
argument_list|)
expr_stmt|;
return|return
operator|&
name|dev
operator|->
name|dev
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_UpdateSet
parameter_list|(
name|struct
name|fdescriptor
modifier|*
name|d
parameter_list|,
name|fd_set
modifier|*
name|r
parameter_list|,
name|fd_set
modifier|*
name|w
parameter_list|,
name|fd_set
modifier|*
name|e
parameter_list|,
name|int
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|physical
modifier|*
name|p
init|=
name|descriptor2physical
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|ngdevice
modifier|*
name|dev
init|=
name|device2ng
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|dl
operator|->
name|state
condition|)
block|{
case|case
name|DATALINK_DIAL
case|:
case|case
name|DATALINK_LOGIN
case|:
if|if
condition|(
name|r
condition|)
block|{
name|FD_SET
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogTIMER
argument_list|,
literal|"%s(ctrl): fdset(r) %d\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|dev
operator|->
name|cs
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|result
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|physical_doUpdateSet
argument_list|(
name|d
argument_list|,
name|r
argument_list|,
name|w
argument_list|,
name|e
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_IsSet
parameter_list|(
name|struct
name|fdescriptor
modifier|*
name|d
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|physical
modifier|*
name|p
init|=
name|descriptor2physical
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|ngdevice
modifier|*
name|dev
init|=
name|device2ng
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
name|int
name|result
decl_stmt|;
name|result
operator|=
name|dev
operator|->
name|cs
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
name|result
operator|+=
name|physical_IsSet
argument_list|(
name|d
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ng_DescriptorRead
parameter_list|(
name|struct
name|fdescriptor
modifier|*
name|d
parameter_list|,
name|struct
name|bundle
modifier|*
name|bundle
parameter_list|,
specifier|const
name|fd_set
modifier|*
name|fdset
parameter_list|)
block|{
name|struct
name|physical
modifier|*
name|p
init|=
name|descriptor2physical
argument_list|(
name|d
argument_list|)
decl_stmt|;
name|struct
name|ngdevice
modifier|*
name|dev
init|=
name|device2ng
argument_list|(
name|p
operator|->
name|handler
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|cs
operator|>=
literal|0
operator|&&
name|FD_ISSET
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|fdset
argument_list|)
condition|)
name|ng_MessageIn
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|physical_IsSet
argument_list|(
name|d
argument_list|,
name|fdset
argument_list|)
condition|)
name|physical_DescriptorRead
argument_list|(
name|d
argument_list|,
name|bundle
argument_list|,
name|fdset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|device
modifier|*
name|ng_Abandon
parameter_list|(
name|struct
name|ngdevice
modifier|*
name|dev
parameter_list|,
name|struct
name|physical
modifier|*
name|p
parameter_list|)
block|{
comment|/* Abandon our node construction */
name|close
argument_list|(
name|dev
operator|->
name|cs
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p
operator|->
name|fd
argument_list|)
expr_stmt|;
name|p
operator|->
name|fd
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Nobody else need try.. */
name|free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Populate the ``word'' (of size ``sz'') named ``what'' from ``from''  * ending with any character from ``sep''.  Point ``endp'' at the next  * word.  */
end_comment

begin_define
define|#
directive|define
name|GETSEGMENT
parameter_list|(
name|what
parameter_list|,
name|from
parameter_list|,
name|sep
parameter_list|,
name|endp
parameter_list|)
define|\
value|getsegment(#what, (what), sizeof(what), from, sep, endp)
end_define

begin_function
specifier|static
name|int
name|getsegment
parameter_list|(
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|char
modifier|*
name|word
parameter_list|,
name|size_t
name|sz
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
specifier|const
name|char
modifier|*
name|sep
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|endp
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|strcspn
argument_list|(
name|from
argument_list|,
name|sep
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s name should not be empty !\n"
argument_list|,
name|what
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|len
operator|>=
name|sz
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s name too long, max %d !\n"
argument_list|,
name|what
argument_list|,
name|sz
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|strncpy
argument_list|(
name|word
argument_list|,
name|from
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|word
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|endp
operator|=
name|from
operator|+
name|len
expr_stmt|;
operator|*
name|endp
operator|+=
name|strspn
argument_list|(
operator|*
name|endp
argument_list|,
name|sep
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|device
modifier|*
name|ng_Create
parameter_list|(
name|struct
name|physical
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sockaddr_ng
name|ngsock
decl_stmt|;
name|u_char
name|rbuf
index|[
literal|2048
index|]
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sock
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ngsock
decl_stmt|;
specifier|const
name|struct
name|hooklist
modifier|*
name|hlist
decl_stmt|;
specifier|const
name|struct
name|nodeinfo
modifier|*
name|ninfo
decl_stmt|;
specifier|const
name|struct
name|linkinfo
modifier|*
name|nlink
decl_stmt|;
name|struct
name|ngdevice
modifier|*
name|dev
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
decl_stmt|;
name|struct
name|ngm_mkpeer
name|mkp
decl_stmt|;
name|struct
name|ngm_connect
name|ngc
decl_stmt|;
specifier|const
name|char
modifier|*
name|devp
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|char
name|lasthook
index|[
name|NG_HOOKLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|hook
index|[
name|NG_HOOKLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|nodetype
index|[
name|NG_TYPELEN
operator|+
name|NG_NODELEN
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|modname
index|[
name|NG_TYPELEN
operator|+
literal|4
index|]
decl_stmt|;
name|char
name|path
index|[
name|NG_PATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|;
name|int
name|len
decl_stmt|,
name|sz
decl_stmt|,
name|done
decl_stmt|,
name|f
decl_stmt|;
name|dev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fd
operator|<
literal|0
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|p
operator|->
name|name
operator|.
name|full
argument_list|,
name|NETGRAPH_PREFIX
argument_list|,
sizeof|sizeof
name|NETGRAPH_PREFIX
operator|-
literal|1
argument_list|)
condition|)
block|{
name|p
operator|->
name|fd
operator|--
expr_stmt|;
comment|/* We own the device - change fd */
if|if
condition|(
operator|(
name|dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|loadmodules
argument_list|(
name|LOAD_VERBOSLY
argument_list|,
literal|"netgraph"
argument_list|,
literal|"ng_socket"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create a socket node */
if|if
condition|(
name|ID0NgMkSockNode
argument_list|(
name|NULL
argument_list|,
operator|&
name|dev
operator|->
name|cs
argument_list|,
operator|&
name|p
operator|->
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Cannot create netgraph socket node: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|p
operator|->
name|fd
operator|=
operator|-
literal|2
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|devp
operator|=
name|p
operator|->
name|name
operator|.
name|full
operator|+
sizeof|sizeof
name|NETGRAPH_PREFIX
operator|-
literal|1
expr_stmt|;
operator|*
name|lasthook
operator|=
operator|*
name|path
operator|=
literal|'\0'
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"%s: Opening netgraph device \"%s\"\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|devp
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|devp
operator|!=
literal|'\0'
operator|&&
operator|!
name|done
condition|)
block|{
if|if
condition|(
operator|*
name|devp
operator|!=
literal|'['
condition|)
block|{
if|if
condition|(
operator|*
name|lasthook
operator|==
literal|'\0'
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Netgraph devices must start with"
literal|" [nodetype:nodename]\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
comment|/* Get the hook name of the new node */
if|if
condition|(
operator|!
name|GETSEGMENT
argument_list|(
name|hook
argument_list|,
name|devp
argument_list|,
literal|".["
argument_list|,
operator|&
name|endp
argument_list|)
condition|)
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"%s: Got hook \"%s\"\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|devp
operator|=
name|endp
expr_stmt|;
if|if
condition|(
operator|*
name|devp
operator|==
literal|'\0'
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Netgraph device must not end with a second"
literal|" hook\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
if|if
condition|(
name|devp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'['
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Expected a [nodetype:nodename] at device"
literal|" pos %d\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|devp
operator|-
name|p
operator|->
name|link
operator|.
name|name
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* Use lasthook as the hook name */
name|strcpy
argument_list|(
name|hook
argument_list|,
name|lasthook
argument_list|)
expr_stmt|;
name|devp
operator|++
expr_stmt|;
block|}
comment|/* We've got ``lasthook'' and ``hook'', get the node type */
if|if
condition|(
operator|!
name|GETSEGMENT
argument_list|(
name|nodetype
argument_list|,
name|devp
argument_list|,
literal|"]"
argument_list|,
operator|&
name|endp
argument_list|)
condition|)
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"%s: Got node \"%s\"\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|nodetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nodename
operator|=
name|strchr
argument_list|(
name|nodetype
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|nodename
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|nodename
operator|==
literal|'\0'
operator|&&
operator|*
name|nodetype
operator|==
literal|'\0'
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Empty [nodetype:nodename] at device"
literal|" pos %d\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|devp
operator|-
name|p
operator|->
name|link
operator|.
name|name
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
block|}
comment|/* Ignore optional colons after nodes */
name|devp
operator|=
operator|*
name|endp
operator|==
literal|':'
condition|?
name|endp
operator|+
literal|1
else|:
name|endp
expr_stmt|;
if|if
condition|(
operator|*
name|devp
operator|==
literal|'.'
condition|)
name|devp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|lasthook
operator|==
literal|'\0'
condition|)
block|{
comment|/* This is the first node in the chain */
if|if
condition|(
name|nodename
operator|==
name|NULL
operator|||
operator|*
name|nodename
operator|==
literal|'\0'
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: %s: No initial device nodename\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|devp
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
if|if
condition|(
operator|*
name|nodetype
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Attempt to load the module */
name|snprintf
argument_list|(
name|modname
argument_list|,
sizeof|sizeof
name|modname
argument_list|,
literal|"ng_%s"
argument_list|,
name|nodetype
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"%s: Attempting to load %s.ko\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|modname
argument_list|)
expr_stmt|;
name|loadmodules
argument_list|(
name|LOAD_QUIETLY
argument_list|,
name|modname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
name|path
argument_list|,
literal|"%s:"
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
comment|/* XXX: If we have a node type, ensure it's correct */
block|}
else|else
block|{
comment|/*          * Ask for a list of hooks attached to the previous node.  If we          * find the one we're interested in, and if it's connected to a          * node of the right type using the correct hook, use that.          * If we find the hook connected to something else, fail.          * If we find no match, mkpeer the new node.          */
if|if
condition|(
operator|*
name|nodetype
operator|==
literal|'\0'
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Nodetype missing at device offset %d\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|devp
operator|-
name|p
operator|->
name|name
operator|.
name|full
operator|+
sizeof|sizeof
name|NETGRAPH_PREFIX
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
comment|/* Get a list of node hooks */
if|if
condition|(
name|NgSendMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|path
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NGM_LISTHOOKS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: %s Cannot send a LISTHOOOKS message: %s\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
comment|/* Get our list back */
name|resp
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|rbuf
expr_stmt|;
if|if
condition|(
name|NgRecvMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|resp
argument_list|,
sizeof|sizeof
name|rbuf
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Cannot get netgraph response: %s\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
name|hlist
operator|=
operator|(
specifier|const
expr|struct
name|hooklist
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|ninfo
operator|=
operator|&
name|hlist
operator|->
name|nodeinfo
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"List of netgraph node ``%s'' (id %x) hooks:\n"
argument_list|,
name|path
argument_list|,
name|ninfo
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* look for a hook already attached.  */
for|for
control|(
name|f
operator|=
literal|0
init|;
name|f
operator|<
name|ninfo
operator|->
name|hooks
condition|;
name|f
operator|++
control|)
block|{
name|nlink
operator|=
operator|&
name|hlist
operator|->
name|link
index|[
name|f
index|]
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"  Found %s -> %s (type %s)\n"
argument_list|,
name|nlink
operator|->
name|ourhook
argument_list|,
name|nlink
operator|->
name|peerhook
argument_list|,
name|nlink
operator|->
name|nodeinfo
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|nlink
operator|->
name|ourhook
argument_list|,
name|lasthook
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|nlink
operator|->
name|peerhook
argument_list|,
name|hook
argument_list|)
operator|||
name|strcmp
argument_list|(
name|nlink
operator|->
name|nodeinfo
operator|.
name|type
argument_list|,
name|nodetype
argument_list|)
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: hook %s:%s is already in use\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|nlink
operator|->
name|ourhook
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
comment|/* The node is already hooked up nicely.... reuse it */
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|==
name|ninfo
operator|->
name|hooks
condition|)
block|{
comment|/* Attempt to load the module */
name|snprintf
argument_list|(
name|modname
argument_list|,
sizeof|sizeof
name|modname
argument_list|,
literal|"ng_%s"
argument_list|,
name|nodetype
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"%s: Attempting to load %s.ko\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|modname
argument_list|)
expr_stmt|;
name|loadmodules
argument_list|(
name|LOAD_QUIETLY
argument_list|,
name|modname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create (mkpeer) the new node */
name|snprintf
argument_list|(
name|mkp
operator|.
name|type
argument_list|,
sizeof|sizeof
name|mkp
operator|.
name|type
argument_list|,
literal|"%s"
argument_list|,
name|nodetype
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|mkp
operator|.
name|ourhook
argument_list|,
sizeof|sizeof
name|mkp
operator|.
name|ourhook
argument_list|,
literal|"%s"
argument_list|,
name|lasthook
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|mkp
operator|.
name|peerhook
argument_list|,
sizeof|sizeof
name|mkp
operator|.
name|peerhook
argument_list|,
literal|"%s"
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"%s: Doing MKPEER %s%s -> %s (type %s)\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|path
argument_list|,
name|mkp
operator|.
name|ourhook
argument_list|,
name|mkp
operator|.
name|peerhook
argument_list|,
name|nodetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|path
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NGM_MKPEER
argument_list|,
operator|&
name|mkp
argument_list|,
sizeof|sizeof
name|mkp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s Cannot create %s netgraph node: %s\n"
argument_list|,
name|path
argument_list|,
name|nodetype
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
block|}
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|path
operator|+
name|len
argument_list|,
sizeof|sizeof
name|path
operator|-
name|len
argument_list|,
literal|"%s%s"
argument_list|,
name|path
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|':'
condition|?
literal|""
else|:
literal|"."
argument_list|,
name|lasthook
argument_list|)
expr_stmt|;
block|}
comment|/* Get a list of node hooks */
if|if
condition|(
name|NgSendMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|path
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NGM_LISTHOOKS
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: %s Cannot send a LISTHOOOKS message: %s\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
comment|/* Get our list back */
name|resp
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|rbuf
expr_stmt|;
if|if
condition|(
name|NgRecvMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|resp
argument_list|,
sizeof|sizeof
name|rbuf
argument_list|,
name|NULL
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Cannot get netgraph response: %s\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
name|hlist
operator|=
operator|(
specifier|const
expr|struct
name|hooklist
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|ninfo
operator|=
operator|&
name|hlist
operator|->
name|nodeinfo
expr_stmt|;
if|if
condition|(
operator|*
name|lasthook
operator|!=
literal|'\0'
operator|&&
name|nodename
operator|!=
name|NULL
operator|&&
operator|*
name|nodename
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|ninfo
operator|->
name|name
argument_list|,
name|nodename
argument_list|)
operator|&&
name|NgNameNode
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
name|path
argument_list|,
literal|"%s"
argument_list|,
name|nodename
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: %s: Cannot name netgraph node: %s\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|GETSEGMENT
argument_list|(
name|lasthook
argument_list|,
name|devp
argument_list|,
literal|" \t.["
argument_list|,
operator|&
name|endp
argument_list|)
condition|)
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"%s: Got hook \"%s\"\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|lasthook
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|lasthook
argument_list|)
expr_stmt|;
name|done
operator|=
name|strchr
argument_list|(
literal|" \t"
argument_list|,
name|devp
index|[
name|len
index|]
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|devp
operator|=
name|endp
expr_stmt|;
if|if
condition|(
operator|*
name|devp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|devp
index|[
operator|-
literal|1
index|]
operator|==
literal|'['
condition|)
name|devp
operator|--
expr_stmt|;
block|}
comment|/* else should moan about devp[-1] being '[' ? */
block|}
name|snprintf
argument_list|(
name|dev
operator|->
name|hook
argument_list|,
sizeof|sizeof
name|dev
operator|->
name|hook
argument_list|,
literal|"%s"
argument_list|,
name|lasthook
argument_list|)
expr_stmt|;
comment|/* Connect the node to our socket node */
name|snprintf
argument_list|(
name|ngc
operator|.
name|path
argument_list|,
sizeof|sizeof
name|ngc
operator|.
name|path
argument_list|,
literal|"%s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|ngc
operator|.
name|ourhook
argument_list|,
sizeof|sizeof
name|ngc
operator|.
name|ourhook
argument_list|,
literal|"%s"
argument_list|,
name|dev
operator|->
name|hook
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ngc
operator|.
name|peerhook
argument_list|,
name|ngc
operator|.
name|ourhook
argument_list|,
sizeof|sizeof
name|ngc
operator|.
name|peerhook
argument_list|)
expr_stmt|;
name|log_Printf
argument_list|(
name|LogDEBUG
argument_list|,
literal|"Connecting netgraph socket .:%s -> %s.%s\n"
argument_list|,
name|ngc
operator|.
name|ourhook
argument_list|,
name|ngc
operator|.
name|path
argument_list|,
name|ngc
operator|.
name|peerhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|NgSendMsg
argument_list|(
name|dev
operator|->
name|cs
argument_list|,
literal|".:"
argument_list|,
name|NGM_GENERIC_COOKIE
argument_list|,
name|NGM_CONNECT
argument_list|,
operator|&
name|ngc
argument_list|,
sizeof|sizeof
name|ngc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"Cannot connect %s and socket netgraph "
literal|"nodes: %s\n"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ng_Abandon
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
return|;
block|}
comment|/* Hook things up so that we monitor dev->cs */
name|p
operator|->
name|desc
operator|.
name|UpdateSet
operator|=
name|ng_UpdateSet
expr_stmt|;
name|p
operator|->
name|desc
operator|.
name|IsSet
operator|=
name|ng_IsSet
expr_stmt|;
name|p
operator|->
name|desc
operator|.
name|Read
operator|=
name|ng_DescriptorRead
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|basengdevice
argument_list|,
sizeof|sizeof
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* See if we're a netgraph socket */
name|sz
operator|=
sizeof|sizeof
name|ngsock
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|p
operator|->
name|fd
argument_list|,
name|sock
argument_list|,
operator|&
name|sz
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|sock
operator|->
name|sa_family
operator|==
name|AF_NETGRAPH
condition|)
block|{
comment|/*        * It's a netgraph node... We can't determine hook names etc, so we        * stay pretty impartial....        */
name|log_Printf
argument_list|(
name|LogPHASE
argument_list|,
literal|"%s: Link is a netgraph node\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log_Printf
argument_list|(
name|LogWARN
argument_list|,
literal|"%s: Cannot allocate an ether device: %s\n"
argument_list|,
name|p
operator|->
name|link
operator|.
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|basengdevice
argument_list|,
sizeof|sizeof
name|dev
operator|->
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|cs
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|dev
operator|->
name|hook
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dev
condition|)
block|{
name|physical_SetupStack
argument_list|(
name|p
argument_list|,
name|dev
operator|->
name|dev
operator|.
name|name
argument_list|,
name|PHYSICAL_FORCE_SYNCNOACF
argument_list|)
expr_stmt|;
return|return
operator|&
name|dev
operator|->
name|dev
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

