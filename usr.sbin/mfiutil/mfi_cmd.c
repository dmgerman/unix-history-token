begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008, 2009 Yahoo!, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The names of the authors may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"mfiutil.h"
end_include

begin_include
include|#
directive|include
file|<dev/mfi/mfi_ioctl.h>
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|mfi_status_codes
index|[]
init|=
block|{
literal|"Command completed successfully"
block|,
literal|"Invalid command"
block|,
literal|"Invalid DMCD opcode"
block|,
literal|"Invalid parameter"
block|,
literal|"Invalid Sequence Number"
block|,
literal|"Abort isn't possible for the requested command"
block|,
literal|"Application 'host' code not found"
block|,
literal|"Application in use"
block|,
literal|"Application not initialized"
block|,
literal|"Array index invalid"
block|,
literal|"Array row not empty"
block|,
literal|"Configuration resource conflict"
block|,
literal|"Device not found"
block|,
literal|"Drive too small"
block|,
literal|"Flash memory allocation failed"
block|,
literal|"Flash download already in progress"
block|,
literal|"Flash operation failed"
block|,
literal|"Bad flash image"
block|,
literal|"Incomplete flash image"
block|,
literal|"Flash not open"
block|,
literal|"Flash not started"
block|,
literal|"Flush failed"
block|,
literal|"Specified application doesn't have host-resident code"
block|,
literal|"Volume consistency check in progress"
block|,
literal|"Volume initialization in progress"
block|,
literal|"Volume LBA out of range"
block|,
literal|"Maximum number of volumes are already configured"
block|,
literal|"Volume is not OPTIMAL"
block|,
literal|"Volume rebuild in progress"
block|,
literal|"Volume reconstruction in progress"
block|,
literal|"Volume RAID level is wrong for requested operation"
block|,
literal|"Too many spares assigned"
block|,
literal|"Scratch memory not available"
block|,
literal|"Error writing MFC data to SEEPROM"
block|,
literal|"Required hardware is missing"
block|,
literal|"Item not found"
block|,
literal|"Volume drives are not within an enclosure"
block|,
literal|"Drive clear in progress"
block|,
literal|"Drive type mismatch (SATA vs SAS)"
block|,
literal|"Patrol read disabled"
block|,
literal|"Invalid row index"
block|,
literal|"SAS Config - Invalid action"
block|,
literal|"SAS Config - Invalid data"
block|,
literal|"SAS Config - Invalid page"
block|,
literal|"SAS Config - Invalid type"
block|,
literal|"SCSI command completed with error"
block|,
literal|"SCSI I/O request failed"
block|,
literal|"SCSI RESERVATION_CONFLICT"
block|,
literal|"One or more flush operations during shutdown failed"
block|,
literal|"Firmware time is not set"
block|,
literal|"Wrong firmware or drive state"
block|,
literal|"Volume is offline"
block|,
literal|"Peer controller rejected request"
block|,
literal|"Unable to inform peer of communication changes"
block|,
literal|"Volume reservation already in progress"
block|,
literal|"I2C errors were detected"
block|,
literal|"PCI errors occurred during XOR/DMA operation"
block|,
literal|"Diagnostics failed"
block|,
literal|"Unable to process command as boot messages are pending"
block|,
literal|"Foreign configuration is incomplete"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|mfi_status
parameter_list|(
name|u_int
name|status_code
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|status_code
operator|==
name|MFI_STAT_INVALID_STATUS
condition|)
return|return
operator|(
literal|"Invalid status"
operator|)
return|;
if|if
condition|(
name|status_code
operator|<
sizeof|sizeof
argument_list|(
name|mfi_status_codes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
return|return
operator|(
name|mfi_status_codes
index|[
name|status_code
index|]
operator|)
return|;
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"Status: 0x%02x"
argument_list|,
name|status_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|mfi_raid_level
parameter_list|(
name|uint8_t
name|primary_level
parameter_list|,
name|uint8_t
name|secondary_level
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
switch|switch
condition|(
name|primary_level
condition|)
block|{
case|case
name|DDF_RAID0
case|:
return|return
operator|(
literal|"RAID-0"
operator|)
return|;
case|case
name|DDF_RAID1
case|:
if|if
condition|(
name|secondary_level
operator|!=
literal|0
condition|)
return|return
operator|(
literal|"RAID-10"
operator|)
return|;
else|else
return|return
operator|(
literal|"RAID-1"
operator|)
return|;
case|case
name|DDF_RAID1E
case|:
return|return
operator|(
literal|"RAID-1E"
operator|)
return|;
case|case
name|DDF_RAID3
case|:
return|return
operator|(
literal|"RAID-3"
operator|)
return|;
case|case
name|DDF_RAID5
case|:
if|if
condition|(
name|secondary_level
operator|!=
literal|0
condition|)
return|return
operator|(
literal|"RAID-50"
operator|)
return|;
else|else
return|return
operator|(
literal|"RAID-5"
operator|)
return|;
case|case
name|DDF_RAID5E
case|:
return|return
operator|(
literal|"RAID-5E"
operator|)
return|;
case|case
name|DDF_RAID5EE
case|:
return|return
operator|(
literal|"RAID-5EE"
operator|)
return|;
case|case
name|DDF_RAID6
case|:
if|if
condition|(
name|secondary_level
operator|!=
literal|0
condition|)
return|return
operator|(
literal|"RAID-60"
operator|)
return|;
else|else
return|return
operator|(
literal|"RAID-6"
operator|)
return|;
case|case
name|DDF_JBOD
case|:
return|return
operator|(
literal|"JBOD"
operator|)
return|;
case|case
name|DDF_CONCAT
case|:
return|return
operator|(
literal|"CONCAT"
operator|)
return|;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LVL 0x%02x"
argument_list|,
name|primary_level
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mfi_query_disk
parameter_list|(
name|int
name|fd
parameter_list|,
name|uint8_t
name|target_id
parameter_list|,
name|struct
name|mfi_query_disk
modifier|*
name|info
parameter_list|)
block|{
name|bzero
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|array_id
operator|=
name|target_id
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|MFIIO_QUERY_DISK
argument_list|,
name|info
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|present
condition|)
block|{
name|errno
operator|=
name|ENXIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|mfi_volume_name
parameter_list|(
name|int
name|fd
parameter_list|,
name|uint8_t
name|target_id
parameter_list|)
block|{
specifier|static
name|struct
name|mfi_query_disk
name|info
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|mfi_query_disk
argument_list|(
name|fd
argument_list|,
name|target_id
argument_list|,
operator|&
name|info
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|target_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
return|return
operator|(
name|info
operator|.
name|devname
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mfi_volume_busy
parameter_list|(
name|int
name|fd
parameter_list|,
name|uint8_t
name|target_id
parameter_list|)
block|{
name|struct
name|mfi_query_disk
name|info
decl_stmt|;
comment|/* Assume it isn't mounted if we can't get information. */
if|if
condition|(
name|mfi_query_disk
argument_list|(
name|fd
argument_list|,
name|target_id
argument_list|,
operator|&
name|info
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|info
operator|.
name|open
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the running kernel supports changing the RAID  * configuration of the mfi controller.  */
end_comment

begin_function
name|int
name|mfi_reconfig_supported
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|mibname
index|[
literal|64
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|mibname
argument_list|,
sizeof|sizeof
argument_list|(
name|mibname
argument_list|)
argument_list|,
literal|"dev.mfi.%d.delete_busy_volumes"
argument_list|,
name|mfi_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctlbyname
argument_list|(
name|mibname
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mfi_lookup_volume
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint8_t
modifier|*
name|target_id
parameter_list|)
block|{
name|struct
name|mfi_query_disk
name|info
decl_stmt|;
name|struct
name|mfi_ld_list
name|list
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|long
name|val
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* If it's a valid number, treat it as a raw target ID. */
name|val
operator|=
name|strtol
argument_list|(
name|name
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|target_id
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|mfi_dcmd_command
argument_list|(
name|fd
argument_list|,
name|MFI_DCMD_LD_GET_LIST
argument_list|,
operator|&
name|list
argument_list|,
sizeof|sizeof
argument_list|(
name|list
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|.
name|ld_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mfi_query_disk
argument_list|(
name|fd
argument_list|,
name|list
operator|.
name|ld_list
index|[
name|i
index|]
operator|.
name|ld
operator|.
name|v
operator|.
name|target_id
argument_list|,
operator|&
name|info
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|info
operator|.
name|devname
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|target_id
operator|=
name|list
operator|.
name|ld_list
index|[
name|i
index|]
operator|.
name|ld
operator|.
name|v
operator|.
name|target_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mfi_dcmd_command
parameter_list|(
name|int
name|fd
parameter_list|,
name|uint32_t
name|opcode
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsize
parameter_list|,
name|uint8_t
modifier|*
name|mbox
parameter_list|,
name|size_t
name|mboxlen
parameter_list|,
name|uint8_t
modifier|*
name|statusp
parameter_list|)
block|{
name|struct
name|mfi_ioc_passthru
name|ioc
decl_stmt|;
name|struct
name|mfi_dcmd_frame
modifier|*
name|dcmd
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
operator|(
name|mbox
operator|!=
name|NULL
operator|&&
operator|(
name|mboxlen
operator|==
literal|0
operator|||
name|mboxlen
operator|>
name|MFI_MBOX_SIZE
operator|)
operator|)
operator|||
operator|(
name|mbox
operator|==
name|NULL
operator|&&
name|mboxlen
operator|!=
literal|0
operator|)
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|ioc
argument_list|,
sizeof|sizeof
argument_list|(
name|ioc
argument_list|)
argument_list|)
expr_stmt|;
name|dcmd
operator|=
operator|&
name|ioc
operator|.
name|ioc_frame
expr_stmt|;
if|if
condition|(
name|mbox
condition|)
name|bcopy
argument_list|(
name|mbox
argument_list|,
name|dcmd
operator|->
name|mbox
argument_list|,
name|mboxlen
argument_list|)
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|cmd
operator|=
name|MFI_CMD_DCMD
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|timeout
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|dcmd
operator|->
name|header
operator|.
name|data_len
operator|=
name|bufsize
expr_stmt|;
name|dcmd
operator|->
name|opcode
operator|=
name|opcode
expr_stmt|;
name|ioc
operator|.
name|buf
operator|=
name|buf
expr_stmt|;
name|ioc
operator|.
name|buf_size
operator|=
name|bufsize
expr_stmt|;
name|r
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|MFIIO_PASSTHRU
argument_list|,
operator|&
name|ioc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
name|statusp
operator|!=
name|NULL
condition|)
operator|*
name|statusp
operator|=
name|dcmd
operator|->
name|header
operator|.
name|cmd_status
expr_stmt|;
elseif|else
if|if
condition|(
name|dcmd
operator|->
name|header
operator|.
name|cmd_status
operator|!=
name|MFI_STAT_OK
condition|)
block|{
name|warnx
argument_list|(
literal|"Command failed: %s"
argument_list|,
name|mfi_status
argument_list|(
name|dcmd
operator|->
name|header
operator|.
name|cmd_status
argument_list|)
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mfi_ctrl_get_info
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|mfi_ctrl_info
modifier|*
name|info
parameter_list|,
name|uint8_t
modifier|*
name|statusp
parameter_list|)
block|{
return|return
operator|(
name|mfi_dcmd_command
argument_list|(
name|fd
argument_list|,
name|MFI_DCMD_CTRL_GETINFO
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfi_ctrl_info
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|statusp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mfi_open
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"/dev/mfi%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|open
argument_list|(
name|path
argument_list|,
name|O_RDWR
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|mfi_display_progress
parameter_list|(
specifier|const
name|char
modifier|*
name|label
parameter_list|,
name|struct
name|mfi_progress
modifier|*
name|prog
parameter_list|)
block|{
name|uint
name|seconds
decl_stmt|;
name|printf
argument_list|(
literal|"%s: %.2f%% complete, after %ds"
argument_list|,
name|label
argument_list|,
operator|(
name|float
operator|)
name|prog
operator|->
name|progress
operator|*
literal|100
operator|/
literal|0xffff
argument_list|,
name|prog
operator|->
name|elapsed_seconds
argument_list|)
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|progress
operator|!=
literal|0
operator|&&
name|prog
operator|->
name|elapsed_seconds
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|" finished in "
argument_list|)
expr_stmt|;
name|seconds
operator|=
operator|(
literal|0x10000
operator|*
operator|(
name|uint32_t
operator|)
name|prog
operator|->
name|elapsed_seconds
operator|)
operator|/
name|prog
operator|->
name|progress
operator|-
name|prog
operator|->
name|elapsed_seconds
expr_stmt|;
if|if
condition|(
name|seconds
operator|>
literal|3600
condition|)
name|printf
argument_list|(
literal|"%u:"
argument_list|,
name|seconds
operator|/
literal|3600
argument_list|)
expr_stmt|;
if|if
condition|(
name|seconds
operator|>
literal|60
condition|)
block|{
name|seconds
operator|%=
literal|3600
expr_stmt|;
name|printf
argument_list|(
literal|"%02u:%02u"
argument_list|,
name|seconds
operator|/
literal|60
argument_list|,
name|seconds
operator|%
literal|60
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%us"
argument_list|,
name|seconds
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mfi_table_handler
parameter_list|(
name|struct
name|mfiutil_command
modifier|*
modifier|*
name|start
parameter_list|,
name|struct
name|mfiutil_command
modifier|*
modifier|*
name|end
parameter_list|,
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|struct
name|mfiutil_command
modifier|*
modifier|*
name|cmd
decl_stmt|;
if|if
condition|(
name|ac
operator|<
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"The %s command requires a sub-command."
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
for|for
control|(
name|cmd
operator|=
name|start
init|;
name|cmd
operator|<
name|end
condition|;
name|cmd
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|(
operator|*
name|cmd
operator|)
operator|->
name|name
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
operator|*
name|cmd
operator|)
operator|->
name|handler
argument_list|(
name|ac
operator|-
literal|1
argument_list|,
name|av
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
name|warnx
argument_list|(
literal|"%s is not a valid sub-command of %s."
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

end_unit

