begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The new sysinstall program.  *  * This is probably the last program in the `sysinstall' line - the next  * generation being essentially a complete rewrite.  *  * $Id$  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,   *    verbatim and that no modifications are made prior to this   *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jordan Hubbard  *	for the FreeBSD Project.  * 4. The name of Jordan Hubbard or the FreeBSD project may not be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*  * I make some pretty gross assumptions about having a max of 50 chunks  * total - 8 slices and 42 partitions.  I can't easily display many more  * than that on the screen at once!  *  * For 2.1 I'll revisit this and try to make it more dynamic, but since  * this will catch 99.99% of all possible cases, I'm not too worried.  */
end_comment

begin_define
define|#
directive|define
name|MAX_CHUNKS
value|50
end_define

begin_define
define|#
directive|define
name|FS_SWAP
value|1
end_define

begin_comment
comment|/* Where to start printing the freebsd slices */
end_comment

begin_define
define|#
directive|define
name|CHUNK_SLICE_START_ROW
value|2
end_define

begin_define
define|#
directive|define
name|CHUNK_PART_START_ROW
value|10
end_define

begin_comment
comment|/* The smallest filesystem we're willing to create */
end_comment

begin_define
define|#
directive|define
name|FS_MIN_SIZE
value|2048
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|PART_NONE
block|,
name|PART_SLICE
block|,
name|PART_SWAP
block|,
name|PART_FILESYSTEM
block|}
name|part_type
typedef|;
end_typedef

begin_struct
struct|struct
name|part_info
block|{
name|Boolean
name|newfs
decl_stmt|;
name|char
name|mountpoint
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|disk
modifier|*
name|d
decl_stmt|;
name|struct
name|chunk
modifier|*
name|c
decl_stmt|;
name|struct
name|part_info
modifier|*
name|p
decl_stmt|;
name|part_type
name|type
decl_stmt|;
block|}
name|fbsd_chunk_info
index|[
name|MAX_CHUNKS
operator|+
literal|1
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|current_chunk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the given disk has a root partition on it, return TRUE */
end_comment

begin_function
specifier|static
name|Boolean
name|contains_root_partition
parameter_list|(
name|struct
name|disk
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|chunk
modifier|*
name|c1
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"Disk %s has no chunks!"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|c1
operator|=
name|d
operator|->
name|chunks
operator|->
name|part
expr_stmt|;
while|while
condition|(
name|c1
condition|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
name|struct
name|chunk
modifier|*
name|c2
init|=
name|c1
operator|->
name|part
decl_stmt|;
while|while
condition|(
name|c2
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|flags
operator|&
name|CHUNK_IS_ROOT
condition|)
return|return
name|TRUE
return|;
name|c2
operator|=
name|c2
operator|->
name|next
expr_stmt|;
block|}
block|}
name|c1
operator|=
name|c1
operator|->
name|next
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|check_conflict
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|d
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PART_FILESYSTEM
operator|&&
operator|!
name|strcmp
argument_list|(
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|space_free
parameter_list|(
name|struct
name|chunk
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|chunk
modifier|*
name|c1
init|=
name|c
operator|->
name|part
decl_stmt|;
name|int
name|sz
init|=
name|c
operator|->
name|size
decl_stmt|;
while|while
condition|(
name|c1
condition|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|!=
name|unused
condition|)
name|sz
operator|-=
name|c1
operator|->
name|size
expr_stmt|;
name|c1
operator|=
name|c1
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
name|msgFatal
argument_list|(
literal|"Partitions are larger than actual chunk??"
argument_list|)
expr_stmt|;
return|return
name|sz
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|record_fbsd_chunks
parameter_list|(
name|struct
name|disk
modifier|*
modifier|*
name|disks
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|p
decl_stmt|;
name|j
operator|=
name|p
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|disks
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|chunk
modifier|*
name|c1
decl_stmt|;
if|if
condition|(
operator|!
name|disks
index|[
name|i
index|]
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disks
index|[
name|i
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
name|c1
operator|=
name|disks
index|[
name|i
index|]
operator|->
name|chunks
operator|->
name|part
expr_stmt|;
while|while
condition|(
name|c1
condition|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
name|struct
name|chunk
modifier|*
name|c2
init|=
name|c1
operator|->
name|part
decl_stmt|;
name|fbsd_chunk_info
index|[
name|j
index|]
operator|.
name|type
operator|=
name|PART_SLICE
expr_stmt|;
name|fbsd_chunk_info
index|[
name|j
index|]
operator|.
name|d
operator|=
name|disks
index|[
name|i
index|]
expr_stmt|;
name|fbsd_chunk_info
index|[
name|j
index|]
operator|.
name|c
operator|=
name|c1
expr_stmt|;
name|fbsd_chunk_info
index|[
name|j
operator|++
index|]
operator|.
name|p
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|c2
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
name|fbsd_chunk_info
index|[
name|j
index|]
operator|.
name|type
operator|=
name|PART_SWAP
expr_stmt|;
else|else
name|fbsd_chunk_info
index|[
name|j
index|]
operator|.
name|type
operator|=
name|PART_FILESYSTEM
expr_stmt|;
name|fbsd_chunk_info
index|[
name|j
index|]
operator|.
name|d
operator|=
name|disks
index|[
name|i
index|]
expr_stmt|;
name|fbsd_chunk_info
index|[
name|j
index|]
operator|.
name|c
operator|=
name|c2
expr_stmt|;
name|fbsd_chunk_info
index|[
name|j
operator|++
index|]
operator|.
name|p
operator|=
name|c2
operator|->
name|private
expr_stmt|;
block|}
name|c2
operator|=
name|c2
operator|->
name|next
expr_stmt|;
block|}
block|}
name|c1
operator|=
name|c1
operator|->
name|next
expr_stmt|;
block|}
block|}
name|fbsd_chunk_info
index|[
name|j
index|]
operator|.
name|d
operator|=
name|NULL
expr_stmt|;
name|fbsd_chunk_info
index|[
name|j
index|]
operator|.
name|c
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|get_mountpoint
parameter_list|(
name|struct
name|chunk
modifier|*
name|c
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|struct
name|part_info
modifier|*
name|part
decl_stmt|;
name|val
operator|=
name|msgGetInput
argument_list|(
name|c
operator|->
name|private
argument_list|,
literal|"Please specify mount point for new partition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"/"
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|flags
operator|&
name|CHUNK_PAST_1024
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"This region cannot be used for your root partition as\nit is past the 1024'th cylinder mark and the system would not be\nable to boot from it.  Please pick another location for your\nroot partition and try again!"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|c
operator|->
name|flags
operator||=
name|CHUNK_IS_ROOT
expr_stmt|;
block|}
if|if
condition|(
name|check_conflict
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You already have a mountpoint for %s assigned!"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|safe_free
argument_list|(
name|c
operator|->
name|private
argument_list|)
expr_stmt|;
name|part
operator|=
operator|(
expr|struct
name|part_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|part_info
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|part
operator|->
name|mountpoint
argument_list|,
name|val
argument_list|,
name|FILENAME_MAX
argument_list|)
expr_stmt|;
name|part
operator|->
name|newfs
operator|=
name|TRUE
expr_stmt|;
name|c
operator|->
name|private
operator|=
operator|(
name|void
operator|*
operator|)
name|part
expr_stmt|;
name|c
operator|->
name|private_free
operator|=
name|free
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|part_type
name|get_partition_type
parameter_list|(
name|struct
name|chunk
modifier|*
name|c
parameter_list|)
block|{
name|char
name|selection
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|unsigned
name|char
modifier|*
name|fs_types
index|[]
init|=
block|{
literal|"Swap"
block|,
literal|"A swap partition."
block|,
literal|"FS"
block|,
literal|"A file system"
block|,     }
decl_stmt|;
if|if
condition|(
operator|!
name|dialog_menu
argument_list|(
literal|"Please choose a partition type"
argument_list|,
literal|"If you want to use this partition for swap space, select Swap.\nIf you want to put a filesystem on it, choose FS."
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|fs_types
argument_list|,
name|selection
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|selection
argument_list|,
literal|"FS"
argument_list|)
condition|)
return|return
name|PART_FILESYSTEM
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|selection
argument_list|,
literal|"Swap"
argument_list|)
condition|)
return|return
name|PART_SWAP
return|;
block|}
return|return
name|PART_NONE
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PART_PART_COL
value|0
end_define

begin_define
define|#
directive|define
name|PART_MOUNT_COL
value|8
end_define

begin_define
define|#
directive|define
name|PART_NEWFS_COL
value|32
end_define

begin_define
define|#
directive|define
name|PART_OFF
value|40
end_define

begin_function
specifier|static
name|void
name|print_fbsd_chunks
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|srow
decl_stmt|,
name|prow
decl_stmt|,
name|pcol
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|attrset
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|25
argument_list|,
literal|"FreeBSD Partition Editor"
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|attrset
argument_list|(
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|CHUNK_PART_START_ROW
operator|-
literal|1
argument_list|,
name|PART_PART_COL
operator|+
operator|(
name|i
operator|*
name|PART_OFF
operator|)
argument_list|,
literal|"Part"
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|CHUNK_PART_START_ROW
operator|-
literal|1
argument_list|,
name|PART_MOUNT_COL
operator|+
operator|(
name|i
operator|*
name|PART_OFF
operator|)
argument_list|,
literal|"Mount"
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|CHUNK_PART_START_ROW
operator|-
literal|1
argument_list|,
name|PART_NEWFS_COL
operator|+
operator|(
name|i
operator|*
name|PART_OFF
operator|)
argument_list|,
literal|"Newfs"
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
name|srow
operator|=
name|CHUNK_SLICE_START_ROW
expr_stmt|;
name|prow
operator|=
name|CHUNK_PART_START_ROW
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|d
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|current_chunk
condition|)
name|attrset
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PART_SLICE
condition|)
block|{
name|sz
operator|=
name|space_free
argument_list|(
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|srow
operator|++
argument_list|,
literal|0
argument_list|,
literal|"Disk: %s\tPartition name: %s\tFree: %d blocks (%dMB)"
argument_list|,
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|d
operator|->
name|name
argument_list|,
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|name
argument_list|,
name|sz
argument_list|,
operator|(
name|sz
operator|/
literal|2048
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Go for two columns */
if|if
condition|(
name|prow
operator|==
operator|(
name|CHUNK_PART_START_ROW
operator|+
literal|9
operator|)
condition|)
name|pcol
operator|=
name|PART_OFF
expr_stmt|;
else|else
name|pcol
operator|=
literal|0
expr_stmt|;
name|mvaddstr
argument_list|(
name|prow
argument_list|,
name|pcol
operator|+
name|PART_PART_COL
argument_list|,
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PART_FILESYSTEM
condition|)
block|{
name|char
modifier|*
name|mountpoint
decl_stmt|,
modifier|*
name|newfs
decl_stmt|;
if|if
condition|(
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|private
condition|)
block|{
name|mountpoint
operator|=
operator|(
operator|(
expr|struct
name|part_info
operator|*
operator|)
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|private
operator|)
operator|->
name|mountpoint
expr_stmt|;
name|newfs
operator|=
operator|(
operator|(
expr|struct
name|part_info
operator|*
operator|)
name|fbsd_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|private
operator|)
operator|->
name|newfs
condition|?
literal|"Y"
else|:
literal|"N"
expr_stmt|;
block|}
else|else
block|{
name|mountpoint
operator|=
literal|"?"
expr_stmt|;
name|newfs
operator|=
literal|""
expr_stmt|;
block|}
name|mvaddstr
argument_list|(
name|prow
argument_list|,
name|pcol
operator|+
name|PART_MOUNT_COL
argument_list|,
name|mountpoint
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|prow
argument_list|,
name|pcol
operator|+
name|PART_NEWFS_COL
argument_list|,
name|newfs
argument_list|)
expr_stmt|;
block|}
else|else
name|mvaddstr
argument_list|(
name|prow
argument_list|,
name|pcol
operator|+
name|PART_MOUNT_COL
argument_list|,
literal|"swap"
argument_list|)
expr_stmt|;
operator|++
name|prow
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|current_chunk
condition|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_command_summary
parameter_list|()
block|{
name|int
name|attrs
init|=
name|ColorDisplay
condition|?
name|A_BOLD
else|:
name|A_UNDERLINE
decl_stmt|;
name|mvprintw
argument_list|(
literal|19
argument_list|,
literal|0
argument_list|,
literal|"The following commands are valid here (upper or lower case):"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|,
literal|"C = Create FreeBSD Partition      D = Delete Partition"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|21
argument_list|,
literal|0
argument_list|,
literal|"M = Mount Partition (no newfs)    ESC = Proceed to summary screen"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|22
argument_list|,
literal|0
argument_list|,
literal|"The default target will be displayed in "
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|ColorDisplay
condition|?
literal|"bold"
else|:
literal|"underline"
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|partition_disks
parameter_list|(
name|struct
name|disk
modifier|*
modifier|*
name|disks
parameter_list|)
block|{
name|int
name|sz
decl_stmt|,
name|key
init|=
literal|0
decl_stmt|;
name|Boolean
name|partitioning
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
name|partitioning
operator|=
name|TRUE
expr_stmt|;
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|record_fbsd_chunks
argument_list|(
name|disks
argument_list|)
expr_stmt|;
while|while
condition|(
name|partitioning
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|print_fbsd_chunks
argument_list|()
expr_stmt|;
name|print_command_summary
argument_list|()
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|standout
argument_list|()
expr_stmt|;
name|mvprintw
argument_list|(
literal|23
argument_list|,
literal|0
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
name|refresh
argument_list|()
expr_stmt|;
name|key
operator|=
name|toupper
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|KEY_UP
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|current_chunk
operator|!=
literal|0
condition|)
operator|--
name|current_chunk
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
case|case
literal|'+'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
if|if
condition|(
name|fbsd_chunk_info
index|[
name|current_chunk
operator|+
literal|1
index|]
operator|.
name|d
condition|)
operator|++
name|current_chunk
expr_stmt|;
break|break;
case|case
name|KEY_HOME
case|:
name|current_chunk
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_END
case|:
while|while
condition|(
name|fbsd_chunk_info
index|[
name|current_chunk
operator|+
literal|1
index|]
operator|.
name|d
condition|)
operator|++
name|current_chunk
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|1
argument_list|)
case|:
case|case
literal|'?'
case|:
name|systemDisplayFile
argument_list|(
literal|"partitioning.hlp"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|fbsd_chunk_info
index|[
name|current_chunk
index|]
operator|.
name|type
operator|!=
name|PART_SLICE
condition|)
block|{
name|msg
operator|=
literal|"Can only create sub-partitions in a master partition (at top)"
expr_stmt|;
break|break;
block|}
name|sz
operator|=
name|space_free
argument_list|(
name|fbsd_chunk_info
index|[
name|current_chunk
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|<=
name|FS_MIN_SIZE
condition|)
name|msg
operator|=
literal|"Not enough space to create additional FreeBSD partition"
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|val
decl_stmt|,
name|tmp
index|[
literal|20
index|]
decl_stmt|;
name|int
name|size
decl_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
literal|20
argument_list|,
literal|"%d"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|val
operator|=
name|msgGetInput
argument_list|(
name|tmp
argument_list|,
literal|"Please specify size for new FreeBSD partition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
operator|(
name|size
operator|=
name|strtol
argument_list|(
name|val
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|part_type
name|type
decl_stmt|;
if|if
condition|(
name|get_mountpoint
argument_list|(
name|fbsd_chunk_info
index|[
name|current_chunk
index|]
operator|.
name|c
argument_list|)
condition|)
break|break;
name|type
operator|=
name|get_partition_type
argument_list|(
name|fbsd_chunk_info
index|[
name|current_chunk
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PART_NONE
condition|)
break|break;
name|Create_Chunk
argument_list|(
name|fbsd_chunk_info
index|[
name|current_chunk
index|]
operator|.
name|d
argument_list|,
name|fbsd_chunk_info
index|[
name|current_chunk
index|]
operator|.
name|c
operator|->
name|offset
argument_list|,
name|size
argument_list|,
name|part
argument_list|,
name|type
operator|==
name|PART_SWAP
condition|?
name|FS_SWAP
else|:
name|freebsd
argument_list|,
name|fbsd_chunk_info
index|[
name|current_chunk
index|]
operator|.
name|c
operator|->
name|flags
argument_list|)
expr_stmt|;
name|record_fbsd_chunks
argument_list|(
name|disks
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|27
case|:
comment|/* ESC */
name|partitioning
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|int
name|write_disks
parameter_list|(
name|struct
name|disk
modifier|*
modifier|*
name|disks
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|extern
name|u_char
name|boot1
index|[]
decl_stmt|,
name|boot2
index|[]
decl_stmt|;
specifier|extern
name|u_char
name|mbr
index|[]
decl_stmt|,
name|bteasy17
index|[]
decl_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Last Chance!  Are you sure you want to write your changes to disk?"
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|disks
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|contains_root_partition
argument_list|(
name|disks
index|[
name|i
index|]
argument_list|)
condition|)
name|Set_Boot_Blocks
argument_list|(
name|disks
index|[
name|i
index|]
argument_list|,
name|boot1
argument_list|,
name|boot2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to install a boot manager?\n\nThis will allow you to easily select between other operating systems\non the first disk, as well as boot from a driver other than the first."
argument_list|)
condition|)
name|Set_Boot_Mgr
argument_list|(
name|disks
index|[
name|i
index|]
argument_list|,
name|bteasy17
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
operator|!
name|msgYesNo
argument_list|(
literal|"Would you like to remove an existing boot manager?"
argument_list|)
condition|)
name|Set_Boot_Mgr
argument_list|(
name|disks
index|[
name|i
index|]
argument_list|,
name|mbr
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|Write_Disk(disks[i]);
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|make_filesystems
parameter_list|(
name|struct
name|disk
modifier|*
modifier|*
name|disks
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|cpio_extract
parameter_list|(
name|struct
name|disk
modifier|*
modifier|*
name|disks
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|extract_dists
parameter_list|(
name|struct
name|disk
modifier|*
modifier|*
name|disks
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|do_final_setup
parameter_list|(
name|struct
name|disk
modifier|*
modifier|*
name|disks
parameter_list|)
block|{ }
end_function

end_unit

