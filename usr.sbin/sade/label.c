begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The new sysinstall program.  *  * This is probably the last program in the `sysinstall' line - the next  * generation being essentially a complete rewrite.  *  * $Id: label.c,v 1.9 1995/05/19 02:09:02 jkh Exp $  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,   *    verbatim and that no modifications are made prior to this   *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jordan Hubbard  *	for the FreeBSD Project.  * 4. The name of Jordan Hubbard or the FreeBSD project may not be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_comment
comment|/*  * Everything to do with editing the contents of disk labels.  */
end_comment

begin_comment
comment|/* A nice message we use a lot in the disklabel editor */
end_comment

begin_define
define|#
directive|define
name|MSG_NOT_APPLICABLE
value|"That option is not applicable here"
end_define

begin_comment
comment|/*  * I make some pretty gross assumptions about having a max of 50 chunks  * total - 8 slices and 42 partitions.  I can't easily display many more  * than that on the screen at once!  *  * For 2.1 I'll revisit this and try to make it more dynamic, but since  * this will catch 99.99% of all possible cases, I'm not too worried.  */
end_comment

begin_define
define|#
directive|define
name|MAX_CHUNKS
value|50
end_define

begin_comment
comment|/* Where to start printing the freebsd slices */
end_comment

begin_define
define|#
directive|define
name|CHUNK_SLICE_START_ROW
value|2
end_define

begin_define
define|#
directive|define
name|CHUNK_PART_START_ROW
value|11
end_define

begin_comment
comment|/* The smallest filesystem we're willing to create */
end_comment

begin_define
define|#
directive|define
name|FS_MIN_SIZE
value|2048
end_define

begin_comment
comment|/* All the chunks currently displayed on the screen */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|disk
modifier|*
name|d
decl_stmt|;
name|struct
name|chunk
modifier|*
name|c
decl_stmt|;
name|PartType
name|type
decl_stmt|;
block|}
name|label_chunk_info
index|[
name|MAX_CHUNKS
operator|+
literal|1
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|here
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See if we're already using a desired partition name */
end_comment

begin_function
specifier|static
name|Boolean
name|check_conflict
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|d
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PART_FILESYSTEM
operator|&&
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|private
operator|&&
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|private
operator|)
operator|->
name|mountpoint
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* How much space is in this FreeBSD slice? */
end_comment

begin_function
specifier|static
name|int
name|space_free
parameter_list|(
name|struct
name|chunk
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|chunk
modifier|*
name|c1
init|=
name|c
operator|->
name|part
decl_stmt|;
name|int
name|sz
init|=
name|c
operator|->
name|size
decl_stmt|;
while|while
condition|(
name|c1
condition|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|!=
name|unused
condition|)
name|sz
operator|-=
name|c1
operator|->
name|size
expr_stmt|;
name|c1
operator|=
name|c1
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sz
operator|<
literal|0
condition|)
name|msgFatal
argument_list|(
literal|"Partitions are larger than actual chunk??"
argument_list|)
expr_stmt|;
return|return
name|sz
return|;
block|}
end_function

begin_comment
comment|/* Snapshot the current situation into the displayed chunks structure */
end_comment

begin_function
specifier|static
name|void
name|record_label_chunks
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|p
decl_stmt|;
name|struct
name|chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|Disk
modifier|*
name|d
decl_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|devs
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No disks found!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|j
operator|=
name|p
operator|=
literal|0
expr_stmt|;
comment|/* First buzz through and pick up the FreeBSD slices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|d
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Put the slice entries first */
for|for
control|(
name|c1
operator|=
name|d
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|type
operator|=
name|PART_SLICE
expr_stmt|;
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|d
operator|=
name|d
expr_stmt|;
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|c
operator|=
name|c1
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
block|}
comment|/* Now run through again and get the FreeBSD partition entries */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|d
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
comment|/* Then buzz through and pick up the partitions */
for|for
control|(
name|c1
operator|=
name|d
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
condition|)
block|{
if|if
condition|(
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|type
operator|=
name|PART_SWAP
expr_stmt|;
else|else
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|type
operator|=
name|PART_FILESYSTEM
expr_stmt|;
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|d
operator|=
name|d
expr_stmt|;
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|c
operator|=
name|c2
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|fat
condition|)
block|{
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|type
operator|=
name|PART_FAT
expr_stmt|;
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|d
operator|=
name|d
expr_stmt|;
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|c
operator|=
name|c1
expr_stmt|;
block|}
block|}
block|}
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|d
operator|=
name|NULL
expr_stmt|;
name|label_chunk_info
index|[
name|j
index|]
operator|.
name|c
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|here
operator|>=
name|j
condition|)
name|here
operator|=
name|j
condition|?
name|j
operator|-
literal|1
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A new partition entry */
end_comment

begin_function
specifier|static
name|PartInfo
modifier|*
name|new_part
parameter_list|(
name|char
modifier|*
name|mpoint
parameter_list|,
name|Boolean
name|newfs
parameter_list|)
block|{
name|PartInfo
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
name|PartInfo
operator|*
operator|)
name|safe_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PartInfo
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ret
operator|->
name|mountpoint
argument_list|,
name|mpoint
argument_list|,
name|FILENAME_MAX
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
operator|->
name|newfs_cmd
argument_list|,
literal|"newfs"
argument_list|)
expr_stmt|;
name|ret
operator|->
name|newfs
operator|=
name|newfs
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Get the mountpoint for a partition and save it away */
end_comment

begin_function
name|PartInfo
modifier|*
name|get_mountpoint
parameter_list|(
name|struct
name|chunk
modifier|*
name|old
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|PartInfo
modifier|*
name|tmp
decl_stmt|;
name|val
operator|=
name|msgGetInput
argument_list|(
name|old
operator|&&
name|old
operator|->
name|private
condition|?
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|old
operator|->
name|private
operator|)
operator|->
name|mountpoint
else|:
name|NULL
argument_list|,
literal|"Please specify a mount point for the partition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
comment|/* Is it just the same value? */
if|if
condition|(
name|old
operator|&&
name|old
operator|->
name|private
operator|&&
operator|!
name|strcmp
argument_list|(
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|old
operator|->
name|private
operator|)
operator|->
name|mountpoint
argument_list|,
name|val
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|check_conflict
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You already have a mount point for %s assigned!"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|val
operator|!=
literal|'/'
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Mount point must start with a / character"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"/"
argument_list|)
condition|)
block|{
if|if
condition|(
name|old
condition|)
name|old
operator|->
name|flags
operator||=
name|CHUNK_IS_ROOT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old
condition|)
name|old
operator|->
name|flags
operator|&=
operator|~
name|CHUNK_IS_ROOT
expr_stmt|;
name|safe_free
argument_list|(
name|old
condition|?
name|old
operator|->
name|private
else|:
name|NULL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|new_part
argument_list|(
name|val
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
block|{
name|old
operator|->
name|private
operator|=
name|tmp
expr_stmt|;
name|old
operator|->
name|private_free
operator|=
name|safe_free
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Get the type of the new partiton */
end_comment

begin_function
specifier|static
name|PartType
name|get_partition_type
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|selection
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|unsigned
name|char
modifier|*
name|fs_types
index|[]
init|=
block|{
literal|"FS"
block|,
literal|"A file system"
block|,
literal|"Swap"
block|,
literal|"A swap partition."
block|,     }
decl_stmt|;
if|if
condition|(
operator|!
name|dialog_menu
argument_list|(
literal|"Please choose a partition type"
argument_list|,
literal|"If you want to use this partition for swap space, select Swap.\nIf you want to put a filesystem on it, choose FS."
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|fs_types
argument_list|,
name|selection
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|selection
argument_list|,
literal|"FS"
argument_list|)
condition|)
return|return
name|PART_FILESYSTEM
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|selection
argument_list|,
literal|"Swap"
argument_list|)
condition|)
return|return
name|PART_SWAP
return|;
block|}
return|return
name|PART_NONE
return|;
block|}
end_function

begin_comment
comment|/* If the user wants a special newfs command for this, set it */
end_comment

begin_function
specifier|static
name|void
name|getNewfsCmd
parameter_list|(
name|PartInfo
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|msgGetInput
argument_list|(
name|p
operator|->
name|newfs_cmd
argument_list|,
literal|"Please enter the newfs command and options you'd like to use in\ncreating this file system."
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|strncpy
argument_list|(
name|p
operator|->
name|newfs_cmd
argument_list|,
name|val
argument_list|,
name|NEWFS_CMD_MAX
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_MOUNT_NAME
value|12
end_define

begin_define
define|#
directive|define
name|PART_PART_COL
value|0
end_define

begin_define
define|#
directive|define
name|PART_MOUNT_COL
value|8
end_define

begin_define
define|#
directive|define
name|PART_SIZE_COL
value|(PART_MOUNT_COL + MAX_MOUNT_NAME + 3)
end_define

begin_define
define|#
directive|define
name|PART_NEWFS_COL
value|(PART_SIZE_COL + 7)
end_define

begin_define
define|#
directive|define
name|PART_OFF
value|38
end_define

begin_comment
comment|/* How many mounted partitions to display in column before going to next */
end_comment

begin_define
define|#
directive|define
name|CHUNK_COLUMN_MAX
value|5
end_define

begin_comment
comment|/* stick this all up on the screen */
end_comment

begin_function
specifier|static
name|void
name|print_label_chunks
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|srow
decl_stmt|,
name|prow
decl_stmt|,
name|pcol
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|int
name|label_attr
decl_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|attrset
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|25
argument_list|,
literal|"FreeBSD Disklabel Editor"
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|mvaddstr
argument_list|(
name|CHUNK_PART_START_ROW
operator|-
literal|2
argument_list|,
name|PART_PART_COL
operator|+
operator|(
name|i
operator|*
name|PART_OFF
operator|)
argument_list|,
literal|"Part"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|CHUNK_PART_START_ROW
operator|-
literal|1
argument_list|,
name|PART_PART_COL
operator|+
operator|(
name|i
operator|*
name|PART_OFF
operator|)
argument_list|,
literal|"----"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|CHUNK_PART_START_ROW
operator|-
literal|2
argument_list|,
name|PART_MOUNT_COL
operator|+
operator|(
name|i
operator|*
name|PART_OFF
operator|)
argument_list|,
literal|"Mount"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|CHUNK_PART_START_ROW
operator|-
literal|1
argument_list|,
name|PART_MOUNT_COL
operator|+
operator|(
name|i
operator|*
name|PART_OFF
operator|)
argument_list|,
literal|"-----"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|CHUNK_PART_START_ROW
operator|-
literal|2
argument_list|,
name|PART_SIZE_COL
operator|+
operator|(
name|i
operator|*
name|PART_OFF
operator|)
operator|+
literal|2
argument_list|,
literal|"Size"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|CHUNK_PART_START_ROW
operator|-
literal|1
argument_list|,
name|PART_SIZE_COL
operator|+
operator|(
name|i
operator|*
name|PART_OFF
operator|)
operator|+
literal|2
argument_list|,
literal|"----"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|CHUNK_PART_START_ROW
operator|-
literal|2
argument_list|,
name|PART_NEWFS_COL
operator|+
operator|(
name|i
operator|*
name|PART_OFF
operator|)
argument_list|,
literal|"Newfs"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|CHUNK_PART_START_ROW
operator|-
literal|1
argument_list|,
name|PART_NEWFS_COL
operator|+
operator|(
name|i
operator|*
name|PART_OFF
operator|)
argument_list|,
literal|"-----"
argument_list|)
expr_stmt|;
block|}
name|srow
operator|=
name|CHUNK_SLICE_START_ROW
expr_stmt|;
name|prow
operator|=
name|CHUNK_PART_START_ROW
expr_stmt|;
name|pcol
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|d
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|here
condition|)
name|attrset
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
comment|/* Is it a slice entry displayed at the top? */
if|if
condition|(
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PART_SLICE
condition|)
block|{
name|sz
operator|=
name|space_free
argument_list|(
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|srow
operator|++
argument_list|,
literal|0
argument_list|,
literal|"Disk: %s\tPartition name: %s\tFree: %d blocks (%dMB)"
argument_list|,
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|d
operator|->
name|name
argument_list|,
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|name
argument_list|,
name|sz
argument_list|,
operator|(
name|sz
operator|/
literal|2048
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise it's a DOS, swap or filesystem entry, at the bottom */
else|else
block|{
name|char
name|onestr
index|[
name|PART_OFF
index|]
decl_stmt|,
name|num
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|mountpoint
decl_stmt|,
modifier|*
name|newfs
decl_stmt|;
comment|/* 	     * We copy this into a blank-padded string so that it looks like 	     * a solid bar in reverse-video 	     */
name|memset
argument_list|(
name|onestr
argument_list|,
literal|' '
argument_list|,
name|PART_OFF
operator|-
literal|1
argument_list|)
expr_stmt|;
name|onestr
index|[
name|PART_OFF
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Go for two columns */
if|if
condition|(
name|prow
operator|==
operator|(
name|CHUNK_PART_START_ROW
operator|+
name|CHUNK_COLUMN_MAX
operator|)
condition|)
block|{
name|pcol
operator|=
name|PART_OFF
expr_stmt|;
name|prow
operator|=
name|CHUNK_PART_START_ROW
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|onestr
operator|+
name|PART_PART_COL
argument_list|,
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If it's a filesystem, display the mountpoint */
if|if
condition|(
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PART_FILESYSTEM
condition|)
block|{
if|if
condition|(
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|private
operator|==
name|NULL
condition|)
block|{
specifier|static
name|int
name|mnt
init|=
literal|0
decl_stmt|;
name|char
name|foo
index|[
literal|10
index|]
decl_stmt|;
comment|/* 		     * Hmm!  A partition that must have already been here. 		     * Fill in a fake mountpoint and register it 		     */
name|sprintf
argument_list|(
name|foo
argument_list|,
literal|"/mnt%d"
argument_list|,
name|mnt
operator|++
argument_list|)
expr_stmt|;
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|private
operator|=
name|new_part
argument_list|(
name|foo
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|private_free
operator|=
name|safe_free
expr_stmt|;
block|}
name|mountpoint
operator|=
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|private
operator|)
operator|->
name|mountpoint
expr_stmt|;
name|newfs
operator|=
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|private
operator|)
operator|->
name|newfs
condition|?
literal|"Y"
else|:
literal|"N"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PART_SWAP
condition|)
block|{
name|mountpoint
operator|=
literal|"swap"
expr_stmt|;
name|newfs
operator|=
literal|" "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|type
operator|==
name|PART_FAT
condition|)
block|{
name|mountpoint
operator|=
literal|"DOS FAT"
expr_stmt|;
name|newfs
operator|=
literal|"*"
expr_stmt|;
block|}
else|else
block|{
name|mountpoint
operator|=
literal|"<unknown>"
expr_stmt|;
name|newfs
operator|=
literal|"*"
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_MOUNT_NAME
operator|&&
name|mountpoint
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
name|onestr
index|[
name|PART_MOUNT_COL
operator|+
name|j
index|]
operator|=
name|mountpoint
index|[
name|j
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|num
argument_list|,
literal|10
argument_list|,
literal|"%4ldMB"
argument_list|,
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|size
condition|?
name|label_chunk_info
index|[
name|i
index|]
operator|.
name|c
operator|->
name|size
operator|/
literal|2048
else|:
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|onestr
operator|+
name|PART_SIZE_COL
argument_list|,
name|num
argument_list|,
name|strlen
argument_list|(
name|num
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|onestr
operator|+
name|PART_NEWFS_COL
argument_list|,
name|newfs
argument_list|,
name|strlen
argument_list|(
name|newfs
argument_list|)
argument_list|)
expr_stmt|;
name|onestr
index|[
name|PART_NEWFS_COL
operator|+
name|strlen
argument_list|(
name|newfs
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mvaddstr
argument_list|(
name|prow
argument_list|,
name|pcol
argument_list|,
name|onestr
argument_list|)
expr_stmt|;
operator|++
name|prow
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|here
condition|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_command_summary
parameter_list|()
block|{
name|mvprintw
argument_list|(
literal|17
argument_list|,
literal|0
argument_list|,
literal|"The following commands are valid here (upper or lower case):"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|19
argument_list|,
literal|0
argument_list|,
literal|"C = Create Partition   D = Delete Partition   M = Mount Partition"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|,
literal|"N = Newfs Options      T = Toggle Newfs       ESC = Exit this screen"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|21
argument_list|,
literal|0
argument_list|,
literal|"The default target will be displayed in "
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"reverse video."
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|22
argument_list|,
literal|0
argument_list|,
literal|"Use F1 or ? to get more help, arrow keys to move."
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|diskLabelEditor
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|sz
decl_stmt|,
name|key
init|=
literal|0
decl_stmt|;
name|Boolean
name|labeling
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|PartInfo
modifier|*
name|p
decl_stmt|;
name|PartType
name|type
decl_stmt|;
name|labeling
operator|=
name|TRUE
expr_stmt|;
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|record_label_chunks
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getenv
argument_list|(
name|DISK_PARTITIONED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to partition your disk(s) before you can assign disk labels."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|labeling
condition|)
block|{
name|print_label_chunks
argument_list|()
expr_stmt|;
name|print_command_summary
argument_list|()
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
name|attrset
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
literal|23
argument_list|,
literal|0
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
name|refresh
argument_list|()
expr_stmt|;
name|key
operator|=
name|toupper
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|KEY_UP
case|:
case|case
literal|'-'
case|:
if|if
condition|(
name|here
operator|!=
literal|0
condition|)
operator|--
name|here
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
case|case
literal|'+'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
if|if
condition|(
name|label_chunk_info
index|[
name|here
operator|+
literal|1
index|]
operator|.
name|d
condition|)
operator|++
name|here
expr_stmt|;
break|break;
case|case
name|KEY_HOME
case|:
name|here
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_END
case|:
while|while
condition|(
name|label_chunk_info
index|[
name|here
operator|+
literal|1
index|]
operator|.
name|d
condition|)
operator|++
name|here
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|1
argument_list|)
case|:
case|case
literal|'?'
case|:
name|systemDisplayFile
argument_list|(
literal|"disklabel.hlp"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|type
operator|!=
name|PART_SLICE
condition|)
block|{
name|msg
operator|=
literal|"You can only do this in a master partition (see top of screen)"
expr_stmt|;
break|break;
block|}
name|sz
operator|=
name|space_free
argument_list|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|<=
name|FS_MIN_SIZE
condition|)
name|msg
operator|=
literal|"Not enough space to create additional FreeBSD partition"
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
name|tmp
index|[
literal|20
index|]
decl_stmt|;
name|int
name|size
decl_stmt|;
name|snprintf
argument_list|(
name|tmp
argument_list|,
literal|20
argument_list|,
literal|"%d"
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|val
operator|=
name|msgGetInput
argument_list|(
name|tmp
argument_list|,
literal|"Please specify the size for new FreeBSD partition in blocks, or append\na trailing `M' for megabytes (e.g. 20M)."
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
operator|(
name|size
operator|=
name|strtol
argument_list|(
name|val
argument_list|,
operator|&
name|cp
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|struct
name|chunk
modifier|*
name|tmp
decl_stmt|;
name|u_long
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|cp
operator|&&
name|toupper
argument_list|(
operator|*
name|cp
argument_list|)
operator|==
literal|'M'
condition|)
name|size
operator|*=
literal|2048
expr_stmt|;
name|type
operator|=
name|get_partition_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|PART_NONE
condition|)
break|break;
elseif|else
if|if
condition|(
name|type
operator|==
name|PART_FILESYSTEM
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|get_mountpoint
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
name|flags
operator||=
name|CHUNK_IS_ROOT
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|CHUNK_IS_ROOT
expr_stmt|;
block|}
else|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|CHUNK_IS_ROOT
operator|)
operator|&&
operator|!
operator|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|c
operator|->
name|flags
operator|&
name|CHUNK_BSD_COMPAT
operator|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"This region cannot be used for your root partition as\nthe FreeBSD boot code cannot deal with a root partition created in\nsuch a location.  Please choose another location for your root\npartition and try again!"
argument_list|)
expr_stmt|;
break|break;
block|}
name|tmp
operator|=
name|Create_Chunk_DWIM
argument_list|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|d
argument_list|,
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|c
argument_list|,
name|size
argument_list|,
name|part
argument_list|,
operator|(
name|type
operator|==
name|PART_SWAP
operator|)
condition|?
name|FS_SWAP
else|:
name|FS_BSDFFS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to create the partition. Too big?"
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|CHUNK_IS_ROOT
operator|)
operator|&&
operator|(
name|tmp
operator|->
name|flags
operator|&
name|CHUNK_PAST_1024
operator|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"This region cannot be used for your root partition as it starts\nor extends past the 1024'th cylinder mark and is thus a\npoor location to boot from.  Please choose another\nlocation for your root partition and try again!"
argument_list|)
expr_stmt|;
name|Delete_Chunk
argument_list|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|d
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
break|break;
block|}
name|tmp
operator|->
name|private
operator|=
name|p
expr_stmt|;
name|tmp
operator|->
name|private_free
operator|=
name|safe_free
expr_stmt|;
name|record_label_chunks
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'D'
case|:
comment|/* delete */
if|if
condition|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|type
operator|==
name|PART_SLICE
condition|)
block|{
name|msg
operator|=
name|MSG_NOT_APPLICABLE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|type
operator|==
name|PART_FAT
condition|)
block|{
name|msg
operator|=
literal|"Use the Disk Partition Editor to delete this"
expr_stmt|;
break|break;
block|}
name|Delete_Chunk
argument_list|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|d
argument_list|,
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
name|record_label_chunks
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* mount */
switch|switch
condition|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|type
condition|)
block|{
case|case
name|PART_SLICE
case|:
name|msg
operator|=
name|MSG_NOT_APPLICABLE
expr_stmt|;
break|break;
case|case
name|PART_SWAP
case|:
name|msg
operator|=
literal|"You don't need to specify a mountpoint for a swap partition."
expr_stmt|;
break|break;
case|case
name|PART_FAT
case|:
case|case
name|PART_FILESYSTEM
case|:
name|p
operator|=
name|get_mountpoint
argument_list|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|newfs
operator|=
name|FALSE
expr_stmt|;
name|record_label_chunks
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|msgFatal
argument_list|(
literal|"Bogus partition under cursor???"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'N'
case|:
comment|/* Set newfs options */
if|if
condition|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|c
operator|->
name|private
operator|&&
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|c
operator|->
name|private
operator|)
operator|->
name|newfs
condition|)
name|getNewfsCmd
argument_list|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|c
operator|->
name|private
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|MSG_NOT_APPLICABLE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* Toggle newfs state */
if|if
condition|(
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|type
operator|==
name|PART_FILESYSTEM
operator|&&
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|c
operator|->
name|private
condition|)
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|c
operator|->
name|private
operator|)
operator|->
name|newfs
operator|=
operator|!
operator|(
operator|(
name|PartInfo
operator|*
operator|)
name|label_chunk_info
index|[
name|here
index|]
operator|.
name|c
operator|->
name|private
operator|)
operator|->
name|newfs
expr_stmt|;
else|else
name|msg
operator|=
name|MSG_NOT_APPLICABLE
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|msgYesNo
argument_list|(
literal|"Are you sure you want to go into Wizard mode?\n\nThis is an entirely undocumented feature which you are not\nexpected to understand!"
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
name|DialogActive
operator|=
name|FALSE
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|devs
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Can't find any disk devicse!"
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
name|slice_wizard
argument_list|(
operator|(
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
operator|)
argument_list|)
expr_stmt|;
block|}
name|dialog_clear
argument_list|()
expr_stmt|;
name|DialogActive
operator|=
name|TRUE
expr_stmt|;
name|record_label_chunks
argument_list|()
expr_stmt|;
block|}
else|else
name|msg
operator|=
literal|"A most prudent choice!"
expr_stmt|;
break|break;
case|case
literal|27
case|:
comment|/* ESC */
name|labeling
operator|=
name|FALSE
expr_stmt|;
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
name|msg
operator|=
literal|"Type F1 or ? for help"
expr_stmt|;
break|break;
block|}
block|}
name|variable_set2
argument_list|(
name|DISK_LABELLED
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

