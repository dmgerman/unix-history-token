begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The new sysinstall program.  *  * This is probably the last program in the `sysinstall' line - the next  * generation being essentially a complete rewrite.  *  * $Id: install.c,v 1.65 1995/05/28 23:12:05 jkh Exp $  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,   *    verbatim and that no modifications are made prior to this   *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jordan Hubbard  *	for the FreeBSD Project.  * 4. The name of Jordan Hubbard or the FreeBSD project may not be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_decl_stmt
name|Boolean
name|SystemWasInstalled
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|make_filesystems
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_self
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|root_extract
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|Chunk
modifier|*
name|rootdev
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Boolean
name|checkLabels
parameter_list|(
name|void
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|swapdev
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
comment|/* First verify that we have a root device */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for root filesystem\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private
operator|&&
name|c2
operator|->
name|flags
operator|&
name|CHUNK_IS_ROOT
condition|)
block|{
name|rootdev
operator|=
name|c2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Now check for swap devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for swap partitions\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
block|{
name|swapdev
operator|=
name|c2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|rootdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No root device found - you must label a partition as /\n in the label editor."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|rootdev
operator|->
name|name
index|[
name|strlen
argument_list|(
name|rootdev
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'a'
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Invalid placement of root partition.  For now, we only support\nmounting root partitions on \"a\" partitions due to limitations\nin the FreeBSD boot block code.  Please correct this and\ntry again."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|swapdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No swap devices found - you must create at least one\nswap partition."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|Boolean
name|installInitial
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|u_char
name|boot1
index|[]
decl_stmt|,
name|boot2
index|[]
decl_stmt|;
specifier|extern
name|u_char
name|mbr
index|[]
decl_stmt|,
name|bteasy17
index|[]
decl_stmt|;
name|u_char
modifier|*
name|mbrContents
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|Boolean
name|alreadyDone
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|alreadyDone
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
name|getenv
argument_list|(
name|DISK_PARTITIONED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to partition your disk before you can proceed with\nthe installation."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|getenv
argument_list|(
name|DISK_LABELLED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to assign disk labels before you can proceed with\nthe installation."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|checkLabels
argument_list|()
condition|)
return|return
name|FALSE
return|;
comment|/* Figure out what kind of MBR the user wants */
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuMBRType
argument_list|)
expr_stmt|;
name|mbrContents
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
literal|"bootManager"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"bteasy"
argument_list|)
condition|)
name|mbrContents
operator|=
name|bteasy17
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"mbr"
argument_list|)
condition|)
name|mbrContents
operator|=
name|mbr
expr_stmt|;
block|}
comment|/* If we refuse to proceed, bail. */
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Last Chance!  Are you SURE you want continue the installation?\n\nIf you're running this on an existing system, we STRONGLY\nencourage you to make proper backups before proceeding.\nWe take no responsibility for lost disk contents!"
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|Chunk
modifier|*
name|c1
decl_stmt|;
name|Disk
modifier|*
name|d
init|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
if|if
condition|(
name|mbrContents
condition|)
block|{
name|Set_Boot_Mgr
argument_list|(
name|d
argument_list|,
name|mbrContents
argument_list|)
expr_stmt|;
name|mbrContents
operator|=
name|NULL
expr_stmt|;
block|}
name|Set_Boot_Blocks
argument_list|(
name|d
argument_list|,
name|boot1
argument_list|,
name|boot2
argument_list|)
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Writing partition information to drive %s"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|Write_Disk
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Now scan for bad blocks, if necessary */
for|for
control|(
name|c1
operator|=
name|d
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|flags
operator|&
name|CHUNK_BAD144
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|msgNotify
argument_list|(
literal|"Running bad block scan on partition %s"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vsystem
argument_list|(
literal|"bad144 -v /dev/r%s 1234"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|msgConfirm
argument_list|(
literal|"Bad144 init on %s returned status of %d!"
argument_list|,
name|c1
operator|->
name|name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vsystem
argument_list|(
literal|"bad144 -v -s /dev/r%s"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|msgConfirm
argument_list|(
literal|"Bad144 scan on %s returned status of %d!"
argument_list|,
name|c1
operator|->
name|name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|make_filesystems
argument_list|()
expr_stmt|;
name|copy_self
argument_list|()
expr_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
name|chroot
argument_list|(
literal|"/mnt"
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|variable_set2
argument_list|(
name|RUNNING_ON_ROOT
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
comment|/* stick a helpful shell over on the 4th VTY */
name|msgDebug
argument_list|(
literal|"Sticking a potentially helpful shell over on the 4th screen\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fork
argument_list|()
condition|)
block|{
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
specifier|extern
name|int
name|login_tty
argument_list|(
name|int
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/ttyv3"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSCTTY
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|login_tty
argument_list|(
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Can't set controlling terminal"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"-sh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|root_extract
argument_list|()
expr_stmt|;
name|alreadyDone
operator|=
name|TRUE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * What happens when we select "Install".  This is broken into a 3 stage installation so that  * the user can do a full installation but come back here again to load more distributions,  * perhaps from a different media type.  This would allow, for example, the user to load the  * majority of the system from CDROM and then use ftp to load just the DES dist.  */
end_comment

begin_function
name|int
name|installCommit
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|static
name|Boolean
name|hostsModified
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|Dists
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You haven't told me what distributions to load yet!\nPlease select a distribution from the Distributions menu."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|RunningAsInit
condition|)
block|{
if|if
condition|(
operator|!
name|installInitial
argument_list|()
condition|)
return|return
literal|0
return|;
name|configFstab
argument_list|()
expr_stmt|;
name|configResolv
argument_list|()
expr_stmt|;
block|}
name|distExtractAll
argument_list|()
expr_stmt|;
comment|/* Tack ourselves at the end of /etc/hosts */
if|if
condition|(
name|RunningAsInit
operator|&&
name|getenv
argument_list|(
name|VAR_IPADDR
argument_list|)
operator|&&
operator|!
name|hostsModified
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
literal|"/etc/hosts"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\t\t%s\n"
argument_list|,
name|getenv
argument_list|(
name|VAR_IPADDR
argument_list|)
argument_list|,
name|getenv
argument_list|(
name|VAR_HOSTNAME
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|hostsModified
operator|=
name|TRUE
expr_stmt|;
block|}
name|msgConfirm
argument_list|(
literal|"Installation completed successfully.\nHit return now to go back to the main menu."
argument_list|)
expr_stmt|;
name|SystemWasInstalled
operator|=
name|TRUE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Go newfs and/or mount all the filesystems we've been asked to */
end_comment

begin_function
specifier|static
name|void
name|make_filesystems
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|char
name|dname
index|[
literal|40
index|]
decl_stmt|;
name|PartInfo
modifier|*
name|p
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|rootdev
operator|->
name|private
decl_stmt|;
name|command_clear
argument_list|()
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
comment|/* First, create and mount the root device */
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: %s is marked as a root partition but is mounted on %s"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|,
name|p
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|newfs
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/r%sa"
argument_list|,
name|rootdev
operator|->
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Making a new root filesystem on %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"%s %s"
argument_list|,
name|p
operator|->
name|newfs_cmd
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make new root filesystem!  Command returned status %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|msgConfirm
argument_list|(
literal|"Warning:  You have selected a Read-Only root device\nand may be unable to find the appropriate device entries on it\nif it is from an older pre-slice version of FreeBSD."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/r%sa"
argument_list|,
name|rootdev
operator|->
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Checking integrity of existing %s filesystem"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"fsck -y %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: fsck returned status off %d - this partition may be\nunsafe to use."
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%sa"
argument_list|,
name|rootdev
operator|->
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mount
argument_list|(
literal|"/mnt"
argument_list|,
name|dname
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to mount the root file system!  Giving up."
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
specifier|extern
name|int
name|makedevs
argument_list|(
name|void
argument_list|)
decl_stmt|;
name|msgNotify
argument_list|(
literal|"Making device files"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mkdir
argument_list|(
literal|"/mnt/dev"
argument_list|,
name|NULL
argument_list|)
operator|||
name|chdir
argument_list|(
literal|"/mnt/dev"
argument_list|)
operator|||
name|makedevs
argument_list|()
condition|)
name|msgConfirm
argument_list|(
literal|"Failed to make some of the devices in /mnt!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mkdir
argument_list|(
literal|"/mnt/stand"
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make /mnt/stand directory!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
comment|/* Now buzz through the rest of the partitions and mount them too */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Make the proper device mount points in /mnt/dev */
name|MakeDevDisk
argument_list|(
name|disk
argument_list|,
literal|"/mnt/dev"
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private
condition|)
block|{
name|PartInfo
modifier|*
name|tmp
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tmp
operator|->
name|newfs
condition|)
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"%s /mnt/dev/r%s"
argument_list|,
name|tmp
operator|->
name|newfs_cmd
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"fsck -y /mnt/dev/r%s"
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|command_func_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
name|Mount
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
block|{
name|char
name|fname
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"/mnt/dev/%s"
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
name|swapon
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
name|msgNotify
argument_list|(
literal|"Added %s as a swap device"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
name|msgConfirm
argument_list|(
literal|"Unable to add %s as a swap device: %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|fat
condition|)
block|{
name|PartInfo
modifier|*
name|tmp
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|c1
operator|->
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
continue|continue;
name|command_func_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
name|Mount_DOS
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|command_sort
argument_list|()
expr_stmt|;
name|command_execute
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the boot floppy contents into /stand */
end_comment

begin_function
specifier|static
name|void
name|copy_self
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|msgWeHaveOutput
argument_list|(
literal|"Copying the boot floppy to /stand on root filesystem"
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"find -x /stand | cpio -pdmV /mnt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|msgConfirm
argument_list|(
literal|"Copy returned error status of %d!"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Copy the /etc files into their rightful place */
operator|(
name|void
operator|)
name|vsystem
argument_list|(
literal|"(cd /stand; find etc) | cpio -pdmv /mnt"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|loop_on_root_floppy
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|root_extract
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|OnCDROM
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
literal|"/floppies/root.flp"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mediaExtractDist
argument_list|(
literal|"root.flp"
argument_list|,
literal|"/"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mediaDevice
condition|)
block|{
switch|switch
condition|(
name|mediaDevice
operator|->
name|type
condition|)
block|{
case|case
name|DEVICE_TYPE_DOS
case|:
case|case
name|DEVICE_TYPE_FTP
case|:
case|case
name|DEVICE_TYPE_DISK
case|:
case|case
name|DEVICE_TYPE_NETWORK
case|:
case|case
name|DEVICE_TYPE_CDROM
case|:
if|if
condition|(
name|mediaDevice
operator|->
name|init
condition|)
if|if
condition|(
operator|!
call|(
modifier|*
name|mediaDevice
operator|->
name|init
call|)
argument_list|(
name|mediaDevice
argument_list|)
condition|)
break|break;
name|fd
operator|=
call|(
modifier|*
name|mediaDevice
operator|->
name|get
call|)
argument_list|(
literal|"floppies/root.flp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|msgNotify
argument_list|(
literal|"Loading root floppy from %s"
argument_list|,
name|mediaDevice
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mediaExtractDist
argument_list|(
literal|"root.flp"
argument_list|,
literal|"/"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mediaDevice
operator|->
name|close
condition|)
call|(
modifier|*
name|mediaDevice
operator|->
name|close
call|)
argument_list|(
name|mediaDevice
argument_list|,
name|fd
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mediaDevice
operator|->
name|shutdown
condition|)
call|(
modifier|*
name|mediaDevice
operator|->
name|shutdown
call|)
argument_list|(
name|mediaDevice
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mediaDevice
operator|->
name|shutdown
condition|)
call|(
modifier|*
name|mediaDevice
operator|->
name|shutdown
call|)
argument_list|(
name|mediaDevice
argument_list|)
expr_stmt|;
name|loop_on_root_floppy
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|DEVICE_TYPE_FLOPPY
case|:
default|default:
name|loop_on_root_floppy
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
else|else
name|loop_on_root_floppy
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|loop_on_root_floppy
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|getRootFloppy
argument_list|()
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
name|mediaExtractDist
argument_list|(
literal|"root.flp"
argument_list|,
literal|"/"
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

