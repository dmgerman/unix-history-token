begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * The new sysinstall program.  *  * This is probably the last program in the `sysinstall' line - the next  * generation being essentially a complete rewrite.  *  * $Id: install.c,v 1.47 1995/05/22 14:10:17 jkh Exp $  *  * Copyright (c) 1995  *	Jordan Hubbard.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,   *    verbatim and that no modifications are made prior to this   *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jordan Hubbard  *	for the FreeBSD Project.  * 4. The name of Jordan Hubbard or the FreeBSD project may not be used to  *    endorse or promote products derived from this software without specific  *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JORDAN HUBBARD ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL JORDAN HUBBARD OR HIS PETS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sysinstall.h"
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_decl_stmt
name|Boolean
name|SystemWasInstalled
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|make_filesystems
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_self
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cpio_extract
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_final_setup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|Disk
modifier|*
name|rootdisk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Chunk
modifier|*
name|rootdev
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|Boolean
name|checkLabels
parameter_list|(
name|void
parameter_list|)
block|{
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|,
modifier|*
name|swapdev
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
comment|/* First verify that we have a root device */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for root filesystem\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private
operator|&&
name|c2
operator|->
name|flags
operator|&
name|CHUNK_IS_ROOT
condition|)
block|{
name|rootdisk
operator|=
name|disk
expr_stmt|;
name|rootdev
operator|=
name|c2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* Now check for swap devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
name|msgDebug
argument_list|(
literal|"Scanning disk %s for swap partitions\n"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
block|{
name|swapdev
operator|=
name|c2
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|rootdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No root device found - you must label a partition as /\n in the label editor."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|!
name|swapdev
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"No swap devices found - you must create at least one\nswap partition."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|installInitial
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|u_char
name|boot1
index|[]
decl_stmt|,
name|boot2
index|[]
decl_stmt|;
specifier|extern
name|u_char
name|mbr
index|[]
decl_stmt|,
name|bteasy17
index|[]
decl_stmt|;
name|u_char
modifier|*
name|mbrContents
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|Boolean
name|alreadyDone
init|=
name|FALSE
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|alreadyDone
condition|)
return|return;
if|if
condition|(
operator|!
name|getenv
argument_list|(
name|DISK_PARTITIONED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to partition your disk before you can proceed with\nthe installation."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|getenv
argument_list|(
name|DISK_LABELLED
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You need to assign disk labels before you can proceed with\nthe installation."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|checkLabels
argument_list|()
condition|)
return|return;
comment|/* Figure out what kind of MBR the user wants */
name|dmenuOpenSimple
argument_list|(
operator|&
name|MenuMBRType
argument_list|)
expr_stmt|;
name|mbrContents
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
literal|"bootManager"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"bteasy"
argument_list|)
condition|)
name|mbrContents
operator|=
name|bteasy17
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"mbr"
argument_list|)
condition|)
name|mbrContents
operator|=
name|mbr
expr_stmt|;
block|}
comment|/* If we refuse to proceed, bail. */
if|if
condition|(
name|msgYesNo
argument_list|(
literal|"Last Chance!  Are you SURE you want continue the installation?\n\nIf you're running this on an existing system, we STRONGLY\nencourage you to make proper backups before proceeding.\nWe take no responsibility for lost disk contents!"
argument_list|)
condition|)
return|return;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|Chunk
modifier|*
name|c1
decl_stmt|;
name|Disk
modifier|*
name|d
init|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|devs
index|[
name|i
index|]
operator|->
name|enabled
condition|)
continue|continue;
if|if
condition|(
name|mbrContents
condition|)
block|{
name|Set_Boot_Mgr
argument_list|(
name|d
argument_list|,
name|mbrContents
argument_list|)
expr_stmt|;
name|mbrContents
operator|=
name|NULL
expr_stmt|;
block|}
name|Set_Boot_Blocks
argument_list|(
name|d
argument_list|,
name|boot1
argument_list|,
name|boot2
argument_list|)
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Writing partition information to drive %s"
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|Write_Disk
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Now scan for bad blocks, if necessary */
for|for
control|(
name|c1
operator|=
name|d
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|flags
operator|&
name|CHUNK_BAD144
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|msgNotify
argument_list|(
literal|"Running bad block scan on partition %s"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vsystem
argument_list|(
literal|"bad144 -v /dev/r%s 1234"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|msgConfirm
argument_list|(
literal|"Bad144 init on %s returned status of %d!"
argument_list|,
name|c1
operator|->
name|name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|ret
operator|=
name|vsystem
argument_list|(
literal|"bad144 -v -s /dev/r%s"
argument_list|,
name|c1
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|msgConfirm
argument_list|(
literal|"Bad144 scan on %s returned status of %d!"
argument_list|,
name|c1
operator|->
name|name
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|make_filesystems
argument_list|()
expr_stmt|;
name|copy_self
argument_list|()
expr_stmt|;
name|dialog_clear
argument_list|()
expr_stmt|;
name|chroot
argument_list|(
literal|"/mnt"
argument_list|)
expr_stmt|;
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|cpio_extract
argument_list|()
expr_stmt|;
name|alreadyDone
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|installFinal
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|Boolean
name|alreadyDone
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|alreadyDone
condition|)
return|return;
name|config_fstab
argument_list|()
expr_stmt|;
name|config_sysconfig
argument_list|()
expr_stmt|;
name|config_resolv
argument_list|()
expr_stmt|;
name|do_final_setup
argument_list|()
expr_stmt|;
name|alreadyDone
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * What happens when we select "GO".  This is broken into a 3 stage installation so that  * the user can do a full installation but come back here again to load more distributions,  * perhaps from a different media type.  This would allow, for example, the user to load the  * majority of the system from CDROM and then use ftp to load just the DES dist.  */
end_comment

begin_function
name|int
name|installCommit
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Dists
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"You haven't told me what distributions to load yet!\nPlease select a distribution from the Distributions menu."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|mediaVerify
argument_list|()
condition|)
return|return
literal|0
return|;
name|installInitial
argument_list|()
expr_stmt|;
name|distExtractAll
argument_list|()
expr_stmt|;
name|installFinal
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Go newfs and/or mount all the filesystems we've been asked to */
end_comment

begin_function
specifier|static
name|void
name|make_filesystems
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Disk
modifier|*
name|disk
decl_stmt|;
name|Chunk
modifier|*
name|c1
decl_stmt|,
modifier|*
name|c2
decl_stmt|;
name|Device
modifier|*
modifier|*
name|devs
decl_stmt|;
name|char
name|dname
index|[
literal|40
index|]
decl_stmt|;
name|PartInfo
modifier|*
name|p
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|rootdev
operator|->
name|private
decl_stmt|;
name|command_clear
argument_list|()
expr_stmt|;
name|devs
operator|=
name|deviceFind
argument_list|(
name|NULL
argument_list|,
name|DEVICE_TYPE_DISK
argument_list|)
expr_stmt|;
comment|/* First, create and mount the root device */
if|if
condition|(
name|strcmp
argument_list|(
name|p
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
name|msgConfirm
argument_list|(
literal|"Warning: %s is marked as a root partition but is mounted on %s"
argument_list|,
name|rootdev
operator|->
name|name
argument_list|,
name|p
operator|->
name|mountpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|newfs
condition|)
block|{
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/r%sa"
argument_list|,
name|rootdisk
operator|->
name|name
argument_list|)
expr_stmt|;
name|msgNotify
argument_list|(
literal|"Making a new root filesystem on %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"%s %s"
argument_list|,
name|p
operator|->
name|newfs_cmd
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make new root filesystem!  Command returned status %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|msgConfirm
argument_list|(
literal|"Warning:  You have selected a Read-Only root device\nand may be unable to find the appropriate device entries on it\nif it is from an older pre-slice version of FreeBSD."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dname
argument_list|,
literal|"/dev/%sa"
argument_list|,
name|rootdisk
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mount
argument_list|(
literal|"/mnt"
argument_list|,
name|dname
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to mount the root file system!  Giving up."
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
specifier|extern
name|int
name|makedevs
argument_list|(
name|void
argument_list|)
decl_stmt|;
name|msgNotify
argument_list|(
literal|"Making device files"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mkdir
argument_list|(
literal|"/mnt/dev"
argument_list|,
name|NULL
argument_list|)
operator|||
name|chdir
argument_list|(
literal|"/mnt/dev"
argument_list|)
operator|||
name|makedevs
argument_list|()
condition|)
name|msgConfirm
argument_list|(
literal|"Failed to make some of the devices in /mnt!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Mkdir
argument_list|(
literal|"/mnt/stand"
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Unable to make /mnt/stand directory!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
block|}
comment|/* Now buzz through the rest of the partitions and mount them too */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|devs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
operator|(
name|Disk
operator|*
operator|)
name|devs
index|[
name|i
index|]
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|chunks
condition|)
name|msgFatal
argument_list|(
literal|"No chunk list found for %s!"
argument_list|,
name|disk
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Make the proper device mount points in /mnt/dev */
name|MakeDevDisk
argument_list|(
name|disk
argument_list|,
literal|"/mnt/dev"
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|disk
operator|->
name|chunks
operator|->
name|part
init|;
name|c1
condition|;
name|c1
operator|=
name|c1
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c1
operator|->
name|type
operator|==
name|freebsd
condition|)
block|{
for|for
control|(
name|c2
operator|=
name|c1
operator|->
name|part
init|;
name|c2
condition|;
name|c2
operator|=
name|c2
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|!=
name|FS_SWAP
operator|&&
name|c2
operator|->
name|private
condition|)
block|{
name|PartInfo
modifier|*
name|tmp
init|=
operator|(
name|PartInfo
operator|*
operator|)
name|c2
operator|->
name|private
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"/"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tmp
operator|->
name|newfs
condition|)
name|command_shell_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
literal|"%s /mnt/dev/r%s"
argument_list|,
name|tmp
operator|->
name|newfs_cmd
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|command_func_add
argument_list|(
name|tmp
operator|->
name|mountpoint
argument_list|,
name|Mount
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|->
name|type
operator|==
name|part
operator|&&
name|c2
operator|->
name|subtype
operator|==
name|FS_SWAP
condition|)
block|{
name|char
name|fname
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|fname
argument_list|,
literal|"/mnt/dev/%s"
argument_list|,
name|c2
operator|->
name|name
argument_list|)
expr_stmt|;
name|i
operator|=
name|swapon
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
name|msgNotify
argument_list|(
literal|"Added %s as a swap device"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
name|msgConfirm
argument_list|(
literal|"Unable to add %s as a swap device: %s"
argument_list|,
name|fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|command_sort
argument_list|()
expr_stmt|;
name|command_execute
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the boot floppy contents into /stand */
end_comment

begin_function
specifier|static
name|void
name|copy_self
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|msgWeHaveOutput
argument_list|(
literal|"Copying the boot floppy to /stand on root filesystem"
argument_list|)
expr_stmt|;
name|i
operator|=
name|vsystem
argument_list|(
literal|"find -x /stand | cpio -pdmv /mnt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|msgConfirm
argument_list|(
literal|"Copy returned error status of %d!"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpio_extract
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|zpid
decl_stmt|,
name|cpid
decl_stmt|,
name|pfd
index|[
literal|2
index|]
decl_stmt|;
name|Boolean
name|onCDROM
init|=
name|FALSE
decl_stmt|;
if|#
directive|if
literal|0
block|if (mediaDevice&& mediaDevice->type == DEVICE_TYPE_CDROM) { 	if (mediaDevice->init) { 	    if ((*mediaDevice->init)(mediaDevice)) { 		CpioFD = open("/cdrom/floppies/cpio.flp", O_RDONLY); 		if (CpioFD != -1) { 		    msgNotify("Loading CPIO floppy from CDROM"); 		    onCDROM = TRUE; 		} 	    } 	}     }
endif|#
directive|endif
name|tryagain
label|:
while|while
condition|(
name|CpioFD
operator|==
operator|-
literal|1
condition|)
block|{
name|msgConfirm
argument_list|(
literal|"Please Insert CPIO floppy in floppy drive 0"
argument_list|)
expr_stmt|;
name|CpioFD
operator|=
name|open
argument_list|(
literal|"/dev/rfd0"
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|CpioFD
operator|>=
literal|0
condition|)
break|break;
name|msgDebug
argument_list|(
literal|"Error on open of cpio floppy: %s (%d)\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|j
condition|)
block|{
name|chdir
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|msgWeHaveOutput
argument_list|(
literal|"Extracting contents of CPIO floppy..."
argument_list|)
expr_stmt|;
name|pipe
argument_list|(
name|pfd
argument_list|)
expr_stmt|;
name|zpid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|zpid
condition|)
block|{
name|dup2
argument_list|(
name|CpioFD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|CpioFD
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|DebugFD
operator|!=
operator|-
literal|1
condition|)
name|dup2
argument_list|(
name|DebugFD
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
name|execl
argument_list|(
literal|"/stand/gunzip"
argument_list|,
literal|"/stand/gunzip"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msgDebug
argument_list|(
literal|"/stand/gunzip command returns %d status\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|cpid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cpid
condition|)
block|{
name|dup2
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|CpioFD
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|DebugFD
operator|!=
operator|-
literal|1
condition|)
block|{
name|dup2
argument_list|(
name|DebugFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|DebugFD
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|execl
argument_list|(
literal|"/stand/cpio"
argument_list|,
literal|"/stand/cpio"
argument_list|,
literal|"-iduvm"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|msgDebug
argument_list|(
literal|"/stand/cpio command returns %d status\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|pfd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pfd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|CpioFD
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitpid
argument_list|(
name|zpid
argument_list|,
operator|&
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Don't check status - gunzip seems to return a bogus one! */
name|dialog_clear
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"wait for gunzip returned status of %d!"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|waitpid
argument_list|(
name|cpid
argument_list|,
operator|&
name|j
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|WEXITSTATUS
argument_list|(
name|j
argument_list|)
condition|)
block|{
name|dialog_clear
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"cpio returned error status of %d!"
argument_list|,
name|WEXITSTATUS
argument_list|(
name|j
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|=
name|wait
argument_list|(
operator|&
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|WEXITSTATUS
argument_list|(
name|j
argument_list|)
operator|||
name|access
argument_list|(
literal|"/OK"
argument_list|,
name|R_OK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|dialog_clear
argument_list|()
expr_stmt|;
name|msgConfirm
argument_list|(
literal|"CPIO floppy did not extract properly!  Please verify\nthat your media is correct and try again."
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|CpioFD
argument_list|)
expr_stmt|;
name|CpioFD
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|unlink
argument_list|(
literal|"/OK"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|onCDROM
condition|)
name|msgConfirm
argument_list|(
literal|"Please remove the CPIO floppy from the drive"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_final_setup
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

end_unit

