begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Server Cache Synchronization Protocol (SCSP) Support  * ----------------------------------------------------  *  * HELLO finite state machine  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|RCSid
init|=
literal|"@(#) $FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<libatm.h>
end_include

begin_include
include|#
directive|include
file|"scsp_msg.h"
end_include

begin_include
include|#
directive|include
file|"scsp_if.h"
end_include

begin_include
include|#
directive|include
file|"scsp_var.h"
end_include

begin_comment
comment|/*  * HELLO FSM actions  */
end_comment

begin_define
define|#
directive|define
name|HELLO_ACTION_CNT
value|7
end_define

begin_decl_stmt
name|int
name|scsp_hello_act_00
name|__P
argument_list|(
operator|(
name|Scsp_dcs
operator|*
operator|,
name|Scsp_msg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsp_hello_act_01
name|__P
argument_list|(
operator|(
name|Scsp_dcs
operator|*
operator|,
name|Scsp_msg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsp_hello_act_02
name|__P
argument_list|(
operator|(
name|Scsp_dcs
operator|*
operator|,
name|Scsp_msg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsp_hello_act_03
name|__P
argument_list|(
operator|(
name|Scsp_dcs
operator|*
operator|,
name|Scsp_msg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsp_hello_act_04
name|__P
argument_list|(
operator|(
name|Scsp_dcs
operator|*
operator|,
name|Scsp_msg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsp_hello_act_05
name|__P
argument_list|(
operator|(
name|Scsp_dcs
operator|*
operator|,
name|Scsp_msg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scsp_hello_act_06
name|__P
argument_list|(
operator|(
name|Scsp_dcs
operator|*
operator|,
name|Scsp_msg
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|scsp_action_vector
index|[
name|HELLO_ACTION_CNT
index|]
function_decl|)
parameter_list|()
init|=
block|{
name|scsp_hello_act_00
operator|,
function_decl|scsp_hello_act_01
operator|,
function_decl|scsp_hello_act_02
operator|,
function_decl|scsp_hello_act_03
operator|,
function_decl|scsp_hello_act_04
operator|,
function_decl|scsp_hello_act_05
operator|,
function_decl|scsp_hello_act_06
end_function_decl

begin_comment
unit|};
comment|/*  * HELLO FSM state table  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hello_state_table
index|[
name|SCSP_HFSM_EVENT_CNT
index|]
index|[
name|SCSP_HFSM_STATE_CNT
index|]
init|=
block|{
comment|/* 0  1  2  3		     */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0 */
block|{
literal|0
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* 1 */
block|{
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|}
block|,
comment|/* 2 */
block|{
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|4
block|}
block|,
comment|/* 3 */
block|{
literal|0
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|}
block|,
comment|/* 4 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * HELLO finite state machine  *  * Arguments:  *	dcsp	pointer to a DCS control block for the neighbor  *	event	the event which has occurred  *	msg	pointer to received message, if there is one  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_hfsm
parameter_list|(
name|dcsp
parameter_list|,
name|event
parameter_list|,
name|msg
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|int
name|event
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|action
decl_stmt|,
name|rc
decl_stmt|,
name|state
decl_stmt|;
comment|/* 	 * Select an action from the state table 	 */
name|state
operator|=
name|dcsp
operator|->
name|sd_hello_state
expr_stmt|;
name|action
operator|=
name|hello_state_table
index|[
name|event
index|]
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|scsp_trace_mode
operator|&
name|SCSP_TRACE_HFSM
condition|)
block|{
name|scsp_trace
argument_list|(
literal|"HFSM: state=%d, event=%d, action=%d\n"
argument_list|,
name|state
argument_list|,
name|event
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|>=
name|HELLO_ACTION_CNT
operator|||
name|action
operator|<=
literal|0
condition|)
block|{
name|scsp_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Hello FSM--invalid action %d; state=%d, event=%d"
argument_list|,
name|action
argument_list|,
name|dcsp
operator|->
name|sd_hello_state
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Perform the selected action 	 */
name|rc
operator|=
name|scsp_action_vector
index|[
name|action
index|]
operator|(
name|dcsp
operator|,
name|msg
operator|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HELLO finite state machine action 0  * Unexpected action -- log an error message  *  * Arguments:  *	dcsp	pointer to DCS control block  *	msg	pointer to received message (ignored)  *  * Returns:  *	EOPNOTSUPP	always returns EOPNOTSUPP  *  */
end_comment

begin_function
name|int
name|scsp_hello_act_00
parameter_list|(
name|dcsp
parameter_list|,
name|msg
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|scsp_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Hello FSM error--unexpected action, state=%d"
argument_list|,
name|dcsp
operator|->
name|sd_hello_state
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HELLO finite state machine action 1  * VCC open -- send HELLO message, start hello timer, go to Waiting  * state  *  * Arguments:  *	dcsp	pointer to DCS control block  *	msg	pointer to received message (ignored)  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_hello_act_01
parameter_list|(
name|dcsp
parameter_list|,
name|msg
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
comment|/* 	 * Cancel the VCC open timer if it's running 	 */
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_open_t
argument_list|)
expr_stmt|;
comment|/* 	 * Go to Waiting state 	 */
name|dcsp
operator|->
name|sd_hello_state
operator|=
name|SCSP_HFSM_WAITING
expr_stmt|;
comment|/* 	 * Send a Hello message 	 */
name|rc
operator|=
name|scsp_send_hello
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Success--start the Hello timer 		 */
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_h_t
argument_list|,
name|SCSP_HELLO_Interval
argument_list|,
name|scsp_hello_timeout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HELLO finite state machine action 2  * VCC closed -- notify CA FSM, go to Down state, try to re-open VCC  *  * Arguments:  *	dcsp	pointer to DCS control block  *	msg	pointer to received message (ignored)  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_hello_act_02
parameter_list|(
name|dcsp
parameter_list|,
name|msg
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
comment|/* 	 * Cancel any current timers 	 */
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_h_t
argument_list|)
expr_stmt|;
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_rcv_t
argument_list|)
expr_stmt|;
comment|/* 	 * Log the loss of the VCC 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_hello_state
operator|>
name|SCSP_HFSM_WAITING
condition|)
block|{
name|scsp_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"VC to %s closed"
argument_list|,
name|format_atm_addr
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Tell the CA FSM that the conection to the DCS is lost 	 */
name|rc
operator|=
name|scsp_cafsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CAFSM_HELLO_DOWN
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Go to Down state 	 */
name|dcsp
operator|->
name|sd_hello_state
operator|=
name|SCSP_HFSM_DOWN
expr_stmt|;
comment|/* 	 * If our ID is lower than the DCS's, wait a second before 	 * trying to connect.  This should keep both of us from 	 * trying to connect at the same time, resulting in two 	 * VCCs being open. 	 */
if|if
condition|(
name|scsp_cmp_id
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_lsid
argument_list|,
operator|&
name|dcsp
operator|->
name|sd_dcsid
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Our ID is lower--start the VCC open timer for one 		 * second so we'll try to open the VCC if the DCS 		 * doesn't do it by then 		 */
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_open_t
argument_list|,
literal|1
argument_list|,
name|scsp_open_timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Our ID is higher--try to reopen the VCC immediately 		 */
if|if
condition|(
name|scsp_dcs_connect
argument_list|(
name|dcsp
argument_list|)
condition|)
block|{
comment|/* 			 * Conncect failed -- set a timer and try 			 * again later 			 */
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_open_t
argument_list|,
name|SCSP_Open_Interval
argument_list|,
name|scsp_open_timeout
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HELLO finite state machine action 3  * Hello timer expired -- send HELLO message, restart hello timer  *  * Arguments:  *	dcsp	pointer to DCS control block  *	msg	pointer to received message (ignored)  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_hello_act_03
parameter_list|(
name|dcsp
parameter_list|,
name|msg
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
comment|/* 	 * Send a Hello message 	 */
name|rc
operator|=
name|scsp_send_hello
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Success--restart the Hello timer 		 */
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_h_t
argument_list|,
name|SCSP_HELLO_Interval
argument_list|,
name|scsp_hello_timeout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HELLO finite state machine action 4  * Receive timer expired -- if we haven't received any Hellos, notify  * CA FSM and go to Waiting state;  if we've received Hellos, but we  * weren't in the receiver ID list, go to Unidirectional state  *  * Arguments:  *	dcsp	pointer to DCS control block  *	msg	pointer to received message (ignored)  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_hello_act_04
parameter_list|(
name|dcsp
parameter_list|,
name|msg
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
comment|/* 	 * Check whether we'ver received any Hellos lately 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_hello_rcvd
condition|)
block|{
comment|/* 		 * We've had Hellos since the receive timer was 		 * started--go to Unidirectional state 		 */
name|dcsp
operator|->
name|sd_hello_rcvd
operator|=
literal|0
expr_stmt|;
name|dcsp
operator|->
name|sd_hello_state
operator|=
name|SCSP_HFSM_UNI_DIR
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We haven't seen any Hellos at all from the DCS in 		 * hello_interval * dead_factor seconds--go to Waiting 		 * state 		 */
name|dcsp
operator|->
name|sd_hello_state
operator|=
name|SCSP_HFSM_WAITING
expr_stmt|;
block|}
comment|/* 	 * Notify the CA FSM 	 */
name|rc
operator|=
name|scsp_cafsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CAFSM_HELLO_DOWN
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HELLO finite state machine action 5  * Message received -- Ignore all but HELLO messages;  if local server  * is in receiver list, notify CA FSM and go to Bidirectional state;  * otherwise, go to Unidirectional state  *  * Arguments:  *	dcsp	pointer to DCS control block  *	msg	pointer to received message  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_hello_act_05
parameter_list|(
name|dcsp
parameter_list|,
name|msg
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|Scsp_id
modifier|*
name|ridp
decl_stmt|;
comment|/* 	 * Null message pointer means message decode failed, so 	 * message must have been invalid.  Go to Waiting state. 	 */
if|if
condition|(
name|msg
operator|==
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
condition|)
block|{
name|dcsp
operator|->
name|sd_hello_state
operator|=
name|SCSP_HFSM_WAITING
expr_stmt|;
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_rcv_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Ignore the message if it isn't a Hello 	 */
if|if
condition|(
name|msg
operator|->
name|sc_msg_type
operator|!=
name|SCSP_HELLO_MSG
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Save relevant information about DCS, but don't let him give 	 * us zero for timeout values 	 */
if|if
condition|(
name|msg
operator|->
name|sc_hello
operator|->
name|hello_int
condition|)
block|{
name|dcsp
operator|->
name|sd_hello_int
operator|=
name|msg
operator|->
name|sc_hello
operator|->
name|hello_int
expr_stmt|;
block|}
else|else
block|{
name|dcsp
operator|->
name|sd_hello_int
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|sc_hello
operator|->
name|dead_factor
condition|)
block|{
name|dcsp
operator|->
name|sd_hello_df
operator|=
name|msg
operator|->
name|sc_hello
operator|->
name|dead_factor
expr_stmt|;
block|}
else|else
block|{
name|dcsp
operator|->
name|sd_hello_df
operator|=
literal|1
expr_stmt|;
block|}
name|dcsp
operator|->
name|sd_dcsid
operator|=
name|msg
operator|->
name|sc_hello
operator|->
name|hello_mcp
operator|.
name|sid
expr_stmt|;
comment|/* 	 * Check the message for the local server's ID 	 */
for|for
control|(
name|ridp
operator|=
operator|&
name|msg
operator|->
name|sc_hello
operator|->
name|hello_mcp
operator|.
name|rid
init|;
name|ridp
condition|;
name|ridp
operator|=
name|ridp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|scsp_cmp_id
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_lsid
argument_list|,
name|ridp
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Cancel and restart the receive timer 			 */
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_rcv_t
argument_list|)
expr_stmt|;
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_rcv_t
argument_list|,
name|dcsp
operator|->
name|sd_hello_int
operator|*
name|dcsp
operator|->
name|sd_hello_df
argument_list|,
name|scsp_hello_rcv_timeout
argument_list|)
expr_stmt|;
comment|/* 			 * Go to Bidirectional state and notify the 			 * CA FSM that the connection is up 			 */
name|dcsp
operator|->
name|sd_hello_state
operator|=
name|SCSP_HFSM_BI_DIR
expr_stmt|;
name|rc
operator|=
name|scsp_cafsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CAFSM_HELLO_UP
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
comment|/* 	 * We weren't in the receiver ID list, so go to 	 * Unidirectional state 	 */
name|dcsp
operator|->
name|sd_hello_state
operator|=
name|SCSP_HFSM_UNI_DIR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HELLO finite state machine action 6  * Message received -- if message is not a HELLO, pass it to the CA  * FSM;  otherwise, if local server is not in receiver list, notify  * CA FSM and go to Unidirectional state  *  * Arguments:  *	dcsp	pointer to DCS control block  *	msg	pointer to received message  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_hello_act_06
parameter_list|(
name|dcsp
parameter_list|,
name|msg
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|rcv_found
decl_stmt|;
name|Scsp_id
modifier|*
name|ridp
decl_stmt|;
comment|/* 	 * Null message pointer means message decode failed, so 	 * message must have been invalid.  Go to Waiting state. 	 */
if|if
condition|(
name|msg
operator|==
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
condition|)
block|{
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_rcv_t
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_hello_state
operator|=
name|SCSP_HFSM_WAITING
expr_stmt|;
name|rc
operator|=
name|scsp_cafsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CAFSM_HELLO_DOWN
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* 	 * Process the message depending on its type 	 */
switch|switch
condition|(
name|msg
operator|->
name|sc_msg_type
condition|)
block|{
case|case
name|SCSP_CA_MSG
case|:
name|rc
operator|=
name|scsp_cafsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CAFSM_CA_MSG
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSP_CSU_REQ_MSG
case|:
name|rc
operator|=
name|scsp_cafsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CAFSM_CSU_REQ
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSP_CSU_REPLY_MSG
case|:
name|rc
operator|=
name|scsp_cafsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CAFSM_CSU_REPLY
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSP_CSUS_MSG
case|:
name|rc
operator|=
name|scsp_cafsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CAFSM_CSUS_MSG
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSP_HELLO_MSG
case|:
comment|/* 		 * Make sure DCS info is consistent.  The sender ID, 		 * family ID, protocol ID, and server group ID are 		 * checked. 		 */
if|if
condition|(
name|scsp_cmp_id
argument_list|(
operator|&
name|msg
operator|->
name|sc_hello
operator|->
name|hello_mcp
operator|.
name|sid
argument_list|,
operator|&
name|dcsp
operator|->
name|sd_dcsid
argument_list|)
operator|||
operator|(
name|msg
operator|->
name|sc_hello
operator|->
name|family_id
operator|!=
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_fid
operator|)
operator|||
operator|(
name|msg
operator|->
name|sc_hello
operator|->
name|hello_mcp
operator|.
name|pid
operator|!=
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_pid
operator|)
operator|||
operator|(
name|msg
operator|->
name|sc_hello
operator|->
name|hello_mcp
operator|.
name|sgid
operator|!=
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_sgid
operator|)
condition|)
block|{
comment|/* 			 * Bad info--revert to waiting state 			 */
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_rcv_t
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_hello_state
operator|=
name|SCSP_HFSM_WAITING
expr_stmt|;
name|rc
operator|=
name|scsp_cafsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_CAFSM_HELLO_DOWN
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
comment|/* 		 * Mark the arrival of the Hello message 		 */
name|dcsp
operator|->
name|sd_hello_rcvd
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Check the message for the local server's ID 		 */
name|rc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ridp
operator|=
operator|&
name|msg
operator|->
name|sc_hello
operator|->
name|hello_mcp
operator|.
name|rid
operator|,
name|rcv_found
operator|=
literal|0
init|;
name|ridp
condition|;
name|ridp
operator|=
name|ridp
operator|->
name|next
control|)
block|{
name|rcv_found
operator|=
operator|(
name|scsp_cmp_id
argument_list|(
name|ridp
argument_list|,
operator|&
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_lsid
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|rcv_found
condition|)
block|{
comment|/* 			 * The LS ID was in the list of receiver IDs-- 			 * Reset the Hello receive timer 			 */
name|dcsp
operator|->
name|sd_hello_rcvd
operator|=
literal|0
expr_stmt|;
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_rcv_t
argument_list|)
expr_stmt|;
name|HARP_TIMER
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_rcv_t
argument_list|,
name|dcsp
operator|->
name|sd_hello_int
operator|*
name|dcsp
operator|->
name|sd_hello_df
argument_list|,
name|scsp_hello_rcv_timeout
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

