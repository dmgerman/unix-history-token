begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Server Cache Synchronization Protocol (SCSP) Support  * ----------------------------------------------------  *  * SCSP subroutines  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sigmgr.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<netatm/uni/unisig_var.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libatm.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"scsp_msg.h"
end_include

begin_include
include|#
directive|include
file|"scsp_if.h"
end_include

begin_include
include|#
directive|include
file|"scsp_var.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Hash an SCSP cache key  *  * Arguments:  *	ckp	pointer to an SCSP cache key structure  *  * Returns:  *	hashed value  *  */
end_comment

begin_function
name|int
name|scsp_hash
parameter_list|(
name|ckp
parameter_list|)
name|Scsp_ckey
modifier|*
name|ckp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|h
decl_stmt|;
comment|/* 	 * Turn cache key into a positive integer 	 */
name|h
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ckp
operator|->
name|key_len
operator|-
literal|1
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|>
literal|0
operator|&&
name|j
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|--
operator|,
name|j
operator|++
control|)
name|h
operator|=
operator|(
name|h
operator|<<
literal|8
operator|)
operator|+
name|ckp
operator|->
name|key
index|[
name|i
index|]
expr_stmt|;
name|h
operator|=
name|abs
argument_list|(
name|h
argument_list|)
expr_stmt|;
comment|/* 	 * Return the hashed value 	 */
return|return
operator|(
name|h
operator|%
name|SCSP_HASHSZ
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two SCSP IDs  *  * Arguments:  *	id1p	pointer to an SCSP ID structure  *	id2p	pointer to an SCSP ID structure  *  * Returns:  *< 0	id1 is less than id2  *	0	id1 and id2 are equal  *> 0	id1 is greater than id2  *  */
end_comment

begin_function
name|int
name|scsp_cmp_id
parameter_list|(
name|id1p
parameter_list|,
name|id2p
parameter_list|)
name|Scsp_id
modifier|*
name|id1p
decl_stmt|;
name|Scsp_id
modifier|*
name|id2p
decl_stmt|;
block|{
name|int
name|diff
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Compare the two IDs, byte for byte 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|id1p
operator|->
name|id_len
operator|&&
name|i
operator|<
name|id2p
operator|->
name|id_len
condition|;
name|i
operator|++
control|)
block|{
name|diff
operator|=
name|id1p
operator|->
name|id
index|[
name|i
index|]
operator|-
name|id2p
operator|->
name|id
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
return|return
operator|(
name|diff
operator|)
return|;
block|}
block|}
comment|/* 	 * IDs are equal.  If lengths differ, the longer ID is 	 * greater than the shorter. 	 */
return|return
operator|(
name|id1p
operator|->
name|id_len
operator|-
name|id2p
operator|->
name|id_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two SCSP cache keys  *  * Arguments:  *	ck1p	pointer to an SCSP cache key structure  *	ck2p	pointer to an SCSP cache key structure  *  * Returns:  *< 0	ck1 is less than ck2  *	0	ck1 and ck2 are equal  *> 0	ck1 is greater than ck2  *  */
end_comment

begin_function
name|int
name|scsp_cmp_key
parameter_list|(
name|ck1p
parameter_list|,
name|ck2p
parameter_list|)
name|Scsp_ckey
modifier|*
name|ck1p
decl_stmt|;
name|Scsp_ckey
modifier|*
name|ck2p
decl_stmt|;
block|{
name|int
name|diff
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Compare the two keys, byte for byte 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ck1p
operator|->
name|key_len
operator|&&
name|i
operator|<
name|ck2p
operator|->
name|key_len
condition|;
name|i
operator|++
control|)
block|{
name|diff
operator|=
name|ck1p
operator|->
name|key
index|[
name|i
index|]
operator|-
name|ck2p
operator|->
name|key
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
operator|(
name|diff
operator|)
return|;
block|}
comment|/* 	 * Keys are equal.  If lengths differ, the longer key is 	 * greater than the shorter. 	 */
return|return
operator|(
name|ck1p
operator|->
name|key_len
operator|-
name|ck2p
operator|->
name|key_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether the host system is an ATMARP server for  * the LIS associated with a given interface  *  * Arguments:  *	netif	pointer to the network interface name  *  * Returns:  *	1	host is a server  *	0	host is not a server  *  */
end_comment

begin_function
name|int
name|scsp_is_atmarp_server
parameter_list|(
name|netif
parameter_list|)
name|char
modifier|*
name|netif
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|int
name|buf_len
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_asrv_rsp
argument_list|)
decl_stmt|;
name|struct
name|atminfreq
name|air
decl_stmt|;
name|struct
name|air_asrv_rsp
modifier|*
name|asrv_info
decl_stmt|;
comment|/* 	 * Get interface information from the kernel 	 */
name|strcpy
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|,
name|netif
argument_list|)
expr_stmt|;
name|air
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_ASV
expr_stmt|;
name|buf_len
operator|=
name|do_info_ioctl
argument_list|(
operator|&
name|air
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_len
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Check the interface's ATMARP server address 	 */
name|asrv_info
operator|=
operator|(
expr|struct
name|air_asrv_rsp
operator|*
operator|)
name|air
operator|.
name|air_buf_addr
expr_stmt|;
name|rc
operator|=
operator|(
name|asrv_info
operator|->
name|asp_addr
operator|.
name|address_format
operator|==
name|T_ATM_ABSENT
operator|)
operator|&&
operator|(
name|asrv_info
operator|->
name|asp_subaddr
operator|.
name|address_format
operator|==
name|T_ATM_ABSENT
operator|)
expr_stmt|;
name|UM_FREE
argument_list|(
name|asrv_info
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a copy of a cache summary entry  *  * Arguments:  *	csep	pointer to CSE entry to copy  *  * Returns:  *	0	copy failed  *	else	pointer to new CSE entry  *  */
end_comment

begin_function
name|Scsp_cse
modifier|*
name|scsp_dup_cse
parameter_list|(
name|csep
parameter_list|)
name|Scsp_cse
modifier|*
name|csep
decl_stmt|;
block|{
name|Scsp_cse
modifier|*
name|dupp
decl_stmt|;
comment|/* 	 * Allocate memory for the duplicate 	 */
name|dupp
operator|=
operator|(
name|Scsp_cse
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_cse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dupp
condition|)
block|{
name|scsp_mem_err
argument_list|(
literal|"scsp_dup_cse: sizeof(Scsp_cse)"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy data to the duplicate 	 */
name|UM_COPY
argument_list|(
name|csep
argument_list|,
name|dupp
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_cse
argument_list|)
argument_list|)
expr_stmt|;
name|dupp
operator|->
name|sc_next
operator|=
operator|(
name|Scsp_cse
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
name|dupp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a copy of a CSA or CSAS record  *  * Arguments:  *	csap	pointer to CSE entry to copy  *  * Returns:  *	0	copy failed  *	else	pointer to new CSA or CSAS record  *  */
end_comment

begin_function
name|Scsp_csa
modifier|*
name|scsp_dup_csa
parameter_list|(
name|csap
parameter_list|)
name|Scsp_csa
modifier|*
name|csap
decl_stmt|;
block|{
name|Scsp_csa
modifier|*
name|dupp
decl_stmt|;
name|Scsp_atmarp_csa
modifier|*
name|adp
decl_stmt|;
comment|/* 	 * Allocate memory for the duplicate 	 */
name|dupp
operator|=
operator|(
name|Scsp_csa
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_csa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dupp
condition|)
block|{
name|scsp_mem_err
argument_list|(
literal|"scsp_dup_csa: sizeof(Scsp_csa)"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy data to the duplicate 	 */
name|UM_COPY
argument_list|(
name|csap
argument_list|,
name|dupp
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_csa
argument_list|)
argument_list|)
expr_stmt|;
name|dupp
operator|->
name|next
operator|=
operator|(
name|Scsp_csa
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* 	 * Copy protocol-specific data, if it's present 	 */
if|if
condition|(
name|csap
operator|->
name|atmarp_data
condition|)
block|{
name|adp
operator|=
operator|(
name|Scsp_atmarp_csa
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_atmarp_csa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adp
condition|)
block|{
name|scsp_mem_err
argument_list|(
literal|"scsp_dup_csa: sizeof(Scsp_atmarp_csa)"
argument_list|)
expr_stmt|;
block|}
name|UM_COPY
argument_list|(
name|csap
operator|->
name|atmarp_data
argument_list|,
name|adp
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_atmarp_csa
argument_list|)
argument_list|)
expr_stmt|;
name|dupp
operator|->
name|atmarp_data
operator|=
name|adp
expr_stmt|;
block|}
return|return
operator|(
name|dupp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a cache summary entry into a CSAS  *  * Arguments:  *	csep	pointer to CSE entry to copy  *  * Returns:  *	0	copy failed  *	else	pointer to CSAS record summarizing the entry  *  */
end_comment

begin_function
name|Scsp_csa
modifier|*
name|scsp_cse2csas
parameter_list|(
name|csep
parameter_list|)
name|Scsp_cse
modifier|*
name|csep
decl_stmt|;
block|{
name|Scsp_csa
modifier|*
name|csap
decl_stmt|;
comment|/* 	 * Allocate memory for the duplicate 	 */
name|csap
operator|=
operator|(
name|Scsp_csa
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_csa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csap
condition|)
block|{
name|scsp_mem_err
argument_list|(
literal|"scsp_cse2csas: sizeof(Scsp_csa)"
argument_list|)
expr_stmt|;
block|}
name|UM_ZERO
argument_list|(
name|csap
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_csa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy data to the CSAS entry 	 */
name|csap
operator|->
name|seq
operator|=
name|csep
operator|->
name|sc_seq
expr_stmt|;
name|csap
operator|->
name|key
operator|=
name|csep
operator|->
name|sc_key
expr_stmt|;
name|csap
operator|->
name|oid
operator|=
name|csep
operator|->
name|sc_oid
expr_stmt|;
return|return
operator|(
name|csap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy an ATMARP cache entry into a cache summary entry  *  * Arguments:  *	aap	pointer to ATMARP cache entry to copy  *  * Returns:  *	0	copy failed  *	else	pointer to CSE record summarizing the entry  *  */
end_comment

begin_function
name|Scsp_cse
modifier|*
name|scsp_atmarp2cse
parameter_list|(
name|aap
parameter_list|)
name|Scsp_atmarp_msg
modifier|*
name|aap
decl_stmt|;
block|{
name|Scsp_cse
modifier|*
name|csep
decl_stmt|;
comment|/* 	 * Allocate memory for the duplicate 	 */
name|csep
operator|=
operator|(
name|Scsp_cse
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_cse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csep
condition|)
block|{
name|scsp_mem_err
argument_list|(
literal|"scsp_atmarp2cse: sizeof(Scsp_cse)"
argument_list|)
expr_stmt|;
block|}
name|UM_ZERO
argument_list|(
name|csep
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_cse
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy data to the CSE entry 	 */
name|csep
operator|->
name|sc_seq
operator|=
name|aap
operator|->
name|sa_seq
expr_stmt|;
name|csep
operator|->
name|sc_key
operator|=
name|aap
operator|->
name|sa_key
expr_stmt|;
name|csep
operator|->
name|sc_oid
operator|=
name|aap
operator|->
name|sa_oid
expr_stmt|;
return|return
operator|(
name|csep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up a DCS block.  This routine is called to clear out any  * lingering state information when the CA FSM reverts to an 'earlier'  * state (Down or Master/Slave Negotiation).  *  * Arguments:  *	dcsp	pointer to a DCS control block for the neighbor  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|scsp_dcs_cleanup
parameter_list|(
name|dcsp
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
block|{
name|Scsp_cse
modifier|*
name|csep
decl_stmt|,
modifier|*
name|ncsep
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
decl_stmt|,
modifier|*
name|next_csap
decl_stmt|;
name|Scsp_csu_rexmt
modifier|*
name|rxp
decl_stmt|,
modifier|*
name|rx_next
decl_stmt|;
comment|/* 	 * Free any CSAS entries waiting to be sent 	 */
for|for
control|(
name|csep
operator|=
name|dcsp
operator|->
name|sd_ca_csas
init|;
name|csep
condition|;
name|csep
operator|=
name|ncsep
control|)
block|{
name|ncsep
operator|=
name|csep
operator|->
name|sc_next
expr_stmt|;
name|UNLINK
argument_list|(
name|csep
argument_list|,
name|Scsp_cse
argument_list|,
name|dcsp
operator|->
name|sd_ca_csas
argument_list|,
name|sc_next
argument_list|)
expr_stmt|;
name|UM_FREE
argument_list|(
name|csep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free any entries on the CRL 	 */
for|for
control|(
name|csap
operator|=
name|dcsp
operator|->
name|sd_crl
init|;
name|csap
condition|;
name|csap
operator|=
name|next_csap
control|)
block|{
name|next_csap
operator|=
name|csap
operator|->
name|next
expr_stmt|;
name|UNLINK
argument_list|(
name|csap
argument_list|,
name|Scsp_csa
argument_list|,
name|dcsp
operator|->
name|sd_crl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free any saved CA message and cancel the CA 	 * retransmission timer 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
condition|)
block|{
name|scsp_free_msg
argument_list|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_ca_rexmt_msg
operator|=
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|)
expr_stmt|;
comment|/* 	 * Free any saved CSU Solicit message and cancel the CSUS 	 * retransmission timer 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_csus_rexmt_msg
condition|)
block|{
name|scsp_free_msg
argument_list|(
name|dcsp
operator|->
name|sd_csus_rexmt_msg
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_csus_rexmt_msg
operator|=
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_csus_rexmt_t
argument_list|)
expr_stmt|;
comment|/* 	 * Free any entries on the CSU Request retransmission queue 	 */
for|for
control|(
name|rxp
operator|=
name|dcsp
operator|->
name|sd_csu_rexmt
init|;
name|rxp
condition|;
name|rxp
operator|=
name|rx_next
control|)
block|{
name|rx_next
operator|=
name|rxp
operator|->
name|sr_next
expr_stmt|;
name|HARP_CANCEL
argument_list|(
operator|&
name|rxp
operator|->
name|sr_t
argument_list|)
expr_stmt|;
for|for
control|(
name|csap
operator|=
name|rxp
operator|->
name|sr_csa
init|;
name|csap
condition|;
name|csap
operator|=
name|next_csap
control|)
block|{
name|next_csap
operator|=
name|csap
operator|->
name|next
expr_stmt|;
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
block|}
name|UNLINK
argument_list|(
name|rxp
argument_list|,
name|Scsp_csu_rexmt
argument_list|,
name|dcsp
operator|->
name|sd_csu_rexmt
argument_list|,
name|sr_next
argument_list|)
expr_stmt|;
name|UM_FREE
argument_list|(
name|rxp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete an SCSP DCS block and any associated information  *  * Arguments:  *	dcsp	pointer to a DCS control block to delete  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|scsp_dcs_delete
parameter_list|(
name|dcsp
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
block|{
name|Scsp_cse
modifier|*
name|csep
decl_stmt|,
modifier|*
name|next_cse
decl_stmt|;
name|Scsp_csu_rexmt
modifier|*
name|rxp
decl_stmt|,
modifier|*
name|next_rxp
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
decl_stmt|,
modifier|*
name|next_csa
decl_stmt|;
comment|/* 	 * Cancel any pending DCS timers 	 */
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_open_t
argument_list|)
expr_stmt|;
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_h_t
argument_list|)
expr_stmt|;
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_rcv_t
argument_list|)
expr_stmt|;
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_ca_rexmt_t
argument_list|)
expr_stmt|;
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_csus_rexmt_t
argument_list|)
expr_stmt|;
comment|/* 	 * Unlink the DCS block from the server block 	 */
name|UNLINK
argument_list|(
name|dcsp
argument_list|,
name|Scsp_dcs
argument_list|,
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_dcs
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
comment|/* 	 * Close the VCC to the DCS, if one is open 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_sock
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|dcsp
operator|->
name|sd_sock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free any saved CA message 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
condition|)
block|{
name|scsp_free_msg
argument_list|(
name|dcsp
operator|->
name|sd_ca_rexmt_msg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free any pending CSAs waiting for cache alignment 	 */
for|for
control|(
name|csep
operator|=
name|dcsp
operator|->
name|sd_ca_csas
init|;
name|csep
condition|;
name|csep
operator|=
name|next_cse
control|)
block|{
name|next_cse
operator|=
name|csep
operator|->
name|sc_next
expr_stmt|;
name|UM_FREE
argument_list|(
name|csep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free anything on the cache request list 	 */
for|for
control|(
name|csap
operator|=
name|dcsp
operator|->
name|sd_crl
init|;
name|csap
condition|;
name|csap
operator|=
name|next_csa
control|)
block|{
name|next_csa
operator|=
name|csap
operator|->
name|next
expr_stmt|;
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free any saved CSUS message 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_csus_rexmt_msg
condition|)
block|{
name|scsp_free_msg
argument_list|(
name|dcsp
operator|->
name|sd_csus_rexmt_msg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free anything on the CSU Request retransmit queue 	 */
for|for
control|(
name|rxp
operator|=
name|dcsp
operator|->
name|sd_csu_rexmt
init|;
name|rxp
condition|;
name|rxp
operator|=
name|next_rxp
control|)
block|{
comment|/* 		 * Cancel the retransmit timer 		 */
name|HARP_CANCEL
argument_list|(
operator|&
name|rxp
operator|->
name|sr_t
argument_list|)
expr_stmt|;
comment|/* 		 * Free the CSAs to be retransmitted 		 */
for|for
control|(
name|csap
operator|=
name|rxp
operator|->
name|sr_csa
init|;
name|csap
condition|;
name|csap
operator|=
name|next_csa
control|)
block|{
name|next_csa
operator|=
name|csap
operator|->
name|next
expr_stmt|;
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Free the CSU Req retransmission control block 		 */
name|next_rxp
operator|=
name|rxp
operator|->
name|sr_next
expr_stmt|;
name|UM_FREE
argument_list|(
name|rxp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the DCS block 	 */
name|UM_FREE
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shut down a server.  This routine is called when a connection to  * a server is lost.  It will clear the server's state without deleting  * the server.  *  * Arguments:  *	ssp	pointer to a server control block  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|scsp_server_shutdown
parameter_list|(
name|ssp
parameter_list|)
name|Scsp_server
modifier|*
name|ssp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_cse
modifier|*
name|csep
decl_stmt|;
comment|/* 	 * Trace the shutdown 	 */
if|if
condition|(
name|scsp_trace_mode
operator|&
operator|(
name|SCSP_TRACE_IF_MSG
operator||
name|SCSP_TRACE_CFSM
operator|)
condition|)
block|{
name|scsp_trace
argument_list|(
literal|"Server %s being shut down\n"
argument_list|,
name|ssp
operator|->
name|ss_name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Terminate up all the DCS connections and clean 	 * up the control blocks 	 */
for|for
control|(
name|dcsp
operator|=
name|ssp
operator|->
name|ss_dcs
init|;
name|dcsp
condition|;
name|dcsp
operator|=
name|dcsp
operator|->
name|sd_next
control|)
block|{
if|if
condition|(
name|dcsp
operator|->
name|sd_sock
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|dcsp
operator|->
name|sd_sock
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_sock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_open_t
argument_list|)
expr_stmt|;
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_h_t
argument_list|)
expr_stmt|;
name|HARP_CANCEL
argument_list|(
operator|&
name|dcsp
operator|->
name|sd_hello_rcv_t
argument_list|)
expr_stmt|;
name|scsp_dcs_cleanup
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_hello_state
operator|=
name|SCSP_HFSM_DOWN
expr_stmt|;
name|dcsp
operator|->
name|sd_ca_state
operator|=
name|SCSP_CAFSM_DOWN
expr_stmt|;
name|dcsp
operator|->
name|sd_client_state
operator|=
name|SCSP_CIFSM_NULL
expr_stmt|;
block|}
comment|/* 	 * Clean up the server control block 	 */
if|if
condition|(
name|ssp
operator|->
name|ss_sock
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ssp
operator|->
name|ss_sock
argument_list|)
expr_stmt|;
name|ssp
operator|->
name|ss_sock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ssp
operator|->
name|ss_dcs_lsock
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|ssp
operator|->
name|ss_dcs_lsock
argument_list|)
expr_stmt|;
name|ssp
operator|->
name|ss_dcs_lsock
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|ssp
operator|->
name|ss_state
operator|=
name|SCSP_SS_NULL
expr_stmt|;
comment|/* 	 * Free the entries in the server's summary cache 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCSP_HASHSZ
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|ssp
operator|->
name|ss_cache
index|[
name|i
index|]
condition|)
block|{
name|csep
operator|=
name|ssp
operator|->
name|ss_cache
index|[
name|i
index|]
expr_stmt|;
name|UNLINK
argument_list|(
name|csep
argument_list|,
name|Scsp_cse
argument_list|,
name|ssp
operator|->
name|ss_cache
index|[
name|i
index|]
argument_list|,
name|sc_next
argument_list|)
expr_stmt|;
name|UM_FREE
argument_list|(
name|csep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Delete an SCSP server block and any associated information  *  * Arguments:  *	ssp	pointer to a server control block to delete  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|scsp_server_delete
parameter_list|(
name|ssp
parameter_list|)
name|Scsp_server
modifier|*
name|ssp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|,
modifier|*
name|next_dcs
decl_stmt|;
name|Scsp_cse
modifier|*
name|csep
decl_stmt|,
modifier|*
name|next_cse
decl_stmt|;
comment|/* 	 * Unlink the server block from the chain 	 */
name|UNLINK
argument_list|(
name|ssp
argument_list|,
name|Scsp_server
argument_list|,
name|scsp_server_head
argument_list|,
name|ss_next
argument_list|)
expr_stmt|;
comment|/* 	 * Free the DCS blocks associated with the server 	 */
for|for
control|(
name|dcsp
operator|=
name|ssp
operator|->
name|ss_dcs
init|;
name|dcsp
condition|;
name|dcsp
operator|=
name|next_dcs
control|)
block|{
name|next_dcs
operator|=
name|dcsp
operator|->
name|sd_next
expr_stmt|;
name|scsp_dcs_delete
argument_list|(
name|dcsp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the entries in the server's summary cache 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCSP_HASHSZ
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|csep
operator|=
name|ssp
operator|->
name|ss_cache
index|[
name|i
index|]
init|;
name|csep
condition|;
name|csep
operator|=
name|next_cse
control|)
block|{
name|next_cse
operator|=
name|csep
operator|->
name|sc_next
expr_stmt|;
name|UM_FREE
argument_list|(
name|csep
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Free the server block 	 */
name|UM_FREE
argument_list|(
name|ssp
operator|->
name|ss_name
argument_list|)
expr_stmt|;
name|UM_FREE
argument_list|(
name|ssp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get informtion about a server from the kernel  *  * Arguments:  *	ssp	pointer to the server block  *  * Returns:  *	0	server info is OK  *	errno	server is not ready  *  */
end_comment

begin_function
name|int
name|scsp_get_server_info
parameter_list|(
name|ssp
parameter_list|)
name|Scsp_server
modifier|*
name|ssp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|mtu
decl_stmt|,
name|rc
decl_stmt|,
name|sel
decl_stmt|;
name|struct
name|atminfreq
name|air
decl_stmt|;
name|struct
name|air_netif_rsp
modifier|*
name|netif_rsp
init|=
operator|(
expr|struct
name|air_netif_rsp
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|air_int_rsp
modifier|*
name|intf_rsp
init|=
operator|(
expr|struct
name|air_int_rsp
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|air_cfg_rsp
modifier|*
name|cfg_rsp
init|=
operator|(
expr|struct
name|air_cfg_rsp
operator|*
operator|)
literal|0
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|ip_addr
decl_stmt|;
name|Atm_addr_nsap
modifier|*
name|anp
decl_stmt|;
comment|/* 	 * Make sure we're the server for the interface 	 */
if|if
condition|(
operator|!
name|scsp_is_atmarp_server
argument_list|(
name|ssp
operator|->
name|ss_intf
argument_list|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|server_info_done
goto|;
block|}
comment|/* 	 * Get the IP address and physical interface name 	 * associated with the network interface 	 */
name|UM_ZERO
argument_list|(
operator|&
name|air
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atminfreq
argument_list|)
argument_list|)
expr_stmt|;
name|air
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_NIF
expr_stmt|;
name|strcpy
argument_list|(
name|air
operator|.
name|air_netif_intf
argument_list|,
name|ssp
operator|->
name|ss_intf
argument_list|)
expr_stmt|;
name|len
operator|=
name|do_info_ioctl
argument_list|(
operator|&
name|air
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|air_netif_rsp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|server_info_done
goto|;
block|}
name|netif_rsp
operator|=
operator|(
expr|struct
name|air_netif_rsp
operator|*
operator|)
name|air
operator|.
name|air_buf_addr
expr_stmt|;
name|ip_addr
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|netif_rsp
operator|->
name|anp_proto_addr
expr_stmt|;
if|if
condition|(
name|ip_addr
operator|->
name|sin_family
operator|!=
name|AF_INET
operator|||
name|ip_addr
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
name|rc
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|server_info_done
goto|;
block|}
comment|/* 	 * Get the MTU for the network interface 	 */
name|mtu
operator|=
name|get_mtu
argument_list|(
name|ssp
operator|->
name|ss_intf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|<
literal|0
condition|)
block|{
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|server_info_done
goto|;
block|}
comment|/* 	 * Get the ATM address associated with the 	 * physical interface 	 */
name|UM_ZERO
argument_list|(
operator|&
name|air
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atminfreq
argument_list|)
argument_list|)
expr_stmt|;
name|air
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_INT
expr_stmt|;
name|strcpy
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|,
name|netif_rsp
operator|->
name|anp_phy_intf
argument_list|)
expr_stmt|;
name|len
operator|=
name|do_info_ioctl
argument_list|(
operator|&
name|air
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|air_int_rsp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|server_info_done
goto|;
block|}
name|intf_rsp
operator|=
operator|(
expr|struct
name|air_int_rsp
operator|*
operator|)
name|air
operator|.
name|air_buf_addr
expr_stmt|;
comment|/* 	 * Make sure we're running UNI signalling 	 */
if|if
condition|(
name|intf_rsp
operator|->
name|anp_sig_proto
operator|!=
name|ATM_SIG_UNI30
operator|&&
name|intf_rsp
operator|->
name|anp_sig_proto
operator|!=
name|ATM_SIG_UNI31
operator|&&
name|intf_rsp
operator|->
name|anp_sig_proto
operator|!=
name|ATM_SIG_UNI40
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|server_info_done
goto|;
block|}
comment|/* 	 * Check the physical interface's state 	 */
if|if
condition|(
name|intf_rsp
operator|->
name|anp_sig_state
operator|!=
name|UNISIG_ACTIVE
condition|)
block|{
name|rc
operator|=
name|EHOSTDOWN
expr_stmt|;
goto|goto
name|server_info_done
goto|;
block|}
comment|/* 	 * Make sure the interface's address is valid 	 */
if|if
condition|(
name|intf_rsp
operator|->
name|anp_addr
operator|.
name|address_format
operator|!=
name|T_ATM_ENDSYS_ADDR
operator|&&
operator|!
operator|(
name|intf_rsp
operator|->
name|anp_addr
operator|.
name|address_format
operator|==
name|T_ATM_E164_ADDR
operator|&&
name|intf_rsp
operator|->
name|anp_subaddr
operator|.
name|address_format
operator|==
name|T_ATM_ENDSYS_ADDR
operator|)
condition|)
block|{
name|rc
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|server_info_done
goto|;
block|}
comment|/* 	 * Find the selector byte value for the interface 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|ssp
operator|->
name|ss_intf
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ssp
operator|->
name|ss_intf
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|ssp
operator|->
name|ss_intf
index|[
name|i
index|]
operator|<=
literal|'9'
condition|)
break|break;
block|}
name|sel
operator|=
name|atoi
argument_list|(
operator|&
name|ssp
operator|->
name|ss_intf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Get configuration information associated with the 	 * physical interface 	 */
name|UM_ZERO
argument_list|(
operator|&
name|air
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atminfreq
argument_list|)
argument_list|)
expr_stmt|;
name|air
operator|.
name|air_opcode
operator|=
name|AIOCS_INF_CFG
expr_stmt|;
name|strcpy
argument_list|(
name|air
operator|.
name|air_int_intf
argument_list|,
name|netif_rsp
operator|->
name|anp_phy_intf
argument_list|)
expr_stmt|;
name|len
operator|=
name|do_info_ioctl
argument_list|(
operator|&
name|air
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|air_cfg_rsp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|server_info_done
goto|;
block|}
name|cfg_rsp
operator|=
operator|(
expr|struct
name|air_cfg_rsp
operator|*
operator|)
name|air
operator|.
name|air_buf_addr
expr_stmt|;
comment|/* 	 * Update the server entry 	 */
name|UM_COPY
argument_list|(
operator|&
name|ip_addr
operator|->
name|sin_addr
argument_list|,
name|ssp
operator|->
name|ss_lsid
operator|.
name|id
argument_list|,
name|ssp
operator|->
name|ss_id_len
argument_list|)
expr_stmt|;
name|ssp
operator|->
name|ss_lsid
operator|.
name|id_len
operator|=
name|ssp
operator|->
name|ss_id_len
expr_stmt|;
name|ssp
operator|->
name|ss_mtu
operator|=
name|mtu
operator|+
literal|8
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|intf_rsp
operator|->
name|anp_addr
argument_list|,
operator|&
name|ssp
operator|->
name|ss_addr
argument_list|)
expr_stmt|;
name|ATM_ADDR_COPY
argument_list|(
operator|&
name|intf_rsp
operator|->
name|anp_subaddr
argument_list|,
operator|&
name|ssp
operator|->
name|ss_subaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssp
operator|->
name|ss_addr
operator|.
name|address_format
operator|==
name|T_ATM_ENDSYS_ADDR
condition|)
block|{
name|anp
operator|=
operator|(
name|Atm_addr_nsap
operator|*
operator|)
name|ssp
operator|->
name|ss_addr
operator|.
name|address
expr_stmt|;
name|anp
operator|->
name|aan_sel
operator|=
name|sel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ssp
operator|->
name|ss_addr
operator|.
name|address_format
operator|==
name|T_ATM_E164_ADDR
operator|&&
name|ssp
operator|->
name|ss_subaddr
operator|.
name|address_format
operator|==
name|T_ATM_ENDSYS_ADDR
condition|)
block|{
name|anp
operator|=
operator|(
name|Atm_addr_nsap
operator|*
operator|)
name|ssp
operator|->
name|ss_subaddr
operator|.
name|address
expr_stmt|;
name|anp
operator|->
name|aan_sel
operator|=
name|sel
expr_stmt|;
block|}
name|ssp
operator|->
name|ss_media
operator|=
name|cfg_rsp
operator|->
name|acp_cfg
operator|.
name|ac_media
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Free dynamic data 	 */
name|server_info_done
label|:
if|if
condition|(
name|netif_rsp
condition|)
name|UM_FREE
argument_list|(
name|netif_rsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|intf_rsp
condition|)
name|UM_FREE
argument_list|(
name|intf_rsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_rsp
condition|)
name|UM_FREE
argument_list|(
name|cfg_rsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a CA message  *  * Arguments:  *	dcsp	pointer to a DCS control block for the neighbor  *	cap	pointer to the CA part of the received message  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|scsp_process_ca
parameter_list|(
name|dcsp
parameter_list|,
name|cap
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_ca
modifier|*
name|cap
decl_stmt|;
block|{
name|Scsp_csa
modifier|*
name|csap
decl_stmt|,
modifier|*
name|next_csap
decl_stmt|;
name|Scsp_cse
modifier|*
name|csep
decl_stmt|;
name|Scsp_server
modifier|*
name|ssp
init|=
name|dcsp
operator|->
name|sd_server
decl_stmt|;
comment|/* 	 * Process CSAS records from the CA message 	 */
for|for
control|(
name|csap
operator|=
name|cap
operator|->
name|ca_csa_rec
init|;
name|csap
condition|;
name|csap
operator|=
name|next_csap
control|)
block|{
name|next_csap
operator|=
name|csap
operator|->
name|next
expr_stmt|;
name|SCSP_LOOKUP
argument_list|(
name|ssp
argument_list|,
operator|&
name|csap
operator|->
name|key
argument_list|,
name|csep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csep
operator|||
operator|(
name|scsp_cmp_id
argument_list|(
operator|&
name|csap
operator|->
name|oid
argument_list|,
operator|&
name|csep
operator|->
name|sc_oid
argument_list|)
operator|==
literal|0
operator|&&
name|csap
operator|->
name|seq
operator|>
name|csep
operator|->
name|sc_seq
operator|)
condition|)
block|{
comment|/* 			 * CSAS entry not in cache or more 			 * up to date than cache, add it to CRL 			 */
name|UNLINK
argument_list|(
name|csap
argument_list|,
name|Scsp_csa
argument_list|,
name|cap
operator|->
name|ca_csa_rec
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|LINK2TAIL
argument_list|(
name|csap
argument_list|,
name|Scsp_csa
argument_list|,
name|dcsp
operator|->
name|sd_crl
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Process a Cache Response message from a server  *  * Arguments:  *	ssp	pointer to the server block  *	smp	pointer to the message  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|scsp_process_cache_rsp
parameter_list|(
name|ssp
parameter_list|,
name|smp
parameter_list|)
name|Scsp_server
modifier|*
name|ssp
decl_stmt|;
name|Scsp_if_msg
modifier|*
name|smp
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|Scsp_atmarp_msg
modifier|*
name|aap
decl_stmt|;
name|Scsp_cse
modifier|*
name|csep
decl_stmt|;
comment|/* 	 * Loop through the message, processing each cache entry 	 */
name|len
operator|=
name|smp
operator|->
name|si_len
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|Scsp_if_msg_hdr
argument_list|)
expr_stmt|;
name|aap
operator|=
operator|&
name|smp
operator|->
name|si_atmarp
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|smp
operator|->
name|si_proto
condition|)
block|{
case|case
name|SCSP_ATMARP_PROTO
case|:
comment|/* 			 * If we already have an entry with this key, 			 * delete it 			 */
name|SCSP_LOOKUP
argument_list|(
name|ssp
argument_list|,
operator|&
name|aap
operator|->
name|sa_key
argument_list|,
name|csep
argument_list|)
expr_stmt|;
if|if
condition|(
name|csep
condition|)
block|{
name|SCSP_DELETE
argument_list|(
name|ssp
argument_list|,
name|csep
argument_list|)
expr_stmt|;
name|UM_FREE
argument_list|(
name|csep
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Copy the data from the server to a cache 			 * summary entry 			 */
name|csep
operator|=
name|scsp_atmarp2cse
argument_list|(
name|aap
argument_list|)
expr_stmt|;
comment|/* 			 * Point past this entry 			 */
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|Scsp_atmarp_msg
argument_list|)
expr_stmt|;
name|aap
operator|++
expr_stmt|;
break|break;
case|case
name|SCSP_NHRP_PROTO
case|:
default|default:
comment|/* 			 * Not implemented yet 			 */
return|return;
block|}
comment|/* 		 * Add the new summary entry to the cache 		 */
name|SCSP_ADD
argument_list|(
name|ssp
argument_list|,
name|csep
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Propagate a CSA to all the DCSs in the server group except  * the one the CSA was received from  *  * Arguments:  *	dcsp	pointer to a the DCS the CSA came from  *	csap	pointer to a the CSA  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_propagate_csa
parameter_list|(
name|dcsp
parameter_list|,
name|csap
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|ret_rc
init|=
literal|0
decl_stmt|;
name|Scsp_server
modifier|*
name|ssp
init|=
name|dcsp
operator|->
name|sd_server
decl_stmt|;
name|Scsp_dcs
modifier|*
name|dcsp1
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap1
decl_stmt|;
comment|/* 	 * Check the hop count in the CSA 	 */
if|if
condition|(
name|csap
operator|->
name|hops
operator|<=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Pass the cache entry on to the server's other DCSs 	 */
for|for
control|(
name|dcsp1
operator|=
name|ssp
operator|->
name|ss_dcs
init|;
name|dcsp1
condition|;
name|dcsp1
operator|=
name|dcsp1
operator|->
name|sd_next
control|)
block|{
comment|/* 		 * Skip this DCS if it's the one we got 		 * the entry from 		 */
if|if
condition|(
name|dcsp1
operator|==
name|dcsp
condition|)
continue|continue;
comment|/* 		 * Copy the  CSA 		 */
name|csap1
operator|=
name|scsp_dup_csa
argument_list|(
name|csap
argument_list|)
expr_stmt|;
comment|/* 		 * Decrement the hop count 		 */
name|csap1
operator|->
name|hops
operator|--
expr_stmt|;
comment|/* 		 * Send the copy of the CSA to the CA FSM for the DCS 		 */
name|rc
operator|=
name|scsp_cafsm
argument_list|(
name|dcsp1
argument_list|,
name|SCSP_CAFSM_CACHE_UPD
argument_list|,
operator|(
name|void
operator|*
operator|)
name|csap1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
name|ret_rc
operator|=
name|rc
expr_stmt|;
block|}
return|return
operator|(
name|ret_rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update SCSP's cache given a CSA or CSAS  *  * Arguments:  *	dcsp	pointer to a DCS   *	csap	pointer to a CSA  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|scsp_update_cache
parameter_list|(
name|dcsp
parameter_list|,
name|csap
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
decl_stmt|;
block|{
name|Scsp_cse
modifier|*
name|csep
decl_stmt|;
comment|/* 	 * Check whether we already have this in the cache 	 */
name|SCSP_LOOKUP
argument_list|(
name|dcsp
operator|->
name|sd_server
argument_list|,
operator|&
name|csap
operator|->
name|key
argument_list|,
name|csep
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't already have it and it's not being deleted, 	 * build a new cache summary entry 	 */
if|if
condition|(
operator|!
name|csep
operator|&&
operator|!
name|csap
operator|->
name|null
condition|)
block|{
comment|/* 		 * Get memory for a new entry 		 */
name|csep
operator|=
operator|(
name|Scsp_cse
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_cse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csep
condition|)
block|{
name|scsp_mem_err
argument_list|(
literal|"scsp_update_cache: sizeof(Scsp_cse)"
argument_list|)
expr_stmt|;
block|}
name|UM_ZERO
argument_list|(
name|csep
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_cse
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Fill out the new cache summary entry 		 */
name|csep
operator|->
name|sc_seq
operator|=
name|csap
operator|->
name|seq
expr_stmt|;
name|csep
operator|->
name|sc_key
operator|=
name|csap
operator|->
name|key
expr_stmt|;
name|csep
operator|->
name|sc_oid
operator|=
name|csap
operator|->
name|oid
expr_stmt|;
comment|/* 		 * Add the new entry to the cache 		 */
name|SCSP_ADD
argument_list|(
name|dcsp
operator|->
name|sd_server
argument_list|,
name|csep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update or delete the entry 	 */
if|if
condition|(
name|csap
operator|->
name|null
condition|)
block|{
comment|/* 		 * The null flag is set--delete the entry 		 */
if|if
condition|(
name|csep
condition|)
block|{
name|SCSP_DELETE
argument_list|(
name|dcsp
operator|->
name|sd_server
argument_list|,
name|csep
argument_list|)
expr_stmt|;
name|UM_FREE
argument_list|(
name|csep
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Update the existing entry 		 */
name|csep
operator|->
name|sc_seq
operator|=
name|csap
operator|->
name|seq
expr_stmt|;
name|csep
operator|->
name|sc_oid
operator|=
name|csap
operator|->
name|oid
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reconfigure SCSP  *  * Called as the result of a SIGHUP interrupt.  Reread the  * configuration file and solicit the cache from the server.  *  * Arguments:  *	none  *  * Returns:  *	none  *  */
end_comment

begin_function
name|void
name|scsp_reconfigure
parameter_list|()
block|{
name|int
name|rc
decl_stmt|;
name|Scsp_server
modifier|*
name|ssp
decl_stmt|;
comment|/* 	 * Log a message saying we're reconfiguring 	 */
name|scsp_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Reconfiguring ..."
argument_list|)
expr_stmt|;
comment|/* 	 * Re-read the configuration file 	 */
name|rc
operator|=
name|scsp_config
argument_list|(
name|scsp_config_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|scsp_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Found %d error%s in configuration file"
argument_list|,
name|rc
argument_list|,
operator|(
operator|(
name|rc
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If a connection to a server is open, get the cache from 	 * the server 	 */
for|for
control|(
name|ssp
operator|=
name|scsp_server_head
init|;
name|ssp
condition|;
name|ssp
operator|=
name|ssp
operator|->
name|ss_next
control|)
block|{
if|if
condition|(
name|ssp
operator|->
name|ss_sock
operator|!=
operator|-
literal|1
condition|)
block|{
name|rc
operator|=
name|scsp_send_cache_ind
argument_list|(
name|ssp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

