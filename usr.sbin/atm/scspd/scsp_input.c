begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Server Cache Synchronization Protocol (SCSP) Support  * ----------------------------------------------------  *  * Input packet processing  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libatm.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"scsp_msg.h"
end_include

begin_include
include|#
directive|include
file|"scsp_if.h"
end_include

begin_include
include|#
directive|include
file|"scsp_var.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|scsp_parse_atmarp
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|Scsp_atmarp_csa
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get a long ingeter  *  * This routine is provided to handle long integers that may not  * be word-aligned in the input buffer.  *  * Arguments:  *	cp	pointer to long int in message  *  * Returns:  *	int	long int in host order  *  */
end_comment

begin_function
specifier|static
name|u_long
name|get_long
parameter_list|(
name|cp
parameter_list|)
name|u_char
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_long
name|l
decl_stmt|;
comment|/* 	 * Read the long out of the input buffer 	 */
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|;
name|i
operator|++
control|)
name|l
operator|=
operator|(
name|l
operator|<<
literal|8
operator|)
operator|+
operator|*
name|cp
operator|++
expr_stmt|;
comment|/* 	 * Return the value in host order 	 */
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an SCSP Cache Alignment message in internal format  *  * Arguments:  *	cap	pointer to CA message  *  * Returns:  *	None  *  */
end_comment

begin_function
specifier|static
name|void
name|scsp_free_ca
parameter_list|(
name|cap
parameter_list|)
name|Scsp_ca
modifier|*
name|cap
decl_stmt|;
block|{
name|Scsp_csa
modifier|*
name|csap
decl_stmt|,
modifier|*
name|ncsap
decl_stmt|;
comment|/* 	 * Return if there's nothing to free 	 */
if|if
condition|(
name|cap
operator|==
operator|(
name|Scsp_ca
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* 	 * Free the CSAS records 	 */
for|for
control|(
name|csap
operator|=
name|cap
operator|->
name|ca_csa_rec
init|;
name|csap
condition|;
name|csap
operator|=
name|ncsap
control|)
block|{
name|ncsap
operator|=
name|csap
operator|->
name|next
expr_stmt|;
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the CA message structure 	 */
name|UM_FREE
argument_list|(
name|cap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an SCSP Cache State Update Request, Cache State Update Reply,  * or Cache State Update Solicit message in internal format  *  * Arguments:  *	csup	pointer to CSU message  *  * Returns:  *	None  *  */
end_comment

begin_function
specifier|static
name|void
name|scsp_free_csu
parameter_list|(
name|csup
parameter_list|)
name|Scsp_csu_msg
modifier|*
name|csup
decl_stmt|;
block|{
name|Scsp_csa
modifier|*
name|csap
decl_stmt|,
modifier|*
name|ncsap
decl_stmt|;
comment|/* 	 * Return if there's nothing to free 	 */
if|if
condition|(
name|csup
operator|==
operator|(
name|Scsp_csu_msg
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* 	 * Free the CSA records 	 */
for|for
control|(
name|csap
operator|=
name|csup
operator|->
name|csu_csa_rec
init|;
name|csap
condition|;
name|csap
operator|=
name|ncsap
control|)
block|{
name|ncsap
operator|=
name|csap
operator|->
name|next
expr_stmt|;
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the CSU message structure 	 */
name|UM_FREE
argument_list|(
name|csup
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an SCSP Hello message in  internal format  *  * Arguments:  *	hp	pointer to Hello message  *  * Returns:  *	None  *  */
end_comment

begin_function
specifier|static
name|void
name|scsp_free_hello
parameter_list|(
name|hp
parameter_list|)
name|Scsp_hello
modifier|*
name|hp
decl_stmt|;
block|{
comment|/* 	 * Return if there's nothing to free 	 */
if|if
condition|(
name|hp
operator|==
operator|(
name|Scsp_hello
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* 	 * Free the Hello message structure 	 */
name|UM_FREE
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an SCSP message in  internal format  *  * Arguments:  *	msg	pointer to input packet  *  * Returns:  *	None  *  */
end_comment

begin_function
name|void
name|scsp_free_msg
parameter_list|(
name|msg
parameter_list|)
name|Scsp_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|Scsp_ext
modifier|*
name|exp
decl_stmt|,
modifier|*
name|nexp
decl_stmt|;
comment|/* 	 * Return if there's nothing to free 	 */
if|if
condition|(
name|msg
operator|==
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* 	 * Free the message body 	 */
switch|switch
condition|(
name|msg
operator|->
name|sc_msg_type
condition|)
block|{
case|case
name|SCSP_CA_MSG
case|:
name|scsp_free_ca
argument_list|(
name|msg
operator|->
name|sc_ca
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSP_CSU_REQ_MSG
case|:
case|case
name|SCSP_CSU_REPLY_MSG
case|:
case|case
name|SCSP_CSUS_MSG
case|:
name|scsp_free_csu
argument_list|(
name|msg
operator|->
name|sc_csu_msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSP_HELLO_MSG
case|:
name|scsp_free_hello
argument_list|(
name|msg
operator|->
name|sc_hello
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Free any extensions 	 */
for|for
control|(
name|exp
operator|=
name|msg
operator|->
name|sc_ext
init|;
name|exp
condition|;
name|exp
operator|=
name|nexp
control|)
block|{
name|nexp
operator|=
name|exp
operator|->
name|next
expr_stmt|;
name|UM_FREE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the message structure 	 */
name|UM_FREE
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse a Sender or Receiver ID  *  * Arguments:  *	buff	pointer to ID  *	id_len	length of ID  *	idp	pointer to structure to receive the ID  *  * Returns:  *	0	input was invalid  *	else	length of ID processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_parse_id
parameter_list|(
name|buff
parameter_list|,
name|id_len
parameter_list|,
name|idp
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|id_len
decl_stmt|;
name|Scsp_id
modifier|*
name|idp
decl_stmt|;
block|{
comment|/* 	 * Sanity check 	 */
if|if
condition|(
operator|!
name|buff
operator|||
name|id_len
operator|==
literal|0
operator|||
name|id_len
operator|>
name|SCSP_MAX_ID_LEN
operator|||
operator|!
name|idp
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Save the ID length 	 */
name|idp
operator|->
name|id_len
operator|=
name|id_len
expr_stmt|;
comment|/* 	 * Get the ID 	 */
name|UM_COPY
argument_list|(
name|buff
argument_list|,
name|idp
operator|->
name|id
argument_list|,
name|id_len
argument_list|)
expr_stmt|;
comment|/* 	 * Return the ID length 	 */
return|return
operator|(
name|id_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the Mandatory Common Part of an SCSP input packet  *  * Arguments:  *	buff	pointer to mandatory common part  *	pdu_len	length of input packet  *	mcp	pointer to location of MCP in decoded record  *  * Returns:  *	0	input was invalid  *	else	length of MCP in message  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_parse_mcp
parameter_list|(
name|buff
parameter_list|,
name|pdu_len
parameter_list|,
name|mcp
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|pdu_len
decl_stmt|;
name|Scsp_mcp
modifier|*
name|mcp
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|u_char
modifier|*
name|idp
decl_stmt|;
name|struct
name|scsp_nmcp
modifier|*
name|smp
decl_stmt|;
comment|/* 	 * Get the protocol ID 	 */
name|smp
operator|=
operator|(
expr|struct
name|scsp_nmcp
operator|*
operator|)
name|buff
expr_stmt|;
name|mcp
operator|->
name|pid
operator|=
name|ntohs
argument_list|(
name|smp
operator|->
name|sm_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcp
operator|->
name|pid
operator|<
name|SCSP_PROTO_ATMARP
operator|||
name|mcp
operator|->
name|pid
operator|>
name|SCSP_PROTO_LNNI
condition|)
block|{
comment|/* Protocol ID is invalid */
goto|goto
name|mcp_invalid
goto|;
block|}
comment|/* 	 * Get the server group ID 	 */
name|mcp
operator|->
name|sgid
operator|=
name|ntohs
argument_list|(
name|smp
operator|->
name|sm_sgid
argument_list|)
expr_stmt|;
comment|/* 	 * Get the flags 	 */
name|mcp
operator|->
name|flags
operator|=
name|ntohs
argument_list|(
name|smp
operator|->
name|sm_flags
argument_list|)
expr_stmt|;
comment|/* 	 * Get the sender ID and length 	 */
name|idp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|smp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_nmcp
argument_list|)
operator|)
expr_stmt|;
name|len
operator|=
name|scsp_parse_id
argument_list|(
name|idp
argument_list|,
name|smp
operator|->
name|sm_sid_len
argument_list|,
operator|&
name|mcp
operator|->
name|sid
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
goto|goto
name|mcp_invalid
goto|;
block|}
comment|/* 	 * Get the receiver ID and length 	 */
name|idp
operator|+=
name|len
expr_stmt|;
name|len
operator|=
name|scsp_parse_id
argument_list|(
name|idp
argument_list|,
name|smp
operator|->
name|sm_rid_len
argument_list|,
operator|&
name|mcp
operator|->
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
goto|goto
name|mcp_invalid
goto|;
block|}
comment|/* 	 * Get the record count 	 */
name|mcp
operator|->
name|rec_cnt
operator|=
name|ntohs
argument_list|(
name|smp
operator|->
name|sm_rec_cnt
argument_list|)
expr_stmt|;
comment|/* 	 * Return the length of data we processed 	 */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_nmcp
argument_list|)
operator|+
name|smp
operator|->
name|sm_sid_len
operator|+
name|smp
operator|->
name|sm_rid_len
operator|)
return|;
name|mcp_invalid
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse an Extension  *  * Arguments:  *	buff	pointer to Extension  *	pdu_len	length of buffer  *	expp	pointer to location to receive pointer to the Extension  *  * Returns:  *	0	input was invalid  *	else	length of Extension processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_parse_ext
parameter_list|(
name|buff
parameter_list|,
name|pdu_len
parameter_list|,
name|expp
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|pdu_len
decl_stmt|;
name|Scsp_ext
modifier|*
modifier|*
name|expp
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|struct
name|scsp_next
modifier|*
name|sep
decl_stmt|;
name|Scsp_ext
modifier|*
name|exp
decl_stmt|;
comment|/* 	 * Get memory for the extension 	 */
name|sep
operator|=
operator|(
expr|struct
name|scsp_next
operator|*
operator|)
name|buff
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|Scsp_ext
argument_list|)
operator|+
name|ntohs
argument_list|(
name|sep
operator|->
name|se_len
argument_list|)
expr_stmt|;
name|exp
operator|=
operator|(
name|Scsp_ext
operator|*
operator|)
name|UM_ALLOC
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|exp
condition|)
block|{
goto|goto
name|ext_invalid
goto|;
block|}
name|UM_ZERO
argument_list|(
name|exp
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Get the type 	 */
name|exp
operator|->
name|type
operator|=
name|ntohs
argument_list|(
name|sep
operator|->
name|se_type
argument_list|)
expr_stmt|;
comment|/* 	 * Get the length 	 */
name|exp
operator|->
name|len
operator|=
name|ntohs
argument_list|(
name|sep
operator|->
name|se_len
argument_list|)
expr_stmt|;
comment|/* 	 * Get the value 	 */
if|if
condition|(
name|exp
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|UM_COPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|sep
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_next
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|exp
operator|+
sizeof|sizeof
argument_list|(
name|Scsp_ext
argument_list|)
argument_list|,
name|exp
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save a pointer to the extension and return the 	 * number of bytes processed 	 */
operator|*
name|expp
operator|=
name|exp
expr_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_next
argument_list|)
operator|+
name|exp
operator|->
name|len
operator|)
return|;
name|ext_invalid
label|:
if|if
condition|(
name|exp
condition|)
block|{
name|UM_FREE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a Cache State Advertisement or Cache State Advertisement  * Summary record  *  * Arguments:  *	buff	pointer to CSA or CSAS record  *	pdu_len	length of input packet  *	csapp	pointer to location to put pointer to CSA or CSAS  *  * Returns:  *	0	input was invalid  *	else	length of record processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_parse_csa
parameter_list|(
name|buff
parameter_list|,
name|pdu_len
parameter_list|,
name|csapp
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|pdu_len
decl_stmt|;
name|Scsp_csa
modifier|*
modifier|*
name|csapp
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|idp
decl_stmt|;
name|struct
name|scsp_ncsa
modifier|*
name|scp
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Check the record length 	 */
name|scp
operator|=
operator|(
expr|struct
name|scsp_ncsa
operator|*
operator|)
name|buff
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|scp
operator|->
name|scs_len
argument_list|)
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_ncsa
argument_list|)
operator|+
name|scp
operator|->
name|scs_ck_len
operator|+
name|scp
operator|->
name|scs_oid_len
operator|)
condition|)
block|{
goto|goto
name|csa_invalid
goto|;
block|}
comment|/* 	 * Get memory for the returned structure 	 */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|Scsp_csa
argument_list|)
operator|+
name|ntohs
argument_list|(
name|scp
operator|->
name|scs_len
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_ncsa
argument_list|)
operator|-
name|scp
operator|->
name|scs_ck_len
operator|-
name|scp
operator|->
name|scs_oid_len
expr_stmt|;
name|csap
operator|=
operator|(
name|Scsp_csa
operator|*
operator|)
name|UM_ALLOC
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csap
condition|)
block|{
goto|goto
name|csa_invalid
goto|;
block|}
name|UM_ZERO
argument_list|(
name|csap
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Get the hop count 	 */
name|csap
operator|->
name|hops
operator|=
name|ntohs
argument_list|(
name|scp
operator|->
name|scs_hop_cnt
argument_list|)
expr_stmt|;
comment|/* 	 * Set the null flag 	 */
name|csap
operator|->
name|null
operator|=
operator|(
name|ntohs
argument_list|(
name|scp
operator|->
name|scs_nfill
argument_list|)
operator|&
name|SCSP_CSAS_NULL
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* 	 * Get the sequence number 	 */
name|csap
operator|->
name|seq
operator|=
name|get_long
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|scp
operator|->
name|scs_seq
argument_list|)
expr_stmt|;
comment|/* 	 * Get the cache key 	 */
if|if
condition|(
name|scp
operator|->
name|scs_ck_len
operator|==
literal|0
operator|||
name|scp
operator|->
name|scs_ck_len
operator|>
name|SCSP_MAX_KEY_LEN
condition|)
block|{
goto|goto
name|csa_invalid
goto|;
block|}
name|csap
operator|->
name|key
operator|.
name|key_len
operator|=
name|scp
operator|->
name|scs_ck_len
expr_stmt|;
name|idp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|scp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_ncsa
argument_list|)
operator|)
expr_stmt|;
name|UM_COPY
argument_list|(
name|idp
argument_list|,
name|csap
operator|->
name|key
operator|.
name|key
argument_list|,
name|scp
operator|->
name|scs_ck_len
argument_list|)
expr_stmt|;
comment|/* 	 * Get the originator ID 	 */
name|idp
operator|+=
name|scp
operator|->
name|scs_ck_len
expr_stmt|;
name|len
operator|=
name|scsp_parse_id
argument_list|(
name|idp
argument_list|,
name|scp
operator|->
name|scs_oid_len
argument_list|,
operator|&
name|csap
operator|->
name|oid
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
goto|goto
name|csa_invalid
goto|;
block|}
comment|/* 	 * Get the protocol-specific data, if present 	 */
name|len
operator|=
name|ntohs
argument_list|(
name|scp
operator|->
name|scs_len
argument_list|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_ncsa
argument_list|)
operator|+
name|scp
operator|->
name|scs_ck_len
operator|+
name|scp
operator|->
name|scs_oid_len
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|idp
operator|+=
name|scp
operator|->
name|scs_oid_len
expr_stmt|;
name|len
operator|=
name|scsp_parse_atmarp
argument_list|(
name|idp
argument_list|,
name|len
argument_list|,
operator|&
name|csap
operator|->
name|atmarp_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|csa_invalid
goto|;
block|}
comment|/* 	 * Set a pointer to the MCP and return the length 	 * of data we processed 	 */
operator|*
name|csapp
operator|=
name|csap
expr_stmt|;
return|return
operator|(
name|ntohs
argument_list|(
name|scp
operator|->
name|scs_len
argument_list|)
operator|)
return|;
name|csa_invalid
label|:
if|if
condition|(
name|csap
condition|)
name|SCSP_FREE_CSA
argument_list|(
name|csap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a Cache Alignment message  *  * Arguments:  *	buff	pointer to start of CA in message  *	pdu_len	length of input packet  *	capp	pointer to location to put pointer to CA message  *  * Returns:  *	0	input was invalid  *	else	length of CA message processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_parse_ca
parameter_list|(
name|buff
parameter_list|,
name|pdu_len
parameter_list|,
name|capp
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|pdu_len
decl_stmt|;
name|Scsp_ca
modifier|*
modifier|*
name|capp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|proc_len
decl_stmt|;
name|struct
name|scsp_nca
modifier|*
name|scap
decl_stmt|;
name|Scsp_ca
modifier|*
name|cap
decl_stmt|;
name|Scsp_csa
modifier|*
modifier|*
name|csapp
decl_stmt|;
comment|/* 	 * Get memory for the returned structure 	 */
name|scap
operator|=
operator|(
expr|struct
name|scsp_nca
operator|*
operator|)
name|buff
expr_stmt|;
name|cap
operator|=
operator|(
name|Scsp_ca
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_ca
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cap
condition|)
block|{
goto|goto
name|ca_invalid
goto|;
block|}
name|UM_ZERO
argument_list|(
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_ca
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get the sequence number 	 */
name|cap
operator|->
name|ca_seq
operator|=
name|get_long
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|scap
operator|->
name|sca_seq
argument_list|)
expr_stmt|;
name|proc_len
operator|=
sizeof|sizeof
argument_list|(
name|scap
operator|->
name|sca_seq
argument_list|)
expr_stmt|;
name|buff
operator|+=
sizeof|sizeof
argument_list|(
name|scap
operator|->
name|sca_seq
argument_list|)
expr_stmt|;
comment|/* 	 * Process the mandatory common part of the message 	 */
name|len
operator|=
name|scsp_parse_mcp
argument_list|(
name|buff
argument_list|,
name|pdu_len
operator|-
name|proc_len
argument_list|,
operator|&
name|cap
operator|->
name|ca_mcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|ca_invalid
goto|;
name|buff
operator|+=
name|len
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
comment|/* 	 * Set the flags 	 */
name|cap
operator|->
name|ca_m
operator|=
operator|(
name|cap
operator|->
name|ca_mcp
operator|.
name|flags
operator|&
name|SCSP_CA_M
operator|)
operator|!=
literal|0
expr_stmt|;
name|cap
operator|->
name|ca_i
operator|=
operator|(
name|cap
operator|->
name|ca_mcp
operator|.
name|flags
operator|&
name|SCSP_CA_I
operator|)
operator|!=
literal|0
expr_stmt|;
name|cap
operator|->
name|ca_o
operator|=
operator|(
name|cap
operator|->
name|ca_mcp
operator|.
name|flags
operator|&
name|SCSP_CA_O
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* 	 * Get the CSAS records from the message 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|csapp
operator|=
operator|&
name|cap
operator|->
name|ca_csa_rec
init|;
name|i
operator|<
name|cap
operator|->
name|ca_mcp
operator|.
name|rec_cnt
condition|;
name|i
operator|++
operator|,
name|csapp
operator|=
operator|&
operator|(
operator|*
name|csapp
operator|)
operator|->
name|next
control|)
block|{
name|len
operator|=
name|scsp_parse_csa
argument_list|(
name|buff
argument_list|,
name|pdu_len
operator|-
name|proc_len
argument_list|,
name|csapp
argument_list|)
expr_stmt|;
name|buff
operator|+=
name|len
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
block|}
comment|/* 	 * Set the address of the CA message and 	 * return the length of processed data 	 */
operator|*
name|capp
operator|=
name|cap
expr_stmt|;
return|return
operator|(
name|proc_len
operator|)
return|;
name|ca_invalid
label|:
if|if
condition|(
name|cap
condition|)
name|scsp_free_ca
argument_list|(
name|cap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the ATMARP-specific part of a CSA record  *  * Arguments:  *	buff	pointer to ATMARP part of CSU message  *	pdu_len	length of data to process  *	acspp	pointer to location to put pointer to CSU message  *  * Returns:  *	0	input was invalid  *	else	length of CSU Req message processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_parse_atmarp
parameter_list|(
name|buff
parameter_list|,
name|pdu_len
parameter_list|,
name|acspp
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|pdu_len
decl_stmt|;
name|Scsp_atmarp_csa
modifier|*
modifier|*
name|acspp
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|proc_len
decl_stmt|;
name|struct
name|scsp_atmarp_ncsa
modifier|*
name|sacp
decl_stmt|;
name|Scsp_atmarp_csa
modifier|*
name|acsp
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Initial packet verification 	 */
name|sacp
operator|=
operator|(
expr|struct
name|scsp_atmarp_ncsa
operator|*
operator|)
name|buff
expr_stmt|;
if|if
condition|(
operator|(
name|sacp
operator|->
name|sa_hrd
operator|!=
name|ntohs
argument_list|(
name|ARP_ATMFORUM
argument_list|)
operator|)
operator|||
operator|(
name|sacp
operator|->
name|sa_pro
operator|!=
name|ntohs
argument_list|(
name|ETHERTYPE_IP
argument_list|)
operator|)
condition|)
goto|goto
name|acs_invalid
goto|;
comment|/* 	 * Get memory for the returned structure 	 */
name|acsp
operator|=
operator|(
name|Scsp_atmarp_csa
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_atmarp_csa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|acsp
condition|)
block|{
goto|goto
name|acs_invalid
goto|;
block|}
name|UM_ZERO
argument_list|(
name|acsp
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_atmarp_csa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get state code 	 */
name|acsp
operator|->
name|sa_state
operator|=
name|sacp
operator|->
name|sa_state
expr_stmt|;
name|proc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_atmarp_ncsa
argument_list|)
expr_stmt|;
comment|/* 	 * Verify/gather source ATM address 	 */
name|acsp
operator|->
name|sa_sha
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|acsp
operator|->
name|sa_sha
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
operator|(
name|sacp
operator|->
name|sa_shtl
operator|&
name|ARP_TL_LMASK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sacp
operator|->
name|sa_shtl
operator|&
name|ARP_TL_E164
condition|)
block|{
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|Atm_addr_e164
argument_list|)
condition|)
goto|goto
name|acs_invalid
goto|;
name|acsp
operator|->
name|sa_sha
operator|.
name|address_format
operator|=
name|T_ATM_E164_ADDR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
condition|)
goto|goto
name|acs_invalid
goto|;
name|acsp
operator|->
name|sa_sha
operator|.
name|address_format
operator|=
name|T_ATM_ENDSYS_ADDR
expr_stmt|;
block|}
name|acsp
operator|->
name|sa_sha
operator|.
name|address_length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|pdu_len
operator|<
name|proc_len
operator|+
name|len
condition|)
goto|goto
name|acs_invalid
goto|;
name|UM_COPY
argument_list|(
operator|&
name|buff
index|[
name|proc_len
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|acsp
operator|->
name|sa_sha
operator|.
name|address
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
block|}
comment|/* 	 * Verify/gather source ATM subaddress 	 */
name|acsp
operator|->
name|sa_ssa
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|acsp
operator|->
name|sa_ssa
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
operator|(
name|sacp
operator|->
name|sa_sstl
operator|&
name|ARP_TL_LMASK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|sacp
operator|->
name|sa_sstl
operator|&
name|ARP_TL_TMASK
operator|)
operator|!=
name|ARP_TL_NSAPA
operator|)
operator|||
operator|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
operator|)
condition|)
goto|goto
name|acs_invalid
goto|;
name|acsp
operator|->
name|sa_ssa
operator|.
name|address_format
operator|=
name|T_ATM_ENDSYS_ADDR
expr_stmt|;
name|acsp
operator|->
name|sa_ssa
operator|.
name|address_length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|pdu_len
operator|<
name|proc_len
operator|+
name|len
condition|)
goto|goto
name|acs_invalid
goto|;
name|UM_COPY
argument_list|(
operator|&
name|buff
index|[
name|proc_len
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|acsp
operator|->
name|sa_ssa
operator|.
name|address
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
block|}
comment|/* 	 * Verify/gather source IP address 	 */
if|if
condition|(
operator|(
name|len
operator|=
name|sacp
operator|->
name|sa_spln
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
goto|goto
name|acs_invalid
goto|;
if|if
condition|(
name|pdu_len
operator|<
name|proc_len
operator|+
name|len
condition|)
goto|goto
name|acs_invalid
goto|;
name|UM_COPY
argument_list|(
operator|&
name|buff
index|[
name|proc_len
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acsp
operator|->
name|sa_spa
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|acsp
operator|->
name|sa_spa
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Verify/gather target ATM address 	 */
name|acsp
operator|->
name|sa_tha
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|acsp
operator|->
name|sa_tha
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
operator|(
name|sacp
operator|->
name|sa_thtl
operator|&
name|ARP_TL_LMASK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sacp
operator|->
name|sa_thtl
operator|&
name|ARP_TL_E164
condition|)
block|{
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|Atm_addr_e164
argument_list|)
condition|)
goto|goto
name|acs_invalid
goto|;
name|acsp
operator|->
name|sa_tha
operator|.
name|address_format
operator|=
name|T_ATM_E164_ADDR
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
condition|)
goto|goto
name|acs_invalid
goto|;
name|acsp
operator|->
name|sa_tha
operator|.
name|address_format
operator|=
name|T_ATM_ENDSYS_ADDR
expr_stmt|;
block|}
name|acsp
operator|->
name|sa_tha
operator|.
name|address_length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|pdu_len
operator|<
name|proc_len
operator|+
name|len
condition|)
goto|goto
name|acs_invalid
goto|;
name|UM_COPY
argument_list|(
operator|&
name|buff
index|[
name|proc_len
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|acsp
operator|->
name|sa_tha
operator|.
name|address
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
block|}
comment|/* 	 * Verify/gather target ATM subaddress 	 */
name|acsp
operator|->
name|sa_tsa
operator|.
name|address_format
operator|=
name|T_ATM_ABSENT
expr_stmt|;
name|acsp
operator|->
name|sa_tsa
operator|.
name|address_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
operator|(
name|sacp
operator|->
name|sa_tstl
operator|&
name|ARP_TL_LMASK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|sacp
operator|->
name|sa_tstl
operator|&
name|ARP_TL_TMASK
operator|)
operator|!=
name|ARP_TL_NSAPA
operator|)
operator|||
operator|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|Atm_addr_nsap
argument_list|)
operator|)
condition|)
goto|goto
name|acs_invalid
goto|;
name|acsp
operator|->
name|sa_tsa
operator|.
name|address_format
operator|=
name|T_ATM_ENDSYS_ADDR
expr_stmt|;
name|acsp
operator|->
name|sa_tsa
operator|.
name|address_length
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|pdu_len
operator|<
name|proc_len
operator|+
name|len
condition|)
goto|goto
name|acs_invalid
goto|;
name|UM_COPY
argument_list|(
operator|&
name|buff
index|[
name|proc_len
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|acsp
operator|->
name|sa_tsa
operator|.
name|address
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
block|}
comment|/* 	 * Verify/gather target IP address 	 */
if|if
condition|(
operator|(
name|len
operator|=
name|sacp
operator|->
name|sa_tpln
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
goto|goto
name|acs_invalid
goto|;
if|if
condition|(
name|pdu_len
operator|<
name|proc_len
operator|+
name|len
condition|)
goto|goto
name|acs_invalid
goto|;
name|UM_COPY
argument_list|(
operator|&
name|buff
index|[
name|proc_len
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|acsp
operator|->
name|sa_tpa
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|acsp
operator|->
name|sa_tpa
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Verify packet length 	 */
if|if
condition|(
name|proc_len
operator|!=
name|pdu_len
condition|)
goto|goto
name|acs_invalid
goto|;
operator|*
name|acspp
operator|=
name|acsp
expr_stmt|;
return|return
operator|(
name|proc_len
operator|)
return|;
name|acs_invalid
label|:
if|if
condition|(
name|acsp
condition|)
name|UM_FREE
argument_list|(
name|acsp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a Cache State Update Request, Cache State Update Reply, or  * Cache State Update Solicit message.  These all have the same format,  * a Mandatory Common Part followed by a number of CSA or CSAS records.  *  * Arguments:  *	buff	pointer to start of CSU message  *	pdu_len	length of input packet  *	csupp	pointer to location to put pointer to CSU message  *  * Returns:  *	0	input was invalid  *	else	length of CSU Req message processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_parse_csu
parameter_list|(
name|buff
parameter_list|,
name|pdu_len
parameter_list|,
name|csupp
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|pdu_len
decl_stmt|;
name|Scsp_csu_msg
modifier|*
modifier|*
name|csupp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|proc_len
decl_stmt|;
name|Scsp_csu_msg
modifier|*
name|csup
decl_stmt|;
name|Scsp_csa
modifier|*
modifier|*
name|csapp
decl_stmt|;
comment|/* 	 * Get memory for the returned structure 	 */
name|csup
operator|=
operator|(
name|Scsp_csu_msg
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_csu_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|csup
condition|)
block|{
goto|goto
name|csu_invalid
goto|;
block|}
name|UM_ZERO
argument_list|(
name|csup
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_csu_msg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Process the mandatory common part of the message 	 */
name|len
operator|=
name|scsp_parse_mcp
argument_list|(
name|buff
argument_list|,
name|pdu_len
argument_list|,
operator|&
name|csup
operator|->
name|csu_mcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|csu_invalid
goto|;
name|buff
operator|+=
name|len
expr_stmt|;
name|proc_len
operator|=
name|len
expr_stmt|;
comment|/* 	 * Get the CSAS records from the message 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|csapp
operator|=
operator|&
name|csup
operator|->
name|csu_csa_rec
init|;
name|i
operator|<
name|csup
operator|->
name|csu_mcp
operator|.
name|rec_cnt
condition|;
name|i
operator|++
operator|,
name|csapp
operator|=
operator|&
operator|(
operator|*
name|csapp
operator|)
operator|->
name|next
control|)
block|{
name|len
operator|=
name|scsp_parse_csa
argument_list|(
name|buff
argument_list|,
name|pdu_len
operator|-
name|proc_len
argument_list|,
name|csapp
argument_list|)
expr_stmt|;
name|buff
operator|+=
name|len
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
block|}
comment|/* 	 * Set the address of the CSU Req message and 	 * return the length of processed data 	 */
operator|*
name|csupp
operator|=
name|csup
expr_stmt|;
return|return
operator|(
name|proc_len
operator|)
return|;
name|csu_invalid
label|:
if|if
condition|(
name|csup
condition|)
name|scsp_free_csu
argument_list|(
name|csup
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a Hello message  *  * Arguments:  *	buff	pointer to start of Hello in message  *	pdu_len	length of input packet  *	hpp	pointer to location to put pointer to Hello message  *  * Returns:  *	0	input was invalid  *	else	length of Hello message processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_parse_hello
parameter_list|(
name|buff
parameter_list|,
name|pdu_len
parameter_list|,
name|hpp
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|pdu_len
decl_stmt|;
name|Scsp_hello
modifier|*
modifier|*
name|hpp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|proc_len
decl_stmt|;
name|struct
name|scsp_nhello
modifier|*
name|shp
init|=
operator|(
expr|struct
name|scsp_nhello
operator|*
operator|)
name|buff
decl_stmt|;
name|Scsp_hello
modifier|*
name|hp
decl_stmt|;
name|Scsp_id
modifier|*
name|idp
decl_stmt|;
name|Scsp_id
modifier|*
modifier|*
name|ridpp
decl_stmt|;
comment|/* 	 * Get memory for the returned structure 	 */
name|hp
operator|=
operator|(
name|Scsp_hello
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_hello
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
block|{
goto|goto
name|hello_invalid
goto|;
block|}
name|UM_ZERO
argument_list|(
name|hp
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_hello
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get the hello interval 	 */
name|hp
operator|->
name|hello_int
operator|=
name|ntohs
argument_list|(
name|shp
operator|->
name|sch_hi
argument_list|)
expr_stmt|;
comment|/* 	 * Get the dead factor 	 */
name|hp
operator|->
name|dead_factor
operator|=
name|ntohs
argument_list|(
name|shp
operator|->
name|sch_df
argument_list|)
expr_stmt|;
comment|/* 	 * Get the family ID 	 */
name|hp
operator|->
name|family_id
operator|=
name|ntohs
argument_list|(
name|shp
operator|->
name|sch_fid
argument_list|)
expr_stmt|;
comment|/* 	 * Process the mandatory common part of the message 	 */
name|proc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_nhello
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_nmcp
argument_list|)
expr_stmt|;
name|buff
operator|+=
name|proc_len
expr_stmt|;
name|len
operator|=
name|scsp_parse_mcp
argument_list|(
name|buff
argument_list|,
name|pdu_len
operator|-
name|proc_len
argument_list|,
operator|&
name|hp
operator|->
name|hello_mcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|hello_invalid
goto|;
name|buff
operator|+=
name|len
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
comment|/* 	 * Get additional receiver ID records from the message 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ridpp
operator|=
operator|&
name|hp
operator|->
name|hello_mcp
operator|.
name|rid
operator|.
name|next
init|;
name|i
operator|<
name|hp
operator|->
name|hello_mcp
operator|.
name|rec_cnt
condition|;
name|i
operator|++
operator|,
name|ridpp
operator|=
operator|&
name|idp
operator|->
name|next
control|)
block|{
name|idp
operator|=
operator|(
name|Scsp_id
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|idp
condition|)
block|{
goto|goto
name|hello_invalid
goto|;
block|}
name|UM_ZERO
argument_list|(
name|idp
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_id
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|scsp_parse_id
argument_list|(
name|buff
argument_list|,
name|hp
operator|->
name|hello_mcp
operator|.
name|rid
operator|.
name|id_len
argument_list|,
name|idp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|UM_FREE
argument_list|(
name|idp
argument_list|)
expr_stmt|;
goto|goto
name|hello_invalid
goto|;
block|}
name|buff
operator|+=
name|len
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
operator|*
name|ridpp
operator|=
name|idp
expr_stmt|;
block|}
comment|/* 	 * Set the address of the CA message and 	 * return the length of processed data 	 */
operator|*
name|hpp
operator|=
name|hp
expr_stmt|;
return|return
operator|(
name|proc_len
operator|)
return|;
name|hello_invalid
label|:
if|if
condition|(
name|hp
condition|)
name|scsp_free_hello
argument_list|(
name|hp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse an SCSP input packet  *  * Arguments:  *	buff	pointer to input packet  *	pdu_len	length of input packet  *  * Returns:  *	NULL	input packet was invalid  *	else	pointer to packet in internal format  *  */
end_comment

begin_function
name|Scsp_msg
modifier|*
name|scsp_parse_msg
parameter_list|(
name|buff
parameter_list|,
name|pdu_len
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|pdu_len
decl_stmt|;
block|{
name|int
name|ext_off
decl_stmt|,
name|len
decl_stmt|,
name|plen
decl_stmt|;
name|struct
name|scsp_nhdr
modifier|*
name|shp
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
init|=
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
decl_stmt|;
name|Scsp_ext
modifier|*
modifier|*
name|expp
decl_stmt|;
comment|/* 	 * Check the message checksum 	 */
if|if
condition|(
name|ip_checksum
argument_list|(
name|buff
argument_list|,
name|pdu_len
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Checksum was bad--discard the message 		 */
goto|goto
name|ignore
goto|;
block|}
comment|/* 	 * Allocate storage for the message 	 */
name|msg
operator|=
operator|(
name|Scsp_msg
operator|*
operator|)
name|UM_ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|Scsp_msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
block|{
goto|goto
name|ignore
goto|;
block|}
name|UM_ZERO
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|Scsp_msg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Decode the fixed header 	 * 	 * Check the version 	 */
name|shp
operator|=
operator|(
expr|struct
name|scsp_nhdr
operator|*
operator|)
name|buff
expr_stmt|;
if|if
condition|(
name|shp
operator|->
name|sh_ver
operator|!=
name|SCSP_VER_1
condition|)
goto|goto
name|ignore
goto|;
comment|/* 	 * Get the message type 	 */
name|msg
operator|->
name|sc_msg_type
operator|=
name|shp
operator|->
name|sh_type
expr_stmt|;
comment|/* 	 * Get and check the length 	 */
name|len
operator|=
name|ntohs
argument_list|(
name|shp
operator|->
name|sh_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|pdu_len
condition|)
goto|goto
name|ignore
goto|;
comment|/* 	 * Get the extension offset 	 */
name|ext_off
operator|=
name|ntohs
argument_list|(
name|shp
operator|->
name|sh_ext_off
argument_list|)
expr_stmt|;
comment|/* 	 * Decode the body of the message, depending on the type 	 */
name|buff
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_nhdr
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_nhdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|sc_msg_type
condition|)
block|{
case|case
name|SCSP_CA_MSG
case|:
name|plen
operator|=
name|scsp_parse_ca
argument_list|(
name|buff
argument_list|,
name|len
argument_list|,
operator|&
name|msg
operator|->
name|sc_ca
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSP_CSU_REQ_MSG
case|:
case|case
name|SCSP_CSU_REPLY_MSG
case|:
case|case
name|SCSP_CSUS_MSG
case|:
name|plen
operator|=
name|scsp_parse_csu
argument_list|(
name|buff
argument_list|,
name|len
argument_list|,
operator|&
name|msg
operator|->
name|sc_csu_msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSP_HELLO_MSG
case|:
name|plen
operator|=
name|scsp_parse_hello
argument_list|(
name|buff
argument_list|,
name|len
argument_list|,
operator|&
name|msg
operator|->
name|sc_hello
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|ignore
goto|;
block|}
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
goto|goto
name|ignore
goto|;
block|}
name|buff
operator|+=
name|plen
expr_stmt|;
name|len
operator|-=
name|plen
expr_stmt|;
comment|/* 	 * Decode any extensions 	 */
if|if
condition|(
name|ext_off
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|expp
operator|=
operator|&
name|msg
operator|->
name|sc_ext
init|;
name|len
operator|>
literal|0
condition|;
name|expp
operator|=
operator|&
operator|(
operator|*
name|expp
operator|)
operator|->
name|next
control|)
block|{
name|plen
operator|=
name|scsp_parse_ext
argument_list|(
name|buff
argument_list|,
name|len
argument_list|,
name|expp
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
goto|goto
name|ignore
goto|;
block|}
name|buff
operator|+=
name|plen
expr_stmt|;
name|len
operator|-=
name|plen
expr_stmt|;
block|}
block|}
comment|/* 	 * Make sure we handled the whole message 	 */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
goto|goto
name|ignore
goto|;
block|}
comment|/* 	 * Return the address of the SCSP message in internal format 	 */
return|return
operator|(
name|msg
operator|)
return|;
name|ignore
label|:
if|if
condition|(
name|msg
condition|)
name|scsp_free_msg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
return|;
block|}
end_function

end_unit

