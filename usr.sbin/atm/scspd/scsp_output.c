begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * ===================================  * HARP  |  Host ATM Research Platform  * ===================================  *  *  * This Host ATM Research Platform ("HARP") file (the "Software") is  * made available by Network Computing Services, Inc. ("NetworkCS")  * "AS IS".  NetworkCS does not provide maintenance, improvements or  * support of any kind.  *  * NETWORKCS MAKES NO WARRANTIES OR REPRESENTATIONS, EXPRESS OR IMPLIED,  * INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE, AS TO ANY ELEMENT OF THE  * SOFTWARE OR ANY SUPPORT PROVIDED IN CONNECTION WITH THIS SOFTWARE.  * In no event shall NetworkCS be responsible for any damages, including  * but not limited to consequential damages, arising from or relating to  * any use of the Software or related support.  *  * Copyright 1994-1998 Network Computing Services, Inc.  *  * Copies of this Software may be made, however, the above copyright  * notice must be reproduced on all copies.  *  *	@(#) $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Server Cache Synchronization Protocol (SCSP) Support  * ----------------------------------------------------  *  * Output packet processing  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<libatm.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"scsp_msg.h"
end_include

begin_include
include|#
directive|include
file|"scsp_if.h"
end_include

begin_include
include|#
directive|include
file|"scsp_var.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"@(#) $FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Put a long integer into the output buffer  *  * This routine is provided for cases where long ints may not be  * word-aligned in the output buffer.  *  * Arguments:  *	l	long integer  *	cp	pointer to output buffer  *  * Returns:  *	None  *  */
end_comment

begin_function
specifier|static
name|void
name|put_long
parameter_list|(
name|l
parameter_list|,
name|cp
parameter_list|)
name|u_long
name|l
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
block|{
name|u_long
name|nl
decl_stmt|;
comment|/* 	 * Convert to network order and copy to output buffer 	 */
name|nl
operator|=
name|htonl
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|UM_COPY
argument_list|(
operator|&
name|nl
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Format a Sender or Receiver ID  *  * Arguments:  *	idp	ponter to ID structure  *	buff	pointer to ID  *  * Returns:  *	0	input was invalid  *	else	length of ID processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_format_id
parameter_list|(
name|idp
parameter_list|,
name|buff
parameter_list|)
name|Scsp_id
modifier|*
name|idp
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
block|{
comment|/* 	 * Copy the ID 	 */
name|UM_COPY
argument_list|(
name|idp
operator|->
name|id
argument_list|,
name|buff
argument_list|,
name|idp
operator|->
name|id_len
argument_list|)
expr_stmt|;
comment|/* 	 * Return the ID length 	 */
return|return
operator|(
name|idp
operator|->
name|id_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Format the Mandatory Common Part of an SCSP input packet  *  * Arguments:  *	mcp	pointer to MCP  *	buff	pointer to mandatory common part  *  * Returns:  *	0	input was invalid  *	else	length of MCP in message  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_format_mcp
parameter_list|(
name|mcp
parameter_list|,
name|buff
parameter_list|)
name|Scsp_mcp
modifier|*
name|mcp
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|odp
decl_stmt|;
name|struct
name|scsp_nmcp
modifier|*
name|smp
decl_stmt|;
comment|/* 	 * Set the protocol ID 	 */
name|smp
operator|=
operator|(
expr|struct
name|scsp_nmcp
operator|*
operator|)
name|buff
expr_stmt|;
name|smp
operator|->
name|sm_pid
operator|=
name|htons
argument_list|(
name|mcp
operator|->
name|pid
argument_list|)
expr_stmt|;
comment|/* 	 * Set the server group ID 	 */
name|smp
operator|->
name|sm_sgid
operator|=
name|htons
argument_list|(
name|mcp
operator|->
name|sgid
argument_list|)
expr_stmt|;
comment|/* 	 * Set the flags 	 */
name|smp
operator|->
name|sm_flags
operator|=
name|htons
argument_list|(
name|mcp
operator|->
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * Set the sender ID and length 	 */
name|smp
operator|->
name|sm_sid_len
operator|=
name|mcp
operator|->
name|sid
operator|.
name|id_len
expr_stmt|;
name|odp
operator|=
name|buff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_nmcp
argument_list|)
expr_stmt|;
name|len
operator|=
name|scsp_format_id
argument_list|(
operator|&
name|mcp
operator|->
name|sid
argument_list|,
name|odp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
goto|goto
name|mcp_invalid
goto|;
block|}
comment|/* 	 * Set the receiver ID and length 	 */
name|smp
operator|->
name|sm_rid_len
operator|=
name|mcp
operator|->
name|rid
operator|.
name|id_len
expr_stmt|;
name|odp
operator|+=
name|mcp
operator|->
name|sid
operator|.
name|id_len
expr_stmt|;
name|len
operator|=
name|scsp_format_id
argument_list|(
operator|&
name|mcp
operator|->
name|rid
argument_list|,
name|odp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
goto|goto
name|mcp_invalid
goto|;
block|}
comment|/* 	 * Set the record count 	 */
name|smp
operator|->
name|sm_rec_cnt
operator|=
name|htons
argument_list|(
name|mcp
operator|->
name|rec_cnt
argument_list|)
expr_stmt|;
comment|/* 	 * Return the length of data we processed 	 */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_nmcp
argument_list|)
operator|+
name|mcp
operator|->
name|sid
operator|.
name|id_len
operator|+
name|mcp
operator|->
name|rid
operator|.
name|id_len
operator|)
return|;
name|mcp_invalid
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Format an Extension  *  * Arguments:  *	exp	pointer to extension in internal format  *	buff	pointer to output buffer  *	blen	space available in buffer  *  * Returns:  *	0	input was invalid  *	else	length of extension processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_format_ext
parameter_list|(
name|exp
parameter_list|,
name|buff
parameter_list|,
name|blen
parameter_list|)
name|Scsp_ext
modifier|*
name|exp
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|blen
decl_stmt|;
block|{
name|struct
name|scsp_next
modifier|*
name|sep
decl_stmt|;
comment|/* 	 * Make sure there's room in the buffer 	 */
if|if
condition|(
name|blen
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_next
argument_list|)
operator|+
name|exp
operator|->
name|len
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Set the type 	 */
name|sep
operator|=
operator|(
expr|struct
name|scsp_next
operator|*
operator|)
name|buff
expr_stmt|;
name|sep
operator|->
name|se_type
operator|=
name|htons
argument_list|(
name|exp
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* 	 * Set the length 	 */
name|sep
operator|->
name|se_len
operator|=
name|htons
argument_list|(
name|exp
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Set the value 	 */
if|if
condition|(
name|exp
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|buff
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_next
argument_list|)
expr_stmt|;
name|UM_COPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|exp
operator|+
sizeof|sizeof
argument_list|(
name|Scsp_ext
argument_list|)
argument_list|,
name|buff
argument_list|,
name|exp
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Return the number of bytes processed 	 */
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_next
argument_list|)
operator|+
name|exp
operator|->
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Format the ATMARP part of a CSA record  *  * Arguments:  *	acsp	pointer to ATMARP protocol-specific CSA record  *	buff	pointer to output buffer  *  * Returns:  *	0	input was invalid  *	else	length of record processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_format_atmarp
parameter_list|(
name|acsp
parameter_list|,
name|buff
parameter_list|)
name|Scsp_atmarp_csa
modifier|*
name|acsp
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|pkt_len
decl_stmt|;
name|struct
name|scsp_atmarp_ncsa
modifier|*
name|sanp
decl_stmt|;
comment|/* 	 * Figure out how long PDU is going to be 	 */
name|pkt_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_atmarp_ncsa
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|acsp
operator|->
name|sa_sha
operator|.
name|address_format
condition|)
block|{
case|case
name|T_ATM_ENDSYS_ADDR
case|:
name|pkt_len
operator|+=
name|acsp
operator|->
name|sa_sha
operator|.
name|address_length
expr_stmt|;
break|break;
case|case
name|T_ATM_E164_ADDR
case|:
name|pkt_len
operator|+=
name|acsp
operator|->
name|sa_sha
operator|.
name|address_length
expr_stmt|;
if|if
condition|(
name|acsp
operator|->
name|sa_ssa
operator|.
name|address_format
operator|==
name|T_ATM_ENDSYS_ADDR
condition|)
name|pkt_len
operator|+=
name|acsp
operator|->
name|sa_ssa
operator|.
name|address_length
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|acsp
operator|->
name|sa_tha
operator|.
name|address_format
condition|)
block|{
case|case
name|T_ATM_ENDSYS_ADDR
case|:
name|pkt_len
operator|+=
name|acsp
operator|->
name|sa_tha
operator|.
name|address_length
expr_stmt|;
break|break;
case|case
name|T_ATM_E164_ADDR
case|:
name|pkt_len
operator|+=
name|acsp
operator|->
name|sa_tha
operator|.
name|address_length
expr_stmt|;
if|if
condition|(
name|acsp
operator|->
name|sa_tha
operator|.
name|address_format
operator|==
name|T_ATM_ENDSYS_ADDR
condition|)
name|pkt_len
operator|+=
name|acsp
operator|->
name|sa_tha
operator|.
name|address_length
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|acsp
operator|->
name|sa_spa
operator|.
name|s_addr
operator|!=
literal|0
condition|)
name|pkt_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|acsp
operator|->
name|sa_tpa
operator|.
name|s_addr
operator|!=
literal|0
condition|)
name|pkt_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Set up pointers 	 */
name|sanp
operator|=
operator|(
expr|struct
name|scsp_atmarp_ncsa
operator|*
operator|)
name|buff
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|sanp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_atmarp_ncsa
argument_list|)
expr_stmt|;
comment|/* 	 * Build fields 	 */
name|sanp
operator|->
name|sa_hrd
operator|=
name|htons
argument_list|(
name|ARP_ATMFORUM
argument_list|)
expr_stmt|;
name|sanp
operator|->
name|sa_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
comment|/* sa_sha */
name|len
operator|=
name|acsp
operator|->
name|sa_sha
operator|.
name|address_length
expr_stmt|;
switch|switch
condition|(
name|acsp
operator|->
name|sa_sha
operator|.
name|address_format
condition|)
block|{
case|case
name|T_ATM_ENDSYS_ADDR
case|:
name|sanp
operator|->
name|sa_shtl
operator|=
name|ARP_TL_NSAPA
operator||
operator|(
name|len
operator|&
name|ARP_TL_LMASK
operator|)
expr_stmt|;
comment|/* sa_sha */
name|UM_COPY
argument_list|(
name|acsp
operator|->
name|sa_sha
operator|.
name|address
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
name|sanp
operator|->
name|sa_sstl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_ATM_E164_ADDR
case|:
name|sanp
operator|->
name|sa_shtl
operator|=
name|ARP_TL_E164
operator||
operator|(
name|len
operator|&
name|ARP_TL_LMASK
operator|)
expr_stmt|;
comment|/* sa_sha */
name|UM_COPY
argument_list|(
name|acsp
operator|->
name|sa_sha
operator|.
name|address
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|acsp
operator|->
name|sa_ssa
operator|.
name|address_format
operator|==
name|T_ATM_ENDSYS_ADDR
condition|)
block|{
name|len
operator|=
name|acsp
operator|->
name|sa_ssa
operator|.
name|address_length
expr_stmt|;
name|sanp
operator|->
name|sa_sstl
operator|=
name|ARP_TL_NSAPA
operator||
operator|(
name|len
operator|&
name|ARP_TL_LMASK
operator|)
expr_stmt|;
comment|/* sa_ssa */
name|UM_COPY
argument_list|(
name|acsp
operator|->
name|sa_ssa
operator|.
name|address
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
block|}
else|else
name|sanp
operator|->
name|sa_sstl
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|sanp
operator|->
name|sa_shtl
operator|=
literal|0
expr_stmt|;
name|sanp
operator|->
name|sa_sstl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* sa_state */
name|sanp
operator|->
name|sa_state
operator|=
name|acsp
operator|->
name|sa_state
expr_stmt|;
name|sanp
operator|->
name|sa_fill1
operator|=
literal|0
expr_stmt|;
comment|/* sa_spa */
if|if
condition|(
name|acsp
operator|->
name|sa_spa
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|sanp
operator|->
name|sa_spln
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|UM_COPY
argument_list|(
operator|&
name|acsp
operator|->
name|sa_spa
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
comment|/* sa_tha */
name|len
operator|=
name|acsp
operator|->
name|sa_tha
operator|.
name|address_length
expr_stmt|;
switch|switch
condition|(
name|acsp
operator|->
name|sa_tha
operator|.
name|address_format
condition|)
block|{
case|case
name|T_ATM_ENDSYS_ADDR
case|:
name|sanp
operator|->
name|sa_thtl
operator|=
name|ARP_TL_NSAPA
operator||
operator|(
name|len
operator|&
name|ARP_TL_LMASK
operator|)
expr_stmt|;
comment|/* sa_tha */
name|UM_COPY
argument_list|(
name|acsp
operator|->
name|sa_tha
operator|.
name|address
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
name|sanp
operator|->
name|sa_tstl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_ATM_E164_ADDR
case|:
name|sanp
operator|->
name|sa_thtl
operator|=
name|ARP_TL_E164
operator||
operator|(
name|len
operator|&
name|ARP_TL_LMASK
operator|)
expr_stmt|;
comment|/* sa_tha */
name|UM_COPY
argument_list|(
name|acsp
operator|->
name|sa_tha
operator|.
name|address
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|acsp
operator|->
name|sa_tsa
operator|.
name|address_format
operator|==
name|T_ATM_ENDSYS_ADDR
condition|)
block|{
name|len
operator|=
name|acsp
operator|->
name|sa_tha
operator|.
name|address_length
expr_stmt|;
name|sanp
operator|->
name|sa_tstl
operator|=
name|ARP_TL_NSAPA
operator||
operator|(
name|len
operator|&
name|ARP_TL_LMASK
operator|)
expr_stmt|;
comment|/* sa_tsa */
name|UM_COPY
argument_list|(
name|acsp
operator|->
name|sa_tsa
operator|.
name|address
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
block|}
else|else
name|sanp
operator|->
name|sa_tstl
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|sanp
operator|->
name|sa_thtl
operator|=
literal|0
expr_stmt|;
name|sanp
operator|->
name|sa_tstl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* sa_tpa */
if|if
condition|(
name|acsp
operator|->
name|sa_tpa
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|sanp
operator|->
name|sa_tpln
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|UM_COPY
argument_list|(
operator|&
name|acsp
operator|->
name|sa_tpa
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|pkt_len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Format a Cache State Advertisement or Cache State Advertisement  * Summary record  *  * Arguments:  *	csapp	pointer to CSA or CSAS  *	buff	pointer to output buffer  *  * Returns:  *	0	input was invalid  *	else	length of record processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_format_csa
parameter_list|(
name|csap
parameter_list|,
name|buff
parameter_list|)
name|Scsp_csa
modifier|*
name|csap
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|odp
decl_stmt|;
name|struct
name|scsp_ncsa
modifier|*
name|scp
decl_stmt|;
comment|/* 	 * Set the hop count 	 */
name|scp
operator|=
operator|(
expr|struct
name|scsp_ncsa
operator|*
operator|)
name|buff
expr_stmt|;
name|scp
operator|->
name|scs_hop_cnt
operator|=
name|htons
argument_list|(
name|csap
operator|->
name|hops
argument_list|)
expr_stmt|;
comment|/* 	 * Set the null flag 	 */
if|if
condition|(
name|csap
operator|->
name|null
condition|)
block|{
name|scp
operator|->
name|scs_nfill
operator|=
name|htons
argument_list|(
name|SCSP_CSAS_NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the sequence number 	 */
name|put_long
argument_list|(
name|csap
operator|->
name|seq
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|scp
operator|->
name|scs_seq
argument_list|)
expr_stmt|;
comment|/* 	 * Set the cache key 	 */
name|scp
operator|->
name|scs_ck_len
operator|=
name|csap
operator|->
name|key
operator|.
name|key_len
expr_stmt|;
name|odp
operator|=
name|buff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_ncsa
argument_list|)
expr_stmt|;
name|UM_COPY
argument_list|(
name|csap
operator|->
name|key
operator|.
name|key
argument_list|,
name|odp
argument_list|,
name|scp
operator|->
name|scs_ck_len
argument_list|)
expr_stmt|;
comment|/* 	 * Set the originator ID 	 */
name|odp
operator|+=
name|scp
operator|->
name|scs_ck_len
expr_stmt|;
name|scp
operator|->
name|scs_oid_len
operator|=
name|scsp_format_id
argument_list|(
operator|&
name|csap
operator|->
name|oid
argument_list|,
name|odp
argument_list|)
expr_stmt|;
comment|/* 	 * Set the protocol-specific data, if present.  At the 	 * moment, we only handle data for ATMARP. 	 */
if|if
condition|(
name|csap
operator|->
name|atmarp_data
condition|)
block|{
name|odp
operator|+=
name|scp
operator|->
name|scs_oid_len
expr_stmt|;
name|len
operator|=
name|scsp_format_atmarp
argument_list|(
name|csap
operator|->
name|atmarp_data
argument_list|,
name|odp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the record length 	 */
name|scp
operator|->
name|scs_len
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_ncsa
argument_list|)
operator|+
name|scp
operator|->
name|scs_ck_len
operator|+
name|scp
operator|->
name|scs_oid_len
operator|+
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Return the length of data we processed 	 */
return|return
operator|(
name|ntohs
argument_list|(
name|scp
operator|->
name|scs_len
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Format a Cache Alignment message  *  * Arguments:  *	cap	pointer to CA message  *	buff	pointer to output buffer  *	blen	space available in buffer  *  * Returns:  *	0	input was invalid  *	else	length of CA message processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_format_ca
parameter_list|(
name|cap
parameter_list|,
name|buff
parameter_list|,
name|blen
parameter_list|)
name|Scsp_ca
modifier|*
name|cap
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|blen
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|proc_len
decl_stmt|;
name|struct
name|scsp_nca
modifier|*
name|scap
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
decl_stmt|;
comment|/* 	 * Set the sequence number 	 */
name|scap
operator|=
operator|(
expr|struct
name|scsp_nca
operator|*
operator|)
name|buff
expr_stmt|;
name|put_long
argument_list|(
name|cap
operator|->
name|ca_seq
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|scap
operator|->
name|sca_seq
argument_list|)
expr_stmt|;
name|proc_len
operator|=
sizeof|sizeof
argument_list|(
name|scap
operator|->
name|sca_seq
argument_list|)
expr_stmt|;
name|buff
operator|+=
sizeof|sizeof
argument_list|(
name|scap
operator|->
name|sca_seq
argument_list|)
expr_stmt|;
comment|/* 	 * Set the flags 	 */
name|cap
operator|->
name|ca_mcp
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cap
operator|->
name|ca_m
condition|)
name|cap
operator|->
name|ca_mcp
operator|.
name|flags
operator||=
name|SCSP_CA_M
expr_stmt|;
if|if
condition|(
name|cap
operator|->
name|ca_i
condition|)
name|cap
operator|->
name|ca_mcp
operator|.
name|flags
operator||=
name|SCSP_CA_I
expr_stmt|;
if|if
condition|(
name|cap
operator|->
name|ca_o
condition|)
name|cap
operator|->
name|ca_mcp
operator|.
name|flags
operator||=
name|SCSP_CA_O
expr_stmt|;
comment|/* 	 * Format the mandatory common part of the message 	 */
name|len
operator|=
name|scsp_format_mcp
argument_list|(
operator|&
name|cap
operator|->
name|ca_mcp
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|ca_invalid
goto|;
name|buff
operator|+=
name|len
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
comment|/* 	 * Put any CSAS records into the message 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|csap
operator|=
name|cap
operator|->
name|ca_csa_rec
init|;
name|i
operator|<
name|cap
operator|->
name|ca_mcp
operator|.
name|rec_cnt
condition|;
name|i
operator|++
operator|,
name|csap
operator|=
name|csap
operator|->
name|next
control|)
block|{
name|len
operator|=
name|scsp_format_csa
argument_list|(
name|csap
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|buff
operator|+=
name|len
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|proc_len
operator|>
name|blen
condition|)
block|{
name|scsp_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"scsp_format_ca: buffer overflow"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 	 * Return the length of processed data 	 */
return|return
operator|(
name|proc_len
operator|)
return|;
name|ca_invalid
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Format a Cache State Update Request, Cache State Update Reply, or  * Cache State Update Solicit message.  These all have the same format,  * a Mandatory Common Part followed by a number of CSA or CSAS records.  *  * Arguments:  *	csup	pointer to location to put pointer to CSU Req message  *	buff	pointer to output buffer  *	blen	space available in buffer  *  * Returns:  *	0	input was invalid  *	else	length of CSU Req message processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_format_csu
parameter_list|(
name|csup
parameter_list|,
name|buff
parameter_list|,
name|blen
parameter_list|)
name|Scsp_csu_msg
modifier|*
name|csup
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|blen
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|proc_len
decl_stmt|;
name|struct
name|scsp_ncsu_msg
modifier|*
name|scsup
decl_stmt|;
name|Scsp_csa
modifier|*
name|csap
decl_stmt|;
comment|/* 	 * Format the mandatory common part of the message 	 */
name|scsup
operator|=
operator|(
expr|struct
name|scsp_ncsu_msg
operator|*
operator|)
name|buff
expr_stmt|;
name|len
operator|=
name|scsp_format_mcp
argument_list|(
operator|&
name|csup
operator|->
name|csu_mcp
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|csu_invalid
goto|;
name|buff
operator|+=
name|len
expr_stmt|;
name|proc_len
operator|=
name|len
expr_stmt|;
comment|/* 	 * Put the CSAS records into the message 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|csap
operator|=
name|csup
operator|->
name|csu_csa_rec
init|;
name|i
operator|<
name|csup
operator|->
name|csu_mcp
operator|.
name|rec_cnt
operator|&&
name|csap
condition|;
name|i
operator|++
operator|,
name|csap
operator|=
name|csap
operator|->
name|next
control|)
block|{
name|len
operator|=
name|scsp_format_csa
argument_list|(
name|csap
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|buff
operator|+=
name|len
expr_stmt|;
name|proc_len
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|proc_len
operator|>
name|blen
condition|)
block|{
name|scsp_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"scsp_format_csu: buffer overflow"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 	 * Return the length of processed data 	 */
return|return
operator|(
name|proc_len
operator|)
return|;
name|csu_invalid
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Format a Hello message  *  * Arguments:  *	hpp	pointer to Hello message  *	buff	pointer to output buffer  *	blen	space available in buffer  *  * Returns:  *	0	input was invalid  *	else	length of Hello message processed  *  */
end_comment

begin_function
specifier|static
name|int
name|scsp_format_hello
parameter_list|(
name|hp
parameter_list|,
name|buff
parameter_list|,
name|blen
parameter_list|)
name|Scsp_hello
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|blen
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|proc_len
decl_stmt|;
name|struct
name|scsp_nhello
modifier|*
name|shp
decl_stmt|;
name|Scsp_id
modifier|*
name|ridp
decl_stmt|;
comment|/* 	 * Set the hello interval 	 */
name|shp
operator|=
operator|(
expr|struct
name|scsp_nhello
operator|*
operator|)
name|buff
expr_stmt|;
name|shp
operator|->
name|sch_hi
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|hello_int
argument_list|)
expr_stmt|;
comment|/* 	 * Set the dead factor 	 */
name|shp
operator|->
name|sch_df
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|dead_factor
argument_list|)
expr_stmt|;
comment|/* 	 * Set the family ID 	 */
name|shp
operator|->
name|sch_fid
operator|=
name|htons
argument_list|(
name|hp
operator|->
name|family_id
argument_list|)
expr_stmt|;
comment|/* 	 * Process the mandatory common part of the message 	 */
name|proc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_nhello
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_nmcp
argument_list|)
expr_stmt|;
name|buff
operator|+=
name|proc_len
expr_stmt|;
name|len
operator|=
name|scsp_format_mcp
argument_list|(
operator|&
name|hp
operator|->
name|hello_mcp
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|hello_invalid
goto|;
name|proc_len
operator|+=
name|len
expr_stmt|;
name|buff
operator|+=
name|len
expr_stmt|;
comment|/* 	 * Add any additional receiver ID records to the message 	 */
for|for
control|(
name|ridp
operator|=
name|hp
operator|->
name|hello_mcp
operator|.
name|rid
operator|.
name|next
init|;
name|ridp
condition|;
name|ridp
operator|=
name|ridp
operator|->
name|next
control|)
block|{
name|len
operator|=
name|scsp_format_id
argument_list|(
name|ridp
argument_list|,
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
goto|goto
name|hello_invalid
goto|;
block|}
name|proc_len
operator|+=
name|len
expr_stmt|;
name|buff
operator|+=
name|len
expr_stmt|;
block|}
comment|/* 	 * Return the length of the Hello message body 	 */
if|if
condition|(
name|proc_len
operator|>
name|blen
condition|)
block|{
name|scsp_log
argument_list|(
name|LOG_CRIT
argument_list|,
literal|"scsp_format_hello: buffer overflow"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|proc_len
operator|)
return|;
name|hello_invalid
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Format an SCSP output packet  *  * Arguments:  *	dcsp	pointer to DCS for which message is being prepared  *	msg	pointer to input packet  *	bpp	pointer to location to put pointer to formatted packet  *  * Returns:  *	0	input packet was invalid  *	else	length of formatted packet  *  */
end_comment

begin_function
name|int
name|scsp_format_msg
parameter_list|(
name|dcsp
parameter_list|,
name|msg
parameter_list|,
name|bpp
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
decl_stmt|;
name|char
modifier|*
modifier|*
name|bpp
decl_stmt|;
block|{
name|char
modifier|*
name|buff
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|,
modifier|*
name|e_buff
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|buff_len
decl_stmt|,
name|e_buff_len
decl_stmt|;
name|int
name|e_len
decl_stmt|,
name|len
decl_stmt|,
name|plen
decl_stmt|;
name|struct
name|scsp_nhdr
modifier|*
name|shp
decl_stmt|;
name|Scsp_ext
modifier|*
name|exp
decl_stmt|;
comment|/* 	 * Allocate a buffer for the message 	 */
name|buff_len
operator|=
name|dcsp
operator|->
name|sd_server
operator|->
name|ss_mtu
expr_stmt|;
name|buff
operator|=
operator|(
name|char
operator|*
operator|)
name|UM_ALLOC
argument_list|(
name|buff_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buff
condition|)
block|{
name|scsp_mem_err
argument_list|(
literal|"scsp_format_msg: dcsp->sd_server->ss_mtu"
argument_list|)
expr_stmt|;
block|}
name|UM_ZERO
argument_list|(
name|buff
argument_list|,
name|buff_len
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|buff
expr_stmt|;
comment|/* 	 * Encode the fixed header 	 * 	 * Set the version 	 */
name|shp
operator|=
operator|(
expr|struct
name|scsp_nhdr
operator|*
operator|)
name|buff
expr_stmt|;
name|shp
operator|->
name|sh_ver
operator|=
name|SCSP_VER_1
expr_stmt|;
comment|/* 	 * Set the message type 	 */
name|shp
operator|->
name|sh_type
operator|=
name|msg
operator|->
name|sc_msg_type
expr_stmt|;
comment|/* 	 * Point past the fixed header 	 */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsp_nhdr
argument_list|)
expr_stmt|;
name|buff_len
operator|-=
name|len
expr_stmt|;
comment|/* 	 * Encode any extensions into a temporary buffer 	 */
name|e_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|sc_ext
condition|)
block|{
comment|/* 		 * Get a buffer for the extensions 		 */
name|e_buff_len
operator|=
literal|1024
expr_stmt|;
name|e_buff
operator|=
operator|(
name|char
operator|*
operator|)
name|UM_ALLOC
argument_list|(
name|e_buff_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buff
condition|)
block|{
name|scsp_mem_err
argument_list|(
literal|"scsp_format_msg: e_buff_len"
argument_list|)
expr_stmt|;
block|}
name|UM_ZERO
argument_list|(
name|e_buff
argument_list|,
name|e_buff_len
argument_list|)
expr_stmt|;
comment|/* 		 * Encode the extensions 		 */
for|for
control|(
name|exp
operator|=
name|msg
operator|->
name|sc_ext
operator|=
literal|0
init|;
name|exp
condition|;
name|exp
operator|=
name|exp
operator|->
name|next
control|)
block|{
name|plen
operator|=
name|scsp_format_ext
argument_list|(
name|exp
argument_list|,
name|e_buff
operator|+
name|e_len
argument_list|,
name|e_buff_len
operator|-
name|e_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
goto|goto
name|ignore
goto|;
block|}
name|e_len
operator|+=
name|plen
expr_stmt|;
block|}
comment|/* 		 * Free the buffer if we didn't use it 		 */
if|if
condition|(
operator|!
name|e_len
condition|)
block|{
name|UM_FREE
argument_list|(
name|e_buff
argument_list|)
expr_stmt|;
name|e_buff
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
name|buff_len
operator|-=
name|e_len
expr_stmt|;
comment|/* 	 * Encode the body of the message, depending on the type 	 */
switch|switch
condition|(
name|msg
operator|->
name|sc_msg_type
condition|)
block|{
case|case
name|SCSP_CA_MSG
case|:
name|plen
operator|=
name|scsp_format_ca
argument_list|(
name|msg
operator|->
name|sc_ca
argument_list|,
name|buff
operator|+
name|len
argument_list|,
name|buff_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSP_CSU_REQ_MSG
case|:
case|case
name|SCSP_CSU_REPLY_MSG
case|:
case|case
name|SCSP_CSUS_MSG
case|:
name|plen
operator|=
name|scsp_format_csu
argument_list|(
name|msg
operator|->
name|sc_csu_msg
argument_list|,
name|buff
operator|+
name|len
argument_list|,
name|buff_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSP_HELLO_MSG
case|:
name|plen
operator|=
name|scsp_format_hello
argument_list|(
name|msg
operator|->
name|sc_hello
argument_list|,
name|buff
operator|+
name|len
argument_list|,
name|buff_len
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|ignore
goto|;
block|}
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
goto|goto
name|ignore
goto|;
block|}
name|len
operator|+=
name|plen
expr_stmt|;
comment|/* 	 * Copy the extensions to the end of the message 	 */
if|if
condition|(
name|e_len
condition|)
block|{
name|shp
operator|->
name|sh_ext_off
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|UM_COPY
argument_list|(
name|e_buff
argument_list|,
name|buff
operator|+
name|len
argument_list|,
name|e_len
argument_list|)
expr_stmt|;
name|UM_FREE
argument_list|(
name|e_buff
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the length 	 */
name|shp
operator|->
name|sh_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the message checksum 	 */
name|shp
operator|->
name|sh_checksum
operator|=
name|htons
argument_list|(
name|ip_checksum
argument_list|(
name|buff
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Return the length of the buffer 	 */
return|return
operator|(
name|len
operator|)
return|;
name|ignore
label|:
if|if
condition|(
name|buff
condition|)
name|UM_FREE
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|e_buff
condition|)
name|UM_FREE
argument_list|(
name|e_buff
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send an SCSP message  *  * Arguments:  *	dcsp	pointer to DCS control block  *	msg	pointer to message to send  *  * Returns:  *	0	success  *	errno	error encountered  *  */
end_comment

begin_function
name|int
name|scsp_send_msg
parameter_list|(
name|dcsp
parameter_list|,
name|msg
parameter_list|)
name|Scsp_dcs
modifier|*
name|dcsp
decl_stmt|;
name|Scsp_msg
modifier|*
name|msg
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|rc
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
comment|/* 	 * Make sure we have a socket open 	 */
if|if
condition|(
name|dcsp
operator|->
name|sd_sock
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
comment|/* 	 * Trace the message 	 */
if|if
condition|(
operator|(
operator|(
name|scsp_trace_mode
operator|&
name|SCSP_TRACE_HELLO_MSG
operator|)
operator|&&
name|msg
operator|->
name|sc_msg_type
operator|==
name|SCSP_HELLO_MSG
operator|)
operator|||
operator|(
operator|(
name|scsp_trace_mode
operator|&
name|SCSP_TRACE_CA_MSG
operator|)
operator|&&
name|msg
operator|->
name|sc_msg_type
operator|!=
name|SCSP_HELLO_MSG
operator|)
condition|)
block|{
name|scsp_trace_msg
argument_list|(
name|dcsp
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scsp_trace
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Put the message into network format 	 */
name|len
operator|=
name|scsp_format_msg
argument_list|(
name|dcsp
argument_list|,
name|msg
argument_list|,
operator|&
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|scsp_log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"scsp_send_msg: message conversion failed\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Write the message to the DCS 	 */
name|rc
operator|=
name|write
argument_list|(
name|dcsp
operator|->
name|sd_sock
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|UM_FREE
argument_list|(
name|buff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
name|len
operator|||
operator|(
name|rc
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINPROGRESS
operator|)
condition|)
block|{
name|rc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * There was an error on the write--close the VCC 		 */
operator|(
name|void
operator|)
name|close
argument_list|(
name|dcsp
operator|->
name|sd_sock
argument_list|)
expr_stmt|;
name|dcsp
operator|->
name|sd_sock
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Inform the Hello FSM 		 */
operator|(
name|void
operator|)
name|scsp_hfsm
argument_list|(
name|dcsp
argument_list|,
name|SCSP_HFSM_VC_CLOSED
argument_list|,
operator|(
name|Scsp_msg
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Set the return code 		 */
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
name|rc
operator|=
name|errno
expr_stmt|;
else|else
name|rc
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

