begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002, 2003 Greg Lehey  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * This software is provided by the author ``as is'' and any express  * or implied warranties, including, but not limited to, the implied  * warranties of merchantability and fitness for a particular purpose  * are disclaimed.  In no event shall the author be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability,  * whether in contract, strict liability, or tort (including  * negligence or otherwise) arising in any way out of the use of this  * software, even if advised of the possibility of such damage.  */
end_comment

begin_comment
comment|/* $Id: asf.c,v 1.4 2003/05/04 02:55:20 grog Exp grog $ */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fts.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"asf.h"
end_include

begin_struct
struct|struct
name|kfile
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|seen
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|kfile
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|kfile
argument_list|)
name|kfile_head
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|kfile_head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|kfile_add
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|caddr_t
name|addr
parameter_list|)
block|{
name|struct
name|kfile
modifier|*
name|kfp
decl_stmt|;
if|if
condition|(
operator|(
name|kfp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kfp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|kfp
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|kfp
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|kfp
operator|->
name|seen
operator|=
literal|0
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kfile_head
argument_list|,
name|kfp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|kfile
modifier|*
name|kfile_find
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|kfile
modifier|*
name|kfp
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|kfp
argument_list|,
argument|&kfile_head
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|kfp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|kfp
operator|)
return|;
comment|/* found */
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* not found */
block|}
end_function

begin_function
specifier|static
name|int
name|kfile_allseen
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kfile
modifier|*
name|kfp
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|kfp
argument_list|,
argument|&kfile_head
argument_list|,
argument|link
argument_list|)
if|if
condition|(
operator|!
name|kfp
operator|->
name|seen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* at least one unseen */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* all seen */
block|}
end_function

begin_function
specifier|static
name|int
name|kfile_empty
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|kfile_head
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take a blank separated list of tokens and turn it into a list of  * individual nul-delimited strings.  Build a list of pointers at  * token, which must have enough space for the tokens.  Return the  * number of tokens, or -1 on error (typically a missing string  * delimiter).  */
end_comment

begin_function
name|int
name|tokenize
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|,
name|char
modifier|*
name|token
index|[]
parameter_list|,
name|int
name|maxtoken
parameter_list|)
block|{
name|char
name|delim
decl_stmt|;
comment|/* delimiter to search for */
name|int
name|tokennr
decl_stmt|;
comment|/* index of this token */
for|for
control|(
name|tokennr
operator|=
literal|0
init|;
name|tokennr
operator|<
name|maxtoken
condition|;
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cptr
argument_list|)
condition|)
name|cptr
operator|++
expr_stmt|;
comment|/* skip initial white space */
if|if
condition|(
operator|(
operator|*
name|cptr
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|==
literal|'#'
operator|)
condition|)
comment|/* end of line */
return|return
name|tokennr
return|;
comment|/* return number of tokens found */
name|delim
operator|=
operator|*
name|cptr
expr_stmt|;
name|token
index|[
name|tokennr
index|]
operator|=
name|cptr
expr_stmt|;
comment|/* point to it */
name|tokennr
operator|++
expr_stmt|;
comment|/* one more */
if|if
condition|(
name|tokennr
operator|==
name|maxtoken
condition|)
comment|/* run off the end? */
return|return
name|tokennr
return|;
if|if
condition|(
operator|(
name|delim
operator|==
literal|'\''
operator|)
operator|||
operator|(
name|delim
operator|==
literal|'"'
operator|)
condition|)
block|{
comment|/* delimitered */
for|for
control|(
init|;
condition|;
control|)
block|{
name|cptr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cptr
operator|==
name|delim
operator|)
operator|&&
operator|(
name|cptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|)
condition|)
block|{
comment|/* found the partner */
name|cptr
operator|++
expr_stmt|;
comment|/* move on past */
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|cptr
argument_list|)
condition|)
comment|/* no space after closing quote */
return|return
operator|-
literal|1
return|;
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* delimit */
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|cptr
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|==
literal|'\n'
operator|)
condition|)
comment|/* end of line */
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
comment|/* not quoted */
while|while
condition|(
operator|(
operator|*
name|cptr
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|!
name|isspace
argument_list|(
operator|*
name|cptr
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|cptr
operator|!=
literal|'\n'
operator|)
condition|)
name|cptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|!=
literal|'\0'
condition|)
comment|/* not end of the line, */
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* delimit and move to the next */
block|}
block|}
return|return
name|maxtoken
return|;
comment|/* can't get here */
block|}
end_function

begin_function
specifier|static
name|void
name|doobj
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|uintmax_t
name|base
init|=
operator|(
name|uintptr_t
operator|)
name|addr
decl_stmt|;
name|uintmax_t
name|textaddr
init|=
literal|0
decl_stmt|;
name|uintmax_t
name|dataaddr
init|=
literal|0
decl_stmt|;
name|uintmax_t
name|bssaddr
init|=
literal|0
decl_stmt|;
name|uintmax_t
modifier|*
name|up
decl_stmt|;
name|int
name|octokens
decl_stmt|;
name|char
modifier|*
name|octoken
index|[
name|MAXTOKEN
index|]
decl_stmt|;
name|char
name|ocbuf
index|[
name|LINE_MAX
operator|+
name|PATH_MAX
index|]
decl_stmt|;
name|FILE
modifier|*
name|objcopy
decl_stmt|;
name|snprintf
argument_list|(
name|ocbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ocbuf
argument_list|)
argument_list|,
literal|"/usr/bin/objdump --section-headers %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|objcopy
operator|=
name|popen
argument_list|(
name|ocbuf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't start %s"
argument_list|,
name|ocbuf
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|ocbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ocbuf
argument_list|)
argument_list|,
name|objcopy
argument_list|)
condition|)
block|{
name|octokens
operator|=
name|tokenize
argument_list|(
name|ocbuf
argument_list|,
name|octoken
argument_list|,
name|MAXTOKEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|octokens
operator|<=
literal|1
condition|)
continue|continue;
name|up
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|octoken
index|[
literal|1
index|]
argument_list|,
literal|".text"
argument_list|)
operator|==
literal|0
condition|)
name|up
operator|=
operator|&
name|textaddr
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|octoken
index|[
literal|1
index|]
argument_list|,
literal|".data"
argument_list|)
operator|==
literal|0
condition|)
name|up
operator|=
operator|&
name|dataaddr
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|octoken
index|[
literal|1
index|]
argument_list|,
literal|".bss"
argument_list|)
operator|==
literal|0
condition|)
name|up
operator|=
operator|&
name|bssaddr
expr_stmt|;
if|if
condition|(
name|up
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|up
operator|=
name|strtoumax
argument_list|(
name|octoken
index|[
literal|3
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
operator|+
name|base
expr_stmt|;
block|}
if|if
condition|(
name|textaddr
condition|)
block|{
comment|/* we must have a text address */
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"add-symbol-file %s 0x%jx"
argument_list|,
name|path
argument_list|,
name|textaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dataaddr
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" -s .data 0x%jx"
argument_list|,
name|dataaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bssaddr
condition|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" -s .bss 0x%jx"
argument_list|,
name|bssaddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|findmodules
parameter_list|(
name|char
modifier|*
name|path_argv
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|sfx
index|[]
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|FTS
modifier|*
name|fts
decl_stmt|;
name|FTSENT
modifier|*
name|ftsent
decl_stmt|;
name|struct
name|kfile
modifier|*
name|kfp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|sl
decl_stmt|;
comment|/* Have to fts once per suffix to find preferred suffixes first */
do|do
block|{
name|sl
operator|=
operator|*
name|sfx
condition|?
name|strlen
argument_list|(
operator|*
name|sfx
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* current suffix length */
name|fts
operator|=
name|fts_open
argument_list|(
name|path_argv
argument_list|,
name|FTS_PHYSICAL
operator||
name|FTS_NOCHDIR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fts
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't begin traversing module path"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ftsent
operator|=
name|fts_read
argument_list|(
name|fts
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ftsent
operator|->
name|fts_info
operator|==
name|FTS_DNR
operator|||
name|ftsent
operator|->
name|fts_info
operator|==
name|FTS_ERR
operator|||
name|ftsent
operator|->
name|fts_info
operator|==
name|FTS_NS
condition|)
block|{
name|errno
operator|=
name|ftsent
operator|->
name|fts_errno
expr_stmt|;
name|err
argument_list|(
literal|2
argument_list|,
literal|"error while traversing path %s"
argument_list|,
name|ftsent
operator|->
name|fts_path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ftsent
operator|->
name|fts_info
operator|!=
name|FTS_F
condition|)
continue|continue;
comment|/* not a plain file */
if|if
condition|(
name|sl
operator|>
literal|0
condition|)
block|{
comment|/* non-blank suffix; see if file name has it */
name|i
operator|=
name|ftsent
operator|->
name|fts_namelen
operator|-
name|sl
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
operator|||
name|strcmp
argument_list|(
name|ftsent
operator|->
name|fts_name
operator|+
name|i
argument_list|,
operator|*
name|sfx
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* no such suffix */
if|if
condition|(
operator|(
name|p
operator|=
name|strdup
argument_list|(
name|ftsent
operator|->
name|fts_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* remove suffix in the copy */
name|kfp
operator|=
name|kfile_find
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|kfp
operator|=
name|kfile_find
argument_list|(
name|ftsent
operator|->
name|fts_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|kfp
operator|&&
operator|!
name|kfp
operator|->
name|seen
condition|)
block|{
name|doobj
argument_list|(
name|ftsent
operator|->
name|fts_path
argument_list|,
name|kfp
operator|->
name|addr
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|kfp
operator|->
name|seen
operator|=
literal|1
expr_stmt|;
comment|/* Optimization: stop fts as soon as seen all loaded modules */
if|if
condition|(
name|kfile_allseen
argument_list|()
condition|)
block|{
name|fts_close
argument_list|(
name|fts
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
name|ftsent
operator|==
name|NULL
operator|&&
name|errno
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"couldn't complete traversing module path"
argument_list|)
expr_stmt|;
name|fts_close
argument_list|(
name|fts
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|sfx
operator|++
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|myname
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:\n"
literal|"%s [-afKksVx] [-M core] [-N system ] [-o outfile] [-X suffix]\n"
literal|"%*s [modules-path [outfile]]\n\n"
literal|"\t-a\tappend to outfile\n"
literal|"\t-f\tfind the module in any subdirectory of modules-path\n"
literal|"\t-K\tuse kld(2) to get the list of modules\n"
literal|"\t-k\ttake input from kldstat(8)\n"
literal|"\t-M\tspecify core name for kvm(3)\n"
literal|"\t-N\tspecify system name for kvm(3)\n"
literal|"\t-o\tuse outfile instead of \".asf\"\n"
literal|"\t-s\tdon't prepend subdir for module path\n"
literal|"\t-V\tuse kvm(3) to get the list of modules\n"
literal|"\t-X\tappend suffix to list of possible module file name suffixes\n"
literal|"\t-x\tclear list of possible module file name suffixes\n"
argument_list|,
name|myname
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|myname
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXPATHS
value|15
end_define

begin_define
define|#
directive|define
name|MAXSUFFIXES
value|15
end_define

begin_comment
comment|/* KLD file names end in this */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsuffixes
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|suffixes
index|[
name|MAXSUFFIXES
operator|+
literal|1
index|]
init|=
block|{
literal|".debug"
block|,
literal|".symbols"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|basename
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|modules_argv
index|[
name|MAXPATHS
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|const
name|char
modifier|*
name|filemode
init|=
literal|"w"
decl_stmt|;
comment|/* mode for outfile */
specifier|const
name|char
modifier|*
name|modules_path
init|=
literal|"modules"
decl_stmt|;
comment|/* path to kernel build directory */
specifier|const
name|char
modifier|*
name|outfile
init|=
literal|".asf"
decl_stmt|;
comment|/* and where to write the output */
specifier|const
name|char
modifier|*
name|corefile
init|=
name|NULL
decl_stmt|;
comment|/* for kvm(3) */
specifier|const
name|char
modifier|*
name|sysfile
init|=
name|NULL
decl_stmt|;
comment|/* for kvm(3) */
specifier|const
name|char
modifier|*
modifier|*
name|sfx
decl_stmt|;
name|struct
name|kfile
modifier|*
name|kfp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
comment|/* output file */
name|int
name|dofind
init|=
literal|0
decl_stmt|;
name|int
name|dokld
init|=
literal|0
decl_stmt|;
name|int
name|dokvm
init|=
literal|0
decl_stmt|;
name|int
name|nosubdir
init|=
literal|0
decl_stmt|;
name|int
name|runprog
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|int
name|sl
init|=
name|strlen
argument_list|(
name|KLDSUFFIX
argument_list|)
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"afKkM:N:o:sVX:x"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|'a'
case|:
name|filemode
operator|=
literal|"a"
expr_stmt|;
comment|/* append to outfile */
break|break;
case|case
literal|'f'
case|:
name|dofind
operator|=
literal|1
expr_stmt|;
comment|/* find .ko (recursively) */
break|break;
case|case
literal|'K'
case|:
name|dokld
operator|=
literal|1
expr_stmt|;
comment|/* use kld(2) interface */
break|break;
case|case
literal|'k'
case|:
name|runprog
operator|=
literal|1
expr_stmt|;
comment|/* get input from kldstat(8) */
break|break;
case|case
literal|'M'
case|:
name|corefile
operator|=
name|optarg
expr_stmt|;
comment|/* core file for kvm(3) */
break|break;
case|case
literal|'N'
case|:
name|sysfile
operator|=
name|optarg
expr_stmt|;
comment|/* system file (kernel) for kvm(3) */
break|break;
case|case
literal|'o'
case|:
name|outfile
operator|=
name|optarg
expr_stmt|;
comment|/* output file name */
break|break;
case|case
literal|'s'
case|:
name|nosubdir
operator|=
literal|1
expr_stmt|;
comment|/* don't descend into subdirs */
break|break;
case|case
literal|'V'
case|:
name|dokvm
operator|=
literal|1
expr_stmt|;
comment|/* use kvm(3) interface */
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|nsuffixes
operator|>=
name|MAXSUFFIXES
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"only %d suffixes can be specified"
argument_list|,
name|MAXSUFFIXES
argument_list|)
expr_stmt|;
name|suffixes
index|[
name|nsuffixes
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
name|suffixes
index|[
name|nsuffixes
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|nsuffixes
operator|=
literal|0
expr_stmt|;
name|suffixes
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|modules_path
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|outfile
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|outfile
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|out
operator|=
name|stdout
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
name|filemode
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't open output file %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dokvm
operator|||
name|corefile
operator|||
name|sysfile
condition|)
block|{
if|if
condition|(
name|dokld
operator|||
name|runprog
condition|)
name|warnx
argument_list|(
literal|"using kvm(3) instead"
argument_list|)
expr_stmt|;
name|asf_kvm
argument_list|(
name|sysfile
argument_list|,
name|corefile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dokld
condition|)
block|{
if|if
condition|(
name|runprog
condition|)
name|warnx
argument_list|(
literal|"using kld(2) instead"
argument_list|)
expr_stmt|;
name|asf_kld
argument_list|()
expr_stmt|;
block|}
else|else
name|asf_prog
argument_list|(
name|runprog
argument_list|)
expr_stmt|;
comment|/* Avoid long operations like module tree traversal when nothing to do */
if|if
condition|(
name|kfile_empty
argument_list|()
condition|)
block|{
name|warnx
argument_list|(
literal|"no kernel modules loaded"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|copy
operator|=
name|strdup
argument_list|(
name|modules_path
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|modules_argv
operator|,
name|p
operator|=
name|copy
init|;
operator|(
operator|*
name|ap
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|";"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|ap
operator|<
operator|&
name|modules_argv
index|[
name|MAXPATHS
index|]
condition|;
name|ap
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|ap
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"only %d module path elements can be specified"
argument_list|,
name|MAXPATHS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dofind
condition|)
name|STAILQ_FOREACH
argument_list|(
argument|kfp
argument_list|,
argument|&kfile_head
argument_list|,
argument|link
argument_list|)
block|{
for|for
control|(
name|ap
operator|=
name|modules_argv
init|;
operator|*
name|ap
condition|;
name|ap
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|nosubdir
condition|)
block|{
comment|/* prepare basename of KLD, w/o suffix */
name|strlcpy
argument_list|(
name|basename
argument_list|,
name|kfp
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|basename
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|sl
operator|&&
name|strcmp
argument_list|(
name|basename
operator|+
name|i
operator|-
name|sl
argument_list|,
name|KLDSUFFIX
argument_list|)
operator|==
literal|0
condition|)
name|i
operator|-=
name|sl
expr_stmt|;
name|basename
index|[
name|i
index|]
operator|=
literal|'/'
expr_stmt|;
name|basename
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
name|sfx
operator|=
name|suffixes
init|;
condition|;
name|sfx
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s%s%s"
argument_list|,
operator|*
name|ap
argument_list|,
name|nosubdir
condition|?
literal|""
else|:
name|basename
argument_list|,
name|kfp
operator|->
name|name
argument_list|,
operator|*
name|sfx
condition|?
operator|*
name|sfx
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
name|doobj
argument_list|(
name|path
argument_list|,
name|kfp
operator|->
name|addr
argument_list|,
name|out
argument_list|)
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
operator|*
name|sfx
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
name|warnx
argument_list|(
literal|"module %s not found in search path"
argument_list|,
name|kfp
operator|->
name|name
argument_list|)
expr_stmt|;
name|found
label|:
empty_stmt|;
block|}
else|else
name|findmodules
argument_list|(
name|modules_argv
argument_list|,
name|suffixes
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

