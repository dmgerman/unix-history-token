begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990, 1991, 1992, 1993  * The Regents of the University of California. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#)$FreeBSD$ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * search.c - supports fast searching through tcpdump files for timestamps  */
end_comment

begin_include
include|#
directive|include
file|"tcpslice.h"
end_include

begin_comment
comment|/* Maximum number of seconds that we can conceive of a dump file spanning. */
end_comment

begin_define
define|#
directive|define
name|MAX_REASONABLE_FILE_SPAN
value|(3600*24*366)
end_define

begin_comment
comment|/* one year */
end_comment

begin_comment
comment|/* Maximum packet length we ever expect to see. */
end_comment

begin_define
define|#
directive|define
name|MAX_REASONABLE_PACKET_LENGTH
value|65535
end_define

begin_comment
comment|/* Size of a packet header in bytes; easier than typing the sizeof() all  * the time ...  */
end_comment

begin_define
define|#
directive|define
name|PACKET_HDR_LEN
value|(sizeof( struct pcap_pkthdr ))
end_define

begin_decl_stmt
specifier|extern
name|int
name|snaplen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The maximum size of a packet, including its header. */
end_comment

begin_define
define|#
directive|define
name|MAX_PACKET_SIZE
value|(PACKET_HDR_LEN + snaplen)
end_define

begin_comment
comment|/* Number of contiguous bytes from a dumpfile in which there's guaranteed  * to be enough information to find a "definite" header if one exists  * therein.  This takes 3 full packets - the first to be just misaligned  * (one byte short of a full packet), missing its timestamp; the second  * to have the legitimate timestamp; and the third to provide confirmation  * that the second is legit, making it a "definite" header.  We could  * scrimp a bit here since not the entire third packet is required, but  * it doesn't seem worth it  */
end_comment

begin_define
define|#
directive|define
name|MAX_BYTES_FOR_DEFINITE_HEADER
value|(3 * MAX_PACKET_SIZE)
end_define

begin_comment
comment|/* Maximum number of seconds that might reasonably separate two headers. */
end_comment

begin_define
define|#
directive|define
name|MAX_REASONABLE_HDR_SEPARATION
value|(3600 * 24 * 7)
end_define

begin_comment
comment|/* one week */
end_comment

begin_comment
comment|/* When searching a file for a packet, if we think we're within this many  * bytes of the packet we just search linearly.  Since linear searches are  * probably much faster than random ones (random ones require searching for  * the beginning of the packet, which may be unaligned in memory), we make  * this value pretty hefty.  */
end_comment

begin_define
define|#
directive|define
name|STRAIGHT_SCAN_THRESHOLD
value|(100 * MAX_PACKET_SIZE)
end_define

begin_comment
comment|/* Given a header and an acceptable first and last time stamp, returns non-zero  * if the header looks reasonable and zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|reasonable_header
parameter_list|(
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
parameter_list|,
name|long
name|first_time
parameter_list|,
name|long
name|last_time
parameter_list|)
block|{
if|if
condition|(
name|last_time
operator|==
literal|0
condition|)
name|last_time
operator|=
name|first_time
operator|+
name|MAX_REASONABLE_FILE_SPAN
expr_stmt|;
return|return
name|hdr
operator|->
name|ts
operator|.
name|tv_sec
operator|>=
name|first_time
operator|&&
name|hdr
operator|->
name|ts
operator|.
name|tv_sec
operator|<=
name|last_time
operator|&&
name|hdr
operator|->
name|len
operator|>
literal|0
operator|&&
name|hdr
operator|->
name|len
operator|<=
name|MAX_REASONABLE_PACKET_LENGTH
operator|&&
name|hdr
operator|->
name|caplen
operator|>
literal|0
operator|&&
name|hdr
operator|->
name|caplen
operator|<=
name|MAX_REASONABLE_PACKET_LENGTH
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SWAPLONG
parameter_list|(
name|y
parameter_list|)
define|\
value|((((y)&0xff)<<24) | (((y)&0xff00)<<8) | (((y)&0xff0000)>>8) | (((y)>>24)&0xff))
end_define

begin_define
define|#
directive|define
name|SWAPSHORT
parameter_list|(
name|y
parameter_list|)
define|\
value|( (((y)&0xff)<<8) | (((y)&0xff00)>>8) )
end_define

begin_comment
comment|/* Given a buffer, extracts a (properly aligned) packet header from it. */
end_comment

begin_function
specifier|static
name|void
name|extract_header
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|hdr
parameter_list|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcap_pkthdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcap_is_swapped
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|hdr
operator|->
name|ts
operator|.
name|tv_sec
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|->
name|ts
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|->
name|ts
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|->
name|len
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|SWAPLONG
argument_list|(
name|hdr
operator|->
name|caplen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * From bpf/libpcap/savefile.c: 	 * 	 * We interchanged the caplen and len fields at version 2.3, 	 * in order to match the bpf header layout.  But unfortunately 	 * some files were written with version 2.3 in their headers 	 * but without the interchanged fields. 	 */
if|if
condition|(
name|pcap_minor_version
argument_list|(
name|p
argument_list|)
operator|<
literal|3
operator|||
operator|(
name|pcap_minor_version
argument_list|(
name|p
argument_list|)
operator|==
literal|3
operator|&&
name|hdr
operator|->
name|caplen
operator|>
name|hdr
operator|->
name|len
operator|)
condition|)
block|{
name|int
name|t
init|=
name|hdr
operator|->
name|caplen
decl_stmt|;
name|hdr
operator|->
name|caplen
operator|=
name|hdr
operator|->
name|len
expr_stmt|;
name|hdr
operator|->
name|len
operator|=
name|t
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Search a buffer to locate the first header within it.  Return values  * are HEADER_NONE, HEADER_CLASH, HEADER_PERHAPS, and HEADER_DEFINITELY.  * The first indicates that no evidence of a header was found; the second  * that two or more possible headers were found, neither more convincing  * than the other(s); the third that exactly one "possible" header was  * found; and the fourth that exactly one "definite" header was found.  *  * Headers are detected by looking for positions in the buffer which have  * reasonable timestamps and lengths.  If there is enough room in the buffer  * for another header to follow a candidate header, a check is made for  * that following header.  If it is present then the header is *definite*  * (unless another "perhaps" or "definite" header is found); if not, then  * the header is discarded.  If there is not enough room in the buffer for  * another header then the candidate is *perhaps* (unless another header  * is subsequently found).  A "tie" between a "definite" header and a  * "perhaps" header is resolved in favor of the definite header.  Any  * other tie leads to HEADER_CLASH.  *  * The buffer position of the header is returned in hdrpos_addr and  * for convenience the corresponding header in return_hdr.  *  * first_time is the earliest possible acceptable timestamp in the  * header.  last_time, if non-zero, is the last such timestamp.  If  * zero, then up to MAX_REASONABLE_FILE_SPAN seconds after first_time  * is acceptable.  */
end_comment

begin_define
define|#
directive|define
name|HEADER_NONE
value|0
end_define

begin_define
define|#
directive|define
name|HEADER_CLASH
value|1
end_define

begin_define
define|#
directive|define
name|HEADER_PERHAPS
value|2
end_define

begin_define
define|#
directive|define
name|HEADER_DEFINITELY
value|3
end_define

begin_function
specifier|static
name|int
name|find_header
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|buf_len
parameter_list|,
name|long
name|first_time
parameter_list|,
name|long
name|last_time
parameter_list|,
name|u_char
modifier|*
modifier|*
name|hdrpos_addr
parameter_list|,
name|struct
name|pcap_pkthdr
modifier|*
name|return_hdr
parameter_list|)
block|{
name|u_char
modifier|*
name|bufptr
decl_stmt|,
modifier|*
name|bufend
decl_stmt|,
modifier|*
name|last_pos_to_try
decl_stmt|;
name|struct
name|pcap_pkthdr
name|hdr
decl_stmt|,
name|hdr2
decl_stmt|;
name|int
name|status
init|=
name|HEADER_NONE
decl_stmt|;
name|int
name|saw_PERHAPS_clash
init|=
literal|0
decl_stmt|;
comment|/* Initially, try each buffer position to see whether it looks like 	 * a valid packet header.  We may later restrict the positions we look 	 * at to avoid seeing a sequence of legitimate headers as conflicting 	 * with one another. 	 */
name|bufend
operator|=
name|buf
operator|+
name|buf_len
expr_stmt|;
name|last_pos_to_try
operator|=
name|bufend
operator|-
name|PACKET_HDR_LEN
expr_stmt|;
for|for
control|(
name|bufptr
operator|=
name|buf
init|;
name|bufptr
operator|<
name|last_pos_to_try
condition|;
operator|++
name|bufptr
control|)
block|{
name|extract_header
argument_list|(
name|p
argument_list|,
name|bufptr
argument_list|,
operator|&
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reasonable_header
argument_list|(
operator|&
name|hdr
argument_list|,
name|first_time
argument_list|,
name|last_time
argument_list|)
condition|)
block|{
name|u_char
modifier|*
name|next_header
init|=
name|bufptr
operator|+
name|PACKET_HDR_LEN
operator|+
name|hdr
operator|.
name|caplen
decl_stmt|;
if|if
condition|(
name|next_header
operator|+
name|PACKET_HDR_LEN
operator|<
name|bufend
condition|)
block|{
comment|/* check for another good header */
name|extract_header
argument_list|(
name|p
argument_list|,
name|next_header
argument_list|,
operator|&
name|hdr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|reasonable_header
argument_list|(
operator|&
name|hdr2
argument_list|,
name|hdr
operator|.
name|ts
operator|.
name|tv_sec
argument_list|,
name|hdr
operator|.
name|ts
operator|.
name|tv_sec
operator|+
name|MAX_REASONABLE_HDR_SEPARATION
argument_list|)
condition|)
block|{
comment|/* a confirmed header */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|HEADER_NONE
case|:
case|case
name|HEADER_PERHAPS
case|:
name|status
operator|=
name|HEADER_DEFINITELY
expr_stmt|;
operator|*
name|hdrpos_addr
operator|=
name|bufptr
expr_stmt|;
operator|*
name|return_hdr
operator|=
name|hdr
expr_stmt|;
comment|/* Make sure we don't demote this "definite" 				 * to a "clash" if we stumble across its 				 * successor. 				 */
name|last_pos_to_try
operator|=
name|next_header
operator|-
name|PACKET_HDR_LEN
expr_stmt|;
break|break;
case|case
name|HEADER_DEFINITELY
case|:
return|return
name|HEADER_CLASH
return|;
default|default:
name|error
argument_list|(
literal|"bad status in find_header()"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ... else the header is bogus - we've verified that it's 		     * not followed by a reasonable header. 		     */
block|}
else|else
block|{
comment|/* can't check for another good header */
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|HEADER_NONE
case|:
name|status
operator|=
name|HEADER_PERHAPS
expr_stmt|;
operator|*
name|hdrpos_addr
operator|=
name|bufptr
expr_stmt|;
operator|*
name|return_hdr
operator|=
name|hdr
expr_stmt|;
break|break;
case|case
name|HEADER_PERHAPS
case|:
comment|/* We don't immediately turn this into a 			     * clash because perhaps we'll later see a 			     * "definite" which will save us ... 			     */
name|saw_PERHAPS_clash
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|HEADER_DEFINITELY
case|:
comment|/* Keep the definite in preference to this one. */
break|break;
default|default:
name|error
argument_list|(
literal|"bad status in find_header()"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|status
operator|==
name|HEADER_PERHAPS
operator|&&
name|saw_PERHAPS_clash
condition|)
name|status
operator|=
name|HEADER_CLASH
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Positions the sf_readfile stream such that the next sf_read() will  * read the final full packet in the file.  Returns non-zero if  * successful, zero if unsuccessful.  If successful, returns the  * timestamp of the last packet in last_timestamp.  *  * Note that this routine is a special case of sf_find_packet().  In  * order to use sf_find_packet(), one first must use this routine in  * order to give sf_find_packet() an upper bound on the timestamps  * present in the dump file.  */
end_comment

begin_function
name|int
name|sf_find_end
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|timeval
modifier|*
name|first_timestamp
parameter_list|,
name|struct
name|timeval
modifier|*
name|last_timestamp
parameter_list|)
block|{
name|long
name|first_time
init|=
name|first_timestamp
operator|->
name|tv_sec
decl_stmt|;
name|u_int
name|num_bytes
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bufpos
decl_stmt|,
modifier|*
name|bufend
decl_stmt|;
name|u_char
modifier|*
name|hdrpos
decl_stmt|;
name|struct
name|pcap_pkthdr
name|hdr
decl_stmt|,
name|successor_hdr
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* Allow enough room for at least two full (untruncated) packets, 	 * perhaps followed by a truncated packet, so we have a shot at 	 * finding a "definite" header and following its chain to the 	 * end of the file. 	 */
name|num_bytes
operator|=
name|MAX_BYTES_FOR_DEFINITE_HEADER
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|pcap_file
argument_list|(
name|p
argument_list|)
argument_list|,
operator|(
name|long
operator|)
operator|-
name|num_bytes
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
name|num_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
literal|0
return|;
name|status
operator|=
literal|0
expr_stmt|;
name|bufpos
operator|=
name|buf
expr_stmt|;
name|bufend
operator|=
name|buf
operator|+
name|num_bytes
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bufpos
argument_list|,
name|num_bytes
argument_list|,
literal|1
argument_list|,
name|pcap_file
argument_list|(
name|p
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|find_header
argument_list|(
name|p
argument_list|,
name|bufpos
argument_list|,
name|num_bytes
argument_list|,
name|first_time
argument_list|,
literal|0L
argument_list|,
operator|&
name|hdrpos
argument_list|,
operator|&
name|hdr
argument_list|)
operator|!=
name|HEADER_DEFINITELY
condition|)
goto|goto
name|done
goto|;
comment|/* Okay, we have a definite header in our hands.  Follow its 	 * chain till we find the last valid packet in the file ... 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* move to the next header position */
name|bufpos
operator|=
name|hdrpos
operator|+
name|PACKET_HDR_LEN
operator|+
name|hdr
operator|.
name|caplen
expr_stmt|;
comment|/* bufpos now points to a candidate packet, which if valid 		 * should replace the current packet pointed to by hdrpos as 		 * the last valid packet ... 		 */
if|if
condition|(
name|bufpos
operator|>=
name|bufend
operator|-
name|PACKET_HDR_LEN
condition|)
comment|/* not enough room for another header */
break|break;
name|extract_header
argument_list|(
name|p
argument_list|,
name|bufpos
argument_list|,
operator|&
name|successor_hdr
argument_list|)
expr_stmt|;
name|first_time
operator|=
name|hdr
operator|.
name|ts
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|!
name|reasonable_header
argument_list|(
operator|&
name|successor_hdr
argument_list|,
name|first_time
argument_list|,
literal|0L
argument_list|)
condition|)
comment|/* this bodes ill - it means bufpos is perhaps a 			 * bogus packet header after all ... 			 */
break|break;
comment|/* Note that the following test is for whether the next 		 * packet starts at a position> bufend, *not* for a 		 * position>= bufend.  If this is the last packet in the 		 * file and there isn't a subsequent partial packet, then 		 * we expect the first buffer position beyond this packet 		 * to be just beyond the end of the buffer, i.e., at bufend 		 * itself. 		 */
if|if
condition|(
name|bufpos
operator|+
name|PACKET_HDR_LEN
operator|+
name|successor_hdr
operator|.
name|caplen
operator|>
name|bufend
condition|)
comment|/* the packet is truncated */
break|break;
comment|/* Accept this packet as fully legit. */
name|hdrpos
operator|=
name|bufpos
expr_stmt|;
name|hdr
operator|=
name|successor_hdr
expr_stmt|;
block|}
comment|/* Success!  Last valid packet is at hdrpos. */
operator|*
name|last_timestamp
operator|=
name|hdr
operator|.
name|ts
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
comment|/* Seek so that the next read will start at last valid packet. */
if|if
condition|(
name|fseek
argument_list|(
name|pcap_file
argument_list|(
name|p
argument_list|)
argument_list|,
operator|(
name|long
operator|)
operator|-
operator|(
name|bufend
operator|-
name|hdrpos
operator|)
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"final fseek() failed in sf_find_end()"
argument_list|)
expr_stmt|;
name|done
label|:
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Takes two timeval's and returns the difference, tv2 - tv1, as a double. */
end_comment

begin_function
specifier|static
name|double
name|timeval_diff
parameter_list|(
name|struct
name|timeval
modifier|*
name|tv1
parameter_list|,
name|struct
name|timeval
modifier|*
name|tv2
parameter_list|)
block|{
name|double
name|result
init|=
operator|(
name|tv2
operator|->
name|tv_sec
operator|-
name|tv1
operator|->
name|tv_sec
operator|)
decl_stmt|;
name|result
operator|+=
operator|(
name|tv2
operator|->
name|tv_usec
operator|-
name|tv1
operator|->
name|tv_usec
operator|)
operator|/
literal|1000000.0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Returns true if timestamp t1 is chronologically less than timestamp t2. */
end_comment

begin_function
name|int
name|sf_timestamp_less_than
parameter_list|(
name|struct
name|timeval
modifier|*
name|t1
parameter_list|,
name|struct
name|timeval
modifier|*
name|t2
parameter_list|)
block|{
return|return
name|t1
operator|->
name|tv_sec
operator|<
name|t2
operator|->
name|tv_sec
operator|||
operator|(
name|t1
operator|->
name|tv_sec
operator|==
name|t2
operator|->
name|tv_sec
operator|&&
name|t1
operator|->
name|tv_usec
operator|<
name|t2
operator|->
name|tv_usec
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given two timestamps on either side of desired_time and their positions,  * returns the interpolated position of the desired_time packet.  Returns a  * negative value if the desired_time is outside the given range.  */
end_comment

begin_function
specifier|static
name|long
name|interpolated_position
parameter_list|(
name|struct
name|timeval
modifier|*
name|min_time
parameter_list|,
name|long
name|min_pos
parameter_list|,
name|struct
name|timeval
modifier|*
name|max_time
parameter_list|,
name|long
name|max_pos
parameter_list|,
name|struct
name|timeval
modifier|*
name|desired_time
parameter_list|)
block|{
name|double
name|full_span
init|=
name|timeval_diff
argument_list|(
name|max_time
argument_list|,
name|min_time
argument_list|)
decl_stmt|;
name|double
name|desired_span
init|=
name|timeval_diff
argument_list|(
name|desired_time
argument_list|,
name|min_time
argument_list|)
decl_stmt|;
name|long
name|full_span_pos
init|=
name|max_pos
operator|-
name|min_pos
decl_stmt|;
name|double
name|fractional_offset
init|=
name|desired_span
operator|/
name|full_span
decl_stmt|;
if|if
condition|(
name|fractional_offset
operator|<
literal|0.0
operator|||
name|fractional_offset
operator|>
literal|1.0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|min_pos
operator|+
call|(
name|long
call|)
argument_list|(
name|fractional_offset
operator|*
operator|(
name|double
operator|)
name|full_span_pos
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reads packets linearly until one with a time>= the given desired time  * is found; positions the dump file so that the next read will start  * at the given packet.  Returns non-zero on success, 0 if an EOF was  * first encountered.  */
end_comment

begin_function
specifier|static
name|int
name|read_up_to
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|timeval
modifier|*
name|desired_time
parameter_list|)
block|{
name|struct
name|pcap_pkthdr
name|hdr
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|buf
decl_stmt|;
name|long
name|pos
decl_stmt|;
name|int
name|status
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|timeval
modifier|*
name|timestamp
decl_stmt|;
name|pos
operator|=
name|ftell
argument_list|(
name|pcap_file
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|pcap_next
argument_list|(
name|p
argument_list|,
operator|&
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|pcap_file
argument_list|(
name|p
argument_list|)
argument_list|)
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
name|clearerr
argument_list|(
name|pcap_file
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
argument_list|(
literal|"bad status in read_up_to()"
argument_list|)
expr_stmt|;
block|}
name|timestamp
operator|=
operator|&
name|hdr
operator|.
name|ts
expr_stmt|;
if|if
condition|(
operator|!
name|sf_timestamp_less_than
argument_list|(
name|timestamp
argument_list|,
name|desired_time
argument_list|)
condition|)
block|{
name|status
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fseek
argument_list|(
name|pcap_file
argument_list|(
name|p
argument_list|)
argument_list|,
name|pos
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"fseek() failed in read_up_to()"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Positions the sf_readfile stream so that the next sf_read() will  * return the first packet with a time greater than or equal to  * desired_time.  desired_time must be greater than min_time and less  * than max_time, which should correspond to actual packets in the  * file.  min_pos is the file position (byte offset) corresponding to  * the min_time packet and max_pos is the same for the max_time packet.  *  * Returns non-zero on success, 0 if the given position is beyond max_pos.  *  * NOTE: when calling this routine, the sf_readfile stream *must* be  * already aligned so that the next call to sf_next_packet() will yield  * a valid packet.  */
end_comment

begin_function
name|int
name|sf_find_packet
parameter_list|(
name|pcap_t
modifier|*
name|p
parameter_list|,
name|struct
name|timeval
modifier|*
name|min_time
parameter_list|,
name|long
name|min_pos
parameter_list|,
name|struct
name|timeval
modifier|*
name|max_time
parameter_list|,
name|long
name|max_pos
parameter_list|,
name|struct
name|timeval
modifier|*
name|desired_time
parameter_list|)
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
name|struct
name|timeval
name|min_time_copy
decl_stmt|,
name|max_time_copy
decl_stmt|;
name|u_int
name|num_bytes
init|=
name|MAX_BYTES_FOR_DEFINITE_HEADER
decl_stmt|;
name|int
name|num_bytes_read
decl_stmt|;
name|long
name|desired_pos
decl_stmt|,
name|present_pos
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|hdrpos
decl_stmt|;
name|struct
name|pcap_pkthdr
name|hdr
decl_stmt|;
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|num_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|error
argument_list|(
literal|"malloc() failured in sf_find_packet()"
argument_list|)
expr_stmt|;
name|min_time_copy
operator|=
operator|*
name|min_time
expr_stmt|;
name|min_time
operator|=
operator|&
name|min_time_copy
expr_stmt|;
name|max_time_copy
operator|=
operator|*
name|max_time
expr_stmt|;
name|max_time
operator|=
operator|&
name|max_time_copy
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
comment|/* loop until positioned correctly */
block|{
name|desired_pos
operator|=
name|interpolated_position
argument_list|(
name|min_time
argument_list|,
name|min_pos
argument_list|,
name|max_time
argument_list|,
name|max_pos
argument_list|,
name|desired_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|desired_pos
operator|<
literal|0
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|present_pos
operator|=
name|ftell
argument_list|(
name|pcap_file
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|present_pos
operator|<=
name|desired_pos
operator|&&
name|desired_pos
operator|-
name|present_pos
operator|<
name|STRAIGHT_SCAN_THRESHOLD
condition|)
block|{
comment|/* we're close enough to just blindly read ahead */
name|status
operator|=
name|read_up_to
argument_list|(
name|p
argument_list|,
name|desired_time
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Undershoot the target a little bit - it's much easier to 		 * then scan straight forward than to try to read backwards ... 		 */
name|desired_pos
operator|-=
name|STRAIGHT_SCAN_THRESHOLD
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|desired_pos
operator|<
name|min_pos
condition|)
name|desired_pos
operator|=
name|min_pos
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|pcap_file
argument_list|(
name|p
argument_list|)
argument_list|,
name|desired_pos
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"fseek() failed in sf_find_packet()"
argument_list|)
expr_stmt|;
name|num_bytes_read
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|1
argument_list|,
name|num_bytes
argument_list|,
name|pcap_file
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_bytes_read
operator|==
literal|0
condition|)
comment|/* This shouldn't ever happen because we try to 			 * undershoot, unless the dump file has only a 			 * couple packets in it ... 			 */
name|error
argument_list|(
literal|"fread() failed in sf_find_packet()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_header
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|num_bytes
argument_list|,
name|min_time
operator|->
name|tv_sec
argument_list|,
name|max_time
operator|->
name|tv_sec
argument_list|,
operator|&
name|hdrpos
argument_list|,
operator|&
name|hdr
argument_list|)
operator|!=
name|HEADER_DEFINITELY
condition|)
name|error
argument_list|(
literal|"can't find header at position %ld in dump file"
argument_list|,
name|desired_pos
argument_list|)
expr_stmt|;
comment|/* Correct desired_pos to reflect beginning of packet. */
name|desired_pos
operator|+=
operator|(
name|hdrpos
operator|-
name|buf
operator|)
expr_stmt|;
comment|/* Seek to the beginning of the header. */
if|if
condition|(
name|fseek
argument_list|(
name|pcap_file
argument_list|(
name|p
argument_list|)
argument_list|,
name|desired_pos
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"fseek() failed in sf_find_packet()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf_timestamp_less_than
argument_list|(
operator|&
name|hdr
operator|.
name|ts
argument_list|,
name|desired_time
argument_list|)
condition|)
block|{
comment|/* too early in the file */
operator|*
name|min_time
operator|=
name|hdr
operator|.
name|ts
expr_stmt|;
name|min_pos
operator|=
name|desired_pos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sf_timestamp_less_than
argument_list|(
name|desired_time
argument_list|,
operator|&
name|hdr
operator|.
name|ts
argument_list|)
condition|)
block|{
comment|/* too late in the file */
operator|*
name|max_time
operator|=
name|hdr
operator|.
name|ts
expr_stmt|;
name|max_pos
operator|=
name|desired_pos
expr_stmt|;
block|}
else|else
comment|/* got it! */
break|break;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

end_unit

