begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990, 1991, 1993, 1994  *    John Robert LoVerso.  All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by John Robert LoVerso.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * This implementation has been influenced by the CMU SNMP release,  * by Steve Waldbusser.  However, this shares no code with that system.  * Additional ASN.1 insight gained from Marshall T. Rose's _The_Open_Book_.  * Earlier forms of this implementation were derived and/or inspired by an  * awk script originally written by C. Philip Wood of LANL (but later  * heavily modified by John Robert LoVerso).  The copyright notice for  * that work is preserved below, even though it may not rightly apply  * to this file.  *  * This started out as a very simple program, but the incremental decoding  * (into the BE structure) complicated things.  *  #			Los Alamos National Laboratory  #  #	Copyright, 1990.  The Regents of the University of California.  #	This software was produced under a U.S. Government contract  #	(W-7405-ENG-36) by Los Alamos National Laboratory, which is  #	operated by the	University of California for the U.S. Department  #	of Energy.  The U.S. Government is licensed to use, reproduce,  #	and distribute this software.  Permission is granted to the  #	public to copy and use this software without charge, provided  #	that this Notice and any statement of authorship are reproduced  #	on all copies.  Neither the Government nor the University makes  #	any warranty, express or implied, or assumes any liability or  #	responsibility for the use of this software.  #	@(#)snmp.awk.x	1.1 (LANL) 1/15/90  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $Id: print-snmp.c,v 3.10 91/01/17 01:18:13 loverso Exp Locker: loverso $ (jlv)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"interface.h"
end_include

begin_include
include|#
directive|include
file|"addrtoname.h"
end_include

begin_comment
comment|/*  * Universal ASN.1 types  * (we only care about the tag values for those allowed in the Internet SMI)  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Universal
index|[]
init|=
block|{
literal|"U-0"
block|,
literal|"Boolean"
block|,
literal|"Integer"
block|,
define|#
directive|define
name|INTEGER
value|2
literal|"Bitstring"
block|,
literal|"String"
block|,
define|#
directive|define
name|STRING
value|4
literal|"Null"
block|,
define|#
directive|define
name|ASN_NULL
value|5
literal|"ObjID"
block|,
define|#
directive|define
name|OBJECTID
value|6
literal|"ObjectDes"
block|,
literal|"U-8"
block|,
literal|"U-9"
block|,
literal|"U-10"
block|,
literal|"U-11"
block|,
comment|/* 8-11 */
literal|"U-12"
block|,
literal|"U-13"
block|,
literal|"U-14"
block|,
literal|"U-15"
block|,
comment|/* 12-15 */
literal|"Sequence"
block|,
define|#
directive|define
name|SEQUENCE
value|16
literal|"Set"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Application-wide ASN.1 types from the Internet SMI and their tags  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Application
index|[]
init|=
block|{
literal|"IpAddress"
block|,
define|#
directive|define
name|IPADDR
value|0
literal|"Counter"
block|,
define|#
directive|define
name|COUNTER
value|1
literal|"Gauge"
block|,
define|#
directive|define
name|GAUGE
value|2
literal|"TimeTicks"
block|,
define|#
directive|define
name|TIMETICKS
value|3
literal|"Opaque"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Context-specific ASN.1 types for the SNMP PDUs and their tags  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Context
index|[]
init|=
block|{
literal|"GetRequest"
block|,
define|#
directive|define
name|GETREQ
value|0
literal|"GetNextRequest"
block|,
define|#
directive|define
name|GETNEXTREQ
value|1
literal|"GetResponse"
block|,
define|#
directive|define
name|GETRESP
value|2
literal|"SetRequest"
block|,
define|#
directive|define
name|SETREQ
value|3
literal|"Trap"
define|#
directive|define
name|TRAP
value|4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Private ASN.1 types  * The Internet SMI does not specify any  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Private
index|[]
init|=
block|{
literal|"P-0"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * error-status values for any SNMP PDU  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ErrorStatus
index|[]
init|=
block|{
literal|"noError"
block|,
literal|"tooBig"
block|,
literal|"noSuchName"
block|,
literal|"badValue"
block|,
literal|"readOnly"
block|,
literal|"genErr"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DECODE_ErrorStatus
parameter_list|(
name|e
parameter_list|)
define|\
value|( e>= 0&& e<= sizeof(ErrorStatus)/sizeof(ErrorStatus[0]) \ 	? ErrorStatus[e] : (sprintf(errbuf, "err=%d", e), errbuf))
end_define

begin_comment
comment|/*  * generic-trap values in the SNMP Trap-PDU  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|GenericTrap
index|[]
init|=
block|{
literal|"coldStart"
block|,
literal|"warmStart"
block|,
literal|"linkDown"
block|,
literal|"linkUp"
block|,
literal|"authenticationFailure"
block|,
literal|"egpNeighborLoss"
block|,
literal|"enterpriseSpecific"
define|#
directive|define
name|GT_ENTERPRISE
value|7
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DECODE_GenericTrap
parameter_list|(
name|t
parameter_list|)
define|\
value|( t>= 0&& t<= sizeof(GenericTrap)/sizeof(GenericTrap[0]) \ 	? GenericTrap[t] : (sprintf(buf, "gt=%d", t), buf))
end_define

begin_comment
comment|/*  * ASN.1 type class table  * Ties together the preceding Universal, Application, Context, and Private  * type definitions.  */
end_comment

begin_define
define|#
directive|define
name|defineCLASS
parameter_list|(
name|x
parameter_list|)
value|{ "x", x, sizeof(x)/sizeof(x[0]) }
end_define

begin_comment
comment|/* not ANSI-C */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|Id
decl_stmt|;
name|int
name|numIDs
decl_stmt|;
block|}
name|Class
index|[]
init|=
block|{
name|defineCLASS
argument_list|(
name|Universal
argument_list|)
block|,
define|#
directive|define
name|UNIVERSAL
value|0
name|defineCLASS
argument_list|(
name|Application
argument_list|)
block|,
define|#
directive|define
name|APPLICATION
value|1
name|defineCLASS
argument_list|(
name|Context
argument_list|)
block|,
define|#
directive|define
name|CONTEXT
value|2
name|defineCLASS
argument_list|(
name|Private
argument_list|)
block|,
define|#
directive|define
name|PRIVATE
value|3
block|}
struct|;
end_struct

begin_comment
comment|/*  * defined forms for ASN.1 types  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Form
index|[]
init|=
block|{
literal|"Primitive"
block|,
define|#
directive|define
name|PRIMITIVE
value|0
literal|"Constructed"
block|,
define|#
directive|define
name|CONSTRUCTED
value|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A structure for the OID tree for the compiled-in MIB.  * This is stored as a general-order tree.  */
end_comment

begin_struct
struct|struct
name|obj
block|{
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* name of object */
name|u_char
name|oid
decl_stmt|;
comment|/* sub-id following parent */
name|u_char
name|type
decl_stmt|;
comment|/* object type (unused) */
name|struct
name|obj
modifier|*
name|child
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* child and next sibling pointers */
block|}
modifier|*
name|objp
init|=
name|NULL
struct|;
end_struct

begin_comment
comment|/*  * Include the compiled in SNMP MIB.  "mib.h" is produced by feeding  * RFC-1156 format files into "makemib".  "mib.h" MUST define at least  * a value for `mibroot'.  *  * In particular, this is gross, as this is including initialized structures,  * and by right shouldn't be an "include" file.  */
end_comment

begin_include
include|#
directive|include
file|"mib.h"
end_include

begin_comment
comment|/*  * This defines a list of OIDs which will be abbreviated on output.  * Currently, this includes the prefixes for the Internet MIB, the  * private enterprises tree, and the experimental tree.  */
end_comment

begin_struct
struct|struct
name|obj_abrev
block|{
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* prefix for this abrev */
name|struct
name|obj
modifier|*
name|node
decl_stmt|;
comment|/* pointer into object table */
name|char
modifier|*
name|oid
decl_stmt|;
comment|/* ASN.1 encoded OID */
block|}
name|obj_abrev_list
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|NO_ABREV_MIB
comment|/* .iso.org.dod.internet.mgmt.mib */
block|{
literal|""
block|,
operator|&
name|_mib_obj
block|,
literal|"\53\6\1\2\1"
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ABREV_ENTER
comment|/* .iso.org.dod.internet.private.enterprises */
block|{
literal|"E:"
block|,
operator|&
name|_enterprises_obj
block|,
literal|"\53\6\1\4\1"
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ABREV_EXPERI
comment|/* .iso.org.dod.internet.experimental */
block|{
literal|"X:"
block|,
operator|&
name|_experimental_obj
block|,
literal|"\53\6\1\3"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * This is used in the OID print routine to walk down the object tree  * rooted at `mibroot'.  */
end_comment

begin_define
define|#
directive|define
name|OBJ_PRINT
parameter_list|(
name|o
parameter_list|,
name|suppressdot
parameter_list|)
define|\
value|{ \ 	if (objp) { \ 		do { \ 			if ((o) == objp->oid) \ 				break; \ 		} while ((objp = objp->next) != NULL); \ 	} \ 	if (objp) { \ 		printf(suppressdot?"%s":".%s", objp->desc); \ 		objp = objp->child; \ 	} else \ 		printf(suppressdot?"%u":".%u", (o)); \ }
end_define

begin_comment
comment|/*  * This is the definition for the Any-Data-Type storage used purely for  * temporary internal representation while decoding an ASN.1 data stream.  */
end_comment

begin_struct
struct|struct
name|be
block|{
name|u_long
name|asnlen
decl_stmt|;
union|union
block|{
name|caddr_t
name|raw
decl_stmt|;
name|long
name|integer
decl_stmt|;
name|u_long
name|uns
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|str
decl_stmt|;
block|}
name|data
union|;
name|u_char
name|form
decl_stmt|,
name|class
decl_stmt|,
name|id
decl_stmt|;
comment|/* tag info */
name|u_char
name|type
decl_stmt|;
define|#
directive|define
name|BE_ANY
value|255
define|#
directive|define
name|BE_NONE
value|0
define|#
directive|define
name|BE_NULL
value|1
define|#
directive|define
name|BE_OCTET
value|2
define|#
directive|define
name|BE_OID
value|3
define|#
directive|define
name|BE_INT
value|4
define|#
directive|define
name|BE_UNS
value|5
define|#
directive|define
name|BE_STR
value|6
define|#
directive|define
name|BE_SEQ
value|7
define|#
directive|define
name|BE_INETADDR
value|8
define|#
directive|define
name|BE_PDU
value|9
block|}
struct|;
end_struct

begin_comment
comment|/*  * Defaults for SNMP PDU components  */
end_comment

begin_define
define|#
directive|define
name|DEF_COMMUNITY
value|"public"
end_define

begin_define
define|#
directive|define
name|DEF_VERSION
value|0
end_define

begin_comment
comment|/*  * constants for ASN.1 decoding  */
end_comment

begin_define
define|#
directive|define
name|OIDMUX
value|40
end_define

begin_define
define|#
directive|define
name|ASNLEN_INETADDR
value|4
end_define

begin_define
define|#
directive|define
name|ASN_SHIFT7
value|7
end_define

begin_define
define|#
directive|define
name|ASN_SHIFT8
value|8
end_define

begin_define
define|#
directive|define
name|ASN_BIT8
value|0x80
end_define

begin_define
define|#
directive|define
name|ASN_LONGLEN
value|0x80
end_define

begin_define
define|#
directive|define
name|ASN_ID_BITS
value|0x1f
end_define

begin_define
define|#
directive|define
name|ASN_FORM_BITS
value|0x20
end_define

begin_define
define|#
directive|define
name|ASN_FORM_SHIFT
value|5
end_define

begin_define
define|#
directive|define
name|ASN_CLASS_BITS
value|0xc0
end_define

begin_define
define|#
directive|define
name|ASN_CLASS_SHIFT
value|6
end_define

begin_define
define|#
directive|define
name|ASN_ID_EXT
value|0x1f
end_define

begin_comment
comment|/* extension ID in tag field */
end_comment

begin_comment
comment|/*  * truncated==1 means the packet was complete, but we don't have all of  * it to decode.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|truncated
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ifNotTruncated
value|if (truncated) fputs("[|snmp]", stdout); else
end_define

begin_comment
comment|/*  * This decodes the next ASN.1 object in the stream pointed to by "p"  * (and of real-length "len") and stores the intermediate data in the  * provided BE object.  *  * This returns -l if it fails (i.e., the ASN.1 stream is not valid).  * O/w, this returns the number of bytes parsed from "p".  */
end_comment

begin_function
specifier|static
name|int
name|asn1_parse
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|be
modifier|*
name|elem
parameter_list|)
block|{
name|u_char
name|form
decl_stmt|,
name|class
decl_stmt|,
name|id
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hdr
decl_stmt|;
name|elem
operator|->
name|asnlen
operator|=
literal|0
expr_stmt|;
name|elem
operator|->
name|type
operator|=
name|BE_ANY
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
name|ifNotTruncated
name|puts
argument_list|(
literal|"[nothing to parse], stdout"
argument_list|)
decl_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* 	 * it would be nice to use a bit field, but you can't depend on them. 	 *  +---+---+---+---+---+---+---+---+ 	 *  + class |frm|        id         | 	 *  +---+---+---+---+---+---+---+---+ 	 *    7   6   5   4   3   2   1   0 	 */
name|id
operator|=
operator|*
name|p
operator|&
name|ASN_ID_BITS
expr_stmt|;
comment|/* lower 5 bits, range 00-1f */
ifdef|#
directive|ifdef
name|notdef
name|form
operator|=
operator|(
operator|*
name|p
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
expr_stmt|;
comment|/* move upper 3 bits to lower 3 */
name|class
operator|=
name|form
operator|>>
literal|1
expr_stmt|;
comment|/* bits 7&6 -> bits 1&0, range 0-3 */
name|form
operator|&=
literal|0x1
expr_stmt|;
comment|/* bit 5 -> bit 0, range 0-1 */
else|#
directive|else
name|form
operator|=
operator|(
operator|*
name|p
operator|&
name|ASN_FORM_BITS
operator|)
operator|>>
name|ASN_FORM_SHIFT
expr_stmt|;
name|class
operator|=
operator|(
operator|*
name|p
operator|&
name|ASN_CLASS_BITS
operator|)
operator|>>
name|ASN_CLASS_SHIFT
expr_stmt|;
endif|#
directive|endif
name|elem
operator|->
name|form
operator|=
name|form
expr_stmt|;
name|elem
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|elem
operator|->
name|id
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|printf
argument_list|(
literal|"|%.2x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|hdr
operator|=
literal|1
expr_stmt|;
comment|/* extended tag field */
if|if
condition|(
name|id
operator|==
name|ASN_ID_EXT
condition|)
block|{
for|for
control|(
name|id
operator|=
literal|0
init|;
operator|*
name|p
operator|&
name|ASN_BIT8
operator|&&
name|len
operator|>
literal|0
condition|;
name|len
operator|--
operator|,
name|hdr
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
name|vflag
condition|)
name|printf
argument_list|(
literal|"|%.2x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|id
operator|+=
operator|*
name|p
operator|&
operator|~
name|ASN_BIT8
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
operator|*
name|p
operator|&
name|ASN_BIT8
condition|)
block|{
name|ifNotTruncated
name|fputs
argument_list|(
literal|"[Xtagfield?]"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|len
operator|<
literal|1
condition|)
block|{
name|ifNotTruncated
name|fputs
argument_list|(
literal|"[no asnlen]"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|elem
operator|->
name|asnlen
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|vflag
condition|)
name|printf
argument_list|(
literal|"|%.2x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|hdr
operator|++
expr_stmt|;
if|if
condition|(
name|elem
operator|->
name|asnlen
operator|&
name|ASN_BIT8
condition|)
block|{
name|int
name|noct
init|=
name|elem
operator|->
name|asnlen
operator|%
name|ASN_BIT8
decl_stmt|;
name|elem
operator|->
name|asnlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|noct
condition|)
block|{
name|ifNotTruncated
name|printf
argument_list|(
literal|"[asnlen? %d<%d]"
argument_list|,
name|len
argument_list|,
name|noct
argument_list|)
decl_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
init|;
name|noct
operator|--
operator|>
literal|0
condition|;
name|len
operator|--
operator|,
name|hdr
operator|++
control|)
block|{
if|if
condition|(
name|vflag
condition|)
name|printf
argument_list|(
literal|"|%.2x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|elem
operator|->
name|asnlen
operator|=
operator|(
name|elem
operator|->
name|asnlen
operator|<<
name|ASN_SHIFT8
operator|)
operator||
operator|*
name|p
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|<
name|elem
operator|->
name|asnlen
condition|)
block|{
if|if
condition|(
operator|!
name|truncated
condition|)
block|{
name|printf
argument_list|(
literal|"[len%d<asnlen%u]"
argument_list|,
name|len
argument_list|,
name|elem
operator|->
name|asnlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* maybe should check at least 4? */
name|elem
operator|->
name|asnlen
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|form
operator|>=
sizeof|sizeof
argument_list|(
name|Form
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|Form
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|ifNotTruncated
name|printf
argument_list|(
literal|"[form?%d]"
argument_list|,
name|form
argument_list|)
decl_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|class
operator|>=
sizeof|sizeof
argument_list|(
name|Class
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|Class
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|ifNotTruncated
name|printf
argument_list|(
literal|"[class?%c/%d]"
argument_list|,
operator|*
name|Form
index|[
name|form
index|]
argument_list|,
name|class
argument_list|)
decl_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|id
operator|>=
name|Class
index|[
name|class
index|]
operator|.
name|numIDs
condition|)
block|{
name|ifNotTruncated
name|printf
argument_list|(
literal|"[id?%c/%s/%d]"
argument_list|,
operator|*
name|Form
index|[
name|form
index|]
argument_list|,
name|Class
index|[
name|class
index|]
operator|.
name|name
argument_list|,
name|id
argument_list|)
decl_stmt|;
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|PRIMITIVE
case|:
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|UNIVERSAL
case|:
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|STRING
case|:
name|elem
operator|->
name|type
operator|=
name|BE_STR
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|str
operator|=
name|p
expr_stmt|;
break|break;
case|case
name|INTEGER
case|:
block|{
specifier|register
name|long
name|data
decl_stmt|;
name|elem
operator|->
name|type
operator|=
name|BE_INT
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
name|ASN_BIT8
condition|)
comment|/* negative */
name|data
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|elem
operator|->
name|asnlen
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
name|data
operator|=
operator|(
name|data
operator|<<
name|ASN_SHIFT8
operator|)
operator||
operator|*
name|p
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|integer
operator|=
name|data
expr_stmt|;
break|break;
block|}
case|case
name|OBJECTID
case|:
name|elem
operator|->
name|type
operator|=
name|BE_OID
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
break|break;
case|case
name|ASN_NULL
case|:
name|elem
operator|->
name|type
operator|=
name|BE_NULL
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|elem
operator|->
name|type
operator|=
name|BE_OCTET
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
name|printf
argument_list|(
literal|"[P/U/%s]"
argument_list|,
name|Class
index|[
name|class
index|]
operator|.
name|Id
index|[
name|id
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|APPLICATION
case|:
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|IPADDR
case|:
name|elem
operator|->
name|type
operator|=
name|BE_INETADDR
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
break|break;
case|case
name|COUNTER
case|:
case|case
name|GAUGE
case|:
case|case
name|TIMETICKS
case|:
block|{
specifier|register
name|u_long
name|data
decl_stmt|;
name|elem
operator|->
name|type
operator|=
name|BE_UNS
expr_stmt|;
name|data
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|elem
operator|->
name|asnlen
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
name|data
operator|=
operator|(
name|data
operator|<<
literal|8
operator|)
operator|+
operator|*
name|p
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|uns
operator|=
name|data
expr_stmt|;
break|break;
block|}
default|default:
name|elem
operator|->
name|type
operator|=
name|BE_OCTET
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
name|printf
argument_list|(
literal|"[P/A/%s]"
argument_list|,
name|Class
index|[
name|class
index|]
operator|.
name|Id
index|[
name|id
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|elem
operator|->
name|type
operator|=
name|BE_OCTET
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
name|printf
argument_list|(
literal|"[P/%s/%s]"
argument_list|,
name|Class
index|[
name|class
index|]
operator|.
name|name
argument_list|,
name|Class
index|[
name|class
index|]
operator|.
name|Id
index|[
name|id
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CONSTRUCTED
case|:
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|UNIVERSAL
case|:
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|SEQUENCE
case|:
name|elem
operator|->
name|type
operator|=
name|BE_SEQ
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
break|break;
default|default:
name|elem
operator|->
name|type
operator|=
name|BE_OCTET
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
name|printf
argument_list|(
literal|"C/U/%s"
argument_list|,
name|Class
index|[
name|class
index|]
operator|.
name|Id
index|[
name|id
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CONTEXT
case|:
name|elem
operator|->
name|type
operator|=
name|BE_PDU
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
break|break;
default|default:
name|elem
operator|->
name|type
operator|=
name|BE_OCTET
expr_stmt|;
name|elem
operator|->
name|data
operator|.
name|raw
operator|=
operator|(
name|caddr_t
operator|)
name|p
expr_stmt|;
name|printf
argument_list|(
literal|"C/%s/%s"
argument_list|,
name|Class
index|[
name|class
index|]
operator|.
name|name
argument_list|,
name|Class
index|[
name|class
index|]
operator|.
name|Id
index|[
name|id
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|p
operator|+=
name|elem
operator|->
name|asnlen
expr_stmt|;
name|len
operator|-=
name|elem
operator|->
name|asnlen
expr_stmt|;
return|return
name|elem
operator|->
name|asnlen
operator|+
name|hdr
return|;
block|}
end_function

begin_comment
comment|/*  * Display the ASN.1 object represented by the BE object.  * This used to be an integral part of asn1_parse() before the intermediate  * BE form was added.  */
end_comment

begin_function
specifier|static
name|void
name|asn1_print
parameter_list|(
name|struct
name|be
modifier|*
name|elem
parameter_list|)
block|{
name|u_char
modifier|*
name|p
init|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|->
name|data
operator|.
name|raw
decl_stmt|;
name|u_long
name|asnlen
init|=
name|elem
operator|->
name|asnlen
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|elem
operator|->
name|type
condition|)
block|{
case|case
name|BE_OCTET
case|:
for|for
control|(
name|i
operator|=
name|asnlen
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
empty_stmt|;
name|printf
argument_list|(
literal|"_%.2x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|BE_NULL
case|:
break|break;
case|case
name|BE_OID
case|:
block|{
name|int
name|o
init|=
literal|0
decl_stmt|,
name|first
init|=
operator|-
literal|1
decl_stmt|,
name|i
init|=
name|asnlen
decl_stmt|;
if|if
condition|(
operator|!
name|nflag
operator|&&
name|asnlen
operator|>
literal|2
condition|)
block|{
name|struct
name|obj_abrev
modifier|*
name|a
init|=
operator|&
name|obj_abrev_list
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
init|;
name|a
operator|->
name|node
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|a
operator|->
name|oid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|strlen
argument_list|(
name|a
operator|->
name|oid
argument_list|)
argument_list|)
condition|)
block|{
name|objp
operator|=
name|a
operator|->
name|node
operator|->
name|child
expr_stmt|;
name|i
operator|-=
name|strlen
argument_list|(
name|a
operator|->
name|oid
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|a
operator|->
name|oid
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|a
operator|->
name|prefix
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|o
operator|=
operator|(
name|o
operator|<<
name|ASN_SHIFT7
operator|)
operator|+
operator|(
operator|*
name|p
operator|&
operator|~
name|ASN_BIT8
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|&
name|ASN_LONGLEN
condition|)
continue|continue;
comment|/* 			 * first subitem encodes two items with 1st*OIDMUX+2nd 			 */
if|if
condition|(
name|first
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|nflag
condition|)
name|objp
operator|=
name|mibroot
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|OBJ_PRINT
argument_list|(
name|o
operator|/
name|OIDMUX
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|o
operator|%=
name|OIDMUX
expr_stmt|;
block|}
name|OBJ_PRINT
argument_list|(
name|o
argument_list|,
name|first
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|first
operator|<
literal|0
condition|)
name|first
operator|=
literal|0
expr_stmt|;
name|o
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
case|case
name|BE_INT
case|:
name|printf
argument_list|(
literal|"%ld"
argument_list|,
name|elem
operator|->
name|data
operator|.
name|integer
argument_list|)
expr_stmt|;
break|break;
case|case
name|BE_UNS
case|:
name|printf
argument_list|(
literal|"%ld"
argument_list|,
name|elem
operator|->
name|data
operator|.
name|uns
argument_list|)
expr_stmt|;
break|break;
case|case
name|BE_STR
case|:
block|{
specifier|register
name|int
name|printable
init|=
literal|1
decl_stmt|,
name|first
init|=
literal|1
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|p
init|=
name|elem
operator|->
name|data
operator|.
name|str
decl_stmt|;
for|for
control|(
name|i
operator|=
name|asnlen
init|;
name|printable
operator|&&
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
name|printable
operator|=
name|isprint
argument_list|(
operator|*
name|p
argument_list|)
operator|||
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|elem
operator|->
name|data
operator|.
name|str
expr_stmt|;
if|if
condition|(
name|printable
condition|)
operator|(
name|void
operator|)
name|fn_print
argument_list|(
name|p
argument_list|,
name|p
operator|+
name|asnlen
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
name|asnlen
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|printf
argument_list|(
name|first
condition|?
literal|"%.2x"
else|:
literal|"_%.2x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
case|case
name|BE_SEQ
case|:
name|printf
argument_list|(
literal|"Seq(%d)"
argument_list|,
name|elem
operator|->
name|asnlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|BE_INETADDR
case|:
block|{
name|char
name|sep
decl_stmt|;
if|if
condition|(
name|asnlen
operator|!=
name|ASNLEN_INETADDR
condition|)
name|printf
argument_list|(
literal|"[inetaddr len!=%d]"
argument_list|,
name|ASNLEN_INETADDR
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|'['
expr_stmt|;
for|for
control|(
name|i
operator|=
name|asnlen
init|;
name|i
operator|--
operator|>
literal|0
condition|;
name|p
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%c%u"
argument_list|,
name|sep
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|'.'
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BE_PDU
case|:
name|printf
argument_list|(
literal|"%s(%d)"
argument_list|,
name|Class
index|[
name|CONTEXT
index|]
operator|.
name|Id
index|[
name|elem
operator|->
name|id
index|]
argument_list|,
name|elem
operator|->
name|asnlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|BE_ANY
case|:
name|fputs
argument_list|(
literal|"[BE_ANY!?]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fputs
argument_list|(
literal|"[be!?]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * This is a brute force ASN.1 printer: recurses to dump an entire structure.  * This will work for any ASN.1 stream, not just an SNMP PDU.  *  * By adding newlines and spaces at the correct places, this would print in  * Rose-Normal-Form.  *  * This is not currently used.  */
end_comment

begin_function
specifier|static
name|void
name|asn1_decode
parameter_list|(
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|0
operator|&&
name|length
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|asn1_parse
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|" "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|elem
operator|.
name|type
operator|==
name|BE_SEQ
operator|||
name|elem
operator|.
name|type
operator|==
name|BE_PDU
condition|)
block|{
name|fputs
argument_list|(
literal|" {"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_decode
argument_list|(
name|elem
operator|.
name|data
operator|.
name|raw
argument_list|,
name|elem
operator|.
name|asnlen
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" }"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|length
operator|-=
name|i
expr_stmt|;
name|p
operator|+=
name|i
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * General SNMP header  *	SEQUENCE {  *		version INTEGER {version-1(0)},  *		community OCTET STRING,  *		data ANY	-- PDUs  *	}  * PDUs for all but Trap: (see rfc1157 from page 15 on)  *	SEQUENCE {  *		request-id INTEGER,  *		error-status INTEGER,  *		error-index INTEGER,  *		varbindlist SEQUENCE OF  *			SEQUENCE {  *				name ObjectName,  *				value ObjectValue  *			}  *	}  * PDU for Trap:  *	SEQUENCE {  *		enterprise OBJECT IDENTIFIER,  *		agent-addr NetworkAddress,  *		generic-trap INTEGER,  *		specific-trap INTEGER,  *		time-stamp TimeTicks,  *		varbindlist SEQUENCE OF  *			SEQUENCE {  *				name ObjectName,  *				value ObjectValue  *			}  *	}  */
end_comment

begin_comment
comment|/*  * Decode SNMP varBind  */
end_comment

begin_function
specifier|static
name|void
name|varbind_print
parameter_list|(
name|u_char
name|pduid
parameter_list|,
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|ind
decl_stmt|;
comment|/* Sequence of varBind */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_SEQ
condition|)
block|{
name|fputs
argument_list|(
literal|"[!SEQ of varbind]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|count
operator|<
name|length
condition|)
name|printf
argument_list|(
literal|"[%d extra after SEQ of varbind]"
argument_list|,
name|length
operator|-
name|count
argument_list|)
expr_stmt|;
comment|/* descend */
name|length
operator|=
name|elem
operator|.
name|asnlen
expr_stmt|;
name|np
operator|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|.
name|data
operator|.
name|raw
expr_stmt|;
for|for
control|(
name|ind
operator|=
literal|1
init|;
name|length
operator|>
literal|0
condition|;
name|ind
operator|++
control|)
block|{
specifier|const
name|u_char
modifier|*
name|vbend
decl_stmt|;
name|int
name|vblength
decl_stmt|;
if|if
condition|(
operator|!
name|error
operator|||
name|ind
operator|==
name|error
condition|)
name|fputs
argument_list|(
literal|" "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* Sequence */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_SEQ
condition|)
block|{
name|fputs
argument_list|(
literal|"[!varbind]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|vbend
operator|=
name|np
operator|+
name|count
expr_stmt|;
name|vblength
operator|=
name|length
operator|-
name|count
expr_stmt|;
comment|/* descend */
name|length
operator|=
name|elem
operator|.
name|asnlen
expr_stmt|;
name|np
operator|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|.
name|data
operator|.
name|raw
expr_stmt|;
comment|/* objName (OID) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_OID
condition|)
block|{
name|fputs
argument_list|(
literal|"[objName!=OID]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|error
operator|||
name|ind
operator|==
name|error
condition|)
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|pduid
operator|!=
name|GETREQ
operator|&&
name|pduid
operator|!=
name|GETNEXTREQ
operator|&&
operator|!
name|error
condition|)
name|fputs
argument_list|(
literal|"="
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* objVal (ANY) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|pduid
operator|==
name|GETREQ
operator|||
name|pduid
operator|==
name|GETNEXTREQ
condition|)
block|{
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_NULL
condition|)
block|{
name|fputs
argument_list|(
literal|"[objVal!=NULL]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|&&
name|ind
operator|==
name|error
operator|&&
name|elem
operator|.
name|type
operator|!=
name|BE_NULL
condition|)
name|fputs
argument_list|(
literal|"[err objVal!=NULL]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|||
name|ind
operator|==
name|error
condition|)
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
name|length
operator|=
name|vblength
expr_stmt|;
name|np
operator|=
name|vbend
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Decode SNMP PDUs: GetRequest, GetNextRequest, GetResponse, and SetRequest  */
end_comment

begin_function
specifier|static
name|void
name|snmppdu_print
parameter_list|(
name|u_char
name|pduid
parameter_list|,
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
comment|/* reqId (Integer) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|fputs
argument_list|(
literal|"[reqId!=INT]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* ignore the reqId */
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* errorStatus (Integer) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|fputs
argument_list|(
literal|"[errorStatus!=INT]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pduid
operator|==
name|GETREQ
operator|||
name|pduid
operator|==
name|GETNEXTREQ
operator|)
operator|&&
name|elem
operator|.
name|data
operator|.
name|integer
operator|!=
literal|0
condition|)
block|{
name|char
name|errbuf
index|[
literal|10
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"[errorStatus(%s)!=0]"
argument_list|,
name|DECODE_ErrorStatus
argument_list|(
name|elem
operator|.
name|data
operator|.
name|integer
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|elem
operator|.
name|data
operator|.
name|integer
operator|!=
literal|0
condition|)
block|{
name|char
name|errbuf
index|[
literal|10
index|]
decl_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|DECODE_ErrorStatus
argument_list|(
name|elem
operator|.
name|data
operator|.
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|elem
operator|.
name|data
operator|.
name|integer
expr_stmt|;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* errorIndex (Integer) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|fputs
argument_list|(
literal|"[errorIndex!=INT]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|pduid
operator|==
name|GETREQ
operator|||
name|pduid
operator|==
name|GETNEXTREQ
operator|)
operator|&&
name|elem
operator|.
name|data
operator|.
name|integer
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"[errorIndex(%d)!=0]"
argument_list|,
name|elem
operator|.
name|data
operator|.
name|integer
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|elem
operator|.
name|data
operator|.
name|integer
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|printf
argument_list|(
literal|"[errorIndex(%d) w/o errorStatus]"
argument_list|,
name|elem
operator|.
name|data
operator|.
name|integer
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"@%d"
argument_list|,
name|elem
operator|.
name|data
operator|.
name|integer
argument_list|)
expr_stmt|;
name|error
operator|=
name|elem
operator|.
name|data
operator|.
name|integer
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
name|fputs
argument_list|(
literal|"[errorIndex==0]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|varbind_print
argument_list|(
name|pduid
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Decode SNMP Trap PDU  */
end_comment

begin_function
specifier|static
name|void
name|trap_print
parameter_list|(
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|generic
decl_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* enterprise (oid) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_OID
condition|)
block|{
name|fputs
argument_list|(
literal|"[enterprise!=OID]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* agent-addr (inetaddr) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INETADDR
condition|)
block|{
name|fputs
argument_list|(
literal|"[agent-addr!=INETADDR]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* generic-trap (Integer) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|fputs
argument_list|(
literal|"[generic-trap!=INT]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|generic
operator|=
name|elem
operator|.
name|data
operator|.
name|integer
expr_stmt|;
block|{
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|DECODE_GenericTrap
argument_list|(
name|generic
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* specific-trap (Integer) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|fputs
argument_list|(
literal|"[specific-trap!=INT]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|generic
operator|!=
name|GT_ENTERPRISE
condition|)
block|{
if|if
condition|(
name|elem
operator|.
name|data
operator|.
name|integer
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"[specific-trap(%d)!=0]"
argument_list|,
name|elem
operator|.
name|data
operator|.
name|integer
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" s=%d"
argument_list|,
name|elem
operator|.
name|data
operator|.
name|integer
argument_list|)
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* time-stamp (TimeTicks) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_UNS
condition|)
block|{
comment|/* XXX */
name|fputs
argument_list|(
literal|"[time-stamp!=TIMETICKS]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
name|varbind_print
argument_list|(
name|TRAP
argument_list|,
name|np
argument_list|,
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Decode SNMP header and pass on to PDU printing routines  */
end_comment

begin_function
name|void
name|snmp_print
parameter_list|(
specifier|const
name|u_char
modifier|*
name|np
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|struct
name|be
name|elem
decl_stmt|,
name|pdu
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|truncated
operator|=
literal|0
expr_stmt|;
comment|/* truncated packet? */
if|if
condition|(
name|np
operator|+
name|length
operator|>
name|snapend
condition|)
block|{
name|truncated
operator|=
literal|1
expr_stmt|;
name|length
operator|=
name|snapend
operator|-
name|np
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
comment|/* initial Sequence */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_SEQ
condition|)
block|{
name|fputs
argument_list|(
literal|"[!init SEQ]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|count
operator|<
name|length
condition|)
name|printf
argument_list|(
literal|"[%d extra after iSEQ]"
argument_list|,
name|length
operator|-
name|count
argument_list|)
expr_stmt|;
comment|/* descend */
name|length
operator|=
name|elem
operator|.
name|asnlen
expr_stmt|;
name|np
operator|=
operator|(
name|u_char
operator|*
operator|)
name|elem
operator|.
name|data
operator|.
name|raw
expr_stmt|;
comment|/* Version (Integer) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_INT
condition|)
block|{
name|fputs
argument_list|(
literal|"[version!=INT]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* only handle version==0 */
if|if
condition|(
name|elem
operator|.
name|data
operator|.
name|integer
operator|!=
name|DEF_VERSION
condition|)
block|{
name|printf
argument_list|(
literal|"[version(%d)!=0]"
argument_list|,
name|elem
operator|.
name|data
operator|.
name|integer
argument_list|)
expr_stmt|;
return|return;
block|}
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* Community (String) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|elem
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|elem
operator|.
name|type
operator|!=
name|BE_STR
condition|)
block|{
name|fputs
argument_list|(
literal|"[comm!=STR]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|elem
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* default community */
if|if
condition|(
name|strncmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|elem
operator|.
name|data
operator|.
name|str
argument_list|,
name|DEF_COMMUNITY
argument_list|,
sizeof|sizeof
argument_list|(
name|DEF_COMMUNITY
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
comment|/* ! "public" */
name|printf
argument_list|(
literal|"C=%.*s "
argument_list|,
operator|(
name|int
operator|)
name|elem
operator|.
name|asnlen
argument_list|,
name|elem
operator|.
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
name|length
operator|-=
name|count
expr_stmt|;
name|np
operator|+=
name|count
expr_stmt|;
comment|/* PDU (Context) */
if|if
condition|(
operator|(
name|count
operator|=
name|asn1_parse
argument_list|(
name|np
argument_list|,
name|length
argument_list|,
operator|&
name|pdu
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|pdu
operator|.
name|type
operator|!=
name|BE_PDU
condition|)
block|{
name|fputs
argument_list|(
literal|"[no PDU]"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|count
operator|<
name|length
condition|)
name|printf
argument_list|(
literal|"[%d extra after PDU]"
argument_list|,
name|length
operator|-
name|count
argument_list|)
expr_stmt|;
name|asn1_print
argument_list|(
operator|&
name|pdu
argument_list|)
expr_stmt|;
comment|/* descend into PDU */
name|length
operator|=
name|pdu
operator|.
name|asnlen
expr_stmt|;
name|np
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pdu
operator|.
name|data
operator|.
name|raw
expr_stmt|;
switch|switch
condition|(
name|pdu
operator|.
name|id
condition|)
block|{
case|case
name|TRAP
case|:
name|trap_print
argument_list|(
name|np
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|GETREQ
case|:
case|case
name|GETNEXTREQ
case|:
case|case
name|GETRESP
case|:
case|case
name|SETREQ
case|:
name|snmppdu_print
argument_list|(
name|pdu
operator|.
name|id
argument_list|,
name|np
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

end_unit

