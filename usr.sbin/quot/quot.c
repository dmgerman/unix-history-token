begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1991, 1994 Wolfgang Solfrank.  * Copyright (C) 1991, 1994 TooLs GmbH.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by TooLs GmbH.  * 4. The name of TooLs GmbH may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* some flags of what to do: */
end_comment

begin_decl_stmt
specifier|static
name|char
name|estimate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|unused
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|long
name|blocksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|header
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|headerlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Original BSD quot doesn't round to number of frags/blocks,  * doesn't account for indirection blocks and gets it totally  * wrong if the	size is a multiple of the blocksize.  * The new code always counts the number of 512 byte blocks  * instead of the number of kilobytes and converts them	to  * kByte when done (on request).  *  * Due to the size of modern disks, we must cast intermediate  * values to 64 bits to prevent potential overflows.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT
end_ifdef

begin_define
define|#
directive|define
name|SIZE
parameter_list|(
name|n
parameter_list|)
value|(n)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SIZE
parameter_list|(
name|n
parameter_list|)
value|((int)(((quad_t)(n) * 512 + blocksize - 1)/blocksize))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INOCNT
parameter_list|(
name|fs
parameter_list|)
value|((fs)->fs_ipg)
end_define

begin_define
define|#
directive|define
name|INOSZ
parameter_list|(
name|fs
parameter_list|)
value|(sizeof(struct dinode) * INOCNT(fs))
end_define

begin_function
specifier|static
name|struct
name|dinode
modifier|*
name|get_inode
parameter_list|(
name|fd
parameter_list|,
name|super
parameter_list|,
name|ino
parameter_list|)
name|struct
name|fs
modifier|*
name|super
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
block|{
specifier|static
name|struct
name|dinode
modifier|*
name|ip
decl_stmt|;
specifier|static
name|ino_t
name|last
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* flush cache */
if|if
condition|(
name|ip
condition|)
block|{
name|free
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ip
operator|||
name|ino
operator|<
name|last
operator|||
name|ino
operator|>=
name|last
operator|+
name|INOCNT
argument_list|(
name|super
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ip
operator|&&
operator|!
operator|(
name|ip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
name|malloc
argument_list|(
name|INOSZ
argument_list|(
name|super
argument_list|)
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"allocate inodes"
argument_list|)
expr_stmt|;
name|last
operator|=
operator|(
name|ino
operator|/
name|INOCNT
argument_list|(
name|super
argument_list|)
operator|)
operator|*
name|INOCNT
argument_list|(
name|super
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|ino_to_fsba
argument_list|(
name|super
argument_list|,
name|last
argument_list|)
operator|<<
name|super
operator|->
name|fs_fshift
argument_list|,
literal|0
argument_list|)
operator|<
operator|(
name|off_t
operator|)
literal|0
operator|||
name|read
argument_list|(
name|fd
argument_list|,
name|ip
argument_list|,
name|INOSZ
argument_list|(
name|super
argument_list|)
argument_list|)
operator|!=
name|INOSZ
argument_list|(
name|super
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"read inodes"
argument_list|)
expr_stmt|;
block|}
return|return
name|ip
operator|+
name|ino
operator|%
name|INOCNT
argument_list|(
name|super
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT
end_ifdef

begin_define
define|#
directive|define
name|actualblocks
parameter_list|(
name|super
parameter_list|,
name|ip
parameter_list|)
value|((ip)->di_blocks/2)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|actualblocks
parameter_list|(
name|super
parameter_list|,
name|ip
parameter_list|)
value|((ip)->di_blocks)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|virtualblocks
parameter_list|(
name|super
parameter_list|,
name|ip
parameter_list|)
name|struct
name|fs
modifier|*
name|super
decl_stmt|;
name|struct
name|dinode
modifier|*
name|ip
decl_stmt|;
block|{
specifier|register
name|off_t
name|nblk
decl_stmt|,
name|sz
decl_stmt|;
name|sz
operator|=
name|ip
operator|->
name|di_size
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT
if|if
condition|(
name|lblkno
argument_list|(
name|super
argument_list|,
name|sz
argument_list|)
operator|>=
name|NDADDR
condition|)
block|{
name|nblk
operator|=
name|blkroundup
argument_list|(
name|super
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|==
name|nblk
condition|)
name|nblk
operator|+=
name|super
operator|->
name|fs_bsize
expr_stmt|;
block|}
return|return
name|sz
operator|/
literal|1024
return|;
else|#
directive|else
comment|/* COMPAT */
if|if
condition|(
name|lblkno
argument_list|(
name|super
argument_list|,
name|sz
argument_list|)
operator|>=
name|NDADDR
condition|)
block|{
name|nblk
operator|=
name|blkroundup
argument_list|(
name|super
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|sz
operator|=
name|lblkno
argument_list|(
name|super
argument_list|,
name|nblk
argument_list|)
expr_stmt|;
name|sz
operator|=
operator|(
name|sz
operator|-
name|NDADDR
operator|+
name|NINDIR
argument_list|(
name|super
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|NINDIR
argument_list|(
name|super
argument_list|)
expr_stmt|;
while|while
condition|(
name|sz
operator|>
literal|0
condition|)
block|{
name|nblk
operator|+=
name|sz
operator|*
name|super
operator|->
name|fs_bsize
expr_stmt|;
comment|/* sz - 1 rounded up */
name|sz
operator|=
operator|(
name|sz
operator|-
literal|1
operator|+
name|NINDIR
argument_list|(
name|super
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|NINDIR
argument_list|(
name|super
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|nblk
operator|=
name|fragroundup
argument_list|(
name|super
argument_list|,
name|sz
argument_list|)
expr_stmt|;
return|return
name|nblk
operator|/
literal|512
return|;
endif|#
directive|endif
comment|/* COMPAT */
block|}
end_function

begin_function
specifier|static
name|int
name|isfree
parameter_list|(
name|ip
parameter_list|)
name|struct
name|dinode
modifier|*
name|ip
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|COMPAT
return|return
operator|(
name|ip
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|==
literal|0
return|;
else|#
directive|else
comment|/* COMPAT */
switch|switch
condition|(
name|ip
operator|->
name|di_mode
operator|&
name|IFMT
condition|)
block|{
case|case
name|IFIFO
case|:
case|case
name|IFLNK
case|:
comment|/* should check FASTSYMLINK? */
case|case
name|IFDIR
case|:
case|case
name|IFREG
case|:
return|return
literal|0
return|;
default|default:
return|return
literal|1
return|;
block|}
endif|#
directive|endif
block|}
end_function

begin_struct
specifier|static
struct|struct
name|user
block|{
name|uid_t
name|uid
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|daddr_t
name|space
decl_stmt|;
name|long
name|count
decl_stmt|;
name|daddr_t
name|spc30
decl_stmt|;
name|daddr_t
name|spc60
decl_stmt|;
name|daddr_t
name|spc90
decl_stmt|;
block|}
modifier|*
name|users
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|nusers
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|inituser
parameter_list|()
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|user
modifier|*
name|usr
decl_stmt|;
if|if
condition|(
operator|!
name|nusers
condition|)
block|{
name|nusers
operator|=
literal|8
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|users
operator|=
operator|(
expr|struct
name|user
operator|*
operator|)
name|calloc
argument_list|(
name|nusers
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"allocate users"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|usr
operator|=
name|users
operator|,
name|i
operator|=
name|nusers
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|usr
operator|++
control|)
block|{
name|usr
operator|->
name|space
operator|=
name|usr
operator|->
name|spc30
operator|=
name|usr
operator|->
name|spc60
operator|=
name|usr
operator|->
name|spc90
operator|=
literal|0
expr_stmt|;
name|usr
operator|->
name|count
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usrrehash
parameter_list|()
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|struct
name|user
modifier|*
name|usr
decl_stmt|,
modifier|*
name|usrn
decl_stmt|;
name|struct
name|user
modifier|*
name|svusr
decl_stmt|;
name|svusr
operator|=
name|users
expr_stmt|;
name|nusers
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|users
operator|=
operator|(
expr|struct
name|user
operator|*
operator|)
name|calloc
argument_list|(
name|nusers
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"allocate users"
argument_list|)
expr_stmt|;
for|for
control|(
name|usr
operator|=
name|svusr
operator|,
name|i
operator|=
name|nusers
operator|>>
literal|1
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|usr
operator|++
control|)
block|{
for|for
control|(
name|usrn
operator|=
name|users
operator|+
operator|(
name|usr
operator|->
name|uid
operator|&
operator|(
name|nusers
operator|-
literal|1
operator|)
operator|)
init|;
name|usrn
operator|->
name|name
condition|;
name|usrn
operator|--
control|)
block|{
if|if
condition|(
name|usrn
operator|<=
name|users
condition|)
name|usrn
operator|=
name|users
operator|+
name|nusers
expr_stmt|;
block|}
operator|*
name|usrn
operator|=
operator|*
name|usr
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|user
modifier|*
name|user
parameter_list|(
name|uid
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
block|{
specifier|register
name|struct
name|user
modifier|*
name|usr
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|usr
operator|=
name|users
operator|+
operator|(
name|uid
operator|&
operator|(
name|nusers
operator|-
literal|1
operator|)
operator|)
operator|,
name|i
operator|=
name|nusers
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
name|usr
operator|--
control|)
block|{
if|if
condition|(
operator|!
name|usr
operator|->
name|name
condition|)
block|{
name|usr
operator|->
name|uid
operator|=
name|uid
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pwd
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|usr
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|7
argument_list|)
operator|)
condition|)
name|sprintf
argument_list|(
name|usr
operator|->
name|name
argument_list|,
literal|"#%d"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|usr
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
name|strcpy
argument_list|(
name|usr
operator|->
name|name
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|usr
operator|->
name|name
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"allocate users"
argument_list|)
expr_stmt|;
return|return
name|usr
return|;
block|}
elseif|else
if|if
condition|(
name|usr
operator|->
name|uid
operator|==
name|uid
condition|)
return|return
name|usr
return|;
if|if
condition|(
name|usr
operator|<=
name|users
condition|)
name|usr
operator|=
name|users
operator|+
name|nusers
expr_stmt|;
block|}
name|usrrehash
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cmpusers
parameter_list|(
name|u1
parameter_list|,
name|u2
parameter_list|)
name|struct
name|user
modifier|*
name|u1
decl_stmt|,
decl|*
name|u2
decl_stmt|;
end_function

begin_block
block|{
return|return
name|u2
operator|->
name|space
operator|-
name|u1
operator|->
name|space
return|;
block|}
end_block

begin_define
define|#
directive|define
name|sortusers
parameter_list|(
name|users
parameter_list|)
value|(qsort((users),nusers,sizeof(struct user), \ 				    cmpusers))
end_define

begin_function
specifier|static
name|void
name|uses
parameter_list|(
name|uid
parameter_list|,
name|blks
parameter_list|,
name|act
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
name|daddr_t
name|blks
decl_stmt|;
name|time_t
name|act
decl_stmt|;
block|{
specifier|static
name|time_t
name|today
decl_stmt|;
specifier|register
name|struct
name|user
modifier|*
name|usr
decl_stmt|;
if|if
condition|(
operator|!
name|today
condition|)
name|time
argument_list|(
operator|&
name|today
argument_list|)
expr_stmt|;
name|usr
operator|=
name|user
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|usr
operator|->
name|count
operator|++
expr_stmt|;
name|usr
operator|->
name|space
operator|+=
name|blks
expr_stmt|;
if|if
condition|(
name|today
operator|-
name|act
operator|>
literal|90L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
condition|)
name|usr
operator|->
name|spc90
operator|+=
name|blks
expr_stmt|;
if|if
condition|(
name|today
operator|-
name|act
operator|>
literal|60L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
condition|)
name|usr
operator|->
name|spc60
operator|+=
name|blks
expr_stmt|;
if|if
condition|(
name|today
operator|-
name|act
operator|>
literal|30L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
condition|)
name|usr
operator|->
name|spc30
operator|+=
name|blks
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT
end_ifdef

begin_define
define|#
directive|define
name|FSZCNT
value|500
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FSZCNT
value|512
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|fsizes
block|{
name|struct
name|fsizes
modifier|*
name|fsz_next
decl_stmt|;
name|daddr_t
name|fsz_first
decl_stmt|,
name|fsz_last
decl_stmt|;
name|ino_t
name|fsz_count
index|[
name|FSZCNT
index|]
decl_stmt|;
name|daddr_t
name|fsz_sz
index|[
name|FSZCNT
index|]
decl_stmt|;
block|}
modifier|*
name|fsizes
struct|;
end_struct

begin_function
specifier|static
name|void
name|initfsizes
parameter_list|()
block|{
specifier|register
name|struct
name|fsizes
modifier|*
name|fp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|fsizes
init|;
name|fp
condition|;
name|fp
operator|=
name|fp
operator|->
name|fsz_next
control|)
block|{
for|for
control|(
name|i
operator|=
name|FSZCNT
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|fp
operator|->
name|fsz_count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|fsz_sz
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dofsizes
parameter_list|(
name|fd
parameter_list|,
name|super
parameter_list|,
name|name
parameter_list|)
name|struct
name|fs
modifier|*
name|super
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|ino_t
name|inode
decl_stmt|,
name|maxino
decl_stmt|;
name|struct
name|dinode
modifier|*
name|ip
decl_stmt|;
name|daddr_t
name|sz
decl_stmt|,
name|ksz
decl_stmt|;
name|struct
name|fsizes
modifier|*
name|fp
decl_stmt|,
modifier|*
modifier|*
name|fsp
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|maxino
operator|=
name|super
operator|->
name|fs_ncg
operator|*
name|super
operator|->
name|fs_ipg
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT
if|if
condition|(
operator|!
operator|(
name|fsizes
operator|=
operator|(
expr|struct
name|fsizes
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fsizes
argument_list|)
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"allocate fsize structure"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPAT */
for|for
control|(
name|inode
operator|=
literal|0
init|;
name|inode
operator|<
name|maxino
condition|;
name|inode
operator|++
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|=
name|get_inode
argument_list|(
name|fd
argument_list|,
name|super
argument_list|,
name|inode
argument_list|)
operator|)
ifdef|#
directive|ifdef
name|COMPAT
operator|&&
operator|(
operator|(
name|ip
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFREG
operator|||
operator|(
name|ip
operator|->
name|di_mode
operator|&
name|IFMT
operator|)
operator|==
name|IFDIR
operator|)
else|#
directive|else
comment|/* COMPAT */
operator|&&
operator|!
name|isfree
argument_list|(
name|ip
argument_list|)
endif|#
directive|endif
comment|/* COMPAT */
condition|)
block|{
name|sz
operator|=
name|estimate
condition|?
name|virtualblocks
argument_list|(
name|super
argument_list|,
name|ip
argument_list|)
else|:
name|actualblocks
argument_list|(
name|super
argument_list|,
name|ip
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT
if|if
condition|(
name|sz
operator|>=
name|FSZCNT
condition|)
block|{
name|fsizes
operator|->
name|fsz_count
index|[
name|FSZCNT
operator|-
literal|1
index|]
operator|++
expr_stmt|;
name|fsizes
operator|->
name|fsz_sz
index|[
name|FSZCNT
operator|-
literal|1
index|]
operator|+=
name|sz
expr_stmt|;
block|}
else|else
block|{
name|fsizes
operator|->
name|fsz_count
index|[
name|sz
index|]
operator|++
expr_stmt|;
name|fsizes
operator|->
name|fsz_sz
index|[
name|sz
index|]
operator|+=
name|sz
expr_stmt|;
block|}
else|#
directive|else
comment|/* COMPAT */
name|ksz
operator|=
name|SIZE
argument_list|(
name|sz
argument_list|)
expr_stmt|;
for|for
control|(
name|fsp
operator|=
operator|&
name|fsizes
init|;
operator|(
name|fp
operator|=
operator|*
name|fsp
operator|)
condition|;
name|fsp
operator|=
operator|&
name|fp
operator|->
name|fsz_next
control|)
block|{
if|if
condition|(
name|ksz
operator|<
name|fp
operator|->
name|fsz_last
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|fp
operator|||
name|ksz
operator|<
name|fp
operator|->
name|fsz_first
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
operator|(
expr|struct
name|fsizes
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fsizes
argument_list|)
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"allocate fsize structure"
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fsz_next
operator|=
operator|*
name|fsp
expr_stmt|;
operator|*
name|fsp
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|fsz_first
operator|=
operator|(
name|ksz
operator|/
name|FSZCNT
operator|)
operator|*
name|FSZCNT
expr_stmt|;
name|fp
operator|->
name|fsz_last
operator|=
name|fp
operator|->
name|fsz_first
operator|+
name|FSZCNT
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FSZCNT
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|fp
operator|->
name|fsz_count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|fsz_sz
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|fp
operator|->
name|fsz_count
index|[
name|ksz
operator|%
name|FSZCNT
index|]
operator|++
expr_stmt|;
name|fp
operator|->
name|fsz_sz
index|[
name|ksz
operator|%
name|FSZCNT
index|]
operator|+=
name|sz
expr_stmt|;
endif|#
directive|endif
comment|/* COMPAT */
block|}
elseif|else
if|if
condition|(
name|errno
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|sz
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|fsizes
init|;
name|fp
condition|;
name|fp
operator|=
name|fp
operator|->
name|fsz_next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FSZCNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|fsz_count
index|[
name|i
index|]
condition|)
name|printf
argument_list|(
literal|"%d\t%d\t%d\n"
argument_list|,
name|fp
operator|->
name|fsz_first
operator|+
name|i
argument_list|,
name|fp
operator|->
name|fsz_count
index|[
name|i
index|]
argument_list|,
name|SIZE
argument_list|(
name|sz
operator|+=
name|fp
operator|->
name|fsz_sz
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|douser
parameter_list|(
name|fd
parameter_list|,
name|super
parameter_list|,
name|name
parameter_list|)
name|struct
name|fs
modifier|*
name|super
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|ino_t
name|inode
decl_stmt|,
name|maxino
decl_stmt|;
name|struct
name|user
modifier|*
name|usr
decl_stmt|,
modifier|*
name|usrs
decl_stmt|;
name|struct
name|dinode
modifier|*
name|ip
decl_stmt|;
specifier|register
name|n
expr_stmt|;
name|maxino
operator|=
name|super
operator|->
name|fs_ncg
operator|*
name|super
operator|->
name|fs_ipg
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|inode
operator|=
literal|0
init|;
name|inode
operator|<
name|maxino
condition|;
name|inode
operator|++
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|=
name|get_inode
argument_list|(
name|fd
argument_list|,
name|super
argument_list|,
name|inode
argument_list|)
operator|)
operator|&&
operator|!
name|isfree
argument_list|(
name|ip
argument_list|)
condition|)
name|uses
argument_list|(
name|ip
operator|->
name|di_uid
argument_list|,
name|estimate
condition|?
name|virtualblocks
argument_list|(
name|super
argument_list|,
name|ip
argument_list|)
else|:
name|actualblocks
argument_list|(
name|super
argument_list|,
name|ip
argument_list|)
argument_list|,
name|ip
operator|->
name|di_atime
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|usrs
operator|=
operator|(
expr|struct
name|user
operator|*
operator|)
name|malloc
argument_list|(
name|nusers
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"allocate users"
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|users
argument_list|,
name|usrs
argument_list|,
name|nusers
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
argument_list|)
expr_stmt|;
name|sortusers
argument_list|(
name|usrs
argument_list|)
expr_stmt|;
for|for
control|(
name|usr
operator|=
name|usrs
operator|,
name|n
operator|=
name|nusers
init|;
operator|--
name|n
operator|>=
literal|0
operator|&&
name|usr
operator|->
name|count
condition|;
name|usr
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%5d"
argument_list|,
name|SIZE
argument_list|(
name|usr
operator|->
name|space
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|printf
argument_list|(
literal|"\t%5d"
argument_list|,
name|usr
operator|->
name|count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t%-8s"
argument_list|,
name|usr
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unused
condition|)
name|printf
argument_list|(
literal|"\t%5d\t%5d\t%5d"
argument_list|,
name|SIZE
argument_list|(
name|usr
operator|->
name|spc30
argument_list|)
argument_list|,
name|SIZE
argument_list|(
name|usr
operator|->
name|spc60
argument_list|)
argument_list|,
name|SIZE
argument_list|(
name|usr
operator|->
name|spc90
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|usrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|donames
parameter_list|(
name|fd
parameter_list|,
name|super
parameter_list|,
name|name
parameter_list|)
name|struct
name|fs
modifier|*
name|super
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|ino_t
name|inode
decl_stmt|,
name|inode1
decl_stmt|;
name|ino_t
name|maxino
decl_stmt|;
name|struct
name|dinode
modifier|*
name|ip
decl_stmt|;
name|maxino
operator|=
name|super
operator|->
name|fs_ncg
operator|*
name|super
operator|->
name|fs_ipg
operator|-
literal|1
expr_stmt|;
comment|/* first skip the name of the filesystem */
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
operator|(
name|c
operator|<
literal|'0'
operator|||
name|c
operator|>
literal|'9'
operator|)
condition|)
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|inode1
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|scanf
argument_list|(
literal|"%d"
argument_list|,
operator|&
name|inode
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|inode
operator|<
literal|0
operator|||
name|inode
operator|>
name|maxino
condition|)
block|{
name|warnx
argument_list|(
literal|"illegal inode %d"
argument_list|,
name|inode
argument_list|)
expr_stmt|;
return|return;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|=
name|get_inode
argument_list|(
name|fd
argument_list|,
name|super
argument_list|,
name|inode
argument_list|)
operator|)
operator|&&
operator|!
name|isfree
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s\t"
argument_list|,
name|user
argument_list|(
name|ip
operator|->
name|di_uid
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* now skip whitespace */
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
empty_stmt|;
comment|/* and print out the remainder of the input line */
while|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|inode1
operator|=
name|inode
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errno
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* skip this line */
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|COMPAT
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: quot [-nfcvha] [filesystem ...]\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* COMPAT */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: quot [-acfhknv] [filesystem ...]\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPAT */
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|superblock
index|[
name|SBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|quot
parameter_list|(
name|name
parameter_list|,
name|mp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|mp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|fd
decl_stmt|;
name|get_inode
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* flush cache */
name|inituser
argument_list|()
expr_stmt|;
name|initfsizes
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|lseek
argument_list|(
name|fd
argument_list|,
name|SBOFF
argument_list|,
literal|0
argument_list|)
operator|!=
name|SBOFF
operator|||
name|read
argument_list|(
name|fd
argument_list|,
name|superblock
argument_list|,
name|SBSIZE
argument_list|)
operator|!=
name|SBSIZE
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|fs
operator|*
operator|)
name|superblock
operator|)
operator|->
name|fs_magic
operator|!=
name|FS_MAGIC
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: not a BSD filesystem"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s:"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
name|printf
argument_list|(
literal|" (%s)"
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
call|(
modifier|*
name|func
call|)
argument_list|(
name|fd
argument_list|,
name|superblock
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
name|all
init|=
literal|0
decl_stmt|;
name|struct
name|statfs
modifier|*
name|mp
decl_stmt|;
name|char
name|dev
index|[
name|MNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|nm
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|func
operator|=
name|douser
expr_stmt|;
ifndef|#
directive|ifndef
name|COMPAT
name|header
operator|=
name|getbsize
argument_list|(
operator|&
name|headerlen
argument_list|,
operator|&
name|blocksize
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
operator|*
operator|++
name|argv
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
block|{
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
case|case
literal|'n'
case|:
name|func
operator|=
name|donames
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|func
operator|=
name|dofsizes
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|all
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|count
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|estimate
operator|=
literal|1
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|COMPAT
case|case
literal|'k'
case|:
name|blocksize
operator|=
literal|1024
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* COMPAT */
case|case
literal|'v'
case|:
name|unused
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|all
condition|)
block|{
name|cnt
operator|=
name|getmntinfo
argument_list|(
operator|&
name|mp
argument_list|,
name|MNT_NOWAIT
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|--
name|cnt
operator|>=
literal|0
condition|;
name|mp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|mp
operator|->
name|f_fstypename
argument_list|,
literal|"ufs"
argument_list|,
name|MFSNAMELEN
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|nm
operator|=
name|strrchr
argument_list|(
name|mp
operator|->
name|f_mntfromname
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|dev
argument_list|,
literal|"/dev/r%s"
argument_list|,
name|nm
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nm
operator|=
name|dev
expr_stmt|;
block|}
else|else
name|nm
operator|=
name|mp
operator|->
name|f_mntfromname
expr_stmt|;
name|quot
argument_list|(
name|nm
argument_list|,
name|mp
operator|->
name|f_mntonname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
operator|--
name|argc
operator|>=
literal|0
condition|)
name|quot
argument_list|(
operator|*
name|argv
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

