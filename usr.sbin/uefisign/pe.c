begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Edward Tomasz Napierala under sponsorship  * from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  * PE format reference:  * http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"uefisign.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CTASSERT
end_ifndef

begin_define
define|#
directive|define
name|CTASSERT
parameter_list|(
name|x
parameter_list|)
value|_CTASSERT(x, __LINE__)
end_define

begin_define
define|#
directive|define
name|_CTASSERT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|__CTASSERT(x, y)
end_define

begin_define
define|#
directive|define
name|__CTASSERT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|typedef char __assert_ ## y [(x) ? 1 : -1]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|mz_header
block|{
name|uint8_t
name|mz_signature
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|mz_dont_care
index|[
literal|58
index|]
decl_stmt|;
name|uint16_t
name|mz_lfanew
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_struct
struct|struct
name|coff_header
block|{
name|uint8_t
name|coff_dont_care
index|[
literal|2
index|]
decl_stmt|;
name|uint16_t
name|coff_number_of_sections
decl_stmt|;
name|uint8_t
name|coff_dont_care_either
index|[
literal|16
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_define
define|#
directive|define
name|PE_SIGNATURE
value|0x00004550
end_define

begin_struct
struct|struct
name|pe_header
block|{
name|uint32_t
name|pe_signature
decl_stmt|;
name|struct
name|coff_header
name|pe_coff
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_define
define|#
directive|define
name|PE_OPTIONAL_MAGIC_32
value|0x010B
end_define

begin_define
define|#
directive|define
name|PE_OPTIONAL_MAGIC_32_PLUS
value|0x020B
end_define

begin_define
define|#
directive|define
name|PE_OPTIONAL_SUBSYSTEM_EFI_APPLICATION
value|10
end_define

begin_define
define|#
directive|define
name|PE_OPTIONAL_SUBSYSTEM_EFI_BOOT
value|11
end_define

begin_define
define|#
directive|define
name|PE_OPTIONAL_SUBSYSTEM_EFI_RUNTIME
value|12
end_define

begin_struct
struct|struct
name|pe_optional_header_32
block|{
name|uint16_t
name|po_magic
decl_stmt|;
name|uint8_t
name|po_dont_care
index|[
literal|58
index|]
decl_stmt|;
name|uint32_t
name|po_size_of_headers
decl_stmt|;
name|uint32_t
name|po_checksum
decl_stmt|;
name|uint16_t
name|po_subsystem
decl_stmt|;
name|uint8_t
name|po_dont_care_either
index|[
literal|22
index|]
decl_stmt|;
name|uint32_t
name|po_number_of_rva_and_sizes
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pe_optional_header_32
argument_list|,
name|po_size_of_headers
argument_list|)
operator|==
literal|60
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pe_optional_header_32
argument_list|,
name|po_checksum
argument_list|)
operator|==
literal|64
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pe_optional_header_32
argument_list|,
name|po_subsystem
argument_list|)
operator|==
literal|68
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pe_optional_header_32
argument_list|,
name|po_number_of_rva_and_sizes
argument_list|)
operator|==
literal|92
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|pe_optional_header_32_plus
block|{
name|uint16_t
name|po_magic
decl_stmt|;
name|uint8_t
name|po_dont_care
index|[
literal|58
index|]
decl_stmt|;
name|uint32_t
name|po_size_of_headers
decl_stmt|;
name|uint32_t
name|po_checksum
decl_stmt|;
name|uint16_t
name|po_subsystem
decl_stmt|;
name|uint8_t
name|po_dont_care_either
index|[
literal|38
index|]
decl_stmt|;
name|uint32_t
name|po_number_of_rva_and_sizes
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pe_optional_header_32_plus
argument_list|,
name|po_size_of_headers
argument_list|)
operator|==
literal|60
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pe_optional_header_32_plus
argument_list|,
name|po_checksum
argument_list|)
operator|==
literal|64
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pe_optional_header_32_plus
argument_list|,
name|po_subsystem
argument_list|)
operator|==
literal|68
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pe_optional_header_32_plus
argument_list|,
name|po_number_of_rva_and_sizes
argument_list|)
operator|==
literal|108
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PE_DIRECTORY_ENTRY_CERTIFICATE
value|4
end_define

begin_struct
struct|struct
name|pe_directory_entry
block|{
name|uint32_t
name|pde_rva
decl_stmt|;
name|uint32_t
name|pde_size
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_struct
struct|struct
name|pe_section_header
block|{
name|uint8_t
name|psh_dont_care
index|[
literal|16
index|]
decl_stmt|;
name|uint32_t
name|psh_size_of_raw_data
decl_stmt|;
name|uint32_t
name|psh_pointer_to_raw_data
decl_stmt|;
name|uint8_t
name|psh_dont_care_either
index|[
literal|16
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pe_section_header
argument_list|,
name|psh_size_of_raw_data
argument_list|)
operator|==
literal|16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|pe_section_header
argument_list|,
name|psh_pointer_to_raw_data
argument_list|)
operator|==
literal|20
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PE_CERTIFICATE_REVISION
value|0x0200
end_define

begin_define
define|#
directive|define
name|PE_CERTIFICATE_TYPE
value|0x0002
end_define

begin_struct
struct|struct
name|pe_certificate
block|{
name|uint32_t
name|pc_len
decl_stmt|;
name|uint16_t
name|pc_revision
decl_stmt|;
name|uint16_t
name|pc_type
decl_stmt|;
name|char
name|pc_signature
index|[
literal|0
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_function
name|void
name|range_check
parameter_list|(
specifier|const
name|struct
name|executable
modifier|*
name|x
parameter_list|,
name|off_t
name|off
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|off
operator|<
literal|0
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s starts at negative offset %jd"
argument_list|,
name|name
argument_list|,
operator|(
name|intmax_t
operator|)
name|off
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|>=
operator|(
name|off_t
operator|)
name|x
operator|->
name|x_len
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s starts at %jd, past the end of executable at %zd"
argument_list|,
name|name
argument_list|,
operator|(
name|intmax_t
operator|)
name|off
argument_list|,
name|x
operator|->
name|x_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
name|x
operator|->
name|x_len
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s size %zd is larger than the executable size %zd"
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|x
operator|->
name|x_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|+
name|len
operator|>
name|x
operator|->
name|x_len
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s extends to %jd, past the end of executable at %zd"
argument_list|,
name|name
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|off
operator|+
name|len
argument_list|)
argument_list|,
name|x
operator|->
name|x_len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|size_t
name|signature_size
parameter_list|(
specifier|const
name|struct
name|executable
modifier|*
name|x
parameter_list|)
block|{
specifier|const
name|struct
name|pe_directory_entry
modifier|*
name|pde
decl_stmt|;
name|range_check
argument_list|(
name|x
argument_list|,
name|x
operator|->
name|x_certificate_entry_off
argument_list|,
name|x
operator|->
name|x_certificate_entry_len
argument_list|,
literal|"Certificate Directory"
argument_list|)
expr_stmt|;
name|pde
operator|=
operator|(
expr|struct
name|pe_directory_entry
operator|*
operator|)
operator|(
name|x
operator|->
name|x_buf
operator|+
name|x
operator|->
name|x_certificate_entry_off
operator|)
expr_stmt|;
if|if
condition|(
name|pde
operator|->
name|pde_rva
operator|!=
literal|0
operator|&&
name|pde
operator|->
name|pde_size
operator|==
literal|0
condition|)
name|warnx
argument_list|(
literal|"signature size is 0, but its RVA is %d"
argument_list|,
name|pde
operator|->
name|pde_rva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|->
name|pde_rva
operator|==
literal|0
operator|&&
name|pde
operator|->
name|pde_size
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"signature RVA is 0, but its size is %d"
argument_list|,
name|pde
operator|->
name|pde_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|pde
operator|->
name|pde_size
operator|)
return|;
block|}
end_function

begin_function
name|void
name|show_certificate
parameter_list|(
specifier|const
name|struct
name|executable
modifier|*
name|x
parameter_list|)
block|{
name|struct
name|pe_certificate
modifier|*
name|pc
decl_stmt|;
specifier|const
name|struct
name|pe_directory_entry
modifier|*
name|pde
decl_stmt|;
name|range_check
argument_list|(
name|x
argument_list|,
name|x
operator|->
name|x_certificate_entry_off
argument_list|,
name|x
operator|->
name|x_certificate_entry_len
argument_list|,
literal|"Certificate Directory"
argument_list|)
expr_stmt|;
name|pde
operator|=
operator|(
expr|struct
name|pe_directory_entry
operator|*
operator|)
operator|(
name|x
operator|->
name|x_buf
operator|+
name|x
operator|->
name|x_certificate_entry_off
operator|)
expr_stmt|;
if|if
condition|(
name|signature_size
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"file not signed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|printf("certificate chunk at offset %zd, size %zd\n", 	    pde->pde_rva, pde->pde_size);
endif|#
directive|endif
name|range_check
argument_list|(
name|x
argument_list|,
name|pde
operator|->
name|pde_rva
argument_list|,
name|pde
operator|->
name|pde_size
argument_list|,
literal|"Certificate chunk"
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
expr|struct
name|pe_certificate
operator|*
operator|)
operator|(
name|x
operator|->
name|x_buf
operator|+
name|pde
operator|->
name|pde_rva
operator|)
expr_stmt|;
if|if
condition|(
name|pc
operator|->
name|pc_revision
operator|!=
name|PE_CERTIFICATE_REVISION
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"wrong certificate chunk revision, is %d, should be %d"
argument_list|,
name|pc
operator|->
name|pc_revision
argument_list|,
name|PE_CERTIFICATE_REVISION
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pc
operator|->
name|pc_type
operator|!=
name|PE_CERTIFICATE_TYPE
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"wrong certificate chunk type, is %d, should be %d"
argument_list|,
name|pc
operator|->
name|pc_type
argument_list|,
name|PE_CERTIFICATE_TYPE
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"to dump PKCS7:\n    "
literal|"dd if='%s' bs=1 skip=%zd | openssl pkcs7 -inform DER -print\n"
argument_list|,
name|x
operator|->
name|x_path
argument_list|,
name|pde
operator|->
name|pde_rva
operator|+
name|offsetof
argument_list|(
expr|struct
name|pe_certificate
argument_list|,
name|pc_signature
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"to dump raw ASN.1:\n    "
literal|"openssl asn1parse -i -inform DER -offset %zd -in '%s'\n"
argument_list|,
name|pde
operator|->
name|pde_rva
operator|+
name|offsetof
argument_list|(
expr|struct
name|pe_certificate
argument_list|,
name|pc_signature
argument_list|)
argument_list|,
name|x
operator|->
name|x_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_section_table
parameter_list|(
name|struct
name|executable
modifier|*
name|x
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|number_of_sections
parameter_list|)
block|{
specifier|const
name|struct
name|pe_section_header
modifier|*
name|psh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|range_check
argument_list|(
name|x
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|psh
argument_list|)
operator|*
name|number_of_sections
argument_list|,
literal|"section table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|x_headers_len
operator|<=
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|psh
argument_list|)
operator|*
name|number_of_sections
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"section table outside of headers"
argument_list|)
expr_stmt|;
name|psh
operator|=
operator|(
specifier|const
expr|struct
name|pe_section_header
operator|*
operator|)
operator|(
name|x
operator|->
name|x_buf
operator|+
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|number_of_sections
operator|>=
name|MAX_SECTIONS
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"too many sections: got %d, should be %d"
argument_list|,
name|number_of_sections
argument_list|,
name|MAX_SECTIONS
argument_list|)
expr_stmt|;
block|}
name|x
operator|->
name|x_nsections
operator|=
name|number_of_sections
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_sections
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|psh
operator|->
name|psh_pointer_to_raw_data
operator|<
name|x
operator|->
name|x_headers_len
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"section points inside the headers"
argument_list|)
expr_stmt|;
name|range_check
argument_list|(
name|x
argument_list|,
name|psh
operator|->
name|psh_pointer_to_raw_data
argument_list|,
name|psh
operator|->
name|psh_size_of_raw_data
argument_list|,
literal|"section"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("section %d: start %d, size %d\n", 		    i, psh->psh_pointer_to_raw_data, psh->psh_size_of_raw_data);
endif|#
directive|endif
name|x
operator|->
name|x_section_off
index|[
name|i
index|]
operator|=
name|psh
operator|->
name|psh_pointer_to_raw_data
expr_stmt|;
name|x
operator|->
name|x_section_len
index|[
name|i
index|]
operator|=
name|psh
operator|->
name|psh_size_of_raw_data
expr_stmt|;
name|psh
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_directory
parameter_list|(
name|struct
name|executable
modifier|*
name|x
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|number_of_rva_and_sizes
parameter_list|,
name|int
name|number_of_sections
parameter_list|)
block|{
comment|//int i;
specifier|const
name|struct
name|pe_directory_entry
modifier|*
name|pde
decl_stmt|;
comment|//printf("Data Directory at offset %zd\n", off);
if|if
condition|(
name|number_of_rva_and_sizes
operator|<=
name|PE_DIRECTORY_ENTRY_CERTIFICATE
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"wrong NumberOfRvaAndSizes %d; should be at least %d"
argument_list|,
name|number_of_rva_and_sizes
argument_list|,
name|PE_DIRECTORY_ENTRY_CERTIFICATE
argument_list|)
expr_stmt|;
block|}
name|range_check
argument_list|(
name|x
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pde
argument_list|)
operator|*
name|number_of_rva_and_sizes
argument_list|,
literal|"PE Data Directory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|x_headers_len
operator|<=
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|pde
argument_list|)
operator|*
name|number_of_rva_and_sizes
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"PE Data Directory outside of headers"
argument_list|)
expr_stmt|;
name|x
operator|->
name|x_certificate_entry_off
operator|=
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|pde
argument_list|)
operator|*
name|PE_DIRECTORY_ENTRY_CERTIFICATE
expr_stmt|;
name|x
operator|->
name|x_certificate_entry_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pde
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("certificate directory entry at offset %zd, len %zd\n", 	    x->x_certificate_entry_off, x->x_certificate_entry_len);  	pde = (struct pe_directory_entry *)(x->x_buf + off); 	for (i = 0; i< number_of_rva_and_sizes; i++) { 		printf("rva %zd, size %zd\n", pde->pde_rva, pde->pde_size); 		pde++; 	}
endif|#
directive|endif
return|return
operator|(
name|parse_section_table
argument_list|(
name|x
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|pde
argument_list|)
operator|*
name|number_of_rva_and_sizes
argument_list|,
name|number_of_sections
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The PE checksum algorithm is undocumented; this code is mostly based on  * http://forum.sysinternals.com/optional-header-checksum-calculation_topic24214.html  *  * "Sum the entire image file, excluding the CheckSum field in the optional  * header, as an array of USHORTs, allowing any carry above 16 bits to be added  * back onto the low 16 bits. Then add the file size to get a 32-bit value."  *  * Note that most software does not care about the checksum at all; perhaps  * we could just set it to 0 instead.  *  * XXX: Endianness?  */
end_comment

begin_function
specifier|static
name|uint32_t
name|compute_checksum
parameter_list|(
specifier|const
name|struct
name|executable
modifier|*
name|x
parameter_list|)
block|{
name|uint32_t
name|cksum
init|=
literal|0
decl_stmt|;
name|uint16_t
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|range_check
argument_list|(
name|x
argument_list|,
name|x
operator|->
name|x_checksum_off
argument_list|,
name|x
operator|->
name|x_checksum_len
argument_list|,
literal|"PE checksum"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|x
operator|->
name|x_checksum_off
operator|%
literal|2
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|<
name|x
operator|->
name|x_len
condition|;
name|i
operator|+=
literal|2
control|)
block|{
comment|/* 		 * Don't checksum the checksum.  The +2 is because the checksum 		 * is 4 bytes, and here we're iterating over 2 byte chunks. 		 */
if|if
condition|(
name|i
operator|==
name|x
operator|->
name|x_checksum_off
operator|||
name|i
operator|==
name|x
operator|->
name|x_checksum_off
operator|+
literal|2
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|i
operator|+
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|<=
name|x
operator|->
name|x_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
argument_list|,
name|x
operator|->
name|x_buf
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cksum
operator|+=
name|tmp
expr_stmt|;
name|cksum
operator|+=
name|cksum
operator|>>
literal|16
expr_stmt|;
name|cksum
operator|&=
literal|0xffff
expr_stmt|;
block|}
name|cksum
operator|+=
name|cksum
operator|>>
literal|16
expr_stmt|;
name|cksum
operator|&=
literal|0xffff
expr_stmt|;
name|cksum
operator|+=
name|x
operator|->
name|x_len
expr_stmt|;
return|return
operator|(
name|cksum
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_optional_32_plus
parameter_list|(
name|struct
name|executable
modifier|*
name|x
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|number_of_sections
parameter_list|)
block|{
if|#
directive|if
literal|0
block|uint32_t computed_checksum;
endif|#
directive|endif
specifier|const
name|struct
name|pe_optional_header_32_plus
modifier|*
name|po
decl_stmt|;
name|range_check
argument_list|(
name|x
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|po
argument_list|)
argument_list|,
literal|"PE Optional Header"
argument_list|)
expr_stmt|;
name|po
operator|=
operator|(
expr|struct
name|pe_optional_header_32_plus
operator|*
operator|)
operator|(
name|x
operator|->
name|x_buf
operator|+
name|off
operator|)
expr_stmt|;
switch|switch
condition|(
name|po
operator|->
name|po_subsystem
condition|)
block|{
case|case
name|PE_OPTIONAL_SUBSYSTEM_EFI_APPLICATION
case|:
case|case
name|PE_OPTIONAL_SUBSYSTEM_EFI_BOOT
case|:
case|case
name|PE_OPTIONAL_SUBSYSTEM_EFI_RUNTIME
case|:
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"wrong PE Optional Header subsystem 0x%x"
argument_list|,
name|po
operator|->
name|po_subsystem
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("subsystem %d, checksum 0x%x, %d data directories\n", 	    po->po_subsystem, po->po_checksum, po->po_number_of_rva_and_sizes);
endif|#
directive|endif
name|x
operator|->
name|x_checksum_off
operator|=
name|off
operator|+
name|offsetof
argument_list|(
expr|struct
name|pe_optional_header_32_plus
argument_list|,
name|po_checksum
argument_list|)
expr_stmt|;
name|x
operator|->
name|x_checksum_len
operator|=
sizeof|sizeof
argument_list|(
name|po
operator|->
name|po_checksum
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("checksum 0x%x at offset %zd, len %zd\n", 	    po->po_checksum, x->x_checksum_off, x->x_checksum_len);  	computed_checksum = compute_checksum(x); 	if (computed_checksum != po->po_checksum) { 		warnx("invalid PE+ checksum; is 0x%x, should be 0x%x", 		    po->po_checksum, computed_checksum); 	}
endif|#
directive|endif
if|if
condition|(
name|x
operator|->
name|x_len
operator|<
name|x
operator|->
name|x_headers_len
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid SizeOfHeaders %d"
argument_list|,
name|po
operator|->
name|po_size_of_headers
argument_list|)
expr_stmt|;
name|x
operator|->
name|x_headers_len
operator|=
name|po
operator|->
name|po_size_of_headers
expr_stmt|;
comment|//printf("Size of Headers: %d\n", po->po_size_of_headers);
return|return
operator|(
name|parse_directory
argument_list|(
name|x
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|po
argument_list|)
argument_list|,
name|po
operator|->
name|po_number_of_rva_and_sizes
argument_list|,
name|number_of_sections
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_optional_32
parameter_list|(
name|struct
name|executable
modifier|*
name|x
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|number_of_sections
parameter_list|)
block|{
if|#
directive|if
literal|0
block|uint32_t computed_checksum;
endif|#
directive|endif
specifier|const
name|struct
name|pe_optional_header_32
modifier|*
name|po
decl_stmt|;
name|range_check
argument_list|(
name|x
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|po
argument_list|)
argument_list|,
literal|"PE Optional Header"
argument_list|)
expr_stmt|;
name|po
operator|=
operator|(
expr|struct
name|pe_optional_header_32
operator|*
operator|)
operator|(
name|x
operator|->
name|x_buf
operator|+
name|off
operator|)
expr_stmt|;
switch|switch
condition|(
name|po
operator|->
name|po_subsystem
condition|)
block|{
case|case
name|PE_OPTIONAL_SUBSYSTEM_EFI_APPLICATION
case|:
case|case
name|PE_OPTIONAL_SUBSYSTEM_EFI_BOOT
case|:
case|case
name|PE_OPTIONAL_SUBSYSTEM_EFI_RUNTIME
case|:
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"wrong PE Optional Header subsystem 0x%x"
argument_list|,
name|po
operator|->
name|po_subsystem
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf("subsystem %d, checksum 0x%x, %d data directories\n", 	    po->po_subsystem, po->po_checksum, po->po_number_of_rva_and_sizes);
endif|#
directive|endif
name|x
operator|->
name|x_checksum_off
operator|=
name|off
operator|+
name|offsetof
argument_list|(
expr|struct
name|pe_optional_header_32
argument_list|,
name|po_checksum
argument_list|)
expr_stmt|;
name|x
operator|->
name|x_checksum_len
operator|=
sizeof|sizeof
argument_list|(
name|po
operator|->
name|po_checksum
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("checksum at offset %zd, len %zd\n", 	    x->x_checksum_off, x->x_checksum_len);  	computed_checksum = compute_checksum(x); 	if (computed_checksum != po->po_checksum) { 		warnx("invalid PE checksum; is 0x%x, should be 0x%x", 		    po->po_checksum, computed_checksum); 	}
endif|#
directive|endif
if|if
condition|(
name|x
operator|->
name|x_len
operator|<
name|x
operator|->
name|x_headers_len
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid SizeOfHeaders %d"
argument_list|,
name|po
operator|->
name|po_size_of_headers
argument_list|)
expr_stmt|;
name|x
operator|->
name|x_headers_len
operator|=
name|po
operator|->
name|po_size_of_headers
expr_stmt|;
comment|//printf("Size of Headers: %d\n", po->po_size_of_headers);
return|return
operator|(
name|parse_directory
argument_list|(
name|x
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|po
argument_list|)
argument_list|,
name|po
operator|->
name|po_number_of_rva_and_sizes
argument_list|,
name|number_of_sections
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_optional
parameter_list|(
name|struct
name|executable
modifier|*
name|x
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|number_of_sections
parameter_list|)
block|{
specifier|const
name|struct
name|pe_optional_header_32
modifier|*
name|po
decl_stmt|;
comment|//printf("Optional header offset %zd\n", off);
name|range_check
argument_list|(
name|x
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|po
argument_list|)
argument_list|,
literal|"PE Optional Header"
argument_list|)
expr_stmt|;
name|po
operator|=
operator|(
expr|struct
name|pe_optional_header_32
operator|*
operator|)
operator|(
name|x
operator|->
name|x_buf
operator|+
name|off
operator|)
expr_stmt|;
switch|switch
condition|(
name|po
operator|->
name|po_magic
condition|)
block|{
case|case
name|PE_OPTIONAL_MAGIC_32
case|:
return|return
operator|(
name|parse_optional_32
argument_list|(
name|x
argument_list|,
name|off
argument_list|,
name|number_of_sections
argument_list|)
operator|)
return|;
case|case
name|PE_OPTIONAL_MAGIC_32_PLUS
case|:
return|return
operator|(
name|parse_optional_32_plus
argument_list|(
name|x
argument_list|,
name|off
argument_list|,
name|number_of_sections
argument_list|)
operator|)
return|;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"wrong PE Optional Header magic 0x%x"
argument_list|,
name|po
operator|->
name|po_magic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_pe
parameter_list|(
name|struct
name|executable
modifier|*
name|x
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
specifier|const
name|struct
name|pe_header
modifier|*
name|pe
decl_stmt|;
comment|//printf("PE offset %zd, PE size %zd\n", off, sizeof(*pe));
name|range_check
argument_list|(
name|x
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pe
argument_list|)
argument_list|,
literal|"PE header"
argument_list|)
expr_stmt|;
name|pe
operator|=
operator|(
expr|struct
name|pe_header
operator|*
operator|)
operator|(
name|x
operator|->
name|x_buf
operator|+
name|off
operator|)
expr_stmt|;
if|if
condition|(
name|pe
operator|->
name|pe_signature
operator|!=
name|PE_SIGNATURE
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"wrong PE signature 0x%x"
argument_list|,
name|pe
operator|->
name|pe_signature
argument_list|)
expr_stmt|;
comment|//printf("Number of sections: %d\n", pe->pe_coff.coff_number_of_sections);
name|parse_optional
argument_list|(
name|x
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|pe
argument_list|)
argument_list|,
name|pe
operator|->
name|pe_coff
operator|.
name|coff_number_of_sections
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|parse
parameter_list|(
name|struct
name|executable
modifier|*
name|x
parameter_list|)
block|{
specifier|const
name|struct
name|mz_header
modifier|*
name|mz
decl_stmt|;
name|range_check
argument_list|(
name|x
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mz
argument_list|)
argument_list|,
literal|"MZ header"
argument_list|)
expr_stmt|;
name|mz
operator|=
operator|(
expr|struct
name|mz_header
operator|*
operator|)
name|x
operator|->
name|x_buf
expr_stmt|;
if|if
condition|(
name|mz
operator|->
name|mz_signature
index|[
literal|0
index|]
operator|!=
literal|'M'
operator|||
name|mz
operator|->
name|mz_signature
index|[
literal|1
index|]
operator|!=
literal|'Z'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"MZ header not found"
argument_list|)
expr_stmt|;
return|return
operator|(
name|parse_pe
argument_list|(
name|x
argument_list|,
name|mz
operator|->
name|mz_lfanew
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|off_t
name|append
parameter_list|(
name|struct
name|executable
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|off_t
name|off
decl_stmt|;
comment|/* 	 * XXX: Alignment. 	 */
name|off
operator|=
name|x
operator|->
name|x_len
expr_stmt|;
name|x
operator|->
name|x_buf
operator|=
name|realloc
argument_list|(
name|x
operator|->
name|x_buf
argument_list|,
name|x
operator|->
name|x_len
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|x_buf
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"realloc"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|x
operator|->
name|x_buf
operator|+
name|x
operator|->
name|x_len
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|x
operator|->
name|x_len
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|off
operator|)
return|;
block|}
end_function

begin_function
name|void
name|update
parameter_list|(
name|struct
name|executable
modifier|*
name|x
parameter_list|)
block|{
name|uint32_t
name|checksum
decl_stmt|;
name|struct
name|pe_certificate
modifier|*
name|pc
decl_stmt|;
name|struct
name|pe_directory_entry
name|pde
decl_stmt|;
name|size_t
name|pc_len
decl_stmt|;
name|off_t
name|pc_off
decl_stmt|;
name|pc_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pc
argument_list|)
operator|+
name|x
operator|->
name|x_signature_len
expr_stmt|;
name|pc
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|pc_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Note that pc_len is the length of pc_certificate, 	 * not the whole structure. 	 * 	 * XXX: That's what the spec says - but it breaks at least 	 *      sbverify and "pesign -S", so the spec is probably wrong. 	 */
block|pc->pc_len = x->x_signature_len;
else|#
directive|else
name|pc
operator|->
name|pc_len
operator|=
name|pc_len
expr_stmt|;
endif|#
directive|endif
name|pc
operator|->
name|pc_revision
operator|=
name|PE_CERTIFICATE_REVISION
expr_stmt|;
name|pc
operator|->
name|pc_type
operator|=
name|PE_CERTIFICATE_TYPE
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pc
operator|->
name|pc_signature
argument_list|,
name|x
operator|->
name|x_signature
argument_list|,
name|x
operator|->
name|x_signature_len
argument_list|)
expr_stmt|;
name|pc_off
operator|=
name|append
argument_list|(
name|x
argument_list|,
name|pc
argument_list|,
name|pc_len
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("added signature chunk at offset %zd, len %zd\n", 	    pc_off, pc_len);
endif|#
directive|endif
name|free
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|pde
operator|.
name|pde_rva
operator|=
name|pc_off
expr_stmt|;
name|pde
operator|.
name|pde_size
operator|=
name|pc_len
expr_stmt|;
name|memcpy
argument_list|(
name|x
operator|->
name|x_buf
operator|+
name|x
operator|->
name|x_certificate_entry_off
argument_list|,
operator|&
name|pde
argument_list|,
sizeof|sizeof
argument_list|(
name|pde
argument_list|)
argument_list|)
expr_stmt|;
name|checksum
operator|=
name|compute_checksum
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|checksum
argument_list|)
operator|==
name|x
operator|->
name|x_checksum_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|x
operator|->
name|x_buf
operator|+
name|x
operator|->
name|x_checksum_off
argument_list|,
operator|&
name|checksum
argument_list|,
sizeof|sizeof
argument_list|(
name|checksum
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("new checksum 0x%x\n", checksum);
endif|#
directive|endif
block|}
end_function

end_unit

