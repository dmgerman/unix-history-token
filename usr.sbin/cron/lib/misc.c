begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 1988,1990,1993,1994 by Paul Vixie  * All rights reserved  *  * Distribute freely, except: don't remove my name from the source or  * documentation (don't take credit for my work), mark your changes (don't  * get me blamed for your possible bugs), don't alter or remove this  * notice.  May be sold if buildable source is provided to buyer.  No  * warrantee of any kind, express or implied, is included with this  * software; use at your own risk, responsibility for damages (if any) to  * anyone resulting from the use of this software rests entirely with the  * user.  *  * Send bug reports, bug fixes, enhancements, requests, flames, etc., and  * I'll try to keep a version up to date.  I can be reached as follows:  * Paul Vixie<paul@vix.com>          uunet!decwrl!vixie!paul  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LINT
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: misc.c,v 1.3 1995/05/30 03:47:11 rgrimes Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* vix 26jan87 [RCS has the rest of the log]  * vix 30dec86 [written]  */
end_comment

begin_include
include|#
directive|include
file|"cron.h"
end_include

begin_if
if|#
directive|if
name|SYS_TIME_H
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYSLOG
argument_list|)
end_if

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LOG_DAEMON
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LOG_CRON
argument_list|)
end_if

begin_define
define|#
directive|define
name|LOG_CRON
value|LOG_DAEMON
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|LogFD
init|=
name|ERR
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|strcmp_until
parameter_list|(
name|left
parameter_list|,
name|right
parameter_list|,
name|until
parameter_list|)
name|char
modifier|*
name|left
decl_stmt|;
name|char
modifier|*
name|right
decl_stmt|;
name|int
name|until
decl_stmt|;
block|{
specifier|register
name|int
name|diff
decl_stmt|;
while|while
condition|(
operator|*
name|left
operator|&&
operator|*
name|left
operator|!=
name|until
operator|&&
operator|*
name|left
operator|==
operator|*
name|right
condition|)
block|{
name|left
operator|++
expr_stmt|;
name|right
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|left
operator|==
literal|'\0'
operator|||
operator|*
name|left
operator|==
name|until
operator|)
operator|&&
operator|(
operator|*
name|right
operator|==
literal|'\0'
operator|||
operator|*
name|right
operator|==
name|until
operator|)
condition|)
block|{
name|diff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|diff
operator|=
operator|*
name|left
operator|-
operator|*
name|right
expr_stmt|;
block|}
return|return
name|diff
return|;
block|}
end_function

begin_comment
comment|/* strdtb(s) - delete trailing blanks in string 's' and return new length  */
end_comment

begin_function
name|int
name|strdtb
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|x
init|=
name|s
decl_stmt|;
comment|/* scan forward to the null 	 */
while|while
condition|(
operator|*
name|x
condition|)
name|x
operator|++
expr_stmt|;
comment|/* scan backward to either the first character before the string, 	 * or the last non-blank in the string, whichever comes first. 	 */
do|do
block|{
name|x
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|>=
name|s
operator|&&
name|isspace
argument_list|(
operator|*
name|x
argument_list|)
condition|)
do|;
comment|/* one character beyond where we stopped above is where the null 	 * goes. 	 */
operator|*
operator|++
name|x
operator|=
literal|'\0'
expr_stmt|;
comment|/* the difference between the position of the null character and 	 * the position of the first character of the string is the length. 	 */
return|return
name|x
operator|-
name|s
return|;
block|}
end_function

begin_function
name|int
name|set_debug_flags
parameter_list|(
name|flags
parameter_list|)
name|char
modifier|*
name|flags
decl_stmt|;
block|{
comment|/* debug flags are of the form    flag[,flag ...] 	 * 	 * if an error occurs, print a message to stdout and return FALSE. 	 * otherwise return TRUE after setting ERROR_FLAGS. 	 */
if|#
directive|if
operator|!
name|DEBUGGING
name|printf
argument_list|(
literal|"this program was compiled without debugging enabled\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
else|#
directive|else
comment|/* DEBUGGING */
name|char
modifier|*
name|pc
init|=
name|flags
decl_stmt|;
name|DebugFlags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|pc
condition|)
block|{
name|char
modifier|*
modifier|*
name|test
decl_stmt|;
name|int
name|mask
decl_stmt|;
comment|/* try to find debug flag name in our list. 		 */
for|for
control|(
name|test
operator|=
name|DebugFlagNames
operator|,
name|mask
operator|=
literal|1
init|;
operator|*
name|test
operator|&&
name|strcmp_until
argument_list|(
operator|*
name|test
argument_list|,
name|pc
argument_list|,
literal|','
argument_list|)
condition|;
name|test
operator|++
operator|,
name|mask
operator|<<=
literal|1
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|test
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unrecognized debug flag<%s><%s>\n"
argument_list|,
name|flags
argument_list|,
name|pc
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|DebugFlags
operator||=
name|mask
expr_stmt|;
comment|/* skip to the next flag 		 */
while|while
condition|(
operator|*
name|pc
operator|&&
operator|*
name|pc
operator|!=
literal|','
condition|)
name|pc
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|pc
operator|==
literal|','
condition|)
name|pc
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|DebugFlags
condition|)
block|{
name|int
name|flag
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"debug flags enabled:"
argument_list|)
expr_stmt|;
for|for
control|(
name|flag
operator|=
literal|0
init|;
name|DebugFlagNames
index|[
name|flag
index|]
condition|;
name|flag
operator|++
control|)
if|if
condition|(
name|DebugFlags
operator|&
operator|(
literal|1
operator|<<
name|flag
operator|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s"
argument_list|,
name|DebugFlagNames
index|[
name|flag
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
endif|#
directive|endif
comment|/* DEBUGGING */
block|}
end_function

begin_function
name|void
name|set_cron_uid
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|POSIX
argument_list|)
if|if
condition|(
name|seteuid
argument_list|(
name|ROOT_UID
argument_list|)
operator|<
name|OK
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"seteuid"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|setuid
argument_list|(
name|ROOT_UID
argument_list|)
operator|<
name|OK
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"setuid"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|set_cron_cwd
parameter_list|()
block|{
name|struct
name|stat
name|sb
decl_stmt|;
comment|/* first check for CRONDIR ("/var/cron" or some such) 	 */
if|if
condition|(
name|stat
argument_list|(
name|CRONDIR
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
name|OK
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|CRONDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|OK
operator|==
name|mkdir
argument_list|(
name|CRONDIR
argument_list|,
literal|0700
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: created"
argument_list|,
name|CRONDIR
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|CRONDIR
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"%s: mkdir"
argument_list|,
name|CRONDIR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"'%s' is not a directory, bailing out"
argument_list|,
name|CRONDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|CRONDIR
argument_list|)
operator|<
name|OK
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"cannot chdir(%s), bailing out"
argument_list|,
name|CRONDIR
argument_list|)
expr_stmt|;
comment|/* CRONDIR okay (now==CWD), now look at SPOOL_DIR ("tabs" or some such) 	 */
if|if
condition|(
name|stat
argument_list|(
name|SPOOL_DIR
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
name|OK
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|SPOOL_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|OK
operator|==
name|mkdir
argument_list|(
name|SPOOL_DIR
argument_list|,
literal|0700
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: created"
argument_list|,
name|SPOOL_DIR
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|SPOOL_DIR
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"%s: mkdir"
argument_list|,
name|SPOOL_DIR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFDIR
operator|)
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"'%s' is not a directory, bailing out"
argument_list|,
name|SPOOL_DIR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* acquire_daemonlock() - write our PID into /etc/cron.pid, unless  *	another daemon is already running, which we detect here.  *  * note: main() calls us twice; once before forking, once after.  *	we maintain static storage of the file pointer so that we  *	can rewrite our PID into the PIDFILE after the fork.  *  * it would be great if fflush() disassociated the file buffer.  */
end_comment

begin_function
name|void
name|acquire_daemonlock
parameter_list|(
name|closeflag
parameter_list|)
name|int
name|closeflag
decl_stmt|;
block|{
specifier|static
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|closeflag
operator|&&
name|fp
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|char
name|pidfile
index|[
name|MAX_FNAME
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAX_TEMPSTR
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|otherpid
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pidfile
argument_list|,
name|PIDFILE
argument_list|,
name|PIDDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|-
literal|1
operator|==
operator|(
name|fd
operator|=
name|open
argument_list|(
name|pidfile
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0644
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|NULL
operator|==
operator|(
name|fp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"can't open or create %s: %s"
argument_list|,
name|pidfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|log_it
argument_list|(
literal|"CRON"
argument_list|,
name|getpid
argument_list|()
argument_list|,
literal|"DEATH"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|<
name|OK
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|otherpid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"can't lock %s, otherpid may be %d: %s"
argument_list|,
name|pidfile
argument_list|,
name|otherpid
argument_list|,
name|strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|log_it
argument_list|(
literal|"CRON"
argument_list|,
name|getpid
argument_list|()
argument_list|,
literal|"DEATH"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|errx
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|rewind
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|ftell
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* abandon fd and fp even though the file is open. we need to 	 * keep it open and locked, but we don't need the handles elsewhere. 	 */
block|}
end_function

begin_comment
comment|/* get_char(file) : like getc() but increment LineNumber on newlines  */
end_comment

begin_function
name|int
name|get_char
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|getc
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|Set_LineNum
argument_list|(
argument|LineNumber +
literal|1
argument_list|)
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* unget_char(ch, file) : like ungetc but do LineNumber processing  */
end_comment

begin_function
name|void
name|unget_char
parameter_list|(
name|ch
parameter_list|,
name|file
parameter_list|)
name|int
name|ch
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|ungetc
argument_list|(
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|Set_LineNum
argument_list|(
argument|LineNumber -
literal|1
argument_list|)
block|}
end_function

begin_comment
comment|/* get_string(str, max, file, termstr) : like fgets() but  *		(1) has terminator string which should include \n  *		(2) will always leave room for the null  *		(3) uses get_char() so LineNumber will be accurate  *		(4) returns EOF or terminating character, whichever  */
end_comment

begin_function
name|int
name|get_string
parameter_list|(
name|string
parameter_list|,
name|size
parameter_list|,
name|file
parameter_list|,
name|terms
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|size
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|terms
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_char
argument_list|(
name|file
argument_list|)
operator|)
operator|&&
operator|!
name|strchr
argument_list|(
name|terms
argument_list|,
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|size
operator|>
literal|1
condition|)
block|{
operator|*
name|string
operator|++
operator|=
operator|(
name|char
operator|)
name|ch
expr_stmt|;
name|size
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
operator|*
name|string
operator|=
literal|'\0'
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* skip_comments(file) : read past comment (if any)  */
end_comment

begin_function
name|void
name|skip_comments
parameter_list|(
name|file
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_char
argument_list|(
name|file
argument_list|)
operator|)
condition|)
block|{
comment|/* ch is now the first character of a line. 		 */
while|while
condition|(
name|ch
operator|==
literal|' '
operator|||
name|ch
operator|==
literal|'\t'
condition|)
name|ch
operator|=
name|get_char
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
break|break;
comment|/* ch is now the first non-blank character of a line. 		 */
if|if
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
literal|'#'
condition|)
break|break;
comment|/* ch must be a newline or comment as first non-blank 		 * character on a line. 		 */
while|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|EOF
condition|)
name|ch
operator|=
name|get_char
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* ch is now the newline of a line which we're going to 		 * ignore. 		 */
block|}
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
name|unget_char
argument_list|(
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* int in_file(char *string, FILE *file)  *	return TRUE if one of the lines in file matches string exactly,  *	FALSE otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|in_file
parameter_list|(
name|string
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|FILE
modifier|*
name|file
decl_stmt|;
block|{
name|char
name|line
index|[
name|MAX_TEMPSTR
index|]
decl_stmt|;
name|rewind
argument_list|(
name|file
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|MAX_TEMPSTR
argument_list|,
name|file
argument_list|)
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|line
argument_list|,
name|string
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* int allowed(char *username)  *	returns TRUE if (ALLOW_FILE exists and user is listed)  *	or (DENY_FILE exists and user is NOT listed)  *	or (neither file exists but user=="root" so it's okay)  */
end_comment

begin_function
name|int
name|allowed
parameter_list|(
name|username
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|;
block|{
specifier|static
name|int
name|init
init|=
name|FALSE
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|allow
decl_stmt|,
modifier|*
name|deny
decl_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
block|{
name|init
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ALLOW_FILE
argument_list|)
operator|&&
name|defined
argument_list|(
name|DENY_FILE
argument_list|)
name|allow
operator|=
name|fopen
argument_list|(
name|ALLOW_FILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|deny
operator|=
name|fopen
argument_list|(
name|DENY_FILE
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|Debug
argument_list|(
argument|DMISC
argument_list|,
argument|(
literal|"allow/deny enabled, %d/%d\n"
argument|, !!allow, !!deny)
argument_list|)
else|#
directive|else
name|allow
operator|=
name|NULL
expr_stmt|;
name|deny
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|allow
condition|)
return|return
operator|(
name|in_file
argument_list|(
name|username
argument_list|,
name|allow
argument_list|)
operator|)
return|;
if|if
condition|(
name|deny
condition|)
return|return
operator|(
operator|!
name|in_file
argument_list|(
name|username
argument_list|,
name|deny
argument_list|)
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|ALLOW_ONLY_ROOT
argument_list|)
return|return
operator|(
name|strcmp
argument_list|(
name|username
argument_list|,
name|ROOT_USER
argument_list|)
operator|==
literal|0
operator|)
return|;
else|#
directive|else
return|return
name|TRUE
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|log_it
parameter_list|(
name|username
parameter_list|,
name|xpid
parameter_list|,
name|event
parameter_list|,
name|detail
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|;
name|int
name|xpid
decl_stmt|;
name|char
modifier|*
name|event
decl_stmt|;
name|char
modifier|*
name|detail
decl_stmt|;
block|{
name|PID_T
name|pid
init|=
name|xpid
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|TIME_T
name|now
init|=
name|time
argument_list|(
operator|(
name|TIME_T
operator|)
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|tm
modifier|*
name|t
init|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/*LOG_FILE*/
if|#
directive|if
name|defined
argument_list|(
name|SYSLOG
argument_list|)
specifier|static
name|int
name|syslog_open
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
comment|/* we assume that MAX_TEMPSTR will hold the date, time,&punctuation. 	 */
name|msg
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|username
argument_list|)
operator|+
name|strlen
argument_list|(
name|event
argument_list|)
operator|+
name|strlen
argument_list|(
name|detail
argument_list|)
operator|+
name|MAX_TEMPSTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogFD
operator|<
name|OK
condition|)
block|{
name|LogFD
operator|=
name|open
argument_list|(
name|LOG_FILE
argument_list|,
name|O_WRONLY
operator||
name|O_APPEND
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|LogFD
operator|<
name|OK
condition|)
block|{
name|warn
argument_list|(
literal|"can't open log file %s"
argument_list|,
name|LOG_FILE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|LogFD
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* we have to sprintf() it because fprintf() doesn't always write 	 * everything out in one chunk and this has to be atomically appended 	 * to the log file. 	 */
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%s (%02d/%02d-%02d:%02d:%02d-%d) %s (%s)\n"
argument_list|,
name|username
argument_list|,
name|t
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|t
operator|->
name|tm_mday
argument_list|,
name|t
operator|->
name|tm_hour
argument_list|,
name|t
operator|->
name|tm_min
argument_list|,
name|t
operator|->
name|tm_sec
argument_list|,
name|pid
argument_list|,
name|event
argument_list|,
name|detail
argument_list|)
expr_stmt|;
comment|/* we have to run strlen() because sprintf() returns (char*) on old BSD 	 */
if|if
condition|(
name|LogFD
operator|<
name|OK
operator|||
name|write
argument_list|(
name|LogFD
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
operator|<
name|OK
condition|)
block|{
if|if
condition|(
name|LogFD
operator|>=
name|OK
condition|)
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|LOG_FILE
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"can't write to log file"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*LOG_FILE*/
if|#
directive|if
name|defined
argument_list|(
name|SYSLOG
argument_list|)
if|if
condition|(
operator|!
name|syslog_open
condition|)
block|{
comment|/* we don't use LOG_PID since the pid passed to us by 		 * our client may not be our own.  therefore we want to 		 * print the pid ourselves. 		 */
ifdef|#
directive|ifdef
name|LOG_DAEMON
name|openlog
argument_list|(
name|ProgramName
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_CRON
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
name|ProgramName
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|syslog_open
operator|=
name|TRUE
expr_stmt|;
comment|/* assume openlog success */
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"(%s) %s (%s)\n"
argument_list|,
name|username
argument_list|,
name|event
argument_list|,
name|detail
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*SYSLOG*/
if|#
directive|if
name|DEBUGGING
if|if
condition|(
name|DebugFlags
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"log_it: (%s %d) %s (%s)\n"
argument_list|,
name|username
argument_list|,
name|pid
argument_list|,
name|event
argument_list|,
name|detail
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|log_close
parameter_list|()
block|{
if|if
condition|(
name|LogFD
operator|!=
name|ERR
condition|)
block|{
name|close
argument_list|(
name|LogFD
argument_list|)
expr_stmt|;
name|LogFD
operator|=
name|ERR
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* two warnings:  *	(1) this routine is fairly slow  *	(2) it returns a pointer to static storage  */
end_comment

begin_function
name|char
modifier|*
name|first_word
parameter_list|(
name|s
parameter_list|,
name|t
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* string we want the first word of */
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
comment|/* terminators, implicitly including \0 */
block|{
specifier|static
name|char
name|retbuf
index|[
literal|2
index|]
index|[
name|MAX_TEMPSTR
operator|+
literal|1
index|]
decl_stmt|;
comment|/* sure wish C had GC */
specifier|static
name|int
name|retsel
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|rb
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
comment|/* select a return buffer */
name|retsel
operator|=
literal|1
operator|-
name|retsel
expr_stmt|;
name|rb
operator|=
operator|&
name|retbuf
index|[
name|retsel
index|]
index|[
literal|0
index|]
expr_stmt|;
name|rp
operator|=
name|rb
expr_stmt|;
comment|/* skip any leading terminators */
while|while
condition|(
operator|*
name|s
operator|&&
operator|(
name|NULL
operator|!=
name|strchr
argument_list|(
name|t
argument_list|,
operator|*
name|s
argument_list|)
operator|)
condition|)
block|{
name|s
operator|++
expr_stmt|;
block|}
comment|/* copy until next terminator or full buffer */
while|while
condition|(
operator|*
name|s
operator|&&
operator|(
name|NULL
operator|==
name|strchr
argument_list|(
name|t
argument_list|,
operator|*
name|s
argument_list|)
operator|)
operator|&&
operator|(
name|rp
operator|<
operator|&
name|rb
index|[
name|MAX_TEMPSTR
index|]
operator|)
condition|)
block|{
operator|*
name|rp
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
comment|/* finish the return-string and return it */
operator|*
name|rp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rb
return|;
block|}
end_function

begin_comment
comment|/* warning:  *	heavily ascii-dependent.  */
end_comment

begin_function
name|void
name|mkprint
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|dst
decl_stmt|;
specifier|register
name|unsigned
name|char
modifier|*
name|src
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
specifier|register
name|unsigned
name|char
name|ch
init|=
operator|*
name|src
operator|++
decl_stmt|;
if|if
condition|(
name|ch
operator|<
literal|' '
condition|)
block|{
comment|/* control character */
operator|*
name|dst
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
name|ch
operator|+
literal|'@'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|<
literal|0177
condition|)
block|{
comment|/* printable */
operator|*
name|dst
operator|++
operator|=
name|ch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|0177
condition|)
block|{
comment|/* delete/rubout */
operator|*
name|dst
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
literal|'?'
expr_stmt|;
block|}
else|else
block|{
comment|/* parity character */
name|sprintf
argument_list|(
name|dst
argument_list|,
literal|"\\%03o"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|4
expr_stmt|;
block|}
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* warning:  *	returns a pointer to malloc'd storage, you must call free yourself.  */
end_comment

begin_function
name|char
modifier|*
name|mkprints
parameter_list|(
name|src
parameter_list|,
name|len
parameter_list|)
specifier|register
name|unsigned
name|char
modifier|*
name|src
decl_stmt|;
specifier|register
name|unsigned
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|dst
init|=
name|malloc
argument_list|(
name|len
operator|*
literal|4
operator|+
literal|1
argument_list|)
decl_stmt|;
name|mkprint
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAIL_DATE
end_ifdef

begin_comment
comment|/* Sat, 27 Feb 93 11:44:51 CST  * 123456789012345678901234567  */
end_comment

begin_function
name|char
modifier|*
name|arpadate
parameter_list|(
name|clock
parameter_list|)
name|time_t
modifier|*
name|clock
decl_stmt|;
block|{
name|time_t
name|t
init|=
name|clock
condition|?
operator|*
name|clock
else|:
name|time
argument_list|(
literal|0L
argument_list|)
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
init|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
decl_stmt|;
specifier|static
name|char
name|ret
index|[
literal|30
index|]
decl_stmt|;
comment|/* zone name might be>3 chars */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ret
argument_list|,
literal|"%s, %2d %s %2d %02d:%02d:%02d %s"
argument_list|,
name|DowNames
index|[
name|tm
operator|->
name|tm_wday
index|]
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|MonthNames
index|[
name|tm
operator|->
name|tm_mon
index|]
argument_list|,
name|tm
operator|->
name|tm_year
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|,
name|tm
operator|->
name|tm_sec
argument_list|,
name|TZONE
argument_list|(
operator|*
name|tm
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*MAIL_DATE*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SAVED_UIDS
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|save_euid
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|swap_uids
parameter_list|()
block|{
name|save_euid
operator|=
name|geteuid
argument_list|()
expr_stmt|;
return|return
name|seteuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|swap_uids_back
parameter_list|()
block|{
return|return
name|seteuid
argument_list|(
name|save_euid
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*HAVE_SAVED_UIDS*/
end_comment

begin_function
name|int
name|swap_uids
parameter_list|()
block|{
return|return
name|setreuid
argument_list|(
name|geteuid
argument_list|()
argument_list|,
name|getuid
argument_list|()
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|swap_uids_back
parameter_list|()
block|{
return|return
name|swap_uids
argument_list|()
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*HAVE_SAVED_UIDS*/
end_comment

end_unit

