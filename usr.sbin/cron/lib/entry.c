begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 1988,1990,1993,1994 by Paul Vixie  * All rights reserved  *  * Distribute freely, except: don't remove my name from the source or  * documentation (don't take credit for my work), mark your changes (don't  * get me blamed for your possible bugs), don't alter or remove this  * notice.  May be sold if buildable source is provided to buyer.  No  * warrantee of any kind, express or implied, is included with this  * software; use at your own risk, responsibility for damages (if any) to  * anyone resulting from the use of this software rests entirely with the  * user.  *  * Send bug reports, bug fixes, enhancements, requests, flames, etc., and  * I'll try to keep a version up to date.  I can be reached as follows:  * Paul Vixie<paul@vix.com>          uunet!decwrl!vixie!paul  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LINT
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: entry.c,v 1.2 1995/04/12 19:04:26 ache Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* vix 26jan87 [RCS'd; rest of log is in RCS file]  * vix 01jan87 [added line-level error recovery]  * vix 31dec86 [added /step to the from-to range, per bob@acornrc]  * vix 30dec86 [written]  */
end_comment

begin_include
include|#
directive|include
file|"cron.h"
end_include

begin_typedef
typedef|typedef
enum|enum
name|ecode
block|{
name|e_none
block|,
name|e_minute
block|,
name|e_hour
block|,
name|e_dom
block|,
name|e_month
block|,
name|e_dow
block|,
name|e_cmd
block|,
name|e_timespec
block|,
name|e_username
block|}
name|ecode_e
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
name|get_list
name|__P
argument_list|(
operator|(
name|bitstr_t
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
index|[]
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|,
name|get_range
name|__P
argument_list|(
operator|(
name|bitstr_t
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
index|[]
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|,
name|get_number
name|__P
argument_list|(
operator|(
name|int
operator|*
operator|,
name|int
operator|,
name|char
operator|*
index|[]
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_element
name|__P
argument_list|(
operator|(
name|bitstr_t
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ecodes
index|[]
init|=
block|{
literal|"no error"
block|,
literal|"bad minute"
block|,
literal|"bad hour"
block|,
literal|"bad day-of-month"
block|,
literal|"bad month"
block|,
literal|"bad day-of-week"
block|,
literal|"bad command"
block|,
literal|"bad time specifier"
block|,
literal|"bad username"
block|, 	}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|free_entry
parameter_list|(
name|e
parameter_list|)
name|entry
modifier|*
name|e
decl_stmt|;
block|{
name|free
argument_list|(
name|e
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|env_free
argument_list|(
name|e
operator|->
name|envp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* return NULL if eof or syntax error occurs;  * otherwise return a pointer to a new entry.  */
end_comment

begin_decl_stmt
name|entry
modifier|*
name|load_entry
argument_list|(
name|file
argument_list|,
name|error_func
argument_list|,
name|pw
argument_list|,
name|envp
argument_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|error_func
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* this function reads one crontab entry -- the next -- from a file. 	 * it skips any leading blank lines, ignores comments, and returns 	 * EOF if for any reason the entry can't be read and parsed. 	 * 	 * the entry is also parsed here. 	 * 	 * syntax: 	 *   user crontab: 	 *	minutes hours doms months dows cmd\n 	 *   system crontab (/etc/crontab): 	 *	minutes hours doms months dows USERNAME cmd\n 	 */
name|ecode_e
name|ecode
init|=
name|e_none
decl_stmt|;
name|entry
modifier|*
name|e
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|char
name|cmd
index|[
name|MAX_COMMAND
index|]
decl_stmt|;
name|char
name|envstr
index|[
name|MAX_ENVSTR
index|]
decl_stmt|;
name|Debug
argument_list|(
argument|DPARS
argument_list|,
argument|(
literal|"load_entry()...about to eat comments\n"
argument|)
argument_list|)
name|skip_comments
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|ch
operator|=
name|get_char
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|NULL
return|;
comment|/* ch is now the first useful character of a useful line. 	 * it may be an @special or it may be the first character 	 * of a list of minutes. 	 */
name|e
operator|=
operator|(
name|entry
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|entry
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'@'
condition|)
block|{
comment|/* all of these should be flagged and load-limited; i.e., 		 * instead of @hourly meaning "0 * * * *" it should mean 		 * "close to the front of every hour but not 'til the 		 * system load is low".  Problems are: how do you know 		 * what "low" means? (save me from /etc/cron.conf!) and: 		 * how to guarantee low variance (how low is low?), which 		 * means how to we run roughly every hour -- seems like 		 * we need to keep a history or let the first hour set 		 * the schedule, which means we aren't load-limited 		 * anymore.  too much for my overloaded brain. (vix, jan90) 		 * HINT 		 */
name|ch
operator|=
name|get_string
argument_list|(
name|cmd
argument_list|,
name|MAX_COMMAND
argument_list|,
name|file
argument_list|,
literal|" \t\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"reboot"
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|e
operator|->
name|flags
operator||=
name|WHEN_REBOOT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"yearly"
argument_list|,
name|cmd
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"annually"
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|bit_set
argument_list|(
name|e
operator|->
name|minute
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|e
operator|->
name|hour
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|e
operator|->
name|dom
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|e
operator|->
name|month
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|e
operator|->
name|dow
argument_list|,
literal|0
argument_list|,
operator|(
name|LAST_DOW
operator|-
name|FIRST_DOW
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"monthly"
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|bit_set
argument_list|(
name|e
operator|->
name|minute
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|e
operator|->
name|hour
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|e
operator|->
name|dom
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|e
operator|->
name|month
argument_list|,
literal|0
argument_list|,
operator|(
name|LAST_MONTH
operator|-
name|FIRST_MONTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|e
operator|->
name|dow
argument_list|,
literal|0
argument_list|,
operator|(
name|LAST_DOW
operator|-
name|FIRST_DOW
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"weekly"
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|bit_set
argument_list|(
name|e
operator|->
name|minute
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|e
operator|->
name|hour
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|e
operator|->
name|dom
argument_list|,
literal|0
argument_list|,
operator|(
name|LAST_DOM
operator|-
name|FIRST_DOM
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|e
operator|->
name|month
argument_list|,
literal|0
argument_list|,
operator|(
name|LAST_MONTH
operator|-
name|FIRST_MONTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|e
operator|->
name|dow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"daily"
argument_list|,
name|cmd
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
literal|"midnight"
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|bit_set
argument_list|(
name|e
operator|->
name|minute
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|e
operator|->
name|hour
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|e
operator|->
name|dom
argument_list|,
literal|0
argument_list|,
operator|(
name|LAST_DOM
operator|-
name|FIRST_DOM
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|e
operator|->
name|month
argument_list|,
literal|0
argument_list|,
operator|(
name|LAST_MONTH
operator|-
name|FIRST_MONTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|e
operator|->
name|dow
argument_list|,
literal|0
argument_list|,
operator|(
name|LAST_DOW
operator|-
name|FIRST_DOW
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
literal|"hourly"
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|bit_set
argument_list|(
name|e
operator|->
name|minute
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|e
operator|->
name|hour
argument_list|,
operator|(
name|LAST_HOUR
operator|-
name|FIRST_HOUR
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|e
operator|->
name|dom
argument_list|,
literal|0
argument_list|,
operator|(
name|LAST_DOM
operator|-
name|FIRST_DOM
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|e
operator|->
name|month
argument_list|,
literal|0
argument_list|,
operator|(
name|LAST_MONTH
operator|-
name|FIRST_MONTH
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bit_nset
argument_list|(
name|e
operator|->
name|dow
argument_list|,
literal|0
argument_list|,
operator|(
name|LAST_DOW
operator|-
name|FIRST_DOW
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ecode
operator|=
name|e_timespec
expr_stmt|;
goto|goto
name|eof
goto|;
block|}
block|}
else|else
block|{
name|Debug
argument_list|(
argument|DPARS
argument_list|,
argument|(
literal|"load_entry()...about to parse numerics\n"
argument|)
argument_list|)
name|ch
operator|=
name|get_list
argument_list|(
name|e
operator|->
name|minute
argument_list|,
name|FIRST_MINUTE
argument_list|,
name|LAST_MINUTE
argument_list|,
name|PPC_NULL
argument_list|,
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|ecode
operator|=
name|e_minute
expr_stmt|;
goto|goto
name|eof
goto|;
block|}
comment|/* hours 		 */
name|ch
operator|=
name|get_list
argument_list|(
name|e
operator|->
name|hour
argument_list|,
name|FIRST_HOUR
argument_list|,
name|LAST_HOUR
argument_list|,
name|PPC_NULL
argument_list|,
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|ecode
operator|=
name|e_hour
expr_stmt|;
goto|goto
name|eof
goto|;
block|}
comment|/* DOM (days of month) 		 */
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
name|e
operator|->
name|flags
operator||=
name|DOM_STAR
expr_stmt|;
name|ch
operator|=
name|get_list
argument_list|(
name|e
operator|->
name|dom
argument_list|,
name|FIRST_DOM
argument_list|,
name|LAST_DOM
argument_list|,
name|PPC_NULL
argument_list|,
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|ecode
operator|=
name|e_dom
expr_stmt|;
goto|goto
name|eof
goto|;
block|}
comment|/* month 		 */
name|ch
operator|=
name|get_list
argument_list|(
name|e
operator|->
name|month
argument_list|,
name|FIRST_MONTH
argument_list|,
name|LAST_MONTH
argument_list|,
name|MonthNames
argument_list|,
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|ecode
operator|=
name|e_month
expr_stmt|;
goto|goto
name|eof
goto|;
block|}
comment|/* DOW (days of week) 		 */
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
name|e
operator|->
name|flags
operator||=
name|DOW_STAR
expr_stmt|;
name|ch
operator|=
name|get_list
argument_list|(
name|e
operator|->
name|dow
argument_list|,
name|FIRST_DOW
argument_list|,
name|LAST_DOW
argument_list|,
name|DowNames
argument_list|,
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|ecode
operator|=
name|e_dow
expr_stmt|;
goto|goto
name|eof
goto|;
block|}
block|}
comment|/* make sundays equivilent */
if|if
condition|(
name|bit_test
argument_list|(
name|e
operator|->
name|dow
argument_list|,
literal|0
argument_list|)
operator|||
name|bit_test
argument_list|(
name|e
operator|->
name|dow
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|bit_set
argument_list|(
name|e
operator|->
name|dow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bit_set
argument_list|(
name|e
operator|->
name|dow
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
comment|/* ch is the first character of a command, or a username */
name|unget_char
argument_list|(
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pw
condition|)
block|{
name|char
modifier|*
name|username
init|=
name|cmd
decl_stmt|;
comment|/* temp buffer */
name|Debug
argument_list|(
argument|DPARS
argument_list|,
argument|(
literal|"load_entry()...about to parse username\n"
argument|)
argument_list|)
name|ch
operator|=
name|get_string
argument_list|(
name|username
argument_list|,
name|MAX_COMMAND
argument_list|,
name|file
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|Debug
argument_list|(
argument|DPARS
argument_list|,
argument|(
literal|"load_entry()...got %s\n"
argument|,username)
argument_list|)
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|ecode
operator|=
name|e_cmd
expr_stmt|;
goto|goto
name|eof
goto|;
block|}
name|pw
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
name|ecode
operator|=
name|e_username
expr_stmt|;
goto|goto
name|eof
goto|;
block|}
name|Debug
argument_list|(
argument|DPARS
argument_list|,
argument|(
literal|"load_entry()...uid %d, gid %d\n"
argument|,e->uid,e->gid)
argument_list|)
block|}
name|e
operator|->
name|uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
name|e
operator|->
name|gid
operator|=
name|pw
operator|->
name|pw_gid
expr_stmt|;
comment|/* copy and fix up environment.  some variables are just defaults and 	 * others are overrides. 	 */
name|e
operator|->
name|envp
operator|=
name|env_copy
argument_list|(
name|envp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|env_get
argument_list|(
literal|"SHELL"
argument_list|,
name|e
operator|->
name|envp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|envstr
argument_list|,
literal|"SHELL=%s"
argument_list|,
name|_PATH_BSHELL
argument_list|)
expr_stmt|;
name|e
operator|->
name|envp
operator|=
name|env_set
argument_list|(
name|e
operator|->
name|envp
argument_list|,
name|envstr
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|envstr
argument_list|,
literal|"HOME=%s"
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|e
operator|->
name|envp
operator|=
name|env_set
argument_list|(
name|e
operator|->
name|envp
argument_list|,
name|envstr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|env_get
argument_list|(
literal|"PATH"
argument_list|,
name|e
operator|->
name|envp
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|envstr
argument_list|,
literal|"PATH=%s"
argument_list|,
name|_PATH_DEFPATH
argument_list|)
expr_stmt|;
name|e
operator|->
name|envp
operator|=
name|env_set
argument_list|(
name|e
operator|->
name|envp
argument_list|,
name|envstr
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|envstr
argument_list|,
literal|"%s=%s"
argument_list|,
literal|"LOGNAME"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|e
operator|->
name|envp
operator|=
name|env_set
argument_list|(
name|e
operator|->
name|envp
argument_list|,
name|envstr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
name|sprintf
argument_list|(
name|envstr
argument_list|,
literal|"%s=%s"
argument_list|,
literal|"USER"
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|e
operator|->
name|envp
operator|=
name|env_set
argument_list|(
name|e
operator|->
name|envp
argument_list|,
name|envstr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Debug
argument_list|(
argument|DPARS
argument_list|,
argument|(
literal|"load_entry()...about to parse command\n"
argument|)
argument_list|)
comment|/* Everything up to the next \n or EOF is part of the command... 	 * too bad we don't know in advance how long it will be, since we 	 * need to malloc a string for it... so, we limit it to MAX_COMMAND. 	 * XXX - should use realloc(). 	 */
name|ch
operator|=
name|get_string
argument_list|(
name|cmd
argument_list|,
name|MAX_COMMAND
argument_list|,
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* a file without a \n before the EOF is rude, so we'll complain... 	 */
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|ecode
operator|=
name|e_cmd
expr_stmt|;
goto|goto
name|eof
goto|;
block|}
comment|/* got the command in the 'cmd' string; save it in *e. 	 */
name|e
operator|->
name|cmd
operator|=
name|strdup
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|Debug
argument_list|(
argument|DPARS
argument_list|,
argument|(
literal|"load_entry()...returning successfully\n"
argument|)
argument_list|)
comment|/* success, fini, return pointer to the entry we just created... 	 */
return|return
name|e
return|;
name|eof
label|:
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecode
operator|!=
name|e_none
operator|&&
name|error_func
condition|)
call|(
modifier|*
name|error_func
call|)
argument_list|(
name|ecodes
index|[
operator|(
name|int
operator|)
name|ecode
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
name|ch
operator|=
name|get_char
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_block

begin_function
specifier|static
name|char
name|get_list
parameter_list|(
name|bits
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|names
parameter_list|,
name|ch
parameter_list|,
name|file
parameter_list|)
name|bitstr_t
modifier|*
name|bits
decl_stmt|;
comment|/* one bit per flag, default=FALSE */
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
comment|/* bounds, impl. offset for bitstr */
name|char
modifier|*
name|names
index|[]
decl_stmt|;
comment|/* NULL or *[] of names for these elements */
name|int
name|ch
decl_stmt|;
comment|/* current character being processed */
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* file being read */
block|{
specifier|register
name|int
name|done
decl_stmt|;
comment|/* we know that we point to a non-blank character here; 	 * must do a Skip_Blanks before we exit, so that the 	 * next call (or the code that picks up the cmd) can 	 * assume the same thing. 	 */
name|Debug
argument_list|(
argument|DPARS|DEXT
argument_list|,
argument|(
literal|"get_list()...entered\n"
argument|)
argument_list|)
comment|/* list = range {"," range} 	 */
comment|/* clear the bit string, since the default is 'off'. 	 */
name|bit_nclear
argument_list|(
name|bits
argument_list|,
literal|0
argument_list|,
operator|(
name|high
operator|-
name|low
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* process all ranges 	 */
name|done
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|ch
operator|=
name|get_range
argument_list|(
name|bits
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
name|names
argument_list|,
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|','
condition|)
name|ch
operator|=
name|get_char
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* exiting.  skip to some blanks, then skip over the blanks. 	 */
name|Skip_Nonblanks
argument_list|(
argument|ch
argument_list|,
argument|file
argument_list|)
name|Skip_Blanks
argument_list|(
argument|ch
argument_list|,
argument|file
argument_list|)
name|Debug
argument_list|(
argument|DPARS|DEXT
argument_list|,
argument|(
literal|"get_list()...exiting w/ %02x\n"
argument|, ch)
argument_list|)
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|get_range
parameter_list|(
name|bits
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|names
parameter_list|,
name|ch
parameter_list|,
name|file
parameter_list|)
name|bitstr_t
modifier|*
name|bits
decl_stmt|;
comment|/* one bit per flag, default=FALSE */
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
comment|/* bounds, impl. offset for bitstr */
name|char
modifier|*
name|names
index|[]
decl_stmt|;
comment|/* NULL or names of elements */
name|int
name|ch
decl_stmt|;
comment|/* current character being processed */
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* file being read */
block|{
comment|/* range = number | number "-" number [ "/" number ] 	 */
specifier|register
name|int
name|i
decl_stmt|;
specifier|auto
name|int
name|num1
decl_stmt|,
name|num2
decl_stmt|,
name|num3
decl_stmt|;
name|Debug
argument_list|(
argument|DPARS|DEXT
argument_list|,
argument|(
literal|"get_range()...entering, exit won't show\n"
argument|)
argument_list|)
if|if
condition|(
name|ch
operator|==
literal|'*'
condition|)
block|{
comment|/* '*' means "first-last" but can still be modified by /step 		 */
name|num1
operator|=
name|low
expr_stmt|;
name|num2
operator|=
name|high
expr_stmt|;
name|ch
operator|=
name|get_char
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
block|}
else|else
block|{
if|if
condition|(
name|EOF
operator|==
operator|(
name|ch
operator|=
name|get_number
argument_list|(
operator|&
name|num1
argument_list|,
name|low
argument_list|,
name|names
argument_list|,
name|ch
argument_list|,
name|file
argument_list|)
operator|)
condition|)
return|return
name|EOF
return|;
if|if
condition|(
name|ch
operator|!=
literal|'-'
condition|)
block|{
comment|/* not a range, it's a single number. 			 */
if|if
condition|(
name|EOF
operator|==
name|set_element
argument_list|(
name|bits
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
name|num1
argument_list|)
condition|)
return|return
name|EOF
return|;
return|return
name|ch
return|;
block|}
else|else
block|{
comment|/* eat the dash 			 */
name|ch
operator|=
name|get_char
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
comment|/* get the number following the dash 			 */
name|ch
operator|=
name|get_number
argument_list|(
operator|&
name|num2
argument_list|,
name|low
argument_list|,
name|names
argument_list|,
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
block|}
block|}
comment|/* check for step size 	 */
if|if
condition|(
name|ch
operator|==
literal|'/'
condition|)
block|{
comment|/* eat the slash 		 */
name|ch
operator|=
name|get_char
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
comment|/* get the step size -- note: we don't pass the 		 * names here, because the number is not an 		 * element id, it's a step size.  'low' is 		 * sent as a 0 since there is no offset either. 		 */
name|ch
operator|=
name|get_number
argument_list|(
operator|&
name|num3
argument_list|,
literal|0
argument_list|,
name|PPC_NULL
argument_list|,
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
block|}
else|else
block|{
comment|/* no step.  default==1. 		 */
name|num3
operator|=
literal|1
expr_stmt|;
block|}
comment|/* range. set all elements from num1 to num2, stepping 	 * by num3.  (the step is a downward-compatible extension 	 * proposed conceptually by bob@acornrc, syntactically 	 * designed then implmented by paul vixie). 	 */
for|for
control|(
name|i
operator|=
name|num1
init|;
name|i
operator|<=
name|num2
condition|;
name|i
operator|+=
name|num3
control|)
if|if
condition|(
name|EOF
operator|==
name|set_element
argument_list|(
name|bits
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
name|i
argument_list|)
condition|)
return|return
name|EOF
return|;
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|get_number
parameter_list|(
name|numptr
parameter_list|,
name|low
parameter_list|,
name|names
parameter_list|,
name|ch
parameter_list|,
name|file
parameter_list|)
name|int
modifier|*
name|numptr
decl_stmt|;
comment|/* where does the result go? */
name|int
name|low
decl_stmt|;
comment|/* offset applied to result if symbolic enum used */
name|char
modifier|*
name|names
index|[]
decl_stmt|;
comment|/* symbolic names, if any, for enums */
name|int
name|ch
decl_stmt|;
comment|/* current character */
name|FILE
modifier|*
name|file
decl_stmt|;
comment|/* source */
block|{
name|char
name|temp
index|[
name|MAX_TEMPSTR
index|]
decl_stmt|,
modifier|*
name|pc
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|,
name|all_digits
decl_stmt|;
comment|/* collect alphanumerics into our fixed-size temp array 	 */
name|pc
operator|=
name|temp
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|all_digits
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|len
operator|>=
name|MAX_TEMPSTR
condition|)
return|return
name|EOF
return|;
operator|*
name|pc
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|all_digits
operator|=
name|FALSE
expr_stmt|;
name|ch
operator|=
name|get_char
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
operator|*
name|pc
operator|=
literal|'\0'
expr_stmt|;
comment|/* try to find the name in the name list 	 */
if|if
condition|(
name|names
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|names
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|Debug
argument_list|(
argument|DPARS|DEXT
argument_list|,
argument|(
literal|"get_num, compare(%s,%s)\n"
argument|, names[i], temp)
argument_list|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|names
index|[
name|i
index|]
argument_list|,
name|temp
argument_list|)
condition|)
block|{
operator|*
name|numptr
operator|=
name|i
operator|+
name|low
expr_stmt|;
return|return
name|ch
return|;
block|}
block|}
block|}
comment|/* no name list specified, or there is one and our string isn't 	 * in it.  either way: if it's all digits, use its magnitude. 	 * otherwise, it's an error. 	 */
if|if
condition|(
name|all_digits
condition|)
block|{
operator|*
name|numptr
operator|=
name|atoi
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|ch
return|;
block|}
return|return
name|EOF
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_element
parameter_list|(
name|bits
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|,
name|number
parameter_list|)
name|bitstr_t
modifier|*
name|bits
decl_stmt|;
comment|/* one bit per flag, default=FALSE */
name|int
name|low
decl_stmt|;
name|int
name|high
decl_stmt|;
name|int
name|number
decl_stmt|;
block|{
name|Debug
argument_list|(
argument|DPARS|DEXT
argument_list|,
argument|(
literal|"set_element(?,%d,%d,%d)\n"
argument|, low, high, number)
argument_list|)
if|if
condition|(
name|number
operator|<
name|low
operator|||
name|number
operator|>
name|high
condition|)
return|return
name|EOF
return|;
name|bit_set
argument_list|(
name|bits
argument_list|,
operator|(
name|number
operator|-
name|low
operator|)
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

end_unit

