begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright 1988,1990,1993,1994 by Paul Vixie  * All rights reserved  *  * Distribute freely, except: don't remove my name from the source or  * documentation (don't take credit for my work), mark your changes (don't  * get me blamed for your possible bugs), don't alter or remove this  * notice.  May be sold if buildable source is provided to buyer.  No  * warrantee of any kind, express or implied, is included with this  * software; use at your own risk, responsibility for damages (if any) to  * anyone resulting from the use of this software rests entirely with the  * user.  *  * Send bug reports, bug fixes, enhancements, requests, flames, etc., and  * I'll try to keep a version up to date.  I can be reached as follows:  * Paul Vixie<paul@vix.com>          uunet!decwrl!vixie!paul  * From Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|LINT
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* crontab - install and manage per-user crontab files  * vix 02may87 [RCS has the rest of the log]  * vix 26jan87 [original]  */
end_comment

begin_define
define|#
directive|define
name|MAIN_PROGRAM
end_define

begin_include
include|#
directive|include
file|"cron.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_UTIMES
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|POSIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NHEADER_LINES
value|3
end_define

begin_enum
enum|enum
name|opt_t
block|{
name|opt_unknown
block|,
name|opt_list
block|,
name|opt_delete
block|,
name|opt_edit
block|,
name|opt_replace
block|}
enum|;
end_enum

begin_if
if|#
directive|if
name|DEBUGGING
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|Options
index|[]
init|=
block|{
literal|"???"
block|,
literal|"list"
block|,
literal|"delete"
block|,
literal|"edit"
block|,
literal|"replace"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|PID_T
name|Pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|User
index|[
name|MAX_UNAME
index|]
decl_stmt|,
name|RealUser
index|[
name|MAX_UNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|Filename
index|[
name|MAX_FNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|NewCrontab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|CheckErrorCount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|enum
name|opt_t
name|Option
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|list_cmd
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|delete_cmd
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|edit_cmd
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|poke_daemon
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|check_error
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|parse_args
name|__P
argument_list|(
operator|(
name|int
name|c
operator|,
name|char
operator|*
name|v
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|replace_cmd
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"crontab: usage error: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n"
argument_list|,
literal|"usage: crontab [-u user] file"
argument_list|,
literal|"       crontab [-u user] { -e | -l | -r }"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|exitstatus
decl_stmt|;
name|Pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|ProgramName
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|POSIX
argument_list|)
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
name|setlinebuf
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|parse_args
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* sets many globals, opens a file */
name|set_cron_uid
argument_list|()
expr_stmt|;
name|set_cron_cwd
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|allowed
argument_list|(
name|User
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"you (%s) are not allowed to use this program"
argument_list|,
name|User
argument_list|)
expr_stmt|;
name|log_it
argument_list|(
name|RealUser
argument_list|,
name|Pid
argument_list|,
literal|"AUTH"
argument_list|,
literal|"crontab command not allowed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
name|exitstatus
operator|=
name|OK_EXIT
expr_stmt|;
switch|switch
condition|(
name|Option
condition|)
block|{
case|case
name|opt_list
case|:
name|list_cmd
argument_list|()
expr_stmt|;
break|break;
case|case
name|opt_delete
case|:
name|delete_cmd
argument_list|()
expr_stmt|;
break|break;
case|case
name|opt_edit
case|:
name|edit_cmd
argument_list|()
expr_stmt|;
break|break;
case|case
name|opt_replace
case|:
if|if
condition|(
name|replace_cmd
argument_list|()
operator|<
literal|0
condition|)
name|exitstatus
operator|=
name|ERROR_EXIT
expr_stmt|;
break|break;
case|case
name|opt_unknown
case|:
break|break;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
specifier|static
name|void
name|parse_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|argch
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"your UID isn't in the passwd file, bailing out"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|User
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
operator|(
sizeof|sizeof
name|User
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|User
index|[
operator|(
sizeof|sizeof
name|User
operator|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|RealUser
argument_list|,
name|User
argument_list|)
expr_stmt|;
name|Filename
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|Option
operator|=
name|opt_unknown
expr_stmt|;
while|while
condition|(
operator|(
name|argch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"u:lerx:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|argch
condition|)
block|{
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|set_debug_flags
argument_list|(
name|optarg
argument_list|)
condition|)
name|usage
argument_list|(
literal|"bad debug option"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|getuid
argument_list|()
operator|!=
name|ROOT_UID
condition|)
name|errx
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"must be privileged to use -u"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|optarg
argument_list|)
operator|)
condition|)
name|errx
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"user `%s' unknown"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|User
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
operator|(
sizeof|sizeof
name|User
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|User
index|[
operator|(
sizeof|sizeof
name|User
operator|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|Option
operator|!=
name|opt_unknown
condition|)
name|usage
argument_list|(
literal|"only one operation permitted"
argument_list|)
expr_stmt|;
name|Option
operator|=
name|opt_list
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|Option
operator|!=
name|opt_unknown
condition|)
name|usage
argument_list|(
literal|"only one operation permitted"
argument_list|)
expr_stmt|;
name|Option
operator|=
name|opt_delete
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|Option
operator|!=
name|opt_unknown
condition|)
name|usage
argument_list|(
literal|"only one operation permitted"
argument_list|)
expr_stmt|;
name|Option
operator|=
name|opt_edit
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
literal|"unrecognized option"
argument_list|)
expr_stmt|;
block|}
block|}
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|Option
operator|!=
name|opt_unknown
condition|)
block|{
if|if
condition|(
name|argv
index|[
name|optind
index|]
operator|!=
name|NULL
condition|)
block|{
name|usage
argument_list|(
literal|"no arguments permitted after this option"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|argv
index|[
name|optind
index|]
operator|!=
name|NULL
condition|)
block|{
name|Option
operator|=
name|opt_replace
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|Filename
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
operator|(
sizeof|sizeof
name|Filename
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Filename
index|[
operator|(
sizeof|sizeof
name|Filename
operator|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|(
literal|"file name must be specified for replace"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Option
operator|==
name|opt_replace
condition|)
block|{
comment|/* we have to open the file here because we're going to 		 * chdir(2) into /var/cron before we get around to 		 * reading the file. 		 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|Filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|NewCrontab
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
comment|/* relinquish the setuid status of the binary during 			 * the open, lest nonroot users read files they should 			 * not be able to read.  we can't use access() here 			 * since there's a race condition.  thanks go out to 			 * Arnt Gulbrandsen<agulbra@pvv.unit.no> for spotting 			 * the race. 			 */
if|if
condition|(
name|swap_uids
argument_list|()
operator|<
name|OK
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"swapping uids"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|NewCrontab
operator|=
name|fopen
argument_list|(
name|Filename
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"%s"
argument_list|,
name|Filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_uids
argument_list|()
operator|<
name|OK
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"swapping uids back"
argument_list|)
expr_stmt|;
block|}
block|}
name|Debug
argument_list|(
argument|DMISC
argument_list|,
argument|(
literal|"user=%s, file=%s, option=%s\n"
argument|, 		      User, Filename, Options[(int)Option])
argument_list|)
block|}
end_function

begin_function
specifier|static
name|void
name|list_cmd
parameter_list|()
block|{
name|char
name|n
index|[
name|MAX_FNAME
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|x
decl_stmt|;
name|log_it
argument_list|(
name|RealUser
argument_list|,
name|Pid
argument_list|,
literal|"LIST"
argument_list|,
name|User
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|n
argument_list|,
name|CRON_TAB
argument_list|(
name|User
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|n
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|errx
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"no crontab for %s"
argument_list|,
name|User
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"%s"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* file is open. copy to stdout, close. 	 */
name|Set_LineNum
argument_list|(
literal|1
argument_list|)
comment|/* ignore the top few comments since we probably put them there. 	 */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NHEADER_LINES
condition|;
name|x
operator|++
control|)
block|{
name|ch
operator|=
name|get_char
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|EOF
operator|==
name|ch
condition|)
break|break;
if|if
condition|(
literal|'#'
operator|!=
name|ch
condition|)
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_char
argument_list|(
name|f
argument_list|)
operator|)
condition|)
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|EOF
operator|==
name|ch
condition|)
break|break;
block|}
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_char
argument_list|(
name|f
argument_list|)
operator|)
condition|)
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_cmd
parameter_list|()
block|{
name|char
name|n
index|[
name|MAX_FNAME
index|]
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|first
decl_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|STDIN_FILENO
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"remove crontab for %s? "
argument_list|,
name|User
argument_list|)
expr_stmt|;
name|first
operator|=
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|EOF
condition|)
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|first
operator|!=
literal|'y'
operator|&&
name|first
operator|!=
literal|'Y'
condition|)
return|return;
block|}
name|log_it
argument_list|(
name|RealUser
argument_list|,
name|Pid
argument_list|,
literal|"DELETE"
argument_list|,
name|User
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|n
argument_list|,
name|CRON_TAB
argument_list|(
name|User
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|n
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|errx
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"no crontab for %s"
argument_list|,
name|User
argument_list|)
expr_stmt|;
else|else
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"%s"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|poke_daemon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_error
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|CheckErrorCount
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"%s\":%d: %s\n"
argument_list|,
name|Filename
argument_list|,
name|LineNumber
operator|-
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|edit_cmd
parameter_list|()
block|{
name|char
name|n
index|[
name|MAX_FNAME
index|]
decl_stmt|,
name|q
index|[
name|MAX_TEMPSTR
index|]
decl_stmt|,
modifier|*
name|editor
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|t
decl_stmt|,
name|x
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|,
name|fsbuf
decl_stmt|;
name|time_t
name|mtime
decl_stmt|;
name|WAIT_T
name|waiter
decl_stmt|;
name|PID_T
name|pid
decl_stmt|,
name|xpid
decl_stmt|;
name|mode_t
name|um
decl_stmt|;
name|log_it
argument_list|(
name|RealUser
argument_list|,
name|Pid
argument_list|,
literal|"BEGIN EDIT"
argument_list|,
name|User
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|n
argument_list|,
name|CRON_TAB
argument_list|(
name|User
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|n
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"%s"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|warnx
argument_list|(
literal|"no crontab for %s - using an empty one"
argument_list|,
name|User
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|_PATH_DEVNULL
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
name|_PATH_DEVNULL
argument_list|)
expr_stmt|;
block|}
name|um
operator|=
name|umask
argument_list|(
literal|077
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Filename
argument_list|,
literal|"/tmp/crontab.XXXXXXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|mkstemp
argument_list|(
name|Filename
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|Filename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|um
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
operator|(
name|void
operator|)
name|umask
argument_list|(
name|um
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_FCHOWN
if|if
condition|(
name|fchown
argument_list|(
name|t
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|chown
argument_list|(
name|Filename
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
name|warn
argument_list|(
literal|"fchown"
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|NewCrontab
operator|=
name|fdopen
argument_list|(
name|t
argument_list|,
literal|"r+"
argument_list|)
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
name|Set_LineNum
argument_list|(
literal|1
argument_list|)
comment|/* ignore the top few comments since we probably put them there. 	 */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NHEADER_LINES
condition|;
name|x
operator|++
control|)
block|{
name|ch
operator|=
name|get_char
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|EOF
operator|==
name|ch
condition|)
break|break;
if|if
condition|(
literal|'#'
operator|!=
name|ch
condition|)
block|{
name|putc
argument_list|(
name|ch
argument_list|,
name|NewCrontab
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_char
argument_list|(
name|f
argument_list|)
operator|)
condition|)
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|EOF
operator|==
name|ch
condition|)
break|break;
block|}
comment|/* copy the rest of the crontab (if any) to the temp file. 	 */
if|if
condition|(
name|EOF
operator|!=
name|ch
condition|)
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_char
argument_list|(
name|f
argument_list|)
operator|)
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|NewCrontab
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|NewCrontab
argument_list|)
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"%s"
argument_list|,
name|Filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|t
argument_list|,
operator|&
name|fsbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"unable to fstat temp file"
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
name|again
label|:
if|if
condition|(
name|stat
argument_list|(
name|Filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"stat"
argument_list|)
expr_stmt|;
name|fatal
label|:
name|unlink
argument_list|(
name|Filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ERROR_EXIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|statbuf
operator|.
name|st_dev
operator|!=
name|fsbuf
operator|.
name|st_dev
operator|||
name|statbuf
operator|.
name|st_ino
operator|!=
name|fsbuf
operator|.
name|st_ino
condition|)
name|errx
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"temp file must be edited in place"
argument_list|)
expr_stmt|;
name|mtime
operator|=
name|statbuf
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|editor
operator|=
name|getenv
argument_list|(
literal|"VISUAL"
argument_list|)
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|editor
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
operator|)
operator|)
condition|)
block|{
name|editor
operator|=
name|EDITOR
expr_stmt|;
block|}
comment|/* we still have the file open.  editors will generally rewrite the 	 * original file rather than renaming/unlinking it and starting a 	 * new one; even backup files are supposed to be made by copying 	 * rather than by renaming.  if some editor does not support this, 	 * then don't use it.  the security problems are more severe if we 	 * close and reopen the file around the edit. 	 */
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|warn
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
case|case
literal|0
case|:
comment|/* child */
if|if
condition|(
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"setuid(getuid())"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
literal|"/tmp"
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"chdir(/tmp)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|editor
argument_list|)
operator|+
name|strlen
argument_list|(
name|Filename
argument_list|)
operator|+
literal|2
operator|>=
name|MAX_TEMPSTR
condition|)
name|errx
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"editor or filename too long"
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
name|editor
argument_list|,
name|editor
argument_list|,
name|Filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"%s"
argument_list|,
name|editor
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
default|default:
comment|/* parent */
break|break;
block|}
comment|/* parent */
block|{
name|void
function_decl|(
modifier|*
name|f
index|[
literal|4
index|]
function_decl|)
parameter_list|()
function_decl|;
name|f
index|[
literal|0
index|]
operator|=
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|f
index|[
literal|1
index|]
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|f
index|[
literal|2
index|]
operator|=
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|xpid
operator|=
name|wait
argument_list|(
operator|&
name|waiter
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|f
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|f
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|f
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xpid
operator|!=
name|pid
condition|)
block|{
name|warnx
argument_list|(
literal|"wrong PID (%d != %d) from \"%s\""
argument_list|,
name|xpid
argument_list|,
name|pid
argument_list|,
name|editor
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|waiter
argument_list|)
operator|&&
name|WEXITSTATUS
argument_list|(
name|waiter
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"\"%s\" exited with status %d"
argument_list|,
name|editor
argument_list|,
name|WEXITSTATUS
argument_list|(
name|waiter
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|waiter
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"\"%s\" killed; signal %d (%score dumped)"
argument_list|,
name|editor
argument_list|,
name|WTERMSIG
argument_list|(
name|waiter
argument_list|)
argument_list|,
name|WCOREDUMP
argument_list|(
name|waiter
argument_list|)
condition|?
literal|""
else|:
literal|"no "
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|Filename
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"stat"
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
if|if
condition|(
name|statbuf
operator|.
name|st_dev
operator|!=
name|fsbuf
operator|.
name|st_dev
operator|||
name|statbuf
operator|.
name|st_ino
operator|!=
name|fsbuf
operator|.
name|st_ino
condition|)
name|errx
argument_list|(
name|ERROR_EXIT
argument_list|,
literal|"temp file must be edited in place"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
operator|==
name|statbuf
operator|.
name|st_mtime
condition|)
block|{
name|warnx
argument_list|(
literal|"no changes made to crontab"
argument_list|)
expr_stmt|;
goto|goto
name|remove
goto|;
block|}
name|warnx
argument_list|(
literal|"installing new crontab"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|replace_cmd
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
operator|-
literal|1
case|:
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"Do you want to retry the same edit? "
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|q
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|q
argument_list|,
sizeof|sizeof
name|q
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|islower
argument_list|(
name|q
index|[
literal|0
index|]
argument_list|)
condition|?
name|q
index|[
literal|0
index|]
else|:
name|tolower
argument_list|(
name|q
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
literal|'y'
case|:
goto|goto
name|again
goto|;
case|case
literal|'n'
case|:
goto|goto
name|abandon
goto|;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Enter Y or N\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*NOTREACHED*/
case|case
operator|-
literal|2
case|:
name|abandon
label|:
name|warnx
argument_list|(
literal|"edits left in %s"
argument_list|,
name|Filename
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
default|default:
name|warnx
argument_list|(
literal|"panic: bad switch() in replace_cmd()"
argument_list|)
expr_stmt|;
goto|goto
name|fatal
goto|;
block|}
name|remove
label|:
name|unlink
argument_list|(
name|Filename
argument_list|)
expr_stmt|;
name|done
label|:
name|log_it
argument_list|(
name|RealUser
argument_list|,
name|Pid
argument_list|,
literal|"END EDIT"
argument_list|,
name|User
argument_list|)
expr_stmt|;
block|}
comment|/* returns	0	on success  *		-1	on syntax error  *		-2	on install error  */
specifier|static
name|int
name|replace_cmd
parameter_list|()
block|{
name|char
name|n
index|[
name|MAX_FNAME
index|]
decl_stmt|,
name|envstr
index|[
name|MAX_ENVSTR
index|]
decl_stmt|,
name|tn
index|[
name|MAX_FNAME
index|]
decl_stmt|;
name|FILE
modifier|*
name|tmp
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|eof
decl_stmt|;
name|entry
modifier|*
name|e
decl_stmt|;
name|time_t
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
init|=
name|env_init
argument_list|()
decl_stmt|;
if|if
condition|(
name|envp
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"cannot allocate memory"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"tmp.%d"
argument_list|,
name|Pid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tn
argument_list|,
name|CRON_TAB
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tmp
operator|=
name|fopen
argument_list|(
name|tn
argument_list|,
literal|"w+"
argument_list|)
operator|)
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|tn
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/* write a signature at the top of the file. 	 * 	 * VERY IMPORTANT: make sure NHEADER_LINES agrees with this code. 	 */
name|fprintf
argument_list|(
name|tmp
argument_list|,
literal|"# DO NOT EDIT THIS FILE - edit the master and reinstall.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tmp
argument_list|,
literal|"# (%s installed on %-24.24s)\n"
argument_list|,
name|Filename
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|tmp
argument_list|,
literal|"# (Cron version -- %s)\n"
argument_list|,
name|rcsid
argument_list|)
expr_stmt|;
comment|/* copy the crontab to the tmp 	 */
name|rewind
argument_list|(
name|NewCrontab
argument_list|)
expr_stmt|;
name|Set_LineNum
argument_list|(
literal|1
argument_list|)
while|while
condition|(
name|EOF
operator|!=
operator|(
name|ch
operator|=
name|get_char
argument_list|(
name|NewCrontab
argument_list|)
operator|)
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|ftell
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|rewind
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|tmp
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"error while writing new crontab to %s"
argument_list|,
name|tn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/* check the syntax of the file being installed. 	 */
comment|/* BUG: was reporting errors after the EOF if there were any errors 	 * in the file proper -- kludged it by stopping after first error. 	 *		vix 31mar87 	 */
name|Set_LineNum
argument_list|(
literal|1
argument|- NHEADER_LINES
argument_list|)
name|CheckErrorCount
operator|=
literal|0
expr_stmt|;
name|eof
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|CheckErrorCount
operator|&&
operator|!
name|eof
condition|)
block|{
switch|switch
condition|(
name|load_env
argument_list|(
name|envstr
argument_list|,
name|tmp
argument_list|)
condition|)
block|{
case|case
name|ERR
case|:
name|eof
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|FALSE
case|:
name|e
operator|=
name|load_entry
argument_list|(
name|tmp
argument_list|,
name|check_error
argument_list|,
name|pw
argument_list|,
name|envp
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
condition|)
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRUE
case|:
break|break;
block|}
block|}
if|if
condition|(
name|CheckErrorCount
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"errors in crontab file, can't install"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAS_FCHOWN
if|if
condition|(
name|fchown
argument_list|(
name|fileno
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|ROOT_UID
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
name|OK
condition|)
else|#
directive|else
if|if
condition|(
name|chown
argument_list|(
name|tn
argument_list|,
name|ROOT_UID
argument_list|,
operator|-
literal|1
argument_list|)
operator|<
name|OK
condition|)
endif|#
directive|endif
block|{
name|warn
argument_list|(
literal|"chown"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAS_FCHMOD
if|if
condition|(
name|fchmod
argument_list|(
name|fileno
argument_list|(
name|tmp
argument_list|)
argument_list|,
literal|0600
argument_list|)
operator|<
name|OK
condition|)
else|#
directive|else
if|if
condition|(
name|chmod
argument_list|(
name|tn
argument_list|,
literal|0600
argument_list|)
operator|<
name|OK
condition|)
endif|#
directive|endif
block|{
name|warn
argument_list|(
literal|"chown"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|tmp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|warn
argument_list|(
literal|"fclose"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|n
argument_list|,
name|CRON_TAB
argument_list|(
name|User
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tn
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"error renaming %s to %s"
argument_list|,
name|tn
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tn
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|log_it
argument_list|(
name|RealUser
argument_list|,
name|Pid
argument_list|,
literal|"REPLACE"
argument_list|,
name|User
argument_list|)
expr_stmt|;
name|poke_daemon
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
specifier|static
name|void
name|poke_daemon
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USE_UTIMES
name|struct
name|timeval
name|tvs
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tvs
index|[
literal|0
index|]
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|tvs
index|[
literal|1
index|]
operator|=
name|tvs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|utimes
argument_list|(
name|SPOOL_DIR
argument_list|,
name|tvs
argument_list|)
operator|<
name|OK
condition|)
block|{
name|warn
argument_list|(
literal|"can't update mtime on spooldir %s"
argument_list|,
name|SPOOL_DIR
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
name|utime
argument_list|(
name|SPOOL_DIR
argument_list|,
name|NULL
argument_list|)
operator|<
name|OK
condition|)
block|{
name|warn
argument_list|(
literal|"can't update mtime on spooldir %s"
argument_list|,
name|SPOOL_DIR
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/*USE_UTIMES*/
block|}
end_function

end_unit

