begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************  *   * Program:	pkg_manage  * Author:	Marc van Kempen  * Desc:	Add, delete packages with the pkg_* binaries  *		Get info about installed packages  *		Review about to be installed packages  *  * 1. View installed packages  * 2. Delete installed packages  * 3. Install packages  *  * Copyright (c) 1995, Marc van Kempen  *  * All rights reserved.  *  * This software may be used, modified, copied, distributed, and  * sold, in both source and binary form provided that the above  * copyright and these terms are retained, verbatim, as the first  * lines of this file.  Under no circumstances is the author  * responsible for the proper functioning of this software, nor does  * the author assume any responsibility for damages incurred with  * its use.  *   ***************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pkg_manage.h"
end_include

begin_include
include|#
directive|include
file|"ui_objects.h"
end_include

begin_include
include|#
directive|include
file|"dialog.priv.h"
end_include

begin_include
include|#
directive|include
file|"dir.h"
end_include

begin_decl_stmt
name|PKG_info
name|p_inf
init|=
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*******************************************************************  *  * 	Misc Functions  *  *******************************************************************/
end_comment

begin_function
name|void
name|FreeInfo
parameter_list|(
name|void
parameter_list|)
comment|/*  * Desc: free the space allocated to p_inf  */
block|{
name|free
argument_list|(
name|p_inf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_inf
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_inf
operator|.
name|comment
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_inf
operator|.
name|description
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|Nitems
operator|=
literal|0
expr_stmt|;
name|FreeMnu
argument_list|(
name|p_inf
operator|.
name|mnu
argument_list|,
literal|2
operator|*
name|p_inf
operator|.
name|Nitems
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* FreeInfo() */
end_comment

begin_function
name|void
name|FreeMnu
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|mnu
parameter_list|,
name|int
name|n
parameter_list|)
comment|/*  * Desc: free mnu array  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|mnu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mnu
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* FreeMnu() */
end_comment

begin_function
name|int
name|file_exists
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
comment|/*   * Desc: check if the file<fname> exists (and is readable)  */
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* apparently opening an empty */
comment|/* file for reading succeeds always */
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* file_exists() */
end_comment

begin_function
name|int
name|exec_catch_errors
parameter_list|(
name|char
modifier|*
name|prog
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|fout
parameter_list|)
comment|/*  * Desc: run the program<prog> with arguments<arg> and catch its output  * 	 in<fout> and display it in case of an error. specify NULL,   *	 if you don't want output.  */
block|{
name|char
modifier|*
name|execstr
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|yesno
decl_stmt|,
name|unlink_fout
decl_stmt|;
name|execstr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|prog
argument_list|)
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|30
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|execstr
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"exec_catch_errors: Error while mallocing memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* when fout == NULL, allocate a temporary file name and unlink it */
comment|/* when done */
if|if
condition|(
operator|!
name|fout
condition|)
block|{
name|fout
operator|=
name|tempnam
argument_list|(
name|NULL
argument_list|,
literal|"pkg."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fout
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"exec_catch_errors: Error allocating temp.name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|unlink_fout
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|unlink_fout
operator|=
name|FALSE
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|execstr
argument_list|,
literal|"%s %s> %s 2>&1"
argument_list|,
name|prog
argument_list|,
name|arg
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|ret
operator|=
name|system
argument_list|(
name|execstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|yesno
operator|=
name|dialog_yesno
argument_list|(
literal|"Error"
argument_list|,
literal|"An error occured, view output?"
argument_list|,
literal|8
argument_list|,
literal|40
argument_list|)
expr_stmt|;
if|if
condition|(
name|yesno
operator|==
literal|0
condition|)
block|{
comment|/* disable helpline */
name|tmp
operator|=
name|get_helpline
argument_list|()
expr_stmt|;
name|use_helpline
argument_list|(
literal|"use arrowkeys, PgUp, PgDn to move, press enter when done"
argument_list|)
expr_stmt|;
name|dialog_textbox
argument_list|(
literal|"Error output from pkg_add"
argument_list|,
name|fout
argument_list|,
name|LINES
operator|-
literal|2
argument_list|,
name|COLS
operator|-
literal|4
argument_list|)
expr_stmt|;
name|restore_helpline
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|unlink_fout
condition|)
block|{
name|unlink
argument_list|(
name|fout
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fout
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|execstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* exec_catch_errors() */
end_comment

begin_function
name|void
name|get_pkginfo
parameter_list|(
name|void
parameter_list|)
comment|/*  * Desc: get info about installed packages  */
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|,
name|lsize
decl_stmt|;
name|int
name|newline
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|state
decl_stmt|;
name|char
modifier|*
name|tmp_file
decl_stmt|;
define|#
directive|define
name|R_NAME
value|1
define|#
directive|define
name|R_COMMENT
value|2
define|#
directive|define
name|R_DESC
value|3
if|if
condition|(
name|p_inf
operator|.
name|Nitems
operator|>
literal|0
condition|)
block|{
name|FreeInfo
argument_list|()
expr_stmt|;
block|}
comment|/* p_inf.Nitems == 0 */
name|dialog_msgbox
argument_list|(
literal|"PKG INFO"
argument_list|,
literal|"Reading info, please wait ..."
argument_list|,
literal|4
argument_list|,
literal|35
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tmp_file
operator|=
name|tempnam
argument_list|(
name|NULL
argument_list|,
literal|"pkg."
argument_list|)
expr_stmt|;
name|ret
operator|=
name|exec_catch_errors
argument_list|(
name|PKG_INFO
argument_list|,
literal|"-a"
argument_list|,
name|tmp_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dialog_notify
argument_list|(
literal|"Could not get package info\nexiting!"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|tmp_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|dialog_notify
argument_list|(
literal|"Could not open temporary file"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
argument_list|(
name|tmp_file
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
comment|/* stat file to get filesize */
name|dialog_notify
argument_list|(
literal|"Could not stat temporary file"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sb
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
name|dialog_notify
argument_list|(
literal|"No packages installed or no info available"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Allocate a buffer with sufficient space to hold the entire file */
name|p_inf
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|sb
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|N
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|p_inf
operator|.
name|buf
argument_list|,
literal|1
argument_list|,
name|p_inf
operator|.
name|N
argument_list|,
name|f
argument_list|)
operator|!=
name|p_inf
operator|.
name|N
condition|)
block|{
name|dialog_notify
argument_list|(
literal|"Could not read entire temporary file"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_inf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_inf
operator|.
name|buf
index|[
name|p_inf
operator|.
name|N
index|]
operator|=
literal|0
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
comment|/* make one sweep through the buffer to determine the # of entries */
comment|/* Look for "Information for" in the first column */
name|i
operator|=
name|p_inf
operator|.
name|N
operator|-
name|strlen
argument_list|(
literal|"Information for"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|p_inf
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p_inf
operator|.
name|buf
argument_list|,
literal|"Information for"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|"Information for"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
name|n
operator|++
expr_stmt|;
block|}
block|}
name|p
operator|++
expr_stmt|;
block|}
comment|/* malloc space for PKG_info */
name|p_inf
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|comment
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|description
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|Nitems
operator|=
name|n
expr_stmt|;
comment|/* parse pkg_info output */
comment|/* use a finite state automate to parse the file */
name|i
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|p_inf
operator|.
name|buf
expr_stmt|;
name|newline
operator|=
name|TRUE
expr_stmt|;
name|state
operator|=
name|R_NAME
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|newline
condition|)
block|{
name|newline
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|R_NAME
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Information for"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|p_inf
operator|.
name|buf
condition|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|p_inf
operator|.
name|name
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|16
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|state
operator|=
name|R_COMMENT
expr_stmt|;
block|}
break|break;
case|case
name|R_COMMENT
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Comment:"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|p_inf
operator|.
name|comment
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|newline
operator|=
name|TRUE
expr_stmt|;
block|}
name|state
operator|=
name|R_DESC
expr_stmt|;
block|}
break|break;
case|case
name|R_DESC
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Description:"
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
name|p_inf
operator|.
name|description
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|1
expr_stmt|;
name|newline
operator|=
name|TRUE
expr_stmt|;
block|}
name|state
operator|=
name|R_NAME
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|newline
operator|=
name|TRUE
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* build menu entries */
name|p_inf
operator|.
name|mnu
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
name|p_inf
operator|.
name|Nitems
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|lsize
operator|=
name|COLS
operator|-
literal|30
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_inf
operator|.
name|Nitems
condition|;
name|i
operator|++
control|)
block|{
comment|/* tag */
name|p_inf
operator|.
name|mnu
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|lsize
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p_inf
operator|.
name|mnu
index|[
name|j
index|]
argument_list|,
name|p_inf
operator|.
name|name
index|[
name|i
index|]
argument_list|,
name|lsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|mnu
index|[
name|j
operator|++
index|]
index|[
name|lsize
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* description */
name|p_inf
operator|.
name|mnu
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|lsize
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p_inf
operator|.
name|mnu
index|[
name|j
index|]
argument_list|,
name|p_inf
operator|.
name|comment
index|[
name|i
index|]
argument_list|,
name|lsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|mnu
index|[
name|j
operator|++
index|]
index|[
name|lsize
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* get_pkginfo() */
end_comment

begin_function
name|int
name|get_pkg_index
parameter_list|(
name|char
modifier|*
name|selection
parameter_list|)
comment|/*  * desc: get the index i, for which p_inf.name[i] == selection  */
block|{
name|int
name|i
decl_stmt|,
name|found
init|=
name|FALSE
decl_stmt|,
name|index
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_inf
operator|.
name|Nitems
operator|&&
operator|!
name|found
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|selection
argument_list|,
name|p_inf
operator|.
name|name
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
operator|(
name|index
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get_pkg_index() */
end_comment

begin_function
name|void
name|install_package
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
comment|/*   * Desc: install the package<fname>  */
block|{
name|char
modifier|*
name|tmp_file
decl_stmt|;
name|tmp_file
operator|=
name|tempnam
argument_list|(
name|NULL
argument_list|,
literal|"pkg."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_file
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"install_package(): Error malloc'ing tmp_file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getenv
argument_list|(
literal|"PKG_PATH"
argument_list|)
condition|)
name|putenv
argument_list|(
literal|"/usr/ports/packages:/usr/ports/packages/all:."
argument_list|)
expr_stmt|;
name|exec_catch_errors
argument_list|(
name|PKG_ADD
argument_list|,
name|fname
argument_list|,
name|tmp_file
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* install_package() */
end_comment

begin_function
name|int
name|get_desc
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|char
modifier|*
modifier|*
name|comment
parameter_list|,
name|char
modifier|*
modifier|*
name|desc
parameter_list|,
name|long
modifier|*
name|size
parameter_list|,
name|char
modifier|*
name|tmp_dir
parameter_list|)
comment|/*  * Desc: get the description and comment from the files  *	 DESC, CONTENT and COMMENT from fname  * Pre:  the current working directory is a temporary,   *	 empty directory.  * Post: name = the name of the package  * 	 comment = the comment for the package  *	 desc = the description for the package  */
block|{
name|char
name|msg
index|[
literal|80
index|]
decl_stmt|,
name|args
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|tmp
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|,
modifier|*
name|pf
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|N
decl_stmt|,
name|ret
decl_stmt|,
name|found
decl_stmt|;
operator|*
name|comment
operator|=
name|NULL
expr_stmt|;
operator|*
name|desc
operator|=
name|NULL
expr_stmt|;
operator|*
name|name
operator|=
name|NULL
expr_stmt|;
name|sprintf
argument_list|(
name|args
argument_list|,
literal|"--fast-read -zxvf %s -C %s %s %s %s"
argument_list|,
name|fname
argument_list|,
name|tmp_dir
argument_list|,
name|CONTENTS
argument_list|,
name|DESC
argument_list|,
name|COMMENT
argument_list|)
expr_stmt|;
name|ret
operator|=
name|exec_catch_errors
argument_list|(
name|TAR
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Could not get info for<%s>"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|dialog_notify
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Read CONTENTS */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|tmp_dir
argument_list|,
name|CONTENTS
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|tmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* No contents file in package, propably not a package */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|tmp
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
comment|/* stat file to get filesize */
name|dialog_notify
argument_list|(
literal|"Could not stat CONTENTS file"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
name|dialog_notify
argument_list|(
literal|"CONTENTS file has zero length"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Allocate a buffer with sufficient space to hold the entire file */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|sb
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|N
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|N
argument_list|,
name|f
argument_list|)
operator|!=
name|N
condition|)
block|{
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Could not read CONTENT file for<%s>"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|dialog_notify
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|buf
index|[
name|N
index|]
operator|=
literal|0
expr_stmt|;
comment|/* look for the name of the package */
name|p
operator|=
name|buf
expr_stmt|;
name|found
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|!
name|found
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"@name "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
literal|6
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|p
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|&&
name|p
index|[
name|i
index|]
operator|!=
literal|'\r'
condition|)
name|i
operator|++
expr_stmt|;
operator|*
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|*
name|name
argument_list|,
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
operator|*
name|name
operator|)
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|p
operator|++
expr_stmt|;
block|}
block|}
name|unlink
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* Read COMMENT file */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|tmp_dir
argument_list|,
name|COMMENT
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|tmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* No comment file in package, propably not a package */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|tmp
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
comment|/* stat file to get filesize */
name|dialog_notify
argument_list|(
literal|"Could not stat COMMENT file"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
name|dialog_notify
argument_list|(
literal|"COMMENT file has zero length"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Allocate a buffer with sufficient space to hold the entire file */
operator|*
name|comment
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|sb
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|N
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|*
name|comment
argument_list|,
literal|1
argument_list|,
name|N
argument_list|,
name|f
argument_list|)
operator|!=
name|N
condition|)
block|{
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Could not read COMMENT file for<%s>"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|dialog_notify
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|comment
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
operator|*
name|comment
operator|)
index|[
name|N
index|]
operator|=
literal|0
expr_stmt|;
name|unlink
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* Read DESC */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s/%s"
argument_list|,
name|tmp_dir
argument_list|,
name|DESC
argument_list|)
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|tmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
comment|/* No description file in package, propably not a package */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|tmp
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
comment|/* stat file to get filesize */
name|dialog_notify
argument_list|(
literal|"Could not stat DESC file"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
name|dialog_notify
argument_list|(
literal|"DESC file has zero length"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* Allocate a buffer with sufficient space to hold the entire file */
operator|*
name|desc
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|sb
operator|.
name|st_size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|N
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|*
name|desc
argument_list|,
literal|1
argument_list|,
name|N
argument_list|,
name|f
argument_list|)
operator|!=
name|N
condition|)
block|{
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Could not read CONTENT file for<%s>"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|dialog_notify
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|desc
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
operator|(
operator|*
name|desc
operator|)
index|[
name|N
index|]
operator|=
literal|0
expr_stmt|;
name|unlink
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* get the size from the uncompressed package */
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s -l %s"
argument_list|,
name|GUNZIP
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|pf
operator|=
name|popen
argument_list|(
name|tmp
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
condition|)
block|{
name|dialog_notify
argument_list|(
literal|"Could not popen gunzip to get package size"
argument_list|)
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|feof
argument_list|(
name|pf
argument_list|)
condition|)
block|{
name|fgets
argument_list|(
name|tmp
argument_list|,
literal|80
argument_list|,
name|pf
argument_list|)
expr_stmt|;
block|}
name|sscanf
argument_list|(
name|tmp
argument_list|,
literal|"%*s %ld"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|pf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* get_desc() */
end_comment

begin_function
name|int
name|already_installed
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
comment|/*   * Desc: check if<name> is already installed as a package  */
block|{
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
name|found
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_inf
operator|.
name|Nitems
operator|&&
operator|!
name|found
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|p_inf
operator|.
name|name
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/* already_installed() */
end_comment

end_unit

