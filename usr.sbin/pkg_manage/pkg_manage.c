begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************  *   * Program:	pkg_manage  * Author:	Marc van Kempen  * Desc:	Add, delete packages with the pkg_* binaries  *		Get info about installed packages  *		Review about to be installed packages  *  * 1. View installed packages  * 2. Delete installed packages  * 3. View package files  * 4. Install packages files.  *  * Installation and deletion of packages should be previewable  *  *  * Copyright (c) 1995, Marc van Kempen  *  * All rights reserved.  *  * This software may be used, modified, copied, distributed, and  * sold, in both source and binary form provided that the above  * copyright and these terms are retained, verbatim, as the first  * lines of this file.  Under no circumstances is the author  * responsible for the proper functioning of this software, nor does  * the author assume any responsibility for damages incurred with  * its use.  *   ***************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"pkg_manage.h"
end_include

begin_decl_stmt
specifier|static
name|PKG_info
name|p_inf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|got_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local prototypes  */
end_comment

begin_function_decl
name|void
name|run_menu
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|get_pkginfo
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|FreeMnu
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|mnu
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|FreeInfo
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Main  */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|init_dialog
argument_list|()
expr_stmt|;
name|get_pkginfo
argument_list|()
expr_stmt|;
name|run_menu
argument_list|()
expr_stmt|;
if|if
condition|(
name|got_info
condition|)
name|FreeInfo
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|dialog_update
argument_list|()
expr_stmt|;
name|end_dialog
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* main() */
end_comment

begin_function
name|void
name|FreeInfo
parameter_list|(
name|void
parameter_list|)
block|{
name|free
argument_list|(
name|p_inf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_inf
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_inf
operator|.
name|comment
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_inf
operator|.
name|description
argument_list|)
expr_stmt|;
name|FreeMnu
argument_list|(
name|p_inf
operator|.
name|mnu
argument_list|,
literal|2
operator|*
name|p_inf
operator|.
name|Nitems
argument_list|)
expr_stmt|;
name|got_info
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FreeMnu
parameter_list|(
name|unsigned
name|char
modifier|*
modifier|*
name|mnu
parameter_list|,
name|int
name|n
parameter_list|)
comment|/*  * Desc: free mnu array  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|mnu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|mnu
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* FreeMnu() */
end_comment

begin_function
name|int
name|file_exists
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
comment|/*   * Desc: check if the file<fname> exists (and is readable)  */
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|fname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* apparently opening an empty */
comment|/* file for reading succeeds always */
name|f
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* file_exists() */
end_comment

begin_function
name|void
name|get_pkginfo
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|prog
index|[
literal|512
index|]
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|,
name|lsize
decl_stmt|;
name|int
name|newline
decl_stmt|;
name|int
name|state
decl_stmt|;
name|char
modifier|*
name|tmp_file
decl_stmt|;
define|#
directive|define
name|R_NAME
value|1
define|#
directive|define
name|R_COMMENT
value|2
define|#
directive|define
name|R_DESC
value|3
if|if
condition|(
name|got_info
condition|)
name|FreeInfo
argument_list|()
expr_stmt|;
name|dialog_msgbox
argument_list|(
literal|"PKG INFO"
argument_list|,
literal|"Reading info, please wait ..."
argument_list|,
literal|4
argument_list|,
literal|35
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|tmp_file
operator|=
name|tempnam
argument_list|(
name|NULL
argument_list|,
literal|"pkg."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|prog
argument_list|,
literal|"%s -a> %s"
argument_list|,
name|PKG_INFO
argument_list|,
name|tmp_file
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|dialog_clear_norefresh
argument_list|()
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|tmp_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|dialog_notify
argument_list|(
literal|"Could not open temporary file"
argument_list|)
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|tmp_file
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
comment|/* stat file to get filesize */
name|dialog_notify
argument_list|(
literal|"Could not stat temporary file"
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_size
operator|==
literal|0
condition|)
block|{
name|dialog_notify
argument_list|(
literal|"No packages info available"
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
comment|/* Allocate a buffer with sufficient space to hold the entire file */
name|p_inf
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|N
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|p_inf
operator|.
name|buf
argument_list|,
literal|1
argument_list|,
name|p_inf
operator|.
name|N
argument_list|,
name|f
argument_list|)
operator|!=
name|p_inf
operator|.
name|N
condition|)
block|{
name|dialog_notify
argument_list|(
literal|"Could not read from temporary file"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p_inf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|err2
label|:
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|err1
label|:
name|got_info
operator|=
name|FALSE
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
return|return;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
comment|/* make one sweep through the buffer to determine the # of entries */
comment|/* Look for "Information for" in the first column */
name|i
operator|=
name|p_inf
operator|.
name|N
operator|-
name|strlen
argument_list|(
literal|"Information for"
argument_list|)
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|p_inf
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p_inf
operator|.
name|buf
argument_list|,
literal|"Information for"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|--
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|"Information for"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
name|n
operator|++
expr_stmt|;
block|}
block|}
name|p
operator|++
expr_stmt|;
block|}
comment|/* malloc space for PKG_info */
name|p_inf
operator|.
name|name
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|comment
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|description
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|Nitems
operator|=
name|n
expr_stmt|;
comment|/* parse pkg_info output */
comment|/* use a finite state automate to parse the file */
name|i
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|p_inf
operator|.
name|buf
expr_stmt|;
name|newline
operator|=
name|TRUE
expr_stmt|;
name|state
operator|=
name|R_NAME
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|newline
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|R_NAME
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Information for"
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|p_inf
operator|.
name|buf
condition|)
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|p_inf
operator|.
name|name
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|16
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|state
operator|=
name|R_COMMENT
expr_stmt|;
block|}
break|break;
case|case
name|R_COMMENT
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Comment:"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|p_inf
operator|.
name|comment
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|state
operator|=
name|R_DESC
expr_stmt|;
block|}
break|break;
case|case
name|R_DESC
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Description:"
argument_list|,
literal|12
argument_list|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|p_inf
operator|.
name|description
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
literal|1
expr_stmt|;
name|state
operator|=
name|R_NAME
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
break|break;
block|}
name|newline
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|newline
operator|=
name|TRUE
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
comment|/* build menu entries */
name|p_inf
operator|.
name|mnu
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
name|p_inf
operator|.
name|Nitems
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|lsize
operator|=
name|COLS
operator|-
literal|30
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_inf
operator|.
name|Nitems
condition|;
name|i
operator|++
control|)
block|{
comment|/* tag */
name|p_inf
operator|.
name|mnu
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|lsize
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p_inf
operator|.
name|mnu
index|[
name|j
index|]
argument_list|,
name|p_inf
operator|.
name|name
index|[
name|i
index|]
argument_list|,
name|lsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|mnu
index|[
name|j
operator|++
index|]
index|[
name|lsize
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* description */
name|p_inf
operator|.
name|mnu
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|lsize
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p_inf
operator|.
name|mnu
index|[
name|j
index|]
argument_list|,
name|p_inf
operator|.
name|comment
index|[
name|i
index|]
argument_list|,
name|lsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_inf
operator|.
name|mnu
index|[
name|j
operator|++
index|]
index|[
name|lsize
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|got_info
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* get_pkginfo() */
end_comment

begin_function
name|int
name|get_pkg_index
parameter_list|(
name|char
modifier|*
name|selection
parameter_list|)
comment|/*  * desc: get the index i, for which p_inf.name[i] == selection  */
block|{
name|int
name|i
decl_stmt|,
name|found
init|=
name|FALSE
decl_stmt|,
name|index
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|got_info
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p_inf
operator|.
name|Nitems
operator|&&
operator|!
name|found
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|selection
argument_list|,
name|p_inf
operator|.
name|name
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|TRUE
expr_stmt|;
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
operator|(
name|index
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get_pkg_index() */
end_comment

begin_function
name|void
name|view_installed
parameter_list|(
name|void
parameter_list|)
comment|/*  * Desc: View the installed packages  */
block|{
name|int
name|i
decl_stmt|,
name|quit_view
decl_stmt|,
name|sc
init|=
literal|0
decl_stmt|,
name|ch
init|=
literal|0
decl_stmt|;
name|char
name|selection
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|got_info
condition|)
block|{
name|use_helpfile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|use_helpline
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|dialog_notify
argument_list|(
literal|"No packages info available"
argument_list|)
expr_stmt|;
return|return;
block|}
name|use_helpfile
argument_list|(
name|VIEW_INST_HLP
argument_list|)
expr_stmt|;
name|quit_view
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|quit_view
condition|)
block|{
name|use_helpline
argument_list|(
literal|"use arrow-keys or character to select option and press enter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialog_menu
argument_list|(
literal|"View installed packages"
argument_list|,
literal|"Press enter to see the package descriptions"
argument_list|,
name|LINES
argument_list|,
name|COLS
argument_list|,
name|LINES
operator|-
literal|5
argument_list|,
name|p_inf
operator|.
name|Nitems
argument_list|,
name|p_inf
operator|.
name|mnu
argument_list|,
name|selection
argument_list|,
operator|&
name|ch
argument_list|,
operator|&
name|sc
argument_list|)
condition|)
block|{
name|quit_view
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|get_pkg_index
argument_list|(
name|selection
argument_list|)
expr_stmt|;
name|use_helpline
argument_list|(
literal|"use PgUp and PgDn and arrow-keys to move throught the text"
argument_list|)
expr_stmt|;
name|dialog_mesgbox
argument_list|(
name|p_inf
operator|.
name|comment
index|[
name|i
index|]
argument_list|,
name|p_inf
operator|.
name|description
index|[
name|i
index|]
argument_list|,
name|LINES
argument_list|,
name|COLS
argument_list|)
expr_stmt|;
block|}
block|}
name|use_helpfile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|use_helpline
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* view_installed() */
end_comment

begin_function
name|void
name|delete_installed
parameter_list|(
name|void
parameter_list|)
comment|/*  * Desc: Delete an installed package  */
block|{
name|unsigned
name|char
modifier|*
name|mnu
index|[]
init|=
block|{
literal|"1. Simulate delete"
block|,
literal|"Display commands that are going to be executed"
block|,
literal|"2. Delete"
block|,
literal|"Execute commands to delete the package"
block|,
literal|"3. Cancel"
block|,
literal|"Do NOT delete the package"
block|}
decl_stmt|;
name|char
name|tmp
index|[
literal|512
index|]
decl_stmt|,
name|selection
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|tmp_file
decl_stmt|;
name|int
name|quit_view
decl_stmt|,
name|quit_del
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sel
decl_stmt|,
name|ch
init|=
literal|0
decl_stmt|,
name|sc
init|=
literal|0
decl_stmt|,
name|ch0
init|=
literal|0
decl_stmt|,
name|sc0
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|got_info
condition|)
block|{
name|use_helpfile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|use_helpline
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|dialog_notify
argument_list|(
literal|"No packages info available"
argument_list|)
expr_stmt|;
return|return;
block|}
name|quit_view
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|quit_view
condition|)
block|{
name|use_helpline
argument_list|(
literal|"use arrow-keys or character to select option and press enter"
argument_list|)
expr_stmt|;
name|use_helpfile
argument_list|(
name|DEL_INST_HLP
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialog_menu
argument_list|(
literal|"DELETE an installed package"
argument_list|,
literal|"Press enter to select a package"
argument_list|,
name|LINES
argument_list|,
name|COLS
argument_list|,
name|LINES
operator|-
literal|5
argument_list|,
name|p_inf
operator|.
name|Nitems
argument_list|,
name|p_inf
operator|.
name|mnu
argument_list|,
name|selection
argument_list|,
operator|&
name|ch
argument_list|,
operator|&
name|sc
argument_list|)
condition|)
block|{
name|quit_view
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|quit_del
operator|=
name|FALSE
expr_stmt|;
name|i
operator|=
name|get_pkg_index
argument_list|(
name|selection
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|quit_del
condition|)
block|{
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"Delete<%s>"
argument_list|,
name|p_inf
operator|.
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|use_helpline
argument_list|(
literal|"use arrow-keys or digit to select option and press enter"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialog_menu
argument_list|(
literal|"Delete a package"
argument_list|,
name|tmp
argument_list|,
literal|10
argument_list|,
name|COLS
operator|-
literal|6
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
name|mnu
argument_list|,
name|selection
argument_list|,
operator|&
name|ch0
argument_list|,
operator|&
name|sc0
argument_list|)
condition|)
block|{
name|quit_del
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|sel
operator|=
name|atoi
argument_list|(
name|selection
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sel
condition|)
block|{
case|case
literal|1
case|:
name|tmp_file
operator|=
name|tempnam
argument_list|(
name|NULL
argument_list|,
literal|"pkg."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s -n %s> %s"
argument_list|,
name|PKG_DELETE
argument_list|,
name|p_inf
operator|.
name|name
index|[
name|i
index|]
argument_list|,
name|tmp_file
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|dialog_textbox
argument_list|(
literal|"Package deletion commands"
argument_list|,
name|tmp_file
argument_list|,
name|LINES
argument_list|,
name|COLS
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s %s"
argument_list|,
name|PKG_DELETE
argument_list|,
name|p_inf
operator|.
name|name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|get_pkginfo
argument_list|()
expr_stmt|;
name|quit_del
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|quit_del
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
name|use_helpfile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|use_helpline
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* delete_installed() */
end_comment

begin_function
name|void
name|preview_pkg
parameter_list|(
name|void
parameter_list|)
comment|/*   * Desc: View the package description and comment before installation  */
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|tmp_file
decl_stmt|;
name|char
name|prog
index|[
literal|512
index|]
decl_stmt|,
name|title
index|[
literal|512
index|]
decl_stmt|;
name|use_helpfile
argument_list|(
name|PREVIEW_HLP
argument_list|)
expr_stmt|;
name|fname
operator|=
name|dialog_fselect
argument_list|(
literal|"."
argument_list|,
literal|"*.tgz"
argument_list|)
expr_stmt|;
while|while
condition|(
name|fname
condition|)
block|{
name|use_helpfile
argument_list|(
name|PREVIEW_HLP
argument_list|)
expr_stmt|;
name|use_helpline
argument_list|(
literal|"use PgUp and PgDn and arrow-keys to move through the text"
argument_list|)
expr_stmt|;
name|tmp_file
operator|=
name|tempnam
argument_list|(
name|NULL
argument_list|,
literal|"pkg."
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|prog
argument_list|,
literal|"%s zxOf %s +COMMENT +DESC> %s"
argument_list|,
name|TAR
argument_list|,
name|fname
argument_list|,
name|tmp_file
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|prog
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|title
argument_list|,
literal|"Preview package<%s>"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|dialog_textbox
argument_list|(
name|title
argument_list|,
name|tmp_file
argument_list|,
name|LINES
argument_list|,
name|COLS
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|fname
operator|=
name|dialog_fselect
argument_list|(
literal|"."
argument_list|,
literal|"*.tgz"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fname
condition|)
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|use_helpfile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|use_helpline
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* preview_pkg() */
end_comment

begin_function
name|void
name|install_new
parameter_list|(
name|void
parameter_list|)
comment|/*  * Desc: Install a new package  */
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|tmp_file
decl_stmt|;
name|char
name|tmp
index|[
literal|512
index|]
decl_stmt|,
name|selection
index|[
literal|40
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|mnu
index|[]
init|=
block|{
literal|"1. Simulate install"
block|,
literal|"Display commands that are going to be executed"
block|,
literal|"2. Install"
block|,
literal|"Execute commands to install the package"
block|,
literal|"3. Cancel"
block|,
literal|"Do NOT install the package"
block|}
decl_stmt|;
name|int
name|sel
decl_stmt|,
name|quit_inst
decl_stmt|,
name|ch
init|=
literal|0
decl_stmt|,
name|sc
init|=
literal|0
decl_stmt|;
name|use_helpfile
argument_list|(
name|INSTALL_HLP
argument_list|)
expr_stmt|;
name|fname
operator|=
name|dialog_fselect
argument_list|(
literal|"."
argument_list|,
literal|"*.tgz"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fname
condition|)
block|{
name|quit_inst
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|quit_inst
operator|=
name|FALSE
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|quit_inst
condition|)
block|{
name|use_helpfile
argument_list|(
name|INSTALL_HLP
argument_list|)
expr_stmt|;
name|use_helpline
argument_list|(
literal|"use arrow-keys or digit to select option and press enter"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"Install package<%s>"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialog_menu
argument_list|(
literal|"Install a package"
argument_list|,
name|tmp
argument_list|,
literal|10
argument_list|,
name|COLS
operator|-
literal|5
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
name|mnu
argument_list|,
name|selection
argument_list|,
operator|&
name|ch
argument_list|,
operator|&
name|sc
argument_list|)
condition|)
block|{
name|quit_inst
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|sel
operator|=
name|atoi
argument_list|(
name|selection
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sel
condition|)
block|{
case|case
literal|1
case|:
name|tmp_file
operator|=
name|tempnam
argument_list|(
name|NULL
argument_list|,
literal|"*.pkg"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s -n %s 2>&1 | cat> %s"
argument_list|,
name|PKG_ADD
argument_list|,
name|fname
argument_list|,
name|tmp_file
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|dialog_textbox
argument_list|(
literal|"Package installation commands"
argument_list|,
name|tmp_file
argument_list|,
name|LINES
argument_list|,
name|COLS
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp_file
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%s %s"
argument_list|,
name|PKG_ADD
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|get_pkginfo
argument_list|()
expr_stmt|;
name|quit_inst
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|quit_inst
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|fname
condition|)
name|free
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|use_helpfile
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|use_helpline
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* install_new() */
end_comment

begin_function
name|void
name|run_menu
parameter_list|(
name|void
parameter_list|)
comment|/*  * Desc: display/choose from menu  */
block|{
name|int
name|quit_pkg
decl_stmt|,
name|sel
decl_stmt|,
name|ch
init|=
literal|0
decl_stmt|,
name|sc
init|=
literal|0
decl_stmt|;
name|char
name|selection
index|[
literal|30
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|pkg_menu
index|[]
init|=
block|{
literal|"1. View installed"
block|,
literal|"Overview of the installed packages"
block|,
literal|"2. Delete installed"
block|,
literal|"Delete an installed package"
block|,
literal|"3. View pkg files"
block|,
literal|"Preview about to be installed packages"
block|,
literal|"4. Install pkg files"
block|,
literal|"Install new packages"
block|,
literal|"5. Quit"
block|,
literal|"Leave the program"
block|,     }
decl_stmt|;
name|quit_pkg
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|quit_pkg
condition|)
block|{
name|use_helpline
argument_list|(
literal|"use arrow-keys or digit to select option and press enter"
argument_list|)
expr_stmt|;
name|use_helpfile
argument_list|(
name|MAIN_HLP
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialog_menu
argument_list|(
literal|"Package Manager"
argument_list|,
literal|"Choose one of the options"
argument_list|,
name|LINES
argument_list|,
name|COLS
argument_list|,
literal|5
argument_list|,
literal|5
argument_list|,
name|pkg_menu
argument_list|,
name|selection
argument_list|,
operator|&
name|ch
argument_list|,
operator|&
name|sc
argument_list|)
condition|)
block|{
name|sel
operator|=
literal|0
expr_stmt|;
name|quit_pkg
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|sel
operator|=
name|atoi
argument_list|(
name|selection
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sel
condition|)
block|{
case|case
literal|0
case|:
comment|/* Quit */
break|break;
case|case
literal|1
case|:
comment|/* View installed packages */
name|view_installed
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Delete installed package */
name|delete_installed
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Preview new package file */
name|preview_pkg
argument_list|()
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* Install new package */
name|install_new
argument_list|()
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* Quit */
name|quit_pkg
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/* run_menu() */
end_comment

end_unit

