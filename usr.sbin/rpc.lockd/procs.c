begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995  *	A.R. Gordon (andrew.gordon@net-tel.co.uk).  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed for the FreeBSD project  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ANDREW GORDON AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"lockd.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* for MAXHOSTNAMELEN	*/
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_define
define|#
directive|define
name|CLIENT_CACHE_SIZE
value|64
end_define

begin_comment
comment|/* No. of client sockets cached	*/
end_comment

begin_define
define|#
directive|define
name|CLIENT_CACHE_LIFETIME
value|120
end_define

begin_comment
comment|/* In seconds			*/
end_comment

begin_comment
comment|/* log_from_addr ----------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Log name of function called and source address    Returns:	Nothing    Notes:	Extracts the source address from the transport handle 		passed in as part of the called procedure specification */
end_comment

begin_function
specifier|static
name|void
name|log_from_addr
parameter_list|(
name|char
modifier|*
name|fun_name
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
name|struct
name|hostent
modifier|*
name|host
decl_stmt|;
name|char
name|hostname_buf
index|[
literal|40
index|]
decl_stmt|;
name|addr
operator|=
name|svc_getcaller
argument_list|(
name|req
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
name|host
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|addr
operator|->
name|sin_addr
operator|)
argument_list|,
name|addr
operator|->
name|sin_len
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
condition|)
block|{
name|strncpy
argument_list|(
name|hostname_buf
argument_list|,
name|host
operator|->
name|h_name
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname_buf
argument_list|)
argument_list|)
expr_stmt|;
name|hostname_buf
index|[
sizeof|sizeof
argument_list|(
name|hostname_buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
comment|/* No hostname available - print raw address	*/
block|{
name|strcpy
argument_list|(
name|hostname_buf
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s from %s"
argument_list|,
name|fun_name
argument_list|,
name|hostname_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get_client -------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Get a CLIENT* for making RPC calls to lockd on given host    Returns:	CLIENT* pointer, from clnt_udp_create, or NULL if error    Notes:	Creating a CLIENT* is quite expensive, involving a 		conversation with the remote portmapper to get the 		port number.  Since a given client is quite likely 		to make several locking requests in succession, it is 		desirable to cache the created CLIENT*.  		Since we are using UDP rather than TCP, there is no cost 		to the remote system in keeping these cached indefinitely. 		Unfortunately there is a snag: if the remote system 		reboots, the cached portmapper results will be invalid, 		and we will never detect this since all of the xxx_msg() 		calls return no result - we just fire off a udp packet 		and hope for the best.  		We solve this by discarding cached values after two 		minutes, regardless of whether they have been used 		in the meanwhile (since a bad one might have been used 		plenty of times, as the host keeps retrying the request 		and we keep sending the reply back to the wrong port).  		Given that the entries will always expire in the order 		that they were created, there is no point in a LRU 		algorithm for when the cache gets full - entries are 		always re-used in sequence. */
end_comment

begin_decl_stmt
specifier|static
name|CLIENT
modifier|*
name|clnt_cache_ptr
index|[
name|CLIENT_CACHE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|clnt_cache_time
index|[
name|CLIENT_CACHE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time entry created	*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|in_addr
name|clnt_cache_addr
index|[
name|CLIENT_CACHE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|clnt_cache_next_to_use
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|CLIENT
modifier|*
name|get_client
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|host_addr
parameter_list|)
block|{
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|int
name|sock_no
decl_stmt|;
name|struct
name|timeval
name|retry_time
decl_stmt|,
name|time_now
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|time_now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Search for the given client in the cache, zapping any expired	*/
comment|/* entries that we happen to notice in passing.			*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLIENT_CACHE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|client
operator|=
name|clnt_cache_ptr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|client
operator|&&
operator|(
operator|(
name|clnt_cache_time
index|[
name|i
index|]
operator|+
name|CLIENT_CACHE_LIFETIME
operator|)
operator|<
name|time_now
operator|.
name|tv_sec
operator|)
condition|)
block|{
comment|/* Cache entry has expired.					*/
if|if
condition|(
name|debug_level
operator|>
literal|3
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Expired CLIENT* in cache"
argument_list|)
expr_stmt|;
name|clnt_cache_time
index|[
name|i
index|]
operator|=
literal|0L
expr_stmt|;
name|clnt_destroy
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|clnt_cache_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|client
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|&&
operator|!
name|memcmp
argument_list|(
operator|&
name|clnt_cache_addr
index|[
name|i
index|]
argument_list|,
operator|&
name|host_addr
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Found it!							*/
if|if
condition|(
name|debug_level
operator|>
literal|3
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Found CLIENT* in cache"
argument_list|)
expr_stmt|;
return|return
operator|(
name|client
operator|)
return|;
block|}
block|}
comment|/* Not found in cache.  Free the next entry if it is in use		*/
if|if
condition|(
name|clnt_cache_ptr
index|[
name|clnt_cache_next_to_use
index|]
condition|)
block|{
name|clnt_destroy
argument_list|(
name|clnt_cache_ptr
index|[
name|clnt_cache_next_to_use
index|]
argument_list|)
expr_stmt|;
name|clnt_cache_ptr
index|[
name|clnt_cache_next_to_use
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Create the new client handle					*/
name|sock_no
operator|=
name|RPC_ANYSOCK
expr_stmt|;
name|retry_time
operator|.
name|tv_sec
operator|=
literal|5
expr_stmt|;
name|retry_time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|host_addr
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
comment|/* Force consultation with portmapper	*/
name|client
operator|=
name|clntudp_create
argument_list|(
name|host_addr
argument_list|,
name|NLM_PROG
argument_list|,
name|NLM_VERS
argument_list|,
name|retry_time
argument_list|,
operator|&
name|sock_no
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|clnt_spcreateerror
argument_list|(
literal|"clntudp_create"
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to return result to %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|host_addr
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Success - update the cache entry					*/
name|clnt_cache_ptr
index|[
name|clnt_cache_next_to_use
index|]
operator|=
name|client
expr_stmt|;
name|clnt_cache_addr
index|[
name|clnt_cache_next_to_use
index|]
operator|=
name|host_addr
operator|->
name|sin_addr
expr_stmt|;
name|clnt_cache_time
index|[
name|clnt_cache_next_to_use
index|]
operator|=
name|time_now
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|++
name|clnt_cache_next_to_use
operator|>
name|CLIENT_CACHE_SIZE
condition|)
name|clnt_cache_next_to_use
operator|=
literal|0
expr_stmt|;
comment|/* Disable the default timeout, so we can specify our own in calls	*/
comment|/* to clnt_call(). [note that the timeout is a different concept	*/
comment|/* from the retry period set in clnt_udp_create() above.]		*/
name|retry_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|retry_time
operator|.
name|tv_usec
operator|=
operator|-
literal|1
expr_stmt|;
name|clnt_control
argument_list|(
name|client
argument_list|,
name|CLSET_TIMEOUT
argument_list|,
operator|&
name|retry_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|3
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Created CLIENT* for %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|host_addr
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|client
return|;
block|}
end_function

begin_comment
comment|/* transmit_result --------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Transmit result for nlm_xxx_msg pseudo-RPCs    Returns:	Nothing - we have no idea if the datagram got there    Notes:	clnt_call() will always fail (with timeout) as we are 		calling it with timeout 0 as a hack to just issue a datagram 		without expecting a result */
end_comment

begin_function
specifier|static
name|void
name|transmit_result
parameter_list|(
name|int
name|opcode
parameter_list|,
name|nlm_res
modifier|*
name|result
parameter_list|,
name|struct
name|svc_req
modifier|*
name|req
parameter_list|)
block|{
specifier|static
name|char
name|dummy
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
name|CLIENT
modifier|*
name|cli
decl_stmt|;
name|int
name|success
decl_stmt|;
name|struct
name|timeval
name|timeo
decl_stmt|;
name|addr
operator|=
name|svc_getcaller
argument_list|(
name|req
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cli
operator|=
name|get_client
argument_list|(
name|addr
argument_list|)
operator|)
condition|)
block|{
name|timeo
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|/* No timeout - not expecting response	*/
name|timeo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|opcode
argument_list|,
name|xdr_nlm_res
argument_list|,
name|result
argument_list|,
name|xdr_void
argument_list|,
operator|&
name|dummy
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|2
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"clnt_call returns %d\n"
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Functions for Unix<->Unix locking (ie. monitored locking, with rpc.statd    involved to ensure reclaim of locks after a crash of the "stateless"    server.     These all come in two flavours - nlm_xxx() and nlm_xxx_msg().    The first are standard RPCs with argument and result.    The nlm_xxx_msg() calls implement exactly the same functions, but    use two pseudo-RPCs (one in each direction).  These calls are NOT    standard use of the RPC protocol in that they do not return a result    at all (NB. this is quite different from returning a void result).    The effect of this is to make the nlm_xxx_msg() calls simple unacknowledged    datagrams, requiring higher-level code to perform retries.     Despite the disadvantages of the nlm_xxx_msg() approach (some of which    are documented in the comments to get_client() above), this is the    interface used by all current commercial NFS implementations    [Solaris, SCO, AIX etc.].  This is presumed to be because these allow    implementations to continue using the standard RPC libraries, while    avoiding the block-until-result nature of the library interface.     No client implementations have been identified so far that make use    of the true RPC version (early SunOS releases would be a likely candidate    for testing). */
end_comment

begin_comment
comment|/* nlm_test ---------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Test whether a specified lock would be granted if requested    Returns:	nlm_granted (or error code)    Notes: */
end_comment

begin_function
name|nlm_testres
modifier|*
name|nlm_test_1_svc
parameter_list|(
name|nlm_testargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nlm_testres
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_test"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
comment|/* Copy the cookie from the argument into the result.  Note that this	*/
comment|/* is slightly hazardous, as the structure contains a pointer to a	*/
comment|/* malloc()ed buffer that will get freed by the caller.  However, the	*/
comment|/* main function transmits the result before freeing the argument	*/
comment|/* so it is in fact safe.						*/
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm_test_msg_1_svc
parameter_list|(
name|nlm_testargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
name|nlm_testres
name|res
decl_stmt|;
specifier|static
name|char
name|dummy
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
name|CLIENT
modifier|*
name|cli
decl_stmt|;
name|int
name|success
decl_stmt|;
name|struct
name|timeval
name|timeo
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_test_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
comment|/* nlm_test has different result type to the other operations, so	*/
comment|/* can't use transmit_result() in this case				*/
name|addr
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cli
operator|=
name|get_client
argument_list|(
name|addr
argument_list|)
operator|)
condition|)
block|{
name|timeo
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|/* No timeout - not expecting response	*/
name|timeo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|NLM_TEST_RES
argument_list|,
name|xdr_nlm_testres
argument_list|,
operator|&
name|res
argument_list|,
name|xdr_void
argument_list|,
operator|&
name|dummy
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|2
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"clnt_call returns %d\n"
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_lock ---------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purposes:	Establish a lock    Returns:	granted, denied or blocked    Notes:	*** grace period support missing */
end_comment

begin_function
name|nlm_res
modifier|*
name|nlm_lock_1_svc
parameter_list|(
name|nlm_lockargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_lock"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
comment|/* copy cookie from arg to result.  See comment in nlm_test_1()	*/
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm_lock_msg_1_svc
parameter_list|(
name|nlm_lockargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_lock_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
name|transmit_result
argument_list|(
name|NLM_LOCK_RES
argument_list|,
operator|&
name|res
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_cancel -------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Cancel a blocked lock request    Returns:	granted or denied    Notes: */
end_comment

begin_function
name|nlm_res
modifier|*
name|nlm_cancel_1_svc
parameter_list|(
name|nlm_cancargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_cancel"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
comment|/* copy cookie from arg to result.  See comment in nlm_test_1()	*/
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
comment|/* Since at present we never return 'nlm_blocked', there can never be	*/
comment|/* a lock to cancel, so this call always fails.			*/
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_denied
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm_cancel_msg_1_svc
parameter_list|(
name|nlm_cancargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_cancel_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
comment|/* Since at present we never return 'nlm_blocked', there can never be	*/
comment|/* a lock to cancel, so this call always fails.			*/
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_denied
expr_stmt|;
name|transmit_result
argument_list|(
name|NLM_CANCEL_RES
argument_list|,
operator|&
name|res
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_unlock -------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Release an existing lock    Returns:	Always granted, unless during grace period    Notes:	"no such lock" error condition is ignored, as the 		protocol uses unreliable UDP datagrams, and may well 		re-try an unlock that has already succeeded. */
end_comment

begin_function
name|nlm_res
modifier|*
name|nlm_unlock_1_svc
parameter_list|(
name|nlm_unlockargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_unlock"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm_unlock_msg_1_svc
parameter_list|(
name|nlm_unlockargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_unlock_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|transmit_result
argument_list|(
name|NLM_UNLOCK_RES
argument_list|,
operator|&
name|res
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Client-side pseudo-RPCs for results.  Note that for the client there    are only nlm_xxx_msg() versions of each call, since the 'real RPC'    version returns the results in the RPC result, and so the client    does not normally receive incoming RPCs.     The exception to this is nlm_granted(), which is genuinely an RPC    call from the server to the client - a 'call-back' in normal procedure    call terms. */
end_comment

begin_comment
comment|/* nlm_granted ------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Receive notification that formerly blocked lock now granted    Returns:	always success ('granted')    Notes:	 */
end_comment

begin_function
name|nlm_res
modifier|*
name|nlm_granted_1_svc
parameter_list|(
name|nlm_testargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_granted"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
comment|/* copy cookie from arg to result.  See comment in nlm_test_1()	*/
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm_granted_msg_1_svc
parameter_list|(
name|nlm_testargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_granted_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
name|transmit_result
argument_list|(
name|NLM_GRANTED_RES
argument_list|,
operator|&
name|res
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_test_res ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*    Purpose:	Accept result from earlier nlm_test_msg() call    Returns:	Nothing */
end_comment

begin_function
name|void
modifier|*
name|nlm_test_res_1_svc
parameter_list|(
name|nlm_testres
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_test_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_lock_res ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*    Purpose:	Accept result from earlier nlm_lock_msg() call    Returns:	Nothing */
end_comment

begin_function
name|void
modifier|*
name|nlm_lock_res_1_svc
parameter_list|(
name|nlm_res
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_lock_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_cancel_res ---------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Accept result from earlier nlm_cancel_msg() call    Returns:	Nothing */
end_comment

begin_function
name|void
modifier|*
name|nlm_cancel_res_1_svc
parameter_list|(
name|nlm_res
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_cancel_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_unlock_res ---------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Accept result from earlier nlm_unlock_msg() call    Returns:	Nothing */
end_comment

begin_function
name|void
modifier|*
name|nlm_unlock_res_1_svc
parameter_list|(
name|nlm_res
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_unlock_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_granted_res --------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Accept result from earlier nlm_granted_msg() call    Returns:	Nothing */
end_comment

begin_function
name|void
modifier|*
name|nlm_granted_res_1_svc
parameter_list|(
name|nlm_res
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_granted_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Calls for PCNFS locking (aka non-monitored locking, no involvement    of rpc.statd).     These are all genuine RPCs - no nlm_xxx_msg() nonsense here. */
end_comment

begin_comment
comment|/* nlm_share --------------------------------------------------------------- */
end_comment

begin_comment
comment|/*    Purpose:	Establish a DOS-style lock    Returns:	success or failure    Notes:	Blocking locks are not supported - client is expected 		to retry if required. */
end_comment

begin_function
name|nlm_shareres
modifier|*
name|nlm_share_3_svc
parameter_list|(
name|nlm_shareargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nlm_shareres
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_share"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
name|res
operator|.
name|sequence
operator|=
literal|1234356
expr_stmt|;
comment|/* X/Open says this field is ignored?	*/
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_unshare ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*    Purpose:	Release a DOS-style lock    Returns:	nlm_granted, unless in grace period    Notes: */
end_comment

begin_function
name|nlm_shareres
modifier|*
name|nlm_unshare_3_svc
parameter_list|(
name|nlm_shareargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nlm_shareres
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_unshare"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
name|res
operator|.
name|sequence
operator|=
literal|1234356
expr_stmt|;
comment|/* X/Open says this field is ignored?	*/
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_nm_lock ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*    Purpose:	non-monitored version of nlm_lock()    Returns:	as for nlm_lock()    Notes:	These locks are in the same style as the standard nlm_lock, 		but the rpc.statd should not be called to establish a 		monitor for the client machine, since that machine is 		declared not to be running a rpc.statd, and so would not 		respond to the statd protocol. */
end_comment

begin_function
name|nlm_res
modifier|*
name|nlm_nm_lock_3_svc
parameter_list|(
name|nlm_lockargs
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_nm_lock"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
comment|/* copy cookie from arg to result.  See comment in nlm_test_1()	*/
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_free_all ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*    Purpose:	Release all locks held by a named client    Returns:	Nothing    Notes:	Potential denial of service security problem here - the 		locks to be released are specified by a host name, independent 		of the address from which the request has arrived. 		Should probably be rejected if the named host has been 		using monitored locks. */
end_comment

begin_function
name|void
modifier|*
name|nlm_free_all_3_svc
parameter_list|(
name|nlm_notify
modifier|*
name|arg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
name|dummy
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_free_all"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|dummy
operator|)
return|;
block|}
end_function

end_unit

