begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: lock_proc.c,v 1.7 2000/10/11 20:23:56 is Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1995  *	A.R. Gordon (andrew.gordon@net-tel.co.uk).  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed for the FreeBSD project  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ANDREW GORDON AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: lock_proc.c,v 1.7 2000/10/11 20:23:56 is Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<netconfig.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/sm_inter.h>
end_include

begin_include
include|#
directive|include
file|"lockd.h"
end_include

begin_include
include|#
directive|include
file|<rpcsvc/nlm_prot.h>
end_include

begin_include
include|#
directive|include
file|"lockd_lock.h"
end_include

begin_define
define|#
directive|define
name|CLIENT_CACHE_SIZE
value|64
end_define

begin_comment
comment|/* No. of client sockets cached */
end_comment

begin_define
define|#
directive|define
name|CLIENT_CACHE_LIFETIME
value|120
end_define

begin_comment
comment|/* In seconds */
end_comment

begin_function_decl
specifier|static
name|void
name|log_from_addr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|svc_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|log_netobj
parameter_list|(
name|netobj
modifier|*
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addrcmp
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* log_from_addr ----------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Log name of function called and source address  * Returns:	Nothing  * Notes:	Extracts the source address from the transport handle  *		passed in as part of the called procedure specification  */
end_comment

begin_function
specifier|static
name|void
name|log_from_addr
parameter_list|(
name|fun_name
parameter_list|,
name|req
parameter_list|)
specifier|const
name|char
modifier|*
name|fun_name
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|req
decl_stmt|;
block|{
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|char
name|hostname_buf
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
name|addr
operator|=
name|svc_getrpccaller
argument_list|(
name|req
operator|->
name|rq_xprt
argument_list|)
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|getnameinfo
argument_list|(
name|addr
argument_list|,
name|addr
operator|->
name|sa_len
argument_list|,
name|hostname_buf
argument_list|,
sizeof|sizeof
name|hostname_buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s from %s"
argument_list|,
name|fun_name
argument_list|,
name|hostname_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* log_netobj ----------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Log a netobj  * Returns:	Nothing  * Notes:	This function should only really be called as part of  *  		a debug subsystem. */
end_comment

begin_function
specifier|static
name|void
name|log_netobj
parameter_list|(
name|obj
parameter_list|)
name|netobj
modifier|*
name|obj
decl_stmt|;
block|{
name|char
name|objvalbuffer
index|[
operator|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|2
operator|)
operator|*
name|MAX_NETOBJ_SZ
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|objascbuffer
index|[
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|MAX_NETOBJ_SZ
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|maxlen
decl_stmt|;
name|char
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
comment|/* Notify of potential security attacks */
if|if
condition|(
name|obj
operator|->
name|n_len
operator|>
name|MAX_NETOBJ_SZ
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"SOMEONE IS TRYING TO DO SOMETHING NASTY!\n"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"netobj too large! Should be %d was %d\n"
argument_list|,
name|MAX_NETOBJ_SZ
argument_list|,
name|obj
operator|->
name|n_len
argument_list|)
expr_stmt|;
block|}
comment|/* Prevent the security hazard from the buffer overflow */
name|maxlen
operator|=
operator|(
name|obj
operator|->
name|n_len
operator|<
name|MAX_NETOBJ_SZ
condition|?
name|obj
operator|->
name|n_len
else|:
name|MAX_NETOBJ_SZ
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmp1
operator|=
name|objvalbuffer
operator|,
name|tmp2
operator|=
name|objascbuffer
init|;
name|i
operator|<
name|obj
operator|->
name|n_len
condition|;
name|i
operator|++
operator|,
name|tmp1
operator|+=
literal|2
operator|,
name|tmp2
operator|+=
literal|1
control|)
block|{
name|sprintf
argument_list|(
name|tmp1
argument_list|,
literal|"%02X"
argument_list|,
operator|*
operator|(
name|obj
operator|->
name|n_bytes
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp2
argument_list|,
literal|"%c"
argument_list|,
operator|*
operator|(
name|obj
operator|->
name|n_bytes
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|tmp1
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|tmp2
operator|=
literal|'\0'
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"netobjvals: %s\n"
argument_list|,
name|objvalbuffer
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"netobjascs: %s\n"
argument_list|,
name|objascbuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get_client -------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Get a CLIENT* for making RPC calls to lockd on given host  * Returns:	CLIENT* pointer, from clnt_udp_create, or NULL if error  * Notes:	Creating a CLIENT* is quite expensive, involving a  *		conversation with the remote portmapper to get the  *		port number.  Since a given client is quite likely  *		to make several locking requests in succession, it is  *		desirable to cache the created CLIENT*.  *  *		Since we are using UDP rather than TCP, there is no cost  *		to the remote system in keeping these cached indefinitely.  *		Unfortunately there is a snag: if the remote system  *		reboots, the cached portmapper results will be invalid,  *		and we will never detect this since all of the xxx_msg()  *		calls return no result - we just fire off a udp packet  *		and hope for the best.  *  *		We solve this by discarding cached values after two  *		minutes, regardless of whether they have been used  *		in the meanwhile (since a bad one might have been used  *		plenty of times, as the host keeps retrying the request  *		and we keep sending the reply back to the wrong port).  *  *		Given that the entries will always expire in the order  *		that they were created, there is no point in a LRU  *		algorithm for when the cache gets full - entries are  *		always re-used in sequence.  */
end_comment

begin_decl_stmt
specifier|static
name|CLIENT
modifier|*
name|clnt_cache_ptr
index|[
name|CLIENT_CACHE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|clnt_cache_time
index|[
name|CLIENT_CACHE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time entry created */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_storage
name|clnt_cache_addr
index|[
name|CLIENT_CACHE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rpcvers_t
name|clnt_cache_vers
index|[
name|CLIENT_CACHE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|clnt_cache_next_to_use
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|addrcmp
parameter_list|(
name|sa1
parameter_list|,
name|sa2
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|sa1
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa2
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|void
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|!=
name|sa2
operator|->
name|sa_family
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|sa1
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|p1
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa1
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|p2
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa2
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|p1
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa1
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|p2
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa2
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|len
operator|=
literal|16
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
name|memcmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|CLIENT
modifier|*
name|get_client
parameter_list|(
name|host_addr
parameter_list|,
name|vers
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|host_addr
decl_stmt|;
name|rpcvers_t
name|vers
decl_stmt|;
block|{
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|struct
name|timeval
name|retry_time
decl_stmt|,
name|time_now
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|netid
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|nconf
decl_stmt|;
name|char
name|host
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|time_now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Search for the given client in the cache, zapping any expired 	 * entries that we happen to notice in passing. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CLIENT_CACHE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|client
operator|=
name|clnt_cache_ptr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|client
operator|&&
operator|(
operator|(
name|clnt_cache_time
index|[
name|i
index|]
operator|+
name|CLIENT_CACHE_LIFETIME
operator|)
operator|<
name|time_now
operator|.
name|tv_sec
operator|)
condition|)
block|{
comment|/* Cache entry has expired. */
if|if
condition|(
name|debug_level
operator|>
literal|3
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Expired CLIENT* in cache"
argument_list|)
expr_stmt|;
name|clnt_cache_time
index|[
name|i
index|]
operator|=
literal|0L
expr_stmt|;
name|clnt_destroy
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|clnt_cache_ptr
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|client
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|client
operator|&&
operator|!
name|addrcmp
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|clnt_cache_addr
index|[
name|i
index|]
argument_list|,
name|host_addr
argument_list|)
operator|&&
name|clnt_cache_vers
index|[
name|i
index|]
operator|==
name|vers
condition|)
block|{
comment|/* Found it! */
if|if
condition|(
name|debug_level
operator|>
literal|3
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Found CLIENT* in cache"
argument_list|)
expr_stmt|;
return|return
operator|(
name|client
operator|)
return|;
block|}
block|}
if|if
condition|(
name|debug_level
operator|>
literal|3
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"CLIENT* not found in cache, creating"
argument_list|)
expr_stmt|;
comment|/* Not found in cache.  Free the next entry if it is in use. */
if|if
condition|(
name|clnt_cache_ptr
index|[
name|clnt_cache_next_to_use
index|]
condition|)
block|{
name|clnt_destroy
argument_list|(
name|clnt_cache_ptr
index|[
name|clnt_cache_next_to_use
index|]
argument_list|)
expr_stmt|;
name|clnt_cache_ptr
index|[
name|clnt_cache_next_to_use
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Need a host string for clnt_tp_create. Use NI_NUMERICHOST 	 * to avoid DNS lookups. 	 */
if|if
condition|(
name|getnameinfo
argument_list|(
name|host_addr
argument_list|,
name|host_addr
operator|->
name|sa_len
argument_list|,
name|host
argument_list|,
sizeof|sizeof
name|host
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to get name string for caller"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|#
directive|if
literal|1
if|if
condition|(
name|host_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|netid
operator|=
literal|"udp6"
expr_stmt|;
else|else
name|netid
operator|=
literal|"udp"
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|host_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|netid
operator|=
literal|"tcp6"
expr_stmt|;
else|else
name|netid
operator|=
literal|"tcp"
expr_stmt|;
endif|#
directive|endif
name|nconf
operator|=
name|getnetconfigent
argument_list|(
name|netid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nconf
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"could not get netconfig info for '%s': "
literal|"no /etc/netconfig file?"
argument_list|,
name|netid
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|client
operator|=
name|clnt_tp_create
argument_list|(
name|host
argument_list|,
name|NLM_PROG
argument_list|,
name|vers
argument_list|,
name|nconf
argument_list|)
expr_stmt|;
name|freenetconfigent
argument_list|(
name|nconf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s"
argument_list|,
name|clnt_spcreateerror
argument_list|(
literal|"clntudp_create"
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Unable to return result to %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Success - update the cache entry */
name|clnt_cache_ptr
index|[
name|clnt_cache_next_to_use
index|]
operator|=
name|client
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|clnt_cache_addr
index|[
name|clnt_cache_next_to_use
index|]
argument_list|,
name|host_addr
argument_list|,
name|host_addr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|clnt_cache_vers
index|[
name|clnt_cache_next_to_use
index|]
operator|=
name|vers
expr_stmt|;
name|clnt_cache_time
index|[
name|clnt_cache_next_to_use
index|]
operator|=
name|time_now
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|++
name|clnt_cache_next_to_use
operator|>
name|CLIENT_CACHE_SIZE
condition|)
name|clnt_cache_next_to_use
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Disable the default timeout, so we can specify our own in calls 	 * to clnt_call().  (Note that the timeout is a different concept 	 * from the retry period set in clnt_udp_create() above.) 	 */
name|retry_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|retry_time
operator|.
name|tv_usec
operator|=
operator|-
literal|1
expr_stmt|;
name|clnt_control
argument_list|(
name|client
argument_list|,
name|CLSET_TIMEOUT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|retry_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|3
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Created CLIENT* for %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
return|return
name|client
return|;
block|}
end_function

begin_comment
comment|/* transmit_result --------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Transmit result for nlm_xxx_msg pseudo-RPCs  * Returns:	Nothing - we have no idea if the datagram got there  * Notes:	clnt_call() will always fail (with timeout) as we are  *		calling it with timeout 0 as a hack to just issue a datagram  *		without expecting a result  */
end_comment

begin_function
name|void
name|transmit_result
parameter_list|(
name|opcode
parameter_list|,
name|result
parameter_list|,
name|addr
parameter_list|)
name|int
name|opcode
decl_stmt|;
name|nlm_res
modifier|*
name|result
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
block|{
specifier|static
name|char
name|dummy
decl_stmt|;
name|CLIENT
modifier|*
name|cli
decl_stmt|;
name|struct
name|timeval
name|timeo
decl_stmt|;
name|int
name|success
decl_stmt|;
if|if
condition|(
operator|(
name|cli
operator|=
name|get_client
argument_list|(
name|addr
argument_list|,
name|NLM_VERS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|timeo
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|/* No timeout - not expecting response */
name|timeo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|opcode
argument_list|,
name|xdr_nlm_res
argument_list|,
name|result
argument_list|,
name|xdr_void
argument_list|,
operator|&
name|dummy
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|2
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"clnt_call returns %d(%s)"
argument_list|,
name|success
argument_list|,
name|clnt_sperrno
argument_list|(
name|success
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* transmit4_result --------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Transmit result for nlm4_xxx_msg pseudo-RPCs  * Returns:	Nothing - we have no idea if the datagram got there  * Notes:	clnt_call() will always fail (with timeout) as we are  *		calling it with timeout 0 as a hack to just issue a datagram  *		without expecting a result  */
end_comment

begin_function
name|void
name|transmit4_result
parameter_list|(
name|opcode
parameter_list|,
name|result
parameter_list|,
name|addr
parameter_list|)
name|int
name|opcode
decl_stmt|;
name|nlm4_res
modifier|*
name|result
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
block|{
specifier|static
name|char
name|dummy
decl_stmt|;
name|CLIENT
modifier|*
name|cli
decl_stmt|;
name|struct
name|timeval
name|timeo
decl_stmt|;
name|int
name|success
decl_stmt|;
if|if
condition|(
operator|(
name|cli
operator|=
name|get_client
argument_list|(
name|addr
argument_list|,
name|NLM_VERS4
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|timeo
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|/* No timeout - not expecting response */
name|timeo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|opcode
argument_list|,
name|xdr_nlm4_res
argument_list|,
name|result
argument_list|,
name|xdr_void
argument_list|,
operator|&
name|dummy
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|2
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"clnt_call returns %d(%s)"
argument_list|,
name|success
argument_list|,
name|clnt_sperrno
argument_list|(
name|success
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * converts a struct nlm_lock to struct nlm4_lock  */
end_comment

begin_function_decl
specifier|static
name|void
name|nlmtonlm4
parameter_list|(
name|struct
name|nlm_lock
modifier|*
parameter_list|,
name|struct
name|nlm4_lock
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|nlmtonlm4
parameter_list|(
name|arg
parameter_list|,
name|arg4
parameter_list|)
name|struct
name|nlm_lock
modifier|*
name|arg
decl_stmt|;
name|struct
name|nlm4_lock
modifier|*
name|arg4
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|arg4
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|nlm_lock
argument_list|)
argument_list|)
expr_stmt|;
name|arg4
operator|->
name|l_offset
operator|=
name|arg
operator|->
name|l_offset
expr_stmt|;
name|arg4
operator|->
name|l_len
operator|=
name|arg
operator|->
name|l_len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Functions for Unix<->Unix locking (ie. monitored locking, with rpc.statd  * involved to ensure reclaim of locks after a crash of the "stateless"  * server.  *  * These all come in two flavours - nlm_xxx() and nlm_xxx_msg().  * The first are standard RPCs with argument and result.  * The nlm_xxx_msg() calls implement exactly the same functions, but  * use two pseudo-RPCs (one in each direction).  These calls are NOT  * standard use of the RPC protocol in that they do not return a result  * at all (NB. this is quite different from returning a void result).  * The effect of this is to make the nlm_xxx_msg() calls simple unacknowledged  * datagrams, requiring higher-level code to perform retries.  *  * Despite the disadvantages of the nlm_xxx_msg() approach (some of which  * are documented in the comments to get_client() above), this is the  * interface used by all current commercial NFS implementations  * [Solaris, SCO, AIX etc.].  This is presumed to be because these allow  * implementations to continue using the standard RPC libraries, while  * avoiding the block-until-result nature of the library interface.  *  * No client implementations have been identified so far that make use  * of the true RPC version (early SunOS releases would be a likely candidate  * for testing).  */
end_comment

begin_comment
comment|/* nlm_test ---------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Test whether a specified lock would be granted if requested  * Returns:	nlm_granted (or error code)  * Notes:  */
end_comment

begin_function
name|nlm_testres
modifier|*
name|nlm_test_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_testargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_testres
name|res
decl_stmt|;
name|struct
name|nlm4_lock
name|arg4
decl_stmt|;
name|struct
name|nlm4_holder
modifier|*
name|holder
decl_stmt|;
name|nlmtonlm4
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
operator|&
name|arg4
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_test"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|holder
operator|=
name|testlock
argument_list|(
operator|&
name|arg4
argument_list|,
name|arg
operator|->
name|exclusive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the cookie from the argument into the result.  Note that this 	 * is slightly hazardous, as the structure contains a pointer to a 	 * malloc()ed buffer that will get freed by the caller.  However, the 	 * main function transmits the result before freeing the argument 	 * so it is in fact safe. 	 */
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
if|if
condition|(
name|holder
operator|==
name|NULL
condition|)
block|{
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_denied
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|res
operator|.
name|stat
operator|.
name|nlm_testrply_u
operator|.
name|holder
argument_list|,
name|holder
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlm_holder
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|nlm_testrply_u
operator|.
name|holder
operator|.
name|l_offset
operator|=
name|holder
operator|->
name|l_offset
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|nlm_testrply_u
operator|.
name|holder
operator|.
name|l_len
operator|=
name|holder
operator|->
name|l_len
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm_test_msg_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_testargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
name|nlm_testres
name|res
decl_stmt|;
specifier|static
name|char
name|dummy
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|CLIENT
modifier|*
name|cli
decl_stmt|;
name|int
name|success
decl_stmt|;
name|struct
name|timeval
name|timeo
decl_stmt|;
name|struct
name|nlm4_lock
name|arg4
decl_stmt|;
name|struct
name|nlm4_holder
modifier|*
name|holder
decl_stmt|;
name|nlmtonlm4
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
operator|&
name|arg4
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_test_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|holder
operator|=
name|testlock
argument_list|(
operator|&
name|arg4
argument_list|,
name|arg
operator|->
name|exclusive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
if|if
condition|(
name|holder
operator|==
name|NULL
condition|)
block|{
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_denied
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|res
operator|.
name|stat
operator|.
name|nlm_testrply_u
operator|.
name|holder
argument_list|,
name|holder
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlm_holder
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|nlm_testrply_u
operator|.
name|holder
operator|.
name|l_offset
operator|=
name|holder
operator|->
name|l_offset
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|nlm_testrply_u
operator|.
name|holder
operator|.
name|l_len
operator|=
name|holder
operator|->
name|l_len
expr_stmt|;
block|}
comment|/* 	 * nlm_test has different result type to the other operations, so 	 * can't use transmit_result() in this case 	 */
name|addr
operator|=
name|svc_getrpccaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
operator|->
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|cli
operator|=
name|get_client
argument_list|(
name|addr
argument_list|,
name|NLM_VERS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|timeo
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|/* No timeout - not expecting response */
name|timeo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|NLM_TEST_RES
argument_list|,
name|xdr_nlm_testres
argument_list|,
operator|&
name|res
argument_list|,
name|xdr_void
argument_list|,
operator|&
name|dummy
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|2
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"clnt_call returns %d"
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_lock ---------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purposes:	Establish a lock  * Returns:	granted, denied or blocked  * Notes:	*** grace period support missing  */
end_comment

begin_function
name|nlm_res
modifier|*
name|nlm_lock_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_lockargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
name|struct
name|nlm4_lockargs
name|arg4
decl_stmt|;
name|nlmtonlm4
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
operator|&
name|arg4
operator|.
name|alock
argument_list|)
expr_stmt|;
name|arg4
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|arg4
operator|.
name|block
operator|=
name|arg
operator|->
name|block
expr_stmt|;
name|arg4
operator|.
name|exclusive
operator|=
name|arg
operator|->
name|exclusive
expr_stmt|;
name|arg4
operator|.
name|reclaim
operator|=
name|arg
operator|->
name|reclaim
expr_stmt|;
name|arg4
operator|.
name|state
operator|=
name|arg
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_lock"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
comment|/* copy cookie from arg to result.  See comment in nlm_test_1() */
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|getlock
argument_list|(
operator|&
name|arg4
argument_list|,
name|rqstp
argument_list|,
name|LOCK_MON
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm_lock_msg_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_lockargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
name|struct
name|nlm4_lockargs
name|arg4
decl_stmt|;
name|nlmtonlm4
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
operator|&
name|arg4
operator|.
name|alock
argument_list|)
expr_stmt|;
name|arg4
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|arg4
operator|.
name|block
operator|=
name|arg
operator|->
name|block
expr_stmt|;
name|arg4
operator|.
name|exclusive
operator|=
name|arg
operator|->
name|exclusive
expr_stmt|;
name|arg4
operator|.
name|reclaim
operator|=
name|arg
operator|->
name|reclaim
expr_stmt|;
name|arg4
operator|.
name|state
operator|=
name|arg
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_lock_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|getlock
argument_list|(
operator|&
name|arg4
argument_list|,
name|rqstp
argument_list|,
name|LOCK_ASYNC
operator||
name|LOCK_MON
argument_list|)
expr_stmt|;
name|transmit_result
argument_list|(
name|NLM_LOCK_RES
argument_list|,
operator|&
name|res
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_cancel -------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Cancel a blocked lock request  * Returns:	granted or denied  * Notes:  */
end_comment

begin_function
name|nlm_res
modifier|*
name|nlm_cancel_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_cancargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
name|struct
name|nlm4_lock
name|arg4
decl_stmt|;
name|nlmtonlm4
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
operator|&
name|arg4
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_cancel"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
comment|/* copy cookie from arg to result.  See comment in nlm_test_1() */
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
comment|/* 	 * Since at present we never return 'nlm_blocked', there can never be 	 * a lock to cancel, so this call always fails. 	 */
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|unlock
argument_list|(
operator|&
name|arg4
argument_list|,
name|LOCK_CANCEL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm_cancel_msg_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_cancargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
name|struct
name|nlm4_lock
name|arg4
decl_stmt|;
name|nlmtonlm4
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
operator|&
name|arg4
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_cancel_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
comment|/* 	 * Since at present we never return 'nlm_blocked', there can never be 	 * a lock to cancel, so this call always fails. 	 */
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|unlock
argument_list|(
operator|&
name|arg4
argument_list|,
name|LOCK_CANCEL
argument_list|)
expr_stmt|;
name|transmit_result
argument_list|(
name|NLM_CANCEL_RES
argument_list|,
operator|&
name|res
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_unlock -------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Release an existing lock  * Returns:	Always granted, unless during grace period  * Notes:	"no such lock" error condition is ignored, as the  *		protocol uses unreliable UDP datagrams, and may well  *		re-try an unlock that has already succeeded.  */
end_comment

begin_function
name|nlm_res
modifier|*
name|nlm_unlock_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_unlockargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
name|struct
name|nlm4_lock
name|arg4
decl_stmt|;
name|nlmtonlm4
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
operator|&
name|arg4
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_unlock"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|unlock
argument_list|(
operator|&
name|arg4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm_unlock_msg_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_unlockargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
name|struct
name|nlm4_lock
name|arg4
decl_stmt|;
name|nlmtonlm4
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
operator|&
name|arg4
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_unlock_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|unlock
argument_list|(
operator|&
name|arg4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|transmit_result
argument_list|(
name|NLM_UNLOCK_RES
argument_list|,
operator|&
name|res
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Client-side pseudo-RPCs for results.  Note that for the client there  * are only nlm_xxx_msg() versions of each call, since the 'real RPC'  * version returns the results in the RPC result, and so the client  * does not normally receive incoming RPCs.  *  * The exception to this is nlm_granted(), which is genuinely an RPC  * call from the server to the client - a 'call-back' in normal procedure  * call terms.  */
end_comment

begin_comment
comment|/* nlm_granted ------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Receive notification that formerly blocked lock now granted  * Returns:	always success ('granted')  * Notes:  */
end_comment

begin_function
name|nlm_res
modifier|*
name|nlm_granted_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_testargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_granted"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|lock_answer
argument_list|(
name|arg
operator|->
name|alock
operator|.
name|svid
argument_list|,
operator|&
name|arg
operator|->
name|cookie
argument_list|,
name|nlm_granted
argument_list|,
name|NULL
argument_list|,
name|NLM_VERS
argument_list|)
operator|==
literal|0
condition|?
name|nlm_granted
else|:
name|nlm_denied
expr_stmt|;
comment|/* copy cookie from arg to result.  See comment in nlm_test_1() */
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm_granted_msg_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_testargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_granted_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
name|transmit_result
argument_list|(
name|NLM_GRANTED_RES
argument_list|,
operator|&
name|res
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_test_res ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Purpose:	Accept result from earlier nlm_test_msg() call  * Returns:	Nothing  */
end_comment

begin_function
name|void
modifier|*
name|nlm_test_res_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_testres
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_test_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lock_answer
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|arg
operator|->
name|cookie
argument_list|,
name|arg
operator|->
name|stat
operator|.
name|stat
argument_list|,
operator|&
name|arg
operator|->
name|stat
operator|.
name|nlm_testrply_u
operator|.
name|holder
operator|.
name|svid
argument_list|,
name|NLM_VERS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_lock_res ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Purpose:	Accept result from earlier nlm_lock_msg() call  * Returns:	Nothing  */
end_comment

begin_function
name|void
modifier|*
name|nlm_lock_res_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_res
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_lock_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lock_answer
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|arg
operator|->
name|cookie
argument_list|,
name|arg
operator|->
name|stat
operator|.
name|stat
argument_list|,
name|NULL
argument_list|,
name|NLM_VERS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_cancel_res ---------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Accept result from earlier nlm_cancel_msg() call  * Returns:	Nothing  */
end_comment

begin_function
name|void
modifier|*
name|nlm_cancel_res_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_res
modifier|*
name|arg
name|__unused
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_cancel_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_unlock_res ---------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Accept result from earlier nlm_unlock_msg() call  * Returns:	Nothing  */
end_comment

begin_function
name|void
modifier|*
name|nlm_unlock_res_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_res
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_unlock_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|lock_answer
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|arg
operator|->
name|cookie
argument_list|,
name|arg
operator|->
name|stat
operator|.
name|stat
argument_list|,
name|NULL
argument_list|,
name|NLM_VERS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_granted_res --------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Accept result from earlier nlm_granted_msg() call  * Returns:	Nothing  */
end_comment

begin_function
name|void
modifier|*
name|nlm_granted_res_1_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_res
modifier|*
name|arg
name|__unused
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_granted_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Calls for PCNFS locking (aka non-monitored locking, no involvement  * of rpc.statd).  *  * These are all genuine RPCs - no nlm_xxx_msg() nonsense here.  */
end_comment

begin_comment
comment|/* nlm_share --------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Establish a DOS-style lock  * Returns:	success or failure  * Notes:	Blocking locks are not supported - client is expected  *		to retry if required.  */
end_comment

begin_function
name|nlm_shareres
modifier|*
name|nlm_share_3_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_shareargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_shareres
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_share"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
name|res
operator|.
name|sequence
operator|=
literal|1234356
expr_stmt|;
comment|/* X/Open says this field is ignored? */
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_unshare ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Purpose:	Release a DOS-style lock  * Returns:	nlm_granted, unless in grace period  * Notes:  */
end_comment

begin_function
name|nlm_shareres
modifier|*
name|nlm_unshare_3_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_shareargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_shareres
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_unshare"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
name|res
operator|.
name|sequence
operator|=
literal|1234356
expr_stmt|;
comment|/* X/Open says this field is ignored? */
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_nm_lock ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Purpose:	non-monitored version of nlm_lock()  * Returns:	as for nlm_lock()  * Notes:	These locks are in the same style as the standard nlm_lock,  *		but the rpc.statd should not be called to establish a  *		monitor for the client machine, since that machine is  *		declared not to be running a rpc.statd, and so would not  *		respond to the statd protocol.  */
end_comment

begin_function
name|nlm_res
modifier|*
name|nlm_nm_lock_3_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_lockargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_nm_lock"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
comment|/* copy cookie from arg to result.  See comment in nlm_test_1() */
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm_granted
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_free_all ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Purpose:	Release all locks held by a named client  * Returns:	Nothing  * Notes:	Potential denial of service security problem here - the  *		locks to be released are specified by a host name, independent  *		of the address from which the request has arrived.  *		Should probably be rejected if the named host has been  *		using monitored locks.  */
end_comment

begin_function
name|void
modifier|*
name|nlm_free_all_3_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm_notify
modifier|*
name|arg
name|__unused
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|char
name|dummy
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_free_all"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|dummy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* calls for nlm version 4 (NFSv3) */
end_comment

begin_comment
comment|/* nlm_test ---------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Test whether a specified lock would be granted if requested  * Returns:	nlm_granted (or error code)  * Notes:  */
end_comment

begin_function
name|nlm4_testres
modifier|*
name|nlm4_test_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_testargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_testres
name|res
decl_stmt|;
name|struct
name|nlm4_holder
modifier|*
name|holder
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_test"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|5
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Locking arguments:\n"
argument_list|)
expr_stmt|;
name|log_netobj
argument_list|(
operator|&
operator|(
name|arg
operator|->
name|cookie
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Alock arguments:\n"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Caller Name: %s\n"
argument_list|,
name|arg
operator|->
name|alock
operator|.
name|caller_name
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"File Handle:\n"
argument_list|)
expr_stmt|;
name|log_netobj
argument_list|(
operator|&
operator|(
name|arg
operator|->
name|alock
operator|.
name|fh
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Owner Handle:\n"
argument_list|)
expr_stmt|;
name|log_netobj
argument_list|(
operator|&
operator|(
name|arg
operator|->
name|alock
operator|.
name|oh
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"SVID:        %d\n"
argument_list|,
name|arg
operator|->
name|alock
operator|.
name|svid
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Lock Offset: %llu\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|arg
operator|->
name|alock
operator|.
name|l_offset
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Lock Length: %llu\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|arg
operator|->
name|alock
operator|.
name|l_len
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Exclusive:   %s\n"
argument_list|,
operator|(
name|arg
operator|->
name|exclusive
condition|?
literal|"true"
else|:
literal|"false"
operator|)
argument_list|)
expr_stmt|;
block|}
name|holder
operator|=
name|testlock
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
name|arg
operator|->
name|exclusive
argument_list|,
name|LOCK_V4
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the cookie from the argument into the result.  Note that this 	 * is slightly hazardous, as the structure contains a pointer to a 	 * malloc()ed buffer that will get freed by the caller.  However, the 	 * main function transmits the result before freeing the argument 	 * so it is in fact safe. 	 */
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
if|if
condition|(
name|holder
operator|==
name|NULL
condition|)
block|{
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm4_granted
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|res
operator|.
name|stat
operator|.
name|nlm4_testrply_u
operator|.
name|holder
argument_list|,
name|holder
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlm4_holder
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm4_test_msg_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_testargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
name|nlm4_testres
name|res
decl_stmt|;
specifier|static
name|char
name|dummy
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|CLIENT
modifier|*
name|cli
decl_stmt|;
name|int
name|success
decl_stmt|;
name|struct
name|timeval
name|timeo
decl_stmt|;
name|struct
name|nlm4_holder
modifier|*
name|holder
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_test_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|holder
operator|=
name|testlock
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
name|arg
operator|->
name|exclusive
argument_list|,
name|LOCK_V4
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
if|if
condition|(
name|holder
operator|==
name|NULL
condition|)
block|{
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm4_granted
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|res
operator|.
name|stat
operator|.
name|nlm4_testrply_u
operator|.
name|holder
argument_list|,
name|holder
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlm4_holder
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * nlm_test has different result type to the other operations, so 	 * can't use transmit4_result() in this case 	 */
name|addr
operator|=
name|svc_getrpccaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
operator|->
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|cli
operator|=
name|get_client
argument_list|(
name|addr
argument_list|,
name|NLM_VERS4
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|timeo
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|/* No timeout - not expecting response */
name|timeo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|NLM4_TEST_RES
argument_list|,
name|xdr_nlm4_testres
argument_list|,
operator|&
name|res
argument_list|,
name|xdr_void
argument_list|,
operator|&
name|dummy
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|2
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"clnt_call returns %d"
argument_list|,
name|success
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_lock ---------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purposes:	Establish a lock  * Returns:	granted, denied or blocked  * Notes:	*** grace period support missing  */
end_comment

begin_function
name|nlm4_res
modifier|*
name|nlm4_lock_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_lockargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_lock"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|5
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Locking arguments:\n"
argument_list|)
expr_stmt|;
name|log_netobj
argument_list|(
operator|&
operator|(
name|arg
operator|->
name|cookie
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Alock arguments:\n"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Caller Name: %s\n"
argument_list|,
name|arg
operator|->
name|alock
operator|.
name|caller_name
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"File Handle:\n"
argument_list|)
expr_stmt|;
name|log_netobj
argument_list|(
operator|&
operator|(
name|arg
operator|->
name|alock
operator|.
name|fh
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Owner Handle:\n"
argument_list|)
expr_stmt|;
name|log_netobj
argument_list|(
operator|&
operator|(
name|arg
operator|->
name|alock
operator|.
name|oh
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"SVID:        %d\n"
argument_list|,
name|arg
operator|->
name|alock
operator|.
name|svid
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Lock Offset: %llu\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|arg
operator|->
name|alock
operator|.
name|l_offset
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Lock Length: %llu\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|arg
operator|->
name|alock
operator|.
name|l_len
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Block:       %s\n"
argument_list|,
operator|(
name|arg
operator|->
name|block
condition|?
literal|"true"
else|:
literal|"false"
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Exclusive:   %s\n"
argument_list|,
operator|(
name|arg
operator|->
name|exclusive
condition|?
literal|"true"
else|:
literal|"false"
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Reclaim:     %s\n"
argument_list|,
operator|(
name|arg
operator|->
name|reclaim
condition|?
literal|"true"
else|:
literal|"false"
operator|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"State num:   %d\n"
argument_list|,
name|arg
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
comment|/* copy cookie from arg to result.  See comment in nlm_test_4() */
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|getlock
argument_list|(
name|arg
argument_list|,
name|rqstp
argument_list|,
name|LOCK_MON
operator||
name|LOCK_V4
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm4_lock_msg_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_lockargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_lock_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|getlock
argument_list|(
name|arg
argument_list|,
name|rqstp
argument_list|,
name|LOCK_MON
operator||
name|LOCK_ASYNC
operator||
name|LOCK_V4
argument_list|)
expr_stmt|;
name|transmit4_result
argument_list|(
name|NLM4_LOCK_RES
argument_list|,
operator|&
name|res
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_cancel -------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Cancel a blocked lock request  * Returns:	granted or denied  * Notes:  */
end_comment

begin_function
name|nlm4_res
modifier|*
name|nlm4_cancel_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_cancargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_cancel"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
comment|/* copy cookie from arg to result.  See comment in nlm_test_1() */
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
comment|/* 	 * Since at present we never return 'nlm_blocked', there can never be 	 * a lock to cancel, so this call always fails. 	 */
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|unlock
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
name|LOCK_CANCEL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm4_cancel_msg_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_cancargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_cancel_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
comment|/* 	 * Since at present we never return 'nlm_blocked', there can never be 	 * a lock to cancel, so this call always fails. 	 */
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|unlock
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
name|LOCK_CANCEL
operator||
name|LOCK_V4
argument_list|)
expr_stmt|;
name|transmit4_result
argument_list|(
name|NLM4_CANCEL_RES
argument_list|,
operator|&
name|res
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_unlock -------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Release an existing lock  * Returns:	Always granted, unless during grace period  * Notes:	"no such lock" error condition is ignored, as the  *		protocol uses unreliable UDP datagrams, and may well  *		re-try an unlock that has already succeeded.  */
end_comment

begin_function
name|nlm4_res
modifier|*
name|nlm4_unlock_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_unlockargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_unlock"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|unlock
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
name|LOCK_V4
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm4_unlock_msg_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_unlockargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_unlock_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|unlock
argument_list|(
operator|&
name|arg
operator|->
name|alock
argument_list|,
name|LOCK_V4
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|transmit4_result
argument_list|(
name|NLM4_UNLOCK_RES
argument_list|,
operator|&
name|res
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Client-side pseudo-RPCs for results.  Note that for the client there  * are only nlm_xxx_msg() versions of each call, since the 'real RPC'  * version returns the results in the RPC result, and so the client  * does not normally receive incoming RPCs.  *  * The exception to this is nlm_granted(), which is genuinely an RPC  * call from the server to the client - a 'call-back' in normal procedure  * call terms.  */
end_comment

begin_comment
comment|/* nlm_granted ------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Receive notification that formerly blocked lock now granted  * Returns:	always success ('granted')  * Notes:  */
end_comment

begin_function
name|nlm4_res
modifier|*
name|nlm4_granted_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_testargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_granted"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|lock_answer
argument_list|(
name|arg
operator|->
name|alock
operator|.
name|svid
argument_list|,
operator|&
name|arg
operator|->
name|cookie
argument_list|,
name|nlm4_granted
argument_list|,
name|NULL
argument_list|,
name|NLM_VERS4
argument_list|)
operator|==
literal|0
condition|?
name|nlm4_granted
else|:
name|nlm4_denied
expr_stmt|;
comment|/* copy cookie from arg to result.  See comment in nlm_test_1() */
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm4_granted_msg_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_testargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_granted_msg"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm4_granted
expr_stmt|;
name|transmit4_result
argument_list|(
name|NLM4_GRANTED_RES
argument_list|,
operator|&
name|res
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|svc_getrpccaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_test_res ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Purpose:	Accept result from earlier nlm_test_msg() call  * Returns:	Nothing  */
end_comment

begin_function
name|void
modifier|*
name|nlm4_test_res_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_testres
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_test_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lock_answer
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|arg
operator|->
name|cookie
argument_list|,
name|arg
operator|->
name|stat
operator|.
name|stat
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|arg
operator|->
name|stat
operator|.
name|nlm4_testrply_u
operator|.
name|holder
operator|.
name|svid
argument_list|,
name|NLM_VERS4
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_lock_res ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Purpose:	Accept result from earlier nlm_lock_msg() call  * Returns:	Nothing  */
end_comment

begin_function
name|void
modifier|*
name|nlm4_lock_res_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_res
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_lock_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lock_answer
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|arg
operator|->
name|cookie
argument_list|,
name|arg
operator|->
name|stat
operator|.
name|stat
argument_list|,
name|NULL
argument_list|,
name|NLM_VERS4
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_cancel_res ---------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Accept result from earlier nlm_cancel_msg() call  * Returns:	Nothing  */
end_comment

begin_function
name|void
modifier|*
name|nlm4_cancel_res_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_res
modifier|*
name|arg
name|__unused
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_cancel_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_unlock_res ---------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Accept result from earlier nlm_unlock_msg() call  * Returns:	Nothing  */
end_comment

begin_function
name|void
modifier|*
name|nlm4_unlock_res_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_res
modifier|*
name|arg
name|__unused
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_unlock_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_granted_res --------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Accept result from earlier nlm_granted_msg() call  * Returns:	Nothing  */
end_comment

begin_function
name|void
modifier|*
name|nlm4_granted_res_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_res
modifier|*
name|arg
name|__unused
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_granted_res"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Calls for PCNFS locking (aka non-monitored locking, no involvement  * of rpc.statd).  *  * These are all genuine RPCs - no nlm_xxx_msg() nonsense here.  */
end_comment

begin_comment
comment|/* nlm_share --------------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	Establish a DOS-style lock  * Returns:	success or failure  * Notes:	Blocking locks are not supported - client is expected  *		to retry if required.  */
end_comment

begin_function
name|nlm4_shareres
modifier|*
name|nlm4_share_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_shareargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_shareres
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_share"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|=
name|nlm4_granted
expr_stmt|;
name|res
operator|.
name|sequence
operator|=
literal|1234356
expr_stmt|;
comment|/* X/Open says this field is ignored? */
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm4_unshare ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Purpose:	Release a DOS-style lock  * Returns:	nlm_granted, unless in grace period  * Notes:  */
end_comment

begin_function
name|nlm4_shareres
modifier|*
name|nlm4_unshare_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_shareargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_shareres
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm_unshare"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|=
name|nlm4_granted
expr_stmt|;
name|res
operator|.
name|sequence
operator|=
literal|1234356
expr_stmt|;
comment|/* X/Open says this field is ignored? */
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm4_nm_lock ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Purpose:	non-monitored version of nlm4_lock()  * Returns:	as for nlm4_lock()  * Notes:	These locks are in the same style as the standard nlm4_lock,  *		but the rpc.statd should not be called to establish a  *		monitor for the client machine, since that machine is  *		declared not to be running a rpc.statd, and so would not  *		respond to the statd protocol.  */
end_comment

begin_function
name|nlm4_res
modifier|*
name|nlm4_nm_lock_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|nlm4_lockargs
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|nlm4_res
name|res
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_nm_lock"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
comment|/* copy cookie from arg to result.  See comment in nlm4_test_1() */
name|res
operator|.
name|cookie
operator|=
name|arg
operator|->
name|cookie
expr_stmt|;
name|res
operator|.
name|stat
operator|.
name|stat
operator|=
name|nlm4_granted
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm4_free_all ------------------------------------------------------------ */
end_comment

begin_comment
comment|/*  * Purpose:	Release all locks held by a named client  * Returns:	Nothing  * Notes:	Potential denial of service security problem here - the  *		locks to be released are specified by a host name, independent  *		of the address from which the request has arrived.  *		Should probably be rejected if the named host has been  *		using monitored locks.  */
end_comment

begin_function
name|void
modifier|*
name|nlm4_free_all_4_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|struct
name|nlm4_notify
modifier|*
name|arg
name|__unused
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
specifier|static
name|char
name|dummy
decl_stmt|;
if|if
condition|(
name|debug_level
condition|)
name|log_from_addr
argument_list|(
literal|"nlm4_free_all"
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|dummy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* nlm_sm_notify --------------------------------------------------------- */
end_comment

begin_comment
comment|/*  * Purpose:	called by rpc.statd when a monitored host state changes.  * Returns:	Nothing  */
end_comment

begin_function
name|void
modifier|*
name|nlm_sm_notify_0_svc
parameter_list|(
name|arg
parameter_list|,
name|rqstp
parameter_list|)
name|struct
name|nlm_sm_status
modifier|*
name|arg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
name|__unused
decl_stmt|;
block|{
specifier|static
name|char
name|dummy
decl_stmt|;
name|notify
argument_list|(
name|arg
operator|->
name|mon_name
argument_list|,
name|arg
operator|->
name|state
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|dummy
operator|)
return|;
block|}
end_function

end_unit

