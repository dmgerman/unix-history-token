begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: lockd_lock.c,v 1.5 2000/11/21 03:47:41 enami Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Andrew P. Lentvorski, Jr.  * Copyright (c) 2000 Manuel Bouyer.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|LOCKD_DEBUG
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LOCKD_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/sm_inter.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/nlm_prot.h>
end_include

begin_include
include|#
directive|include
file|"lockd_lock.h"
end_include

begin_include
include|#
directive|include
file|"lockd.h"
end_include

begin_define
define|#
directive|define
name|MAXOBJECTSIZE
value|64
end_define

begin_define
define|#
directive|define
name|MAXBUFFERSIZE
value|1024
end_define

begin_comment
comment|/*  * A set of utilities for managing file locking  *  * XXX: All locks are in a linked list, a better structure should be used  * to improve search/access efficiency.  */
end_comment

begin_comment
comment|/* struct describing a lock */
end_comment

begin_struct
struct|struct
name|file_lock
block|{
name|LIST_ENTRY
argument_list|(
argument|file_lock
argument_list|)
name|nfslocklist
expr_stmt|;
name|fhandle_t
name|filehandle
decl_stmt|;
comment|/* NFS filehandle */
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|nlm4_holder
name|client
decl_stmt|;
comment|/* lock holder */
comment|/* XXX: client_cookie used *only* in send_granted */
name|netobj
name|client_cookie
decl_stmt|;
comment|/* cookie sent by the client */
name|int
name|nsm_status
decl_stmt|;
comment|/* status from the remote lock manager */
name|int
name|status
decl_stmt|;
comment|/* lock status, see below */
name|int
name|flags
decl_stmt|;
comment|/* lock flags, see lockd_lock.h */
name|int
name|blocking
decl_stmt|;
comment|/* blocking lock or not */
name|char
name|client_name
index|[
name|SM_MAXSTRLEN
index|]
decl_stmt|;
comment|/* client_name is really variable 					   length and must be last! */
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|nfslocklist_head
argument_list|,
name|file_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|nfslocklist_head
name|nfslocklist_head
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|nfslocklist_head
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|blockedlocklist_head
argument_list|,
name|file_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|blockedlocklist_head
name|blockedlocklist_head
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|blockedlocklist_head
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lock status */
end_comment

begin_define
define|#
directive|define
name|LKST_LOCKED
value|1
end_define

begin_comment
comment|/* lock is locked */
end_comment

begin_comment
comment|/* XXX: Is this flag file specific or lock specific? */
end_comment

begin_define
define|#
directive|define
name|LKST_WAITING
value|2
end_define

begin_comment
comment|/* file is already locked by another host */
end_comment

begin_define
define|#
directive|define
name|LKST_PROCESSING
value|3
end_define

begin_comment
comment|/* child is trying to acquire the lock */
end_comment

begin_define
define|#
directive|define
name|LKST_DYING
value|4
end_define

begin_comment
comment|/* must dies when we get news from the child */
end_comment

begin_comment
comment|/* struct describing a monitored host */
end_comment

begin_struct
struct|struct
name|host
block|{
name|LIST_ENTRY
argument_list|(
argument|host
argument_list|)
name|hostlst
expr_stmt|;
name|int
name|refcnt
decl_stmt|;
name|char
name|name
index|[
name|SM_MAXSTRLEN
index|]
decl_stmt|;
comment|/* name is really variable length and                                     must be last! */
block|}
struct|;
end_struct

begin_comment
comment|/* list of hosts we monitor */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|hostlst_head
argument_list|,
name|host
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|hostlst_head
name|hostlst_head
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|hostlst_head
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * File monitoring handlers  * XXX: These might be able to be removed when kevent support  * is placed into the hardware lock/unlock routines.  (ie.  * let the kernel do all the file monitoring)  */
end_comment

begin_comment
comment|/* Struct describing a monitored file */
end_comment

begin_struct
struct|struct
name|monfile
block|{
name|LIST_ENTRY
argument_list|(
argument|monfile
argument_list|)
name|monfilelist
expr_stmt|;
name|fhandle_t
name|filehandle
decl_stmt|;
comment|/* Local access filehandle */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor: remains open until unlock! */
name|int
name|refcount
decl_stmt|;
name|int
name|exclusive
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* List of files we monitor */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|monfilelist_head
argument_list|,
name|monfile
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|monfilelist_head
name|monfilelist_head
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|monfilelist_head
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debugdelay
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|nfslock_status
block|{
name|NFS_GRANTED
init|=
literal|0
block|,
name|NFS_GRANTED_DUPLICATE
block|,
name|NFS_DENIED
block|,
name|NFS_DENIED_NOLOCK
block|,
name|NFS_RESERR
block|}
enum|;
end_enum

begin_enum
enum|enum
name|hwlock_status
block|{
name|HW_GRANTED
init|=
literal|0
block|,
name|HW_GRANTED_DUPLICATE
block|,
name|HW_DENIED
block|,
name|HW_DENIED_NOLOCK
block|,
name|HW_STALEFH
block|,
name|HW_READONLY
block|,
name|HW_RESERR
block|}
enum|;
end_enum

begin_enum
enum|enum
name|partialfilelock_status
block|{
name|PFL_GRANTED
init|=
literal|0
block|,
name|PFL_GRANTED_DUPLICATE
block|,
name|PFL_DENIED
block|,
name|PFL_NFSDENIED
block|,
name|PFL_NFSBLOCKED
block|,
name|PFL_NFSDENIED_NOLOCK
block|,
name|PFL_NFSRESERR
block|,
name|PFL_HWDENIED
block|,
name|PFL_HWBLOCKED
block|,
name|PFL_HWDENIED_NOLOCK
block|,
name|PFL_HWRESERR
block|}
enum|;
end_enum

begin_enum
enum|enum
name|LFLAGS
block|{
name|LEDGE_LEFT
block|,
name|LEDGE_LBOUNDARY
block|,
name|LEDGE_INSIDE
block|,
name|LEDGE_RBOUNDARY
block|,
name|LEDGE_RIGHT
block|}
enum|;
end_enum

begin_enum
enum|enum
name|RFLAGS
block|{
name|REDGE_LEFT
block|,
name|REDGE_LBOUNDARY
block|,
name|REDGE_INSIDE
block|,
name|REDGE_RBOUNDARY
block|,
name|REDGE_RIGHT
block|}
enum|;
end_enum

begin_comment
comment|/* XXX: WARNING! I HAVE OVERLOADED THIS STATUS ENUM!  SPLIT IT APART INTO TWO */
end_comment

begin_enum
enum|enum
name|split_status
block|{
name|SPL_DISJOINT
init|=
literal|0
block|,
name|SPL_LOCK1
init|=
literal|1
block|,
name|SPL_LOCK2
init|=
literal|2
block|,
name|SPL_CONTAINED
init|=
literal|4
block|,
name|SPL_RESERR
init|=
literal|8
block|}
enum|;
end_enum

begin_function_decl
name|enum
name|partialfilelock_status
name|lock_partialfilelock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|send_granted
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|,
name|int
name|opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|siglock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sigunlock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|monitor_lock_host
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|unmonitor_lock_host
parameter_list|(
name|char
modifier|*
name|hostname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|copy_nlm4_lock_to_nlm4_holder
parameter_list|(
specifier|const
name|struct
name|nlm4_lock
modifier|*
name|src
parameter_list|,
specifier|const
name|bool_t
name|exclusive
parameter_list|,
name|struct
name|nlm4_holder
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|file_lock
modifier|*
name|allocate_file_lock
parameter_list|(
specifier|const
name|netobj
modifier|*
name|lockowner
parameter_list|,
specifier|const
name|netobj
modifier|*
name|matchcookie
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|caller_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|deallocate_file_lock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|fill_file_lock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|,
specifier|const
name|fhandle_t
modifier|*
name|fh
parameter_list|,
specifier|const
name|bool_t
name|exclusive
parameter_list|,
specifier|const
name|int32_t
name|svid
parameter_list|,
specifier|const
name|u_int64_t
name|offset
parameter_list|,
specifier|const
name|u_int64_t
name|len
parameter_list|,
specifier|const
name|int
name|state
parameter_list|,
specifier|const
name|int
name|status
parameter_list|,
specifier|const
name|int
name|flags
parameter_list|,
specifier|const
name|int
name|blocking
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|regions_overlap
parameter_list|(
specifier|const
name|u_int64_t
name|start1
parameter_list|,
specifier|const
name|u_int64_t
name|len1
parameter_list|,
specifier|const
name|u_int64_t
name|start2
parameter_list|,
specifier|const
name|u_int64_t
name|len2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|split_status
name|region_compare
parameter_list|(
specifier|const
name|u_int64_t
name|starte
parameter_list|,
specifier|const
name|u_int64_t
name|lene
parameter_list|,
specifier|const
name|u_int64_t
name|startu
parameter_list|,
specifier|const
name|u_int64_t
name|lenu
parameter_list|,
name|u_int64_t
modifier|*
name|start1
parameter_list|,
name|u_int64_t
modifier|*
name|len1
parameter_list|,
name|u_int64_t
modifier|*
name|start2
parameter_list|,
name|u_int64_t
modifier|*
name|len2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|same_netobj
parameter_list|(
specifier|const
name|netobj
modifier|*
name|n0
parameter_list|,
specifier|const
name|netobj
modifier|*
name|n1
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|same_filelock_identity
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl0
parameter_list|,
specifier|const
name|struct
name|file_lock
modifier|*
name|fl2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debuglog
parameter_list|(
name|char
specifier|const
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_static_object
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|object
parameter_list|,
specifier|const
name|int
name|sizeof_object
parameter_list|,
name|unsigned
name|char
modifier|*
name|hbuff
parameter_list|,
specifier|const
name|int
name|sizeof_hbuff
parameter_list|,
name|unsigned
name|char
modifier|*
name|cbuff
parameter_list|,
specifier|const
name|int
name|sizeof_cbuff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_netobj
parameter_list|(
specifier|const
name|struct
name|netobj
modifier|*
name|nobj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_filelock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|file_lock
modifier|*
name|get_lock_matching_unlock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|nfslock_status
name|test_nfslock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|conflicting_fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|nfslock_status
name|lock_nfslock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|nfslock_status
name|delete_nfslock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|nfslock_status
name|unlock_nfslock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|released_lock
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|left_lock
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|right_lock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|hwlock_status
name|lock_hwlock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|split_status
name|split_nfslock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|exist_lock
parameter_list|,
specifier|const
name|struct
name|file_lock
modifier|*
name|unlock_lock
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|left_lock
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|right_lock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|duplicate_block
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_blockingfilelock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|hwlock_status
name|unlock_hwlock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|hwlock_status
name|test_hwlock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|conflicting_fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|remove_blockingfilelock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|clear_blockingfilelock
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|retry_blockingfilelocklist
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|partialfilelock_status
name|unlock_partialfilelock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|clear_partialfilelock
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|partialfilelock_status
name|test_partialfilelock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|conflicting_fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|nlm_stats
name|do_test
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|conflicting_fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|nlm_stats
name|do_unlock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|enum
name|nlm_stats
name|do_lock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|do_clear
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|strnlen
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|debuglog
parameter_list|(
name|char
specifier|const
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|debug_level
operator|<
literal|1
condition|)
block|{
return|return;
block|}
name|sleep
argument_list|(
name|debugdelay
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsyslog
argument_list|(
name|LOG_DEBUG
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dump_static_object
parameter_list|(
name|object
parameter_list|,
name|size_object
parameter_list|,
name|hbuff
parameter_list|,
name|size_hbuff
parameter_list|,
name|cbuff
parameter_list|,
name|size_cbuff
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|object
decl_stmt|;
specifier|const
name|int
name|size_object
decl_stmt|;
name|unsigned
name|char
modifier|*
name|hbuff
decl_stmt|;
specifier|const
name|int
name|size_hbuff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cbuff
decl_stmt|;
specifier|const
name|int
name|size_cbuff
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|objectsize
decl_stmt|;
if|if
condition|(
name|debug_level
operator|<
literal|2
condition|)
block|{
return|return;
block|}
name|objectsize
operator|=
name|size_object
expr_stmt|;
if|if
condition|(
name|objectsize
operator|==
literal|0
condition|)
block|{
name|debuglog
argument_list|(
literal|"object is size 0\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|objectsize
operator|>
name|MAXOBJECTSIZE
condition|)
block|{
name|debuglog
argument_list|(
literal|"Object of size %d being clamped"
literal|"to size %d\n"
argument_list|,
name|objectsize
argument_list|,
name|MAXOBJECTSIZE
argument_list|)
expr_stmt|;
name|objectsize
operator|=
name|MAXOBJECTSIZE
expr_stmt|;
block|}
if|if
condition|(
name|hbuff
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|size_hbuff
operator|<
name|objectsize
operator|*
literal|2
operator|+
literal|1
condition|)
block|{
name|debuglog
argument_list|(
literal|"Hbuff not large enough."
literal|"  Increase size\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objectsize
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|hbuff
operator|+
name|i
operator|*
literal|2
argument_list|,
literal|"%02x"
argument_list|,
operator|*
operator|(
name|object
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|hbuff
operator|+
name|i
operator|*
literal|2
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cbuff
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|size_cbuff
operator|<
name|objectsize
operator|+
literal|1
condition|)
block|{
name|debuglog
argument_list|(
literal|"Cbuff not large enough."
literal|"  Increase Size\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objectsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|object
operator|+
name|i
operator|)
operator|>=
literal|32
operator|&&
operator|*
operator|(
name|object
operator|+
name|i
operator|)
operator|<=
literal|127
condition|)
block|{
operator|*
operator|(
name|cbuff
operator|+
name|i
operator|)
operator|=
operator|*
operator|(
name|object
operator|+
name|i
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|cbuff
operator|+
name|i
operator|)
operator|=
literal|'.'
expr_stmt|;
block|}
block|}
operator|*
operator|(
name|cbuff
operator|+
name|i
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|dump_netobj
parameter_list|(
specifier|const
name|struct
name|netobj
modifier|*
name|nobj
parameter_list|)
block|{
name|char
name|hbuff
index|[
name|MAXBUFFERSIZE
operator|*
literal|2
index|]
decl_stmt|;
name|char
name|cbuff
index|[
name|MAXBUFFERSIZE
index|]
decl_stmt|;
if|if
condition|(
name|debug_level
operator|<
literal|2
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|nobj
operator|==
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|"Null netobj pointer\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nobj
operator|->
name|n_len
operator|==
literal|0
condition|)
block|{
name|debuglog
argument_list|(
literal|"Size zero netobj\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dump_static_object
argument_list|(
name|nobj
operator|->
name|n_bytes
argument_list|,
name|nobj
operator|->
name|n_len
argument_list|,
name|hbuff
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuff
argument_list|)
argument_list|,
name|cbuff
argument_list|,
sizeof|sizeof
argument_list|(
name|cbuff
argument_list|)
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"netobj: len: %d  data: %s :::  %s\n"
argument_list|,
name|nobj
operator|->
name|n_len
argument_list|,
name|hbuff
argument_list|,
name|cbuff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* #define DUMP_FILELOCK_VERBOSE */
end_comment

begin_function
name|void
name|dump_filelock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DUMP_FILELOCK_VERBOSE
name|char
name|hbuff
index|[
name|MAXBUFFERSIZE
operator|*
literal|2
index|]
decl_stmt|;
name|char
name|cbuff
index|[
name|MAXBUFFERSIZE
index|]
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|debug_level
operator|<
literal|2
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|fl
operator|!=
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|"Dumping file lock structure @ %p\n"
argument_list|,
name|fl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMP_FILELOCK_VERBOSE
name|dump_static_object
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fl
operator|->
name|filehandle
argument_list|)
argument_list|,
name|hbuff
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuff
argument_list|)
argument_list|,
name|cbuff
argument_list|,
sizeof|sizeof
argument_list|(
name|cbuff
argument_list|)
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Filehandle: %8s  :::  %8s\n"
argument_list|,
name|hbuff
argument_list|,
name|cbuff
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|debuglog
argument_list|(
literal|"Dumping nlm4_holder:\n"
literal|"exc: %x  svid: %x  offset:len %llx:%llx\n"
argument_list|,
name|fl
operator|->
name|client
operator|.
name|exclusive
argument_list|,
name|fl
operator|->
name|client
operator|.
name|svid
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMP_FILELOCK_VERBOSE
name|debuglog
argument_list|(
literal|"Dumping client identity:\n"
argument_list|)
expr_stmt|;
name|dump_netobj
argument_list|(
operator|&
name|fl
operator|->
name|client
operator|.
name|oh
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Dumping client cookie:\n"
argument_list|)
expr_stmt|;
name|dump_netobj
argument_list|(
operator|&
name|fl
operator|->
name|client_cookie
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"nsm: %d  status: %d  flags: %d  svid: %x"
literal|"  client_name: %s\n"
argument_list|,
name|fl
operator|->
name|nsm_status
argument_list|,
name|fl
operator|->
name|status
argument_list|,
name|fl
operator|->
name|flags
argument_list|,
name|fl
operator|->
name|client
operator|.
name|svid
argument_list|,
name|fl
operator|->
name|client_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|debuglog
argument_list|(
literal|"NULL file lock structure\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|copy_nlm4_lock_to_nlm4_holder
parameter_list|(
name|src
parameter_list|,
name|exclusive
parameter_list|,
name|dest
parameter_list|)
specifier|const
name|struct
name|nlm4_lock
modifier|*
name|src
decl_stmt|;
specifier|const
name|bool_t
name|exclusive
decl_stmt|;
name|struct
name|nlm4_holder
modifier|*
name|dest
decl_stmt|;
block|{
name|dest
operator|->
name|exclusive
operator|=
name|exclusive
expr_stmt|;
name|dest
operator|->
name|oh
operator|.
name|n_len
operator|=
name|src
operator|->
name|oh
operator|.
name|n_len
expr_stmt|;
name|dest
operator|->
name|oh
operator|.
name|n_bytes
operator|=
name|src
operator|->
name|oh
operator|.
name|n_bytes
expr_stmt|;
name|dest
operator|->
name|svid
operator|=
name|src
operator|->
name|svid
expr_stmt|;
name|dest
operator|->
name|l_offset
operator|=
name|src
operator|->
name|l_offset
expr_stmt|;
name|dest
operator|->
name|l_len
operator|=
name|src
operator|->
name|l_len
expr_stmt|;
block|}
end_function

begin_function
name|size_t
name|strnlen
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|s
index|[
name|n
index|]
operator|!=
literal|0
operator|&&
name|n
operator|<
name|len
condition|;
name|n
operator|++
control|)
empty_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * allocate_file_lock: Create a lock with the given parameters  */
end_comment

begin_function
name|struct
name|file_lock
modifier|*
name|allocate_file_lock
parameter_list|(
specifier|const
name|netobj
modifier|*
name|lockowner
parameter_list|,
specifier|const
name|netobj
modifier|*
name|matchcookie
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|caller_name
parameter_list|)
block|{
name|struct
name|file_lock
modifier|*
name|newfl
decl_stmt|;
name|size_t
name|n
decl_stmt|;
comment|/* Beware of rubbish input! */
name|n
operator|=
name|strnlen
argument_list|(
name|caller_name
argument_list|,
name|SM_MAXSTRLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|SM_MAXSTRLEN
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|newfl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newfl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|newfl
operator|->
name|client_name
argument_list|)
operator|+
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfl
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|newfl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|newfl
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|newfl
operator|->
name|client_name
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newfl
operator|->
name|client_name
argument_list|,
name|caller_name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|newfl
operator|->
name|client_name
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|newfl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
operator|=
name|malloc
argument_list|(
name|lockowner
operator|->
name|n_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|newfl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|newfl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_len
operator|=
name|lockowner
operator|->
name|n_len
expr_stmt|;
name|bcopy
argument_list|(
name|lockowner
operator|->
name|n_bytes
argument_list|,
name|newfl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
argument_list|,
name|lockowner
operator|->
name|n_len
argument_list|)
expr_stmt|;
name|newfl
operator|->
name|client_cookie
operator|.
name|n_bytes
operator|=
name|malloc
argument_list|(
name|matchcookie
operator|->
name|n_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfl
operator|->
name|client_cookie
operator|.
name|n_bytes
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|newfl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newfl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|newfl
operator|->
name|client_cookie
operator|.
name|n_len
operator|=
name|matchcookie
operator|->
name|n_len
expr_stmt|;
name|bcopy
argument_list|(
name|matchcookie
operator|->
name|n_bytes
argument_list|,
name|newfl
operator|->
name|client_cookie
operator|.
name|n_bytes
argument_list|,
name|matchcookie
operator|->
name|n_len
argument_list|)
expr_stmt|;
name|newfl
operator|->
name|addr
operator|=
name|malloc
argument_list|(
name|addr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfl
operator|->
name|addr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|newfl
operator|->
name|client_cookie
operator|.
name|n_bytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newfl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newfl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|newfl
operator|->
name|addr
argument_list|,
name|addr
argument_list|,
name|addr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
return|return
name|newfl
return|;
block|}
end_function

begin_comment
comment|/*  * file_file_lock: Force creation of a valid file lock  */
end_comment

begin_function
name|void
name|fill_file_lock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|,
specifier|const
name|fhandle_t
modifier|*
name|fh
parameter_list|,
specifier|const
name|bool_t
name|exclusive
parameter_list|,
specifier|const
name|int32_t
name|svid
parameter_list|,
specifier|const
name|u_int64_t
name|offset
parameter_list|,
specifier|const
name|u_int64_t
name|len
parameter_list|,
specifier|const
name|int
name|state
parameter_list|,
specifier|const
name|int
name|status
parameter_list|,
specifier|const
name|int
name|flags
parameter_list|,
specifier|const
name|int
name|blocking
parameter_list|)
block|{
name|bcopy
argument_list|(
name|fh
argument_list|,
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
name|fl
operator|->
name|client
operator|.
name|exclusive
operator|=
name|exclusive
expr_stmt|;
name|fl
operator|->
name|client
operator|.
name|svid
operator|=
name|svid
expr_stmt|;
name|fl
operator|->
name|client
operator|.
name|l_offset
operator|=
name|offset
expr_stmt|;
name|fl
operator|->
name|client
operator|.
name|l_len
operator|=
name|len
expr_stmt|;
name|fl
operator|->
name|nsm_status
operator|=
name|state
expr_stmt|;
name|fl
operator|->
name|status
operator|=
name|status
expr_stmt|;
name|fl
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|fl
operator|->
name|blocking
operator|=
name|blocking
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * deallocate_file_lock: Free all storage associated with a file lock  */
end_comment

begin_function
name|void
name|deallocate_file_lock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|free
argument_list|(
name|fl
operator|->
name|addr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fl
operator|->
name|client_cookie
operator|.
name|n_bytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * regions_overlap(): This function examines the two provided regions for  * overlap.  */
end_comment

begin_function
name|int
name|regions_overlap
parameter_list|(
name|start1
parameter_list|,
name|len1
parameter_list|,
name|start2
parameter_list|,
name|len2
parameter_list|)
specifier|const
name|u_int64_t
name|start1
decl_stmt|,
name|len1
decl_stmt|,
name|start2
decl_stmt|,
name|len2
decl_stmt|;
block|{
name|u_int64_t
name|d1
decl_stmt|,
name|d2
decl_stmt|,
name|d3
decl_stmt|,
name|d4
decl_stmt|;
name|enum
name|split_status
name|result
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering region overlap with vals: %llu:%llu--%llu:%llu\n"
argument_list|,
name|start1
argument_list|,
name|len1
argument_list|,
name|start2
argument_list|,
name|len2
argument_list|)
expr_stmt|;
name|result
operator|=
name|region_compare
argument_list|(
name|start1
argument_list|,
name|len1
argument_list|,
name|start2
argument_list|,
name|len2
argument_list|,
operator|&
name|d1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|d3
argument_list|,
operator|&
name|d4
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Exiting region overlap with val: %d\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|SPL_DISJOINT
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * region_compare(): Examine lock regions and split appropriately  *  * XXX: Fix 64 bit overflow problems  * XXX: Check to make sure I got *ALL* the cases.  * XXX: This DESPERATELY needs a regression test.  */
end_comment

begin_function
name|enum
name|split_status
name|region_compare
parameter_list|(
name|starte
parameter_list|,
name|lene
parameter_list|,
name|startu
parameter_list|,
name|lenu
parameter_list|,
name|start1
parameter_list|,
name|len1
parameter_list|,
name|start2
parameter_list|,
name|len2
parameter_list|)
specifier|const
name|u_int64_t
name|starte
decl_stmt|,
name|lene
decl_stmt|,
name|startu
decl_stmt|,
name|lenu
decl_stmt|;
name|u_int64_t
modifier|*
name|start1
decl_stmt|,
decl|*
name|len1
decl_stmt|,
modifier|*
name|start2
decl_stmt|,
modifier|*
name|len2
decl_stmt|;
end_function

begin_block
block|{
comment|/* 	 * Please pay attention to the sequential exclusions 	 * of the if statements!!! 	 */
name|enum
name|LFLAGS
name|lflags
decl_stmt|;
name|enum
name|RFLAGS
name|rflags
decl_stmt|;
name|enum
name|split_status
name|retval
decl_stmt|;
name|retval
operator|=
name|SPL_DISJOINT
expr_stmt|;
if|if
condition|(
name|lene
operator|==
literal|0
operator|&&
name|lenu
operator|==
literal|0
condition|)
block|{
comment|/* Examine left edge of locker */
name|lflags
operator|=
name|LEDGE_INSIDE
expr_stmt|;
if|if
condition|(
name|startu
operator|<
name|starte
condition|)
block|{
name|lflags
operator|=
name|LEDGE_LEFT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|startu
operator|==
name|starte
condition|)
block|{
name|lflags
operator|=
name|LEDGE_LBOUNDARY
expr_stmt|;
block|}
name|rflags
operator|=
name|REDGE_RBOUNDARY
expr_stmt|;
comment|/* Both are infiinite */
if|if
condition|(
name|lflags
operator|==
name|LEDGE_INSIDE
condition|)
block|{
operator|*
name|start1
operator|=
name|starte
expr_stmt|;
operator|*
name|len1
operator|=
name|startu
operator|-
name|starte
expr_stmt|;
block|}
if|if
condition|(
name|lflags
operator|==
name|LEDGE_LEFT
operator|||
name|lflags
operator|==
name|LEDGE_LBOUNDARY
condition|)
block|{
name|retval
operator|=
name|SPL_CONTAINED
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|SPL_LOCK1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lene
operator|==
literal|0
operator|&&
name|lenu
operator|!=
literal|0
condition|)
block|{
comment|/* Established lock is infinite */
comment|/* Examine left edge of unlocker */
name|lflags
operator|=
name|LEDGE_INSIDE
expr_stmt|;
if|if
condition|(
name|startu
operator|<
name|starte
condition|)
block|{
name|lflags
operator|=
name|LEDGE_LEFT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|startu
operator|==
name|starte
condition|)
block|{
name|lflags
operator|=
name|LEDGE_LBOUNDARY
expr_stmt|;
block|}
comment|/* Examine right edge of unlocker */
if|if
condition|(
name|startu
operator|+
name|lenu
operator|<
name|starte
condition|)
block|{
comment|/* Right edge of unlocker left of established lock */
name|rflags
operator|=
name|REDGE_LEFT
expr_stmt|;
return|return
name|SPL_DISJOINT
return|;
block|}
elseif|else
if|if
condition|(
name|startu
operator|+
name|lenu
operator|==
name|starte
condition|)
block|{
comment|/* Right edge of unlocker on start of established lock */
name|rflags
operator|=
name|REDGE_LBOUNDARY
expr_stmt|;
return|return
name|SPL_DISJOINT
return|;
block|}
else|else
block|{
comment|/* Infinifty is right of finity */
comment|/* Right edge of unlocker inside established lock */
name|rflags
operator|=
name|REDGE_INSIDE
expr_stmt|;
block|}
if|if
condition|(
name|lflags
operator|==
name|LEDGE_INSIDE
condition|)
block|{
operator|*
name|start1
operator|=
name|starte
expr_stmt|;
operator|*
name|len1
operator|=
name|startu
operator|-
name|starte
expr_stmt|;
name|retval
operator||=
name|SPL_LOCK1
expr_stmt|;
block|}
if|if
condition|(
name|rflags
operator|==
name|REDGE_INSIDE
condition|)
block|{
comment|/* Create right lock */
operator|*
name|start2
operator|=
name|startu
operator|+
name|lenu
expr_stmt|;
operator|*
name|len2
operator|=
literal|0
expr_stmt|;
name|retval
operator||=
name|SPL_LOCK2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lene
operator|!=
literal|0
operator|&&
name|lenu
operator|==
literal|0
condition|)
block|{
comment|/* Unlocker is infinite */
comment|/* Examine left edge of unlocker */
name|lflags
operator|=
name|LEDGE_RIGHT
expr_stmt|;
if|if
condition|(
name|startu
operator|<
name|starte
condition|)
block|{
name|lflags
operator|=
name|LEDGE_LEFT
expr_stmt|;
name|retval
operator|=
name|SPL_CONTAINED
expr_stmt|;
return|return
name|retval
return|;
block|}
elseif|else
if|if
condition|(
name|startu
operator|==
name|starte
condition|)
block|{
name|lflags
operator|=
name|LEDGE_LBOUNDARY
expr_stmt|;
name|retval
operator|=
name|SPL_CONTAINED
expr_stmt|;
return|return
name|retval
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|startu
operator|>
name|starte
operator|)
operator|&&
operator|(
name|startu
operator|<
name|starte
operator|+
name|lene
operator|-
literal|1
operator|)
condition|)
block|{
name|lflags
operator|=
name|LEDGE_INSIDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|startu
operator|==
name|starte
operator|+
name|lene
operator|-
literal|1
condition|)
block|{
name|lflags
operator|=
name|LEDGE_RBOUNDARY
expr_stmt|;
block|}
else|else
block|{
comment|/* startu> starte + lene -1 */
name|lflags
operator|=
name|LEDGE_RIGHT
expr_stmt|;
return|return
name|SPL_DISJOINT
return|;
block|}
name|rflags
operator|=
name|REDGE_RIGHT
expr_stmt|;
comment|/* Infinity is right of finity */
if|if
condition|(
name|lflags
operator|==
name|LEDGE_INSIDE
operator|||
name|lflags
operator|==
name|LEDGE_RBOUNDARY
condition|)
block|{
operator|*
name|start1
operator|=
name|starte
expr_stmt|;
operator|*
name|len1
operator|=
name|startu
operator|-
name|starte
expr_stmt|;
name|retval
operator||=
name|SPL_LOCK1
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
else|else
block|{
comment|/* Both locks are finite */
comment|/* Examine left edge of unlocker */
name|lflags
operator|=
name|LEDGE_RIGHT
expr_stmt|;
if|if
condition|(
name|startu
operator|<
name|starte
condition|)
block|{
name|lflags
operator|=
name|LEDGE_LEFT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|startu
operator|==
name|starte
condition|)
block|{
name|lflags
operator|=
name|LEDGE_LBOUNDARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|startu
operator|>
name|starte
operator|)
operator|&&
operator|(
name|startu
operator|<
name|starte
operator|+
name|lene
operator|-
literal|1
operator|)
condition|)
block|{
name|lflags
operator|=
name|LEDGE_INSIDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|startu
operator|==
name|starte
operator|+
name|lene
operator|-
literal|1
condition|)
block|{
name|lflags
operator|=
name|LEDGE_RBOUNDARY
expr_stmt|;
block|}
else|else
block|{
comment|/* startu> starte + lene -1 */
name|lflags
operator|=
name|LEDGE_RIGHT
expr_stmt|;
return|return
name|SPL_DISJOINT
return|;
block|}
comment|/* Examine right edge of unlocker */
if|if
condition|(
name|startu
operator|+
name|lenu
operator|<
name|starte
condition|)
block|{
comment|/* Right edge of unlocker left of established lock */
name|rflags
operator|=
name|REDGE_LEFT
expr_stmt|;
return|return
name|SPL_DISJOINT
return|;
block|}
elseif|else
if|if
condition|(
name|startu
operator|+
name|lenu
operator|==
name|starte
condition|)
block|{
comment|/* Right edge of unlocker on start of established lock */
name|rflags
operator|=
name|REDGE_LBOUNDARY
expr_stmt|;
return|return
name|SPL_DISJOINT
return|;
block|}
elseif|else
if|if
condition|(
name|startu
operator|+
name|lenu
operator|<
name|starte
operator|+
name|lene
condition|)
block|{
comment|/* Right edge of unlocker inside established lock */
name|rflags
operator|=
name|REDGE_INSIDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|startu
operator|+
name|lenu
operator|==
name|starte
operator|+
name|lene
condition|)
block|{
comment|/* Right edge of unlocker on right edge of established lock */
name|rflags
operator|=
name|REDGE_RBOUNDARY
expr_stmt|;
block|}
else|else
block|{
comment|/* startu + lenu> starte + lene */
comment|/* Right edge of unlocker is right of established lock */
name|rflags
operator|=
name|REDGE_RIGHT
expr_stmt|;
block|}
if|if
condition|(
name|lflags
operator|==
name|LEDGE_INSIDE
operator|||
name|lflags
operator|==
name|LEDGE_RBOUNDARY
condition|)
block|{
comment|/* Create left lock */
operator|*
name|start1
operator|=
name|starte
expr_stmt|;
operator|*
name|len1
operator|=
operator|(
name|startu
operator|-
name|starte
operator|)
expr_stmt|;
name|retval
operator||=
name|SPL_LOCK1
expr_stmt|;
block|}
if|if
condition|(
name|rflags
operator|==
name|REDGE_INSIDE
condition|)
block|{
comment|/* Create right lock */
operator|*
name|start2
operator|=
name|startu
operator|+
name|lenu
expr_stmt|;
operator|*
name|len2
operator|=
name|starte
operator|+
name|lene
operator|-
operator|(
name|startu
operator|+
name|lenu
operator|)
expr_stmt|;
name|retval
operator||=
name|SPL_LOCK2
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lflags
operator|==
name|LEDGE_LEFT
operator|||
name|lflags
operator|==
name|LEDGE_LBOUNDARY
operator|)
operator|&&
operator|(
name|rflags
operator|==
name|REDGE_RBOUNDARY
operator|||
name|rflags
operator|==
name|REDGE_RIGHT
operator|)
condition|)
block|{
name|retval
operator|=
name|SPL_CONTAINED
expr_stmt|;
block|}
block|}
return|return
name|retval
return|;
block|}
end_block

begin_comment
comment|/*  * same_netobj: Compares the apprpriate bits of a netobj for identity  */
end_comment

begin_function
name|int
name|same_netobj
parameter_list|(
specifier|const
name|netobj
modifier|*
name|n0
parameter_list|,
specifier|const
name|netobj
modifier|*
name|n1
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|debuglog
argument_list|(
literal|"Entering netobj identity check\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n0
operator|->
name|n_len
operator|==
name|n1
operator|->
name|n_len
condition|)
block|{
name|debuglog
argument_list|(
literal|"Preliminary length check passed\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|!
name|bcmp
argument_list|(
name|n0
operator|->
name|n_bytes
argument_list|,
name|n1
operator|->
name|n_bytes
argument_list|,
name|n0
operator|->
name|n_len
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"netobj %smatch\n"
argument_list|,
name|retval
condition|?
literal|""
else|:
literal|"mis"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * same_filelock_identity: Compares the appropriate bits of a file_lock  */
end_comment

begin_function
name|int
name|same_filelock_identity
parameter_list|(
name|fl0
parameter_list|,
name|fl1
parameter_list|)
specifier|const
name|struct
name|file_lock
modifier|*
name|fl0
decl_stmt|,
decl|*
name|fl1
decl_stmt|;
end_function

begin_block
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|debuglog
argument_list|(
literal|"Checking filelock identity\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Check process ids and host information. 	 */
name|retval
operator|=
operator|(
name|fl0
operator|->
name|client
operator|.
name|svid
operator|==
name|fl1
operator|->
name|client
operator|.
name|svid
operator|&&
name|same_netobj
argument_list|(
operator|&
operator|(
name|fl0
operator|->
name|client
operator|.
name|oh
operator|)
argument_list|,
operator|&
operator|(
name|fl1
operator|->
name|client
operator|.
name|oh
operator|)
argument_list|)
operator|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Exiting checking filelock identity: retval: %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Below here are routines associated with manipulating the NFS  * lock list.  */
end_comment

begin_comment
comment|/*  * get_lock_matching_unlock: Return a lock which matches the given unlock lock  *                           or NULL otehrwise  * XXX: It is a shame that this duplicates so much code from test_nfslock.  */
end_comment

begin_function
name|struct
name|file_lock
modifier|*
name|get_lock_matching_unlock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|file_lock
modifier|*
name|ifl
decl_stmt|;
comment|/* Iterator */
name|debuglog
argument_list|(
literal|"Entering get_lock_matching_unlock\n"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"********Dump of fl*****************\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ifl
argument_list|,
argument|&nfslocklist_head
argument_list|,
argument|nfslocklist
argument_list|)
block|{
name|debuglog
argument_list|(
literal|"Pointer to file lock: %p\n"
argument_list|,
name|ifl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"****Dump of ifl****\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|ifl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"*******************\n"
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: It is conceivable that someone could use the NLM RPC 		 * system to directly access filehandles.  This may be a 		 * security hazard as the filehandle code may bypass normal 		 * file access controls 		 */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
operator|&
name|ifl
operator|->
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
condition|)
continue|continue;
name|debuglog
argument_list|(
literal|"get_lock_matching_unlock: Filehandles match, "
literal|"checking regions\n"
argument_list|)
expr_stmt|;
comment|/* Filehandles match, check for region overlap */
if|if
condition|(
operator|!
name|regions_overlap
argument_list|(
name|fl
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_len
argument_list|,
name|ifl
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|ifl
operator|->
name|client
operator|.
name|l_len
argument_list|)
condition|)
continue|continue;
name|debuglog
argument_list|(
literal|"get_lock_matching_unlock: Region overlap"
literal|" found %llu : %llu -- %llu : %llu\n"
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_len
argument_list|,
name|ifl
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|ifl
operator|->
name|client
operator|.
name|l_len
argument_list|)
expr_stmt|;
comment|/* Regions overlap, check the identity */
if|if
condition|(
operator|!
name|same_filelock_identity
argument_list|(
name|fl
argument_list|,
name|ifl
argument_list|)
condition|)
continue|continue;
name|debuglog
argument_list|(
literal|"get_lock_matching_unlock: Duplicate lock id.  Granting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ifl
operator|)
return|;
block|}
name|debuglog
argument_list|(
literal|"Exiting bet_lock_matching_unlock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * test_nfslock: check for NFS lock in lock list  *  * This routine makes the following assumptions:  *    1) Nothing will adjust the lock list during a lookup  *  * This routine has an intersting quirk which bit me hard.  * The conflicting_fl is the pointer to the conflicting lock.  * However, to modify the "*pointer* to the conflicting lock" rather  * that the "conflicting lock itself" one must pass in a "pointer to  * the pointer of the conflicting lock".  Gross.  */
end_comment

begin_function
name|enum
name|nfslock_status
name|test_nfslock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|conflicting_fl
parameter_list|)
block|{
name|struct
name|file_lock
modifier|*
name|ifl
decl_stmt|;
comment|/* Iterator */
name|enum
name|nfslock_status
name|retval
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering test_nfslock\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|NFS_GRANTED
expr_stmt|;
operator|(
operator|*
name|conflicting_fl
operator|)
operator|=
name|NULL
expr_stmt|;
name|debuglog
argument_list|(
literal|"Entering lock search loop\n"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"***********************************\n"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Dumping match filelock\n"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"***********************************\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"***********************************\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ifl
argument_list|,
argument|&nfslocklist_head
argument_list|,
argument|nfslocklist
argument_list|)
block|{
if|if
condition|(
name|retval
operator|==
name|NFS_DENIED
condition|)
break|break;
name|debuglog
argument_list|(
literal|"Top of lock loop\n"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Pointer to file lock: %p\n"
argument_list|,
name|ifl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"***********************************\n"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Dumping test filelock\n"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"***********************************\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|ifl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"***********************************\n"
argument_list|)
expr_stmt|;
comment|/* 		 * XXX: It is conceivable that someone could use the NLM RPC 		 * system to directly access filehandles.  This may be a 		 * security hazard as the filehandle code may bypass normal 		 * file access controls 		 */
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
operator|&
name|ifl
operator|->
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
condition|)
continue|continue;
name|debuglog
argument_list|(
literal|"test_nfslock: filehandle match found\n"
argument_list|)
expr_stmt|;
comment|/* Filehandles match, check for region overlap */
if|if
condition|(
operator|!
name|regions_overlap
argument_list|(
name|fl
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_len
argument_list|,
name|ifl
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|ifl
operator|->
name|client
operator|.
name|l_len
argument_list|)
condition|)
continue|continue;
name|debuglog
argument_list|(
literal|"test_nfslock: Region overlap found"
literal|" %llu : %llu -- %llu : %llu\n"
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_len
argument_list|,
name|ifl
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|ifl
operator|->
name|client
operator|.
name|l_len
argument_list|)
expr_stmt|;
comment|/* Regions overlap, check the exclusivity */
if|if
condition|(
operator|!
operator|(
name|fl
operator|->
name|client
operator|.
name|exclusive
operator|||
name|ifl
operator|->
name|client
operator|.
name|exclusive
operator|)
condition|)
continue|continue;
name|debuglog
argument_list|(
literal|"test_nfslock: Exclusivity failure: %d %d\n"
argument_list|,
name|fl
operator|->
name|client
operator|.
name|exclusive
argument_list|,
name|ifl
operator|->
name|client
operator|.
name|exclusive
argument_list|)
expr_stmt|;
if|if
condition|(
name|same_filelock_identity
argument_list|(
name|fl
argument_list|,
name|ifl
argument_list|)
condition|)
block|{
name|debuglog
argument_list|(
literal|"test_nfslock: Duplicate id.  Granting\n"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|conflicting_fl
operator|)
operator|=
name|ifl
expr_stmt|;
name|retval
operator|=
name|NFS_GRANTED_DUPLICATE
expr_stmt|;
block|}
else|else
block|{
comment|/* locking attempt fails */
name|debuglog
argument_list|(
literal|"test_nfslock: Lock attempt failed\n"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Desired lock\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Conflicting lock\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|ifl
argument_list|)
expr_stmt|;
operator|(
operator|*
name|conflicting_fl
operator|)
operator|=
name|ifl
expr_stmt|;
name|retval
operator|=
name|NFS_DENIED
expr_stmt|;
block|}
block|}
name|debuglog
argument_list|(
literal|"Dumping file locks\n"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Exiting test_nfslock\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lock_nfslock: attempt to create a lock in the NFS lock list  *  * This routine tests whether the lock will be granted and then adds  * the entry to the lock list if so.  *  * Argument fl gets modified as its list housekeeping entries get modified  * upon insertion into the NFS lock list  *  * This routine makes several assumptions:  *    1) It is perfectly happy to grant a duplicate lock from the same pid.  *       While this seems to be intuitively wrong, it is required for proper  *       Posix semantics during unlock.  It is absolutely imperative to not  *       unlock the main lock before the two child locks are established. Thus,  *       one has be be able to create duplicate locks over an existing lock  *    2) It currently accepts duplicate locks from the same id,pid  */
end_comment

begin_function
name|enum
name|nfslock_status
name|lock_nfslock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|enum
name|nfslock_status
name|retval
decl_stmt|;
name|struct
name|file_lock
modifier|*
name|dummy_fl
decl_stmt|;
name|dummy_fl
operator|=
name|NULL
expr_stmt|;
name|debuglog
argument_list|(
literal|"Entering lock_nfslock...\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|test_nfslock
argument_list|(
name|fl
argument_list|,
operator|&
name|dummy_fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NFS_GRANTED
operator|||
name|retval
operator|==
name|NFS_GRANTED_DUPLICATE
condition|)
block|{
name|debuglog
argument_list|(
literal|"Inserting lock...\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|nfslocklist_head
argument_list|,
name|fl
argument_list|,
name|nfslocklist
argument_list|)
expr_stmt|;
block|}
name|debuglog
argument_list|(
literal|"Exiting lock_nfslock...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * delete_nfslock: delete an NFS lock list entry  *  * This routine is used to delete a lock out of the NFS lock list  * without regard to status, underlying locks, regions or anything else  *  * Note that this routine *does not deallocate memory* of the lock.  * It just disconnects it from the list.  The lock can then be used  * by other routines without fear of trashing the list.  */
end_comment

begin_function
name|enum
name|nfslock_status
name|delete_nfslock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|fl
argument_list|,
name|nfslocklist
argument_list|)
expr_stmt|;
return|return
operator|(
name|NFS_GRANTED
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|split_status
name|split_nfslock
parameter_list|(
name|exist_lock
parameter_list|,
name|unlock_lock
parameter_list|,
name|left_lock
parameter_list|,
name|right_lock
parameter_list|)
specifier|const
name|struct
name|file_lock
modifier|*
name|exist_lock
decl_stmt|,
decl|*
name|unlock_lock
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|file_lock
modifier|*
modifier|*
name|left_lock
decl_stmt|,
modifier|*
modifier|*
name|right_lock
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_int64_t
name|start1
decl_stmt|,
name|len1
decl_stmt|,
name|start2
decl_stmt|,
name|len2
decl_stmt|;
name|enum
name|split_status
name|spstatus
decl_stmt|;
name|spstatus
operator|=
name|region_compare
argument_list|(
name|exist_lock
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|exist_lock
operator|->
name|client
operator|.
name|l_len
argument_list|,
name|unlock_lock
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|unlock_lock
operator|->
name|client
operator|.
name|l_len
argument_list|,
operator|&
name|start1
argument_list|,
operator|&
name|len1
argument_list|,
operator|&
name|start2
argument_list|,
operator|&
name|len2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spstatus
operator|&
name|SPL_LOCK1
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|left_lock
operator|=
name|allocate_file_lock
argument_list|(
operator|&
name|exist_lock
operator|->
name|client
operator|.
name|oh
argument_list|,
operator|&
name|exist_lock
operator|->
name|client_cookie
argument_list|,
name|exist_lock
operator|->
name|addr
argument_list|,
name|exist_lock
operator|->
name|client_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|left_lock
operator|==
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|"Unable to allocate resource for split 1\n"
argument_list|)
expr_stmt|;
return|return
name|SPL_RESERR
return|;
block|}
name|fill_file_lock
argument_list|(
operator|*
name|left_lock
argument_list|,
operator|&
name|exist_lock
operator|->
name|filehandle
argument_list|,
name|exist_lock
operator|->
name|client
operator|.
name|exclusive
argument_list|,
name|exist_lock
operator|->
name|client
operator|.
name|svid
argument_list|,
name|start1
argument_list|,
name|len1
argument_list|,
name|exist_lock
operator|->
name|nsm_status
argument_list|,
name|exist_lock
operator|->
name|status
argument_list|,
name|exist_lock
operator|->
name|flags
argument_list|,
name|exist_lock
operator|->
name|blocking
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spstatus
operator|&
name|SPL_LOCK2
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|right_lock
operator|=
name|allocate_file_lock
argument_list|(
operator|&
name|exist_lock
operator|->
name|client
operator|.
name|oh
argument_list|,
operator|&
name|exist_lock
operator|->
name|client_cookie
argument_list|,
name|exist_lock
operator|->
name|addr
argument_list|,
name|exist_lock
operator|->
name|client_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|right_lock
operator|==
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|"Unable to allocate resource for split 1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|left_lock
operator|!=
name|NULL
condition|)
block|{
name|deallocate_file_lock
argument_list|(
operator|*
name|left_lock
argument_list|)
expr_stmt|;
block|}
return|return
name|SPL_RESERR
return|;
block|}
name|fill_file_lock
argument_list|(
operator|*
name|right_lock
argument_list|,
operator|&
name|exist_lock
operator|->
name|filehandle
argument_list|,
name|exist_lock
operator|->
name|client
operator|.
name|exclusive
argument_list|,
name|exist_lock
operator|->
name|client
operator|.
name|svid
argument_list|,
name|start2
argument_list|,
name|len2
argument_list|,
name|exist_lock
operator|->
name|nsm_status
argument_list|,
name|exist_lock
operator|->
name|status
argument_list|,
name|exist_lock
operator|->
name|flags
argument_list|,
name|exist_lock
operator|->
name|blocking
argument_list|)
expr_stmt|;
block|}
return|return
name|spstatus
return|;
block|}
end_block

begin_function
name|enum
name|nfslock_status
name|unlock_nfslock
parameter_list|(
name|fl
parameter_list|,
name|released_lock
parameter_list|,
name|left_lock
parameter_list|,
name|right_lock
parameter_list|)
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
decl_stmt|;
name|struct
name|file_lock
modifier|*
modifier|*
name|released_lock
decl_stmt|;
name|struct
name|file_lock
modifier|*
modifier|*
name|left_lock
decl_stmt|;
name|struct
name|file_lock
modifier|*
modifier|*
name|right_lock
decl_stmt|;
block|{
name|struct
name|file_lock
modifier|*
name|mfl
decl_stmt|;
comment|/* Matching file lock */
name|enum
name|nfslock_status
name|retval
decl_stmt|;
name|enum
name|split_status
name|spstatus
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering unlock_nfslock\n"
argument_list|)
expr_stmt|;
operator|*
name|released_lock
operator|=
name|NULL
expr_stmt|;
operator|*
name|left_lock
operator|=
name|NULL
expr_stmt|;
operator|*
name|right_lock
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|NFS_DENIED_NOLOCK
expr_stmt|;
name|debuglog
argument_list|(
literal|"Attempting to match lock...\n"
argument_list|)
expr_stmt|;
name|mfl
operator|=
name|get_lock_matching_unlock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfl
operator|!=
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|"Unlock matched.  Querying for split\n"
argument_list|)
expr_stmt|;
name|spstatus
operator|=
name|split_nfslock
argument_list|(
name|mfl
argument_list|,
name|fl
argument_list|,
name|left_lock
argument_list|,
name|right_lock
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Split returned %d %p %p %p %p\n"
argument_list|,
name|spstatus
argument_list|,
name|mfl
argument_list|,
name|fl
argument_list|,
operator|*
name|left_lock
argument_list|,
operator|*
name|right_lock
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"********Split dumps********"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|mfl
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
operator|*
name|left_lock
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
operator|*
name|right_lock
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"********End Split dumps********"
argument_list|)
expr_stmt|;
if|if
condition|(
name|spstatus
operator|==
name|SPL_RESERR
condition|)
block|{
if|if
condition|(
operator|*
name|left_lock
operator|!=
name|NULL
condition|)
block|{
name|deallocate_file_lock
argument_list|(
operator|*
name|left_lock
argument_list|)
expr_stmt|;
operator|*
name|left_lock
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|right_lock
operator|!=
name|NULL
condition|)
block|{
name|deallocate_file_lock
argument_list|(
operator|*
name|right_lock
argument_list|)
expr_stmt|;
operator|*
name|right_lock
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|NFS_RESERR
return|;
block|}
comment|/* Insert new locks from split if required */
if|if
condition|(
operator|*
name|left_lock
operator|!=
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|"Split left activated\n"
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|nfslocklist_head
argument_list|,
operator|*
name|left_lock
argument_list|,
name|nfslocklist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|right_lock
operator|!=
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|"Split right activated\n"
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|nfslocklist_head
argument_list|,
operator|*
name|right_lock
argument_list|,
name|nfslocklist
argument_list|)
expr_stmt|;
block|}
comment|/* Unlock the lock since it matches identity */
name|LIST_REMOVE
argument_list|(
name|mfl
argument_list|,
name|nfslocklist
argument_list|)
expr_stmt|;
operator|*
name|released_lock
operator|=
name|mfl
expr_stmt|;
name|retval
operator|=
name|NFS_GRANTED
expr_stmt|;
block|}
name|debuglog
argument_list|(
literal|"Exiting unlock_nfslock\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Below here are the routines for manipulating the file lock directly  * on the disk hardware itself  */
end_comment

begin_function
name|enum
name|hwlock_status
name|lock_hwlock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|monfile
modifier|*
name|imf
decl_stmt|,
modifier|*
name|nmf
decl_stmt|;
name|int
name|lflags
decl_stmt|,
name|flerror
decl_stmt|;
comment|/* Scan to see if filehandle already present */
name|LIST_FOREACH
argument_list|(
argument|imf
argument_list|,
argument|&monfilelist_head
argument_list|,
argument|monfilelist
argument_list|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
operator|&
name|imf
operator|->
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fl
operator|->
name|filehandle
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* imf is the correct filehandle */
break|break;
block|}
block|}
comment|/* 	 * Filehandle already exists (we control the file) 	 * *AND* NFS has already cleared the lock for availability 	 * Grant it and bump the refcount. 	 */
if|if
condition|(
name|imf
operator|!=
name|NULL
condition|)
block|{
operator|++
operator|(
name|imf
operator|->
name|refcount
operator|)
expr_stmt|;
return|return
operator|(
name|HW_GRANTED
operator|)
return|;
block|}
comment|/* No filehandle found, create and go */
name|nmf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|monfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmf
operator|==
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|"hwlock resource allocation failure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|HW_RESERR
operator|)
return|;
block|}
comment|/* XXX: Is O_RDWR always the correct mode? */
name|nmf
operator|->
name|fd
operator|=
name|fhopen
argument_list|(
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmf
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|debuglog
argument_list|(
literal|"fhopen failed (from %16s): %32s\n"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nmf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ESTALE
case|:
return|return
operator|(
name|HW_STALEFH
operator|)
return|;
case|case
name|EROFS
case|:
return|return
operator|(
name|HW_READONLY
operator|)
return|;
default|default:
return|return
operator|(
name|HW_RESERR
operator|)
return|;
block|}
block|}
comment|/* File opened correctly, fill the monitor struct */
name|bcopy
argument_list|(
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
operator|&
name|nmf
operator|->
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fl
operator|->
name|filehandle
argument_list|)
argument_list|)
expr_stmt|;
name|nmf
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|nmf
operator|->
name|exclusive
operator|=
name|fl
operator|->
name|client
operator|.
name|exclusive
expr_stmt|;
name|lflags
operator|=
operator|(
name|nmf
operator|->
name|exclusive
operator|==
literal|1
operator|)
condition|?
operator|(
name|LOCK_EX
operator||
name|LOCK_NB
operator|)
else|:
operator|(
name|LOCK_SH
operator||
name|LOCK_NB
operator|)
expr_stmt|;
name|flerror
operator|=
name|flock
argument_list|(
name|nmf
operator|->
name|fd
argument_list|,
name|lflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flerror
operator|!=
literal|0
condition|)
block|{
name|debuglog
argument_list|(
literal|"flock failed (from %16s): %32s\n"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|nmf
operator|->
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nmf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EAGAIN
case|:
return|return
operator|(
name|HW_DENIED
operator|)
return|;
case|case
name|ESTALE
case|:
return|return
operator|(
name|HW_STALEFH
operator|)
return|;
case|case
name|EROFS
case|:
return|return
operator|(
name|HW_READONLY
operator|)
return|;
default|default:
return|return
operator|(
name|HW_RESERR
operator|)
return|;
break|break;
block|}
block|}
comment|/* File opened and locked */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|monfilelist_head
argument_list|,
name|nmf
argument_list|,
name|monfilelist
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"flock succeeded (from %16s)\n"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|HW_GRANTED
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|hwlock_status
name|unlock_hwlock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|monfile
modifier|*
name|imf
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering unlock_hwlock\n"
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Entering loop interation\n"
argument_list|)
expr_stmt|;
comment|/* Scan to see if filehandle already present */
name|LIST_FOREACH
argument_list|(
argument|imf
argument_list|,
argument|&monfilelist_head
argument_list|,
argument|monfilelist
argument_list|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
operator|&
name|imf
operator|->
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fl
operator|->
name|filehandle
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* imf is the correct filehandle */
break|break;
block|}
block|}
name|debuglog
argument_list|(
literal|"Completed iteration.  Proceeding\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|imf
operator|==
name|NULL
condition|)
block|{
comment|/* No lock found */
name|debuglog
argument_list|(
literal|"Exiting unlock_hwlock (HW_DENIED_NOLOCK)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|HW_DENIED_NOLOCK
operator|)
return|;
block|}
comment|/* Lock found */
operator|--
name|imf
operator|->
name|refcount
expr_stmt|;
if|if
condition|(
name|imf
operator|->
name|refcount
operator|<
literal|0
condition|)
block|{
name|debuglog
argument_list|(
literal|"Negative hardware reference count\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|imf
operator|->
name|refcount
operator|<=
literal|0
condition|)
block|{
name|close
argument_list|(
name|imf
operator|->
name|fd
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|imf
argument_list|,
name|monfilelist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imf
argument_list|)
expr_stmt|;
block|}
name|debuglog
argument_list|(
literal|"Exiting unlock_hwlock (HW_GRANTED)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|HW_GRANTED
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|hwlock_status
name|test_hwlock
parameter_list|(
name|fl
parameter_list|,
name|conflicting_fl
parameter_list|)
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
name|__unused
decl_stmt|;
name|struct
name|file_lock
modifier|*
modifier|*
name|conflicting_fl
name|__unused
decl_stmt|;
block|{
comment|/* 	 * XXX: lock tests on hardware are not required until 	 * true partial file testing is done on the underlying file 	 */
return|return
operator|(
name|HW_RESERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Below here are routines for manipulating blocked lock requests  * They should only be called from the XXX_partialfilelock routines  * if at all possible  */
end_comment

begin_function
name|int
name|duplicate_block
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|file_lock
modifier|*
name|ifl
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering duplicate_block"
argument_list|)
expr_stmt|;
comment|/* 	 * Is this lock request already on the blocking list? 	 * Consider it a dupe if the file handles, offset, length, 	 * exclusivity and client match. 	 */
name|LIST_FOREACH
argument_list|(
argument|ifl
argument_list|,
argument|&blockedlocklist_head
argument_list|,
argument|nfslocklist
argument_list|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
operator|&
name|ifl
operator|->
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
operator|&&
name|fl
operator|->
name|client
operator|.
name|exclusive
operator|==
name|ifl
operator|->
name|client
operator|.
name|exclusive
operator|&&
name|fl
operator|->
name|client
operator|.
name|l_offset
operator|==
name|ifl
operator|->
name|client
operator|.
name|l_offset
operator|&&
name|fl
operator|->
name|client
operator|.
name|l_len
operator|==
name|ifl
operator|->
name|client
operator|.
name|l_len
operator|&&
name|same_filelock_identity
argument_list|(
name|fl
argument_list|,
name|ifl
argument_list|)
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|debuglog
argument_list|(
literal|"Exiting duplicate_block: %s\n"
argument_list|,
name|retval
condition|?
literal|"already blocked"
else|:
literal|"not already blocked"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|void
name|add_blockingfilelock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|debuglog
argument_list|(
literal|"Entering add_blockingfilelock\n"
argument_list|)
expr_stmt|;
comment|/* 	 * A blocking lock request _should_ never be duplicated as a client 	 * that is already blocked shouldn't be able to request another 	 * lock. Alas, there are some buggy clients that do request the same 	 * lock repeatedly. Make sure only unique locks are on the blocked 	 * lock list. 	 */
if|if
condition|(
name|duplicate_block
argument_list|(
name|fl
argument_list|)
condition|)
block|{
name|debuglog
argument_list|(
literal|"Exiting add_blockingfilelock: already blocked\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Clear the blocking flag so that it can be reused without 	 * adding it to the blocking queue a second time 	 */
name|fl
operator|->
name|blocking
operator|=
literal|0
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|blockedlocklist_head
argument_list|,
name|fl
argument_list|,
name|nfslocklist
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Exiting add_blockingfilelock: added blocked lock\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|remove_blockingfilelock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|debuglog
argument_list|(
literal|"Entering remove_blockingfilelock\n"
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|fl
argument_list|,
name|nfslocklist
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Exiting remove_blockingfilelock\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_blockingfilelock
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|struct
name|file_lock
modifier|*
name|ifl
decl_stmt|,
modifier|*
name|nfl
decl_stmt|;
comment|/* 	 * Normally, LIST_FOREACH is called for, but since 	 * the current element *is* the iterator, deleting it 	 * would mess up the iteration.  Thus, a next element 	 * must be used explicitly 	 */
name|ifl
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|blockedlocklist_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|ifl
operator|!=
name|NULL
condition|)
block|{
name|nfl
operator|=
name|LIST_NEXT
argument_list|(
name|ifl
argument_list|,
name|nfslocklist
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|hostname
argument_list|,
name|ifl
operator|->
name|client_name
argument_list|,
name|SM_MAXSTRLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|remove_blockingfilelock
argument_list|(
name|ifl
argument_list|)
expr_stmt|;
name|deallocate_file_lock
argument_list|(
name|ifl
argument_list|)
expr_stmt|;
block|}
name|ifl
operator|=
name|nfl
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|retry_blockingfilelocklist
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Retry all locks in the blocked list */
name|struct
name|file_lock
modifier|*
name|ifl
decl_stmt|,
modifier|*
name|nfl
decl_stmt|;
comment|/* Iterator */
name|enum
name|partialfilelock_status
name|pflstatus
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering retry_blockingfilelocklist\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|ifl
argument_list|,
argument|&blockedlocklist_head
argument_list|,
argument|nfslocklist
argument_list|,
argument|nfl
argument_list|)
block|{
name|debuglog
argument_list|(
literal|"Iterator choice %p\n"
argument_list|,
name|ifl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Next iterator choice %p\n"
argument_list|,
name|nfl
argument_list|)
expr_stmt|;
comment|/* 		 * SUBTLE BUG: The file_lock must be removed from the 		 * old list so that it's list pointers get disconnected 		 * before being allowed to participate in the new list 		 * which will automatically add it in if necessary. 		 */
name|LIST_REMOVE
argument_list|(
name|ifl
argument_list|,
name|nfslocklist
argument_list|)
expr_stmt|;
name|pflstatus
operator|=
name|lock_partialfilelock
argument_list|(
name|ifl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pflstatus
operator|==
name|PFL_GRANTED
operator|||
name|pflstatus
operator|==
name|PFL_GRANTED_DUPLICATE
condition|)
block|{
name|debuglog
argument_list|(
literal|"Granted blocked lock\n"
argument_list|)
expr_stmt|;
comment|/* lock granted and is now being used */
name|send_granted
argument_list|(
name|ifl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Reinsert lock back into blocked list */
name|debuglog
argument_list|(
literal|"Replacing blocked lock\n"
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|blockedlocklist_head
argument_list|,
name|ifl
argument_list|,
name|nfslocklist
argument_list|)
expr_stmt|;
block|}
block|}
name|debuglog
argument_list|(
literal|"Exiting retry_blockingfilelocklist\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Below here are routines associated with manipulating all  * aspects of the partial file locking system (list, hardware, etc.)  */
end_comment

begin_comment
comment|/*  * Please note that lock monitoring must be done at this level which  * keeps track of *individual* lock requests on lock and unlock  *  * XXX: Split unlocking is going to make the unlock code miserable  */
end_comment

begin_comment
comment|/*  * lock_partialfilelock:  *  * Argument fl gets modified as its list housekeeping entries get modified  * upon insertion into the NFS lock list  *  * This routine makes several assumptions:  * 1) It (will) pass locks through to flock to lock the entire underlying file  *     and then parcel out NFS locks if it gets control of the file.  *         This matches the old rpc.lockd file semantics (except where it  *         is now more correct).  It is the safe solution, but will cause  *         overly restrictive blocking if someone is trying to use the  *         underlying files without using NFS.  This appears to be an  *         acceptable tradeoff since most people use standalone NFS servers.  * XXX: The right solution is probably kevent combined with fcntl  *  *    2) Nothing modifies the lock lists between testing and granting  *           I have no idea whether this is a useful assumption or not  */
end_comment

begin_function
name|enum
name|partialfilelock_status
name|lock_partialfilelock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|enum
name|partialfilelock_status
name|retval
decl_stmt|;
name|enum
name|nfslock_status
name|lnlstatus
decl_stmt|;
name|enum
name|hwlock_status
name|hwstatus
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering lock_partialfilelock\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PFL_DENIED
expr_stmt|;
comment|/* 	 * Execute the NFS lock first, if possible, as it is significantly 	 * easier and less expensive to undo than the filesystem lock 	 */
name|lnlstatus
operator|=
name|lock_nfslock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lnlstatus
condition|)
block|{
case|case
name|NFS_GRANTED
case|:
case|case
name|NFS_GRANTED_DUPLICATE
case|:
comment|/* 		 * At this point, the NFS lock is allocated and active. 		 * Remember to clean it up if the hardware lock fails 		 */
name|hwstatus
operator|=
name|lock_hwlock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hwstatus
condition|)
block|{
case|case
name|HW_GRANTED
case|:
case|case
name|HW_GRANTED_DUPLICATE
case|:
name|debuglog
argument_list|(
literal|"HW GRANTED\n"
argument_list|)
expr_stmt|;
comment|/* 			 * XXX: Fixme: Check hwstatus for duplicate when 			 * true partial file locking and accounting is 			 * done on the hardware. 			 */
if|if
condition|(
name|lnlstatus
operator|==
name|NFS_GRANTED_DUPLICATE
condition|)
block|{
name|retval
operator|=
name|PFL_GRANTED_DUPLICATE
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|PFL_GRANTED
expr_stmt|;
block|}
name|monitor_lock_host
argument_list|(
name|fl
operator|->
name|client_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|HW_RESERR
case|:
name|debuglog
argument_list|(
literal|"HW RESERR\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PFL_HWRESERR
expr_stmt|;
break|break;
case|case
name|HW_DENIED
case|:
name|debuglog
argument_list|(
literal|"HW DENIED\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PFL_HWDENIED
expr_stmt|;
break|break;
default|default:
name|debuglog
argument_list|(
literal|"Unmatched hwstatus %d\n"
argument_list|,
name|hwstatus
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|retval
operator|!=
name|PFL_GRANTED
operator|&&
name|retval
operator|!=
name|PFL_GRANTED_DUPLICATE
condition|)
block|{
comment|/* Clean up the NFS lock */
name|debuglog
argument_list|(
literal|"Deleting trial NFS lock\n"
argument_list|)
expr_stmt|;
name|delete_nfslock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NFS_DENIED
case|:
name|retval
operator|=
name|PFL_NFSDENIED
expr_stmt|;
break|break;
case|case
name|NFS_RESERR
case|:
name|retval
operator|=
name|PFL_NFSRESERR
expr_stmt|;
break|break;
default|default:
name|debuglog
argument_list|(
literal|"Unmatched lnlstatus %d\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PFL_NFSDENIED_NOLOCK
expr_stmt|;
break|break;
block|}
comment|/* 	 * By the time fl reaches here, it is completely free again on 	 * failure.  The NFS lock done before attempting the 	 * hardware lock has been backed out 	 */
if|if
condition|(
name|retval
operator|==
name|PFL_NFSDENIED
operator|||
name|retval
operator|==
name|PFL_HWDENIED
condition|)
block|{
comment|/* Once last chance to check the lock */
if|if
condition|(
name|fl
operator|->
name|blocking
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|retval
operator|==
name|PFL_NFSDENIED
condition|)
block|{
comment|/* Queue the lock */
name|debuglog
argument_list|(
literal|"BLOCKING LOCK RECEIVED\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PFL_NFSBLOCKED
expr_stmt|;
name|add_blockingfilelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* retval is okay as PFL_HWDENIED */
name|debuglog
argument_list|(
literal|"BLOCKING LOCK DENIED IN HARDWARE\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Leave retval alone, it's already correct */
name|debuglog
argument_list|(
literal|"Lock denied.  Non-blocking failure\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
block|}
name|debuglog
argument_list|(
literal|"Exiting lock_partialfilelock\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * unlock_partialfilelock:  *  * Given a file_lock, unlock all locks which match.  *  * Note that a given lock might have to unlock ITSELF!  See  * clear_partialfilelock for example.  */
end_comment

begin_function
name|enum
name|partialfilelock_status
name|unlock_partialfilelock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|file_lock
modifier|*
name|lfl
decl_stmt|,
modifier|*
name|rfl
decl_stmt|,
modifier|*
name|releasedfl
decl_stmt|,
modifier|*
name|selffl
decl_stmt|;
name|enum
name|partialfilelock_status
name|retval
decl_stmt|;
name|enum
name|nfslock_status
name|unlstatus
decl_stmt|;
name|enum
name|hwlock_status
name|unlhwstatus
decl_stmt|,
name|lhwstatus
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering unlock_partialfilelock\n"
argument_list|)
expr_stmt|;
name|selffl
operator|=
name|NULL
expr_stmt|;
name|lfl
operator|=
name|NULL
expr_stmt|;
name|rfl
operator|=
name|NULL
expr_stmt|;
name|releasedfl
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
name|PFL_DENIED
expr_stmt|;
comment|/* 	 * There are significant overlap and atomicity issues 	 * with partially releasing a lock.  For example, releasing 	 * part of an NFS shared lock does *not* always release the 	 * corresponding part of the file since there is only one 	 * rpc.lockd UID but multiple users could be requesting it 	 * from NFS.  Also, an unlock request should never allow 	 * another process to gain a lock on the remaining parts. 	 * ie. Always apply the new locks before releasing the 	 * old one 	 */
comment|/* 	 * Loop is required since multiple little locks 	 * can be allocated and then deallocated with one 	 * big unlock. 	 * 	 * The loop is required to be here so that the nfs& 	 * hw subsystems do not need to communicate with one 	 * one another 	 */
do|do
block|{
name|debuglog
argument_list|(
literal|"Value of releasedfl: %p\n"
argument_list|,
name|releasedfl
argument_list|)
expr_stmt|;
comment|/* lfl&rfl are created *AND* placed into the NFS lock list if required */
name|unlstatus
operator|=
name|unlock_nfslock
argument_list|(
name|fl
argument_list|,
operator|&
name|releasedfl
argument_list|,
operator|&
name|lfl
argument_list|,
operator|&
name|rfl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Value of releasedfl: %p\n"
argument_list|,
name|releasedfl
argument_list|)
expr_stmt|;
comment|/* XXX: This is grungy.  It should be refactored to be cleaner */
if|if
condition|(
name|lfl
operator|!=
name|NULL
condition|)
block|{
name|lhwstatus
operator|=
name|lock_hwlock
argument_list|(
name|lfl
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhwstatus
operator|!=
name|HW_GRANTED
operator|&&
name|lhwstatus
operator|!=
name|HW_GRANTED_DUPLICATE
condition|)
block|{
name|debuglog
argument_list|(
literal|"HW duplicate lock failure for left split\n"
argument_list|)
expr_stmt|;
block|}
name|monitor_lock_host
argument_list|(
name|lfl
operator|->
name|client_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rfl
operator|!=
name|NULL
condition|)
block|{
name|lhwstatus
operator|=
name|lock_hwlock
argument_list|(
name|rfl
argument_list|)
expr_stmt|;
if|if
condition|(
name|lhwstatus
operator|!=
name|HW_GRANTED
operator|&&
name|lhwstatus
operator|!=
name|HW_GRANTED_DUPLICATE
condition|)
block|{
name|debuglog
argument_list|(
literal|"HW duplicate lock failure for right split\n"
argument_list|)
expr_stmt|;
block|}
name|monitor_lock_host
argument_list|(
name|rfl
operator|->
name|client_name
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|unlstatus
condition|)
block|{
case|case
name|NFS_GRANTED
case|:
comment|/* Attempt to unlock on the hardware */
name|debuglog
argument_list|(
literal|"NFS unlock granted.  Attempting hardware unlock\n"
argument_list|)
expr_stmt|;
comment|/* This call *MUST NOT* unlock the two newly allocated locks */
name|unlhwstatus
operator|=
name|unlock_hwlock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"HW unlock returned with code %d\n"
argument_list|,
name|unlhwstatus
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|unlhwstatus
condition|)
block|{
case|case
name|HW_GRANTED
case|:
name|debuglog
argument_list|(
literal|"HW unlock granted\n"
argument_list|)
expr_stmt|;
name|unmonitor_lock_host
argument_list|(
name|releasedfl
operator|->
name|client_name
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PFL_GRANTED
expr_stmt|;
break|break;
case|case
name|HW_DENIED_NOLOCK
case|:
comment|/* Huh?!?!  This shouldn't happen */
name|debuglog
argument_list|(
literal|"HW unlock denied no lock\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PFL_HWRESERR
expr_stmt|;
comment|/* Break out of do-while */
name|unlstatus
operator|=
name|NFS_RESERR
expr_stmt|;
break|break;
default|default:
name|debuglog
argument_list|(
literal|"HW unlock failed\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PFL_HWRESERR
expr_stmt|;
comment|/* Break out of do-while */
name|unlstatus
operator|=
name|NFS_RESERR
expr_stmt|;
break|break;
block|}
name|debuglog
argument_list|(
literal|"Exiting with status retval: %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|retry_blockingfilelocklist
argument_list|()
expr_stmt|;
break|break;
case|case
name|NFS_DENIED_NOLOCK
case|:
name|retval
operator|=
name|PFL_GRANTED
expr_stmt|;
name|debuglog
argument_list|(
literal|"All locks cleaned out\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
name|PFL_NFSRESERR
expr_stmt|;
name|debuglog
argument_list|(
literal|"NFS unlock failure\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|releasedfl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fl
operator|==
name|releasedfl
condition|)
block|{
comment|/* 				 * XXX: YECHHH!!! Attempt to unlock self succeeded 				 * but we can't deallocate the space yet.  This is what 				 * happens when you don't write malloc and free together 				 */
name|debuglog
argument_list|(
literal|"Attempt to unlock self\n"
argument_list|)
expr_stmt|;
name|selffl
operator|=
name|releasedfl
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * XXX: this deallocation *still* needs to migrate closer 				 * to the allocation code way up in get_lock or the allocation 				 * code needs to migrate down (violation of "When you write 				 * malloc you must write free") 				 */
name|deallocate_file_lock
argument_list|(
name|releasedfl
argument_list|)
expr_stmt|;
name|releasedfl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|unlstatus
operator|==
name|NFS_GRANTED
condition|)
do|;
if|if
condition|(
name|selffl
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * This statement wipes out the incoming file lock (fl) 		 * in spite of the fact that it is declared const 		 */
name|debuglog
argument_list|(
literal|"WARNING!  Destroying incoming lock pointer\n"
argument_list|)
expr_stmt|;
name|deallocate_file_lock
argument_list|(
name|selffl
argument_list|)
expr_stmt|;
block|}
name|debuglog
argument_list|(
literal|"Exiting unlock_partialfilelock\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * clear_partialfilelock  *  * Normally called in response to statd state number change.  * Wipe out all locks held by a host.  As a bonus, the act of  * doing so should automatically clear their statd entries and  * unmonitor the host.  */
end_comment

begin_function
name|void
name|clear_partialfilelock
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|struct
name|file_lock
modifier|*
name|ifl
decl_stmt|,
modifier|*
name|nfl
decl_stmt|;
comment|/* Clear blocking file lock list */
name|clear_blockingfilelock
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
comment|/* do all required unlocks */
comment|/* Note that unlock can smash the current pointer to a lock */
comment|/* 	 * Normally, LIST_FOREACH is called for, but since 	 * the current element *is* the iterator, deleting it 	 * would mess up the iteration.  Thus, a next element 	 * must be used explicitly 	 */
name|ifl
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|nfslocklist_head
argument_list|)
expr_stmt|;
while|while
condition|(
name|ifl
operator|!=
name|NULL
condition|)
block|{
name|nfl
operator|=
name|LIST_NEXT
argument_list|(
name|ifl
argument_list|,
name|nfslocklist
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|hostname
argument_list|,
name|ifl
operator|->
name|client_name
argument_list|,
name|SM_MAXSTRLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Unlock destroys ifl out from underneath */
name|unlock_partialfilelock
argument_list|(
name|ifl
argument_list|)
expr_stmt|;
comment|/* ifl is NO LONGER VALID AT THIS POINT */
block|}
name|ifl
operator|=
name|nfl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * test_partialfilelock:  */
end_comment

begin_function
name|enum
name|partialfilelock_status
name|test_partialfilelock
parameter_list|(
specifier|const
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|conflicting_fl
parameter_list|)
block|{
name|enum
name|partialfilelock_status
name|retval
decl_stmt|;
name|enum
name|nfslock_status
name|teststatus
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering testpartialfilelock...\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|PFL_DENIED
expr_stmt|;
name|teststatus
operator|=
name|test_nfslock
argument_list|(
name|fl
argument_list|,
name|conflicting_fl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"test_partialfilelock: teststatus %d\n"
argument_list|,
name|teststatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|teststatus
operator|==
name|NFS_GRANTED
operator|||
name|teststatus
operator|==
name|NFS_GRANTED_DUPLICATE
condition|)
block|{
comment|/* XXX: Add the underlying filesystem locking code */
name|retval
operator|=
operator|(
name|teststatus
operator|==
name|NFS_GRANTED
operator|)
condition|?
name|PFL_GRANTED
else|:
name|PFL_GRANTED_DUPLICATE
expr_stmt|;
name|debuglog
argument_list|(
literal|"Dumping locks...\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
operator|*
name|conflicting_fl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Done dumping locks...\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|PFL_NFSDENIED
expr_stmt|;
name|debuglog
argument_list|(
literal|"NFS test denied.\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Conflicting.\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
operator|*
name|conflicting_fl
argument_list|)
expr_stmt|;
block|}
name|debuglog
argument_list|(
literal|"Exiting testpartialfilelock...\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Below here are routines associated with translating the partial file locking  * codes into useful codes to send back to the NFS RPC messaging system  */
end_comment

begin_comment
comment|/*  * These routines translate the (relatively) useful return codes back onto  * the few return codes which the nlm subsystems wishes to trasmit  */
end_comment

begin_function
name|enum
name|nlm_stats
name|do_test
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|,
name|struct
name|file_lock
modifier|*
modifier|*
name|conflicting_fl
parameter_list|)
block|{
name|enum
name|partialfilelock_status
name|pfsret
decl_stmt|;
name|enum
name|nlm_stats
name|retval
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering do_test...\n"
argument_list|)
expr_stmt|;
name|pfsret
operator|=
name|test_partialfilelock
argument_list|(
name|fl
argument_list|,
name|conflicting_fl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pfsret
condition|)
block|{
case|case
name|PFL_GRANTED
case|:
name|debuglog
argument_list|(
literal|"PFL test lock granted\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
operator|*
name|conflicting_fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
expr_stmt|;
break|break;
case|case
name|PFL_GRANTED_DUPLICATE
case|:
name|debuglog
argument_list|(
literal|"PFL test lock granted--duplicate id detected\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
operator|*
name|conflicting_fl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Clearing conflicting_fl for call semantics\n"
argument_list|)
expr_stmt|;
operator|*
name|conflicting_fl
operator|=
name|NULL
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
expr_stmt|;
break|break;
case|case
name|PFL_NFSDENIED
case|:
case|case
name|PFL_HWDENIED
case|:
name|debuglog
argument_list|(
literal|"PFL test lock denied\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
operator|*
name|conflicting_fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied
else|:
name|nlm_denied
expr_stmt|;
break|break;
case|case
name|PFL_NFSRESERR
case|:
case|case
name|PFL_HWRESERR
case|:
name|debuglog
argument_list|(
literal|"PFL test lock resource fail\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
operator|*
name|conflicting_fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied_nolocks
else|:
name|nlm_denied_nolocks
expr_stmt|;
break|break;
default|default:
name|debuglog
argument_list|(
literal|"PFL test lock *FAILED*\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
operator|*
name|conflicting_fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_failed
else|:
name|nlm_denied
expr_stmt|;
break|break;
block|}
name|debuglog
argument_list|(
literal|"Exiting do_test...\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * do_lock: Try to acquire a lock  *  * This routine makes a distinction between NLM versions.  I am pretty  * convinced that this should be abstracted out and bounced up a level  */
end_comment

begin_function
name|enum
name|nlm_stats
name|do_lock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|enum
name|partialfilelock_status
name|pfsret
decl_stmt|;
name|enum
name|nlm_stats
name|retval
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering do_lock...\n"
argument_list|)
expr_stmt|;
name|pfsret
operator|=
name|lock_partialfilelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pfsret
condition|)
block|{
case|case
name|PFL_GRANTED
case|:
name|debuglog
argument_list|(
literal|"PFL lock granted"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
expr_stmt|;
break|break;
case|case
name|PFL_GRANTED_DUPLICATE
case|:
name|debuglog
argument_list|(
literal|"PFL lock granted--duplicate id detected"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
expr_stmt|;
break|break;
case|case
name|PFL_NFSDENIED
case|:
case|case
name|PFL_HWDENIED
case|:
name|debuglog
argument_list|(
literal|"PFL_NFS lock denied"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied
else|:
name|nlm_denied
expr_stmt|;
break|break;
case|case
name|PFL_NFSBLOCKED
case|:
case|case
name|PFL_HWBLOCKED
case|:
name|debuglog
argument_list|(
literal|"PFL_NFS blocking lock denied.  Queued.\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_blocked
else|:
name|nlm_blocked
expr_stmt|;
break|break;
case|case
name|PFL_NFSRESERR
case|:
case|case
name|PFL_HWRESERR
case|:
name|debuglog
argument_list|(
literal|"PFL lock resource alocation fail\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied_nolocks
else|:
name|nlm_denied_nolocks
expr_stmt|;
break|break;
default|default:
name|debuglog
argument_list|(
literal|"PFL lock *FAILED*"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_failed
else|:
name|nlm_denied
expr_stmt|;
break|break;
block|}
name|debuglog
argument_list|(
literal|"Exiting do_lock...\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
name|enum
name|nlm_stats
name|do_unlock
parameter_list|(
name|struct
name|file_lock
modifier|*
name|fl
parameter_list|)
block|{
name|enum
name|partialfilelock_status
name|pfsret
decl_stmt|;
name|enum
name|nlm_stats
name|retval
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering do_unlock...\n"
argument_list|)
expr_stmt|;
name|pfsret
operator|=
name|unlock_partialfilelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pfsret
condition|)
block|{
case|case
name|PFL_GRANTED
case|:
name|debuglog
argument_list|(
literal|"PFL unlock granted"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
expr_stmt|;
break|break;
case|case
name|PFL_NFSDENIED
case|:
case|case
name|PFL_HWDENIED
case|:
name|debuglog
argument_list|(
literal|"PFL_NFS unlock denied"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied
else|:
name|nlm_denied
expr_stmt|;
break|break;
case|case
name|PFL_NFSDENIED_NOLOCK
case|:
case|case
name|PFL_HWDENIED_NOLOCK
case|:
name|debuglog
argument_list|(
literal|"PFL_NFS no lock found\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
expr_stmt|;
break|break;
case|case
name|PFL_NFSRESERR
case|:
case|case
name|PFL_HWRESERR
case|:
name|debuglog
argument_list|(
literal|"PFL unlock resource failure"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied_nolocks
else|:
name|nlm_denied_nolocks
expr_stmt|;
break|break;
default|default:
name|debuglog
argument_list|(
literal|"PFL unlock *FAILED*"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_failed
else|:
name|nlm_denied
expr_stmt|;
break|break;
block|}
name|debuglog
argument_list|(
literal|"Exiting do_unlock...\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * do_clear  *  * This routine is non-existent because it doesn't have a return code.  * It is here for completeness in case someone *does* need to do return  * codes later.  A decent compiler should optimize this away.  */
end_comment

begin_function
name|void
name|do_clear
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|clear_partialfilelock
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The following routines are all called from the code which the  * RPC layer invokes  */
end_comment

begin_comment
comment|/*  * testlock(): inform the caller if the requested lock would be granted  *  * returns NULL if lock would granted  * returns pointer to a conflicting nlm4_holder if not  */
end_comment

begin_function
name|struct
name|nlm4_holder
modifier|*
name|testlock
parameter_list|(
name|struct
name|nlm4_lock
modifier|*
name|lock
parameter_list|,
name|bool_t
name|exclusive
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|file_lock
name|test_fl
decl_stmt|,
modifier|*
name|conflicting_fl
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|test_fl
argument_list|,
sizeof|sizeof
argument_list|(
name|test_fl
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|lock
operator|->
name|fh
operator|.
name|n_bytes
argument_list|,
operator|&
operator|(
name|test_fl
operator|.
name|filehandle
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
name|copy_nlm4_lock_to_nlm4_holder
argument_list|(
name|lock
argument_list|,
name|exclusive
argument_list|,
operator|&
name|test_fl
operator|.
name|client
argument_list|)
expr_stmt|;
name|siglock
argument_list|()
expr_stmt|;
name|do_test
argument_list|(
operator|&
name|test_fl
argument_list|,
operator|&
name|conflicting_fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicting_fl
operator|==
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|"No conflicting lock found\n"
argument_list|)
expr_stmt|;
name|sigunlock
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|debuglog
argument_list|(
literal|"Found conflicting lock\n"
argument_list|)
expr_stmt|;
name|dump_filelock
argument_list|(
name|conflicting_fl
argument_list|)
expr_stmt|;
name|sigunlock
argument_list|()
expr_stmt|;
return|return
operator|(
operator|&
name|conflicting_fl
operator|->
name|client
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * getlock: try to acquire the lock.  * If file is already locked and we can sleep, put the lock in the list with  * status LKST_WAITING; it'll be processed later.  * Otherwise try to lock. If we're allowed to block, fork a child which  * will do the blocking lock.  */
end_comment

begin_function
name|enum
name|nlm_stats
name|getlock
parameter_list|(
name|nlm4_lockargs
modifier|*
name|lckarg
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
specifier|const
name|int
name|flags
parameter_list|)
block|{
name|struct
name|file_lock
modifier|*
name|newfl
decl_stmt|;
name|enum
name|nlm_stats
name|retval
decl_stmt|;
name|debuglog
argument_list|(
literal|"Entering getlock...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|grace_expired
operator|==
literal|0
operator|&&
name|lckarg
operator|->
name|reclaim
operator|==
literal|0
condition|)
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied_grace_period
else|:
name|nlm_denied_grace_period
return|;
comment|/* allocate new file_lock for this request */
name|newfl
operator|=
name|allocate_file_lock
argument_list|(
operator|&
name|lckarg
operator|->
name|alock
operator|.
name|oh
argument_list|,
operator|&
name|lckarg
operator|->
name|cookie
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|svc_getrpccaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
operator|->
name|buf
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|caller_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfl
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"lock allocate failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* failed */
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied_nolocks
else|:
name|nlm_denied_nolocks
return|;
block|}
if|if
condition|(
name|lckarg
operator|->
name|alock
operator|.
name|fh
operator|.
name|n_len
operator|!=
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
condition|)
block|{
name|debuglog
argument_list|(
literal|"received fhandle size %d, local size %d"
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|fh
operator|.
name|n_len
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fill_file_lock
argument_list|(
name|newfl
argument_list|,
operator|(
name|fhandle_t
operator|*
operator|)
name|lckarg
operator|->
name|alock
operator|.
name|fh
operator|.
name|n_bytes
argument_list|,
name|lckarg
operator|->
name|exclusive
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|svid
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|l_offset
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|l_len
argument_list|,
name|lckarg
operator|->
name|state
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|lckarg
operator|->
name|block
argument_list|)
expr_stmt|;
comment|/* 	 * newfl is now fully constructed and deallocate_file_lock 	 * can now be used to delete it 	 */
name|siglock
argument_list|()
expr_stmt|;
name|debuglog
argument_list|(
literal|"Pointer to new lock is %p\n"
argument_list|,
name|newfl
argument_list|)
expr_stmt|;
name|retval
operator|=
name|do_lock
argument_list|(
name|newfl
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Pointer to new lock is %p\n"
argument_list|,
name|newfl
argument_list|)
expr_stmt|;
name|sigunlock
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|nlm4_granted
case|:
comment|/* case nlm_granted: is the same as nlm4_granted */
comment|/* do_mon(lckarg->alock.caller_name); */
break|break;
case|case
name|nlm4_blocked
case|:
comment|/* case nlm_blocked: is the same as nlm4_blocked */
comment|/* do_mon(lckarg->alock.caller_name); */
break|break;
default|default:
name|deallocate_file_lock
argument_list|(
name|newfl
argument_list|)
expr_stmt|;
break|break;
block|}
name|debuglog
argument_list|(
literal|"Exiting getlock...\n"
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* unlock a filehandle */
end_comment

begin_function
name|enum
name|nlm_stats
name|unlock
parameter_list|(
name|nlm4_lock
modifier|*
name|lock
parameter_list|,
specifier|const
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|file_lock
name|fl
decl_stmt|;
name|enum
name|nlm_stats
name|err
decl_stmt|;
name|siglock
argument_list|()
expr_stmt|;
name|debuglog
argument_list|(
literal|"Entering unlock...\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|fl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|file_lock
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|lock
operator|->
name|fh
operator|.
name|n_bytes
argument_list|,
operator|&
name|fl
operator|.
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
name|copy_nlm4_lock_to_nlm4_holder
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|,
operator|&
name|fl
operator|.
name|client
argument_list|)
expr_stmt|;
name|err
operator|=
name|do_unlock
argument_list|(
operator|&
name|fl
argument_list|)
expr_stmt|;
name|sigunlock
argument_list|()
expr_stmt|;
name|debuglog
argument_list|(
literal|"Exiting unlock...\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: The following monitor/unmonitor routines  * have not been extensively tested (ie. no regression  * script exists like for the locking sections  */
end_comment

begin_comment
comment|/*  * monitor_lock_host: monitor lock hosts locally with a ref count and  * inform statd  */
end_comment

begin_function
name|void
name|monitor_lock_host
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|struct
name|host
modifier|*
name|ihp
decl_stmt|,
modifier|*
name|nhp
decl_stmt|;
name|struct
name|mon
name|smon
decl_stmt|;
name|struct
name|sm_stat_res
name|sres
decl_stmt|;
name|int
name|rpcret
decl_stmt|,
name|statflag
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|rpcret
operator|=
literal|0
expr_stmt|;
name|statflag
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ihp
argument_list|,
argument|&hostlst_head
argument_list|,
argument|hostlst
argument_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|hostname
argument_list|,
name|ihp
operator|->
name|name
argument_list|,
name|SM_MAXSTRLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Host is already monitored, bump refcount */
operator|++
name|ihp
operator|->
name|refcnt
expr_stmt|;
comment|/* Host should only be in the monitor list once */
return|return;
block|}
block|}
comment|/* Host is not yet monitored, add it */
name|n
operator|=
name|strnlen
argument_list|(
name|hostname
argument_list|,
name|SM_MAXSTRLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|SM_MAXSTRLEN
condition|)
block|{
return|return;
block|}
name|nhp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nhp
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|nhp
operator|->
name|name
argument_list|)
operator|+
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nhp
operator|==
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|"Unable to allocate entry for statd mon\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Allocated new host entry, now fill the fields */
name|memcpy
argument_list|(
name|nhp
operator|->
name|name
argument_list|,
name|hostname
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|nhp
operator|->
name|name
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|nhp
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|debuglog
argument_list|(
literal|"Locally Monitoring host %16s\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|debuglog
argument_list|(
literal|"Attempting to tell statd\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|smon
argument_list|,
sizeof|sizeof
argument_list|(
name|smon
argument_list|)
argument_list|)
expr_stmt|;
name|smon
operator|.
name|mon_id
operator|.
name|mon_name
operator|=
name|nhp
operator|->
name|name
expr_stmt|;
name|smon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_name
operator|=
literal|"localhost"
expr_stmt|;
name|smon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_prog
operator|=
name|NLM_PROG
expr_stmt|;
name|smon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_vers
operator|=
name|NLM_SM
expr_stmt|;
name|smon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_proc
operator|=
name|NLM_SM_NOTIFY
expr_stmt|;
name|rpcret
operator|=
name|callrpc
argument_list|(
literal|"localhost"
argument_list|,
name|SM_PROG
argument_list|,
name|SM_VERS
argument_list|,
name|SM_MON
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_mon
argument_list|,
operator|&
name|smon
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_sm_stat_res
argument_list|,
operator|&
name|sres
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpcret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sres
operator|.
name|res_stat
operator|==
name|stat_fail
condition|)
block|{
name|debuglog
argument_list|(
literal|"Statd call failed\n"
argument_list|)
expr_stmt|;
name|statflag
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|statflag
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|debuglog
argument_list|(
literal|"Rpc call to statd failed with return value: %d\n"
argument_list|,
name|rpcret
argument_list|)
expr_stmt|;
name|statflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|statflag
operator|==
literal|1
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|hostlst_head
argument_list|,
name|nhp
argument_list|,
name|hostlst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|nhp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * unmonitor_lock_host: clear monitor ref counts and inform statd when gone  */
end_comment

begin_function
name|void
name|unmonitor_lock_host
parameter_list|(
name|char
modifier|*
name|hostname
parameter_list|)
block|{
name|struct
name|host
modifier|*
name|ihp
decl_stmt|;
name|struct
name|mon_id
name|smon_id
decl_stmt|;
name|struct
name|sm_stat
name|smstat
decl_stmt|;
name|int
name|rpcret
decl_stmt|;
name|rpcret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ihp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|hostlst_head
argument_list|)
init|;
name|ihp
operator|!=
name|NULL
condition|;
name|ihp
operator|=
name|LIST_NEXT
argument_list|(
name|ihp
argument_list|,
name|hostlst
argument_list|)
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|hostname
argument_list|,
name|ihp
operator|->
name|name
argument_list|,
name|SM_MAXSTRLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Host is monitored, bump refcount */
operator|--
name|ihp
operator|->
name|refcnt
expr_stmt|;
comment|/* Host should only be in the monitor list once */
break|break;
block|}
block|}
if|if
condition|(
name|ihp
operator|==
name|NULL
condition|)
block|{
name|debuglog
argument_list|(
literal|"Could not find host %16s in mon list\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ihp
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|ihp
operator|->
name|refcnt
operator|<
literal|0
condition|)
block|{
name|debuglog
argument_list|(
literal|"Negative refcount!: %d\n"
argument_list|,
name|ihp
operator|->
name|refcnt
argument_list|)
expr_stmt|;
block|}
name|debuglog
argument_list|(
literal|"Attempting to unmonitor host %16s\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|smon_id
argument_list|,
sizeof|sizeof
argument_list|(
name|smon_id
argument_list|)
argument_list|)
expr_stmt|;
name|smon_id
operator|.
name|mon_name
operator|=
name|hostname
expr_stmt|;
name|smon_id
operator|.
name|my_id
operator|.
name|my_name
operator|=
literal|"localhost"
expr_stmt|;
name|smon_id
operator|.
name|my_id
operator|.
name|my_prog
operator|=
name|NLM_PROG
expr_stmt|;
name|smon_id
operator|.
name|my_id
operator|.
name|my_vers
operator|=
name|NLM_SM
expr_stmt|;
name|smon_id
operator|.
name|my_id
operator|.
name|my_proc
operator|=
name|NLM_SM_NOTIFY
expr_stmt|;
name|rpcret
operator|=
name|callrpc
argument_list|(
literal|"localhost"
argument_list|,
name|SM_PROG
argument_list|,
name|SM_VERS
argument_list|,
name|SM_UNMON
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_mon_id
argument_list|,
operator|&
name|smon_id
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_sm_stat
argument_list|,
operator|&
name|smstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpcret
operator|!=
literal|0
condition|)
block|{
name|debuglog
argument_list|(
literal|"Rpc call to unmonitor statd failed with "
literal|" return value: %d\n"
argument_list|,
name|rpcret
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|ihp
argument_list|,
name|hostlst
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ihp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * notify: Clear all locks from a host if statd complains  *  * XXX: This routine has not been thoroughly tested.  However, neither  * had the old one been.  It used to compare the statd crash state counter  * to the current lock state.  The upshot of this was that it basically  * cleared all locks from the specified host 99% of the time (with the  * other 1% being a bug).  Consequently, the assumption is that clearing  * all locks from a host when notified by statd is acceptable.  *  * Please note that this routine skips the usual level of redirection  * through a do_* type routine.  This introduces a possible level of  * error and might better be written as do_notify and take this one out.   */
end_comment

begin_function
name|void
name|notify
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|int
name|state
parameter_list|)
block|{
name|debuglog
argument_list|(
literal|"notify from %s, new state %d"
argument_list|,
name|hostname
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|siglock
argument_list|()
expr_stmt|;
name|do_clear
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|sigunlock
argument_list|()
expr_stmt|;
name|debuglog
argument_list|(
literal|"Leaving notify\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|send_granted
parameter_list|(
name|fl
parameter_list|,
name|opcode
parameter_list|)
name|struct
name|file_lock
modifier|*
name|fl
decl_stmt|;
name|int
name|opcode
name|__unused
decl_stmt|;
block|{
name|CLIENT
modifier|*
name|cli
decl_stmt|;
specifier|static
name|char
name|dummy
decl_stmt|;
name|struct
name|timeval
name|timeo
decl_stmt|;
name|int
name|success
decl_stmt|;
specifier|static
name|struct
name|nlm_res
name|retval
decl_stmt|;
specifier|static
name|struct
name|nlm4_res
name|retval4
decl_stmt|;
name|debuglog
argument_list|(
literal|"About to send granted on blocked lock\n"
argument_list|)
expr_stmt|;
name|cli
operator|=
name|get_client
argument_list|(
name|fl
operator|->
name|addr
argument_list|,
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|NLM_VERS4
else|:
name|NLM_VERS
argument_list|)
expr_stmt|;
if|if
condition|(
name|cli
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"failed to get CLIENT for %s"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|)
expr_stmt|;
comment|/* 		 * We fail to notify remote that the lock has been granted. 		 * The client will timeout and retry, the lock will be 		 * granted at this time. 		 */
return|return;
block|}
name|timeo
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeo
operator|.
name|tv_usec
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_ASYNC
operator|)
condition|?
literal|0
else|:
literal|500000
expr_stmt|;
comment|/* 0.5s */
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
condition|)
block|{
specifier|static
name|nlm4_testargs
name|res
decl_stmt|;
name|res
operator|.
name|cookie
operator|=
name|fl
operator|->
name|client_cookie
expr_stmt|;
name|res
operator|.
name|exclusive
operator|=
name|fl
operator|->
name|client
operator|.
name|exclusive
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|caller_name
operator|=
name|fl
operator|->
name|client_name
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|fh
operator|.
name|n_len
operator|=
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|fh
operator|.
name|n_bytes
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fl
operator|->
name|filehandle
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|oh
operator|=
name|fl
operator|->
name|client
operator|.
name|oh
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|svid
operator|=
name|fl
operator|->
name|client
operator|.
name|svid
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|l_offset
operator|=
name|fl
operator|->
name|client
operator|.
name|l_offset
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|l_len
operator|=
name|fl
operator|->
name|client
operator|.
name|l_len
expr_stmt|;
name|debuglog
argument_list|(
literal|"sending v4 reply%s"
argument_list|,
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_ASYNC
operator|)
condition|?
literal|" (async)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_ASYNC
condition|)
block|{
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|NLM4_GRANTED_MSG
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm4_testargs
argument_list|,
operator|&
name|res
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_void
argument_list|,
operator|&
name|dummy
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|NLM4_GRANTED
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm4_testargs
argument_list|,
operator|&
name|res
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm4_res
argument_list|,
operator|&
name|retval4
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|static
name|nlm_testargs
name|res
decl_stmt|;
name|res
operator|.
name|cookie
operator|=
name|fl
operator|->
name|client_cookie
expr_stmt|;
name|res
operator|.
name|exclusive
operator|=
name|fl
operator|->
name|client
operator|.
name|exclusive
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|caller_name
operator|=
name|fl
operator|->
name|client_name
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|fh
operator|.
name|n_len
operator|=
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|fh
operator|.
name|n_bytes
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fl
operator|->
name|filehandle
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|oh
operator|=
name|fl
operator|->
name|client
operator|.
name|oh
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|svid
operator|=
name|fl
operator|->
name|client
operator|.
name|svid
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|l_offset
operator|=
name|fl
operator|->
name|client
operator|.
name|l_offset
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|l_len
operator|=
name|fl
operator|->
name|client
operator|.
name|l_len
expr_stmt|;
name|debuglog
argument_list|(
literal|"sending v1 reply%s"
argument_list|,
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_ASYNC
operator|)
condition|?
literal|" (async)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_ASYNC
condition|)
block|{
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|NLM_GRANTED_MSG
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm_testargs
argument_list|,
operator|&
name|res
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_void
argument_list|,
operator|&
name|dummy
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|NLM_GRANTED
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm_testargs
argument_list|,
operator|&
name|res
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm_res
argument_list|,
operator|&
name|retval
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_level
operator|>
literal|2
condition|)
name|debuglog
argument_list|(
literal|"clnt_call returns %d(%s) for granted"
argument_list|,
name|success
argument_list|,
name|clnt_sperrno
argument_list|(
name|success
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routines below here have not been modified in the overhaul  */
end_comment

begin_comment
comment|/*  * Are these two routines still required since lockd is not spawning off  * children to service locks anymore?  Presumably they were originally  * put in place to prevent a one child from changing the lock list out  * from under another one.  */
end_comment

begin_function
name|void
name|siglock
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|block
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|block
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|block
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"siglock failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sigunlock
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|block
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|block
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|block
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"sigunlock failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

