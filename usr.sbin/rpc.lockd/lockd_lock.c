begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: lockd_lock.c,v 1.5 2000/11/21 03:47:41 enami Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 2000 Manuel Bouyer.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/sm_inter.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/nlm_prot.h>
end_include

begin_include
include|#
directive|include
file|"lockd_lock.h"
end_include

begin_include
include|#
directive|include
file|"lockd.h"
end_include

begin_comment
comment|/*  * A set of utilities for managing file locking  *  * XXX: All locks are in a linked list, a better structure should be used  * to improve search/access effeciency.  */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|lcklst_head
argument_list|,
name|file_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|lcklst_head
name|lcklst_head
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|lcklst_head
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* struct describing a lock */
end_comment

begin_struct
struct|struct
name|file_lock
block|{
name|LIST_ENTRY
argument_list|(
argument|file_lock
argument_list|)
name|lcklst
expr_stmt|;
name|fhandle_t
name|filehandle
decl_stmt|;
comment|/* NFS filehandle */
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|nlm4_holder
name|client
decl_stmt|;
comment|/* lock holder */
name|netobj
name|client_cookie
decl_stmt|;
comment|/* cookie sent by the client */
name|char
name|client_name
index|[
literal|128
index|]
decl_stmt|;
name|int
name|nsm_status
decl_stmt|;
comment|/* status from the remote lock manager */
name|int
name|status
decl_stmt|;
comment|/* lock status, see below */
name|int
name|flags
decl_stmt|;
comment|/* lock flags, see lockd_lock.h */
name|pid_t
name|locker
decl_stmt|;
comment|/* pid of the child process trying to get the lock */
name|int
name|fd
decl_stmt|;
comment|/* file descriptor for this lock */
block|}
struct|;
end_struct

begin_comment
comment|/* lock status */
end_comment

begin_define
define|#
directive|define
name|LKST_LOCKED
value|1
end_define

begin_comment
comment|/* lock is locked */
end_comment

begin_comment
comment|/* XXX: Is this flag file specific or lock specific? */
end_comment

begin_define
define|#
directive|define
name|LKST_WAITING
value|2
end_define

begin_comment
comment|/* file is already locked by another host */
end_comment

begin_define
define|#
directive|define
name|LKST_PROCESSING
value|3
end_define

begin_comment
comment|/* child is trying to aquire the lock */
end_comment

begin_define
define|#
directive|define
name|LKST_DYING
value|4
end_define

begin_comment
comment|/* must dies when we get news from the child */
end_comment

begin_decl_stmt
name|void
name|lfree
name|__P
argument_list|(
operator|(
expr|struct
name|file_lock
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|nlm_stats
name|do_lock
name|__P
argument_list|(
operator|(
expr|struct
name|file_lock
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|nlm_stats
name|do_unlock
name|__P
argument_list|(
operator|(
expr|struct
name|file_lock
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|send_granted
name|__P
argument_list|(
operator|(
expr|struct
name|file_lock
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|siglock
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|sigunlock
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|regions_overlap
name|__P
argument_list|(
operator|(
name|u_int64_t
name|start1
operator|,
name|u_int64_t
name|len1
operator|,
name|u_int64_t
name|start2
operator|,
name|u_int64_t
name|len2
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of hosts we monitor */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|hostlst_head
argument_list|,
name|host
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|hostlst_head
name|hostlst_head
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|hostlst_head
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* struct describing a lock */
end_comment

begin_struct
struct|struct
name|host
block|{
name|LIST_ENTRY
argument_list|(
argument|host
argument_list|)
name|hostlst
expr_stmt|;
name|char
name|name
index|[
name|SM_MAXSTRLEN
index|]
decl_stmt|;
name|int
name|refcnt
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|void
name|do_mon
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * regions_overlap(): This function examines the two provided regions for overlap.  * It is non-trivial because start+len *CAN* overflow a 64-bit unsigned integer  * and NFS semantics are unspecified on this account.  */
end_comment

begin_function
name|int
name|regions_overlap
parameter_list|(
name|start1
parameter_list|,
name|len1
parameter_list|,
name|start2
parameter_list|,
name|len2
parameter_list|)
name|u_int64_t
name|start1
decl_stmt|,
name|len1
decl_stmt|,
name|start2
decl_stmt|,
name|len2
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
comment|/* XXX: Need to adjust checks to account for integer overflow */
if|if
condition|(
name|len1
operator|==
literal|0
operator|&&
name|len2
operator|==
literal|0
condition|)
block|{
comment|/* Regions *must* overlap if they both extend to the end */
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len1
operator|==
literal|0
operator|&&
name|start2
operator|+
name|len2
operator|<
name|start1
condition|)
block|{
comment|/* Region 2 is completely to the left of Region 1 */
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start1
operator|+
name|len1
operator|<
name|start2
operator|&&
name|len2
operator|==
literal|0
condition|)
block|{
comment|/* Region 1 is completely to the left of region 2 */
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|start1
operator|+
name|len1
operator|<=
name|start2
operator|||
name|start2
operator|+
name|len2
operator|<=
name|start1
condition|)
block|{
comment|/* 1 is completely left of 2 or 2 is completely left of 1 */
name|result
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * testlock(): inform the caller if the requested lock would be granted or not  * returns NULL if lock would granted, or pointer to the current nlm4_holder  * otherwise.  */
end_comment

begin_function
name|struct
name|nlm4_holder
modifier|*
name|testlock
parameter_list|(
name|lock
parameter_list|,
name|exclusive
parameter_list|,
name|flags
parameter_list|)
name|struct
name|nlm4_lock
modifier|*
name|lock
decl_stmt|;
name|bool_t
name|exclusive
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|file_lock
modifier|*
name|fl
decl_stmt|;
name|fhandle_t
name|filehandle
decl_stmt|;
comment|/* convert lock to a local filehandle */
name|memcpy
argument_list|(
operator|&
name|filehandle
argument_list|,
name|lock
operator|->
name|fh
operator|.
name|n_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|filehandle
argument_list|)
argument_list|)
expr_stmt|;
name|siglock
argument_list|()
expr_stmt|;
comment|/* search through the list for lock holder */
for|for
control|(
name|fl
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lcklst_head
argument_list|)
init|;
name|fl
operator|!=
name|NULL
condition|;
name|fl
operator|=
name|LIST_NEXT
argument_list|(
name|fl
argument_list|,
name|lcklst
argument_list|)
control|)
block|{
if|if
condition|(
name|fl
operator|->
name|status
operator|!=
name|LKST_LOCKED
condition|)
continue|continue;
comment|/* 		 * XXX: Could we possibly have identical filehandles 		 * on different systems? 		 * ie. Do we need to check more than just the filehandle? 		 * ie. Could someone artificially create requests which are 		 * security violations? 		 */
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
operator|&
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|filehandle
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* File handles match, look for lock region overlap */
if|if
condition|(
name|regions_overlap
argument_list|(
name|lock
operator|->
name|l_offset
argument_list|,
name|lock
operator|->
name|l_len
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_len
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"Region overlap found %llu : %llu -- %llu : %llu\n"
argument_list|,
name|lock
operator|->
name|l_offset
argument_list|,
name|lock
operator|->
name|l_len
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_offset
argument_list|,
name|fl
operator|->
name|client
operator|.
name|l_len
argument_list|)
expr_stmt|;
comment|/* Regions overlap. Now check for exclusivity. */
if|if
condition|(
name|exclusive
operator|||
name|fl
operator|->
name|client
operator|.
name|exclusive
condition|)
block|{
comment|/* Lock test must fail, regions are exclusive */
break|break;
block|}
block|}
comment|/* Continue looping through all locks */
block|}
name|sigunlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|fl
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"test for %s: no lock found"
argument_list|,
name|lock
operator|->
name|caller_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"test for %s: found lock held by %s"
argument_list|,
name|lock
operator|->
name|caller_name
argument_list|,
name|fl
operator|->
name|client_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|fl
operator|->
name|client
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * getlock: try to aquire the lock.   * If file is already locked and we can sleep, put the lock in the list with  * status LKST_WAITING; it'll be processed later.  * Otherwise try to lock. If we're allowed to block, fork a child which  * will do the blocking lock.  */
end_comment

begin_function
name|enum
name|nlm_stats
name|getlock
parameter_list|(
name|lckarg
parameter_list|,
name|rqstp
parameter_list|,
name|flags
parameter_list|)
name|nlm4_lockargs
modifier|*
name|lckarg
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|file_lock
modifier|*
name|fl
decl_stmt|,
modifier|*
name|newfl
decl_stmt|;
name|enum
name|nlm_stats
name|retval
decl_stmt|;
if|if
condition|(
name|grace_expired
operator|==
literal|0
operator|&&
name|lckarg
operator|->
name|reclaim
operator|==
literal|0
condition|)
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied_grace_period
else|:
name|nlm_denied_grace_period
return|;
comment|/* allocate new file_lock for this request */
name|newfl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfl
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"malloc failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* failed */
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied_nolocks
else|:
name|nlm_denied_nolocks
return|;
block|}
if|if
condition|(
name|lckarg
operator|->
name|alock
operator|.
name|fh
operator|.
name|n_len
operator|!=
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"recieved fhandle size %d, local size %d"
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|fh
operator|.
name|n_len
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|newfl
operator|->
name|filehandle
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|fh
operator|.
name|n_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
name|newfl
operator|->
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|svc_getrpccaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
operator|->
name|buf
expr_stmt|;
name|newfl
operator|->
name|client
operator|.
name|exclusive
operator|=
name|lckarg
operator|->
name|exclusive
expr_stmt|;
name|newfl
operator|->
name|client
operator|.
name|svid
operator|=
name|lckarg
operator|->
name|alock
operator|.
name|svid
expr_stmt|;
name|newfl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
operator|=
name|malloc
argument_list|(
name|lckarg
operator|->
name|alock
operator|.
name|oh
operator|.
name|n_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"malloc failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newfl
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied_nolocks
else|:
name|nlm_denied_nolocks
return|;
block|}
name|newfl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_len
operator|=
name|lckarg
operator|->
name|alock
operator|.
name|oh
operator|.
name|n_len
expr_stmt|;
name|memcpy
argument_list|(
name|newfl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|oh
operator|.
name|n_bytes
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|oh
operator|.
name|n_len
argument_list|)
expr_stmt|;
name|newfl
operator|->
name|client
operator|.
name|l_offset
operator|=
name|lckarg
operator|->
name|alock
operator|.
name|l_offset
expr_stmt|;
name|newfl
operator|->
name|client
operator|.
name|l_len
operator|=
name|lckarg
operator|->
name|alock
operator|.
name|l_len
expr_stmt|;
name|newfl
operator|->
name|client_cookie
operator|.
name|n_len
operator|=
name|lckarg
operator|->
name|cookie
operator|.
name|n_len
expr_stmt|;
name|newfl
operator|->
name|client_cookie
operator|.
name|n_bytes
operator|=
name|malloc
argument_list|(
name|lckarg
operator|->
name|cookie
operator|.
name|n_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfl
operator|->
name|client_cookie
operator|.
name|n_bytes
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"malloc failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newfl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newfl
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied_nolocks
else|:
name|nlm_denied_nolocks
return|;
block|}
name|memcpy
argument_list|(
name|newfl
operator|->
name|client_cookie
operator|.
name|n_bytes
argument_list|,
name|lckarg
operator|->
name|cookie
operator|.
name|n_bytes
argument_list|,
name|lckarg
operator|->
name|cookie
operator|.
name|n_len
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|newfl
operator|->
name|client_name
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|caller_name
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|newfl
operator|->
name|nsm_status
operator|=
name|lckarg
operator|->
name|state
expr_stmt|;
name|newfl
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|newfl
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|siglock
argument_list|()
expr_stmt|;
comment|/* look for a lock rq from this host for this fh */
for|for
control|(
name|fl
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lcklst_head
argument_list|)
init|;
name|fl
operator|!=
name|NULL
condition|;
name|fl
operator|=
name|LIST_NEXT
argument_list|(
name|fl
argument_list|,
name|lcklst
argument_list|)
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|newfl
operator|->
name|filehandle
argument_list|,
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|newfl
operator|->
name|client_name
argument_list|,
name|fl
operator|->
name|client_name
argument_list|)
operator|==
literal|0
operator|&&
name|newfl
operator|->
name|client
operator|.
name|svid
operator|==
name|fl
operator|->
name|client
operator|.
name|svid
condition|)
block|{
comment|/* already locked by this host ??? */
name|sigunlock
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"duplicate lock from %s"
argument_list|,
name|newfl
operator|->
name|client_name
argument_list|)
expr_stmt|;
name|lfree
argument_list|(
name|newfl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fl
operator|->
name|status
condition|)
block|{
case|case
name|LKST_LOCKED
case|:
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
return|;
case|case
name|LKST_WAITING
case|:
case|case
name|LKST_PROCESSING
case|:
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_blocked
else|:
name|nlm_blocked
return|;
case|case
name|LKST_DYING
case|:
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied
else|:
name|nlm_denied
return|;
default|default:
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"bad status %d"
argument_list|,
name|fl
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_failed
else|:
name|nlm_denied
return|;
block|}
block|}
comment|/* 			 * We already have a lock for this file. Put this one 			 * in waiting state if allowed to block 			 */
if|if
condition|(
name|lckarg
operator|->
name|block
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"lock from %s: already "
literal|"locked, waiting"
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|caller_name
argument_list|)
expr_stmt|;
name|newfl
operator|->
name|status
operator|=
name|LKST_WAITING
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lcklst_head
argument_list|,
name|newfl
argument_list|,
name|lcklst
argument_list|)
expr_stmt|;
name|do_mon
argument_list|(
name|lckarg
operator|->
name|alock
operator|.
name|caller_name
argument_list|)
expr_stmt|;
name|sigunlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_blocked
else|:
name|nlm_blocked
return|;
block|}
else|else
block|{
name|sigunlock
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"lock from %s: already "
literal|"locked, failed"
argument_list|,
name|lckarg
operator|->
name|alock
operator|.
name|caller_name
argument_list|)
expr_stmt|;
name|lfree
argument_list|(
name|newfl
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied
else|:
name|nlm_denied
return|;
block|}
block|}
block|}
comment|/* no entry for this file yet; add to list */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lcklst_head
argument_list|,
name|newfl
argument_list|,
name|lcklst
argument_list|)
expr_stmt|;
comment|/* do the lock */
name|retval
operator|=
name|do_lock
argument_list|(
name|newfl
argument_list|,
name|lckarg
operator|->
name|block
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|nlm4_granted
case|:
comment|/* case nlm_granted: is the same as nlm4_granted */
case|case
name|nlm4_blocked
case|:
comment|/* case nlm_blocked: is the same as nlm4_blocked */
name|do_mon
argument_list|(
name|lckarg
operator|->
name|alock
operator|.
name|caller_name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lfree
argument_list|(
name|newfl
argument_list|)
expr_stmt|;
break|break;
block|}
name|sigunlock
argument_list|()
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* unlock a filehandle */
end_comment

begin_function
name|enum
name|nlm_stats
name|unlock
parameter_list|(
name|lck
parameter_list|,
name|flags
parameter_list|)
name|nlm4_lock
modifier|*
name|lck
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|file_lock
modifier|*
name|fl
decl_stmt|;
name|fhandle_t
name|filehandle
decl_stmt|;
name|int
name|err
init|=
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|filehandle
argument_list|,
name|lck
operator|->
name|fh
operator|.
name|n_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
name|siglock
argument_list|()
expr_stmt|;
for|for
control|(
name|fl
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lcklst_head
argument_list|)
init|;
name|fl
operator|!=
name|NULL
condition|;
name|fl
operator|=
name|LIST_NEXT
argument_list|(
name|fl
argument_list|,
name|lcklst
argument_list|)
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fl
operator|->
name|client_name
argument_list|,
name|lck
operator|->
name|caller_name
argument_list|)
operator|||
name|memcmp
argument_list|(
operator|&
name|filehandle
argument_list|,
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
operator|||
name|fl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_len
operator|!=
name|lck
operator|->
name|oh
operator|.
name|n_len
operator|||
name|memcmp
argument_list|(
name|fl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
argument_list|,
name|lck
operator|->
name|oh
operator|.
name|n_bytes
argument_list|,
name|fl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_len
argument_list|)
operator|!=
literal|0
operator|||
name|fl
operator|->
name|client
operator|.
name|svid
operator|!=
name|lck
operator|->
name|svid
condition|)
continue|continue;
comment|/* Got it, unlock and remove from the queue */
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unlock from %s: found struct, status %d"
argument_list|,
name|lck
operator|->
name|caller_name
argument_list|,
name|fl
operator|->
name|status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fl
operator|->
name|status
condition|)
block|{
case|case
name|LKST_LOCKED
case|:
name|err
operator|=
name|do_unlock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
break|break;
case|case
name|LKST_WAITING
case|:
comment|/* remove from the list */
name|LIST_REMOVE
argument_list|(
name|fl
argument_list|,
name|lcklst
argument_list|)
expr_stmt|;
name|lfree
argument_list|(
name|fl
argument_list|)
expr_stmt|;
break|break;
case|case
name|LKST_PROCESSING
case|:
comment|/* 			 * being handled by a child; will clean up 			 * when the child exits 			 */
name|fl
operator|->
name|status
operator|=
name|LKST_DYING
expr_stmt|;
break|break;
case|case
name|LKST_DYING
case|:
comment|/* nothing to do */
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"unknow status %d for %s"
argument_list|,
name|fl
operator|->
name|status
argument_list|,
name|fl
operator|->
name|client_name
argument_list|)
expr_stmt|;
block|}
name|sigunlock
argument_list|()
expr_stmt|;
return|return
name|err
return|;
block|}
name|sigunlock
argument_list|()
expr_stmt|;
comment|/* didn't find a matching entry; log anyway */
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"no matching entry for %s"
argument_list|,
name|lck
operator|->
name|caller_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
return|;
block|}
end_function

begin_function
name|void
name|lfree
parameter_list|(
name|fl
parameter_list|)
name|struct
name|file_lock
modifier|*
name|fl
decl_stmt|;
block|{
name|free
argument_list|(
name|fl
operator|->
name|client
operator|.
name|oh
operator|.
name|n_bytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fl
operator|->
name|client_cookie
operator|.
name|n_bytes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sigchild_handler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|struct
name|file_lock
modifier|*
name|fl
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|pid
operator|=
name|wait4
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ECHILD
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"wait failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"wait failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* no more child to handle yet */
return|return;
block|}
comment|/* 		 * if we're here we have a child that exited 		 * Find the associated file_lock. 		 */
for|for
control|(
name|fl
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lcklst_head
argument_list|)
init|;
name|fl
operator|!=
name|NULL
condition|;
name|fl
operator|=
name|LIST_NEXT
argument_list|(
name|fl
argument_list|,
name|lcklst
argument_list|)
control|)
block|{
if|if
condition|(
name|pid
operator|==
name|fl
operator|->
name|locker
condition|)
break|break;
block|}
if|if
condition|(
name|pid
operator|!=
name|fl
operator|->
name|locker
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"unknow child %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"child %d failed"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
comment|/* 				 * can't do much here; we can't reply 				 * anything but OK for blocked locks 				 * Eventually the client will time out 				 * and retry. 				 */
name|do_unlock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* check lock status */
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"processing child %d, status %d"
argument_list|,
name|pid
argument_list|,
name|fl
operator|->
name|status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fl
operator|->
name|status
condition|)
block|{
case|case
name|LKST_PROCESSING
case|:
name|fl
operator|->
name|status
operator|=
name|LKST_LOCKED
expr_stmt|;
name|send_granted
argument_list|(
name|fl
argument_list|,
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
argument_list|)
expr_stmt|;
break|break;
case|case
name|LKST_DYING
case|:
name|do_unlock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"bad lock status (%d) for"
literal|" child %d"
argument_list|,
name|fl
operator|->
name|status
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  * try to aquire the lock described by fl. Eventually fock a child to do a  * blocking lock if allowed and required.  */
end_comment

begin_function
name|enum
name|nlm_stats
name|do_lock
parameter_list|(
name|fl
parameter_list|,
name|block
parameter_list|)
name|struct
name|file_lock
modifier|*
name|fl
decl_stmt|;
name|int
name|block
decl_stmt|;
block|{
name|int
name|lflags
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|fl
operator|->
name|fd
operator|=
name|fhopen
argument_list|(
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ESTALE
case|:
name|error
operator|=
name|nlm4_stale_fh
expr_stmt|;
break|break;
case|case
name|EROFS
case|:
name|error
operator|=
name|nlm4_rofs
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|nlm4_failed
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|nlm_denied
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"fhopen failed (from %s): %s"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|fl
argument_list|,
name|lcklst
argument_list|)
expr_stmt|;
return|return
name|error
return|;
empty_stmt|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fl
operator|->
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"fstat failed (from %s): %s"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"lock from %s for file%s%s: dev %d ino %d (uid %d), "
literal|"flags %d"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|,
name|fl
operator|->
name|client
operator|.
name|exclusive
condition|?
literal|" (exclusive)"
else|:
literal|""
argument_list|,
name|block
condition|?
literal|" (block)"
else|:
literal|""
argument_list|,
name|st
operator|.
name|st_dev
argument_list|,
name|st
operator|.
name|st_ino
argument_list|,
name|st
operator|.
name|st_uid
argument_list|,
name|fl
operator|->
name|flags
argument_list|)
expr_stmt|;
name|lflags
operator|=
name|LOCK_NB
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|client
operator|.
name|exclusive
operator|==
literal|0
condition|)
name|lflags
operator||=
name|LOCK_SH
expr_stmt|;
else|else
name|lflags
operator||=
name|LOCK_EX
expr_stmt|;
name|error
operator|=
name|flock
argument_list|(
name|fl
operator|->
name|fd
argument_list|,
name|lflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|EAGAIN
operator|&&
name|block
condition|)
block|{
switch|switch
condition|(
name|fl
operator|->
name|locker
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* fork failed */
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"fork failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|fl
argument_list|,
name|lcklst
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fl
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_denied_nolocks
else|:
name|nlm_denied_nolocks
return|;
case|case
literal|0
case|:
comment|/* 			 * Attempt a blocking lock. Will have to call 			 * NLM_GRANTED later. 			 */
name|setproctitle
argument_list|(
literal|"%s"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|)
expr_stmt|;
name|lflags
operator|&=
operator|~
name|LOCK_NB
expr_stmt|;
if|if
condition|(
name|flock
argument_list|(
name|fl
operator|->
name|fd
argument_list|,
name|lflags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"flock failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* lock granted */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"lock request from %s: forked %d"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|,
name|fl
operator|->
name|locker
argument_list|)
expr_stmt|;
name|fl
operator|->
name|status
operator|=
name|LKST_PROCESSING
expr_stmt|;
return|return
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_blocked
else|:
name|nlm_blocked
return|;
block|}
block|}
comment|/* non block case */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EAGAIN
case|:
name|error
operator|=
name|nlm4_denied
expr_stmt|;
break|break;
case|case
name|ESTALE
case|:
name|error
operator|=
name|nlm4_stale_fh
expr_stmt|;
break|break;
case|case
name|EROFS
case|:
name|error
operator|=
name|nlm4_rofs
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|nlm4_failed
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|nlm_denied
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EAGAIN
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"flock for %s failed: %s"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"flock for %s failed: %s"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|fl
argument_list|,
name|lcklst
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fl
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|fl
operator|->
name|status
operator|=
name|LKST_LOCKED
expr_stmt|;
return|return
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
return|;
block|}
end_function

begin_function
name|void
name|send_granted
parameter_list|(
name|fl
parameter_list|,
name|opcode
parameter_list|)
name|struct
name|file_lock
modifier|*
name|fl
decl_stmt|;
name|int
name|opcode
decl_stmt|;
block|{
name|CLIENT
modifier|*
name|cli
decl_stmt|;
specifier|static
name|char
name|dummy
decl_stmt|;
name|struct
name|timeval
name|timeo
decl_stmt|;
name|int
name|success
decl_stmt|;
specifier|static
name|struct
name|nlm_res
name|retval
decl_stmt|;
specifier|static
name|struct
name|nlm4_res
name|retval4
decl_stmt|;
name|cli
operator|=
name|get_client
argument_list|(
name|fl
operator|->
name|addr
argument_list|,
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|NLM_VERS4
else|:
name|NLM_VERS
argument_list|)
expr_stmt|;
if|if
condition|(
name|cli
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"failed to get CLIENT for %s"
argument_list|,
name|fl
operator|->
name|client_name
argument_list|)
expr_stmt|;
comment|/* 		 * We fail to notify remote that the lock has been granted. 		 * The client will timeout and retry, the lock will be 		 * granted at this time. 		 */
return|return;
block|}
name|timeo
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeo
operator|.
name|tv_usec
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_ASYNC
operator|)
condition|?
literal|0
else|:
literal|500000
expr_stmt|;
comment|/* 0.5s */
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
condition|)
block|{
specifier|static
name|nlm4_testargs
name|res
decl_stmt|;
name|res
operator|.
name|cookie
operator|=
name|fl
operator|->
name|client_cookie
expr_stmt|;
name|res
operator|.
name|exclusive
operator|=
name|fl
operator|->
name|client
operator|.
name|exclusive
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|caller_name
operator|=
name|fl
operator|->
name|client_name
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|fh
operator|.
name|n_len
operator|=
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|fh
operator|.
name|n_bytes
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fl
operator|->
name|filehandle
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|oh
operator|=
name|fl
operator|->
name|client
operator|.
name|oh
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|svid
operator|=
name|fl
operator|->
name|client
operator|.
name|svid
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|l_offset
operator|=
name|fl
operator|->
name|client
operator|.
name|l_offset
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|l_len
operator|=
name|fl
operator|->
name|client
operator|.
name|l_len
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"sending v4 reply%s"
argument_list|,
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_ASYNC
operator|)
condition|?
literal|" (async)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_ASYNC
condition|)
block|{
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|NLM4_GRANTED_MSG
argument_list|,
name|xdr_nlm4_testargs
argument_list|,
operator|&
name|res
argument_list|,
name|xdr_void
argument_list|,
operator|&
name|dummy
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|NLM4_GRANTED
argument_list|,
name|xdr_nlm4_testargs
argument_list|,
operator|&
name|res
argument_list|,
name|xdr_nlm4_res
argument_list|,
operator|&
name|retval4
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|static
name|nlm_testargs
name|res
decl_stmt|;
name|res
operator|.
name|cookie
operator|=
name|fl
operator|->
name|client_cookie
expr_stmt|;
name|res
operator|.
name|exclusive
operator|=
name|fl
operator|->
name|client
operator|.
name|exclusive
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|caller_name
operator|=
name|fl
operator|->
name|client_name
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|fh
operator|.
name|n_len
operator|=
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|fh
operator|.
name|n_bytes
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|fl
operator|->
name|filehandle
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|oh
operator|=
name|fl
operator|->
name|client
operator|.
name|oh
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|svid
operator|=
name|fl
operator|->
name|client
operator|.
name|svid
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|l_offset
operator|=
name|fl
operator|->
name|client
operator|.
name|l_offset
expr_stmt|;
name|res
operator|.
name|alock
operator|.
name|l_len
operator|=
name|fl
operator|->
name|client
operator|.
name|l_len
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"sending v1 reply%s"
argument_list|,
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_ASYNC
operator|)
condition|?
literal|" (async)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_ASYNC
condition|)
block|{
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|NLM_GRANTED_MSG
argument_list|,
name|xdr_nlm_testargs
argument_list|,
operator|&
name|res
argument_list|,
name|xdr_void
argument_list|,
operator|&
name|dummy
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|success
operator|=
name|clnt_call
argument_list|(
name|cli
argument_list|,
name|NLM_GRANTED
argument_list|,
name|xdr_nlm_testargs
argument_list|,
operator|&
name|res
argument_list|,
name|xdr_nlm_res
argument_list|,
operator|&
name|retval
argument_list|,
name|timeo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug_level
operator|>
literal|2
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"clnt_call returns %d(%s) for granted"
argument_list|,
name|success
argument_list|,
name|clnt_sperrno
argument_list|(
name|success
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|nlm_stats
name|do_unlock
parameter_list|(
name|rfl
parameter_list|)
name|struct
name|file_lock
modifier|*
name|rfl
decl_stmt|;
block|{
name|struct
name|file_lock
modifier|*
name|fl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|lockst
decl_stmt|;
comment|/* unlock the file: closing is enouth ! */
if|if
condition|(
name|close
argument_list|(
name|rfl
operator|->
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ESTALE
condition|)
name|error
operator|=
name|nlm4_stale_fh
expr_stmt|;
else|else
name|error
operator|=
name|nlm4_failed
expr_stmt|;
if|if
condition|(
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|nlm_denied
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"close failed (from %s): %s"
argument_list|,
name|rfl
operator|->
name|client_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|rfl
argument_list|,
name|lcklst
argument_list|)
expr_stmt|;
comment|/* process the next LKST_WAITING lock request for this fh */
for|for
control|(
name|fl
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lcklst_head
argument_list|)
init|;
name|fl
operator|!=
name|NULL
condition|;
name|fl
operator|=
name|LIST_NEXT
argument_list|(
name|fl
argument_list|,
name|lcklst
argument_list|)
control|)
block|{
if|if
condition|(
name|fl
operator|->
name|status
operator|!=
name|LKST_WAITING
operator|||
name|memcmp
argument_list|(
operator|&
name|rfl
operator|->
name|filehandle
argument_list|,
operator|&
name|fl
operator|->
name|filehandle
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|lockst
operator|=
name|do_lock
argument_list|(
name|fl
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If it's LKST_WAITING we can block */
switch|switch
condition|(
name|lockst
condition|)
block|{
case|case
name|nlm4_granted
case|:
comment|/* case nlm_granted: same as nlm4_granted */
name|send_granted
argument_list|(
name|fl
argument_list|,
operator|(
name|fl
operator|->
name|flags
operator|&
name|LOCK_V4
operator|)
condition|?
name|nlm4_granted
else|:
name|nlm_granted
argument_list|)
expr_stmt|;
break|break;
case|case
name|nlm4_blocked
case|:
comment|/* case nlm_blocked: same as nlm4_blocked */
break|break;
default|default:
name|lfree
argument_list|(
name|fl
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|siglock
parameter_list|()
block|{
name|sigset_t
name|block
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|block
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|block
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"siglock failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sigunlock
parameter_list|()
block|{
name|sigset_t
name|block
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|block
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|block
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|block
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"sigunlock failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* monitor a host through rpc.statd, and keep a ref count */
end_comment

begin_function
name|void
name|do_mon
parameter_list|(
name|hostname
parameter_list|)
name|char
modifier|*
name|hostname
decl_stmt|;
block|{
name|struct
name|host
modifier|*
name|hp
decl_stmt|;
name|struct
name|mon
name|my_mon
decl_stmt|;
name|struct
name|sm_stat_res
name|res
decl_stmt|;
name|int
name|retval
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|hostlst_head
argument_list|)
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|LIST_NEXT
argument_list|(
name|hp
argument_list|,
name|hostlst
argument_list|)
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|hostname
argument_list|,
name|hp
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* already monitored, just bump refcnt */
name|hp
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return;
block|}
block|}
comment|/* not found, have to create an entry for it */
name|hp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|host
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|hp
operator|->
name|name
argument_list|,
name|hostname
argument_list|,
name|SM_MAXSTRLEN
argument_list|)
expr_stmt|;
name|hp
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"monitoring host %s"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|my_mon
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|my_mon
argument_list|)
argument_list|)
expr_stmt|;
name|my_mon
operator|.
name|mon_id
operator|.
name|mon_name
operator|=
name|hp
operator|->
name|name
expr_stmt|;
name|my_mon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_name
operator|=
literal|"localhost"
expr_stmt|;
name|my_mon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_prog
operator|=
name|NLM_PROG
expr_stmt|;
name|my_mon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_vers
operator|=
name|NLM_SM
expr_stmt|;
name|my_mon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_proc
operator|=
name|NLM_SM_NOTIFY
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|callrpc
argument_list|(
literal|"localhost"
argument_list|,
name|SM_PROG
argument_list|,
name|SM_VERS
argument_list|,
name|SM_MON
argument_list|,
name|xdr_mon
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|my_mon
argument_list|,
name|xdr_sm_stat_res
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|res
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"rpc to statd failed: %s"
argument_list|,
name|clnt_sperrno
argument_list|(
operator|(
expr|enum
name|clnt_stat
operator|)
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|res
operator|.
name|res_stat
operator|==
name|stat_fail
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"statd failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
return|return;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|hostlst_head
argument_list|,
name|hp
argument_list|,
name|hostlst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|notify
parameter_list|(
name|hostname
parameter_list|,
name|state
parameter_list|)
name|char
modifier|*
name|hostname
decl_stmt|;
name|int
name|state
decl_stmt|;
block|{
name|struct
name|file_lock
modifier|*
name|fl
decl_stmt|,
modifier|*
name|next_fl
decl_stmt|;
name|int
name|err
decl_stmt|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"notify from %s, new state %d"
argument_list|,
name|hostname
argument_list|,
name|state
argument_list|)
expr_stmt|;
comment|/* search all lock for this host; if status changed, release the lock */
name|siglock
argument_list|()
expr_stmt|;
for|for
control|(
name|fl
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lcklst_head
argument_list|)
init|;
name|fl
operator|!=
name|NULL
condition|;
name|fl
operator|=
name|next_fl
control|)
block|{
name|next_fl
operator|=
name|LIST_NEXT
argument_list|(
name|fl
argument_list|,
name|lcklst
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hostname
argument_list|,
name|fl
operator|->
name|client_name
argument_list|)
operator|==
literal|0
operator|&&
name|fl
operator|->
name|nsm_status
operator|!=
name|state
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"state %d, nsm_state %d, unlocking"
argument_list|,
name|fl
operator|->
name|status
argument_list|,
name|fl
operator|->
name|nsm_status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fl
operator|->
name|status
condition|)
block|{
case|case
name|LKST_LOCKED
case|:
name|err
operator|=
name|do_unlock
argument_list|(
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|nlm_granted
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"notify: unlock failed for %s (%d)"
argument_list|,
name|hostname
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
case|case
name|LKST_WAITING
case|:
name|LIST_REMOVE
argument_list|(
name|fl
argument_list|,
name|lcklst
argument_list|)
expr_stmt|;
name|lfree
argument_list|(
name|fl
argument_list|)
expr_stmt|;
break|break;
case|case
name|LKST_PROCESSING
case|:
name|fl
operator|->
name|status
operator|=
name|LKST_DYING
expr_stmt|;
break|break;
case|case
name|LKST_DYING
case|:
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"unknow status %d for %s"
argument_list|,
name|fl
operator|->
name|status
argument_list|,
name|fl
operator|->
name|client_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sigunlock
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

