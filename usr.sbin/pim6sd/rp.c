begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1999 LSIIT Laboratory.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  Copyright (c) 1998 by the University of Southern California.  *  All rights reserved.  *  *  Permission to use, copy, modify, and distribute this software and  *  its documentation in source and binary forms for lawful  *  purposes and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both  *  the copyright notice and this permission notice appear in supporting  *  documentation, and that any documentation, advertising materials,  *  and other materials related to such distribution and use acknowledge  *  that the software was developed by the University of Southern  *  California and/or Information Sciences Institute.  *  The name of the University of Southern California may not  *  be used to endorse or promote products derived from this software  *  without specific prior written permission.  *  *  THE UNIVERSITY OF SOUTHERN CALIFORNIA DOES NOT MAKE ANY REPRESENTATIONS  *  ABOUT THE SUITABILITY OF THIS SOFTWARE FOR ANY PURPOSE.  THIS SOFTWARE IS  *  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  *  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND   *  NON-INFRINGEMENT.  *  *  IN NO EVENT SHALL USC, OR ANY OTHER CONTRIBUTOR BE LIABLE FOR ANY  *  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, WHETHER IN CONTRACT,  *  TORT, OR OTHER FORM OF ACTION, ARISING OUT OF OR IN CONNECTION WITH,  *  THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *  Other copyrights might apply to parts of this software and are so  *  noted when applicable.  */
end_comment

begin_comment
comment|/*  *  Questions concerning this software should be directed to  *  Mickael Hoerdt (hoerdt@clarinet.u-strasbg.fr) LSIIT Strasbourg.  *  */
end_comment

begin_comment
comment|/*  * This program has been derived from pim6dd.          * The pim6dd program is covered by the license in the accompanying file  * named "LICENSE.pim6dd".  */
end_comment

begin_comment
comment|/*  * This program has been derived from pimd.          * The pimd program is covered by the license in the accompanying file  * named "LICENSE.pimd".  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"rp.h"
end_include

begin_include
include|#
directive|include
file|"pim6_proto.h"
end_include

begin_include
include|#
directive|include
file|"pimd.h"
end_include

begin_include
include|#
directive|include
file|<netinet6/pim6.h>
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"inet6.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_include
include|#
directive|include
file|"pimd.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"crc.h"
end_include

begin_comment
comment|/*  * The hash function. Stollen from Eddy's (eddy@isi.edu) implementation (for  * compatibility ;)  */
end_comment

begin_define
define|#
directive|define
name|SEED1
value|1103515245
end_define

begin_define
define|#
directive|define
name|SEED2
value|12345
end_define

begin_define
define|#
directive|define
name|RP_HASH_VALUE
parameter_list|(
name|G
parameter_list|,
name|M
parameter_list|,
name|C
parameter_list|)
value|(((SEED1) * (((SEED1) * ((G)& (M)) + (SEED2)) ^ (C)) + (SEED2)) % 0x80000000)
end_define

begin_define
define|#
directive|define
name|RP_HASH_VALUE2
parameter_list|(
name|P
parameter_list|,
name|C
parameter_list|)
value|(((SEED1) * (((SEED1) * (P) + (SEED2)) ^ (C)) + (SEED2)) % 0x80000000)
end_define

begin_decl_stmt
name|cand_rp_t
modifier|*
name|cand_rp_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|grp_mask_t
modifier|*
name|grp_mask_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cand_rp_t
modifier|*
name|segmented_cand_rp_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|grp_mask_t
modifier|*
name|segmented_grp_mask_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16
name|curr_bsr_fragment_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8
name|curr_bsr_priority
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in6
name|curr_bsr_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in6_addr
name|curr_bsr_hash_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16
name|pim_bootstrap_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For electing the BSR and sending 					 		 * Cand-RP-set msgs */
end_comment

begin_decl_stmt
name|u_int8
name|my_bsr_priority
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in6
name|my_bsr_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in6_addr
name|my_bsr_hash_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8
name|cand_bsr_flag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to TRUE if I am a candidate 						 	 * BSR */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in6
name|my_cand_rp_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8
name|my_cand_rp_priority
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16
name|my_cand_rp_holdtime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16
name|my_cand_rp_adv_period
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The locally configured Cand-RP 					 		 * adv. period. */
end_comment

begin_decl_stmt
name|u_int16
name|my_bsr_period
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The locally configured BSR	 							   period */
end_comment

begin_decl_stmt
name|u_int16
name|pim_cand_rp_adv_timer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8
name|cand_rp_flag
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Candidate RP flag */
end_comment

begin_decl_stmt
name|struct
name|cand_rp_adv_message_
name|cand_rp_adv_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in6_addr
name|rp_my_ipv6_hashmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local functions definition.  */
end_comment

begin_decl_stmt
specifier|static
name|cand_rp_t
modifier|*
name|add_cand_rp
name|__P
argument_list|(
operator|(
name|cand_rp_t
operator|*
operator|*
name|used_cand_rp_list
operator|,
expr|struct
name|sockaddr_in6
operator|*
name|address
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|grp_mask_t
modifier|*
name|add_grp_mask
name|__P
argument_list|(
operator|(
name|grp_mask_t
operator|*
operator|*
name|used_grp_mask_list
operator|,
expr|struct
name|sockaddr_in6
operator|*
name|group_addr
operator|,
expr|struct
name|in6_addr
name|group_mask
operator|,
expr|struct
name|in6_addr
name|hash_mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_grp_mask_entry
name|__P
argument_list|(
operator|(
name|cand_rp_t
operator|*
operator|*
name|used_cand_rp_list
operator|,
name|grp_mask_t
operator|*
operator|*
name|used_grp_mask_list
operator|,
name|grp_mask_t
operator|*
name|grp_mask_delete
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_rp_entry
name|__P
argument_list|(
operator|(
name|cand_rp_t
operator|*
operator|*
name|used_cand_rp_list
operator|,
name|grp_mask_t
operator|*
operator|*
name|used_grp_mask_list
operator|,
name|cand_rp_t
operator|*
name|cand_rp_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_rp6_and_bsr6
parameter_list|()
block|{
comment|/* TODO: if the grplist is not NULL, remap all groups ASAP! */
name|delete_rp_list
argument_list|(
operator|&
name|cand_rp_list
argument_list|,
operator|&
name|grp_mask_list
argument_list|)
expr_stmt|;
name|delete_rp_list
argument_list|(
operator|&
name|segmented_cand_rp_list
argument_list|,
operator|&
name|segmented_grp_mask_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand_bsr_flag
operator|==
name|FALSE
condition|)
block|{
comment|/* 	 * If I am not candidat BSR, initialize the "current BSR" as having 	 * the lowest priority. 	 */
name|curr_bsr_fragment_tag
operator|=
literal|0
expr_stmt|;
name|curr_bsr_priority
operator|=
literal|0
expr_stmt|;
comment|/* Lowest priority */
name|curr_bsr_address
operator|=
name|sockaddr6_any
expr_stmt|;
comment|/* Lowest priority */
name|MASKLEN_TO_MASK6
argument_list|(
name|RP_DEFAULT_IPV6_HASHMASKLEN
argument_list|,
name|curr_bsr_hash_mask
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|pim_bootstrap_timer
argument_list|,
name|PIM_BOOTSTRAP_TIMEOUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curr_bsr_fragment_tag
operator|=
name|RANDOM
argument_list|()
expr_stmt|;
name|curr_bsr_priority
operator|=
name|my_bsr_priority
expr_stmt|;
name|curr_bsr_address
operator|=
name|my_bsr_address
expr_stmt|;
name|curr_bsr_hash_mask
operator|=
name|my_bsr_hash_mask
expr_stmt|;
name|SET_TIMER
argument_list|(
name|pim_bootstrap_timer
argument_list|,
name|bootstrap_initial_delay
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cand_rp_flag
operator|!=
name|FALSE
condition|)
block|{
name|MASKLEN_TO_MASK6
argument_list|(
name|RP_DEFAULT_IPV6_HASHMASKLEN
argument_list|,
name|rp_my_ipv6_hashmask
argument_list|)
expr_stmt|;
comment|/* Setup the Cand-RP-Adv-Timer */
name|SET_TIMER
argument_list|(
name|pim_cand_rp_adv_timer
argument_list|,
name|RANDOM
argument_list|()
operator|%
name|my_cand_rp_adv_period
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX: This implementation is based on section 6.2 of RFC 2362, which  * is highly dependent on IPv4.  * We'll have to rewrite the function...  */
end_comment

begin_function
name|u_int16
name|bootstrap_initial_delay
parameter_list|()
block|{
comment|//    long            AddrDelay;
comment|//    long            Delay;
comment|//    long            log_mask;
comment|//    int             log_of_2;
comment|//    u_int8          bestPriority;
comment|/*      * The bootstrap timer initial value (if Cand-BSR). It depends of the      * bootstrap router priority: higher priority has shorter value:      *       * Delay = 5 + 2*log_2(1 + bestPriority - myPriority) + AddrDelay;      *       * bestPriority = Max(storedPriority, myPriority); if (bestPriority ==      * myPriority) AddrDelay = log_2(bestAddr - myAddr)/16; else AddrDelay =      * 2 - (myAddr/2^31);      */
comment|//    bestPriority = max(curr_bsr_priority, my_bsr_priority);
comment|//    if (bestPriority == my_bsr_priority)
comment|//   {
comment|//	AddrDelay = ntohl(curr_bsr_address) - ntohl(my_bsr_address);
comment|/* Calculate the integer part of log_2 of (bestAddr - myAddr) */
comment|/* 	 * To do so, have to find the position number of the first bit from 	 * left which is `1` 	 */
comment|//	log_mask = sizeof(AddrDelay)<< 3;
comment|//	log_mask = (1<< (log_mask - 1));	/* Set the leftmost bit to
comment|//						 * `1` */
comment|/*	for (log_of_2 = (sizeof(AddrDelay)<< 3) - 1; log_of_2; log_of_2--) 	{ 	    if (AddrDelay& log_mask) 		break; 	    else */
comment|//		log_mask>>= 1;	/* Start shifting `1` on right */
comment|/* } 	AddrDelay = log_of_2 / 16;     }     else 	AddrDelay = 2 - (ntohl(my_bsr_address) / (1<< 31));      Delay = 1 + bestPriority - my_bsr_priority;  */
comment|/* Calculate log_2(Delay) */
comment|//    log_mask = sizeof(Delay)<< 3;
comment|//    log_mask = (1<< (log_mask - 1));
comment|/* Set the leftmost bit to `1`  */
comment|/*   for (log_of_2 = (sizeof(Delay)<< 3) - 1; log_of_2; log_of_2--)     { 	if (Delay& log_mask) 	    break; 	else */
comment|//	    log_mask>>= 1;	/* Start shifting `1` on right */
comment|/* }      Delay = 5 + 2 * Delay + AddrDelay;     return (u_int16) Delay; */
comment|/* Temporary implementation */
return|return
operator|(
name|RANDOM
argument_list|()
operator|%
name|my_bsr_period
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|cand_rp_t
modifier|*
name|add_cand_rp
parameter_list|(
name|used_cand_rp_list
parameter_list|,
name|address
parameter_list|)
name|cand_rp_t
modifier|*
modifier|*
name|used_cand_rp_list
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|address
decl_stmt|;
block|{
name|cand_rp_t
modifier|*
name|cand_rp_prev
init|=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
decl_stmt|;
name|cand_rp_t
modifier|*
name|cand_rp
decl_stmt|;
name|cand_rp_t
modifier|*
name|cand_rp_new
decl_stmt|;
name|rpentry_t
modifier|*
name|rpentry_ptr
decl_stmt|;
comment|/* The ordering is the bigger first */
for|for
control|(
name|cand_rp
operator|=
operator|*
name|used_cand_rp_list
init|;
name|cand_rp
operator|!=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|;
name|cand_rp_prev
operator|=
name|cand_rp
operator|,
name|cand_rp
operator|=
name|cand_rp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|inet6_greaterthan
argument_list|(
operator|&
name|cand_rp
operator|->
name|rpentry
operator|->
name|address
argument_list|,
name|address
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|cand_rp
operator|->
name|rpentry
operator|->
name|address
argument_list|,
name|address
argument_list|)
condition|)
return|return
operator|(
name|cand_rp
operator|)
return|;
else|else
break|break;
block|}
comment|/* Create and insert the new entry between cand_rp_prev and cand_rp */
name|cand_rp_new
operator|=
operator|(
name|cand_rp_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|cand_rp_t
argument_list|)
argument_list|)
expr_stmt|;
name|cand_rp_new
operator|->
name|rp_grp_next
operator|=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|cand_rp_new
operator|->
name|next
operator|=
name|cand_rp
expr_stmt|;
name|cand_rp_new
operator|->
name|prev
operator|=
name|cand_rp_prev
expr_stmt|;
if|if
condition|(
name|cand_rp
operator|!=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|)
name|cand_rp
operator|->
name|prev
operator|=
name|cand_rp_new
expr_stmt|;
if|if
condition|(
name|cand_rp_prev
operator|==
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|used_cand_rp_list
operator|=
name|cand_rp_new
expr_stmt|;
block|}
else|else
block|{
name|cand_rp_prev
operator|->
name|next
operator|=
name|cand_rp_new
expr_stmt|;
block|}
name|rpentry_ptr
operator|=
operator|(
name|rpentry_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rpentry_t
argument_list|)
argument_list|)
expr_stmt|;
name|cand_rp_new
operator|->
name|rpentry
operator|=
name|rpentry_ptr
expr_stmt|;
name|rpentry_ptr
operator|->
name|next
operator|=
operator|(
name|srcentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|rpentry_ptr
operator|->
name|prev
operator|=
operator|(
name|srcentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|rpentry_ptr
operator|->
name|address
operator|=
operator|*
name|address
expr_stmt|;
name|rpentry_ptr
operator|->
name|mrtlink
operator|=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|rpentry_ptr
operator|->
name|incoming
operator|=
name|NO_VIF
expr_stmt|;
name|rpentry_ptr
operator|->
name|upstream
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
comment|/* TODO: setup the metric and the preference as ~0 (the lowest)? */
name|rpentry_ptr
operator|->
name|metric
operator|=
operator|~
literal|0
expr_stmt|;
name|rpentry_ptr
operator|->
name|preference
operator|=
operator|~
literal|0
expr_stmt|;
name|RESET_TIMER
argument_list|(
name|rpentry_ptr
operator|->
name|timer
argument_list|)
expr_stmt|;
name|rpentry_ptr
operator|->
name|cand_rp
operator|=
name|cand_rp_new
expr_stmt|;
comment|/*      * TODO: XXX: check whether there is a route to that RP: if return value      * is FALSE, then no route.      */
if|if
condition|(
name|local_address
argument_list|(
operator|&
name|rpentry_ptr
operator|->
name|address
argument_list|)
operator|==
name|NO_VIF
condition|)
block|{
comment|/* TODO: check for error and delete */
name|set_incoming
argument_list|(
name|rpentry_ptr
argument_list|,
name|PIM_IIF_RP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO: XXX: CHECK!!! */
name|rpentry_ptr
operator|->
name|incoming
operator|=
name|reg_vif_num
expr_stmt|;
block|}
return|return
operator|(
name|cand_rp_new
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|grp_mask_t
modifier|*
name|add_grp_mask
parameter_list|(
name|used_grp_mask_list
parameter_list|,
name|group_addr
parameter_list|,
name|group_mask
parameter_list|,
name|hash_mask
parameter_list|)
name|grp_mask_t
modifier|*
modifier|*
name|used_grp_mask_list
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|group_addr
decl_stmt|;
name|struct
name|in6_addr
name|group_mask
decl_stmt|;
name|struct
name|in6_addr
name|hash_mask
decl_stmt|;
block|{
name|grp_mask_t
modifier|*
name|grp_mask_prev
init|=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
decl_stmt|;
name|grp_mask_t
modifier|*
name|grp_mask
decl_stmt|;
name|grp_mask_t
modifier|*
name|grp_mask_tmp
decl_stmt|;
name|struct
name|sockaddr_in6
name|prefix_h
decl_stmt|;
name|struct
name|sockaddr_in6
name|prefix_h2
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* I compare on the adresses, inet6_equal use the scope, too */
name|prefix_h
operator|.
name|sin6_scope_id
operator|=
name|prefix_h2
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
name|prefix_h
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
name|group_addr
operator|->
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|&
name|group_mask
operator|.
name|s6_addr
index|[
name|i
index|]
expr_stmt|;
comment|/* The ordering is: bigger first */
for|for
control|(
name|grp_mask
operator|=
operator|*
name|used_grp_mask_list
init|;
name|grp_mask
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|;
name|grp_mask_prev
operator|=
name|grp_mask
operator|,
name|grp_mask
operator|=
name|grp_mask
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
name|prefix_h2
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
operator|(
name|grp_mask
operator|->
name|group_addr
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|&
name|grp_mask
operator|->
name|group_mask
operator|.
name|s6_addr
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|inet6_greaterthan
argument_list|(
operator|&
name|prefix_h2
argument_list|,
operator|&
name|prefix_h
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|prefix_h2
argument_list|,
operator|&
name|prefix_h
argument_list|)
condition|)
return|return
operator|(
name|grp_mask
operator|)
return|;
else|else
break|break;
block|}
name|grp_mask_tmp
operator|=
operator|(
name|grp_mask_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|grp_mask_t
argument_list|)
argument_list|)
expr_stmt|;
name|grp_mask_tmp
operator|->
name|grp_rp_next
operator|=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|grp_mask_tmp
operator|->
name|next
operator|=
name|grp_mask
expr_stmt|;
name|grp_mask_tmp
operator|->
name|prev
operator|=
name|grp_mask_prev
expr_stmt|;
if|if
condition|(
name|grp_mask
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|)
name|grp_mask
operator|->
name|prev
operator|=
name|grp_mask_tmp
expr_stmt|;
if|if
condition|(
name|grp_mask_prev
operator|==
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|)
block|{
operator|*
name|used_grp_mask_list
operator|=
name|grp_mask_tmp
expr_stmt|;
block|}
else|else
block|{
name|grp_mask_prev
operator|->
name|next
operator|=
name|grp_mask_tmp
expr_stmt|;
block|}
name|grp_mask_tmp
operator|->
name|group_addr
operator|=
operator|*
name|group_addr
expr_stmt|;
name|grp_mask_tmp
operator|->
name|group_mask
operator|=
name|group_mask
expr_stmt|;
name|grp_mask_tmp
operator|->
name|hash_mask
operator|=
name|hash_mask
expr_stmt|;
name|grp_mask_tmp
operator|->
name|group_rp_number
operator|=
literal|0
expr_stmt|;
name|grp_mask_tmp
operator|->
name|fragment_tag
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|grp_mask_tmp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: XXX: BUG: a remapping for some groups currently using some other  * grp_mask may be required by the addition of the new entry!!! Remapping all  * groups might be a costly process...  */
end_comment

begin_function
name|rp_grp_entry_t
modifier|*
name|add_rp_grp_entry
parameter_list|(
name|used_cand_rp_list
parameter_list|,
name|used_grp_mask_list
parameter_list|,
name|rp_addr
parameter_list|,
name|rp_priority
parameter_list|,
name|rp_holdtime
parameter_list|,
name|group_addr
parameter_list|,
name|group_mask
parameter_list|,
name|bsr_hash_mask
parameter_list|,
name|fragment_tag
parameter_list|)
name|cand_rp_t
modifier|*
modifier|*
name|used_cand_rp_list
decl_stmt|;
name|grp_mask_t
modifier|*
modifier|*
name|used_grp_mask_list
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|rp_addr
decl_stmt|;
name|u_int8
name|rp_priority
decl_stmt|;
name|u_int16
name|rp_holdtime
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|group_addr
decl_stmt|;
name|struct
name|in6_addr
name|group_mask
decl_stmt|;
name|struct
name|in6_addr
name|bsr_hash_mask
decl_stmt|;
name|u_int16
name|fragment_tag
decl_stmt|;
block|{
name|cand_rp_t
modifier|*
name|cand_rp_ptr
decl_stmt|;
name|grp_mask_t
modifier|*
name|grp_mask_ptr
decl_stmt|;
name|rpentry_t
modifier|*
name|rpentry_ptr
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|grp_rp_entry_next
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|grp_rp_entry_new
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|grp_rp_entry_prev
init|=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr_prev
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr_next
decl_stmt|;
name|u_int8
name|old_highest_priority
init|=
operator|~
literal|0
decl_stmt|;
comment|/* Smaller value means 						 * "higher" */
comment|/* Input data verification */
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
name|rp_addr
argument_list|)
condition|)
return|return
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
return|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|group_addr
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
return|return
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
return|;
block|}
name|grp_mask_ptr
operator|=
name|add_grp_mask
argument_list|(
name|used_grp_mask_list
argument_list|,
name|group_addr
argument_list|,
name|group_mask
argument_list|,
name|bsr_hash_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp_mask_ptr
operator|==
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
return|;
comment|/* TODO: delete */
if|#
directive|if
literal|0
block|if (grp_mask_ptr->grp_rp_next != (rp_grp_entry_t *) NULL)     {
comment|/* Check for obsolete grp_rp chain */
block|if ((my_bsr_address != curr_bsr_address)&& (grp_mask_ptr->grp_rp_next->fragment_tag != fragment_tag)) 	{
comment|/* This grp_rp chain is obsolete. Delete it. */
block|delete_grp_mask(used_cand_rp_list, used_grp_mask_list, 			    group_addr, group_mask); 	    grp_mask_ptr = add_grp_mask(used_grp_mask_list, group_addr, 					group_mask, bsr_hash_mask); 	    if (grp_mask_ptr == (grp_mask_t *) NULL) 		return (rp_grp_entry_t *) NULL; 	}     }
endif|#
directive|endif
comment|/* 0 */
name|cand_rp_ptr
operator|=
name|add_cand_rp
argument_list|(
name|used_cand_rp_list
argument_list|,
name|rp_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cand_rp_ptr
operator|==
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|grp_mask_ptr
operator|->
name|grp_rp_next
operator|==
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|delete_grp_mask
argument_list|(
name|used_cand_rp_list
argument_list|,
name|used_grp_mask_list
argument_list|,
name|group_addr
argument_list|,
name|group_mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
return|;
block|}
name|rpentry_ptr
operator|=
name|cand_rp_ptr
operator|->
name|rpentry
expr_stmt|;
name|SET_TIMER
argument_list|(
name|rpentry_ptr
operator|->
name|timer
argument_list|,
name|rp_holdtime
argument_list|)
expr_stmt|;
name|grp_mask_ptr
operator|->
name|fragment_tag
operator|=
name|fragment_tag
expr_stmt|;
comment|/* For garbage collection */
name|grp_rp_entry_prev
operator|=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|grp_rp_entry_next
operator|=
name|grp_mask_ptr
operator|->
name|grp_rp_next
expr_stmt|;
comment|/* TODO: improve it */
if|if
condition|(
name|grp_rp_entry_next
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|old_highest_priority
operator|=
name|grp_rp_entry_next
operator|->
name|priority
expr_stmt|;
for|for
control|(
init|;
name|grp_rp_entry_next
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|grp_rp_entry_prev
operator|=
name|grp_rp_entry_next
operator|,
name|grp_rp_entry_next
operator|=
name|grp_rp_entry_next
operator|->
name|grp_rp_next
control|)
block|{
comment|/* 	 * Smaller value means higher priority. The entries are sorted with 	 * the highest priority first. 	 */
if|if
condition|(
name|grp_rp_entry_next
operator|->
name|priority
operator|<
name|rp_priority
condition|)
continue|continue;
if|if
condition|(
name|grp_rp_entry_next
operator|->
name|priority
operator|>
name|rp_priority
condition|)
break|break;
comment|/* 	 * Here we don't care about higher/lower addresses, because higher 	 * address does not guarantee higher hash_value, but anyway we do 	 * order with the higher address first, so it will be easier to find 	 * an existing entry and update the holdtime. 	 */
if|if
condition|(
name|inet6_greaterthan
argument_list|(
operator|&
name|grp_rp_entry_next
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|address
argument_list|,
name|rp_addr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|inet6_lessthan
argument_list|(
operator|&
name|grp_rp_entry_next
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|address
argument_list|,
name|rp_addr
argument_list|)
condition|)
break|break;
comment|/* We already have this entry. Update the holdtime */
comment|/* 	 * TODO: We shoudn't have old existing entry, because with the 	 * current implementation all of them will be deleted (different 	 * fragment_tag). Debug and check and eventually delete. 	 */
name|grp_rp_entry_next
operator|->
name|holdtime
operator|=
name|rp_holdtime
expr_stmt|;
name|grp_rp_entry_next
operator|->
name|advholdtime
operator|=
name|rp_holdtime
expr_stmt|;
name|grp_rp_entry_next
operator|->
name|fragment_tag
operator|=
name|fragment_tag
expr_stmt|;
return|return
operator|(
name|grp_rp_entry_next
operator|)
return|;
block|}
comment|/* Create and link the new entry */
name|grp_rp_entry_new
operator|=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|rp_grp_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|grp_rp_entry_new
operator|->
name|grp_rp_next
operator|=
name|grp_rp_entry_next
expr_stmt|;
name|grp_rp_entry_new
operator|->
name|grp_rp_prev
operator|=
name|grp_rp_entry_prev
expr_stmt|;
if|if
condition|(
name|grp_rp_entry_next
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|grp_rp_entry_next
operator|->
name|grp_rp_prev
operator|=
name|grp_rp_entry_new
expr_stmt|;
if|if
condition|(
name|grp_rp_entry_prev
operator|==
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|grp_mask_ptr
operator|->
name|grp_rp_next
operator|=
name|grp_rp_entry_new
expr_stmt|;
else|else
name|grp_rp_entry_prev
operator|->
name|grp_rp_next
operator|=
name|grp_rp_entry_new
expr_stmt|;
comment|/*      * The rp_grp_entry chain is not ordered, so just plug the new entry at      * the head.      */
name|grp_rp_entry_new
operator|->
name|rp_grp_next
operator|=
name|cand_rp_ptr
operator|->
name|rp_grp_next
expr_stmt|;
if|if
condition|(
name|cand_rp_ptr
operator|->
name|rp_grp_next
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|cand_rp_ptr
operator|->
name|rp_grp_next
operator|->
name|rp_grp_prev
operator|=
name|grp_rp_entry_new
expr_stmt|;
name|grp_rp_entry_new
operator|->
name|rp_grp_prev
operator|=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|cand_rp_ptr
operator|->
name|rp_grp_next
operator|=
name|grp_rp_entry_new
expr_stmt|;
name|grp_rp_entry_new
operator|->
name|holdtime
operator|=
name|rp_holdtime
expr_stmt|;
name|grp_rp_entry_new
operator|->
name|advholdtime
operator|=
name|rp_holdtime
expr_stmt|;
name|grp_rp_entry_new
operator|->
name|fragment_tag
operator|=
name|fragment_tag
expr_stmt|;
name|grp_rp_entry_new
operator|->
name|priority
operator|=
name|rp_priority
expr_stmt|;
name|grp_rp_entry_new
operator|->
name|group
operator|=
name|grp_mask_ptr
expr_stmt|;
name|grp_rp_entry_new
operator|->
name|rp
operator|=
name|cand_rp_ptr
expr_stmt|;
name|grp_rp_entry_new
operator|->
name|grplink
operator|=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|grp_mask_ptr
operator|->
name|group_rp_number
operator|++
expr_stmt|;
if|if
condition|(
name|grp_mask_ptr
operator|->
name|grp_rp_next
operator|->
name|priority
operator|==
name|rp_priority
condition|)
block|{
comment|/* The first entries are with the best priority. */
comment|/* Adding this rp_grp_entry may result in group_to_rp remapping */
for|for
control|(
name|grp_rp_entry_next
operator|=
name|grp_mask_ptr
operator|->
name|grp_rp_next
init|;
name|grp_rp_entry_next
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|grp_rp_entry_next
operator|=
name|grp_rp_entry_next
operator|->
name|grp_rp_next
control|)
block|{
if|if
condition|(
name|grp_rp_entry_next
operator|->
name|priority
operator|>
name|old_highest_priority
condition|)
break|break;
for|for
control|(
name|grpentry_ptr_prev
operator|=
name|grp_rp_entry_next
operator|->
name|grplink
init|;
name|grpentry_ptr_prev
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
control|)
block|{
name|grpentry_ptr_next
operator|=
name|grpentry_ptr_prev
operator|->
name|rpnext
expr_stmt|;
name|remap_grpentry
argument_list|(
name|grpentry_ptr_prev
argument_list|)
expr_stmt|;
name|grpentry_ptr_prev
operator|=
name|grpentry_ptr_next
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|grp_rp_entry_new
operator|)
return|;
block|}
end_function

begin_function
name|void
name|delete_rp_grp_entry
parameter_list|(
name|used_cand_rp_list
parameter_list|,
name|used_grp_mask_list
parameter_list|,
name|rp_grp_entry_delete
parameter_list|)
name|cand_rp_t
modifier|*
modifier|*
name|used_cand_rp_list
decl_stmt|;
name|grp_mask_t
modifier|*
modifier|*
name|used_grp_mask_list
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_delete
decl_stmt|;
block|{
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr_next
decl_stmt|;
if|if
condition|(
name|rp_grp_entry_delete
operator|==
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
name|rp_grp_entry_delete
operator|->
name|group
operator|->
name|group_rp_number
operator|--
expr_stmt|;
comment|/* Free the rp_grp* and grp_rp* links */
if|if
condition|(
name|rp_grp_entry_delete
operator|->
name|rp_grp_prev
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|rp_grp_entry_delete
operator|->
name|rp_grp_prev
operator|->
name|rp_grp_next
operator|=
name|rp_grp_entry_delete
operator|->
name|rp_grp_next
expr_stmt|;
else|else
name|rp_grp_entry_delete
operator|->
name|rp
operator|->
name|rp_grp_next
operator|=
name|rp_grp_entry_delete
operator|->
name|rp_grp_next
expr_stmt|;
if|if
condition|(
name|rp_grp_entry_delete
operator|->
name|rp_grp_next
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|rp_grp_entry_delete
operator|->
name|rp_grp_next
operator|->
name|rp_grp_prev
operator|=
name|rp_grp_entry_delete
operator|->
name|rp_grp_prev
expr_stmt|;
if|if
condition|(
name|rp_grp_entry_delete
operator|->
name|grp_rp_prev
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|rp_grp_entry_delete
operator|->
name|grp_rp_prev
operator|->
name|grp_rp_next
operator|=
name|rp_grp_entry_delete
operator|->
name|grp_rp_next
expr_stmt|;
else|else
name|rp_grp_entry_delete
operator|->
name|group
operator|->
name|grp_rp_next
operator|=
name|rp_grp_entry_delete
operator|->
name|grp_rp_next
expr_stmt|;
if|if
condition|(
name|rp_grp_entry_delete
operator|->
name|grp_rp_next
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|rp_grp_entry_delete
operator|->
name|grp_rp_next
operator|->
name|grp_rp_prev
operator|=
name|rp_grp_entry_delete
operator|->
name|grp_rp_prev
expr_stmt|;
comment|/* Delete Cand-RP or Group-prefix if useless */
if|if
condition|(
name|rp_grp_entry_delete
operator|->
name|group
operator|->
name|grp_rp_next
operator|==
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|delete_grp_mask_entry
argument_list|(
name|used_cand_rp_list
argument_list|,
name|used_grp_mask_list
argument_list|,
name|rp_grp_entry_delete
operator|->
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_grp_entry_delete
operator|->
name|rp
operator|->
name|rp_grp_next
operator|==
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|delete_rp_entry
argument_list|(
name|used_cand_rp_list
argument_list|,
name|used_grp_mask_list
argument_list|,
name|rp_grp_entry_delete
operator|->
name|rp
argument_list|)
expr_stmt|;
comment|/* Remap all affected groups */
for|for
control|(
name|grpentry_ptr
operator|=
name|rp_grp_entry_delete
operator|->
name|grplink
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_ptr_next
control|)
block|{
name|grpentry_ptr_next
operator|=
name|grpentry_ptr
operator|->
name|rpnext
expr_stmt|;
name|remap_grpentry
argument_list|(
name|grpentry_ptr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rp_grp_entry_delete
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TODO: XXX: the affected group entries will be partially setup, because may  * have group routing entry, but NULL pointers to RP. After the call to this  * function, must remap all group entries ASAP.  */
end_comment

begin_function
name|void
name|delete_rp_list
parameter_list|(
name|used_cand_rp_list
parameter_list|,
name|used_grp_mask_list
parameter_list|)
name|cand_rp_t
modifier|*
modifier|*
name|used_cand_rp_list
decl_stmt|;
name|grp_mask_t
modifier|*
modifier|*
name|used_grp_mask_list
decl_stmt|;
block|{
name|cand_rp_t
modifier|*
name|cand_rp_ptr
decl_stmt|,
modifier|*
name|cand_rp_next
decl_stmt|;
name|grp_mask_t
modifier|*
name|grp_mask_ptr
decl_stmt|,
modifier|*
name|grp_mask_next
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_ptr
decl_stmt|,
modifier|*
name|rp_grp_entry_next
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|,
modifier|*
name|grpentry_ptr_next
decl_stmt|;
for|for
control|(
name|cand_rp_ptr
operator|=
operator|*
name|used_cand_rp_list
init|;
name|cand_rp_ptr
operator|!=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|;
control|)
block|{
name|cand_rp_next
operator|=
name|cand_rp_ptr
operator|->
name|next
expr_stmt|;
comment|/* Free the mrtentry (if any) for this RP */
if|if
condition|(
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|mrtlink
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|mrtlink
operator|->
name|flags
operator|&
name|MRTF_KERNEL_CACHE
condition|)
name|delete_mrtentry_all_kernel_cache
argument_list|(
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|mrtlink
argument_list|)
expr_stmt|;
name|FREE_MRTENTRY
argument_list|(
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|mrtlink
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|cand_rp_ptr
operator|->
name|rpentry
argument_list|)
expr_stmt|;
comment|/* Free the whole chain of rp_grp_entry for this RP */
for|for
control|(
name|rp_grp_entry_ptr
operator|=
name|cand_rp_ptr
operator|->
name|rp_grp_next
init|;
name|rp_grp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|rp_grp_entry_ptr
operator|=
name|rp_grp_entry_next
control|)
block|{
name|rp_grp_entry_next
operator|=
name|rp_grp_entry_ptr
operator|->
name|rp_grp_next
expr_stmt|;
comment|/* Clear the RP related invalid pointers for all group entries */
for|for
control|(
name|grpentry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|grplink
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_ptr_next
control|)
block|{
name|grpentry_ptr_next
operator|=
name|grpentry_ptr
operator|->
name|rpnext
expr_stmt|;
name|grpentry_ptr
operator|->
name|rpnext
operator|=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|grpentry_ptr
operator|->
name|rpprev
operator|=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|grpentry_ptr
operator|->
name|active_rp_grp
operator|=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|grpentry_ptr
operator|->
name|rpaddr
operator|=
name|sockaddr6_any
expr_stmt|;
block|}
name|free
argument_list|(
name|rp_grp_entry_ptr
argument_list|)
expr_stmt|;
block|}
name|cand_rp_ptr
operator|=
name|cand_rp_next
expr_stmt|;
block|}
operator|*
name|used_cand_rp_list
operator|=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|grp_mask_ptr
operator|=
operator|*
name|used_grp_mask_list
init|;
name|grp_mask_ptr
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|;
name|grp_mask_ptr
operator|=
name|grp_mask_next
control|)
block|{
name|grp_mask_next
operator|=
name|grp_mask_ptr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|grp_mask_ptr
argument_list|)
expr_stmt|;
block|}
operator|*
name|used_grp_mask_list
operator|=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|delete_grp_mask
parameter_list|(
name|used_cand_rp_list
parameter_list|,
name|used_grp_mask_list
parameter_list|,
name|group_addr
parameter_list|,
name|group_mask
parameter_list|)
name|cand_rp_t
modifier|*
modifier|*
name|used_cand_rp_list
decl_stmt|;
name|grp_mask_t
modifier|*
modifier|*
name|used_grp_mask_list
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|group_addr
decl_stmt|;
name|struct
name|in6_addr
name|group_mask
decl_stmt|;
block|{
name|grp_mask_t
modifier|*
name|grp_mask_ptr
decl_stmt|;
name|struct
name|sockaddr_in6
name|prefix_h
decl_stmt|;
name|struct
name|sockaddr_in6
name|prefix_h2
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
name|prefix_h
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
name|group_addr
operator|->
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|&
name|group_mask
operator|.
name|s6_addr
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|grp_mask_ptr
operator|=
operator|*
name|used_grp_mask_list
init|;
name|grp_mask_ptr
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|;
name|grp_mask_ptr
operator|=
name|grp_mask_ptr
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
name|prefix_h2
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
name|grp_mask_ptr
operator|->
name|group_addr
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|&
name|grp_mask_ptr
operator|->
name|group_mask
operator|.
name|s6_addr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|inet6_greaterthan
argument_list|(
operator|&
name|prefix_h2
argument_list|,
operator|&
name|prefix_h
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|grp_mask_ptr
operator|->
name|group_addr
operator|.
name|sin6_addr
argument_list|,
operator|&
name|group_addr
operator|->
name|sin6_addr
argument_list|)
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|grp_mask_ptr
operator|->
name|group_mask
argument_list|,
operator|&
name|group_mask
argument_list|)
condition|)
break|break;
else|else
return|return;
comment|/* Not found */
block|}
if|if
condition|(
name|grp_mask_ptr
operator|==
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* Not found */
name|delete_grp_mask_entry
argument_list|(
name|used_cand_rp_list
argument_list|,
name|used_grp_mask_list
argument_list|,
name|grp_mask_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_grp_mask_entry
parameter_list|(
name|used_cand_rp_list
parameter_list|,
name|used_grp_mask_list
parameter_list|,
name|grp_mask_delete
parameter_list|)
name|cand_rp_t
modifier|*
modifier|*
name|used_cand_rp_list
decl_stmt|;
name|grp_mask_t
modifier|*
modifier|*
name|used_grp_mask_list
decl_stmt|;
name|grp_mask_t
modifier|*
name|grp_mask_delete
decl_stmt|;
block|{
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|,
modifier|*
name|grpentry_ptr_next
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|grp_rp_entry_ptr
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|grp_rp_entry_next
decl_stmt|;
if|if
condition|(
name|grp_mask_delete
operator|==
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* Remove from the grp_mask_list first */
if|if
condition|(
name|grp_mask_delete
operator|->
name|prev
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|)
name|grp_mask_delete
operator|->
name|prev
operator|->
name|next
operator|=
name|grp_mask_delete
operator|->
name|next
expr_stmt|;
else|else
operator|*
name|used_grp_mask_list
operator|=
name|grp_mask_delete
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|grp_mask_delete
operator|->
name|next
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|)
name|grp_mask_delete
operator|->
name|next
operator|->
name|prev
operator|=
name|grp_mask_delete
operator|->
name|prev
expr_stmt|;
comment|/* Remove all grp_rp entries for this grp_mask */
for|for
control|(
name|grp_rp_entry_ptr
operator|=
name|grp_mask_delete
operator|->
name|grp_rp_next
init|;
name|grp_rp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|grp_rp_entry_ptr
operator|=
name|grp_rp_entry_next
control|)
block|{
name|grp_rp_entry_next
operator|=
name|grp_rp_entry_ptr
operator|->
name|grp_rp_next
expr_stmt|;
comment|/* Remap all related grpentry */
for|for
control|(
name|grpentry_ptr
operator|=
name|grp_rp_entry_ptr
operator|->
name|grplink
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_ptr_next
control|)
block|{
name|grpentry_ptr_next
operator|=
name|grpentry_ptr
operator|->
name|rpnext
expr_stmt|;
name|remap_grpentry
argument_list|(
name|grpentry_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|grp_rp_entry_ptr
operator|->
name|rp_grp_prev
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|grp_rp_entry_ptr
operator|->
name|rp_grp_prev
operator|->
name|rp_grp_next
operator|=
name|grp_rp_entry_ptr
operator|->
name|rp_grp_next
expr_stmt|;
block|}
else|else
block|{
name|grp_rp_entry_ptr
operator|->
name|rp
operator|->
name|rp_grp_next
operator|=
name|grp_rp_entry_ptr
operator|->
name|rp_grp_next
expr_stmt|;
block|}
if|if
condition|(
name|grp_rp_entry_ptr
operator|->
name|rp_grp_next
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|grp_rp_entry_ptr
operator|->
name|rp_grp_next
operator|->
name|rp_grp_prev
operator|=
name|grp_rp_entry_ptr
operator|->
name|rp_grp_prev
expr_stmt|;
if|if
condition|(
name|grp_rp_entry_ptr
operator|->
name|rp
operator|->
name|rp_grp_next
operator|==
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Delete the RP entry */
name|delete_rp_entry
argument_list|(
name|used_cand_rp_list
argument_list|,
name|used_grp_mask_list
argument_list|,
name|grp_rp_entry_ptr
operator|->
name|rp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|grp_rp_entry_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * TODO: currently not used.  */
end_comment

begin_function
name|void
name|delete_rp
parameter_list|(
name|used_cand_rp_list
parameter_list|,
name|used_grp_mask_list
parameter_list|,
name|rp_addr
parameter_list|)
name|cand_rp_t
modifier|*
modifier|*
name|used_cand_rp_list
decl_stmt|;
name|grp_mask_t
modifier|*
modifier|*
name|used_grp_mask_list
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|rp_addr
decl_stmt|;
block|{
name|cand_rp_t
modifier|*
name|cand_rp_ptr
decl_stmt|;
for|for
control|(
name|cand_rp_ptr
operator|=
operator|*
name|used_cand_rp_list
init|;
name|cand_rp_ptr
operator|!=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|;
name|cand_rp_ptr
operator|=
name|cand_rp_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|inet6_greaterthan
argument_list|(
operator|&
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|address
argument_list|,
name|rp_addr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|address
argument_list|,
name|rp_addr
argument_list|)
condition|)
break|break;
else|else
return|return;
comment|/* Not found */
block|}
if|if
condition|(
name|cand_rp_ptr
operator|==
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* Not found */
name|delete_rp_entry
argument_list|(
name|used_cand_rp_list
argument_list|,
name|used_grp_mask_list
argument_list|,
name|cand_rp_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_rp_entry
parameter_list|(
name|used_cand_rp_list
parameter_list|,
name|used_grp_mask_list
parameter_list|,
name|cand_rp_delete
parameter_list|)
name|cand_rp_t
modifier|*
modifier|*
name|used_cand_rp_list
decl_stmt|;
name|grp_mask_t
modifier|*
modifier|*
name|used_grp_mask_list
decl_stmt|;
name|cand_rp_t
modifier|*
name|cand_rp_delete
decl_stmt|;
block|{
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_ptr
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_next
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr_next
decl_stmt|;
if|if
condition|(
name|cand_rp_delete
operator|==
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* Remove from the cand-RP chain */
if|if
condition|(
name|cand_rp_delete
operator|->
name|prev
operator|!=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|)
name|cand_rp_delete
operator|->
name|prev
operator|->
name|next
operator|=
name|cand_rp_delete
operator|->
name|next
expr_stmt|;
else|else
operator|*
name|used_cand_rp_list
operator|=
name|cand_rp_delete
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|cand_rp_delete
operator|->
name|next
operator|!=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|)
name|cand_rp_delete
operator|->
name|next
operator|->
name|prev
operator|=
name|cand_rp_delete
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|cand_rp_delete
operator|->
name|rpentry
operator|->
name|mrtlink
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|cand_rp_delete
operator|->
name|rpentry
operator|->
name|mrtlink
operator|->
name|flags
operator|&
name|MRTF_KERNEL_CACHE
condition|)
name|delete_mrtentry_all_kernel_cache
argument_list|(
name|cand_rp_delete
operator|->
name|rpentry
operator|->
name|mrtlink
argument_list|)
expr_stmt|;
name|FREE_MRTENTRY
argument_list|(
name|cand_rp_delete
operator|->
name|rpentry
operator|->
name|mrtlink
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cand_rp_delete
operator|->
name|rpentry
argument_list|)
expr_stmt|;
comment|/* Remove all rp_grp entries for this RP */
for|for
control|(
name|rp_grp_entry_ptr
operator|=
name|cand_rp_delete
operator|->
name|rp_grp_next
init|;
name|rp_grp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|rp_grp_entry_ptr
operator|=
name|rp_grp_entry_next
control|)
block|{
name|rp_grp_entry_next
operator|=
name|rp_grp_entry_ptr
operator|->
name|rp_grp_next
expr_stmt|;
name|rp_grp_entry_ptr
operator|->
name|group
operator|->
name|group_rp_number
operator|--
expr_stmt|;
comment|/* First take care of the grp_rp chain */
if|if
condition|(
name|rp_grp_entry_ptr
operator|->
name|grp_rp_prev
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|rp_grp_entry_ptr
operator|->
name|grp_rp_prev
operator|->
name|grp_rp_next
operator|=
name|rp_grp_entry_ptr
operator|->
name|grp_rp_next
expr_stmt|;
block|}
else|else
block|{
name|rp_grp_entry_ptr
operator|->
name|group
operator|->
name|grp_rp_next
operator|=
name|rp_grp_entry_ptr
operator|->
name|grp_rp_next
expr_stmt|;
block|}
if|if
condition|(
name|rp_grp_entry_ptr
operator|->
name|grp_rp_next
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|rp_grp_entry_ptr
operator|->
name|grp_rp_next
operator|->
name|grp_rp_prev
operator|=
name|rp_grp_entry_ptr
operator|->
name|grp_rp_prev
expr_stmt|;
block|}
if|if
condition|(
name|rp_grp_entry_ptr
operator|->
name|grp_rp_next
operator|==
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|delete_grp_mask_entry
argument_list|(
name|used_cand_rp_list
argument_list|,
name|used_grp_mask_list
argument_list|,
name|rp_grp_entry_ptr
operator|->
name|group
argument_list|)
expr_stmt|;
block|}
comment|/* Remap the related groups */
for|for
control|(
name|grpentry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|grplink
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_ptr_next
control|)
block|{
name|grpentry_ptr_next
operator|=
name|grpentry_ptr
operator|->
name|rpnext
expr_stmt|;
name|remap_grpentry
argument_list|(
name|grpentry_ptr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|rp_grp_entry_ptr
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cand_rp_delete
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rehash the RP for the group. XXX: currently, every time when  * remap_grpentry() is called, there has being a good reason to change the  * RP, so for performancy reasons no check is performed whether the RP will  * be really different one.  */
end_comment

begin_function
name|int
name|remap_grpentry
parameter_list|(
name|grpentry_ptr
parameter_list|)
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|;
block|{
name|rpentry_t
modifier|*
name|rpentry_ptr
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|grp_route
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
if|if
condition|(
name|grpentry_ptr
operator|==
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Remove from the list of all groups matching to the same RP */
if|if
condition|(
name|grpentry_ptr
operator|->
name|rpprev
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|)
name|grpentry_ptr
operator|->
name|rpprev
operator|->
name|rpnext
operator|=
name|grpentry_ptr
operator|->
name|rpnext
expr_stmt|;
else|else
block|{
if|if
condition|(
name|grpentry_ptr
operator|->
name|active_rp_grp
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
name|grpentry_ptr
operator|->
name|active_rp_grp
operator|->
name|grplink
operator|=
name|grpentry_ptr
operator|->
name|rpnext
expr_stmt|;
block|}
if|if
condition|(
name|grpentry_ptr
operator|->
name|rpnext
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|)
name|grpentry_ptr
operator|->
name|rpnext
operator|->
name|rpprev
operator|=
name|grpentry_ptr
operator|->
name|rpprev
expr_stmt|;
name|rp_grp_entry_ptr
operator|=
name|rp_grp_match
argument_list|(
operator|&
name|grpentry_ptr
operator|->
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_grp_entry_ptr
operator|==
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* If cannot remap, delete the group */
name|delete_grpentry
argument_list|(
name|grpentry_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|rpentry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|rp
operator|->
name|rpentry
expr_stmt|;
comment|/* Add to the new chain of all groups mapping to the same RP */
name|grpentry_ptr
operator|->
name|rpaddr
operator|=
name|rpentry_ptr
operator|->
name|address
expr_stmt|;
name|grpentry_ptr
operator|->
name|active_rp_grp
operator|=
name|rp_grp_entry_ptr
expr_stmt|;
name|grpentry_ptr
operator|->
name|rpnext
operator|=
name|rp_grp_entry_ptr
operator|->
name|grplink
expr_stmt|;
if|if
condition|(
name|grpentry_ptr
operator|->
name|rpnext
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|)
name|grpentry_ptr
operator|->
name|rpnext
operator|->
name|rpprev
operator|=
name|grpentry_ptr
expr_stmt|;
name|grpentry_ptr
operator|->
name|rpprev
operator|=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|rp_grp_entry_ptr
operator|->
name|grplink
operator|=
name|grpentry_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|grp_route
operator|=
name|grpentry_ptr
operator|->
name|grp_route
operator|)
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|grp_route
operator|->
name|upstream
operator|=
name|rpentry_ptr
operator|->
name|upstream
expr_stmt|;
name|grp_route
operator|->
name|metric
operator|=
name|rpentry_ptr
operator|->
name|metric
expr_stmt|;
name|grp_route
operator|->
name|preference
operator|=
name|rpentry_ptr
operator|->
name|preference
expr_stmt|;
name|change_interfaces
argument_list|(
name|grp_route
argument_list|,
name|rpentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|grp_route
operator|->
name|joined_oifs
argument_list|,
operator|&
name|grp_route
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|grp_route
operator|->
name|leaves
argument_list|,
operator|&
name|grp_route
operator|->
name|asserted_oifs
argument_list|,
name|MFC_UPDATE_FORCE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|mrtentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|grpnext
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
operator|)
condition|)
continue|continue;
name|mrtentry_ptr
operator|->
name|upstream
operator|=
name|rpentry_ptr
operator|->
name|upstream
expr_stmt|;
name|mrtentry_ptr
operator|->
name|metric
operator|=
name|rpentry_ptr
operator|->
name|metric
expr_stmt|;
name|mrtentry_ptr
operator|->
name|preference
operator|=
name|rpentry_ptr
operator|->
name|preference
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|rpentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
name|MFC_UPDATE_FORCE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|rpentry_t
modifier|*
name|rp_match
parameter_list|(
name|group
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|group
decl_stmt|;
block|{
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_ptr
decl_stmt|;
name|rp_grp_entry_ptr
operator|=
name|rp_grp_match
argument_list|(
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_grp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|rp_grp_entry_ptr
operator|->
name|rp
operator|->
name|rpentry
operator|)
return|;
else|else
return|return
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_function
name|rp_grp_entry_t
modifier|*
name|rp_grp_match
parameter_list|(
name|group
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|group
decl_stmt|;
block|{
name|grp_mask_t
modifier|*
name|grp_mask_ptr
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|grp_rp_entry_ptr
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|best_entry
init|=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
decl_stmt|;
name|u_int8
name|best_priority
init|=
operator|~
literal|0
decl_stmt|;
comment|/* Smaller is better */
name|u_int32
name|best_hash_value
init|=
literal|0
decl_stmt|;
comment|/* Bigger is better */
name|struct
name|sockaddr_in6
name|best_address_h
decl_stmt|;
comment|/* Bigger is better */
name|u_int32
name|curr_hash_value
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in6
name|curr_address_h
decl_stmt|;
name|struct
name|sockaddr_in6
name|prefix_h
decl_stmt|;
name|struct
name|sockaddr_in6
name|prefix_h2
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|grp_mask_list
operator|==
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
return|;
comment|/* XXX: I compare on the adresses, inet6_equal use the scope too */
name|prefix_h
operator|.
name|sin6_scope_id
operator|=
name|prefix_h2
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|grp_mask_ptr
operator|=
name|grp_mask_list
init|;
name|grp_mask_ptr
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|;
name|grp_mask_ptr
operator|=
name|grp_mask_ptr
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
name|prefix_h2
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
operator|(
name|grp_mask_ptr
operator|->
name|group_addr
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|&
name|grp_mask_ptr
operator|->
name|group_mask
operator|.
name|s6_addr
index|[
name|i
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
name|prefix_h
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
operator|(
name|group
operator|->
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|&
name|grp_mask_ptr
operator|->
name|group_mask
operator|.
name|s6_addr
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|/* Search the grp_mask (group_prefix) list */
if|if
condition|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|prefix_h
argument_list|,
operator|&
name|prefix_h2
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|grp_rp_entry_ptr
operator|=
name|grp_mask_ptr
operator|->
name|grp_rp_next
init|;
name|grp_rp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|grp_rp_entry_ptr
operator|=
name|grp_rp_entry_ptr
operator|->
name|grp_rp_next
control|)
block|{
if|if
condition|(
name|best_priority
operator|<
name|grp_rp_entry_ptr
operator|->
name|priority
condition|)
break|break;
name|curr_address_h
operator|=
name|grp_rp_entry_ptr
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|address
expr_stmt|;
if|#
directive|if
literal|0
block|curr_hash_value = RP_HASH_VALUE(crc((char *)&group->sin6_addr, 						sizeof(struct in6_addr)), 					    crc((char *)&grp_mask_ptr->hash_mask, 						sizeof(struct in6_addr)), 					    crc((char *)&curr_address_h.sin6_addr, 						sizeof(struct in6_addr)));
else|#
directive|else
block|{
name|struct
name|in6_addr
name|masked_grp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
name|masked_grp
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
name|group
operator|->
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|&
name|grp_mask_ptr
operator|->
name|hash_mask
operator|.
name|s6_addr
index|[
name|i
index|]
expr_stmt|;
name|curr_hash_value
operator|=
name|RP_HASH_VALUE2
argument_list|(
name|crc
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|masked_grp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
argument_list|,
name|crc
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|curr_address_h
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|best_priority
operator|==
name|grp_rp_entry_ptr
operator|->
name|priority
condition|)
block|{
comment|/* Compare the hash_value and then the addresses */
if|if
condition|(
name|curr_hash_value
operator|<
name|best_hash_value
condition|)
continue|continue;
if|if
condition|(
name|curr_hash_value
operator|==
name|best_hash_value
condition|)
if|if
condition|(
name|inet6_lessthan
argument_list|(
operator|&
name|curr_address_h
argument_list|,
operator|&
name|best_address_h
argument_list|)
condition|)
continue|continue;
block|}
comment|/* The current entry in the loop is preferred */
name|best_entry
operator|=
name|grp_rp_entry_ptr
expr_stmt|;
name|best_priority
operator|=
name|best_entry
operator|->
name|priority
expr_stmt|;
name|best_address_h
operator|=
name|curr_address_h
expr_stmt|;
name|best_hash_value
operator|=
name|curr_hash_value
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_entry
operator|==
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
return|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_CAND_RP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Rp_grp_match found %s for group %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|best_entry
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|best_entry
operator|)
return|;
block|}
end_function

begin_function
name|rpentry_t
modifier|*
name|rp_find
parameter_list|(
name|rp_address
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|rp_address
decl_stmt|;
block|{
name|cand_rp_t
modifier|*
name|cand_rp_ptr
decl_stmt|;
for|for
control|(
name|cand_rp_ptr
operator|=
name|cand_rp_list
init|;
name|cand_rp_ptr
operator|!=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|;
name|cand_rp_ptr
operator|=
name|cand_rp_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|inet6_greaterthan
argument_list|(
operator|&
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|address
argument_list|,
name|rp_address
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|address
argument_list|,
name|rp_address
argument_list|)
condition|)
return|return
operator|(
name|cand_rp_ptr
operator|->
name|rpentry
operator|)
return|;
return|return
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
return|;
block|}
return|return
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Create a bootstrap message in "send_buff" and returns the data size  * (excluding the IP header and the PIM header) Can be used both by the  * Bootstrap router to multicast the RP-set or by the DR to unicast it to a  * new neighbor. It DOES NOT change any timers.  */
end_comment

begin_function
name|int
name|create_pim6_bootstrap_message
parameter_list|(
name|send_buff
parameter_list|)
name|char
modifier|*
name|send_buff
decl_stmt|;
block|{
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|grp_mask_t
modifier|*
name|grp_mask_ptr
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|grp_rp_entry_ptr
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|u_int8
name|masklen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|curr_bsr_address
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|send_buff
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|curr_bsr_address
argument_list|,
operator|&
name|my_bsr_address
argument_list|)
condition|)
name|curr_bsr_fragment_tag
operator|++
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|curr_bsr_fragment_tag
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|MASK_TO_MASKLEN6
argument_list|(
name|curr_bsr_hash_mask
argument_list|,
name|masklen
argument_list|)
expr_stmt|;
name|PUT_BYTE
argument_list|(
name|masklen
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_BYTE
argument_list|(
name|curr_bsr_priority
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_EUADDR6
argument_list|(
name|curr_bsr_address
operator|.
name|sin6_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* TODO: XXX: No fragmentation support (yet) */
for|for
control|(
name|grp_mask_ptr
operator|=
name|grp_mask_list
init|;
name|grp_mask_ptr
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|;
name|grp_mask_ptr
operator|=
name|grp_mask_ptr
operator|->
name|next
control|)
block|{
name|MASK_TO_MASKLEN6
argument_list|(
name|grp_mask_ptr
operator|->
name|group_mask
argument_list|,
name|masklen
argument_list|)
expr_stmt|;
name|PUT_EGADDR6
argument_list|(
name|grp_mask_ptr
operator|->
name|group_addr
operator|.
name|sin6_addr
argument_list|,
name|masklen
argument_list|,
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_BYTE
argument_list|(
name|grp_mask_ptr
operator|->
name|group_rp_number
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_BYTE
argument_list|(
name|grp_mask_ptr
operator|->
name|group_rp_number
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* TODO: if frag. */
name|PUT_HOSTSHORT
argument_list|(
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
for|for
control|(
name|grp_rp_entry_ptr
operator|=
name|grp_mask_ptr
operator|->
name|grp_rp_next
init|;
name|grp_rp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|grp_rp_entry_ptr
operator|=
name|grp_rp_entry_ptr
operator|->
name|grp_rp_next
control|)
block|{
name|PUT_EUADDR6
argument_list|(
name|grp_rp_entry_ptr
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|address
operator|.
name|sin6_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|grp_rp_entry_ptr
operator|->
name|advholdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_BYTE
argument_list|(
name|grp_rp_entry_ptr
operator|->
name|priority
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_BYTE
argument_list|(
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* The reserved field */
block|}
block|}
name|datalen
operator|=
operator|(
name|data_ptr
operator|-
operator|(
name|u_int8
operator|*
operator|)
name|send_buff
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
expr_stmt|;
return|return
operator|(
name|datalen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the rp_addr is the RP for the group corresponding to  * mrtentry_ptr. Return TRUE or FALSE.  */
end_comment

begin_function
name|int
name|check_mrtentry_rp
parameter_list|(
name|mrtentry_ptr
parameter_list|,
name|rp_addr
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|rp_addr
decl_stmt|;
block|{
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_ptr
decl_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|rp_addr
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rp_grp_entry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
expr_stmt|;
if|if
condition|(
name|rp_grp_entry_ptr
operator|==
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|rpaddr
argument_list|,
name|rp_addr
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

end_unit

