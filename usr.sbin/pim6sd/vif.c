begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1998 by the University of Southern California.  *  All rights reserved.  *  *  Permission to use, copy, modify, and distribute this software and  *  its documentation in source and binary forms for lawful  *  purposes and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both  *  the copyright notice and this permission notice appear in supporting  *  documentation, and that any documentation, advertising materials,  *  and other materials related to such distribution and use acknowledge  *  that the software was developed by the University of Southern  *  California and/or Information Sciences Institute.  *  The name of the University of Southern California may not  *  be used to endorse or promote products derived from this software  *  without specific prior written permission.  *  *  THE UNIVERSITY OF SOUTHERN CALIFORNIA DOES NOT MAKE ANY REPRESENTATIONS  *  ABOUT THE SUITABILITY OF THIS SOFTWARE FOR ANY PURPOSE.  THIS SOFTWARE IS  *  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  *  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND  *  NON-INFRINGEMENT.  *  *  IN NO EVENT SHALL USC, OR ANY OTHER CONTRIBUTOR BE LIABLE FOR ANY  *  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, WHETHER IN CONTRACT,  *  TORT, OR OTHER FORM OF ACTION, ARISING OUT OF OR IN CONNECTION WITH,  *  THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *  Other copyrights might apply to parts of this software and are so  *  noted when applicable.  */
end_comment

begin_comment
comment|/*  *  Questions concerning this software should be directed to  *  Mickael Hoerdt (hoerdt@clarinet.u-strasbg.fr) LSIIT Strasbourg.  *  */
end_comment

begin_comment
comment|/*  * This program has been derived from pim6dd.          * The pim6dd program is covered by the license in the accompanying file  * named "LICENSE.pim6dd".  */
end_comment

begin_comment
comment|/*  * This program has been derived from pimd.          * The pimd program is covered by the license in the accompanying file  * named "LICENSE.pimd".  *  */
end_comment

begin_comment
comment|/*  * Part of this program has been derived from mrouted.  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE.mrouted".  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"vif.h"
end_include

begin_include
include|#
directive|include
file|"mld6.h"
end_include

begin_include
include|#
directive|include
file|"pim6.h"
end_include

begin_include
include|#
directive|include
file|"pimd.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"inet6.h"
end_include

begin_include
include|#
directive|include
file|"kern.h"
end_include

begin_include
include|#
directive|include
file|"mld6_proto.h"
end_include

begin_include
include|#
directive|include
file|"pim6_proto.h"
end_include

begin_include
include|#
directive|include
file|"mrt.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_decl_stmt
name|struct
name|uvif
name|uvifs
index|[
name|MAXMIFS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*the list of virtualsinterfaces */
end_comment

begin_decl_stmt
name|vifi_t
name|numvifs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*total number of interface */
end_comment

begin_decl_stmt
name|int
name|vifs_down
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vifi_t
name|reg_vif_num
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*register interface*/
end_comment

begin_decl_stmt
name|int
name|phys_vif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* An enabled vif that has a global address */
end_comment

begin_decl_stmt
name|int
name|udp_socket
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|total_interfaces
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|if_set
name|if_nullset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|if_set
name|if_result
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|init_reg_vif
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|start_all_vifs
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|start_vif
name|__P
argument_list|(
operator|(
name|vifi_t
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|stop_vif
name|__P
argument_list|(
operator|(
name|vifi_t
name|vivi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|update_reg_vif
name|__P
argument_list|(
operator|(
name|vifi_t
name|register_vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cfparse
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|init_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|int
name|enabled_vifs
decl_stmt|;
name|numvifs
operator|=
literal|0
expr_stmt|;
name|reg_vif_num
operator|=
name|NO_VIF
expr_stmt|;
comment|/* 	 * Configure the vifs based on the interface configuration of 	 * the kernel and the contents of the configuration file. 	 * (Open a UDP socket for ioctl use in the config procedures if 	 * the kernel can't handle IOCTL's on the MLD socket.) 	 */
ifdef|#
directive|ifdef
name|IOCTL_OK_ON_RAW_SOCKET
name|udp_socket
operator|=
name|mld6_socket
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|udp_socket
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"UDP6 socket"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* clean all the interfaces ... */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|MAXVIFS
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
name|memset
argument_list|(
name|v
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|v
argument_list|)
argument_list|)
expr_stmt|;
comment|/* everything is zeroed  => NULL , pointer NULL , addrANY ...) */
name|v
operator|->
name|uv_metric
operator|=
name|DEFAULT_METRIC
expr_stmt|;
name|v
operator|->
name|uv_rate_limit
operator|=
name|DEFAULT_PHY_RATE_LIMIT
expr_stmt|;
name|strncpy
argument_list|(
name|v
operator|->
name|uv_name
argument_list|,
literal|""
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_local_pref
operator|=
name|default_source_preference
expr_stmt|;
name|v
operator|->
name|uv_local_metric
operator|=
name|default_source_metric
expr_stmt|;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_IF
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Interfaces world initialized..."
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_IF
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Getting vifs from kernel"
argument_list|)
expr_stmt|;
name|config_vifs_from_kernel
argument_list|()
expr_stmt|;
if|if
condition|(
name|max_global_address
argument_list|()
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"There's no global address"
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_IF
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Getting vifs from %s"
argument_list|,
name|configfilename
argument_list|)
expr_stmt|;
comment|/* read config from file */
if|if
condition|(
name|cfparse
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"fatal error in parsing the config file"
argument_list|)
expr_stmt|;
name|enabled_vifs
operator|=
literal|0
expr_stmt|;
name|phys_vif
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
if|if
condition|(
name|v
operator|->
name|uv_linklocal
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"there is no link-local address on vif %s"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|phys_vif
operator|==
operator|-
literal|1
condition|)
block|{
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
comment|/* 			 * If this vif has a global address, set its id 			 * to phys_vif. 			 */
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|phys_vif
operator|=
name|vifi
expr_stmt|;
break|break;
block|}
block|}
block|}
name|enabled_vifs
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|enabled_vifs
operator|<
literal|2
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"can't forward: %s"
argument_list|,
name|enabled_vifs
operator|==
literal|0
condition|?
literal|"no enabled vifs"
else|:
literal|"only one enabled vif"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|if_nullset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|if_nullset
argument_list|)
argument_list|)
expr_stmt|;
name|k_init_pim
argument_list|(
name|mld6_socket
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_DETAIL
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Pim kernel initialization done"
argument_list|)
expr_stmt|;
comment|/* Add a dummy virtual interface to support Registers in the kernel. */
name|init_reg_vif
argument_list|()
expr_stmt|;
name|start_all_vifs
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|init_reg_vif
parameter_list|()
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|vifi_t
name|i
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|numvifs
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|numvifs
operator|+
literal|1
operator|)
operator|==
name|MAXVIFS
condition|)
block|{
comment|/* Exit the program! The PIM router must have a Register vif */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"cannot install the Register vif: too many interfaces"
argument_list|)
expr_stmt|;
comment|/* To make lint happy */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*      * So far in PIM we need only one register vif and we save its number in      * the global reg_vif_num.      */
name|reg_vif_num
operator|=
name|numvifs
expr_stmt|;
comment|/* Use the address of the first available physical interface to      * create the register vif.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|uvifs
index|[
name|i
index|]
operator|.
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
else|else
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|numvifs
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"No physical interface enabled"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
name|v
argument_list|,
operator|&
name|uvifs
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|v
operator|->
name|uv_name
argument_list|,
literal|"register_mif0"
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|=
name|MIFF_REGISTER
expr_stmt|;
ifdef|#
directive|ifdef
name|PIM_EXPERIMENTAL
name|v
operator|->
name|uv_flags
operator||=
name|MIFF_REGISTER_KERNEL_ENCAP
expr_stmt|;
endif|#
directive|endif
name|IF_DEBUG
argument_list|(
argument|DEBUG_IF
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Interface %s (subnet %s) ,installed on vif #%u - rate = %d"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|net6name
argument_list|(
operator|&
name|v
operator|->
name|uv_prefix
operator|.
name|sin6_addr
argument_list|,
operator|&
name|v
operator|->
name|uv_subnetmask
argument_list|)
argument_list|,
name|reg_vif_num
argument_list|,
name|v
operator|->
name|uv_rate_limit
argument_list|)
expr_stmt|;
name|numvifs
operator|++
expr_stmt|;
name|total_interfaces
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|start_all_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_int
name|action
decl_stmt|;
comment|/* Start first the NON-REGISTER vifs */
for|for
control|(
name|action
operator|=
literal|0
init|;
condition|;
name|action
operator|=
name|MIFF_REGISTER
control|)
block|{
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|MIFF_REGISTER
operator|)
operator|^
name|action
condition|)
comment|/* If starting non-registers but the vif is a register          * or if starting registers, but the interface is not          * a register, then just continue.          */
continue|continue;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_IF
argument_list|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DISABLED
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s is DISABLED ; vif #%u out of service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s is DOWN ; vif #%u out of service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|start_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|==
name|MIFF_REGISTER
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the vif and add to the kernel. The vif can be either  * physical, register or tunnel (tunnels will be used in the future  * when this code becomes PIM multicast boarder router.  */
end_comment

begin_function
name|void
name|start_vif
parameter_list|(
name|vifi_t
name|vifi
parameter_list|)
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
comment|/* Initialy no router on any vif */
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|MIFF_REGISTER
condition|)
name|v
operator|->
name|uv_flags
operator|=
name|v
operator|->
name|uv_flags
operator|&
operator|~
name|VIFF_DOWN
expr_stmt|;
else|else
block|{
name|v
operator|->
name|uv_flags
operator|=
operator|(
name|v
operator|->
name|uv_flags
operator||
name|VIFF_DR
operator||
name|VIFF_NONBRS
operator|)
operator|&
operator|~
name|VIFF_DOWN
expr_stmt|;
name|v
operator|->
name|uv_pim_hello_timer
operator|=
literal|1
operator|+
name|RANDOM
argument_list|()
operator|%
name|pim_hello_period
expr_stmt|;
name|v
operator|->
name|uv_jp_timer
operator|=
literal|1
operator|+
name|RANDOM
argument_list|()
operator|%
name|pim_join_prune_period
expr_stmt|;
block|}
comment|/* Tell kernel to add, i.e. start this vif */
name|k_add_vif
argument_list|(
name|mld6_socket
argument_list|,
name|vifi
argument_list|,
operator|&
name|uvifs
index|[
name|vifi
index|]
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_IF
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s comes up ,vif #%u now in service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|MIFF_REGISTER
operator|)
condition|)
block|{
comment|/* 	     * Join the PIM multicast group on the interface. 	     */
name|k_join
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|allpim6routers_group
operator|.
name|sin6_addr
argument_list|,
name|v
operator|->
name|uv_ifindex
argument_list|)
expr_stmt|;
comment|/* 	     * Join the ALL-ROUTERS multicast group on the interface. 	     * This allows mtrace requests to loop back if they are run 	     * on the multicast router.this allow receiving mld6 messages too. 	     */
name|k_join
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|allrouters_group
operator|.
name|sin6_addr
argument_list|,
name|v
operator|->
name|uv_ifindex
argument_list|)
expr_stmt|;
comment|/* 	     * Until neighbors are discovered, assume responsibility for sending 	     * periodic group membership queries to the subnet.  Send the first 	     * query. 	     */
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_QUERIER
expr_stmt|;
if|if
condition|(
operator|!
name|v
operator|->
name|uv_querier
condition|)
block|{
name|v
operator|->
name|uv_querier
operator|=
operator|(
expr|struct
name|listaddr
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listaddr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|v
operator|->
name|uv_querier
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|listaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
operator|=
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
expr_stmt|;
name|v
operator|->
name|uv_querier
operator|->
name|al_timer
operator|=
name|MLD6_OTHER_QUERIER_PRESENT_INTERVAL
expr_stmt|;
name|time
argument_list|(
operator|&
name|v
operator|->
name|uv_querier
operator|->
name|al_ctime
argument_list|)
expr_stmt|;
comment|/* reset timestamp */
name|query_groups
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* 	     * Send a probe via the new vif to look for neighbors. 	     */
name|send_pim6_hello
argument_list|(
name|v
argument_list|,
name|pim_hello_holdtime
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Stop a vif (either physical interface, tunnel or  * register.) If we are running only PIM we don't have tunnels.  */
end_comment

begin_function
name|void
name|stop_vif
parameter_list|(
name|vifi_t
name|vifi
parameter_list|)
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|listaddr
modifier|*
name|a
decl_stmt|;
specifier|register
name|pim_nbr_entry_t
modifier|*
name|n
decl_stmt|;
specifier|register
name|pim_nbr_entry_t
modifier|*
name|next
decl_stmt|;
name|struct
name|vif_acl
modifier|*
name|acl
decl_stmt|;
comment|/*      * TODO: make sure that the kernel viftable is      * consistent with the daemon table      */
name|v
operator|=
operator|&
name|uvifs
index|[
name|vifi
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|MIFF_REGISTER
operator|)
condition|)
block|{
name|k_leave
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|allpim6routers_group
operator|.
name|sin6_addr
argument_list|,
name|v
operator|->
name|uv_ifindex
argument_list|)
expr_stmt|;
name|k_leave
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|allrouters_group
operator|.
name|sin6_addr
argument_list|,
name|v
operator|->
name|uv_ifindex
argument_list|)
expr_stmt|;
comment|/*      * Discard all group addresses.  (No need to tell kernel;      * the k_del_vif() call will clean up kernel state.)      */
while|while
condition|(
name|v
operator|->
name|uv_groups
operator|!=
name|NULL
condition|)
block|{
name|a
operator|=
name|v
operator|->
name|uv_groups
expr_stmt|;
name|v
operator|->
name|uv_groups
operator|=
name|a
operator|->
name|al_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|a
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * TODO: inform (eventually) the neighbors I am going down by sending      * PIM_HELLO with holdtime=0 so someone else should become a DR.      */
comment|/* TODO: dummy! Implement it!! Any problems if don't use it? */
name|delete_vif_from_mrt
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
comment|/*      * Delete the interface from the kernel's vif structure.      */
name|k_del_vif
argument_list|(
name|mld6_socket
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|=
operator|(
name|v
operator|->
name|uv_flags
operator|&
operator|~
name|VIFF_DR
operator|&
operator|~
name|VIFF_QUERIER
operator|&
operator|~
name|VIFF_NONBRS
operator|)
operator||
name|VIFF_DOWN
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|MIFF_REGISTER
operator|)
condition|)
block|{
name|RESET_TIMER
argument_list|(
name|v
operator|->
name|uv_pim_hello_timer
argument_list|)
expr_stmt|;
name|RESET_TIMER
argument_list|(
name|v
operator|->
name|uv_jp_timer
argument_list|)
expr_stmt|;
name|RESET_TIMER
argument_list|(
name|v
operator|->
name|uv_gq_timer
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|v
operator|->
name|uv_pim_neighbors
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|next
control|)
block|{
name|next
operator|=
name|n
operator|->
name|next
expr_stmt|;
comment|/* Free the space for each neighbour */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|n
argument_list|)
expr_stmt|;
block|}
name|v
operator|->
name|uv_pim_neighbors
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* TODO: currently not used */
comment|/* The Access Control List (list with the scoped addresses) */
while|while
condition|(
name|v
operator|->
name|uv_acl
operator|!=
name|NULL
condition|)
block|{
name|acl
operator|=
name|v
operator|->
name|uv_acl
expr_stmt|;
name|v
operator|->
name|uv_acl
operator|=
name|acl
operator|->
name|acl_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|acl
argument_list|)
expr_stmt|;
block|}
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_IF
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s goes down , vif #%u out of service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the register vif in the multicast routing daemon and the  * kernel because the interface used initially to get its local address  * is DOWN. register_vifi is the index to the Register vif which needs  * to be updated. As a result the Register vif has a new uv_lcl_addr and  * is UP (virtually :))  */
end_comment

begin_function
name|int
name|update_reg_vif
parameter_list|(
name|vifi_t
name|register_vifi
parameter_list|)
block|{
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
comment|/* Find the first useable vif with solid physical background */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|VIFF_TUNNEL
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
comment|/* Found. Stop the bogus Register vif first */
name|stop_vif
argument_list|(
name|register_vifi
argument_list|)
expr_stmt|;
name|uvifs
index|[
name|register_vifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
operator|=
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
expr_stmt|;
name|start_vif
argument_list|(
name|register_vifi
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_REGISTER | DEBUG_IF
argument_list|)
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"%s has come up; vif #%u now in service"
argument_list|,
name|uvifs
index|[
name|register_vifi
index|]
operator|.
name|uv_name
argument_list|,
name|register_vifi
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"Cannot start Register vif: %s"
argument_list|,
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return the max global Ipv6 address of an UP and ENABLED interface  * other than the MIFF_REGISTER interface. */
end_comment

begin_function
name|struct
name|sockaddr_in6
modifier|*
name|max_global_address
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|pmax
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
comment|/* 		 * take first the max global address of the interface 		 * (without link local) => aliasing 		 */
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
comment|/* 			 * If this is the first global address, take it anyway. 			 */
if|if
condition|(
name|pmax
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
condition|)
name|pmax
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inet6_lessthan
argument_list|(
operator|&
name|pmax
operator|->
name|pa_addr
argument_list|,
operator|&
name|p
operator|->
name|pa_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
condition|)
name|pmax
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|pmax
condition|?
operator|&
name|pmax
operator|->
name|pa_addr
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sockaddr_in6
modifier|*
name|uv_global
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
init|=
operator|&
name|uvifs
index|[
name|vifi
index|]
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
operator|&
name|p
operator|->
name|pa_addr
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the interface exists in the mif table. If true   * return the highest address of the interface else return NULL.  */
end_comment

begin_function
name|struct
name|sockaddr_in6
modifier|*
name|local_iface
parameter_list|(
name|char
modifier|*
name|ifname
parameter_list|)
block|{
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
name|struct
name|phaddr
modifier|*
name|pmax
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
if|if
condition|(
name|EQUAL
argument_list|(
name|v
operator|->
name|uv_name
argument_list|,
name|ifname
argument_list|)
condition|)
block|{
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|p
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 					 * If this is the first global address 					 * or larger than the current MAX global 					 * address, remember it. 					 */
if|if
condition|(
name|pmax
operator|==
name|NULL
operator|||
name|inet6_lessthan
argument_list|(
operator|&
name|pmax
operator|->
name|pa_addr
argument_list|,
operator|&
name|p
operator|->
name|pa_addr
argument_list|)
condition|)
name|pmax
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pmax
condition|)
return|return
operator|(
operator|&
name|pmax
operator|->
name|pa_addr
operator|)
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*    * See if any interfaces have changed from up state to down, or vice versa,  * including any non-multicast-capable interfaces that are in use as local  * tunnel end-points.  Ignore interfaces that have been administratively  * disabled.  */
end_comment

begin_function
name|void
name|check_vif_state
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
specifier|static
name|int
name|checking_vifs
init|=
literal|0
decl_stmt|;
comment|/*      * XXX: TODO: True only for DVMRP?? Check.      * If we get an error while checking, (e.g. two interfaces go down      * at once, and we decide to send a prune out one of the failed ones)      * then don't go into an infinite loop!      */
if|if
condition|(
name|checking_vifs
condition|)
return|return;
name|vifs_down
operator|=
name|FALSE
expr_stmt|;
name|checking_vifs
operator|=
name|TRUE
expr_stmt|;
comment|/* TODO: Check all potential interfaces!!! */
comment|/* Check the physical and tunnels only */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
comment|/* get the interface flags */
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"check_vif_state: ioctl SIOCGIFFLAGS for %s"
argument_list|,
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
condition|)
block|{
if|if
condition|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
condition|)
block|{
name|start_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
else|else
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"%s has gone down ; vif #%u taken out of  service"
argument_list|,
name|v
operator|->
name|uv_name
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|stop_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
name|vifs_down
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
comment|/* Check the register(s) vif(s) */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
specifier|register
name|vifi_t
name|vifi2
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v2
decl_stmt|;
name|int
name|found
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
else|else
block|{
name|found
operator|=
literal|0
expr_stmt|;
comment|/* Find a physical vif with the same IP address as the 	     * Register vif. 	     */
for|for
control|(
name|vifi2
operator|=
literal|0
operator|,
name|v2
operator|=
name|uvifs
init|;
name|vifi2
operator|<
name|numvifs
condition|;
operator|++
name|vifi2
operator|,
operator|++
name|v2
control|)
block|{
if|if
condition|(
name|v2
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|VIFF_TUNNEL
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|,
operator|&
name|v2
operator|->
name|uv_linklocal
operator|->
name|pa_addr
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
comment|/* The physical interface with the IP address as the Register 		 * vif is probably DOWN. Get a replacement. 		 */
name|update_reg_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
name|checking_vifs
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If the source is directly connected to us, find the vif number for  * the corresponding physical interface (tunnels excluded).  * Local addresses are excluded.  * Return the vif number or NO_VIF if not found.  */
end_comment

begin_function
name|vifi_t
name|find_vif_direct
parameter_list|(
name|src
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|VIFF_TUNNEL
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
name|inet6_equal
argument_list|(
name|src
argument_list|,
operator|&
name|p
operator|->
name|pa_addr
argument_list|)
condition|)
return|return
operator|(
name|NO_VIF
operator|)
return|;
if|if
condition|(
name|inet6_match_prefix
argument_list|(
name|src
argument_list|,
operator|&
name|p
operator|->
name|pa_prefix
argument_list|,
operator|&
name|p
operator|->
name|pa_subnetmask
argument_list|)
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NO_VIF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks if src is local address. If "yes" return the vif index,  * otherwise return value is NO_VIF.  */
end_comment

begin_function
name|vifi_t
name|local_address
parameter_list|(
name|src
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
name|inet6_equal
argument_list|(
name|src
argument_list|,
operator|&
name|p
operator|->
name|pa_addr
argument_list|)
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
block|}
comment|/* Returning NO_VIF means not a local address */
return|return
operator|(
name|NO_VIF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    * If the source is directly connected, or is local address,  * find the vif number for the corresponding physical interface  * (tunnels excluded).  * Return the vif number or NO_VIF if not found.  */
end_comment

begin_function
name|vifi_t
name|find_vif_direct_local
parameter_list|(
name|src
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
block|{
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|struct
name|phaddr
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|VIFF_TUNNEL
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
for|for
control|(
name|p
operator|=
name|v
operator|->
name|uv_addrs
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|pa_next
control|)
block|{
if|if
condition|(
name|inet6_equal
argument_list|(
name|src
argument_list|,
operator|&
name|p
operator|->
name|pa_addr
argument_list|)
operator|||
name|inet6_match_prefix
argument_list|(
name|src
argument_list|,
operator|&
name|p
operator|->
name|pa_prefix
argument_list|,
operator|&
name|p
operator|->
name|pa_subnetmask
argument_list|)
condition|)
return|return
operator|(
name|vifi
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NO_VIF
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vif_forwarder
parameter_list|(
name|if_set
modifier|*
name|p1
parameter_list|,
name|if_set
modifier|*
name|p2
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|p1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|p1
operator|->
name|ifs_bits
index|[
name|idx
index|]
operator|&
name|p2
operator|->
name|ifs_bits
index|[
name|idx
index|]
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* (p1& p2) is empty. We're not the forwarder */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|if_set
modifier|*
name|vif_and
parameter_list|(
name|if_set
modifier|*
name|p1
parameter_list|,
name|if_set
modifier|*
name|p2
parameter_list|,
name|if_set
modifier|*
name|result
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|IF_ZERO
argument_list|(
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|p1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
condition|;
name|idx
operator|++
control|)
block|{
name|result
operator|->
name|ifs_bits
index|[
name|idx
index|]
operator|=
name|p1
operator|->
name|ifs_bits
index|[
name|idx
index|]
operator|&
name|p2
operator|->
name|ifs_bits
index|[
name|idx
index|]
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|if_set
modifier|*
name|vif_xor
parameter_list|(
name|if_set
modifier|*
name|p1
parameter_list|,
name|if_set
modifier|*
name|p2
parameter_list|,
name|if_set
modifier|*
name|result
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|IF_ZERO
argument_list|(
name|result
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|p1
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
condition|;
name|idx
operator|++
control|)
block|{
name|result
operator|->
name|ifs_bits
index|[
name|idx
index|]
operator|=
name|p1
operator|->
name|ifs_bits
index|[
name|idx
index|]
operator|^
name|p2
operator|->
name|ifs_bits
index|[
name|idx
index|]
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    * stop all vifs  */
end_comment

begin_function
name|void
name|stop_all_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DOWN
operator|)
condition|)
block|{
name|stop_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|struct
name|uvif
modifier|*
name|find_vif
parameter_list|(
name|ifname
parameter_list|)
name|char
modifier|*
name|ifname
decl_stmt|;
block|{
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|v
operator|->
name|uv_name
argument_list|,
name|ifname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|v
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

