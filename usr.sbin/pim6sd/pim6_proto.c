begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1999 LSIIT Laboratory.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (C) 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  Copyright (c) 1998 by the University of Southern California.  *  All rights reserved.  *  *  Permission to use, copy, modify, and distribute this software and  *  its documentation in source and binary forms for lawful  *  purposes and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both  *  the copyright notice and this permission notice appear in supporting  *  documentation, and that any documentation, advertising materials,  *  and other materials related to such distribution and use acknowledge  *  that the software was developed by the University of Southern  *  California and/or Information Sciences Institute.  *  The name of the University of Southern California may not  *  be used to endorse or promote products derived from this software  *  without specific prior written permission.  *  *  THE UNIVERSITY OF SOUTHERN CALIFORNIA DOES NOT MAKE ANY REPRESENTATIONS  *  ABOUT THE SUITABILITY OF THIS SOFTWARE FOR ANY PURPOSE.  THIS SOFTWARE IS  *  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  *  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND  *  NON-INFRINGEMENT.  *  *  IN NO EVENT SHALL USC, OR ANY OTHER CONTRIBUTOR BE LIABLE FOR ANY  *  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, WHETHER IN CONTRACT,  *  TORT, OR OTHER FORM OF ACTION, ARISING OUT OF OR IN CONNECTION WITH,  *  THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *  Other copyrights might apply to parts of this software and are so  *  noted when applicable.  */
end_comment

begin_comment
comment|/*  *  Questions concerning this software should be directed to  *  Mickael Hoerdt (hoerdt@clarinet.u-strasbg.fr) LSIIT Strasbourg.  *  */
end_comment

begin_comment
comment|/*  * This program has been derived from pim6dd.          * The pim6dd program is covered by the license in the accompanying file  * named "LICENSE.pim6dd".  */
end_comment

begin_comment
comment|/*  * This program has been derived from pimd.          * The pimd program is covered by the license in the accompanying file  * named "LICENSE.pimd".  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/pim6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"mrt.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"vif.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"pim6.h"
end_include

begin_include
include|#
directive|include
file|"pim6_proto.h"
end_include

begin_include
include|#
directive|include
file|"pimd.h"
end_include

begin_include
include|#
directive|include
file|"rp.h"
end_include

begin_include
include|#
directive|include
file|"mld6.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_include
include|#
directive|include
file|"inet6.h"
end_include

begin_include
include|#
directive|include
file|"kern.h"
end_include

begin_include
include|#
directive|include
file|"routesock.h"
end_include

begin_comment
comment|/*  * Local functions definitions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|parse_pim6_hello
name|__P
argument_list|(
operator|(
name|char
operator|*
name|pktPtr
operator|,
name|int
name|datalen
operator|,
expr|struct
name|sockaddr_in6
operator|*
name|src
operator|,
name|u_int16
operator|*
name|holdtime
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|send_pim6_register_stop
name|__P
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
name|reg_src
operator|,
expr|struct
name|sockaddr_in6
operator|*
name|reg_dst
operator|,
expr|struct
name|sockaddr_in6
operator|*
name|inner_source
operator|,
expr|struct
name|sockaddr_in6
operator|*
name|inner_grp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|build_jp_message_t
modifier|*
name|get_jp6_working_buff
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|return_jp6_working_buff
name|__P
argument_list|(
operator|(
name|pim_nbr_entry_t
operator|*
name|pim_nbr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pack_jp6_message
name|__P
argument_list|(
operator|(
name|pim_nbr_entry_t
operator|*
name|pim_nbr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_jp6_message
name|__P
argument_list|(
operator|(
name|pim_nbr_entry_t
operator|*
name|pim_nbr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compare_metrics
name|__P
argument_list|(
operator|(
name|u_int32
name|local_preference
operator|,
name|u_int32
name|local_metric
operator|,
expr|struct
name|sockaddr_in6
operator|*
name|local_address
operator|,
name|u_int32
name|remote_preference
operator|,
name|u_int32
name|remote_metric
operator|,
expr|struct
name|sockaddr_in6
operator|*
name|remote_address
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|build_jp_message_t
modifier|*
name|build_jp_message_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|build_jp_message_pool_counter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in6
name|sockaddr6_any
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
block|,
name|AF_INET6
block|,
literal|0
block|,
literal|0
block|,
name|IN6ADDR_ANY_INIT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in6
name|sockaddr6_d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pim6dstat
name|pim6dstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************  *                        PIM_HELLO  ************************************************************************/
end_comment

begin_function
name|int
name|receive_pim6_hello
parameter_list|(
name|src
parameter_list|,
name|pim_message
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
specifier|register
name|char
modifier|*
name|pim_message
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|mifi_t
name|mifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|pim_nbr_entry_t
modifier|*
name|nbr
decl_stmt|,
modifier|*
name|prev_nbr
decl_stmt|,
modifier|*
name|new_nbr
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
name|int
name|bsr_length
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|srcentry_t
modifier|*
name|srcentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
if|if
condition|(
operator|(
name|mifi
operator|=
name|find_vif_direct
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
comment|/* 	 * Either a local vif or somehow received PIM_HELLO from non-directly 	 * connected router. Ignore it. 	 */
if|if
condition|(
name|local_address
argument_list|(
name|src
argument_list|)
operator|==
name|NO_VIF
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Ignoring PIM_HELLO from non-neighbor router %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|mifi
index|]
expr_stmt|;
name|v
operator|->
name|uv_in_pim6_hello
operator|++
expr_stmt|;
comment|/* increment statistacs */
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator||
name|MIFF_REGISTER
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Shoudn't come on this interface */
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the Holdtime (in seconds) from the message. Return if error. */
if|if
condition|(
name|parse_pim6_hello
argument_list|(
name|pim_message
argument_list|,
name|datalen
argument_list|,
name|src
argument_list|,
operator|&
name|holdtime
argument_list|)
operator|==
name|FALSE
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_HELLO | DEBUG_PIM_TIMER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"PIM HELLO holdtime from %s is %u"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
for|for
control|(
name|prev_nbr
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
operator|,
name|nbr
operator|=
name|v
operator|->
name|uv_pim_neighbors
init|;
name|nbr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|;
name|prev_nbr
operator|=
name|nbr
operator|,
name|nbr
operator|=
name|nbr
operator|->
name|next
control|)
block|{
comment|/* 	 * The PIM neighbors are sorted in decreasing order of the network 	 * addresses (note that to be able to compare them correctly we must 	 * translate the addresses in host order. 	 */
if|if
condition|(
name|inet6_lessthan
argument_list|(
name|src
argument_list|,
operator|&
name|nbr
operator|->
name|address
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|inet6_equal
argument_list|(
name|src
argument_list|,
operator|&
name|nbr
operator|->
name|address
argument_list|)
condition|)
block|{
comment|/* We already have an entry for this host */
if|if
condition|(
literal|0
operator|==
name|holdtime
condition|)
block|{
comment|/* 		 * Looks like we have a nice neighbor who is going down and 		 * wants to inform us by sending "holdtime=0". Thanks buddy 		 * and see you again! 		 */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"PIM HELLO received: neighbor %s going down"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|delete_pim6_nbr
argument_list|(
name|nbr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|SET_TIMER
argument_list|(
name|nbr
operator|->
name|timer
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
comment|/* 	     * No entry for this neighbor. Exit the loop and create an entry 	     * for it. 	     */
break|break;
block|}
comment|/*      * This is a new neighbor. Create a new entry for it. It must be added      * right after `prev_nbr`      */
name|new_nbr
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pim_nbr_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|new_nbr
operator|->
name|address
operator|=
operator|*
name|src
expr_stmt|;
name|new_nbr
operator|->
name|vifi
operator|=
name|mifi
expr_stmt|;
name|SET_TIMER
argument_list|(
name|new_nbr
operator|->
name|timer
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
name|new_nbr
operator|->
name|build_jp_message
operator|=
operator|(
name|build_jp_message_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|new_nbr
operator|->
name|next
operator|=
name|nbr
expr_stmt|;
name|new_nbr
operator|->
name|prev
operator|=
name|prev_nbr
expr_stmt|;
if|if
condition|(
name|prev_nbr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
name|prev_nbr
operator|->
name|next
operator|=
name|new_nbr
expr_stmt|;
else|else
name|v
operator|->
name|uv_pim_neighbors
operator|=
name|new_nbr
expr_stmt|;
if|if
condition|(
name|new_nbr
operator|->
name|next
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
name|new_nbr
operator|->
name|next
operator|->
name|prev
operator|=
name|new_nbr
expr_stmt|;
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_NONBRS
expr_stmt|;
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_PIM_NBR
expr_stmt|;
comment|/* Since a new neighbour has come up, let it know your existence */
comment|/*      * XXX: TODO: not in the spec, but probably should send the message after      * a short random period?      */
name|send_pim6_hello
argument_list|(
name|v
argument_list|,
name|pim_hello_holdtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DR
condition|)
block|{
comment|/* 	 * If I am the current DR on that interface, so send an RP-Set 	 * message to the new neighbor. 	 */
if|if
condition|(
operator|(
name|bsr_length
operator|=
name|create_pim6_bootstrap_message
argument_list|(
name|pim6_send_buf
argument_list|)
operator|)
condition|)
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
name|src
argument_list|,
name|PIM_BOOTSTRAP
argument_list|,
name|bsr_length
argument_list|)
expr_stmt|;
comment|/* The router with highest network address is the elected DR */
if|if
condition|(
name|inet6_lessthan
argument_list|(
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|v
operator|->
name|uv_pim_neighbors
operator|->
name|address
argument_list|)
condition|)
block|{
comment|/* 	     * I was the DR, but not anymore. Remove all register_vif from 	     * oif list for all directly connected sources (for vifi). 	     */
comment|/* TODO: XXX: first entry is not used! */
for|for
control|(
name|srcentry_ptr
operator|=
name|srclist
operator|->
name|next
init|;
name|srcentry_ptr
operator|!=
operator|(
name|srcentry_t
operator|*
operator|)
name|NULL
condition|;
name|srcentry_ptr
operator|=
name|srcentry_ptr
operator|->
name|next
control|)
block|{
comment|/* If not directly connected source for vifi */
if|if
condition|(
operator|(
name|srcentry_ptr
operator|->
name|incoming
operator|!=
name|mifi
operator|)
operator|||
operator|(
name|srcentry_ptr
operator|->
name|upstream
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
operator|)
condition|)
continue|continue;
for|for
control|(
name|mrtentry_ptr
operator|=
name|srcentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|srcnext
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SG
operator|)
condition|)
continue|continue;
comment|/* This is not (S,G) entry */
comment|/* Remove the register oif */
name|IF_CLR
argument_list|(
name|reg_vif_num
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_DR
expr_stmt|;
block|}
block|}
comment|/*      * TODO: XXX: does a new neighbor change any routing entries info? Need      * to trigger joins?      */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_HELLO
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"I'have got a new neighbor %s on vif %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|v
operator|->
name|uv_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|delete_pim6_nbr
parameter_list|(
name|nbr_delete
parameter_list|)
name|pim_nbr_entry_t
modifier|*
name|nbr_delete
decl_stmt|;
block|{
name|srcentry_t
modifier|*
name|srcentry_ptr
decl_stmt|;
name|srcentry_t
modifier|*
name|srcentry_ptr_next
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_srcs
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|;
name|pim_nbr_entry_t
modifier|*
name|new_nbr
decl_stmt|;
name|cand_rp_t
modifier|*
name|cand_rp_ptr
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_ptr
decl_stmt|;
name|rpentry_t
modifier|*
name|rpentry_ptr
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|v
operator|=
operator|&
name|uvifs
index|[
name|nbr_delete
operator|->
name|vifi
index|]
expr_stmt|;
comment|/* Delete the entry from the pim_nbrs chain */
if|if
condition|(
name|nbr_delete
operator|->
name|prev
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
name|nbr_delete
operator|->
name|prev
operator|->
name|next
operator|=
name|nbr_delete
operator|->
name|next
expr_stmt|;
else|else
name|v
operator|->
name|uv_pim_neighbors
operator|=
name|nbr_delete
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|nbr_delete
operator|->
name|next
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
name|nbr_delete
operator|->
name|next
operator|->
name|prev
operator|=
name|nbr_delete
operator|->
name|prev
expr_stmt|;
name|return_jp6_working_buff
argument_list|(
name|nbr_delete
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_pim_neighbors
operator|==
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* This was our last neighbor. */
name|v
operator|->
name|uv_flags
operator|&=
operator|~
name|VIFF_PIM_NBR
expr_stmt|;
name|v
operator|->
name|uv_flags
operator||=
operator|(
name|VIFF_NONBRS
operator||
name|VIFF_DR
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inet6_greaterthan
argument_list|(
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|v
operator|->
name|uv_pim_neighbors
operator|->
name|address
argument_list|)
condition|)
comment|/* 	     * The first address is the new potential remote DR address, but 	     * the local address is the winner. 	     */
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_DR
expr_stmt|;
block|}
comment|/* Update the source entries */
for|for
control|(
name|srcentry_ptr
operator|=
name|srclist
init|;
name|srcentry_ptr
operator|!=
operator|(
name|srcentry_t
operator|*
operator|)
name|NULL
condition|;
name|srcentry_ptr
operator|=
name|srcentry_ptr_next
control|)
block|{
name|srcentry_ptr_next
operator|=
name|srcentry_ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|srcentry_ptr
operator|->
name|upstream
operator|!=
name|nbr_delete
condition|)
continue|continue;
comment|/* Reset the next hop (PIM) router */
if|if
condition|(
name|set_incoming
argument_list|(
name|srcentry_ptr
argument_list|,
name|PIM_IIF_SOURCE
argument_list|)
operator|==
name|FALSE
condition|)
block|{
comment|/* 	     * Coudn't reset it. Sorry, the hext hop router toward that 	     * source is probably not a PIM router, or cannot find route at 	     * all, hence I cannot handle this source and have to delete it. 	     */
name|delete_srcentry
argument_list|(
name|srcentry_ptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|srcentry_ptr
operator|->
name|upstream
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* Ignore the local or directly connected sources */
comment|/* 		 * Browse all MRT entries for this source and reset the 		 * upstream router. Note that the upstream router is not 		 * always toward the source: it could be toward the RP for 		 * example. 		 */
name|new_nbr
operator|=
name|srcentry_ptr
operator|->
name|upstream
expr_stmt|;
for|for
control|(
name|mrtentry_ptr
operator|=
name|srcentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|srcnext
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
operator|)
condition|)
block|{
name|mrtentry_ptr
operator|->
name|upstream
operator|=
name|srcentry_ptr
operator|->
name|upstream
expr_stmt|;
name|mrtentry_ptr
operator|->
name|metric
operator|=
name|srcentry_ptr
operator|->
name|metric
expr_stmt|;
name|mrtentry_ptr
operator|->
name|preference
operator|=
name|srcentry_ptr
operator|->
name|preference
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|srcentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Update the RP entries */
for|for
control|(
name|cand_rp_ptr
operator|=
name|cand_rp_list
init|;
name|cand_rp_ptr
operator|!=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|;
name|cand_rp_ptr
operator|=
name|cand_rp_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|upstream
operator|!=
name|nbr_delete
condition|)
continue|continue;
name|rpentry_ptr
operator|=
name|cand_rp_ptr
operator|->
name|rpentry
expr_stmt|;
comment|/* Reset the RP entry iif */
comment|/* TODO: check if error setting the iif! */
if|if
condition|(
name|local_address
argument_list|(
operator|&
name|rpentry_ptr
operator|->
name|address
argument_list|)
operator|==
name|NO_VIF
condition|)
block|{
name|set_incoming
argument_list|(
name|rpentry_ptr
argument_list|,
name|PIM_IIF_RP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rpentry_ptr
operator|->
name|incoming
operator|=
name|reg_vif_num
expr_stmt|;
name|rpentry_ptr
operator|->
name|upstream
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|mrtentry_ptr
operator|=
name|rpentry_ptr
operator|->
name|mrtlink
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|mrtentry_ptr
operator|->
name|upstream
operator|=
name|rpentry_ptr
operator|->
name|upstream
expr_stmt|;
name|mrtentry_ptr
operator|->
name|metric
operator|=
name|rpentry_ptr
operator|->
name|metric
expr_stmt|;
name|mrtentry_ptr
operator|->
name|preference
operator|=
name|rpentry_ptr
operator|->
name|preference
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|rpentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Update the group entries for this RP */
for|for
control|(
name|rp_grp_entry_ptr
operator|=
name|cand_rp_ptr
operator|->
name|rp_grp_next
init|;
name|rp_grp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|rp_grp_entry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|rp_grp_next
control|)
block|{
for|for
control|(
name|grpentry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|grplink
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|rpnext
control|)
block|{
name|mrtentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|grp_route
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|mrtentry_ptr
operator|->
name|upstream
operator|=
name|rpentry_ptr
operator|->
name|upstream
expr_stmt|;
name|mrtentry_ptr
operator|->
name|metric
operator|=
name|rpentry_ptr
operator|->
name|metric
expr_stmt|;
name|mrtentry_ptr
operator|->
name|preference
operator|=
name|rpentry_ptr
operator|->
name|preference
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|rpentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Update only the (S,G)RPbit entries for this group */
for|for
control|(
name|mrtentry_srcs
operator|=
name|grpentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
control|)
block|{
if|if
condition|(
name|mrtentry_srcs
operator|->
name|flags
operator|&
name|MRTF_RP
condition|)
block|{
name|mrtentry_ptr
operator|->
name|upstream
operator|=
name|rpentry_ptr
operator|->
name|upstream
expr_stmt|;
name|mrtentry_ptr
operator|->
name|metric
operator|=
name|rpentry_ptr
operator|->
name|metric
expr_stmt|;
name|mrtentry_ptr
operator|->
name|preference
operator|=
name|rpentry_ptr
operator|->
name|preference
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|rpentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nbr_delete
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TODO: simplify it! */
end_comment

begin_function
specifier|static
name|int
name|parse_pim6_hello
parameter_list|(
name|pim_message
parameter_list|,
name|datalen
parameter_list|,
name|src
parameter_list|,
name|holdtime
parameter_list|)
name|char
modifier|*
name|pim_message
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
name|u_int16
modifier|*
name|holdtime
decl_stmt|;
block|{
name|u_int8
modifier|*
name|pim_hello_message
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|u_int16
name|option_type
decl_stmt|;
name|u_int16
name|option_length
decl_stmt|;
name|int
name|holdtime_received_ok
init|=
name|FALSE
decl_stmt|;
name|int
name|option_total_length
decl_stmt|;
name|pim_hello_message
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
name|datalen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|datalen
operator|>=
sizeof|sizeof
argument_list|(
name|pim_hello_t
argument_list|)
condition|;
control|)
block|{
comment|/* Ignore any data if shorter than (pim_hello header) */
name|data_ptr
operator|=
name|pim_hello_message
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|option_type
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|option_length
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|option_type
condition|)
block|{
case|case
name|PIM_MESSAGE_HELLO_HOLDTIME
case|:
if|if
condition|(
name|PIM_MESSAGE_HELLO_HOLDTIME_LENGTH
operator|!=
name|option_length
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_HELLO
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"PIM HELLO Holdtime from %s: invalid OptionLength = %u"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|option_length
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|GET_HOSTSHORT
argument_list|(
operator|*
name|holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|holdtime_received_ok
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
comment|/* Ignore any unknown options */
break|break;
block|}
comment|/* Move to the next option */
comment|/* 	 * XXX: TODO: If we are padding to the end of the 32 bit boundary, 	 * use the first method to move to the next option, otherwise simply 	 * (sizeof(pim_hello_t) + option_length). 	 */
ifdef|#
directive|ifdef
name|BOUNDARY_32_BIT
name|option_total_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|pim_hello_t
argument_list|)
operator|+
operator|(
name|option_length
operator|&
operator|~
literal|0x3
operator|)
operator|+
operator|(
operator|(
name|option_length
operator|&
literal|0x3
operator|)
condition|?
literal|4
else|:
literal|0
operator|)
operator|)
expr_stmt|;
else|#
directive|else
name|option_total_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|pim_hello_t
argument_list|)
operator|+
name|option_length
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* BOUNDARY_32_BIT */
name|datalen
operator|-=
name|option_total_length
expr_stmt|;
name|pim_hello_message
operator|+=
name|option_total_length
expr_stmt|;
block|}
return|return
operator|(
name|holdtime_received_ok
operator|)
return|;
block|}
end_function

begin_function
name|int
name|send_pim6_hello
parameter_list|(
name|v
parameter_list|,
name|holdtime
parameter_list|)
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|buf
operator|=
name|pim6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
name|buf
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|PIM_MESSAGE_HELLO_HOLDTIME
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|PIM_MESSAGE_HELLO_HOLDTIME_LENGTH
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|data_ptr
operator|-
operator|(
name|u_int8
operator|*
operator|)
name|buf
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|allpim6routers_group
argument_list|,
name|PIM_HELLO
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|v
operator|->
name|uv_pim_hello_timer
argument_list|,
name|pim_hello_period
argument_list|)
expr_stmt|;
name|v
operator|->
name|uv_out_pim6_hello
operator|++
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  *                        PIM_REGISTER  ************************************************************************/
end_comment

begin_comment
comment|/*  * TODO: XXX: IF THE BORDER BIT IS SET, THEN FORWARD THE WHOLE PACKET FROM  * USER SPACE AND AT THE SAME TIME IGNORE ANY CACHE_MISS SIGNALS FROM THE  * KERNEL.  */
end_comment

begin_function
name|int
name|receive_pim6_register
parameter_list|(
name|reg_src
parameter_list|,
name|reg_dst
parameter_list|,
name|pim_message
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|reg_src
decl_stmt|,
decl|*
name|reg_dst
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|pim_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sockaddr_in6
name|inner_src
decl_stmt|,
name|inner_grp
decl_stmt|;
name|pim_register_t
modifier|*
name|register_p
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip
decl_stmt|;
name|u_int32
name|borderBit
decl_stmt|,
name|nullRegisterBit
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr2
decl_stmt|;
name|if_set
name|oifs
decl_stmt|;
name|pim6dstat
operator|.
name|in_pim6_register
operator|++
expr_stmt|;
name|register_p
operator|=
operator|(
name|pim_register_t
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
name|borderBit
operator|=
name|ntohl
argument_list|(
name|register_p
operator|->
name|reg_flags
argument_list|)
operator|&
name|PIM_MESSAGE_REGISTER_BORDER_BIT
expr_stmt|;
name|nullRegisterBit
operator|=
name|ntohl
argument_list|(
name|register_p
operator|->
name|reg_flags
argument_list|)
operator|&
name|PIM_MESSAGE_REGISTER_NULL_REGISTER_BIT
expr_stmt|;
comment|/* initialize the pointer to the encapsulated packet */
name|ip
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|register_p
operator|+
literal|1
operator|)
expr_stmt|;
comment|/*      * We are keeping all addresses in network order,      * so no need for byte order translation.      */
name|inner_src
operator|.
name|sin6_addr
operator|=
name|ip
operator|->
name|ip6_src
expr_stmt|;
name|inner_grp
operator|.
name|sin6_addr
operator|=
name|ip
operator|->
name|ip6_dst
expr_stmt|;
comment|/* scope validation of the inner source and destination addresses */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|ip
operator|->
name|ip6_src
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_register: inner source(%s) has invalid scope"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|ip
operator|->
name|ip6_src
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
condition|)
name|inner_src
operator|.
name|sin6_scope_id
operator|=
name|addr2scopeid
argument_list|(
operator|&
name|ip
operator|->
name|ip6_src
argument_list|,
operator|&
name|ip
operator|->
name|ip6_dst
argument_list|,
name|reg_src
argument_list|,
name|reg_dst
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|inner_src
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MC_NODELOCAL
argument_list|(
operator|&
name|ip
operator|->
name|ip6_dst
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|ip
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_register: inner group(%s) has invalid scope"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|ip
operator|->
name|ip6_dst
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* XXX: can we discard it? */
block|}
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|IN6_IS_ADDR_MC_SITELOCAL
argument_list|(
operator|&
name|ip
operator|->
name|ip6_dst
argument_list|)
condition|)
name|inner_grp
operator|.
name|sin6_scope_id
operator|=
name|addr2scopeid
argument_list|(
operator|&
name|ip
operator|->
name|ip6_src
argument_list|,
operator|&
name|ip
operator|->
name|ip6_dst
argument_list|,
name|reg_src
argument_list|,
name|reg_dst
argument_list|)
expr_stmt|;
else|else
name|inner_grp
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|inner_grp
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|inner_src
argument_list|,
operator|&
name|inner_grp
argument_list|,
name|MRTF_SG
operator||
name|MRTF_WC
operator||
name|MRTF_PMBR
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* No routing entry. Send REGISTER_STOP and return. */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_REGISTER
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"No routing entry for source %s and/or group %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|inner_src
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|inner_grp
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO: XXX: shouldn't be inner_src=IN6ADDR_ANY? Not in the spec. */
name|send_pim6_register_stop
argument_list|(
name|reg_dst
argument_list|,
name|reg_src
argument_list|,
operator|&
name|inner_grp
argument_list|,
operator|&
name|inner_src
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* XXX: not in the spec: check if I am the RP for that group */
if|if
condition|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|my_cand_rp_address
argument_list|,
name|reg_dst
argument_list|)
operator|||
operator|(
name|check_mrtentry_rp
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|my_cand_rp_address
argument_list|)
operator|==
name|FALSE
operator|)
condition|)
block|{
name|send_pim6_register_stop
argument_list|(
name|reg_dst
argument_list|,
name|reg_src
argument_list|,
operator|&
name|inner_grp
argument_list|,
operator|&
name|inner_src
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SG
condition|)
block|{
comment|/* (S,G) found */
comment|/* TODO: check the timer again */
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|pim_data_timeout
argument_list|)
expr_stmt|;
comment|/* restart timer */
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SPT
operator|)
condition|)
block|{
comment|/* The SPT bit is not set */
if|if
condition|(
operator|!
name|nullRegisterBit
condition|)
block|{
name|calc_oifs
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|oifs
argument_list|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|incoming
operator|==
name|reg_vif_num
operator|)
condition|)
block|{
name|send_pim6_register_stop
argument_list|(
name|reg_dst
argument_list|,
name|reg_src
argument_list|,
operator|&
name|inner_grp
argument_list|,
operator|&
name|inner_src
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* 		 * TODO: XXX: BUG!!! The data will be forwarded by the kernel 		 * MFC!!! Need to set a special flag for this routing entry 		 * so after a cache miss occur, the multicast packet will be 		 * forwarded from user space and won't install entry in the 		 * kernel MFC. The problem is that the kernel MFC doesn't 		 * know the PMBR address and simply sets the multicast 		 * forwarding cache to accept/forward all data coming from 		 * the register_vif. 		 */
if|if
condition|(
name|borderBit
condition|)
block|{
if|if
condition|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|pmbr_addr
argument_list|,
name|reg_src
argument_list|)
condition|)
block|{
name|send_pim6_register_stop
argument_list|(
name|reg_dst
argument_list|,
name|reg_src
argument_list|,
operator|&
name|inner_grp
argument_list|,
operator|&
name|inner_src
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* TODO: XXX: if NULL_REGISTER and has (S,G) with SPT=0, then..? */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
comment|/* The SPT bit is set */
name|send_pim6_register_stop
argument_list|(
name|reg_dst
argument_list|,
name|reg_src
argument_list|,
operator|&
name|inner_grp
argument_list|,
operator|&
name|inner_src
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
operator|(
name|MRTF_WC
operator||
name|MRTF_PMBR
operator|)
condition|)
block|{
if|if
condition|(
name|borderBit
condition|)
block|{
comment|/* 	     * Create (S,G) state. The oifs will be the copied from the 	     * existing (*,G) or (*,*,RP) entry. 	     */
name|mrtentry_ptr2
operator|=
name|find_route
argument_list|(
operator|&
name|inner_src
argument_list|,
operator|&
name|inner_grp
argument_list|,
name|MRTF_SG
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr2
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|mrtentry_ptr2
operator|->
name|pmbr_addr
operator|=
operator|*
name|reg_src
expr_stmt|;
comment|/* Clear the SPT flag */
name|mrtentry_ptr2
operator|->
name|flags
operator|&=
operator|~
operator|(
name|MRTF_SPT
operator||
name|MRTF_NEW
operator|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|mrtentry_ptr2
operator|->
name|timer
argument_list|,
name|pim_data_timeout
argument_list|)
expr_stmt|;
comment|/* TODO: explicitly call the Join/Prune send function? */
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr2
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
comment|/* Send the Join 							 * immediately */
comment|/* 		 * TODO: explicitly call this function? 		 * send_pim6_join_prune(mrtentry_ptr2->upstream->vifi, 		 * mrtentry_ptr2->upstream, pim_join_prune_holdtime); 		 */
block|}
block|}
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_WC
condition|)
block|{
comment|/* (*,G) entry */
name|calc_oifs
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|oifs
argument_list|)
condition|)
block|{
name|send_pim6_register_stop
argument_list|(
name|reg_dst
argument_list|,
name|reg_src
argument_list|,
operator|&
name|inner_grp
argument_list|,
operator|&
name|sockaddr6_any
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* XXX: TODO: check with the spec again */
else|else
block|{
if|if
condition|(
operator|!
name|nullRegisterBit
condition|)
block|{
comment|/* Install cache entry in the kernel */
comment|/* 		 * TODO: XXX: probably redundant here, because the 		 * decapsulated mcast packet in the kernel will result in 		 * CACHE_MISS 		 */
name|struct
name|sockaddr_in6
modifier|*
name|mfc_source
init|=
operator|&
name|inner_src
decl_stmt|;
ifdef|#
directive|ifdef
name|KERNEL_MFC_WC_G
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_MFC_CLONE_SG
operator|)
condition|)
name|mfc_source
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* KERNEL_MFC_WC_G */
name|add_kernel_cache
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mfc_source
argument_list|,
operator|&
name|inner_grp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|k_chg_mfc
argument_list|(
name|mld6_socket
argument_list|,
name|mfc_source
argument_list|,
operator|&
name|inner_grp
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|rpaddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_PMBR
condition|)
block|{
comment|/* (*,*,RP) entry */
if|if
condition|(
operator|!
name|nullRegisterBit
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|mfc_source
init|=
operator|&
name|inner_src
decl_stmt|;
comment|/* 	     * XXX: have to create either (S,G) or (*,G). The choice below is 	     * (*,G) 	     */
name|mrtentry_ptr2
operator|=
name|find_route
argument_list|(
name|NULL
argument_list|,
operator|&
name|inner_grp
argument_list|,
name|MRTF_WC
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr2
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|mrtentry_ptr2
operator|->
name|flags
operator|&
name|MRTF_NEW
condition|)
block|{
comment|/* TODO: something else? Have the feeling sth is missing */
name|mrtentry_ptr2
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
comment|/* TODO: XXX: copy the timer from the (*,*,RP) entry? */
name|COPY_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|mrtentry_ptr2
operator|->
name|timer
argument_list|)
expr_stmt|;
block|}
comment|/* Install cache entry in the kernel */
ifdef|#
directive|ifdef
name|KERNEL_MFC_WC_G
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_MFC_CLONE_SG
operator|)
condition|)
name|mfc_source
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* KERNEL_MFC_WC_G */
name|add_kernel_cache
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mfc_source
argument_list|,
operator|&
name|inner_grp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|k_chg_mfc
argument_list|(
name|mld6_socket
argument_list|,
name|mfc_source
argument_list|,
operator|&
name|inner_grp
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr2
operator|->
name|group
operator|->
name|rpaddr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
comment|/* Shoudn't happen: invalid routing entry? */
comment|/* XXX: TODO: shoudn't be inner_src=IN6ADDR_ANY? Not in the spec. */
name|send_pim6_register_stop
argument_list|(
name|reg_dst
argument_list|,
name|reg_src
argument_list|,
operator|&
name|inner_grp
argument_list|,
operator|&
name|inner_src
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_function
name|int
name|send_pim6_register
parameter_list|(
name|pkt
parameter_list|)
name|char
modifier|*
name|pkt
decl_stmt|;
block|{
specifier|register
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in6
name|source
init|=
block|{
sizeof|sizeof
argument_list|(
name|source
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in6
name|group
init|=
block|{
sizeof|sizeof
argument_list|(
name|group
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
name|rpentry_t
modifier|*
name|rpentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr2
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|reg_src
decl_stmt|,
modifier|*
name|reg_dst
decl_stmt|;
name|int
name|pktlen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|pkt
expr_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
if|if
condition|(
operator|(
name|mifi
operator|=
name|find_vif_direct_local
argument_list|(
operator|&
name|source
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_DR
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* I am not the DR for that subnet */
name|rpentry_ptr
operator|=
name|rp_match
argument_list|(
operator|&
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpentry_ptr
operator|==
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* No RP for this group */
if|if
condition|(
name|local_address
argument_list|(
operator|&
name|rpentry_ptr
operator|->
name|address
argument_list|)
operator|!=
name|NO_VIF
condition|)
comment|/* TODO: XXX: not sure it is working! */
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* I am the RP for this group */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Cannot create (S,G) state */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_NEW
condition|)
block|{
comment|/* A new entry */
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
name|RESET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|rs_timer
argument_list|)
expr_stmt|;
comment|/* Reset the 						 * Register-Suppression timer */
if|if
condition|(
operator|(
name|mrtentry_ptr2
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|grp_route
operator|)
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
name|mrtentry_ptr2
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|mrtlink
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr2
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr2
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
comment|/* Timeout the 							 * Join/Prune timer */
comment|/* 	     * TODO: explicitly call this function? 	     * send_pim6_join_prune(mrtentry_ptr2->upstream->vifi, 	     * mrtentry_ptr2->upstream, pim_join_prune_holdtime); 	     */
block|}
block|}
comment|/* Restart the (S,G) Entry-timer */
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|pim_data_timeout
argument_list|)
expr_stmt|;
name|IF_TIMER_NOT_SET
argument_list|(
argument|mrtentry_ptr->rs_timer
argument_list|)
block|{
comment|/* 	 * The Register-Suppression Timer is not running. Encapsulate the 	 * data and send to the RP. 	 */
name|buf
operator|=
name|pim6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|pim_register_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No flags set */
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|pim_register_t
argument_list|)
expr_stmt|;
comment|/* Copy the data packet at the back of the register packet */
comment|/* TODO: check pktlen. ntohs? */
name|pktlen
operator|=
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
name|pktlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
comment|/* XXX */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip6
argument_list|,
name|buf
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|pktlen
operator|+=
sizeof|sizeof
argument_list|(
name|pim_register_t
argument_list|)
expr_stmt|;
name|reg_src
operator|=
name|max_global_address
argument_list|()
expr_stmt|;
name|reg_dst
operator|=
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|rpaddr
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
name|reg_src
argument_list|,
name|reg_dst
argument_list|,
name|PIM_REGISTER
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|pim6dstat
operator|.
name|out_pim6_register
operator|++
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|send_pim6_null_register
parameter_list|(
name|mrtentry_ptr
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip
decl_stmt|;
name|pim_register_t
modifier|*
name|pim_register
decl_stmt|;
name|int
name|pktlen
init|=
literal|0
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|reg_source
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
comment|/* No directly connected source; no local address */
if|if
condition|(
operator|(
name|mifi
operator|=
name|find_vif_direct_local
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|pim_register
operator|=
operator|(
name|pim_register_t
operator|*
operator|)
operator|(
name|pim6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pim_register
argument_list|,
sizeof|sizeof
argument_list|(
name|pim_register_t
argument_list|)
argument_list|)
expr_stmt|;
name|pim_register
operator|->
name|reg_flags
operator|=
name|htonl
argument_list|(
name|pim_register
operator|->
name|reg_flags
operator||
name|PIM_MESSAGE_REGISTER_NULL_REGISTER_BIT
argument_list|)
expr_stmt|;
comment|/* include the dummy ip header */
name|ip
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|pim_register
operator|+
literal|1
operator|)
expr_stmt|;
name|ip
operator|->
name|ip6_plen
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip6_flow
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip6_vfc
operator|=
literal|0x60
expr_stmt|;
name|ip
operator|->
name|ip6_hlim
operator|=
name|MINHLIM
expr_stmt|;
name|ip
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_NONE
expr_stmt|;
name|ip
operator|->
name|ip6_src
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
operator|.
name|sin6_addr
expr_stmt|;
name|ip
operator|->
name|ip6_dst
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
operator|.
name|sin6_addr
expr_stmt|;
name|pktlen
operator|=
sizeof|sizeof
argument_list|(
name|pim_register_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|dest
operator|=
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|rpaddr
expr_stmt|;
name|reg_source
operator|=
name|max_global_address
argument_list|()
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
name|reg_source
argument_list|,
name|dest
argument_list|,
name|PIM_REGISTER
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|pim6dstat
operator|.
name|out_pim6_register
operator|++
expr_stmt|;
comment|/* should be counted separately? */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  *                        PIM_REGISTER_STOP  ************************************************************************/
end_comment

begin_function
name|int
name|receive_pim6_register_stop
parameter_list|(
name|reg_src
parameter_list|,
name|reg_dst
parameter_list|,
name|pim_message
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|reg_src
decl_stmt|,
decl|*
name|reg_dst
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|pim_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|pim_register_stop_t
modifier|*
name|pim_regstop_p
decl_stmt|;
name|pim6_encod_grp_addr_t
name|encod_grp
decl_stmt|;
name|pim6_encod_uni_addr_t
name|encod_unisrc
decl_stmt|;
name|struct
name|sockaddr_in6
name|source
decl_stmt|,
name|group
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|if_set
name|pruned_oifs
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|pim6dstat
operator|.
name|in_pim6_register_stop
operator|++
expr_stmt|;
name|pim_regstop_p
operator|=
operator|(
name|pim_register_stop_t
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|&
name|pim_regstop_p
operator|->
name|encod_grp
expr_stmt|;
name|GET_EGADDR6
argument_list|(
operator|&
name|encod_grp
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_EUADDR6
argument_list|(
operator|&
name|encod_unisrc
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|encod_grp
operator|.
name|mcast_addr
expr_stmt|;
comment|/* scope validation of the inner source and destination addresses */
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|IN6_IS_ADDR_MC_SITELOCAL
argument_list|(
operator|&
name|ip
operator|->
name|ip6_dst
argument_list|)
condition|)
name|group
operator|.
name|sin6_scope_id
operator|=
name|addr2scopeid
argument_list|(
operator|&
name|ip
operator|->
name|ip6_src
argument_list|,
operator|&
name|ip
operator|->
name|ip6_dst
argument_list|,
name|reg_src
argument_list|,
name|reg_dst
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|group
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_unisrc
operator|.
name|unicast_addr
expr_stmt|;
comment|/* the source address must be global...but is it always true? */
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
condition|)
name|source
operator|.
name|sin6_scope_id
operator|=
name|addr2scopeid
argument_list|(
operator|&
name|ip
operator|->
name|ip6_src
argument_list|,
operator|&
name|ip
operator|->
name|ip6_dst
argument_list|,
name|reg_src
argument_list|,
name|reg_dst
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|source
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|mifi
operator|=
name|find_vif_direct_local
argument_list|(
operator|&
name|source
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_REGISTER
argument_list|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"Received PIM_REGISTER_STOP from RP %s for a non "
literal|"direct-connect source %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|reg_src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|encod_unisrc
operator|.
name|unicast_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|mifi
index|]
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_REGISTER
argument_list|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Received PIM_REGISTER_STOP from RP %s to %s "
literal|"source : %s group : %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|reg_src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|reg_dst
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|encod_unisrc
operator|.
name|unicast_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|encod_grp
operator|.
name|mcast_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: apply the group mask and do register_stop for all grp addresses */
comment|/* TODO: check for SourceAddress == 0 */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/*      * XXX: not in the spec: check if the PIM_REGISTER_STOP originator is      * really the RP      */
if|if
condition|(
name|check_mrtentry_rp
argument_list|(
name|mrtentry_ptr
argument_list|,
name|reg_src
argument_list|)
operator|==
name|FALSE
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* restart the Register-Suppression timer */
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|rs_timer
argument_list|,
operator|(
literal|0.5
operator|*
name|pim_register_suppression_timeout
operator|)
operator|+
operator|(
name|RANDOM
argument_list|()
operator|%
operator|(
name|pim_register_suppression_timeout
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Prune the register_vif from the outgoing list */
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|reg_vif_num
argument_list|,
operator|&
name|pruned_oifs
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* TODO: optional rate limiting is not implemented yet */
end_comment

begin_comment
comment|/* Unicasts a REGISTER_STOP message to the DR */
end_comment

begin_function
specifier|static
name|int
name|send_pim6_register_stop
parameter_list|(
name|reg_src
parameter_list|,
name|reg_dst
parameter_list|,
name|inner_grp
parameter_list|,
name|inner_src
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|reg_src
decl_stmt|,
decl|*
name|reg_dst
decl_stmt|,
modifier|*
name|inner_grp
decl_stmt|,
modifier|*
name|inner_src
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|buf
operator|=
name|pim6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
name|buf
expr_stmt|;
name|PUT_EGADDR6
argument_list|(
name|inner_grp
operator|->
name|sin6_addr
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_EUADDR6
argument_list|(
name|inner_src
operator|->
name|sin6_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
name|reg_src
argument_list|,
name|reg_dst
argument_list|,
name|PIM_REGISTER_STOP
argument_list|,
name|data_ptr
operator|-
operator|(
name|u_int8
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|pim6dstat
operator|.
name|out_pim6_register_stop
operator|++
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/************************************************************************  *                        PIM_JOIN_PRUNE  ************************************************************************/
end_comment

begin_function
name|int
name|join_or_prune
parameter_list|(
name|mrtentry_ptr
parameter_list|,
name|upstream_router
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|pim_nbr_entry_t
modifier|*
name|upstream_router
decl_stmt|;
block|{
name|if_set
name|entry_oifs
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_grp
decl_stmt|;
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Join_or_prune : mrtentry_ptr is null"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PIM_ACTION_NOTHING
operator|)
return|;
block|}
if|if
condition|(
name|upstream_router
operator|==
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Join_or_prune : upstream_router is null"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PIM_ACTION_NOTHING
operator|)
return|;
block|}
name|calc_oifs
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|entry_oifs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
operator|(
name|MRTF_PMBR
operator||
name|MRTF_WC
operator|)
condition|)
block|{
comment|/* (*,*,RP) or (*,G) entry */
comment|/* The (*,*,RP) or (*,G) J/P messages are sent only toward the RP */
if|if
condition|(
name|upstream_router
operator|!=
name|mrtentry_ptr
operator|->
name|upstream
condition|)
return|return
operator|(
name|PIM_ACTION_NOTHING
operator|)
return|;
comment|/* TODO: XXX: Can we have (*,*,RP) prune? */
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|entry_oifs
argument_list|)
condition|)
block|{
comment|/* NULL oifs */
if|if
condition|(
operator|!
operator|(
name|uvifs
index|[
name|mrtentry_ptr
operator|->
name|incoming
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_DR
operator|)
condition|)
block|{
comment|/* I am not the DR for that subnet. */
return|return
operator|(
name|PIM_ACTION_PRUNE
operator|)
return|;
block|}
if|if
condition|(
name|IF_ISSET
argument_list|(
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|)
condition|)
comment|/* I am the DR and have local leaves */
return|return
operator|(
name|PIM_ACTION_JOIN
operator|)
return|;
comment|/* Probably the last local member hast timeout */
return|return
operator|(
name|PIM_ACTION_PRUNE
operator|)
return|;
block|}
return|return
operator|(
name|PIM_ACTION_JOIN
operator|)
return|;
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SG
condition|)
block|{
comment|/* (S,G) entry */
comment|/* TODO: check again */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|upstream
operator|==
name|upstream_router
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
operator|)
condition|)
block|{
comment|/* Upstream router toward S */
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|entry_oifs
argument_list|)
condition|)
block|{
if|if
condition|(
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
operator|&&
name|inet6_equal
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|rpaddr
argument_list|,
operator|&
name|my_cand_rp_address
argument_list|)
condition|)
block|{
comment|/* 			 * (S,G) at the RP. Don't send Join/Prune (see the 			 * end of Section 3.3.2) 			 */
return|return
operator|(
name|PIM_ACTION_NOTHING
operator|)
return|;
block|}
return|return
operator|(
name|PIM_ACTION_PRUNE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|PIM_ACTION_JOIN
operator|)
return|;
block|}
else|else
block|{
comment|/* Upstream router toward RP */
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|entry_oifs
argument_list|)
condition|)
return|return
operator|(
name|PIM_ACTION_PRUNE
operator|)
return|;
block|}
block|}
comment|/* 	 * Looks like the case when the upstream router toward S is different 	 * from the upstream router toward RP 	 */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|==
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|PIM_ACTION_NOTHING
operator|)
return|;
name|mrtentry_grp
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|grp_route
expr_stmt|;
if|if
condition|(
name|mrtentry_grp
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
name|mrtentry_grp
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|mrtlink
expr_stmt|;
if|if
condition|(
name|mrtentry_grp
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|PIM_ACTION_NOTHING
operator|)
return|;
if|if
condition|(
name|mrtentry_grp
operator|->
name|upstream
operator|!=
name|upstream_router
condition|)
return|return
operator|(
name|PIM_ACTION_NOTHING
operator|)
return|;
comment|/* XXX: shoudn't happen */
if|if
condition|(
operator|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
operator|)
operator|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SPT
operator|)
condition|)
block|{
return|return
operator|(
name|PIM_ACTION_PRUNE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|PIM_ACTION_NOTHING
operator|)
return|;
block|}
end_function

begin_comment
comment|/* TODO: too long, simplify it! */
end_comment

begin_define
define|#
directive|define
name|PIM6_JOIN_PRUNE_MINLEN
value|(4 + PIM6_ENCODE_UNI_ADDR_LEN + 4)
end_define

begin_function
name|int
name|receive_pim6_join_prune
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|pim_message
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|pim_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mifi_t
name|mifi
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|pim6_encod_uni_addr_t
name|uni_target_addr
decl_stmt|;
name|pim6_encod_grp_addr_t
name|encod_group
decl_stmt|;
name|pim6_encod_src_addr_t
name|encod_src
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr_start
decl_stmt|;
name|u_int8
name|num_groups
decl_stmt|;
name|u_int8
name|num_groups_tmp
decl_stmt|;
name|int
name|star_star_rp_found
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
name|u_int16
name|num_j_srcs
decl_stmt|;
name|u_int16
name|num_j_srcs_tmp
decl_stmt|;
name|u_int16
name|num_p_srcs
decl_stmt|;
name|struct
name|sockaddr_in6
name|source
decl_stmt|;
name|struct
name|sockaddr_in6
name|group
decl_stmt|;
name|struct
name|sockaddr_in6
name|target
decl_stmt|;
name|struct
name|in6_addr
name|s_mask
decl_stmt|;
name|struct
name|in6_addr
name|g_mask
decl_stmt|;
name|u_int8
name|s_flags
decl_stmt|;
name|u_int8
name|reserved
decl_stmt|;
name|rpentry_t
modifier|*
name|rpentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_srcs
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_rp
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|;
name|u_int16
name|jp_value
decl_stmt|;
name|pim_nbr_entry_t
modifier|*
name|upstream_router
decl_stmt|;
name|int
name|my_action
decl_stmt|;
name|int
name|ignore_group
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_ptr
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr_group_j_start
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr_group_p_start
decl_stmt|;
if|if
condition|(
operator|(
name|mifi
operator|=
name|find_vif_direct
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
comment|/* 	 * Either a local vif or somehow received PIM_JOIN_PRUNE from 	 * non-directly connected router. Ignore it. 	 */
if|if
condition|(
name|local_address
argument_list|(
name|src
argument_list|)
operator|==
name|NO_VIF
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Ignoring PIM_JOIN_PRUNE from non-neighbor router %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|mifi
index|]
expr_stmt|;
name|v
operator|->
name|uv_in_pim6_join_prune
operator|++
expr_stmt|;
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator||
name|VIFF_NONBRS
operator||
name|MIFF_REGISTER
operator|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Shoudn't come on this interface */
block|}
comment|/* sanity check for the minimum length */
if|if
condition|(
name|datalen
operator|<
name|PIM6_JOIN_PRUNE_MINLEN
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_join_prune: Join/Prune message size(%u) is"
literal|" too short from %s on %s"
argument_list|,
name|datalen
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|v
operator|->
name|uv_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|datalen
operator|-=
name|PIM6_JOIN_PRUNE_MINLEN
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the target address */
name|GET_EUADDR6
argument_list|(
operator|&
name|uni_target_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|reserved
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|num_groups
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_groups
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* No indication for groups in the message */
name|GET_HOSTSHORT
argument_list|(
name|holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|target
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|target
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|target
operator|.
name|sin6_addr
operator|=
name|uni_target_addr
operator|.
name|unicast_addr
expr_stmt|;
name|target
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|target
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Sanity check for the message length through all the groups */
name|num_groups_tmp
operator|=
name|num_groups
expr_stmt|;
name|data_ptr_start
operator|=
name|data_ptr
expr_stmt|;
while|while
condition|(
name|num_groups_tmp
operator|--
condition|)
block|{
name|int
name|srclen
decl_stmt|;
comment|/* group addr + #join + #src */
if|if
condition|(
name|datalen
operator|<
name|PIM6_ENCODE_GRP_ADDR_LEN
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_join_prune: Join/Prune message from %s on %s is"
literal|" too short to contain enough data"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|v
operator|->
name|uv_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|datalen
operator|-=
operator|(
name|PIM6_ENCODE_GRP_ADDR_LEN
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
expr_stmt|;
name|data_ptr
operator|+=
name|PIM6_ENCODE_GRP_ADDR_LEN
expr_stmt|;
comment|/* joined source addresses and pruned source addresses */
name|GET_HOSTSHORT
argument_list|(
name|num_j_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_p_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|srclen
operator|=
operator|(
name|num_j_srcs
operator|+
name|num_p_srcs
operator|)
operator|*
name|PIM6_ENCODE_SRC_ADDR_LEN
expr_stmt|;
if|if
condition|(
name|datalen
operator|<
name|srclen
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_join_prune: Join/Prune message from %s on %s is"
literal|" too short to contain enough data"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|v
operator|->
name|uv_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|datalen
operator|-=
name|srclen
expr_stmt|;
name|data_ptr
operator|+=
name|srclen
expr_stmt|;
block|}
name|data_ptr
operator|=
name|data_ptr_start
expr_stmt|;
name|num_groups_tmp
operator|=
name|num_groups
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_localif_address
argument_list|(
operator|&
name|target
argument_list|,
name|v
argument_list|)
operator|&&
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|uni_target_addr
operator|.
name|unicast_addr
argument_list|)
condition|)
block|{
comment|/* if I am not the targer of the join message */
comment|/* 	 * Join/Prune suppression code. This either modifies the J/P timers 	 * or triggers an overriding Join. 	 */
comment|/* 	 * Note that if we have (S,G) prune and (*,G) Join, we must send them 	 * in the same message. We don't bother to modify both timers here. 	 * The Join/Prune sending function will take care of that. 	 */
name|upstream_router
operator|=
name|find_pim6_nbr
argument_list|(
operator|&
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|upstream_router
operator|==
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* I have no such neighbor */
name|group
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|group
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|source
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
while|while
condition|(
name|num_groups
operator|--
condition|)
block|{
name|GET_EGADDR6
argument_list|(
operator|&
name|encod_group
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_j_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_p_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|encod_group
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_group
operator|.
name|masklen
argument_list|,
name|g_mask
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|encod_group
operator|.
name|mcast_addr
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|data_ptr
operator|+=
operator|(
name|num_j_srcs
operator|+
name|num_p_srcs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Ignore this group and jump to the next */
block|}
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|group
argument_list|,
operator|&
name|sockaddr6_d
argument_list|)
operator|&&
operator|(
name|encod_src
operator|.
name|masklen
operator|==
name|STAR_STAR_RP_MSK6LEN
operator|)
condition|)
block|{
comment|/* (*,*,RP) Join suppression */
while|while
condition|(
name|num_j_srcs
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* sanity checks */
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|encod_src
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_src
operator|.
name|masklen
argument_list|,
name|s_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s_flags
operator|&
name|USADDR_RP_BIT
operator|)
operator|&&
operator|(
name|s_flags
operator|&
name|USADDR_WC_BIT
operator|)
condition|)
block|{
comment|/* This is the RP address. */
name|rpentry_ptr
operator|=
name|rp_find
argument_list|(
operator|&
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpentry_ptr
operator|==
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
comment|/* Don't have such RP. Ignore */
name|mrtentry_rp
operator|=
name|rpentry_ptr
operator|->
name|mrtlink
expr_stmt|;
name|my_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_rp
argument_list|,
name|upstream_router
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_action
operator|!=
name|PIM_ACTION_JOIN
condition|)
continue|continue;
comment|/* Check the holdtime */
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_rp
operator|->
name|jp_timer
operator|>
name|holdtime
condition|)
continue|continue;
if|if
condition|(
operator|(
name|mrtentry_rp
operator|->
name|jp_timer
operator|==
name|holdtime
operator|)
operator|&&
operator|(
name|inet6_greaterthan
argument_list|(
name|src
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* 			 * Set the Join/Prune suppression timer for this 			 * routing entry by increasing the current Join/Prune 			 * timer. 			 */
name|jp_value
operator|=
name|pim_join_prune_period
operator|+
literal|0.5
operator|*
operator|(
name|RANDOM
argument_list|()
operator|%
name|pim_join_prune_period
operator|)
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_rp
operator|->
name|jp_timer
operator|<
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_rp
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* num_j_srcs */
while|while
condition|(
name|num_p_srcs
operator|--
condition|)
block|{
comment|/* 		     * TODO: XXX: Can we have (*,*,RP) prune message? Not in 		     * the spec, but anyway, the code below can handle them: 		     * either suppress the local (*,*,RP) prunes or override 		     * the prunes by sending (*,*,RP) and/or (*,G) and/or 		     * (S,G) Join. 		     */
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|encod_src
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_src
operator|.
name|masklen
argument_list|,
name|s_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s_flags
operator|&
name|USADDR_RP_BIT
operator|)
operator|&&
operator|(
name|s_flags
operator|&
name|USADDR_WC_BIT
operator|)
condition|)
block|{
comment|/* This is the RP address. */
name|rpentry_ptr
operator|=
name|rp_find
argument_list|(
operator|&
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpentry_ptr
operator|==
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
comment|/* Don't have such RP. Ignore */
name|mrtentry_rp
operator|=
name|rpentry_ptr
operator|->
name|mrtlink
expr_stmt|;
name|my_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_rp
argument_list|,
name|upstream_router
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_action
operator|==
name|PIM_ACTION_PRUNE
condition|)
block|{
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
operator|(
name|mrtentry_rp
operator|->
name|jp_timer
operator|<
name|holdtime
operator|)
operator|||
operator|(
operator|(
name|mrtentry_rp
operator|->
name|jp_timer
operator|==
name|holdtime
operator|)
operator|&&
operator|(
name|inet6_greaterthan
argument_list|(
name|src
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Suppress the Prune */
name|jp_value
operator|=
name|pim_join_prune_period
operator|+
literal|0.5
operator|*
operator|(
name|RANDOM
argument_list|()
operator|%
name|pim_join_prune_period
operator|)
expr_stmt|;
if|if
condition|(
name|mrtentry_rp
operator|->
name|jp_timer
operator|<
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_rp
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|my_action
operator|==
name|PIM_ACTION_JOIN
condition|)
block|{
comment|/* Override the Prune by scheduling a Join */
name|jp_value
operator|=
operator|(
name|RANDOM
argument_list|()
operator|%
literal|11
operator|)
operator|/
operator|(
literal|10
operator|*
name|PIM_RANDOM_DELAY_JOIN_TIMEOUT
operator|)
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_rp
operator|->
name|jp_timer
operator|>
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_rp
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Check all (*,G) and (S,G) matching to this RP. If 			 * my_action == JOIN, then send a Join and override 			 * the (*,*,RP) Prune. 			 */
for|for
control|(
name|grpentry_ptr
operator|=
name|rpentry_ptr
operator|->
name|cand_rp
operator|->
name|rp_grp_next
operator|->
name|grplink
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|rpnext
control|)
block|{
name|my_action
operator|=
name|join_or_prune
argument_list|(
name|grpentry_ptr
operator|->
name|grp_route
argument_list|,
name|upstream_router
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_action
operator|==
name|PIM_ACTION_JOIN
condition|)
block|{
name|jp_value
operator|=
operator|(
name|RANDOM
argument_list|()
operator|%
literal|11
operator|)
operator|/
operator|(
literal|10
operator|*
name|PIM_RANDOM_DELAY_JOIN_TIMEOUT
operator|)
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|jp_timer
operator|>
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|mrtentry_srcs
operator|=
name|grpentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
control|)
block|{
name|my_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_srcs
argument_list|,
name|upstream_router
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_action
operator|==
name|PIM_ACTION_JOIN
condition|)
block|{
name|jp_value
operator|=
operator|(
name|RANDOM
argument_list|()
operator|%
literal|11
operator|)
operator|/
operator|(
literal|10
operator|*
name|PIM_RANDOM_DELAY_JOIN_TIMEOUT
operator|)
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_srcs
operator|->
name|jp_timer
operator|>
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_srcs
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For all (S,G) */
block|}
comment|/* For all (*,G) */
block|}
block|}
comment|/* num_p_srcs */
continue|continue;
comment|/* This was (*,*,RP) suppression */
block|}
comment|/* (*,G) or (S,G) suppression */
comment|/* 	     * TODO: XXX: currently, accumulated groups (i.e. group_masklen< 	     * group_address_lengt) are not implemented. Just need to create 	     * a loop and apply the procedure below for all groups matching 	     * the prefix. 	     */
while|while
condition|(
name|num_j_srcs
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|encod_src
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_src
operator|.
name|masklen
argument_list|,
name|s_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s_flags
operator|&
name|USADDR_RP_BIT
operator|)
operator|&&
operator|(
name|s_flags
operator|&
name|USADDR_WC_BIT
operator|)
condition|)
block|{
comment|/* (*,G) JOIN_REQUEST (toward the RP) */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|sockaddr6_any
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_WC
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
name|my_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_ptr
argument_list|,
name|upstream_router
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_action
operator|!=
name|PIM_ACTION_JOIN
condition|)
continue|continue;
comment|/* (*,G) Join suppresion */
if|if
condition|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|address
argument_list|)
condition|)
continue|continue;
comment|/* The RP address doesn't match. 					 * Ignore. */
comment|/* Check the holdtime */
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|>
name|holdtime
condition|)
continue|continue;
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|==
name|holdtime
operator|)
operator|&&
operator|(
name|inet6_greaterthan
argument_list|(
name|src
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|)
operator|)
condition|)
continue|continue;
name|jp_value
operator|=
name|pim_join_prune_period
operator|+
literal|0.5
operator|*
operator|(
name|RANDOM
argument_list|()
operator|%
name|pim_join_prune_period
operator|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|<
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* End of (*,G) Join suppression */
comment|/* (S,G) Join suppresion */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
name|my_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_ptr
argument_list|,
name|upstream_router
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_action
operator|!=
name|PIM_ACTION_JOIN
condition|)
continue|continue;
comment|/* Check the holdtime */
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|>
name|holdtime
condition|)
continue|continue;
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|==
name|holdtime
operator|)
operator|&&
operator|(
name|inet6_greaterthan
argument_list|(
name|src
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|)
operator|)
condition|)
continue|continue;
name|jp_value
operator|=
name|pim_join_prune_period
operator|+
literal|0.5
operator|*
operator|(
name|RANDOM
argument_list|()
operator|%
name|pim_join_prune_period
operator|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|<
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Prunes suppression */
while|while
condition|(
name|num_p_srcs
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|encod_src
operator|.
name|masklen
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|<<
literal|3
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_src
operator|.
name|masklen
argument_list|,
name|s_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s_flags
operator|&
name|USADDR_RP_BIT
operator|)
operator|&&
operator|(
name|s_flags
operator|&
name|USADDR_WC_BIT
operator|)
condition|)
block|{
comment|/* (*,G) prune suppression */
name|rpentry_ptr
operator|=
name|rp_match
argument_list|(
operator|&
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rpentry_ptr
operator|==
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|rpentry_ptr
operator|->
name|address
argument_list|,
operator|&
name|source
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* No such RP or it is different. 					 * Ignore */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|sockaddr6_any
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_WC
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
name|my_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_ptr
argument_list|,
name|upstream_router
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_action
operator|==
name|PIM_ACTION_PRUNE
condition|)
block|{
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|<
name|holdtime
operator|)
operator|||
operator|(
operator|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|==
name|holdtime
operator|)
operator|&&
operator|(
name|inet6_greaterthan
argument_list|(
name|src
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Suppress the Prune */
name|jp_value
operator|=
name|pim_join_prune_period
operator|+
literal|0.5
operator|*
operator|(
name|RANDOM
argument_list|()
operator|%
name|pim_join_prune_period
operator|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|<
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|my_action
operator|==
name|PIM_ACTION_JOIN
condition|)
block|{
comment|/* Override the Prune by scheduling a Join */
name|jp_value
operator|=
operator|(
name|RANDOM
argument_list|()
operator|%
literal|11
operator|)
operator|/
operator|(
literal|10
operator|*
name|PIM_RANDOM_DELAY_JOIN_TIMEOUT
operator|)
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|>
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
block|}
comment|/* 		     * Check all (S,G) entries for this group. If my_action 		     * == JOIN, then send the Join and override the (*,G) 		     * Prune. 		     */
for|for
control|(
name|mrtentry_srcs
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|mrtlink
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
control|)
block|{
name|my_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_srcs
argument_list|,
name|upstream_router
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_action
operator|==
name|PIM_ACTION_JOIN
condition|)
block|{
name|jp_value
operator|=
operator|(
name|RANDOM
argument_list|()
operator|%
literal|11
operator|)
operator|/
operator|(
literal|10
operator|*
name|PIM_RANDOM_DELAY_JOIN_TIMEOUT
operator|)
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|>
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* For all (S,G) */
continue|continue;
comment|/* End of (*,G) prune suppression */
block|}
comment|/* (S,G) prune suppression */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
name|my_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_ptr
argument_list|,
name|upstream_router
argument_list|)
expr_stmt|;
if|if
condition|(
name|my_action
operator|==
name|PIM_ACTION_PRUNE
condition|)
block|{
comment|/* Suppress the (S,G) Prune */
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|<
name|holdtime
operator|)
operator|||
operator|(
operator|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|==
name|holdtime
operator|)
operator|&&
operator|(
name|inet6_greaterthan
argument_list|(
name|src
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|)
operator|)
operator|)
condition|)
block|{
name|jp_value
operator|=
name|pim_join_prune_period
operator|+
literal|0.5
operator|*
operator|(
name|RANDOM
argument_list|()
operator|%
name|pim_join_prune_period
operator|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|<
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|my_action
operator|==
name|PIM_ACTION_JOIN
condition|)
block|{
comment|/* Override the Prune by scheduling a Join */
name|jp_value
operator|=
operator|(
name|RANDOM
argument_list|()
operator|%
literal|11
operator|)
operator|/
operator|(
literal|10
operator|*
name|PIM_RANDOM_DELAY_JOIN_TIMEOUT
operator|)
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|>
name|jp_value
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|,
name|jp_value
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* while (num_p_srcs--) */
block|}
comment|/* while (num_groups--) */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* End of Join/Prune suppression code */
comment|/* I am the target of this join, so process the message */
comment|/*      * The spec says that if there is (*,G) Join, it has priority over old      * existing ~(S,G) prunes in the routing table. However, if the (*,G)      * Join and the ~(S,G) prune are in the same message, ~(S,G) has the      * priority. The spec doesn't say it, but I think the same is true for      * (*,*,RP) and ~(S,G) prunes.      *       * The code below do: (1) Check the whole message for (*,*,RP) Joins. (1.1)      * If found, clean all pruned_oifs for all (*,G) and all (S,G) for each      * RP in the list, but do not update the kernel cache. Then go back to      * the beginning of the message and start processing for each group: (2)      * Check for Prunes. If no prunes, process the Joins. (3) If there are      * Prunes: (3.1) Scan the Join part for existing (*,G) Join. (3.1.1) If      * there is (*,G) Join, clear join interface from the pruned_oifs for all      * (S,G), but DO NOT flush the change to the kernel (by using      * change_interfaces() for example) (3.2) After the pruned_oifs are      * eventually cleared in (3.1.1), process the Prune part of the message      * normally (setting the prune_oifs and flashing the changes to the      * (kernel). (3.3) After the Prune part is processed, process the Join      * part normally (by applying any changes to the kernel) (4) If there      * were (*,*,RP) Join/Prune, process them.      *       * If the Join/Prune list is too long, it may result in long processing      * overhead. The idea above is not to place any wrong info in the kernel,      * because it may result in short-time existing traffic forwarding on      * wrong interface. Hopefully, in the future will find a better way to      * implement it.      */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"I'm the target of the JOIN/PRUNE message"
argument_list|)
expr_stmt|;
name|num_groups_tmp
operator|=
name|num_groups
expr_stmt|;
name|data_ptr_start
operator|=
name|data_ptr
expr_stmt|;
name|star_star_rp_found
operator|=
name|FALSE
expr_stmt|;
comment|/* Indicating whether we have (*,*,RP) join */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Number of groups to process : %d"
argument_list|,
name|num_groups_tmp
argument_list|)
expr_stmt|;
while|while
condition|(
name|num_groups_tmp
operator|--
condition|)
block|{
comment|/* Search for (*,*,RP) Join */
name|GET_EGADDR6
argument_list|(
operator|&
name|encod_group
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_j_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_p_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|encod_group
operator|.
name|mcast_addr
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Group to process : %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|encod_group
operator|.
name|mcast_addr
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Number of join   : %d"
argument_list|,
name|num_j_srcs
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Number of prune  : %d"
argument_list|,
name|num_p_srcs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|inet6_equal
argument_list|(
operator|&
name|group
argument_list|,
operator|&
name|sockaddr6_d
argument_list|)
operator|)
operator|||
operator|(
name|encod_src
operator|.
name|masklen
operator|!=
name|STAR_STAR_RP_MSK6LEN
operator|)
condition|)
block|{
comment|/* This is not (*,*,RP). Jump to the next group. */
name|data_ptr
operator|+=
operator|(
name|num_j_srcs
operator|+
name|num_p_srcs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"I'm looking for the (*,*,RP) entry , skip to next entry"
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 	 * (*,*,RP) found. For each RP and each (*,G) and each (S,G) clear 	 * the pruned oif, but do not update the kernel. 	 */
name|star_star_rp_found
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|num_j_srcs
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|rpentry_ptr
operator|=
name|rp_find
argument_list|(
operator|&
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpentry_ptr
operator|==
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
for|for
control|(
name|rp_grp_entry_ptr
operator|=
name|rpentry_ptr
operator|->
name|cand_rp
operator|->
name|rp_grp_next
init|;
name|rp_grp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|rp_grp_entry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|rp_grp_next
control|)
block|{
for|for
control|(
name|grpentry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|grplink
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|rpnext
control|)
block|{
if|if
condition|(
name|grpentry_ptr
operator|->
name|grp_route
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
for|for
control|(
name|mrtentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|grpnext
control|)
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|data_ptr
operator|+=
operator|(
name|num_p_srcs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
expr_stmt|;
block|}
comment|/*      * Start processing the groups. If this is (*,*,RP), skip it, but process      * it at the end.don't forget to reinit data_ptr!      */
name|data_ptr
operator|=
name|data_ptr_start
expr_stmt|;
name|num_groups_tmp
operator|=
name|num_groups
expr_stmt|;
while|while
condition|(
name|num_groups_tmp
operator|--
condition|)
block|{
name|GET_EGADDR6
argument_list|(
operator|&
name|encod_group
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_j_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_p_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|encod_group
operator|.
name|mcast_addr
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Group to process : %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|encod_group
operator|.
name|mcast_addr
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Number of join   : %d"
argument_list|,
name|num_j_srcs
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Number of prune  : %d"
argument_list|,
name|num_p_srcs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|data_ptr
operator|+=
operator|(
name|num_j_srcs
operator|+
name|num_p_srcs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Ignore this group and jump to the next one */
block|}
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|group
argument_list|,
operator|&
name|sockaddr6_d
argument_list|)
operator|&&
operator|(
name|encod_group
operator|.
name|masklen
operator|==
name|STAR_STAR_RP_MSK6LEN
operator|)
condition|)
block|{
comment|/* This is (*,*,RP). Jump to the next group. */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"This is (*,*,RP). Jump to next."
argument_list|)
expr_stmt|;
block|}
name|data_ptr
operator|+=
operator|(
name|num_j_srcs
operator|+
name|num_p_srcs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rpentry_ptr
operator|=
name|rp_match
argument_list|(
operator|&
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpentry_ptr
operator|==
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"The rp for this JOIN/PRUNE is %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|rpentry_ptr
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|data_ptr_group_j_start
operator|=
name|data_ptr
expr_stmt|;
name|data_ptr_group_p_start
operator|=
name|data_ptr
operator|+
name|num_j_srcs
operator|*
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
expr_stmt|;
comment|/* 	 * Scan the Join part for (*,G) Join and then clear the particular 	 * interface from pruned_oifs for all (S,G). If the RP address in the 	 * Join message is different from the local match, ignore the whole 	 * group. 	 */
name|num_j_srcs_tmp
operator|=
name|num_j_srcs
expr_stmt|;
name|ignore_group
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
name|num_j_srcs_tmp
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|encod_src
operator|.
name|flags
operator|&
name|USADDR_RP_BIT
operator|)
operator|&&
operator|(
name|encod_src
operator|.
name|flags
operator|&
name|USADDR_WC_BIT
operator|)
condition|)
block|{
comment|/* 		 * This is the RP address, i.e. (*,G) Join. Check if the 		 * RP-mapping is consistent and if "yes", then Reset the 		 * pruned_oifs for all (S,G) entries. 		 */
if|if
condition|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|rpentry_ptr
operator|->
name|address
argument_list|,
operator|&
name|source
argument_list|)
condition|)
block|{
name|ignore_group
operator|=
name|TRUE
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"And I'm not the RP for this address"
argument_list|)
expr_stmt|;
break|break;
block|}
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|sockaddr6_any
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_WC
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
for|for
control|(
name|mrtentry_srcs
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|mrtlink
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
control|)
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|ignore_group
operator|==
name|TRUE
condition|)
continue|continue;
name|data_ptr
operator|=
name|data_ptr_group_p_start
expr_stmt|;
comment|/* Process the Prune part first */
while|while
condition|(
name|num_p_srcs
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s_flags
operator|&
operator|(
name|USADDR_WC_BIT
operator||
name|USADDR_RP_BIT
operator|)
operator|)
condition|)
block|{
comment|/* (S,G) prune sent toward S */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
comment|/* I don't have (S,G) to prune. Ignore. */
comment|/* 		 * If the link is point-to-point, timeout the oif 		 * immediately, otherwise decrease the timer to allow other 		 * downstream routers to override the prune. 		 */
comment|/* TODO: XXX: increase the entry timer? */
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_POINT_TO_POINT
condition|)
block|{
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
operator|>
name|mrtentry_ptr
operator|->
name|vif_deletion_delay
index|[
name|mifi
index|]
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|,
name|mrtentry_ptr
operator|->
name|vif_deletion_delay
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
block|}
name|IF_TIMER_NOT_SET
argument_list|(
argument|mrtentry_ptr->vif_timers[mifi]
argument_list|)
block|{
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|s_flags
operator|&
name|USADDR_RP_BIT
operator|)
operator|&&
operator|(
operator|!
operator|(
name|s_flags
operator|&
name|USADDR_WC_BIT
operator|)
operator|)
condition|)
block|{
comment|/* ~(S,G)RPbit prune sent toward the RP */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_POINT_TO_POINT
condition|)
block|{
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
operator|>
name|mrtentry_ptr
operator|->
name|vif_deletion_delay
index|[
name|mifi
index|]
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|,
name|mrtentry_ptr
operator|->
name|vif_deletion_delay
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
block|}
name|IF_TIMER_NOT_SET
argument_list|(
argument|mrtentry_ptr->vif_timers[mifi]
argument_list|)
block|{
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* There is no (S,G) entry. Check for (*,G) or (*,*,RP) */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
name|NULL
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_WC
operator||
name|MRTF_PMBR
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
operator||
name|MRTF_RP
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
name|RESET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
comment|/* 		     * TODO: XXX: The spec doens't say what value to use for 		     * the entry time. Use the J/P holdtime. 		     */
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
comment|/* 		     * TODO: XXX: The spec says to delete the oif. However, 		     * its timer only should be lowered, so the prune can be 		     * overwritten on multiaccess LAN. Spec BUG. 		     */
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|s_flags
operator|&
name|USADDR_RP_BIT
operator|)
operator|&&
operator|(
name|s_flags
operator|&
name|USADDR_WC_BIT
operator|)
condition|)
block|{
comment|/* (*,G) Prune */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
name|NULL
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_WC
operator||
name|MRTF_PMBR
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_WC
condition|)
block|{
comment|/* 			 * TODO: XXX: Should check the whole Prune list in 			 * advance for (*,G) prune and if the RP address does 			 * not match the local RP-map, then ignore the whole 			 * group, not only this particular (*,G) prune. 			 */
if|if
condition|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|address
argument_list|,
operator|&
name|source
argument_list|)
condition|)
continue|continue;
comment|/* The RP address doesn't match. */
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_POINT_TO_POINT
condition|)
block|{
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
operator|>
name|mrtentry_ptr
operator|->
name|vif_deletion_delay
index|[
name|mifi
index|]
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|,
name|mrtentry_ptr
operator|->
name|vif_deletion_delay
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
block|}
name|IF_TIMER_NOT_SET
argument_list|(
argument|mrtentry_ptr->vif_timers[mifi]
argument_list|)
block|{
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* No (*,G) entry, but found (*,*,RP). Create (*,G) */
if|if
condition|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
argument_list|,
operator|&
name|source
argument_list|)
condition|)
continue|continue;
comment|/* The RP address doesn't match. */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
name|NULL
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_WC
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
name|RESET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
comment|/* 		     * TODO: XXX: should only lower the oif timer, so it can 		     * be overwritten on multiaccess LAN. Spec bug. 		     */
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* (*,G) or (*,*,RP) found */
block|}
comment|/* (*,G) prune */
block|}
comment|/* while(num_p_srcs--) */
comment|/* End of (S,G) and (*,G) Prune handling */
comment|/* Jump back to the Join part and process it */
name|data_ptr
operator|=
name|data_ptr_group_j_start
expr_stmt|;
while|while
condition|(
name|num_j_srcs
operator|--
condition|)
block|{
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_src
operator|.
name|masklen
argument_list|,
name|s_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s_flags
operator|&
name|USADDR_WC_BIT
operator|)
operator|&&
operator|(
name|s_flags
operator|&
name|USADDR_RP_BIT
operator|)
condition|)
block|{
comment|/* (*,G) Join toward RP */
comment|/* 		 * It has been checked already that this RP address is the 		 * same as the local RP-maping. 		 */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
name|NULL
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_WC
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
operator|<
name|holdtime
condition|)
block|{
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|vif_deletion_delay
index|[
name|mifi
index|]
operator|=
name|holdtime
operator|/
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|timer
operator|<
name|holdtime
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Need to update the (S,G) entries, because of the previous 		 * cleaning of the pruned_oifs. The reason is that if the 		 * oifs for (*,G) weren't changed, the (S,G) entries won't be 		 * updated by change_interfaces() 		 */
for|for
control|(
name|mrtentry_srcs
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|mrtlink
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
control|)
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|mrtentry_srcs
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|s_flags
operator|&
operator|(
name|USADDR_WC_BIT
operator||
name|USADDR_RP_BIT
operator|)
operator|)
condition|)
block|{
comment|/* (S,G) Join toward S */
if|if
condition|(
name|mifi
operator|==
name|get_iif
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
comment|/* Ignore this (S,G) Join */
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
operator|<
name|holdtime
condition|)
block|{
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|vif_deletion_delay
index|[
name|mifi
index|]
operator|=
name|holdtime
operator|/
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|timer
operator|<
name|holdtime
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
comment|/* 		 * TODO: if this is a new entry, send immediately the Join 		 * message toward S. The Join/Prune timer for new entries is 		 * 0, but it does not means the message will be sent 		 * immediately. 		 */
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
comment|/* 		 * Note that we must create (S,G) without the RPbit set. If 		 * we already had such entry, change_interfaces() will reset 		 * the RPbit propertly. 		 */
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|source
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* while(num_j_srcs--) */
block|}
comment|/* for all groups */
comment|/* Now process the (*,*,RP) Join/Prune */
if|if
condition|(
name|star_star_rp_found
operator|==
name|TRUE
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|data_ptr
operator|=
name|data_ptr_start
expr_stmt|;
while|while
condition|(
name|num_groups
operator|--
condition|)
block|{
comment|/* 	 * The conservative approach is to scan again the whole message, just 	 * in case if we have more than one (*,*,RP) requests. 	 */
name|GET_EGADDR6
argument_list|(
operator|&
name|encod_group
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_j_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|num_p_srcs
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|encod_group
operator|.
name|mcast_addr
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|group
argument_list|,
operator|&
name|sockaddr6_d
argument_list|)
operator|||
operator|(
name|encod_group
operator|.
name|masklen
operator|!=
name|STAR_STAR_RP_MSK6LEN
operator|)
condition|)
block|{
comment|/* This is not (*,*,RP). Jump to the next group. */
name|data_ptr
operator|+=
operator|(
name|num_j_srcs
operator|+
name|num_p_srcs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* (*,*,RP) found */
while|while
condition|(
name|num_j_srcs
operator|--
condition|)
block|{
comment|/* TODO: XXX: check that the iif is different from the Join oifs */
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_src
operator|.
name|masklen
argument_list|,
name|s_mask
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
name|NULL
argument_list|,
name|MRTF_PMBR
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
operator|<
name|holdtime
condition|)
block|{
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|vif_deletion_delay
index|[
name|mifi
index|]
operator|=
name|holdtime
operator|/
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|timer
operator|<
name|holdtime
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|holdtime
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	     * Need to update the (S,G) and (*,G) entries, because of the 	     * previous cleaning of the pruned_oifs. The reason is that if 	     * the oifs for (*,*,RP) weren't changed, the (*,G) and (S,G) 	     * entries won't be updated by change_interfaces() 	     */
for|for
control|(
name|rp_grp_entry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|cand_rp
operator|->
name|rp_grp_next
init|;
name|rp_grp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|rp_grp_entry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|rp_grp_next
control|)
for|for
control|(
name|grpentry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|grplink
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|rpnext
control|)
block|{
comment|/* Update the (*,G) entry */
name|change_interfaces
argument_list|(
name|grpentry_ptr
operator|->
name|grp_route
argument_list|,
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|incoming
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|joined_oifs
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|leaves
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Update the (S,G) entries */
for|for
control|(
name|mrtentry_srcs
operator|=
name|grpentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
control|)
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|mrtentry_srcs
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
while|while
condition|(
name|num_p_srcs
operator|--
condition|)
block|{
comment|/* TODO: XXX: can we have (*,*,RP) Prune? */
name|GET_ESADDR6
argument_list|(
operator|&
name|encod_src
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|encod_src
operator|.
name|src_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|source
argument_list|)
condition|)
continue|continue;
name|s_flags
operator|=
name|encod_src
operator|.
name|flags
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_src
operator|.
name|masklen
argument_list|,
name|s_mask
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
name|NULL
argument_list|,
name|MRTF_PMBR
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
comment|/* 	     * If the link is point-to-point, timeout the oif immediately, 	     * otherwise decrease the timer to allow other downstream routers 	     * to override the prune. 	     */
comment|/* TODO: XXX: increase the entry timer? */
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_POINT_TO_POINT
condition|)
block|{
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
operator|>
name|mrtentry_ptr
operator|->
name|vif_deletion_delay
index|[
name|mifi
index|]
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|vif_timers
index|[
name|mifi
index|]
argument_list|,
name|mrtentry_ptr
operator|->
name|vif_deletion_delay
index|[
name|mifi
index|]
argument_list|)
expr_stmt|;
block|}
name|IF_TIMER_NOT_SET
argument_list|(
argument|mrtentry_ptr->vif_timers[mifi]
argument_list|)
block|{
name|IF_CLR
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* For all groups processing (*,*,R) */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * TODO: NOT USED, probably buggy, but may need it in the future.  */
end_comment

begin_comment
comment|/*  * TODO: create two functions: periodic which timeout the timers and  * non-periodic which only check but don't timeout the timers.  */
end_comment

begin_comment
comment|/*  * Create and send Join/Prune messages per interface. Only the entries which  * have the Join/Prune timer expired are included. In the special case when  * we have ~(S,G)RPbit Prune entry, we must include any (*,G) or (*,*,RP)  * Currently the whole table is scanned. In the future will have all routing  * entries linked in a chain with the corresponding upstream pim_nbr_entry.  *   * If pim_nbr is not NULL, then send to only this particular PIM neighbor,  */
end_comment

begin_function
name|int
name|send_periodic_pim6_join_prune
parameter_list|(
name|mifi
parameter_list|,
name|pim_nbr
parameter_list|,
name|holdtime
parameter_list|)
name|mifi_t
name|mifi
decl_stmt|;
name|pim_nbr_entry_t
modifier|*
name|pim_nbr
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
block|{
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|rpentry_t
modifier|*
name|rpentry_ptr
decl_stmt|;
name|struct
name|sockaddr_in6
name|src_addr
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|pim_nbr_entry_t
modifier|*
name|pim_nbr_ptr
decl_stmt|;
name|cand_rp_t
modifier|*
name|cand_rp_ptr
decl_stmt|;
comment|/*      * Walk through all routing entries. The iif must match to include the      * entry. Check first the (*,G) entry and then all associated (S,G). At      * the end of the message will add any (*,*,RP) entries. TODO: check      * other PIM-SM implementations and decide the more appropriate place to      * put the (*,*,RP) entries: in the beginning of the message or at the      * end.      */
name|v
operator|=
operator|&
name|uvifs
index|[
name|mifi
index|]
expr_stmt|;
comment|/* Check the (*,G) and (S,G) entries */
for|for
control|(
name|grpentry_ptr
operator|=
name|grplist
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|next
control|)
block|{
name|mrtentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|grp_route
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|incoming
operator|==
name|mifi
operator|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|<=
name|timer_interval
operator|)
condition|)
block|{
comment|/* If join/prune to a particular neighbor only was specified */
if|if
condition|(
operator|(
name|pim_nbr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|upstream
operator|!=
name|pim_nbr
operator|)
condition|)
continue|continue;
comment|/* TODO: XXX: The J/P suppression timer is not in the spec! */
if|if
condition|(
operator|!
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
operator|||
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DR
operator|)
condition|)
block|{
name|add_jp_entry
argument_list|(
name|mrtentry_ptr
operator|->
name|upstream
argument_list|,
name|holdtime
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|group
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|rpaddr
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|PIM_ACTION_JOIN
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
operator|&&
operator|(
operator|!
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_DR
operator|)
operator|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|<=
name|timer_interval
operator|)
condition|)
block|{
name|add_jp_entry
argument_list|(
name|mrtentry_ptr
operator|->
name|upstream
argument_list|,
name|holdtime
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|group
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|rpaddr
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|PIM_ACTION_PRUNE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check the (S,G) entries */
for|for
control|(
name|mrtentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|grpnext
control|)
block|{
comment|/* If join/prune to a particular neighbor only was specified */
if|if
condition|(
operator|(
name|pim_nbr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|upstream
operator|!=
name|pim_nbr
operator|)
condition|)
continue|continue;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
condition|)
block|{
comment|/* RPbit set */
name|src_addr
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
expr_stmt|;
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
operator|||
operator|(
operator|(
name|find_vif_direct_local
argument_list|(
operator|&
name|src_addr
argument_list|)
operator|!=
name|NO_VIF
operator|)
operator|&&
name|grpentry_ptr
operator|->
name|grp_route
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
operator|)
condition|)
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
operator|(
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|incoming
operator|==
name|mifi
operator|)
operator|&&
operator|(
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|jp_timer
operator|<=
name|timer_interval
operator|)
condition|)
comment|/* S is directly connected. Send toward RP */
name|add_jp_entry
argument_list|(
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|upstream
argument_list|,
name|holdtime
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|group
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
operator|&
name|src_addr
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
name|MRTF_RP
argument_list|,
name|PIM_ACTION_PRUNE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* RPbit cleared */
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
condition|)
block|{
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|->
name|incoming
operator|==
name|mifi
operator|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|<=
name|timer_interval
operator|)
condition|)
name|add_jp_entry
argument_list|(
name|mrtentry_ptr
operator|->
name|upstream
argument_list|,
name|holdtime
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|group
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|PIM_ACTION_PRUNE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|->
name|incoming
operator|==
name|mifi
operator|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|jp_timer
operator|<=
name|timer_interval
operator|)
condition|)
name|add_jp_entry
argument_list|(
name|mrtentry_ptr
operator|->
name|upstream
argument_list|,
name|holdtime
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|group
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|PIM_ACTION_JOIN
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SPT
operator|)
operator|&&
operator|(
name|grpentry_ptr
operator|->
name|grp_route
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|incoming
operator|!=
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|incoming
operator|)
operator|&&
operator|(
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|incoming
operator|==
name|mifi
operator|)
operator|&&
operator|(
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|jp_timer
operator|<=
name|timer_interval
operator|)
condition|)
name|add_jp_entry
argument_list|(
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|upstream
argument_list|,
name|holdtime
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|group
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
name|MRTF_RP
argument_list|,
name|PIM_ACTION_PRUNE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Check the (*,*,RP) entries */
for|for
control|(
name|cand_rp_ptr
operator|=
name|cand_rp_list
init|;
name|cand_rp_ptr
operator|!=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|;
name|cand_rp_ptr
operator|=
name|cand_rp_ptr
operator|->
name|next
control|)
block|{
name|rpentry_ptr
operator|=
name|cand_rp_ptr
operator|->
name|rpentry
expr_stmt|;
comment|/* If join/prune to a particular neighbor only was specified */
if|if
condition|(
operator|(
name|pim_nbr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|rpentry_ptr
operator|->
name|upstream
operator|!=
name|pim_nbr
operator|)
condition|)
continue|continue;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
operator|(
name|rpentry_ptr
operator|->
name|mrtlink
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|rpentry_ptr
operator|->
name|incoming
operator|==
name|mifi
operator|)
operator|&&
operator|(
name|rpentry_ptr
operator|->
name|mrtlink
operator|->
name|jp_timer
operator|<=
name|timer_interval
operator|)
condition|)
block|{
name|add_jp_entry
argument_list|(
name|rpentry_ptr
operator|->
name|upstream
argument_list|,
name|holdtime
argument_list|,
operator|&
name|sockaddr6_d
argument_list|,
name|STAR_STAR_RP_MSK6LEN
argument_list|,
operator|&
name|rpentry_ptr
operator|->
name|address
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
name|MRTF_RP
operator||
name|MRTF_WC
argument_list|,
name|PIM_ACTION_JOIN
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Send all pending Join/Prune messages */
for|for
control|(
name|pim_nbr_ptr
operator|=
name|v
operator|->
name|uv_pim_neighbors
init|;
name|pim_nbr_ptr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|;
name|pim_nbr_ptr
operator|=
name|pim_nbr
operator|->
name|next
control|)
block|{
comment|/* If join/prune to a particular neighbor only was specified */
if|if
condition|(
operator|(
name|pim_nbr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|pim_nbr_ptr
operator|!=
name|pim_nbr
operator|)
condition|)
continue|continue;
name|pack_and_send_jp6_message
argument_list|(
name|pim_nbr_ptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|add_jp_entry
parameter_list|(
name|pim_nbr
parameter_list|,
name|holdtime
parameter_list|,
name|group
parameter_list|,
name|grp_msklen
parameter_list|,
name|source
parameter_list|,
name|src_msklen
parameter_list|,
name|addr_flags
parameter_list|,
name|join_prune
parameter_list|)
name|pim_nbr_entry_t
modifier|*
name|pim_nbr
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|group
decl_stmt|;
name|u_int8
name|grp_msklen
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|source
decl_stmt|;
name|u_int8
name|src_msklen
decl_stmt|;
name|u_int16
name|addr_flags
decl_stmt|;
name|u_int8
name|join_prune
decl_stmt|;
block|{
name|build_jp_message_t
modifier|*
name|bjpm
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|u_int8
name|flags
init|=
literal|0
decl_stmt|;
name|int
name|rp_flag
decl_stmt|;
name|bjpm
operator|=
name|pim_nbr
operator|->
name|build_jp_message
expr_stmt|;
if|if
condition|(
name|bjpm
operator|!=
operator|(
name|build_jp_message_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|bjpm
operator|->
name|jp_message_size
operator|+
name|bjpm
operator|->
name|join_list_size
operator|+
name|bjpm
operator|->
name|prune_list_size
operator|+
name|bjpm
operator|->
name|rp_list_join_size
operator|+
name|bjpm
operator|->
name|rp_list_prune_size
operator|>=
name|MAX_JP_MESSAGE_SIZE
operator|)
operator|||
operator|(
name|bjpm
operator|->
name|join_list_size
operator|>=
name|MAX_JOIN_LIST_SIZE
operator|)
operator|||
operator|(
name|bjpm
operator|->
name|prune_list_size
operator|>=
name|MAX_PRUNE_LIST_SIZE
operator|)
operator|||
operator|(
name|bjpm
operator|->
name|rp_list_join_size
operator|>=
name|MAX_JOIN_LIST_SIZE
operator|)
operator|||
operator|(
name|bjpm
operator|->
name|rp_list_prune_size
operator|>=
name|MAX_PRUNE_LIST_SIZE
operator|)
condition|)
block|{
comment|/* 	     * TODO: XXX: BUG: If the list is getting too large, must be 	     * careful with the fragmentation. 	     */
name|pack_and_send_jp6_message
argument_list|(
name|pim_nbr
argument_list|)
expr_stmt|;
name|bjpm
operator|=
name|pim_nbr
operator|->
name|build_jp_message
expr_stmt|;
comment|/* The buffer will be freed */
block|}
block|}
if|if
condition|(
name|bjpm
operator|!=
operator|(
name|build_jp_message_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|bjpm
operator|->
name|curr_group
argument_list|,
name|group
argument_list|)
operator|||
operator|(
name|bjpm
operator|->
name|curr_group_msklen
operator|!=
name|grp_msklen
operator|)
operator|||
operator|(
name|bjpm
operator|->
name|holdtime
operator|!=
name|holdtime
operator|)
operator|)
condition|)
block|{
name|pack_jp6_message
argument_list|(
name|pim_nbr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bjpm
operator|==
operator|(
name|build_jp_message_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|bjpm
operator|=
name|get_jp6_working_buff
argument_list|()
expr_stmt|;
name|pim_nbr
operator|->
name|build_jp_message
operator|=
name|bjpm
expr_stmt|;
name|data_ptr
operator|=
name|bjpm
operator|->
name|jp_message
expr_stmt|;
name|PUT_EUADDR6
argument_list|(
name|pim_nbr
operator|->
name|address
operator|.
name|sin6_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_BYTE
argument_list|(
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* Reserved */
name|bjpm
operator|->
name|num_groups_ptr
operator|=
name|data_ptr
operator|++
expr_stmt|;
comment|/* The pointer for numgroups */
operator|*
operator|(
name|bjpm
operator|->
name|num_groups_ptr
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* Zero groups */
name|PUT_HOSTSHORT
argument_list|(
name|holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|bjpm
operator|->
name|holdtime
operator|=
name|holdtime
expr_stmt|;
name|bjpm
operator|->
name|jp_message_size
operator|=
name|data_ptr
operator|-
name|bjpm
operator|->
name|jp_message
expr_stmt|;
block|}
comment|/* TODO: move somewhere else, only when it is a new group */
name|bjpm
operator|->
name|curr_group
operator|=
operator|*
name|group
expr_stmt|;
name|bjpm
operator|->
name|curr_group_msklen
operator|=
name|grp_msklen
expr_stmt|;
if|if
condition|(
name|inet6_equal
argument_list|(
name|group
argument_list|,
operator|&
name|sockaddr6_d
argument_list|)
operator|&&
operator|(
name|grp_msklen
operator|==
name|STAR_STAR_RP_MSK6LEN
operator|)
condition|)
name|rp_flag
operator|=
name|TRUE
expr_stmt|;
else|else
name|rp_flag
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|join_prune
condition|)
block|{
case|case
name|PIM_ACTION_JOIN
case|:
if|if
condition|(
name|rp_flag
operator|==
name|TRUE
condition|)
name|data_ptr
operator|=
name|bjpm
operator|->
name|rp_list_join
operator|+
name|bjpm
operator|->
name|rp_list_join_size
expr_stmt|;
else|else
name|data_ptr
operator|=
name|bjpm
operator|->
name|join_list
operator|+
name|bjpm
operator|->
name|join_list_size
expr_stmt|;
break|break;
case|case
name|PIM_ACTION_PRUNE
case|:
if|if
condition|(
name|rp_flag
operator|==
name|TRUE
condition|)
name|data_ptr
operator|=
name|bjpm
operator|->
name|rp_list_join
operator|+
name|bjpm
operator|->
name|rp_list_join_size
expr_stmt|;
else|else
name|data_ptr
operator|=
name|bjpm
operator|->
name|prune_list
operator|+
name|bjpm
operator|->
name|prune_list_size
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|flags
operator||=
name|USADDR_S_BIT
expr_stmt|;
comment|/* Mandatory for PIMv2 */
if|if
condition|(
name|addr_flags
operator|&
name|MRTF_RP
condition|)
name|flags
operator||=
name|USADDR_RP_BIT
expr_stmt|;
if|if
condition|(
name|addr_flags
operator|&
name|MRTF_WC
condition|)
name|flags
operator||=
name|USADDR_WC_BIT
expr_stmt|;
name|PUT_ESADDR6
argument_list|(
name|source
operator|->
name|sin6_addr
argument_list|,
name|src_msklen
argument_list|,
name|flags
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|join_prune
condition|)
block|{
case|case
name|PIM_ACTION_JOIN
case|:
if|if
condition|(
name|rp_flag
operator|==
name|TRUE
condition|)
block|{
name|bjpm
operator|->
name|rp_list_join_size
operator|=
name|data_ptr
operator|-
name|bjpm
operator|->
name|rp_list_join
expr_stmt|;
name|bjpm
operator|->
name|rp_list_join_number
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bjpm
operator|->
name|join_list_size
operator|=
name|data_ptr
operator|-
name|bjpm
operator|->
name|join_list
expr_stmt|;
name|bjpm
operator|->
name|join_addr_number
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|PIM_ACTION_PRUNE
case|:
if|if
condition|(
name|rp_flag
operator|==
name|TRUE
condition|)
block|{
name|bjpm
operator|->
name|rp_list_prune_size
operator|=
name|data_ptr
operator|-
name|bjpm
operator|->
name|rp_list_prune
expr_stmt|;
name|bjpm
operator|->
name|rp_list_prune_number
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bjpm
operator|->
name|prune_list_size
operator|=
name|data_ptr
operator|-
name|bjpm
operator|->
name|prune_list
expr_stmt|;
name|bjpm
operator|->
name|prune_addr_number
operator|++
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* TODO: check again the size of the buffers */
end_comment

begin_function
specifier|static
name|build_jp_message_t
modifier|*
name|get_jp6_working_buff
parameter_list|()
block|{
name|build_jp_message_t
modifier|*
name|bjpm_ptr
decl_stmt|;
if|if
condition|(
name|build_jp_message_pool_counter
operator|==
literal|0
condition|)
block|{
name|bjpm_ptr
operator|=
operator|(
name|build_jp_message_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|build_jp_message_t
argument_list|)
argument_list|)
expr_stmt|;
name|bjpm_ptr
operator|->
name|next
operator|=
operator|(
name|build_jp_message_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|bjpm_ptr
operator|->
name|jp_message
operator|=
operator|(
name|u_int8
operator|*
operator|)
name|malloc
argument_list|(
name|MAX_JP_MESSAGE_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|pim_jp_encod_grp_t
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bjpm_ptr
operator|->
name|jp_message_size
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|join_list_size
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|join_addr_number
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|join_list
operator|=
operator|(
name|u_int8
operator|*
operator|)
name|malloc
argument_list|(
name|MAX_JOIN_LIST_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bjpm_ptr
operator|->
name|prune_list_size
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|prune_addr_number
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|prune_list
operator|=
operator|(
name|u_int8
operator|*
operator|)
name|malloc
argument_list|(
name|MAX_PRUNE_LIST_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bjpm_ptr
operator|->
name|rp_list_join_size
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|rp_list_join_number
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|rp_list_join
operator|=
operator|(
name|u_int8
operator|*
operator|)
name|malloc
argument_list|(
name|MAX_JOIN_LIST_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bjpm_ptr
operator|->
name|rp_list_prune_size
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|rp_list_prune_number
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|rp_list_prune
operator|=
operator|(
name|u_int8
operator|*
operator|)
name|malloc
argument_list|(
name|MAX_PRUNE_LIST_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|pim6_encod_src_addr_t
argument_list|)
argument_list|)
expr_stmt|;
name|bjpm_ptr
operator|->
name|curr_group
operator|=
name|sockaddr6_any
expr_stmt|;
name|bjpm_ptr
operator|->
name|curr_group_msklen
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|holdtime
operator|=
literal|0
expr_stmt|;
return|return
name|bjpm_ptr
return|;
block|}
else|else
block|{
name|bjpm_ptr
operator|=
name|build_jp_message_pool
expr_stmt|;
name|build_jp_message_pool
operator|=
name|build_jp_message_pool
operator|->
name|next
expr_stmt|;
name|build_jp_message_pool_counter
operator|--
expr_stmt|;
name|bjpm_ptr
operator|->
name|jp_message_size
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|join_list_size
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|join_addr_number
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|prune_list_size
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|prune_addr_number
operator|=
literal|0
expr_stmt|;
name|bjpm_ptr
operator|->
name|curr_group
operator|=
name|sockaddr6_any
expr_stmt|;
name|bjpm_ptr
operator|->
name|curr_group_msklen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|bjpm_ptr
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|return_jp6_working_buff
parameter_list|(
name|pim_nbr
parameter_list|)
name|pim_nbr_entry_t
modifier|*
name|pim_nbr
decl_stmt|;
block|{
name|build_jp_message_t
modifier|*
name|bjpm_ptr
init|=
name|pim_nbr
operator|->
name|build_jp_message
decl_stmt|;
if|if
condition|(
name|bjpm_ptr
operator|==
operator|(
name|build_jp_message_t
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/* Don't waste memory by keeping too many free buffers */
comment|/* TODO: check/modify the definitions for POOL_NUMBER and size */
if|if
condition|(
name|build_jp_message_pool_counter
operator|>=
name|MAX_JP_MESSAGE_POOL_NUMBER
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bjpm_ptr
operator|->
name|jp_message
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bjpm_ptr
operator|->
name|join_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bjpm_ptr
operator|->
name|prune_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bjpm_ptr
operator|->
name|rp_list_join
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bjpm_ptr
operator|->
name|rp_list_prune
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bjpm_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bjpm_ptr
operator|->
name|next
operator|=
name|build_jp_message_pool
expr_stmt|;
name|build_jp_message_pool
operator|=
name|bjpm_ptr
expr_stmt|;
name|build_jp_message_pool_counter
operator|++
expr_stmt|;
block|}
name|pim_nbr
operator|->
name|build_jp_message
operator|=
operator|(
name|build_jp_message_t
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TODO: XXX: Currently, the (*,*,RP) stuff goes at the end of the Join/Prune  * message. However, this particular implementation of PIM processes the  * Join/Prune messages faster if (*,*,RP) is at the beginning. Modify some of  * the functions below such that the outgoing messages place (*,*,RP) at the  * beginning, not at the end.  */
end_comment

begin_function
specifier|static
name|void
name|pack_jp6_message
parameter_list|(
name|pim_nbr
parameter_list|)
name|pim_nbr_entry_t
modifier|*
name|pim_nbr
decl_stmt|;
block|{
name|build_jp_message_t
modifier|*
name|bjpm
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|bjpm
operator|=
name|pim_nbr
operator|->
name|build_jp_message
expr_stmt|;
if|if
condition|(
operator|(
name|bjpm
operator|==
operator|(
name|build_jp_message_t
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|inet6_equal
argument_list|(
operator|&
name|bjpm
operator|->
name|curr_group
argument_list|,
operator|&
name|sockaddr6_any
argument_list|)
operator|)
condition|)
return|return;
name|data_ptr
operator|=
name|bjpm
operator|->
name|jp_message
operator|+
name|bjpm
operator|->
name|jp_message_size
expr_stmt|;
name|PUT_EGADDR6
argument_list|(
name|bjpm
operator|->
name|curr_group
operator|.
name|sin6_addr
argument_list|,
name|bjpm
operator|->
name|curr_group_msklen
argument_list|,
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|bjpm
operator|->
name|join_addr_number
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|bjpm
operator|->
name|prune_addr_number
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bjpm
operator|->
name|join_list
argument_list|,
name|data_ptr
argument_list|,
name|bjpm
operator|->
name|join_list_size
argument_list|)
expr_stmt|;
name|data_ptr
operator|+=
name|bjpm
operator|->
name|join_list_size
expr_stmt|;
name|bcopy
argument_list|(
name|bjpm
operator|->
name|prune_list
argument_list|,
name|data_ptr
argument_list|,
name|bjpm
operator|->
name|prune_list_size
argument_list|)
expr_stmt|;
name|data_ptr
operator|+=
name|bjpm
operator|->
name|prune_list_size
expr_stmt|;
name|bjpm
operator|->
name|jp_message_size
operator|=
operator|(
name|data_ptr
operator|-
name|bjpm
operator|->
name|jp_message
operator|)
expr_stmt|;
name|bjpm
operator|->
name|join_list_size
operator|=
literal|0
expr_stmt|;
name|bjpm
operator|->
name|join_addr_number
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* isn't this necessary? */
block|bjpm->rp_list_join_size = 0;     bjpm->rp_list_join_number = 0;
endif|#
directive|endif
name|bjpm
operator|->
name|prune_list_size
operator|=
literal|0
expr_stmt|;
name|bjpm
operator|->
name|prune_addr_number
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* isn't this necessary? */
block|bjpm->rp_list_prune_size = 0;     bjpm->rp_list_prune_number = 0;
endif|#
directive|endif
operator|(
operator|*
name|bjpm
operator|->
name|num_groups_ptr
operator|)
operator|++
expr_stmt|;
name|bjpm
operator|->
name|curr_group
operator|=
name|sockaddr6_any
expr_stmt|;
name|bjpm
operator|->
name|curr_group_msklen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|bjpm
operator|->
name|num_groups_ptr
operator|==
operator|(
operator|(
name|u_int8
operator|)
operator|~
literal|0
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|bjpm
operator|->
name|rp_list_join_number
operator|+
name|bjpm
operator|->
name|rp_list_prune_number
condition|)
block|{
comment|/* Add the (*,*,RP) at the end */
name|data_ptr
operator|=
name|bjpm
operator|->
name|jp_message
operator|+
name|bjpm
operator|->
name|jp_message_size
expr_stmt|;
name|PUT_EGADDR6
argument_list|(
name|sockaddr6_d
operator|.
name|sin6_addr
argument_list|,
name|STAR_STAR_RP_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|bjpm
operator|->
name|rp_list_join_number
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|bjpm
operator|->
name|rp_list_prune_number
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bjpm
operator|->
name|rp_list_join
argument_list|,
name|data_ptr
argument_list|,
name|bjpm
operator|->
name|rp_list_join_size
argument_list|)
expr_stmt|;
name|data_ptr
operator|+=
name|bjpm
operator|->
name|rp_list_join_size
expr_stmt|;
name|bcopy
argument_list|(
name|bjpm
operator|->
name|rp_list_prune
argument_list|,
name|data_ptr
argument_list|,
name|bjpm
operator|->
name|rp_list_prune_size
argument_list|)
expr_stmt|;
name|data_ptr
operator|+=
name|bjpm
operator|->
name|rp_list_prune_size
expr_stmt|;
name|bjpm
operator|->
name|jp_message_size
operator|=
operator|(
name|data_ptr
operator|-
name|bjpm
operator|->
name|jp_message
operator|)
expr_stmt|;
name|bjpm
operator|->
name|rp_list_join_size
operator|=
literal|0
expr_stmt|;
name|bjpm
operator|->
name|rp_list_join_number
operator|=
literal|0
expr_stmt|;
name|bjpm
operator|->
name|rp_list_prune_size
operator|=
literal|0
expr_stmt|;
name|bjpm
operator|->
name|rp_list_prune_number
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|bjpm
operator|->
name|num_groups_ptr
operator|)
operator|++
expr_stmt|;
block|}
name|send_jp6_message
argument_list|(
name|pim_nbr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pack_and_send_jp6_message
parameter_list|(
name|pim_nbr
parameter_list|)
name|pim_nbr_entry_t
modifier|*
name|pim_nbr
decl_stmt|;
block|{
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|build_jp_message_t
modifier|*
name|bjpm
decl_stmt|;
if|if
condition|(
operator|(
name|pim_nbr
operator|==
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
operator|(
name|bjpm
operator|=
name|pim_nbr
operator|->
name|build_jp_message
operator|)
operator|==
operator|(
name|build_jp_message_t
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|pack_jp6_message
argument_list|(
name|pim_nbr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bjpm
operator|->
name|rp_list_join_number
operator|+
name|bjpm
operator|->
name|rp_list_prune_number
condition|)
block|{
comment|/* Add the (*,*,RP) at the end */
name|data_ptr
operator|=
name|bjpm
operator|->
name|jp_message
operator|+
name|bjpm
operator|->
name|jp_message_size
expr_stmt|;
name|PUT_EGADDR6
argument_list|(
name|sockaddr6_d
operator|.
name|sin6_addr
argument_list|,
name|STAR_STAR_RP_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|bjpm
operator|->
name|rp_list_join_number
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTSHORT
argument_list|(
name|bjpm
operator|->
name|rp_list_prune_number
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bjpm
operator|->
name|rp_list_join
argument_list|,
name|data_ptr
argument_list|,
name|bjpm
operator|->
name|rp_list_join_size
argument_list|)
expr_stmt|;
name|data_ptr
operator|+=
name|bjpm
operator|->
name|rp_list_join_size
expr_stmt|;
name|bcopy
argument_list|(
name|bjpm
operator|->
name|rp_list_prune
argument_list|,
name|data_ptr
argument_list|,
name|bjpm
operator|->
name|rp_list_prune_size
argument_list|)
expr_stmt|;
name|data_ptr
operator|+=
name|bjpm
operator|->
name|rp_list_prune_size
expr_stmt|;
name|bjpm
operator|->
name|jp_message_size
operator|=
operator|(
name|data_ptr
operator|-
name|bjpm
operator|->
name|jp_message
operator|)
expr_stmt|;
name|bjpm
operator|->
name|rp_list_join_size
operator|=
literal|0
expr_stmt|;
name|bjpm
operator|->
name|rp_list_join_number
operator|=
literal|0
expr_stmt|;
name|bjpm
operator|->
name|rp_list_prune_size
operator|=
literal|0
expr_stmt|;
name|bjpm
operator|->
name|rp_list_prune_number
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|bjpm
operator|->
name|num_groups_ptr
operator|)
operator|++
expr_stmt|;
block|}
name|send_jp6_message
argument_list|(
name|pim_nbr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_jp6_message
parameter_list|(
name|pim_nbr
parameter_list|)
name|pim_nbr_entry_t
modifier|*
name|pim_nbr
decl_stmt|;
block|{
name|u_int16
name|datalen
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
name|datalen
operator|=
name|pim_nbr
operator|->
name|build_jp_message
operator|->
name|jp_message_size
expr_stmt|;
name|mifi
operator|=
name|pim_nbr
operator|->
name|vifi
expr_stmt|;
name|bcopy
argument_list|(
name|pim_nbr
operator|->
name|build_jp_message
operator|->
name|jp_message
argument_list|,
name|pim6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|allpim6routers_group
argument_list|,
name|PIM_JOIN_PRUNE
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_out_pim6_join_prune
operator|++
expr_stmt|;
name|return_jp6_working_buff
argument_list|(
name|pim_nbr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************  *                        PIM_ASSERT  ************************************************************************/
end_comment

begin_function
name|int
name|receive_pim6_assert
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|pim_message
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|char
modifier|*
name|pim_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|mifi_t
name|mifi
decl_stmt|;
name|pim6_encod_uni_addr_t
name|eusaddr
decl_stmt|;
name|pim6_encod_grp_addr_t
name|egaddr
decl_stmt|;
name|struct
name|sockaddr_in6
name|source
decl_stmt|,
name|group
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|,
modifier|*
name|mrtentry_ptr2
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|u_int32
name|assert_preference
decl_stmt|;
name|u_int32
name|assert_metric
decl_stmt|;
name|u_int32
name|assert_rptbit
decl_stmt|;
name|u_int32
name|local_metric
decl_stmt|;
name|u_int32
name|local_preference
decl_stmt|;
name|u_int8
name|local_rptbit
decl_stmt|;
name|u_int8
name|local_wins
decl_stmt|;
name|pim_nbr_entry_t
modifier|*
name|original_upstream_router
decl_stmt|;
if|if
condition|(
operator|(
name|mifi
operator|=
name|find_vif_direct
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
comment|/* 	 * Either a local vif or somehow received PIM_ASSERT from 	 * non-directly connected router. Ignore it. 	 */
if|if
condition|(
name|local_address
argument_list|(
name|src
argument_list|)
operator|==
name|NO_VIF
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Ignoring PIM_ASSERT from non-neighbor router %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|mifi
index|]
expr_stmt|;
name|v
operator|->
name|uv_in_pim6_assert
operator|++
expr_stmt|;
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
operator|(
name|VIFF_DOWN
operator||
name|VIFF_DISABLED
operator||
name|VIFF_NONBRS
operator||
name|MIFF_REGISTER
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Shoudn't come on this interface */
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
comment|/* Get the group and source addresses */
name|GET_EGADDR6
argument_list|(
operator|&
name|egaddr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_EUADDR6
argument_list|(
operator|&
name|eusaddr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/* Get the metric related info */
name|GET_HOSTLONG
argument_list|(
name|assert_preference
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTLONG
argument_list|(
name|assert_metric
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|assert_rptbit
operator|=
name|assert_preference
operator|&
name|PIM_ASSERT_RPT_BIT
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|eusaddr
operator|.
name|unicast_addr
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|egaddr
operator|.
name|mcast_addr
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* Find the longest "active" entry, i.e. the one with a kernel mirror */
if|if
condition|(
name|assert_rptbit
condition|)
block|{
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
name|NULL
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_WC
operator||
name|MRTF_PMBR
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_KERNEL_CACHE
operator|)
condition|)
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_WC
condition|)
block|{
name|mrtentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|mrtlink
expr_stmt|;
block|}
block|}
else|else
block|{
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
operator||
name|MRTF_WC
operator||
name|MRTF_PMBR
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_KERNEL_CACHE
operator|)
condition|)
block|{
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SG
condition|)
block|{
name|mrtentry_ptr2
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|grp_route
expr_stmt|;
if|if
condition|(
operator|(
name|mrtentry_ptr2
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|mrtentry_ptr2
operator|->
name|flags
operator|&
name|MRTF_KERNEL_CACHE
operator|)
condition|)
name|mrtentry_ptr
operator|=
name|mrtentry_ptr2
expr_stmt|;
else|else
name|mrtentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|mrtlink
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_WC
condition|)
name|mrtentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|mrtlink
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_KERNEL_CACHE
operator|)
operator|)
condition|)
comment|/* No routing entry or not "active" entry. Ignore the assert */
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Prepare the local preference and metric */
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_PMBR
operator|)
operator|||
operator|(
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SG
operator|)
operator|&&
operator|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Either (S,G) (toward S) or (*,*,RP). */
comment|/* TODO: XXX: get the info from mrtentry, or source or from kernel ? */
comment|/* 	 * local_metric = mrtentry_ptr->source->metric; local_preference = 	 * mrtentry_ptr->source->preference; 	 */
name|local_metric
operator|=
name|mrtentry_ptr
operator|->
name|metric
expr_stmt|;
name|local_preference
operator|=
name|mrtentry_ptr
operator|->
name|preference
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Should be (*,G) or (S,G)RPbit entry. Get what we need from the RP 	 * info. 	 */
comment|/* TODO: get the info from mrtentry, RP-entry or kernel? */
comment|/* 	 * local_metric = 	 * mrtentry_ptr->group->active_rp_grp->rp->rpentry->metric; 	 * local_preference = 	 * mrtentry_ptr->group->active_rp_grp->rp->rpentry->preference; 	 */
name|local_metric
operator|=
name|mrtentry_ptr
operator|->
name|metric
expr_stmt|;
name|local_preference
operator|=
name|mrtentry_ptr
operator|->
name|preference
expr_stmt|;
block|}
name|local_rptbit
operator|=
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
operator|)
expr_stmt|;
if|if
condition|(
name|local_rptbit
condition|)
comment|/* Make the RPT bit the most significant one */
name|local_preference
operator||=
name|PIM_ASSERT_RPT_BIT
expr_stmt|;
if|if
condition|(
name|IF_ISSET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
condition|)
block|{
comment|/* The ASSERT has arrived on oif */
comment|/* 	 * TODO: XXX: here the processing order is different from the spec. 	 * The spec requires first eventually to create a routing entry (see 	 * 3.5.2.1(1) and then compare the metrics. Here we compare first the 	 * metrics with the existing longest match entry and if we lose then 	 * create a new entry and compare again. This saves us the 	 * unnecessary creating of a routing entry if we anyway are going to 	 * lose: for example the local (*,*,RP) vs the remote (*,*,RP) or 	 * (*,G) 	 */
name|local_wins
operator|=
name|compare_metrics
argument_list|(
name|local_preference
argument_list|,
name|local_metric
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
name|assert_preference
argument_list|,
name|assert_metric
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_wins
operator|==
name|TRUE
condition|)
block|{
comment|/* TODO: verify the parameters */
name|send_pim6_assert
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|mifi
argument_list|,
name|mrtentry_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* Create a "better" routing entry and try again */
if|if
condition|(
operator|(
name|assert_rptbit
operator|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_PMBR
operator|)
condition|)
block|{
comment|/* The matching entry was (*,*,RP). Create (*,G) */
name|mrtentry_ptr2
operator|=
name|find_route
argument_list|(
name|NULL
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_WC
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|assert_rptbit
operator|)
operator|&&
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
operator|(
name|MRTF_WC
operator||
name|MRTF_PMBR
operator|)
operator|)
condition|)
block|{
comment|/* create (S,G) */
name|mrtentry_ptr2
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We have no chance to win. Give up and prune the oif */
name|mrtentry_ptr2
operator|=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mrtentry_ptr2
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|mrtentry_ptr2
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
comment|/* 	     * TODO: XXX: The spec doesn't say what entry timer value to use 	     * when the routing entry is created because of asserts. 	     */
name|SET_TIMER
argument_list|(
name|mrtentry_ptr2
operator|->
name|timer
argument_list|,
name|pim_data_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr2
operator|->
name|flags
operator|&
name|MRTF_RP
condition|)
block|{
comment|/* 		 * Either (*,G) or (S,G)RPbit entry. Get what we need from 		 * the RP info. 		 */
comment|/* TODO: where to get the metric+preference from? */
comment|/* 		 * local_metric = 		 * mrtentry_ptr->group->active_rp_grp->rp->rpentry->metric; 		 * local_preference = 		 * mrtentry_ptr->group->active_rp_grp->rp->rpentry->preference 		 * ; 		 */
name|local_metric
operator|=
name|mrtentry_ptr
operator|->
name|metric
expr_stmt|;
name|local_preference
operator|=
name|mrtentry_ptr
operator|->
name|preference
expr_stmt|;
name|local_preference
operator||=
name|PIM_ASSERT_RPT_BIT
expr_stmt|;
block|}
else|else
block|{
comment|/* (S,G) toward the source */
comment|/* TODO: where to get the metric from ? */
comment|/* 		 * local_metric = mrtentry_ptr->source->metric; 		 * local_preference = mrtentry_ptr->source->preference; 		 */
name|local_metric
operator|=
name|mrtentry_ptr
operator|->
name|metric
expr_stmt|;
name|local_preference
operator|=
name|mrtentry_ptr
operator|->
name|preference
expr_stmt|;
block|}
name|local_wins
operator|=
name|compare_metrics
argument_list|(
name|local_preference
argument_list|,
name|local_metric
argument_list|,
operator|&
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
name|assert_preference
argument_list|,
name|assert_metric
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_wins
operator|==
name|TRUE
condition|)
block|{
comment|/* TODO: verify the parameters */
name|send_pim6_assert
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|mifi
argument_list|,
name|mrtentry_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* We lost, but have created the entry which has to be pruned */
name|mrtentry_ptr
operator|=
name|mrtentry_ptr2
expr_stmt|;
block|}
comment|/* Have to remove that outgoing vifi from mrtentry_ptr */
name|IF_SET
argument_list|(
name|mifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|timer
operator|<
name|pim_assert_timeout
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|pim_assert_timeout
argument_list|)
expr_stmt|;
comment|/* 	 * TODO: XXX: check that the timer of all affected routing entries 	 * has been restarted. 	 */
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Doesn't matter the return value */
block|}
comment|/* End of assert received on oif */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|incoming
operator|==
name|mifi
condition|)
block|{
comment|/* Assert received on iif */
if|if
condition|(
name|assert_rptbit
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* The locally used upstream router will win 				 * the assert, so don't change it. */
block|}
comment|/* 	 * TODO: where to get the local metric and preference from? system 	 * call or mrtentry is fine? 	 */
name|local_metric
operator|=
name|mrtentry_ptr
operator|->
name|metric
expr_stmt|;
name|local_preference
operator|=
name|mrtentry_ptr
operator|->
name|preference
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
condition|)
name|local_preference
operator||=
name|PIM_ASSERT_RPT_BIT
expr_stmt|;
name|local_wins
operator|=
name|compare_metrics
argument_list|(
name|local_preference
argument_list|,
name|local_metric
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|upstream
operator|->
name|address
argument_list|,
name|assert_preference
argument_list|,
name|assert_metric
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_wins
operator|==
name|TRUE
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* return whatever */
comment|/* The upstream must be changed to the winner */
name|mrtentry_ptr
operator|->
name|preference
operator|=
name|assert_preference
expr_stmt|;
name|mrtentry_ptr
operator|->
name|metric
operator|=
name|assert_metric
expr_stmt|;
name|mrtentry_ptr
operator|->
name|upstream
operator|=
name|find_pim6_nbr
argument_list|(
name|src
argument_list|)
expr_stmt|;
comment|/* Check if the upstream router is different from the original one */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_PMBR
condition|)
name|original_upstream_router
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|upstream
expr_stmt|;
elseif|else
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
condition|)
name|original_upstream_router
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|upstream
expr_stmt|;
else|else
name|original_upstream_router
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|upstream
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|upstream
operator|!=
name|original_upstream_router
condition|)
block|{
name|mrtentry_ptr
operator|->
name|flags
operator||=
name|MRTF_ASSERTED
expr_stmt|;
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|assert_timer
argument_list|,
name|pim_assert_timeout
argument_list|)
expr_stmt|;
block|}
else|else
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_ASSERTED
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_function
name|int
name|send_pim6_assert
parameter_list|(
name|source
parameter_list|,
name|group
parameter_list|,
name|mifi
parameter_list|,
name|mrtentry_ptr
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|source
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|group
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
block|{
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|u_int8
modifier|*
name|data_start_ptr
decl_stmt|;
name|u_int32
name|local_preference
decl_stmt|;
name|u_int32
name|local_metric
decl_stmt|;
name|srcentry_t
modifier|*
name|srcentry_ptr
decl_stmt|;
comment|/* Don't send assert if the outgoing interface a tunnel or register vif */
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
operator|(
name|MIFF_REGISTER
operator||
name|VIFF_TUNNEL
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
name|data_start_ptr
operator|=
name|data_ptr
expr_stmt|;
name|PUT_EGADDR6
argument_list|(
name|group
operator|->
name|sin6_addr
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
literal|0
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_EUADDR6
argument_list|(
name|source
operator|->
name|sin6_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/*      * TODO: XXX: where to get the metric from: srcentry_ptr or mrtentry_ptr      * or from the kernel?      */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_PMBR
condition|)
block|{
comment|/* (*,*,RP) */
name|srcentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|source
expr_stmt|;
comment|/* 	 * TODO: set_incoming(srcentry_ptr, PIM_IIF_RP); 	 */
block|}
elseif|else
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
condition|)
block|{
comment|/* (*,G) or (S,G)RPbit (iif toward RP) */
name|srcentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
expr_stmt|;
comment|/* 	     * TODO: set_incoming(srcentry_ptr, PIM_IIF_RP); 	     */
block|}
else|else
block|{
comment|/* (S,G) toward S */
name|srcentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|source
expr_stmt|;
comment|/* 	     * TODO: set_incoming(srcentry_ptr, PIM_IIF_SOURCE); 	     */
block|}
comment|/*      * TODO: check again! local_metric = srcentry_ptr->metric;      * local_preference = srcentry_ptr->preference;      */
name|local_metric
operator|=
name|mrtentry_ptr
operator|->
name|metric
expr_stmt|;
name|local_preference
operator|=
name|mrtentry_ptr
operator|->
name|preference
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
condition|)
name|local_preference
operator||=
name|PIM_ASSERT_RPT_BIT
expr_stmt|;
name|PUT_HOSTLONG
argument_list|(
name|local_preference
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|PUT_HOSTLONG
argument_list|(
name|local_metric
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|allpim6routers_group
argument_list|,
name|PIM_ASSERT
argument_list|,
name|data_ptr
operator|-
name|data_start_ptr
argument_list|)
expr_stmt|;
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_out_pim6_assert
operator|++
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the local win, otherwise FALSE */
end_comment

begin_function
specifier|static
name|int
name|compare_metrics
parameter_list|(
name|local_preference
parameter_list|,
name|local_metric
parameter_list|,
name|local_address
parameter_list|,
name|remote_preference
parameter_list|,
name|remote_metric
parameter_list|,
name|remote_address
parameter_list|)
name|u_int32
name|local_preference
decl_stmt|;
name|u_int32
name|local_metric
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|local_address
decl_stmt|;
name|u_int32
name|remote_preference
decl_stmt|;
name|u_int32
name|remote_metric
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|remote_address
decl_stmt|;
block|{
comment|/* Now lets see who has a smaller gun (aka "asserts war") */
comment|/*      * FYI, the smaller gun...err metric wins, but if the same caliber, then      * the bigger network address wins. The order of threatment is:      * preference, metric, address.      */
comment|/*      * The RPT bits are already included as the most significant bits of the      * preferences.      */
if|if
condition|(
name|remote_preference
operator|>
name|local_preference
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|remote_preference
operator|<
name|local_preference
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|remote_metric
operator|>
name|local_metric
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|remote_metric
operator|<
name|local_metric
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|inet6_greaterthan
argument_list|(
name|local_address
argument_list|,
name|remote_address
argument_list|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/************************************************************************  *                        PIM_BOOTSTRAP  ************************************************************************/
end_comment

begin_define
define|#
directive|define
name|PIM6_BOOTSTRAP_MINLEN
value|(PIM_MINLEN + PIM6_ENCODE_UNI_ADDR_LEN)
end_define

begin_function
name|int
name|receive_pim6_bootstrap
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|pim_message
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|pim_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|u_int8
modifier|*
name|max_data_ptr
decl_stmt|;
name|u_int16
name|new_bsr_fragment_tag
decl_stmt|;
name|u_int8
name|new_bsr_hash_masklen
decl_stmt|;
name|u_int8
name|new_bsr_priority
decl_stmt|;
name|pim6_encod_uni_addr_t
name|new_bsr_uni_addr
decl_stmt|;
name|struct
name|sockaddr_in6
name|new_bsr_address
decl_stmt|;
name|struct
name|rpfctl
name|rpfc
decl_stmt|;
name|pim_nbr_entry_t
modifier|*
name|n
decl_stmt|,
modifier|*
name|rpf_neighbor
decl_stmt|;
name|struct
name|sockaddr_in6
name|neighbor_addr
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|,
name|incoming
init|=
name|NO_VIF
decl_stmt|;
name|int
name|min_datalen
decl_stmt|;
name|pim6_encod_grp_addr_t
name|curr_group_addr
decl_stmt|;
name|pim6_encod_uni_addr_t
name|curr_rp_addr
decl_stmt|;
name|u_int8
name|curr_rp_count
decl_stmt|;
name|u_int8
name|curr_frag_rp_count
decl_stmt|;
name|u_int16
name|reserved_short
decl_stmt|;
name|u_int16
name|curr_rp_holdtime
decl_stmt|;
name|u_int8
name|curr_rp_priority
decl_stmt|;
name|u_int8
name|reserved_byte
decl_stmt|;
name|struct
name|in6_addr
name|curr_group_mask
decl_stmt|;
name|grp_mask_t
modifier|*
name|grp_mask_ptr
decl_stmt|;
name|grp_mask_t
modifier|*
name|grp_mask_next
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|grp_rp_entry_ptr
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|grp_rp_entry_next
decl_stmt|;
name|struct
name|sockaddr_in6
name|prefix_h
decl_stmt|,
name|prefix_h2
decl_stmt|,
name|group_
decl_stmt|,
name|rpp_
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
if|if
condition|(
operator|(
name|mifi
operator|=
name|find_vif_direct
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
comment|/* 	 * Either a local vif or somehow received PIM_BOOTSTRAP from 	 * non-directly connected router. Ignore it. 	 */
if|if
condition|(
name|local_address
argument_list|(
name|src
argument_list|)
operator|==
name|NO_VIF
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"Ignoring PIM_BOOTSTRAP from non-neighbor router %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* sanity check for the minimum length */
if|if
condition|(
name|datalen
operator|<
name|PIM6_BOOTSTRAP_MINLEN
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: Bootstrap message size(%u) is"
literal|" too short from %s"
argument_list|,
name|datalen
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|v
operator|=
operator|&
name|uvifs
index|[
name|mifi
index|]
expr_stmt|;
name|v
operator|->
name|uv_in_pim6_bootsrap
operator|++
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
comment|/* Parse the PIM_BOOTSTRAP message */
name|GET_HOSTSHORT
argument_list|(
name|new_bsr_fragment_tag
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|new_bsr_hash_masklen
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|new_bsr_priority
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_EUADDR6
argument_list|(
operator|&
name|new_bsr_uni_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/*       * BSR address must be a global unicast address.      * [draft-ietf-pim-ipv6-01.txt sec 4.5]      */
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|new_bsr_uni_addr
operator|.
name|unicast_addr
argument_list|)
operator|||
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|new_bsr_uni_addr
operator|.
name|unicast_addr
argument_list|)
operator|||
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|new_bsr_uni_addr
operator|.
name|unicast_addr
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: invalid BSR address: %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|new_bsr_uni_addr
operator|.
name|unicast_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|new_bsr_address
operator|.
name|sin6_addr
operator|=
name|new_bsr_uni_addr
operator|.
name|unicast_addr
expr_stmt|;
name|new_bsr_address
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|new_bsr_address
argument_list|)
expr_stmt|;
name|new_bsr_address
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|new_bsr_address
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|new_bsr_address
argument_list|,
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_address
argument_list|(
operator|&
name|new_bsr_address
argument_list|)
operator|!=
name|NO_VIF
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_RPF | DEBUG_PIM_BOOTSTRAP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: Bootstrap from myself(%s), ignored."
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|new_bsr_address
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* The new BSR is one of my local addresses */
block|}
comment|/*      * Compare the current BSR priority with the priority of the BSR included      * in the message.      */
comment|/*      * TODO: if I am just starting and will become the BSR, I should accept      * the message coming from the current BSR and get the current      * Cand-RP-Set.      */
if|if
condition|(
operator|(
name|curr_bsr_priority
operator|>
name|new_bsr_priority
operator|)
operator|||
operator|(
operator|(
name|curr_bsr_priority
operator|==
name|new_bsr_priority
operator|)
operator|&&
operator|(
name|inet6_greaterthan
argument_list|(
operator|&
name|curr_bsr_address
argument_list|,
operator|&
name|new_bsr_address
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* The message's BSR is less preferred than the current BSR */
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: BSR(%s, prio=%d) is less preferred"
literal|" than the current BSR(%s, prio=%d)"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|new_bsr_address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|new_bsr_priority
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|curr_bsr_address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|curr_bsr_priority
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Ignore the received BSR message */
block|}
comment|/* Check the iif, if this was PIM-ROUTERS multicast */
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
operator|&
name|allpim6routers_group
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|k_req_incoming
argument_list|(
operator|&
name|new_bsr_address
argument_list|,
operator|&
name|rpfc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rpfc
operator|.
name|iif
operator|==
name|NO_VIF
operator|)
operator|||
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|rpfc
operator|.
name|rpfneighbor
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* coudn't find a route to the BSR */
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: can't find a route to the BSR(%s)"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|new_bsr_address
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|neighbor_addr
operator|=
operator|*
name|src
expr_stmt|;
name|incoming
operator|=
name|rpfc
operator|.
name|iif
expr_stmt|;
if|if
condition|(
name|uvifs
index|[
name|incoming
index|]
operator|.
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|MIFF_REGISTER
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: Bootstrap from an invalid interface(%s)"
argument_list|,
name|uvifs
index|[
name|incoming
index|]
operator|.
name|uv_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Shoudn't arrive on that interface */
block|}
comment|/* Find the upstream router */
for|for
control|(
name|n
operator|=
name|uvifs
index|[
name|incoming
index|]
operator|.
name|uv_pim_neighbors
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|inet6_lessthan
argument_list|(
operator|&
name|neighbor_addr
argument_list|,
operator|&
name|n
operator|->
name|address
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|neighbor_addr
argument_list|,
operator|&
name|n
operator|->
name|address
argument_list|)
condition|)
block|{
name|rpf_neighbor
operator|=
name|n
expr_stmt|;
break|break;
block|}
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: Bootstrap from an unrecognized "
literal|"neighbor(%s) on %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|neighbor_addr
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|uvifs
index|[
name|incoming
index|]
operator|.
name|uv_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* No neighbor toward BSR found */
block|}
comment|/* redundant checks? */
if|if
condition|(
operator|(
name|n
operator|==
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Sender of this message is not the RPF*/
block|}
comment|/* neighbor */
if|if
condition|(
operator|!
operator|(
name|inet6_equal
argument_list|(
operator|&
name|n
operator|->
name|address
argument_list|,
name|src
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|local_address
argument_list|(
name|dst
argument_list|)
operator|==
name|NO_VIF
condition|)
comment|/* 	     * TODO: XXX: this situation should be handled earlier: The 	     * destination is neither ALL_PIM_ROUTERS nor me 	     */
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: Bootstrap with an invalid dst(%s)"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* Probably unicasted from the current DR */
if|if
condition|(
name|cand_rp_list
operator|!=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 	     * Hmmm, I do have a Cand-RP-list, but some neighbor has a 	     * different opinion and is unicasting it to me. Ignore this guy. 	     */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: Bootstrap received but we already "
literal|"have RPs. ignored."
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
for|for
control|(
name|mifi
operator|=
literal|0
init|;
name|mifi
operator|<
name|numvifs
condition|;
name|mifi
operator|++
control|)
block|{
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
name|dst
argument_list|)
condition|)
block|{
name|incoming
operator|=
name|mifi
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|incoming
operator|==
name|NO_VIF
condition|)
block|{
comment|/* Cannot find the receiving iif toward that DR */
name|IF_DEBUG
argument_list|(
argument|DEBUG_RPF | DEBUG_PIM_BOOTSTRAP
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Unicast boostrap message from %s to %s ignored: "
literal|"cannot find iif"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 	 * TODO: check the sender is directly connected and I am really the 	 * DR. 	 */
block|}
if|if
condition|(
name|cand_rp_flag
operator|==
name|TRUE
condition|)
block|{
comment|/* If change in the BSR address, send immediately Cand-RP-Adv */
comment|/* TODO: use some random delay? */
if|if
condition|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|new_bsr_address
argument_list|,
operator|&
name|curr_bsr_address
argument_list|)
condition|)
block|{
name|send_pim6_cand_rp_adv
argument_list|()
expr_stmt|;
name|SET_TIMER
argument_list|(
name|pim_cand_rp_adv_timer
argument_list|,
name|my_cand_rp_adv_period
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Forward the BSR Message first and then update the RP-set list */
comment|/* XXX: should we do sanity checks before forwarding?? */
comment|/* TODO: if the message was unicasted to me, resend? */
for|for
control|(
name|mifi
operator|=
literal|0
init|;
name|mifi
operator|<
name|numvifs
condition|;
name|mifi
operator|++
control|)
block|{
if|if
condition|(
name|mifi
operator|==
name|incoming
condition|)
continue|continue;
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|MIFF_REGISTER
operator||
name|VIFF_TUNNEL
operator||
name|VIFF_NONBRS
operator|)
condition|)
continue|continue;
name|bcopy
argument_list|(
name|pim_message
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|pim6_send_buf
operator|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|allpim6routers_group
argument_list|,
name|PIM_BOOTSTRAP
argument_list|,
name|datalen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|max_data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
name|pim_message
operator|+
name|datalen
expr_stmt|;
comment|/*      * TODO: XXX: this 24 is HARDCODING!!! Do a bunch of definitions and make      * it stylish!      * 24 = Encoded-Group Address(20) + RP-cound(1) + Frag-RP(1) + Reserved(2)      */
name|min_datalen
operator|=
literal|24
expr_stmt|;
if|if
condition|(
operator|(
name|new_bsr_fragment_tag
operator|!=
name|curr_bsr_fragment_tag
operator|)
operator|||
operator|(
name|inet6_equal
argument_list|(
operator|&
name|new_bsr_address
argument_list|,
operator|&
name|curr_bsr_address
argument_list|)
operator|)
condition|)
block|{
comment|/* Throw away the old segment */
name|delete_rp_list
argument_list|(
operator|&
name|segmented_cand_rp_list
argument_list|,
operator|&
name|segmented_grp_mask_list
argument_list|)
expr_stmt|;
block|}
name|curr_bsr_address
operator|=
name|new_bsr_address
expr_stmt|;
name|curr_bsr_priority
operator|=
name|new_bsr_priority
expr_stmt|;
name|curr_bsr_fragment_tag
operator|=
name|new_bsr_fragment_tag
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|new_bsr_hash_masklen
argument_list|,
name|curr_bsr_hash_mask
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|pim_bootstrap_timer
argument_list|,
name|PIM_BOOTSTRAP_TIMEOUT
argument_list|)
expr_stmt|;
while|while
condition|(
name|data_ptr
operator|+
name|min_datalen
operator|<=
name|max_data_ptr
condition|)
block|{
name|GET_EGADDR6
argument_list|(
operator|&
name|curr_group_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|curr_rp_count
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|curr_frag_rp_count
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|reserved_short
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|curr_group_addr
operator|.
name|masklen
argument_list|,
name|curr_group_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MC_NODELOCAL
argument_list|(
operator|&
name|curr_group_addr
operator|.
name|mcast_addr
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|curr_group_addr
operator|.
name|mcast_addr
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: "
literal|"group prefix has a narraw scope: %s (ignored)"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|curr_group_addr
operator|.
name|mcast_addr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|curr_rp_count
operator|==
literal|0
condition|)
block|{
name|group_
operator|.
name|sin6_addr
operator|=
name|curr_group_addr
operator|.
name|mcast_addr
expr_stmt|;
name|delete_grp_mask
argument_list|(
operator|&
name|cand_rp_list
argument_list|,
operator|&
name|grp_mask_list
argument_list|,
operator|&
name|group_
argument_list|,
name|curr_group_mask
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|curr_rp_count
operator|==
name|curr_frag_rp_count
condition|)
block|{
comment|/* Add all RPs */
while|while
condition|(
name|curr_frag_rp_count
operator|--
condition|)
block|{
comment|/* 		 * Sanity for the data length; the data packet must contain 		 * Encoded-Unicast-RP-Address(18) + RP-Holdtime(2) + 		 * RP-Priority(1) + Reserved(1). 		 */
if|if
condition|(
name|data_ptr
operator|+
name|PIM6_ENCODE_UNI_ADDR_LEN
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|>
name|max_data_ptr
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: Bootstrap from %s on %s "
literal|"does not have enough length to contatin RP information"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|v
operator|->
name|uv_name
argument_list|)
expr_stmt|;
comment|/* 		     * Ignore the rest of the message. 		     * XXX: should we discard the entire message? 		     */
goto|goto
name|garbage_collect
goto|;
block|}
name|GET_EUADDR6
argument_list|(
operator|&
name|curr_rp_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|curr_rp_holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|curr_rp_priority
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|reserved_byte
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|curr_group_addr
operator|.
name|masklen
argument_list|,
name|curr_group_mask
argument_list|)
expr_stmt|;
name|rpp_
operator|.
name|sin6_addr
operator|=
name|curr_rp_addr
operator|.
name|unicast_addr
expr_stmt|;
name|rpp_
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|rpp_
argument_list|)
expr_stmt|;
name|rpp_
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
comment|/* 		 * The cand_rp address scope should be global. 		 * XXX: however, is a site-local RP sometimes useful? 		 *      we currently discard such RP... 		 */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|rpp_
operator|.
name|sin6_addr
argument_list|)
operator|||
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|rpp_
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_bootstrap: invalid RP address: %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|rpp_
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rpp_
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
name|group_
operator|.
name|sin6_addr
operator|=
name|curr_group_addr
operator|.
name|mcast_addr
expr_stmt|;
name|group_
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|group_
argument_list|)
expr_stmt|;
name|group_
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|group_
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group_
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|add_rp_grp_entry
argument_list|(
operator|&
name|cand_rp_list
argument_list|,
operator|&
name|grp_mask_list
argument_list|,
operator|&
name|rpp_
argument_list|,
name|curr_rp_priority
argument_list|,
name|curr_rp_holdtime
argument_list|,
operator|&
name|group_
argument_list|,
name|curr_group_mask
argument_list|,
name|curr_bsr_hash_mask
argument_list|,
name|curr_bsr_fragment_tag
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 	 * This is a partial list of the RPs for this group prefix. Save 	 * until all segments arrive. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|prefix_h
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
name|curr_group_addr
operator|.
name|mcast_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|&
name|curr_group_mask
operator|.
name|s6_addr
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|grp_mask_ptr
operator|=
name|segmented_grp_mask_list
init|;
name|grp_mask_ptr
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|;
name|grp_mask_ptr
operator|=
name|grp_mask_ptr
operator|->
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|prefix_h2
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
name|grp_mask_ptr
operator|->
name|group_addr
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|&
name|grp_mask_ptr
operator|->
name|group_mask
operator|.
name|s6_addr
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|inet6_greaterthan
argument_list|(
operator|&
name|prefix_h2
argument_list|,
operator|&
name|prefix_h
argument_list|)
condition|)
continue|continue;
else|else
break|break;
block|}
if|if
condition|(
operator|(
name|grp_mask_ptr
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|grp_mask_ptr
operator|->
name|group_addr
operator|.
name|sin6_addr
argument_list|,
operator|&
name|curr_group_addr
operator|.
name|mcast_addr
argument_list|)
operator|)
operator|&&
operator|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|grp_mask_ptr
operator|->
name|group_mask
argument_list|,
operator|&
name|curr_group_mask
argument_list|)
operator|)
operator|&&
operator|(
name|grp_mask_ptr
operator|->
name|group_rp_number
operator|+
name|curr_frag_rp_count
operator|==
name|curr_rp_count
operator|)
condition|)
block|{
comment|/* All missing PRs have arrived. Add all RP entries */
while|while
condition|(
name|curr_frag_rp_count
operator|--
condition|)
block|{
name|GET_EUADDR6
argument_list|(
operator|&
name|curr_rp_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|curr_rp_holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|curr_rp_priority
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|reserved_byte
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|curr_group_addr
operator|.
name|masklen
argument_list|,
name|curr_group_mask
argument_list|)
expr_stmt|;
name|rpp_
operator|.
name|sin6_addr
operator|=
name|curr_rp_addr
operator|.
name|unicast_addr
expr_stmt|;
name|rpp_
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
name|group_
operator|.
name|sin6_addr
operator|=
name|curr_group_addr
operator|.
name|mcast_addr
expr_stmt|;
name|group_
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group_
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|add_rp_grp_entry
argument_list|(
operator|&
name|cand_rp_list
argument_list|,
operator|&
name|grp_mask_list
argument_list|,
operator|&
name|rpp_
argument_list|,
name|curr_rp_priority
argument_list|,
name|curr_rp_holdtime
argument_list|,
operator|&
name|group_
argument_list|,
name|curr_group_mask
argument_list|,
name|curr_bsr_hash_mask
argument_list|,
name|curr_bsr_fragment_tag
argument_list|)
expr_stmt|;
block|}
comment|/* Add the rest from the previously saved segments */
for|for
control|(
name|grp_rp_entry_ptr
operator|=
name|grp_mask_ptr
operator|->
name|grp_rp_next
init|;
name|grp_rp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|grp_rp_entry_ptr
operator|=
name|grp_rp_entry_ptr
operator|->
name|grp_rp_next
control|)
block|{
name|group_
operator|.
name|sin6_addr
operator|=
name|curr_group_addr
operator|.
name|mcast_addr
expr_stmt|;
name|group_
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group_
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|add_rp_grp_entry
argument_list|(
operator|&
name|cand_rp_list
argument_list|,
operator|&
name|grp_mask_list
argument_list|,
operator|&
name|grp_rp_entry_ptr
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|address
argument_list|,
name|grp_rp_entry_ptr
operator|->
name|priority
argument_list|,
name|grp_rp_entry_ptr
operator|->
name|holdtime
argument_list|,
operator|&
name|group_
argument_list|,
name|curr_group_mask
argument_list|,
name|curr_bsr_hash_mask
argument_list|,
name|curr_bsr_fragment_tag
argument_list|)
expr_stmt|;
block|}
name|group_
operator|.
name|sin6_addr
operator|=
name|curr_group_addr
operator|.
name|mcast_addr
expr_stmt|;
name|group_
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group_
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|delete_grp_mask
argument_list|(
operator|&
name|segmented_cand_rp_list
argument_list|,
operator|&
name|segmented_grp_mask_list
argument_list|,
operator|&
name|group_
argument_list|,
name|curr_group_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add the partially received RP-list to the group of pending RPs */
while|while
condition|(
name|curr_frag_rp_count
operator|--
condition|)
block|{
name|GET_EUADDR6
argument_list|(
operator|&
name|curr_rp_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|curr_rp_holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|curr_rp_priority
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|reserved_byte
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|curr_group_addr
operator|.
name|masklen
argument_list|,
name|curr_group_mask
argument_list|)
expr_stmt|;
name|rpp_
operator|.
name|sin6_addr
operator|=
name|curr_rp_addr
operator|.
name|unicast_addr
expr_stmt|;
name|group_
operator|.
name|sin6_addr
operator|=
name|curr_group_addr
operator|.
name|mcast_addr
expr_stmt|;
name|group_
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group_
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|add_rp_grp_entry
argument_list|(
operator|&
name|segmented_cand_rp_list
argument_list|,
operator|&
name|segmented_grp_mask_list
argument_list|,
operator|&
name|rpp_
argument_list|,
name|curr_rp_priority
argument_list|,
name|curr_rp_holdtime
argument_list|,
operator|&
name|group_
argument_list|,
name|curr_group_mask
argument_list|,
name|curr_bsr_hash_mask
argument_list|,
name|curr_bsr_fragment_tag
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|garbage_collect
label|:
comment|/*      * Garbage collection. Check all group prefixes and if the fragment_tag      * for a group_prefix is the same as curr_bsr_fragment_tag, then remove      * all RPs for this group_prefix which have different fragment tag.      */
for|for
control|(
name|grp_mask_ptr
operator|=
name|grp_mask_list
init|;
name|grp_mask_ptr
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|;
name|grp_mask_ptr
operator|=
name|grp_mask_next
control|)
block|{
name|grp_mask_next
operator|=
name|grp_mask_ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|grp_mask_ptr
operator|->
name|fragment_tag
operator|==
name|curr_bsr_fragment_tag
condition|)
block|{
for|for
control|(
name|grp_rp_entry_ptr
operator|=
name|grp_mask_ptr
operator|->
name|grp_rp_next
init|;
name|grp_rp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|grp_rp_entry_ptr
operator|=
name|grp_rp_entry_next
control|)
block|{
name|grp_rp_entry_next
operator|=
name|grp_rp_entry_ptr
operator|->
name|grp_rp_next
expr_stmt|;
if|if
condition|(
name|grp_rp_entry_ptr
operator|->
name|fragment_tag
operator|!=
name|curr_bsr_fragment_tag
condition|)
name|delete_rp_grp_entry
argument_list|(
operator|&
name|cand_rp_list
argument_list|,
operator|&
name|grp_mask_list
argument_list|,
name|grp_rp_entry_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Cleanup also the list used by incompleted segments */
for|for
control|(
name|grp_mask_ptr
operator|=
name|segmented_grp_mask_list
init|;
name|grp_mask_ptr
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|;
name|grp_mask_ptr
operator|=
name|grp_mask_next
control|)
block|{
name|grp_mask_next
operator|=
name|grp_mask_ptr
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|grp_mask_ptr
operator|->
name|fragment_tag
operator|==
name|curr_bsr_fragment_tag
condition|)
block|{
for|for
control|(
name|grp_rp_entry_ptr
operator|=
name|grp_mask_ptr
operator|->
name|grp_rp_next
init|;
name|grp_rp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|grp_rp_entry_ptr
operator|=
name|grp_rp_entry_next
control|)
block|{
name|grp_rp_entry_next
operator|=
name|grp_rp_entry_ptr
operator|->
name|grp_rp_next
expr_stmt|;
if|if
condition|(
name|grp_rp_entry_ptr
operator|->
name|fragment_tag
operator|!=
name|curr_bsr_fragment_tag
condition|)
name|delete_rp_grp_entry
argument_list|(
operator|&
name|segmented_cand_rp_list
argument_list|,
operator|&
name|segmented_grp_mask_list
argument_list|,
name|grp_rp_entry_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_function
name|void
name|send_pim6_bootstrap
parameter_list|()
block|{
name|int
name|datalen
decl_stmt|;
name|mifi_t
name|mifi
decl_stmt|;
if|if
condition|(
operator|(
name|datalen
operator|=
name|create_pim6_bootstrap_message
argument_list|(
name|pim6_send_buf
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|mifi
operator|=
literal|0
init|;
name|mifi
operator|<
name|numvifs
condition|;
name|mifi
operator|++
control|)
block|{
if|if
condition|(
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|MIFF_REGISTER
operator||
name|VIFF_TUNNEL
operator|)
condition|)
continue|continue;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
argument_list|,
operator|&
name|allpim6routers_group
argument_list|,
name|PIM_BOOTSTRAP
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|uvifs
index|[
name|mifi
index|]
operator|.
name|uv_out_pim6_bootsrap
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/************************************************************************  *                        PIM_CAND_RP_ADV  ************************************************************************/
end_comment

begin_comment
comment|/*  * minimum length of a cand. RP adv. message;  * length of PIM header + prefix-cnt(1) + priority(1) + holdtime(2) +  *                        encoded unicast RP addr(18)   */
end_comment

begin_define
define|#
directive|define
name|PIM6_CAND_RP_ADV_MINLEN
value|(PIM_MINLEN + PIM6_ENCODE_UNI_ADDR_LEN)
end_define

begin_comment
comment|/*  * If I am the Bootstrap router, process the advertisement, otherwise ignore  * it.  */
end_comment

begin_function
name|int
name|receive_pim6_cand_rp_adv
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|pim_message
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|pim_message
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_int8
name|prefix_cnt
decl_stmt|;
name|u_int8
name|priority
decl_stmt|;
name|u_int16
name|holdtime
decl_stmt|;
name|pim6_encod_uni_addr_t
name|cand_rp_addr
decl_stmt|;
name|pim6_encod_grp_addr_t
name|encod_grp_addr
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|struct
name|in6_addr
name|grp_mask
decl_stmt|;
name|struct
name|sockaddr_in6
name|group_
decl_stmt|,
name|rpp_
decl_stmt|;
name|pim6dstat
operator|.
name|in_pim6_cand_rp
operator|++
expr_stmt|;
comment|/* if I am not the bootstrap RP, then do not accept the message */
if|if
condition|(
operator|(
name|cand_bsr_flag
operator|!=
name|FALSE
operator|)
operator|&&
operator|!
name|inet6_equal
argument_list|(
operator|&
name|curr_bsr_address
argument_list|,
operator|&
name|my_bsr_address
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_cand_rp_adv: receive cand_RP from %s "
literal|"but I'm not the BSR"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* sanity check for the minimum length */
if|if
condition|(
name|datalen
operator|<
name|PIM6_CAND_RP_ADV_MINLEN
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_cand_rp_adv: cand_RP message size(%u) is"
literal|" too short from %s"
argument_list|,
name|datalen
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|datalen
operator|-=
name|PIM6_CAND_RP_ADV_MINLEN
expr_stmt|;
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim_message
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
comment|/* Parse the CAND_RP_ADV message */
name|GET_BYTE
argument_list|(
name|prefix_cnt
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_BYTE
argument_list|(
name|priority
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_HOSTSHORT
argument_list|(
name|holdtime
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|GET_EUADDR6
argument_list|(
operator|&
name|cand_rp_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
comment|/*      * The RP Address field is set to the globally reachable IPv6 address      * [draft-ietf-pim-ipv6].      */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|cand_rp_addr
operator|.
name|unicast_addr
argument_list|)
condition|)
block|{
comment|/* XXX: prohibit a site-local address as well? */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_cand_rp_adv: non global address(%s) as RP"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|cand_rp_addr
operator|.
name|unicast_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|rpp_
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rpp_
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix_cnt
operator|==
literal|0
condition|)
block|{
comment|/* The default ff:: and masklen of 8 */
name|MASKLEN_TO_MASK6
argument_list|(
name|ALL_MCAST_GROUPS_LENGTH
argument_list|,
name|grp_mask
argument_list|)
expr_stmt|;
name|rpp_
operator|.
name|sin6_addr
operator|=
name|cand_rp_addr
operator|.
name|unicast_addr
expr_stmt|;
comment|/* 	 * note that we don't have to take care of scope id, since 	 * the address should be global(see above). 	 */
name|add_rp_grp_entry
argument_list|(
operator|&
name|cand_rp_list
argument_list|,
operator|&
name|grp_mask_list
argument_list|,
operator|&
name|rpp_
argument_list|,
name|priority
argument_list|,
name|holdtime
argument_list|,
operator|&
name|sockaddr6_d
argument_list|,
name|grp_mask
argument_list|,
name|my_bsr_hash_mask
argument_list|,
name|curr_bsr_fragment_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
while|while
condition|(
name|prefix_cnt
operator|--
condition|)
block|{
comment|/* 	     * Sanity check for the message length. 	     * XXX: do we have to do the check at an earlier stage and 	     *      discard the whole message (instead of adopting a part of it) 	     *      if it's bogus? 	     */
if|if
condition|(
name|datalen
operator|<
name|PIM6_ENCODE_GRP_ADDR_LEN
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"receive_pim6_cand_rp_adv: cand_RP message from %s is"
literal|" too short to contain enough groups"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|datalen
operator|-=
name|PIM6_ENCODE_GRP_ADDR_LEN
expr_stmt|;
name|GET_EGADDR6
argument_list|(
operator|&
name|encod_grp_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_grp_addr
operator|.
name|masklen
argument_list|,
name|grp_mask
argument_list|)
expr_stmt|;
name|group_
operator|.
name|sin6_addr
operator|=
name|encod_grp_addr
operator|.
name|mcast_addr
expr_stmt|;
name|group_
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
comment|/* XXX: what if for scoped multicast addr? */
name|rpp_
operator|.
name|sin6_addr
operator|=
name|cand_rp_addr
operator|.
name|unicast_addr
expr_stmt|;
comment|/* see above note on scope id */
name|add_rp_grp_entry
argument_list|(
operator|&
name|cand_rp_list
argument_list|,
operator|&
name|grp_mask_list
argument_list|,
operator|&
name|rpp_
argument_list|,
name|priority
argument_list|,
name|holdtime
argument_list|,
operator|&
name|group_
argument_list|,
name|grp_mask
argument_list|,
name|my_bsr_hash_mask
argument_list|,
name|curr_bsr_fragment_tag
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_function
name|int
name|send_pim6_cand_rp_adv
parameter_list|()
block|{
name|u_int8
name|prefix_cnt
decl_stmt|;
name|struct
name|in6_addr
name|grp_mask
decl_stmt|;
name|pim6_encod_grp_addr_t
name|encod_grp_addr
decl_stmt|;
name|u_int8
modifier|*
name|data_ptr
decl_stmt|;
name|struct
name|sockaddr_in6
name|group_
decl_stmt|;
if|if
condition|(
operator|!
name|inet6_valid_host
argument_list|(
operator|&
name|curr_bsr_address
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* No BSR yet */
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|curr_bsr_address
argument_list|,
operator|&
name|my_bsr_address
argument_list|)
condition|)
block|{
comment|/* I am the BSR and have to include my own group_prefix stuff */
name|prefix_cnt
operator|=
operator|*
name|cand_rp_adv_message
operator|.
name|prefix_cnt_ptr
expr_stmt|;
if|if
condition|(
name|prefix_cnt
operator|==
literal|0
condition|)
block|{
comment|/* The default ff00:: and masklen of 8 */
name|MASKLEN_TO_MASK6
argument_list|(
name|ALL_MCAST_GROUPS_LENGTH
argument_list|,
name|grp_mask
argument_list|)
expr_stmt|;
name|add_rp_grp_entry
argument_list|(
operator|&
name|cand_rp_list
argument_list|,
operator|&
name|grp_mask_list
argument_list|,
operator|&
name|my_cand_rp_address
argument_list|,
name|my_cand_rp_priority
argument_list|,
name|my_cand_rp_holdtime
argument_list|,
operator|&
name|sockaddr6_d
argument_list|,
name|grp_mask
argument_list|,
name|my_bsr_hash_mask
argument_list|,
name|curr_bsr_fragment_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* TODO: hardcoding!! */
comment|/* 18 = sizeof(pim6_encod_uni_addr_t) without padding */
name|data_ptr
operator|=
name|cand_rp_adv_message
operator|.
name|buffer
operator|+
operator|(
literal|4
operator|+
literal|18
operator|)
expr_stmt|;
while|while
condition|(
name|prefix_cnt
operator|--
condition|)
block|{
name|GET_EGADDR6
argument_list|(
operator|&
name|encod_grp_addr
argument_list|,
name|data_ptr
argument_list|)
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|encod_grp_addr
operator|.
name|masklen
argument_list|,
name|grp_mask
argument_list|)
expr_stmt|;
name|group_
operator|.
name|sin6_addr
operator|=
name|encod_grp_addr
operator|.
name|mcast_addr
expr_stmt|;
name|group_
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
comment|/*XXX */
name|add_rp_grp_entry
argument_list|(
operator|&
name|cand_rp_list
argument_list|,
operator|&
name|grp_mask_list
argument_list|,
operator|&
name|my_cand_rp_address
argument_list|,
name|my_cand_rp_priority
argument_list|,
name|my_cand_rp_holdtime
argument_list|,
operator|&
name|group_
argument_list|,
name|grp_mask
argument_list|,
name|my_bsr_hash_mask
argument_list|,
name|curr_bsr_fragment_tag
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|data_ptr
operator|=
operator|(
name|u_int8
operator|*
operator|)
operator|(
name|pim6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|pim
argument_list|)
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cand_rp_adv_message
operator|.
name|buffer
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data_ptr
argument_list|,
name|cand_rp_adv_message
operator|.
name|message_size
argument_list|)
expr_stmt|;
name|send_pim6
argument_list|(
name|pim6_send_buf
argument_list|,
operator|&
name|my_cand_rp_address
argument_list|,
operator|&
name|curr_bsr_address
argument_list|,
name|PIM_CAND_RP_ADV
argument_list|,
name|cand_rp_adv_message
operator|.
name|message_size
argument_list|)
expr_stmt|;
name|pim6dstat
operator|.
name|out_pim6_cand_rp
operator|++
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

end_unit

