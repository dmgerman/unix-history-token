begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1999 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  Copyright (c) 1998 by the University of Southern California.  *  All rights reserved.  *  *  Permission to use, copy, modify, and distribute this software and  *  its documentation in source and binary forms for lawful  *  non-commercial purposes and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both  *  the copyright notice and this permission notice appear in supporting  *  documentation, and that any documentation, advertising materials,  *  and other materials related to such distribution and use acknowledge  *  that the software was developed by the University of Southern  *  California and/or Information Sciences Institute.  *  The name of the University of Southern California may not  *  be used to endorse or promote products derived from this software  *  without specific prior written permission.  *  *  THE UNIVERSITY OF SOUTHERN CALIFORNIA DOES NOT MAKE ANY REPRESENTATIONS  *  ABOUT THE SUITABILITY OF THIS SOFTWARE FOR ANY PURPOSE.  THIS SOFTWARE IS  *  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  *  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND  *  NON-INFRINGEMENT.  *  *  IN NO EVENT SHALL USC, OR ANY OTHER CONTRIBUTOR BE LIABLE FOR ANY  *  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, WHETHER IN CONTRACT,  *  TORT, OR OTHER FORM OF ACTION, ARISING OUT OF OR IN CONNECTION WITH,  *  THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *  Other copyrights might apply to parts of this software and are so  *  noted when applicable.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *  Questions concerning this software should be directed to  *  Pavlin Ivanov Radoslavov (pavlin@catarina.usc.edu)  *  *  $Id: trace.c,v 1.7 1999/09/16 08:45:45 jinmei Exp $  */
end_comment

begin_comment
comment|/*  * Part of this program has been derived from mrouted.  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE.mrouted".  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|"vif.h"
end_include

begin_include
include|#
directive|include
file|"inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
end_if

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_mroute.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"mld6.h"
end_include

begin_include
include|#
directive|include
file|"kern.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"mld6_proto.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_include
include|#
directive|include
file|"rp.h"
end_include

begin_include
include|#
directive|include
file|"trace.h"
end_include

begin_comment
comment|/* TODO */
end_comment

begin_comment
comment|/*  * Traceroute function which returns traceroute replies to the requesting  * router. Also forwards the request to downstream routers.  */
end_comment

begin_function
name|void
name|accept_mtrace
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|group
parameter_list|,
name|ifindex
parameter_list|,
name|data
parameter_list|,
name|no
parameter_list|,
name|datalen
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|src
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|dst
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|group
decl_stmt|;
name|int
name|ifindex
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|u_int
name|no
decl_stmt|;
comment|/* promoted u_char */
name|int
name|datalen
decl_stmt|;
block|{
name|u_char
name|type
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrt
decl_stmt|;
name|struct
name|tr6_query
modifier|*
name|qry
decl_stmt|;
name|struct
name|tr6_resp
modifier|*
name|resp
decl_stmt|;
name|int
name|vifi
decl_stmt|,
name|ovifi
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|rcount
decl_stmt|;
name|int
name|errcode
init|=
name|TR_NO_ERR
decl_stmt|;
name|int
name|resptype
decl_stmt|;
name|struct
name|timeval
name|tp
decl_stmt|;
name|struct
name|sioc_mif_req6
name|mreq
decl_stmt|;
name|struct
name|in6_addr
name|parent_address
decl_stmt|;
name|struct
name|sockaddr_in6
name|src_sa6
init|=
block|{
sizeof|sizeof
argument_list|(
name|src_sa6
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|struct
name|sockaddr_in6
name|dst_sa6
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst_sa6
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|struct
name|sockaddr_in6
name|resp_sa6
init|=
block|{
sizeof|sizeof
argument_list|(
name|resp_sa6
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|struct
name|sockaddr_in6
name|grp_sa6
init|=
block|{
sizeof|sizeof
argument_list|(
name|grp_sa6
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sa_global
decl_stmt|;
name|rpentry_t
modifier|*
name|rpentry_ptr
decl_stmt|;
comment|/* Remember qid across invocations */
specifier|static
name|u_int32
name|oqid
init|=
literal|0
decl_stmt|;
comment|/* timestamp the request/response */
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Check if it is a query or a response 	 */
if|if
condition|(
name|datalen
operator|==
name|QLEN
condition|)
block|{
name|type
operator|=
name|QUERY
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Initial traceroute query rcvd "
literal|"from %s to %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|datalen
operator|-
name|QLEN
operator|)
operator|%
name|RLEN
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|RESP
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"In-transit traceroute query rcvd "
literal|"from %s to %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
name|dst
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Dropping multicast response"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|0
argument_list|,
literal|"%s from %s to %s"
argument_list|,
literal|"Non decipherable traceroute request recieved"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|src
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|qry
operator|=
operator|(
expr|struct
name|tr6_query
operator|*
operator|)
name|data
expr_stmt|;
name|src_sa6
operator|.
name|sin6_addr
operator|=
name|qry
operator|->
name|tr_src
expr_stmt|;
name|src_sa6
operator|.
name|sin6_scope_id
operator|=
operator|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|qry
operator|->
name|tr_src
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|qry
operator|->
name|tr_src
argument_list|)
operator|)
condition|?
name|ifindex
else|:
literal|0
expr_stmt|;
name|dst_sa6
operator|.
name|sin6_addr
operator|=
name|qry
operator|->
name|tr_dst
expr_stmt|;
name|dst_sa6
operator|.
name|sin6_scope_id
operator|=
operator|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|qry
operator|->
name|tr_dst
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|qry
operator|->
name|tr_dst
argument_list|)
operator|)
condition|?
name|ifindex
else|:
literal|0
expr_stmt|;
name|grp_sa6
operator|.
name|sin6_addr
operator|=
operator|*
name|group
expr_stmt|;
name|grp_sa6
operator|.
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
comment|/* 	 * if it is a packet with all reports filled, drop it 	 */
if|if
condition|(
operator|(
name|rcount
operator|=
operator|(
name|datalen
operator|-
name|QLEN
operator|)
operator|/
name|RLEN
operator|)
operator|==
name|no
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"packet with all reports filled in"
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"s: %s g: %s d: %s "
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|qry
operator|->
name|tr_src
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
name|group
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|qry
operator|->
name|tr_dst
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rhlim: %d rd: %s"
argument_list|,
name|qry
operator|->
name|tr_rhlim
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|qry
operator|->
name|tr_raddr
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rcount:%d, qid:%06x"
argument_list|,
name|rcount
argument_list|,
name|qry
operator|->
name|tr_qid
argument_list|)
expr_stmt|;
block|}
comment|/* determine the routing table entry for this traceroute */
name|mrt
operator|=
name|find_route
argument_list|(
operator|&
name|src_sa6
argument_list|,
operator|&
name|grp_sa6
argument_list|,
name|MRTF_SG
operator||
name|MRTF_WC
operator||
name|MRTF_PMBR
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
block|{
if|if
condition|(
name|mrt
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|mrt
operator|->
name|upstream
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
name|parent_address
operator|=
name|mrt
operator|->
name|upstream
operator|->
name|address
operator|.
name|sin6_addr
expr_stmt|;
else|else
name|parent_address
operator|=
name|in6addr_any
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"mrt parent mif: %d rtr: %s metric: %d"
argument_list|,
name|mrt
operator|->
name|incoming
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|parent_address
argument_list|)
argument_list|,
name|mrt
operator|->
name|metric
argument_list|)
expr_stmt|;
comment|/* TODO 			   log(LOG_DEBUG, 0, "mrt origin %s", 			   RT_FMT(rt, s1)); 			*/
block|}
else|else
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"...no route"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Query type packet - check if rte exists 	 * Check if the query destination is a vif connected to me. 	 * and if so, whether I should start response back 	 */
if|if
condition|(
name|type
operator|==
name|QUERY
condition|)
block|{
if|if
condition|(
name|oqid
operator|==
name|qry
operator|->
name|tr_qid
condition|)
block|{
comment|/* 			 * If the multicast router is a member of the group 			 * being queried, and the query is multicasted, 			 * then the router can recieve multiple copies of 			 * the same query.  If we have already replied to 			 * this traceroute, just ignore it this time. 			 * 			 * This is not a total solution, but since if this 			 * fails you only get N copies, N<= the number of 			 * interfaces on the router, it is not fatal. 			 */
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"ignoring duplicate traceroute packet"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mrt
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Mcast traceroute: no route entry %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|qry
operator|->
name|tr_src
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (IN6_IS_ADDR_MULTICAST(dst)) 				return;
endif|#
directive|endif
block|}
name|vifi
operator|=
name|find_vif_direct
argument_list|(
operator|&
name|dst_sa6
argument_list|)
expr_stmt|;
if|if
condition|(
name|vifi
operator|==
name|NO_VIF
condition|)
block|{
comment|/* 			 * The traceroute destination is not on one of 			 * my subnet vifs. 			 */
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Destination %s not an interface"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|qry
operator|->
name|tr_dst
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
name|dst
argument_list|)
condition|)
return|return;
name|errcode
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mrt
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
operator|&&
operator|!
name|IF_ISSET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrt
operator|->
name|oifs
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Destination %s not on forwarding tree "
literal|"for src %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|qry
operator|->
name|tr_dst
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|qry
operator|->
name|tr_src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
name|dst
argument_list|)
condition|)
return|return;
name|errcode
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * determine which interface the packet came in on 		 * RESP packets travel hop-by-hop so this either traversed 		 * a tunnel or came from a directly attached mrouter. 		 */
if|if
condition|(
operator|(
name|vifi
operator|=
name|find_vif_direct
argument_list|(
name|src
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Wrong interface for packet"
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
block|}
comment|/* Now that we've decided to send a response, save the qid */
name|oqid
operator|=
name|qry
operator|->
name|tr_qid
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending traceroute response"
argument_list|)
expr_stmt|;
comment|/* copy the packet to the sending buffer */
name|p
operator|=
name|mld6_send_buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mld6_hdr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|p
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|datalen
expr_stmt|;
comment|/* 	 * If there is no room to insert our reply, coopt the previous hop 	 * error indication to relay this fact. 	 */
if|if
condition|(
name|p
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tr6_resp
argument_list|)
operator|>
name|mld6_send_buf
operator|+
name|RECV_BUF_SIZE
condition|)
block|{
name|resp
operator|=
operator|(
expr|struct
name|tr6_resp
operator|*
operator|)
name|p
operator|-
literal|1
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_SPACE
expr_stmt|;
name|mrt
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sendit
goto|;
block|}
comment|/* 	 * fill in initial response fields 	 */
name|resp
operator|=
operator|(
expr|struct
name|tr6_resp
operator|*
operator|)
name|p
expr_stmt|;
name|bzero
argument_list|(
name|resp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tr6_resp
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
operator|(
name|RLEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mld6_hdr
argument_list|)
operator|)
expr_stmt|;
name|resp
operator|->
name|tr_qarr
operator|=
name|htonl
argument_list|(
operator|(
operator|(
name|tp
operator|.
name|tv_sec
operator|+
name|JAN_1970
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
name|tp
operator|.
name|tv_usec
operator|<<
literal|10
operator|)
operator|/
literal|15625
operator|)
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_rproto
operator|=
name|PROTO_PIM
expr_stmt|;
name|resp
operator|->
name|tr_outifid
operator|=
operator|(
name|vifi
operator|==
name|NO_VIF
operator|)
condition|?
name|TR_NO_VIF
else|:
name|htonl
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|errcode
expr_stmt|;
if|if
condition|(
operator|(
name|sa_global
operator|=
name|max_global_address
argument_list|()
operator|)
operator|==
name|NULL
condition|)
comment|/* impossible */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|0
argument_list|,
literal|"acept_mtrace: max_global_address returns NULL"
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_lcladdr
operator|=
name|sa_global
operator|->
name|sin6_addr
expr_stmt|;
comment|/* 	 * obtain # of packets out on interface 	 */
name|mreq
operator|.
name|mifi
operator|=
name|vifi
expr_stmt|;
if|if
condition|(
name|vifi
operator|!=
name|NO_VIF
operator|&&
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETMIFCNT_IN6
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|)
operator|>=
literal|0
condition|)
name|resp
operator|->
name|tr_vifout
operator|=
name|htonl
argument_list|(
name|mreq
operator|.
name|ocount
argument_list|)
expr_stmt|;
else|else
name|resp
operator|->
name|tr_vifout
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* 	 * fill in scoping& pruning information 	 */
comment|/* TODO */
if|#
directive|if
literal|0
block|if (mrt != (mrtentry_t *)NULL) 		for (gt = rt->rt_groups; gt; gt = gt->gt_next) { 			if (gt->gt_mcastgrp>= group) 				break; 		} 	else 		gt = NULL;  	if (gt&& gt->gt_mcastgrp == group) { 		struct stable *st;  		for (st = gt->gt_srctbl; st; st = st->st_next) 			if (qry->tr_src == st->st_origin) 				break;  		sg_req.src.s_addr = qry->tr_src; 		sg_req.grp.s_addr = group; 		if (st&& st->st_ctime != 0&& 		    ioctl(udp_socket, SIOCGETSGCNT, (char *)&sg_req)>= 0) 			resp->tr_pktcnt = htonl(sg_req.pktcnt + st->st_savpkt); 		else 			resp->tr_pktcnt = htonl(st ? st->st_savpkt : 0xffffffff);  		if (VIFM_ISSET(vifi, gt->gt_scope)) 			resp->tr_rflags = TR_SCOPED; 		else if (gt->gt_prsent_timer) 			resp->tr_rflags = TR_PRUNED; 		else if (!VIFM_ISSET(vifi, gt->gt_grpmems)) 			if (VIFM_ISSET(vifi, rt->rt_children)&& 			    NBRM_ISSETMASK(uvifs[vifi].uv_nbrmap, 					   rt->rt_subordinates))
comment|/*XXX*/
block|resp->tr_rflags = TR_OPRUNED; 			else 				resp->tr_rflags = TR_NO_FWD; 	} else { 		if (scoped_addr(vifi, group)) 			resp->tr_rflags = TR_SCOPED; 		else if (rt&& !VIFM_ISSET(vifi, rt->rt_children)) 			resp->tr_rflags = TR_NO_FWD; 	}
endif|#
directive|endif
comment|/* 0 */
comment|/* 	 *  if no rte exists, set NO_RTE error 	 */
if|if
condition|(
name|mrt
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|src
operator|->
name|sin6_addr
operator|=
operator|*
name|dst
expr_stmt|;
comment|/* the dst address of resp. pkt */
name|resp
operator|->
name|tr_inifid
operator|=
name|TR_NO_VIF
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_NO_RTE
expr_stmt|;
name|memset
argument_list|(
operator|&
name|resp
operator|->
name|tr_rmtaddr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get # of packets in on interface */
name|mreq
operator|.
name|mifi
operator|=
name|mrt
operator|->
name|incoming
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|udp_socket
argument_list|,
name|SIOCGETMIFCNT_IN6
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mreq
argument_list|)
operator|>=
literal|0
condition|)
name|resp
operator|->
name|tr_vifin
operator|=
name|htonl
argument_list|(
name|mreq
operator|.
name|icount
argument_list|)
expr_stmt|;
else|else
name|resp
operator|->
name|tr_vifin
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* 		 * TODO 		 * MASK_TO_VAL(rt->rt_originmask, resp->tr_smask); 		 */
name|resp
operator|->
name|tr_inifid
operator|=
name|htonl
argument_list|(
name|mrt
operator|->
name|incoming
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrt
operator|->
name|upstream
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
name|parent_address
operator|=
name|mrt
operator|->
name|upstream
operator|->
name|address
operator|.
name|sin6_addr
expr_stmt|;
else|else
name|parent_address
operator|=
name|in6addr_any
expr_stmt|;
name|resp
operator|->
name|tr_rmtaddr
operator|=
name|parent_address
expr_stmt|;
if|if
condition|(
operator|!
name|IF_ISSET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrt
operator|->
name|oifs
argument_list|)
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Destination %s not on forwarding tree "
literal|"for src %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|qry
operator|->
name|tr_dst
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|qry
operator|->
name|tr_src
argument_list|)
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_WRONG_IF
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (rt->rt_metric>= UNREACHABLE) { 			resp->tr_rflags = TR_NO_RTE;
comment|/* Hack to send reply directly */
block|rt = NULL; 		}
endif|#
directive|endif
comment|/* 0 */
block|}
comment|/* 	 * If we're the RP for the trace group, note it. 	 */
name|rpentry_ptr
operator|=
name|rp_match
argument_list|(
operator|&
name|grp_sa6
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpentry_ptr
operator|&&
name|local_address
argument_list|(
operator|&
name|rpentry_ptr
operator|->
name|address
argument_list|)
operator|!=
name|NO_VIF
condition|)
name|resp
operator|->
name|tr_rflags
operator|=
name|TR_RP
expr_stmt|;
name|sendit
label|:
comment|/* 	 * if metric is 1 or no. of reports is 1, send response to requestor 	 * else send to upstream router.  If the upstream router can't handle 	 * mtrace, set an error code and send to requestor anyway. 	 */
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rcount:%d, no:%d"
argument_list|,
name|rcount
argument_list|,
name|no
argument_list|)
expr_stmt|;
name|ovifi
operator|=
name|NO_VIF
expr_stmt|;
comment|/* unspecified */
if|if
condition|(
operator|(
name|rcount
operator|+
literal|1
operator|==
name|no
operator|)
operator|||
operator|(
name|mrt
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mrt
operator|->
name|metric
operator|==
literal|1
operator|)
condition|)
block|{
name|resptype
operator|=
name|MLD6_MTRACE_RESP
expr_stmt|;
name|resp_sa6
operator|.
name|sin6_addr
operator|=
name|qry
operator|->
name|tr_raddr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|resp_sa6
operator|.
name|sin6_addr
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|resp_sa6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ovifi
operator|=
name|find_vif_direct
argument_list|(
operator|&
name|dst_sa6
argument_list|)
operator|)
operator|==
name|NO_VIF
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"can't determine outgoing i/f for mtrace "
literal|"response."
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
comment|/* TODO */
block|{
if|#
directive|if
literal|0
block|if (!can_mtrace(rt->rt_parent, rt->rt_gateway)) { 			resp_sa6.sin6_addr = qry->tr_raddr; 			resp->tr_rflags = TR_OLD_ROUTER; 			resptype = MLD6_MTRACE_RESP; 		} else
endif|#
directive|endif
comment|/* 0 */
if|if
condition|(
name|mrt
operator|->
name|incoming
operator|&&
operator|(
name|uvifs
index|[
name|mrt
operator|->
name|incoming
index|]
operator|.
name|uv_flags
operator|&
name|MIFF_REGISTER
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"incoming i/f is for register. "
literal|"Can't be forwarded anymore."
argument_list|)
expr_stmt|;
name|resp_sa6
operator|.
name|sin6_addr
operator|=
name|qry
operator|->
name|tr_raddr
expr_stmt|;
name|resptype
operator|=
name|MLD6_MTRACE_RESP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mrt
operator|->
name|upstream
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|)
name|parent_address
operator|=
name|mrt
operator|->
name|upstream
operator|->
name|address
operator|.
name|sin6_addr
expr_stmt|;
else|else
name|parent_address
operator|=
name|allrouters_group
operator|.
name|sin6_addr
expr_stmt|;
name|resp_sa6
operator|.
name|sin6_addr
operator|=
name|parent_address
expr_stmt|;
name|ovifi
operator|=
name|mrt
operator|->
name|incoming
expr_stmt|;
name|resptype
operator|=
name|MLD6_MTRACE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|resp_sa6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sa6
decl_stmt|;
comment|/* 		 * Send the reply on a known multicast capable vif. 		 * If we don't have one, we can't source any 		 * multicasts anyway. 		 */
if|if
condition|(
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|resp_sa6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|sa6
operator|=
operator|&
name|uvifs
index|[
name|ovifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
expr_stmt|;
name|ifindex
operator|=
name|uvifs
index|[
name|ovifi
index|]
operator|.
name|uv_ifindex
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|phys_vif
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|sa6
operator|=
name|uv_global
argument_list|(
name|phys_vif
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending reply to %s from %s"
argument_list|,
name|inet6_fmt
argument_list|(
name|dst
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ifindex
operator|=
name|uvifs
index|[
name|phys_vif
index|]
operator|.
name|uv_ifindex
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"No enabled phyints -- %s"
argument_list|,
literal|"dropping traceroute reply"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|k_set_hlim
argument_list|(
name|mld6_socket
argument_list|,
name|qry
operator|->
name|tr_rhlim
argument_list|)
expr_stmt|;
name|send_mld6
argument_list|(
name|resptype
argument_list|,
name|no
argument_list|,
name|sa6
argument_list|,
operator|&
name|resp_sa6
argument_list|,
name|group
argument_list|,
name|ifindex
argument_list|,
literal|0
argument_list|,
name|datalen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|k_set_hlim
argument_list|(
name|mld6_socket
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sa6
init|=
name|NULL
decl_stmt|;
name|ifindex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unspecified by default */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|resp_sa6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* ovifi must be valid in this case */
name|ifindex
operator|=
name|uvifs
index|[
name|ovifi
index|]
operator|.
name|uv_ifindex
expr_stmt|;
name|sa6
operator|=
operator|&
name|uvifs
index|[
name|ovifi
index|]
operator|.
name|uv_linklocal
operator|->
name|pa_addr
expr_stmt|;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_TRACE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Sending %s to %s from %s"
argument_list|,
name|resptype
operator|==
name|MLD6_MTRACE_RESP
condition|?
literal|"reply"
else|:
literal|"request on"
argument_list|,
name|inet6_fmt
argument_list|(
name|dst
argument_list|)
argument_list|,
name|sa6
condition|?
name|inet6_fmt
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
else|:
literal|"unspecified"
argument_list|)
expr_stmt|;
name|send_mld6
argument_list|(
name|resptype
argument_list|,
name|no
argument_list|,
name|sa6
argument_list|,
operator|&
name|resp_sa6
argument_list|,
name|group
argument_list|,
name|ifindex
argument_list|,
literal|0
argument_list|,
name|datalen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

