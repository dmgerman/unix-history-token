begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1998 by the University of Southern California.  *  All rights reserved.  *  *  Permission to use, copy, modify, and distribute this software and  *  its documentation in source and binary forms for lawful  *  purposes and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both  *  the copyright notice and this permission notice appear in supporting  *  documentation, and that any documentation, advertising materials,  *  and other materials related to such distribution and use acknowledge  *  that the software was developed by the University of Southern  *  California and/or Information Sciences Institute.  *  The name of the University of Southern California may not  *  be used to endorse or promote products derived from this software  *  without specific prior written permission.  *  *  THE UNIVERSITY OF SOUTHERN CALIFORNIA DOES NOT MAKE ANY REPRESENTATIONS  *  ABOUT THE SUITABILITY OF THIS SOFTWARE FOR ANY PURPOSE.  THIS SOFTWARE IS  *  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  *  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND  *  NON-INFRINGEMENT.  *  *  IN NO EVENT SHALL USC, OR ANY OTHER CONTRIBUTOR BE LIABLE FOR ANY  *  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, WHETHER IN CONTRACT,  *  TORT, OR OTHER FORM OF ACTION, ARISING OUT OF OR IN CONNECTION WITH,  *  THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *  Other copyrights might apply to parts of this software and are so  *  noted when applicable.  */
end_comment

begin_comment
comment|/*  *  Questions concerning this software should be directed to  *  Mickael Hoerdt (hoerdt@clarinet.u-strasbg.fr) LSIIT Strasbourg.  *  */
end_comment

begin_comment
comment|/*  * This program has been derived from pim6dd.          * The pim6dd program is covered by the license in the accompanying file  * named "LICENSE.pim6dd".  */
end_comment

begin_comment
comment|/*  * This program has been derived from pimd.          * The pimd program is covered by the license in the accompanying file  * named "LICENSE.pimd".  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"pimd.h"
end_include

begin_include
include|#
directive|include
file|"vif.h"
end_include

begin_include
include|#
directive|include
file|"mrt.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"pim6_proto.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_include
include|#
directive|include
file|"mld6.h"
end_include

begin_include
include|#
directive|include
file|"rp.h"
end_include

begin_include
include|#
directive|include
file|"kern.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"inet6.h"
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_mroute.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|"routesock.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|process_cache_miss
name|__P
argument_list|(
operator|(
expr|struct
name|mrt6msg
operator|*
name|im
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_wrong_iif
name|__P
argument_list|(
operator|(
expr|struct
name|mrt6msg
operator|*
name|im
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_whole_pkt
name|__P
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|default_source_metric
init|=
name|UCAST_DEFAULT_SOURCE_METRIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|default_source_preference
init|=
name|UCAST_DEFAULT_SOURCE_PREFERENCE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the iif for given address */
end_comment

begin_function
name|vifi_t
name|get_iif
parameter_list|(
name|address
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|address
decl_stmt|;
block|{
name|struct
name|rpfctl
name|rpfc
decl_stmt|;
name|k_req_incoming
argument_list|(
name|address
argument_list|,
operator|&
name|rpfc
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|rpfc
operator|.
name|rpfneighbor
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
name|NO_VIF
operator|)
return|;
return|return
operator|(
name|rpfc
operator|.
name|iif
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the PIM neighbor toward a source */
end_comment

begin_comment
comment|/*  * If route not found or if a local source or if a directly connected source,  * but is not PIM router, or if the first hop router is not a PIM router,  * then return NULL.  */
end_comment

begin_function
name|pim_nbr_entry_t
modifier|*
name|find_pim6_nbr
parameter_list|(
name|source
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|source
decl_stmt|;
block|{
name|struct
name|rpfctl
name|rpfc
decl_stmt|;
name|pim_nbr_entry_t
modifier|*
name|pim_nbr
decl_stmt|;
name|struct
name|sockaddr_in6
name|next_hop_router_addr
decl_stmt|;
if|if
condition|(
name|local_address
argument_list|(
name|source
argument_list|)
operator|!=
name|NO_VIF
condition|)
return|return
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
return|;
name|k_req_incoming
argument_list|(
name|source
argument_list|,
operator|&
name|rpfc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|rpfc
operator|.
name|rpfneighbor
operator|.
name|sin6_addr
argument_list|)
operator|)
operator|||
operator|(
name|rpfc
operator|.
name|iif
operator|==
name|NO_VIF
operator|)
condition|)
return|return
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
return|;
name|next_hop_router_addr
operator|=
name|rpfc
operator|.
name|rpfneighbor
expr_stmt|;
for|for
control|(
name|pim_nbr
operator|=
name|uvifs
index|[
name|rpfc
operator|.
name|iif
index|]
operator|.
name|uv_pim_neighbors
init|;
name|pim_nbr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|;
name|pim_nbr
operator|=
name|pim_nbr
operator|->
name|next
control|)
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|pim_nbr
operator|->
name|address
argument_list|,
operator|&
name|next_hop_router_addr
argument_list|)
condition|)
return|return
operator|(
name|pim_nbr
operator|)
return|;
return|return
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: check again the exact setup if the source is local or directly  * connected!!! Yes Really for Ipv6!!  */
end_comment

begin_comment
comment|/*  * TODO: XXX: change the metric and preference for all (S,G) entries per  * source or RP?  */
end_comment

begin_comment
comment|/*  * TODO - If possible, this would be the place to correct set the source's  * preference and metric to that obtained from the kernel and/or unicast  * routing protocol.  For now, set it to the configured default for local  * pref/metric.  */
end_comment

begin_comment
comment|/*  * Set the iif, upstream router, preference and metric for the route toward  * the source. Return TRUE is the route was found, othewise FALSE. If  * srctype==PIM_IIF_SOURCE and if the source is directly connected then the  * "upstream" is set to NULL. If srcentry==PIM_IIF_RP, then "upstream" in  * case of directly connected "source" will be that "source" (if it is also  * PIM router).,  */
end_comment

begin_function
name|int
name|set_incoming
parameter_list|(
name|srcentry_ptr
parameter_list|,
name|srctype
parameter_list|)
name|srcentry_t
modifier|*
name|srcentry_ptr
decl_stmt|;
name|int
name|srctype
decl_stmt|;
block|{
name|struct
name|rpfctl
name|rpfc
decl_stmt|;
name|struct
name|sockaddr_in6
name|source
init|=
name|srcentry_ptr
operator|->
name|address
decl_stmt|;
name|struct
name|sockaddr_in6
name|neighbor_addr
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|pim_nbr_entry_t
modifier|*
name|n
decl_stmt|;
comment|/* Preference will be 0 if directly connected */
name|srcentry_ptr
operator|->
name|metric
operator|=
literal|0
expr_stmt|;
name|srcentry_ptr
operator|->
name|preference
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|srcentry_ptr
operator|->
name|incoming
operator|=
name|local_address
argument_list|(
operator|&
name|source
argument_list|)
operator|)
operator|!=
name|NO_VIF
condition|)
block|{
comment|/* The source is a local address */
comment|/* TODO: set the upstream to myself? */
name|srcentry_ptr
operator|->
name|upstream
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|srcentry_ptr
operator|->
name|incoming
operator|=
name|find_vif_direct
argument_list|(
operator|&
name|source
argument_list|)
operator|)
operator|!=
name|NO_VIF
condition|)
block|{
comment|/* 	 * The source is directly connected. Check whether we are looking for 	 * real source or RP 	 */
if|if
condition|(
name|srctype
operator|==
name|PIM_IIF_SOURCE
condition|)
block|{
name|srcentry_ptr
operator|->
name|upstream
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
comment|/* PIM_IIF_RP */
name|neighbor_addr
operator|=
name|source
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* TODO: probably need to check the case if the iif is disabled */
comment|/* Use the lastest resource: the kernel unicast routing table */
name|k_req_incoming
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|rpfc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rpfc
operator|.
name|iif
operator|==
name|NO_VIF
operator|)
operator|||
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|rpfc
operator|.
name|rpfneighbor
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* couldn't find a route */
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_MRT | DEBUG_RPF
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"NO ROUTE found for %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|srcentry_ptr
operator|->
name|incoming
operator|=
name|rpfc
operator|.
name|iif
expr_stmt|;
name|neighbor_addr
operator|=
name|rpfc
operator|.
name|rpfneighbor
expr_stmt|;
comment|/* set the preference for sources that aren't directly connected. */
name|v
operator|=
operator|&
name|uvifs
index|[
name|srcentry_ptr
operator|->
name|incoming
index|]
expr_stmt|;
name|srcentry_ptr
operator|->
name|preference
operator|=
name|v
operator|->
name|uv_local_pref
expr_stmt|;
name|srcentry_ptr
operator|->
name|metric
operator|=
name|v
operator|->
name|uv_local_metric
expr_stmt|;
block|}
comment|/*      * The upstream router must be a (PIM router) neighbor, otherwise we are      * in big trouble ;-).       * Yes but the neighbors are link-local and the rp is global ipv6..      */
comment|/* WARNING WARNING WARNING WARNING */
comment|/* If the router is directly connected to the RP and the RP is the BSR , the next hop is  * the globally reachable addresse of the RP : NOT link local neighbor but  * a ipv6 global neighbor...   * the upstream router is the globally reachable router...  *  */
comment|/* WARNING WARNING WARNING WARNING */
name|v
operator|=
operator|&
name|uvifs
index|[
name|srcentry_ptr
operator|->
name|incoming
index|]
expr_stmt|;
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|neighbor_addr
argument_list|)
condition|)
block|{
name|srcentry_ptr
operator|->
name|upstream
operator|=
name|v
operator|->
name|uv_pim_neighbors
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
for|for
control|(
name|n
operator|=
name|v
operator|->
name|uv_pim_neighbors
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
block|{
if|if
condition|(
name|inet6_lessthan
argument_list|(
operator|&
name|neighbor_addr
argument_list|,
operator|&
name|n
operator|->
name|address
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|neighbor_addr
argument_list|,
operator|&
name|n
operator|->
name|address
argument_list|)
condition|)
block|{
comment|/* 	     * The upstream router is found in the list of neighbors. We are 	     * safe! 	     */
name|srcentry_ptr
operator|->
name|upstream
operator|=
name|n
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_RPF
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"For src %s, iif is %d, next hop router is %s"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|srcentry_ptr
operator|->
name|incoming
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|neighbor_addr
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
break|break;
block|}
comment|/* TODO: control the number of messages! */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"For src %s, iif is %d, next hop router is %s: NOT A PIM ROUTER"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|srcentry_ptr
operator|->
name|incoming
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|neighbor_addr
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|srcentry_ptr
operator|->
name|upstream
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: XXX: currently `source` is not used. Will be used with IGMPv3 where  * we have source-specific Join/Prune.  */
end_comment

begin_function
name|void
name|add_leaf
parameter_list|(
name|vifi
parameter_list|,
name|source
parameter_list|,
name|group
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|source
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|group
decl_stmt|;
block|{
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|if_set
name|old_oifs
decl_stmt|;
name|if_set
name|new_oifs
decl_stmt|;
name|if_set
name|new_leaves
decl_stmt|;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|sockaddr6_any
argument_list|,
name|group
argument_list|,
name|MRTF_WC
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|->
name|incoming
operator|==
name|vifi
operator|)
operator|&&
operator|(
operator|!
operator|(
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_DR
operator|)
operator|)
condition|)
block|{
comment|/* 	 * The report is received on the iif for this routing entry and I am 	 * not the DR for that subnet. Ignore it. 	 */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_NEW
condition|)
name|delete_mrtentry
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_MRT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Adding vif %d for group %s"
argument_list|,
name|vifi
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IF_ISSET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|)
condition|)
return|return;
comment|/* Already a leaf */
name|calc_oifs
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|old_oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
name|IF_SET
argument_list|(
name|vifi
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
comment|/* Add the leaf */
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|new_leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calc_oifs
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|new_oifs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_NEW
operator|)
operator|||
operator|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|old_oifs
argument_list|)
operator|&&
operator|(
operator|!
name|IF_ISEMPTY
argument_list|(
operator|&
name|new_oifs
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 	 * A new created entry or the oifs have changed from NULL to 	 * non-NULL. 	 */
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
comment|/* Timeout the Join/Prune 						 * timer */
comment|/* 	 * TODO: explicitly call the function below? 	 * send_pim6_join_prune(mrtentry_ptr->upstream->vifi, 	 * mrtentry_ptr->upstream, pim_join_prune_holdtime); 	 */
block|}
block|}
end_function

begin_comment
comment|/*  * TODO: XXX: currently `source` is not used. To be used with IGMPv3 where we  * have source-specific joins/prunes.  */
end_comment

begin_function
name|void
name|delete_leaf
parameter_list|(
name|vifi
parameter_list|,
name|source
parameter_list|,
name|group
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|source
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|group
decl_stmt|;
block|{
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_srcs
decl_stmt|;
name|if_set
name|new_oifs
decl_stmt|;
name|if_set
name|old_oifs
decl_stmt|;
name|if_set
name|new_leaves
decl_stmt|;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|sockaddr6_any
argument_list|,
name|group
argument_list|,
name|MRTF_WC
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|IF_ISSET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|)
condition|)
return|return;
comment|/* This interface wasn't leaf */
name|calc_oifs
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|old_oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|vifi
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|new_leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|calc_oifs
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|new_oifs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|IF_ISEMPTY
argument_list|(
operator|&
name|old_oifs
argument_list|)
operator|)
operator|&&
name|IF_ISEMPTY
argument_list|(
operator|&
name|new_oifs
argument_list|)
condition|)
block|{
comment|/* The result oifs have changed from non-NULL to NULL */
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
comment|/* Timeout the Join/Prune 						 * timer */
comment|/* 	 * TODO: explicitly call the function? 	 * send_pim6_join_prune(mrtentry_ptr->upstream->vifi, 	 * mrtentry_ptr->upstream, pim_join_prune_holdtime); 	 */
block|}
comment|/*      * Check all (S,G) entries and clear the inherited "leaf" flag. TODO:      * XXX: This won't work for IGMPv3, because there we don't know whether      * the (S,G) leaf oif was inherited from the (*,G) entry or was created      * by source specific IGMP join.      */
for|for
control|(
name|mrtentry_srcs
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|mrtlink
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
control|)
block|{
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|vifi
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|mrtentry_srcs
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|new_leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|calc_oifs
parameter_list|(
name|mrtentry_ptr
parameter_list|,
name|oifs_ptr
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|if_set
modifier|*
name|oifs_ptr
decl_stmt|;
block|{
name|if_set
name|oifs
decl_stmt|;
name|mrtentry_t
modifier|*
name|grp_route
decl_stmt|;
name|mrtentry_t
modifier|*
name|rp_route
decl_stmt|;
comment|/*      * oifs = (((copied_outgoing + my_join) - my_prune) + my_leaves) -      * my_asserted_oifs - incoming_interface, i.e. `leaves` have higher      * priority than `prunes`, but lower priority than `asserted`. The      * incoming interface is always deleted from the oifs      */
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|IF_ZERO
argument_list|(
name|oifs_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_ZERO
argument_list|(
operator|&
name|oifs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_PMBR
operator|)
condition|)
block|{
comment|/* Either (*,G) or (S,G). Merge with the oifs from the (*,*,RP) */
if|if
condition|(
operator|(
name|rp_route
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|mrtlink
operator|)
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|IF_MERGE
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|rp_route
operator|->
name|joined_oifs
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
name|IF_CLR_MASK
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|rp_route
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_MERGE
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|rp_route
operator|->
name|leaves
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
name|IF_CLR_MASK
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|rp_route
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SG
condition|)
block|{
comment|/* (S,G) entry. Merge with the oifs from (*,G) */
if|if
condition|(
operator|(
name|grp_route
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|grp_route
operator|)
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|IF_MERGE
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|grp_route
operator|->
name|joined_oifs
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
name|IF_CLR_MASK
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|grp_route
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_MERGE
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|grp_route
operator|->
name|leaves
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
name|IF_CLR_MASK
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|grp_route
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Calculate my own stuff */
name|IF_MERGE
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
name|IF_CLR_MASK
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_MERGE
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
name|IF_CLR_MASK
argument_list|(
operator|&
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|oifs
argument_list|,
name|oifs_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the iif, join/prune/leaves/asserted interfaces. Calculate and set the  * oifs. Return 1 if oifs change from NULL to not-NULL. Return -1 if oifs  * change from non-NULL to NULL else return 0 If the iif change or if the  * oifs change from NULL to non-NULL or vice-versa, then schedule that  * mrtentry join/prune timer to timeout immediately.  */
end_comment

begin_function
name|int
name|change_interfaces
parameter_list|(
name|mrtentry_ptr
parameter_list|,
name|new_iif
parameter_list|,
name|new_joined_oifs_
parameter_list|,
name|new_pruned_oifs
parameter_list|,
name|new_leaves_
parameter_list|,
name|new_asserted_oifs
parameter_list|,
name|flags
parameter_list|)
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|vifi_t
name|new_iif
decl_stmt|;
name|if_set
modifier|*
name|new_joined_oifs_
decl_stmt|;
name|if_set
modifier|*
name|new_pruned_oifs
decl_stmt|;
name|if_set
modifier|*
name|new_leaves_
decl_stmt|;
name|if_set
modifier|*
name|new_asserted_oifs
decl_stmt|;
name|u_int16
name|flags
decl_stmt|;
block|{
name|if_set
name|new_joined_oifs
decl_stmt|;
comment|/* The oifs for that particular 					 * mrtentry */
name|if_set
name|old_joined_oifs
decl_stmt|;
name|if_set
name|old_pruned_oifs
decl_stmt|;
name|if_set
name|old_leaves
decl_stmt|;
name|if_set
name|new_leaves
decl_stmt|;
name|if_set
name|old_asserted_oifs
decl_stmt|;
name|if_set
name|new_real_oifs
decl_stmt|;
comment|/* The result oifs */
name|if_set
name|old_real_oifs
decl_stmt|;
name|vifi_t
name|old_iif
decl_stmt|;
name|rpentry_t
modifier|*
name|rpentry_ptr
decl_stmt|;
name|cand_rp_t
modifier|*
name|cand_rp_ptr
decl_stmt|;
name|kernel_cache_t
modifier|*
name|kernel_cache_ptr
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_ptr
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_srcs
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_wc
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_rp
decl_stmt|;
name|int
name|delete_mrtentry_flag
decl_stmt|;
name|int
name|return_value
decl_stmt|;
name|int
name|fire_timer_flag
decl_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|IF_COPY
argument_list|(
name|new_joined_oifs_
argument_list|,
operator|&
name|new_joined_oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
name|new_leaves_
argument_list|,
operator|&
name|new_leaves
argument_list|)
expr_stmt|;
name|old_iif
operator|=
name|mrtentry_ptr
operator|->
name|incoming
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|old_joined_oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|old_leaves
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|old_pruned_oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
operator|&
name|old_asserted_oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|,
operator|&
name|old_real_oifs
argument_list|)
expr_stmt|;
name|mrtentry_ptr
operator|->
name|incoming
operator|=
name|new_iif
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|new_joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
name|new_pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|new_leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
name|new_asserted_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|)
expr_stmt|;
name|calc_oifs
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|new_real_oifs
argument_list|)
expr_stmt|;
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|old_real_oifs
argument_list|)
condition|)
block|{
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|new_real_oifs
argument_list|)
condition|)
name|return_value
operator|=
literal|0
expr_stmt|;
else|else
name|return_value
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|new_real_oifs
argument_list|)
condition|)
name|return_value
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|return_value
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|IF_SAME
argument_list|(
operator|&
name|new_real_oifs
argument_list|,
operator|&
name|old_real_oifs
argument_list|)
operator|)
operator|&&
operator|(
name|new_iif
operator|==
name|old_iif
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|MFC_UPDATE_FORCE
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Nothing to change */
if|if
condition|(
operator|(
name|return_value
operator|!=
literal|0
operator|)
operator|||
operator|(
name|new_iif
operator|!=
name|old_iif
operator|)
operator|||
operator|(
name|flags
operator|&
name|MFC_UPDATE_FORCE
operator|)
condition|)
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
name|IF_COPY
argument_list|(
operator|&
name|new_real_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_PMBR
condition|)
block|{
comment|/* (*,*,RP) entry */
name|rpentry_ptr
operator|=
name|mrtentry_ptr
operator|->
name|source
expr_stmt|;
if|if
condition|(
name|rpentry_ptr
operator|==
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Shoudn't happen */
name|rpentry_ptr
operator|->
name|incoming
operator|=
name|new_iif
expr_stmt|;
name|cand_rp_ptr
operator|=
name|rpentry_ptr
operator|->
name|cand_rp
expr_stmt|;
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|new_real_oifs
argument_list|)
condition|)
block|{
name|delete_mrtentry_flag
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|delete_mrtentry_flag
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
name|rsrr_cache_send
argument_list|(
name|mrtentry_ptr
argument_list|,
name|RSRR_NOTIFICATION_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_KERNEL_CACHE
condition|)
block|{
comment|/* Update the kernel MFC entries */
if|if
condition|(
name|delete_mrtentry_flag
operator|==
name|TRUE
condition|)
comment|/* 		 * XXX: no need to send RSRR message. Will do it when delete 		 * the mrtentry. 		 */
for|for
control|(
name|kernel_cache_ptr
operator|=
name|mrtentry_ptr
operator|->
name|kernel_cache
init|;
name|kernel_cache_ptr
operator|!=
operator|(
name|kernel_cache_t
operator|*
operator|)
name|NULL
condition|;
name|kernel_cache_ptr
operator|=
name|kernel_cache_ptr
operator|->
name|next
control|)
name|delete_mrtentry_all_kernel_cache
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|kernel_cache_ptr
operator|=
name|mrtentry_ptr
operator|->
name|kernel_cache
init|;
name|kernel_cache_ptr
operator|!=
operator|(
name|kernel_cache_t
operator|*
operator|)
name|NULL
condition|;
name|kernel_cache_ptr
operator|=
name|kernel_cache_ptr
operator|->
name|next
control|)
comment|/* here mrtentry_ptr->source->address is the RP address */
name|k_chg_mfc
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|source
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|group
argument_list|,
name|new_iif
argument_list|,
operator|&
name|new_real_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Update all (*,G) entries associated with this RP. The particular 	 * (*,G) outgoing are not changed, but the change in the (*,*,RP) 	 * oifs may have affect the real oifs. 	 */
name|fire_timer_flag
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|rp_grp_entry_ptr
operator|=
name|cand_rp_ptr
operator|->
name|rp_grp_next
init|;
name|rp_grp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|rp_grp_entry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|rp_grp_next
control|)
block|{
for|for
control|(
name|grpentry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|grplink
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_ptr
operator|->
name|rpnext
control|)
block|{
if|if
condition|(
name|grpentry_ptr
operator|->
name|grp_route
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|change_interfaces
argument_list|(
name|grpentry_ptr
operator|->
name|grp_route
argument_list|,
name|new_iif
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|joined_oifs
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|leaves
argument_list|,
operator|&
name|grpentry_ptr
operator|->
name|grp_route
operator|->
name|asserted_oifs
argument_list|,
name|flags
argument_list|)
condition|)
name|fire_timer_flag
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* Change all (S,G) entries if no (*,G) */
for|for
control|(
name|mrtentry_srcs
operator|=
name|grpentry_ptr
operator|->
name|mrtlink
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
control|)
block|{
if|if
condition|(
name|mrtentry_srcs
operator|->
name|flags
operator|&
name|MRTF_RP
condition|)
block|{
if|if
condition|(
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|new_iif
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|,
name|flags
argument_list|)
condition|)
name|fire_timer_flag
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|mrtentry_srcs
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|,
name|flags
argument_list|)
condition|)
name|fire_timer_flag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|fire_timer_flag
operator|==
name|TRUE
condition|)
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_mrtentry_flag
operator|==
name|TRUE
condition|)
block|{
comment|/* 	     * TODO: XXX: trigger a Prune message? Don't delete now, it will 	     * be automatically timed out. If want to delete now, don't 	     * reference to it anymore! delete_mrtentry(mrtentry_ptr); 	     */
block|}
return|return
operator|(
name|return_value
operator|)
return|;
comment|/* (*,*,RP) */
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_WC
condition|)
block|{
comment|/* (*,G) entry */
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|new_real_oifs
argument_list|)
condition|)
name|delete_mrtentry_flag
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|delete_mrtentry_flag
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
name|rsrr_cache_send
argument_list|(
name|mrtentry_ptr
argument_list|,
name|RSRR_NOTIFICATION_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_KERNEL_CACHE
condition|)
block|{
if|if
condition|(
name|delete_mrtentry_flag
operator|==
name|TRUE
condition|)
name|delete_mrtentry_all_kernel_cache
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|kernel_cache_ptr
operator|=
name|mrtentry_ptr
operator|->
name|kernel_cache
init|;
name|kernel_cache_ptr
operator|!=
operator|(
name|kernel_cache_t
operator|*
operator|)
name|NULL
condition|;
name|kernel_cache_ptr
operator|=
name|kernel_cache_ptr
operator|->
name|next
control|)
name|k_chg_mfc
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|source
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|group
argument_list|,
name|new_iif
argument_list|,
operator|&
name|new_real_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|rpaddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Update all (S,G) entries for this group. For the (S,G)RPbit 	 * entries the iif is the iif toward the RP; The particular (S,G) 	 * oifs are not changed, but the change in the (*,G) oifs may affect 	 * the real oifs. 	 */
name|fire_timer_flag
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|mrtentry_srcs
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|mrtlink
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
control|)
block|{
if|if
condition|(
name|mrtentry_srcs
operator|->
name|flags
operator|&
name|MRTF_RP
condition|)
block|{
if|if
condition|(
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|new_iif
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|,
name|flags
argument_list|)
condition|)
name|fire_timer_flag
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|mrtentry_srcs
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|,
name|flags
argument_list|)
condition|)
name|fire_timer_flag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fire_timer_flag
operator|==
name|TRUE
condition|)
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|delete_mrtentry_flag
operator|==
name|TRUE
condition|)
block|{
comment|/* TODO: XXX: the oifs are NULL. Send a Prune message? */
block|}
return|return
operator|(
name|return_value
operator|)
return|;
comment|/* (*,G) */
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SG
condition|)
block|{
comment|/* (S,G) entry */
ifdef|#
directive|ifdef
name|KERNEL_MFC_WC_G
name|if_set
name|tmp_oifs
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_tmp
decl_stmt|;
endif|#
directive|endif
comment|/* KERNEL_MFC_WC_G */
name|mrtentry_rp
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|mrtlink
expr_stmt|;
name|mrtentry_wc
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|grp_route
expr_stmt|;
ifdef|#
directive|ifdef
name|KERNEL_MFC_WC_G
comment|/* 	 * Check whether (*,*,RP) or (*,G) have different (iif,oifs) from the 	 * (S,G). If "yes", then forbid creating (*,G) MFC. 	 */
for|for
control|(
name|mrtentry_tmp
operator|=
name|mrtentry_rp
init|;
literal|1
condition|;
name|mrtentry_tmp
operator|=
name|mrtentry_wc
control|)
block|{
for|for
control|(
init|;
literal|1
condition|;
control|)
block|{
if|if
condition|(
name|mrtentry_tmp
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
break|break;
if|if
condition|(
name|mrtentry_tmp
operator|->
name|flags
operator|&
name|MRTF_MFC_CLONE_SG
condition|)
break|break;
if|if
condition|(
name|mrtentry_tmp
operator|->
name|incoming
operator|!=
name|mrtentry_ptr
operator|->
name|incoming
condition|)
block|{
name|delete_single_kernel_cache_addr
argument_list|(
name|mrtentry_tmp
argument_list|,
name|IN6ADDR_ANY_N
argument_list|,
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
argument_list|)
expr_stmt|;
name|mrtentry_tmp
operator|->
name|flags
operator||=
name|MRTF_MFC_CLONE_SG
expr_stmt|;
break|break;
block|}
name|calc_oifs
argument_list|(
name|mrtentry_tmp
argument_list|,
operator|&
name|tmp_oifs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|IF_SAME
argument_list|(
operator|&
name|new_real_oifs
argument_list|,
operator|&
name|tmp_oifs
argument_list|)
operator|)
condition|)
name|mrtentry_tmp
operator|->
name|flags
operator||=
name|MRTF_MFC_CLONE_SG
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mrtentry_tmp
operator|==
name|mrtentry_wc
condition|)
break|break;
block|}
endif|#
directive|endif
comment|/* KERNEL_MFC_WC_G */
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|new_real_oifs
argument_list|)
condition|)
name|delete_mrtentry_flag
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|delete_mrtentry_flag
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
name|rsrr_cache_send
argument_list|(
name|mrtentry_ptr
argument_list|,
name|RSRR_NOTIFICATION_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_KERNEL_CACHE
condition|)
block|{
if|if
condition|(
name|delete_mrtentry_flag
operator|==
name|TRUE
condition|)
name|delete_mrtentry_all_kernel_cache
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
else|else
block|{
name|k_chg_mfc
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|group
argument_list|,
name|new_iif
argument_list|,
operator|&
name|new_real_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|rpaddr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old_iif
operator|!=
name|new_iif
condition|)
block|{
if|if
condition|(
name|new_iif
operator|==
name|mrtentry_ptr
operator|->
name|source
operator|->
name|incoming
condition|)
block|{
comment|/* 		 * For example, if this was (S,G)RPbit with iif toward the 		 * RP, and now switch to the Shortest Path. The setup of 		 * MRTF_SPT flag must be done by the external calling 		 * function (triggered only by receiving of a data from the 		 * source.) 		 */
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_RP
expr_stmt|;
comment|/* 		 * TODO: XXX: delete? Check again where will be the best 		 * place to set it. mrtentry_ptr->flags |= MRTF_SPT; 		 */
block|}
if|if
condition|(
operator|(
operator|(
name|mrtentry_wc
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|mrtentry_wc
operator|->
name|incoming
operator|==
name|new_iif
operator|)
operator|)
operator|||
operator|(
operator|(
name|mrtentry_rp
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
name|mrtentry_rp
operator|->
name|incoming
operator|==
name|new_iif
operator|)
operator|)
condition|)
block|{
comment|/* 		 * If the new iif points toward the RP, reset the SPT flag. 		 * (PIM-SM-spec-10.ps pp. 11, 2.10, last sentence of first 		 * paragraph. 		 */
comment|/* TODO: XXX: check again! */
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_SPT
expr_stmt|;
name|mrtentry_ptr
operator|->
name|flags
operator||=
name|MRTF_RP
expr_stmt|;
block|}
block|}
comment|/* 	 * TODO: XXX: if this is (S,G)RPbit entry and the oifs==(*,G)oifs, 	 * then delete the (S,G) entry?? The same if we have (*,*,RP) ? 	 */
if|if
condition|(
name|delete_mrtentry_flag
operator|==
name|TRUE
condition|)
block|{
comment|/* TODO: XXX: the oifs are NULL. Send a Prune message ? */
block|}
comment|/* TODO: XXX: have the feeling something is missing.... */
return|return
operator|(
name|return_value
operator|)
return|;
comment|/* (S,G) */
block|}
return|return
operator|(
name|return_value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: implement it. Required to allow changing of the physical interfaces  * configuration without need to restart pimd.  */
end_comment

begin_function
name|int
name|delete_vif_from_mrt
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|process_kernel_call
parameter_list|()
block|{
specifier|register
name|struct
name|mrt6msg
modifier|*
name|im
decl_stmt|;
comment|/* igmpmsg control struct */
name|im
operator|=
operator|(
expr|struct
name|mrt6msg
operator|*
operator|)
name|mld6_recv_buf
expr_stmt|;
switch|switch
condition|(
name|im
operator|->
name|im6_msgtype
condition|)
block|{
case|case
name|MRT6MSG_NOCACHE
case|:
name|process_cache_miss
argument_list|(
name|im
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT6MSG_WRONGMIF
case|:
name|process_wrong_iif
argument_list|(
name|im
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT6MSG_WHOLEPKT
case|:
name|process_whole_pkt
argument_list|(
name|mld6_recv_buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IF_DEBUG
argument_list|(
argument|DEBUG_KERN
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Unknown kernel_call code"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * TODO: when cache miss, check the iif, because probably ASSERTS shoult take  * place  */
end_comment

begin_function
specifier|static
name|void
name|process_cache_miss
parameter_list|(
name|im
parameter_list|)
name|struct
name|mrt6msg
modifier|*
name|im
decl_stmt|;
block|{
specifier|static
name|struct
name|sockaddr_in6
name|source
init|=
block|{
sizeof|sizeof
argument_list|(
name|source
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in6
name|mfc_source
init|=
block|{
sizeof|sizeof
argument_list|(
name|source
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in6
name|group
init|=
block|{
sizeof|sizeof
argument_list|(
name|group
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in6
name|rp_addr
init|=
block|{
sizeof|sizeof
argument_list|(
name|source
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|vifi_t
name|iif
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_rp
decl_stmt|;
comment|/*      * When there is a cache miss, we check only the header of the packet      * (and only it should be sent up by the kernel.)      */
name|group
operator|.
name|sin6_addr
operator|=
name|im
operator|->
name|im6_dst
expr_stmt|;
name|group
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|group
argument_list|,
operator|&
name|uvifs
index|[
name|im
operator|->
name|im6_mif
index|]
argument_list|)
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|mfc_source
operator|.
name|sin6_addr
operator|=
name|im
operator|->
name|im6_src
expr_stmt|;
name|source
operator|.
name|sin6_scope_id
operator|=
name|inet6_uvif2scopeid
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|uvifs
index|[
name|im
operator|->
name|im6_mif
index|]
argument_list|)
expr_stmt|;
name|iif
operator|=
name|im
operator|->
name|im6_mif
expr_stmt|;
name|uvifs
index|[
name|iif
index|]
operator|.
name|uv_cache_miss
operator|++
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_MFC
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Cache miss, src %s, dst %s, iif %d"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|source
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|iif
argument_list|)
expr_stmt|;
comment|/*      * TODO: XXX: check whether the kernel generates cache miss for the LAN      * scoped addresses      */
comment|/* Don't create routing entries for the LAN scoped addresses */
if|if
condition|(
name|IN6_IS_ADDR_MC_NODELOCAL
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
operator|||
comment|/* sanity? */
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* TODO: check if correct in case the source is one of my addresses */
comment|/*      * If I am the DR for this source, create (S,G) and add the register_vif      * to the oifs.      */
if|if
condition|(
operator|(
name|uvifs
index|[
name|iif
index|]
operator|.
name|uv_flags
operator|&
name|VIFF_DR
operator|)
operator|&&
operator|(
name|find_vif_direct_local
argument_list|(
operator|&
name|source
argument_list|)
operator|==
name|iif
operator|)
condition|)
block|{
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
comment|/* set reg_vif_num as outgoing interface ONLY if I am not the RP */
if|if
condition|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|rpaddr
argument_list|,
operator|&
name|my_cand_rp_address
argument_list|)
condition|)
name|IF_SET
argument_list|(
name|reg_vif_num
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
operator||
name|MRTF_WC
operator||
name|MRTF_PMBR
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/*      * TODO: if there are too many cache miss for the same (S,G), install      * negative cache entry in the kernel (oif==NULL) to prevent too many      * upcalls.      */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|incoming
operator|==
name|iif
condition|)
block|{
if|if
condition|(
operator|!
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
condition|)
block|{
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SG
condition|)
block|{
comment|/* TODO: check that the RPbit is not set? */
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|timer
operator|<
name|pim_data_timeout
condition|)
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|pim_data_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SPT
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|mrtentry_rp
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|grp_route
operator|)
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
name|mrtentry_rp
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|mrtlink
expr_stmt|;
if|if
condition|(
name|mrtentry_rp
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 			 * Check if the (S,G) iif is different from the (*,G) 			 * or (*,*,RP) iif 			 */
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|->
name|incoming
operator|!=
name|mrtentry_rp
operator|->
name|incoming
operator|)
operator|||
operator|(
name|mrtentry_ptr
operator|->
name|upstream
operator|!=
name|mrtentry_rp
operator|->
name|upstream
operator|)
condition|)
block|{
name|mrtentry_ptr
operator|->
name|flags
operator||=
name|MRTF_SPT
expr_stmt|;
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_RP
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_PMBR
condition|)
name|rp_addr
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|address
expr_stmt|;
else|else
name|rp_addr
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|rpaddr
expr_stmt|;
name|mfc_source
operator|=
name|source
expr_stmt|;
comment|// TODO
ifdef|#
directive|ifdef
name|KERNEL_MFC_WC_G
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
operator|(
name|MRTF_WC
operator||
name|MRTF_PMBR
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_MFC_CLONE_SG
operator|)
condition|)
name|mfc_source
operator|=
name|IN6ADDR_ANY_N
expr_stmt|;
endif|#
directive|endif
comment|/* KERNEL_MFC_WC_G */
name|add_kernel_cache
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|mfc_source
argument_list|,
operator|&
name|group
argument_list|,
name|MFC_MOVE_FORCE
argument_list|)
expr_stmt|;
name|k_chg_mfc
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|mfc_source
argument_list|,
operator|&
name|group
argument_list|,
name|iif
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|,
operator|&
name|rp_addr
argument_list|)
expr_stmt|;
comment|/* 	     * TODO: XXX: No need for RSRR message, because nothing has 	     * changed. 	     */
block|}
return|return;
comment|/* iif match */
block|}
comment|/* The iif doesn't match */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SG
condition|)
block|{
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SPT
condition|)
comment|/* Arrived on wrong interface */
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|mrtentry_rp
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|grp_route
operator|)
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
name|mrtentry_rp
operator|=
name|mrtentry_ptr
operator|->
name|group
operator|->
name|active_rp_grp
operator|->
name|rp
operator|->
name|rpentry
operator|->
name|mrtlink
expr_stmt|;
if|if
condition|(
name|mrtentry_rp
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|mrtentry_rp
operator|->
name|incoming
operator|==
name|iif
condition|)
block|{
comment|/* Forward on (*,G) or (*,*,RP) */
ifdef|#
directive|ifdef
name|KERNEL_MFC_WC_G
if|if
condition|(
operator|!
operator|(
name|mrtentry_rp
operator|->
name|flags
operator|&
name|MRTF_MFC_CLONE_SG
operator|)
condition|)
name|mfc_source
operator|=
name|IN6ADDR_ANY_N
expr_stmt|;
endif|#
directive|endif
comment|/* KERNEL_MFC_WC_G */
name|add_kernel_cache
argument_list|(
name|mrtentry_rp
argument_list|,
operator|&
name|mfc_source
argument_list|,
operator|&
name|group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|k_chg_mfc
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|mfc_source
argument_list|,
operator|&
name|group
argument_list|,
name|iif
argument_list|,
operator|&
name|mrtentry_rp
operator|->
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|rpaddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
name|rsrr_cache_send
argument_list|(
name|mrtentry_rp
argument_list|,
name|RSRR_NOTIFICATION_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
return|return;
block|}
block|}
goto|goto
name|fail
goto|;
block|}
name|fail
label|:
name|uvifs
index|[
name|iif
index|]
operator|.
name|uv_cache_notcreated
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A multicast packet has been received on wrong iif by the kernel. Check for  * a matching entry. If there is (S,G) with reset SPTbit and the packet was  * received on the iif toward the source, this completes the switch to the  * shortest path and triggers (S,G) prune toward the RP (unless I am the RP).  * Otherwise, if the packet's iif is in the oiflist of the routing entry,  * trigger an Assert.  */
end_comment

begin_function
specifier|static
name|void
name|process_wrong_iif
parameter_list|(
name|im
parameter_list|)
name|struct
name|mrt6msg
modifier|*
name|im
decl_stmt|;
block|{
specifier|static
name|struct
name|sockaddr_in6
name|source
init|=
block|{
sizeof|sizeof
argument_list|(
name|source
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in6
name|group
init|=
block|{
sizeof|sizeof
argument_list|(
name|group
argument_list|)
block|,
name|AF_INET6
block|}
decl_stmt|;
name|vifi_t
name|iif
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
name|group
operator|.
name|sin6_addr
operator|=
name|im
operator|->
name|im6_dst
expr_stmt|;
name|source
operator|.
name|sin6_addr
operator|=
name|im
operator|->
name|im6_src
expr_stmt|;
name|iif
operator|=
name|im
operator|->
name|im6_mif
expr_stmt|;
comment|/* Don't create routing entries for the LAN scoped addresses */
if|if
condition|(
name|IN6_IS_ADDR_MC_NODELOCAL
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
operator|||
comment|/* sanity? */
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|group
operator|.
name|sin6_addr
argument_list|)
condition|)
return|return;
comment|/*      * Ignore if it comes on register vif. register vif is neither SPT iif,      * neither is used to send asserts out.      */
if|if
condition|(
name|uvifs
index|[
name|iif
index|]
operator|.
name|uv_flags
operator|&
name|MIFF_REGISTER
condition|)
return|return;
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MRTF_SG
operator||
name|MRTF_WC
operator||
name|MRTF_PMBR
argument_list|,
name|DONT_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_ptr
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
return|return;
comment|/*      * TODO: check again!      */
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SG
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_SPT
operator|)
condition|)
block|{
if|if
condition|(
name|mrtentry_ptr
operator|->
name|source
operator|->
name|incoming
operator|==
name|iif
condition|)
block|{
comment|/* Switch to the Shortest Path */
name|mrtentry_ptr
operator|->
name|flags
operator||=
name|MRTF_SPT
expr_stmt|;
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_RP
expr_stmt|;
name|add_kernel_cache
argument_list|(
name|mrtentry_ptr
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|MFC_MOVE_FORCE
argument_list|)
expr_stmt|;
name|k_chg_mfc
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|iif
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|group
operator|->
name|rpaddr
argument_list|)
expr_stmt|;
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSRR
name|rsrr_cache_send
argument_list|(
name|mrtentry_ptr
argument_list|,
name|RSRR_NOTIFICATION_OK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RSRR */
return|return;
block|}
block|}
block|}
comment|/* Trigger an Assert */
if|if
condition|(
name|IF_ISSET
argument_list|(
name|iif
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|oifs
argument_list|)
condition|)
name|send_pim6_assert
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|group
argument_list|,
name|iif
argument_list|,
name|mrtentry_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receives whole packets from the register vif entries in the kernel, and  * calls the send_pim_register procedure to encapsulate the packets and  * unicasts them to the RP.  */
end_comment

begin_function
specifier|static
name|void
name|process_whole_pkt
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|send_pim6_register
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mrt6msg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|mrtentry_t
modifier|*
name|switch_shortest_path
parameter_list|(
name|source
parameter_list|,
name|group
parameter_list|)
name|struct
name|sockaddr_in6
modifier|*
name|source
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|group
decl_stmt|;
block|{
name|mrtentry_t
modifier|*
name|mrtentry_ptr
decl_stmt|;
comment|/* TODO: XXX: prepare and send immediately the (S,G) join? */
if|if
condition|(
operator|(
name|mrtentry_ptr
operator|=
name|find_route
argument_list|(
name|source
argument_list|,
name|group
argument_list|,
name|MRTF_SG
argument_list|,
name|CREATE
argument_list|)
operator|)
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_NEW
condition|)
block|{
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_NEW
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mrtentry_ptr
operator|->
name|flags
operator|&
name|MRTF_RP
condition|)
block|{
comment|/* 		 * (S,G)RPbit with iif toward RP. Reset to (S,G) with iif 		 * toward S. Delete the kernel cache (if any), because 		 * change_interfaces() will reset it with iif toward S and no 		 * data will arrive from RP before the switch really occurs. 		 */
name|mrtentry_ptr
operator|->
name|flags
operator|&=
operator|~
name|MRTF_RP
expr_stmt|;
name|mrtentry_ptr
operator|->
name|incoming
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|incoming
expr_stmt|;
name|mrtentry_ptr
operator|->
name|upstream
operator|=
name|mrtentry_ptr
operator|->
name|source
operator|->
name|upstream
expr_stmt|;
name|delete_mrtentry_all_kernel_cache
argument_list|(
name|mrtentry_ptr
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_ptr
argument_list|,
name|mrtentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_ptr
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|SET_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|timer
argument_list|,
name|pim_data_timeout
argument_list|)
expr_stmt|;
name|FIRE_TIMER
argument_list|(
name|mrtentry_ptr
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mrtentry_ptr
operator|)
return|;
block|}
end_function

end_unit

