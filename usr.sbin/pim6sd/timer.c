begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1998 by the University of Southern California.  *  All rights reserved.  *  *  Permission to use, copy, modify, and distribute this software and  *  its documentation in source and binary forms for lawful  *  purposes and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both  *  the copyright notice and this permission notice appear in supporting  *  documentation, and that any documentation, advertising materials,  *  and other materials related to such distribution and use acknowledge  *  that the software was developed by the University of Southern  *  California and/or Information Sciences Institute.  *  The name of the University of Southern California may not  *  be used to endorse or promote products derived from this software  *  without specific prior written permission.  *  *  THE UNIVERSITY OF SOUTHERN CALIFORNIA DOES NOT MAKE ANY REPRESENTATIONS  *  ABOUT THE SUITABILITY OF THIS SOFTWARE FOR ANY PURPOSE.  THIS SOFTWARE IS  *  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  *  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND  *  NON-INFRINGEMENT.  *  *  IN NO EVENT SHALL USC, OR ANY OTHER CONTRIBUTOR BE LIABLE FOR ANY  *  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, WHETHER IN CONTRACT,  *  TORT, OR OTHER FORM OF ACTION, ARISING OUT OF OR IN CONNECTION WITH,  *  THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *  Other copyrights might apply to parts of this software and are so  *  noted when applicable.  */
end_comment

begin_comment
comment|/*  *  Questions concerning this software should be directed to  *  Mickael Hoerdt (hoerdt@clarinet.u-strasbg.fr) LSIIT Strasbourg.  *  */
end_comment

begin_comment
comment|/*  * This program has been derived from pim6dd.          * The pim6dd program is covered by the license in the accompanying file  * named "LICENSE.pim6dd".  */
end_comment

begin_comment
comment|/*  * This program has been derived from pimd.          * The pimd program is covered by the license in the accompanying file  * named "LICENSE.pimd".  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|"pimd.h"
end_include

begin_include
include|#
directive|include
file|"mrt.h"
end_include

begin_include
include|#
directive|include
file|"vif.h"
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_mroute.h>
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"rp.h"
end_include

begin_include
include|#
directive|include
file|"pim6_proto.h"
end_include

begin_include
include|#
directive|include
file|"mld6.h"
end_include

begin_include
include|#
directive|include
file|"mld6_proto.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_include
include|#
directive|include
file|"kern.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"inet6.h"
end_include

begin_comment
comment|/*  * Global variables  */
end_comment

begin_comment
comment|/*  * XXX: The RATE is in bits/s. To include the header overhead, the  * approximation is 1 byte/s = 10 bits/s `whatever_bytes` is the maximum  * number of bytes within the test interval.  */
end_comment

begin_decl_stmt
name|u_int32
name|timer_interval
init|=
name|DEFAULT_TIMER_INTERVAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_reg_rate_bytes
init|=
operator|(
name|PIM_DEFAULT_REG_RATE
operator|*
name|PIM_DEFAULT_REG_RATE_INTERVAL
operator|)
operator|/
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_reg_rate_check_interval
init|=
name|PIM_DEFAULT_REG_RATE_INTERVAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_data_rate_bytes
init|=
operator|(
name|PIM_DEFAULT_DATA_RATE
operator|*
name|PIM_DEFAULT_DATA_RATE_INTERVAL
operator|)
operator|/
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_data_rate_check_interval
init|=
name|PIM_DEFAULT_DATA_RATE_INTERVAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_hello_period
init|=
name|PIM_TIMER_HELLO_PERIOD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_hello_holdtime
init|=
name|PIM_TIMER_HELLO_HOLDTIME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_join_prune_period
init|=
name|PIM_JOIN_PRUNE_PERIOD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_join_prune_holdtime
init|=
name|PIM_JOIN_PRUNE_HOLDTIME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_data_timeout
init|=
name|PIM_DATA_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_register_suppression_timeout
init|=
name|PIM_REGISTER_SUPPRESSION_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_register_probe_time
init|=
name|PIM_REGISTER_PROBE_TIME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32
name|pim_assert_timeout
init|=
name|PIM_ASSERT_TIMEOUT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local functions definitions.  */
end_comment

begin_comment
comment|/*  * Local variables  */
end_comment

begin_decl_stmt
name|u_int16
name|unicast_routing_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to check periodically for any 					 * change in the unicast routing. */
end_comment

begin_decl_stmt
name|u_int16
name|unicast_routing_check_interval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8
name|ucast_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to indicate there was a timeout */
end_comment

begin_decl_stmt
name|u_int16
name|pim_data_rate_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to check periodically the 					 * datarate of the active sources and 					 * eventually switch to the shortest 					 * path (if forwarder) */
end_comment

begin_decl_stmt
name|u_int8
name|pim_data_rate_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to indicate there was a 					 * timeout */
end_comment

begin_decl_stmt
name|u_int16
name|pim_reg_rate_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The same as above, but used by the 					 * RP to switch to the shortest path 					 * and avoid the PIM registers. */
end_comment

begin_decl_stmt
name|u_int8
name|pim_reg_rate_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int8
name|rate_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TODO: XXX: the timers below are not used. Instead, the data rate timer is  * used.  */
end_comment

begin_decl_stmt
name|u_int16
name|kernel_cache_timer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to timeout the kernel cache 					 * entries for idle sources */
end_comment

begin_decl_stmt
name|u_int16
name|kernel_cache_check_interval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to request and compare any route changes */
end_comment

begin_decl_stmt
name|srcentry_t
name|srcentry_save
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|rpentry_t
name|rpentry_save
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Init some timers  */
end_comment

begin_function
name|void
name|init_timers
parameter_list|()
block|{
name|unicast_routing_check_interval
operator|=
name|UCAST_ROUTING_CHECK_INTERVAL
expr_stmt|;
name|SET_TIMER
argument_list|(
name|unicast_routing_timer
argument_list|,
name|unicast_routing_check_interval
argument_list|)
expr_stmt|;
comment|/*      * The routing_check and the rate_check timers are interleaved to reduce      * the amount of work that has to be done at once.      */
comment|/* XXX: for simplicity, both the intervals are the same */
if|if
condition|(
name|pim_data_rate_check_interval
operator|<
name|pim_reg_rate_check_interval
condition|)
name|pim_reg_rate_check_interval
operator|=
name|pim_data_rate_check_interval
expr_stmt|;
name|SET_TIMER
argument_list|(
name|pim_data_rate_timer
argument_list|,
literal|3
operator|*
name|pim_data_rate_check_interval
operator|/
literal|2
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|pim_reg_rate_timer
argument_list|,
literal|3
operator|*
name|pim_reg_rate_check_interval
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/*      * Initialize the srcentry and rpentry used to save the old routes during      * unicast routing change discovery process.      */
name|srcentry_save
operator|.
name|prev
operator|=
operator|(
name|srcentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|srcentry_save
operator|.
name|next
operator|=
operator|(
name|srcentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|srcentry_save
operator|.
name|address
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|srcentry_save
operator|.
name|address
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|srcentry_save
operator|.
name|address
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|srcentry_save
operator|.
name|mrtlink
operator|=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|srcentry_save
operator|.
name|incoming
operator|=
name|NO_VIF
expr_stmt|;
name|srcentry_save
operator|.
name|upstream
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|srcentry_save
operator|.
name|metric
operator|=
operator|~
literal|0
expr_stmt|;
name|srcentry_save
operator|.
name|preference
operator|=
operator|~
literal|0
expr_stmt|;
name|RESET_TIMER
argument_list|(
name|srcentry_save
operator|.
name|timer
argument_list|)
expr_stmt|;
name|srcentry_save
operator|.
name|cand_rp
operator|=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|rpentry_save
operator|.
name|prev
operator|=
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|rpentry_save
operator|.
name|next
operator|=
operator|(
name|rpentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rpentry_save
operator|.
name|address
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|rpentry_save
operator|.
name|address
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|rpentry_save
operator|.
name|address
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|rpentry_save
operator|.
name|mrtlink
operator|=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|rpentry_save
operator|.
name|incoming
operator|=
name|NO_VIF
expr_stmt|;
name|rpentry_save
operator|.
name|upstream
operator|=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|rpentry_save
operator|.
name|metric
operator|=
operator|~
literal|0
expr_stmt|;
name|rpentry_save
operator|.
name|preference
operator|=
operator|~
literal|0
expr_stmt|;
name|RESET_TIMER
argument_list|(
name|rpentry_save
operator|.
name|timer
argument_list|)
expr_stmt|;
name|rpentry_save
operator|.
name|cand_rp
operator|=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * On every timer interrupt, advance (i.e. decrease) the timer for each  * neighbor and group entry for each vif.  */
end_comment

begin_function
name|void
name|age_vifs
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
specifier|register
name|pim_nbr_entry_t
modifier|*
name|next_nbr
decl_stmt|,
modifier|*
name|curr_nbr
decl_stmt|;
comment|/*      * XXX: TODO: currently, sending to qe* interface which is DOWN doesn't      * return error (ENETDOWN) on my Solaris machine, so have to check      * periodically the interfaces status. If this is fixed, just remove the      * defs around the "if (vifs_down)" line.      */
if|#
directive|if
operator|(
operator|!
operator|(
operator|(
name|defined
name|SunOS
operator|)
operator|&&
operator|(
name|SunOS
operator|>=
literal|50
operator|)
operator|)
operator|)
if|if
condition|(
name|vifs_down
condition|)
endif|#
directive|endif
comment|/* Solaris */
name|check_vif_state
argument_list|()
expr_stmt|;
comment|/* Age many things */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
name|uvifs
init|;
name|vifi
operator|<
name|numvifs
condition|;
operator|++
name|vifi
operator|,
operator|++
name|v
control|)
block|{
if|if
condition|(
name|v
operator|->
name|uv_flags
operator|&
operator|(
name|VIFF_DISABLED
operator||
name|VIFF_DOWN
operator||
name|MIFF_REGISTER
operator|)
condition|)
continue|continue;
comment|/* Timeout the MLD querier (unless we re the querier) */
if|if
condition|(
operator|(
name|v
operator|->
name|uv_flags
operator|&
name|VIFF_QUERIER
operator|)
operator|==
literal|0
operator|&&
name|v
operator|->
name|uv_querier
condition|)
block|{
comment|/* this must be non-NULL, but check for safety. */
name|IF_TIMEOUT
argument_list|(
argument|v->uv_querier->al_timer
argument_list|)
block|{
name|v
operator|->
name|uv_querier_timo
operator|++
expr_stmt|;
comment|/* count statistics */
comment|/* act as a querier by myself */
name|v
operator|->
name|uv_flags
operator||=
name|VIFF_QUERIER
expr_stmt|;
name|v
operator|->
name|uv_querier
operator|->
name|al_addr
operator|=
name|v
operator|->
name|uv_linklocal
operator|->
name|pa_addr
expr_stmt|;
name|v
operator|->
name|uv_querier
operator|->
name|al_timer
operator|=
name|MLD6_OTHER_QUERIER_PRESENT_INTERVAL
expr_stmt|;
name|time
argument_list|(
operator|&
name|v
operator|->
name|uv_querier
operator|->
name|al_ctime
argument_list|)
expr_stmt|;
comment|/* reset timestamp */
name|query_groups
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Timeout neighbors */
for|for
control|(
name|curr_nbr
operator|=
name|v
operator|->
name|uv_pim_neighbors
init|;
name|curr_nbr
operator|!=
name|NULL
condition|;
name|curr_nbr
operator|=
name|next_nbr
control|)
block|{
name|next_nbr
operator|=
name|curr_nbr
operator|->
name|next
expr_stmt|;
comment|/* 	     * Never timeout neighbors with holdtime = 0xffff. This may be 	     * used with ISDN lines to avoid keeping the link up with 	     * periodic Hello messages. 	     */
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|PIM_MESSAGE_HELLO_HOLDTIME_FOREVER
operator|==
name|curr_nbr
operator|->
name|timer
condition|)
continue|continue;
name|IF_NOT_TIMEOUT
argument_list|(
argument|curr_nbr->timer
argument_list|)
continue|continue;
name|v
operator|->
name|uv_pim6_nbr_timo
operator|++
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_HELLO
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"%s on %s is dead , delete it"
argument_list|,
name|inet6_fmt
argument_list|(
operator|&
name|curr_nbr
operator|->
name|address
operator|.
name|sin6_addr
argument_list|)
argument_list|,
name|uvifs
index|[
name|curr_nbr
operator|->
name|vifi
index|]
operator|.
name|uv_name
argument_list|)
expr_stmt|;
name|delete_pim6_nbr
argument_list|(
name|curr_nbr
argument_list|)
expr_stmt|;
block|}
comment|/* PIM_HELLO periodic */
name|IF_TIMEOUT
argument_list|(
argument|v->uv_pim_hello_timer
argument_list|)
name|send_pim6_hello
argument_list|(
name|v
argument_list|,
name|pim_hello_holdtime
argument_list|)
expr_stmt|;
comment|/* MLD6 query periodic */
name|IF_TIMEOUT
argument_list|(
argument|v->uv_gq_timer
argument_list|)
name|query_groups
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_IF
argument_list|)
block|{
name|dump_vifs
argument_list|(
name|log_fp
argument_list|)
expr_stmt|;
empty_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Scan the whole routing table and timeout a bunch of timers:  *  - oifs timers  *  - Join/Prune timer  *  - routing entry  *  - Assert timer  *  - Register-Suppression timer  *  *  - If the global timer for checking the unicast routing has expired, perform  *  also iif/upstream router change verification  *  - If the global timer for checking the data rate has expired, check the  *  number of bytes forwarded after the lastest timeout. If bigger than  *  a given threshold, then switch to the shortest path.  *  If `number_of_bytes == 0`, then delete the kernel cache entry.  *  * Only the entries which have the Join/Prune timer expired are sent.  * In the special case when we have ~(S,G)RPbit Prune entry, we must  * include any (*,G) or (*,*,RP) XXX: ???? what and why?  *  * Below is a table which summarizes the segmantic rules.  *  * On the left side is "if A must be included in the J/P message".  * On the top is "shall/must include B?"  * "Y" means "MUST include"  * "SY" means "SHOULD include"  * "N" means  "NO NEED to include"  * (G is a group that matches to RP)  *  *              -----------||-----------||-----------  *            ||  (*,*,RP) ||   (*,G)   ||   (S,G)   ||  *            ||-----------||-----------||-----------||  *            ||  J  |  P  ||  J  |  P  ||  J  |  P  ||  * ==================================================||  *          J || n/a | n/a ||  N  |  Y  ||  N  |  Y  ||  * (*,*,RP) -----------------------------------------||  *          P || n/a | n/a ||  SY |  N  ||  SY |  N  ||  * ==================================================||  *          J ||  N  |  N  || n/a | n/a ||  N  |  Y  ||  *   (*,G)  -----------------------------------------||  *          P ||  N  |  N  || n/a | n/a ||  SY |  N  ||  * ==================================================||  *          J ||  N  |  N  ||  N  |  N  || n/a | n/a ||  *   (S,G)  -----------------------------------------||  *          P ||  N  |  N  ||  N  |  N  || n/a | n/a ||  * ==================================================  *  */
end_comment

begin_function
name|void
name|age_routes
parameter_list|()
block|{
name|cand_rp_t
modifier|*
name|cand_rp_ptr
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr
decl_stmt|;
name|grpentry_t
modifier|*
name|grpentry_ptr_next
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_grp
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_rp
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_wide
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_srcs
decl_stmt|;
name|mrtentry_t
modifier|*
name|mrtentry_srcs_next
decl_stmt|;
name|struct
name|uvif
modifier|*
name|v
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|pim_nbr_entry_t
modifier|*
name|pim_nbr_ptr
decl_stmt|;
name|int
name|change_flag
decl_stmt|;
name|int
name|rp_action
decl_stmt|,
name|grp_action
decl_stmt|,
name|src_action
init|=
literal|0
decl_stmt|,
name|src_action_rp
init|=
literal|0
decl_stmt|;
name|int
name|dont_calc_action
decl_stmt|;
name|int
name|did_switch_flag
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_ptr
decl_stmt|;
name|kernel_cache_t
modifier|*
name|kernel_cache_ptr
decl_stmt|;
name|kernel_cache_t
modifier|*
name|kernel_cache_next
decl_stmt|;
name|u_long
name|curr_bytecnt
decl_stmt|;
name|rpentry_t
modifier|*
name|rpentry_ptr
decl_stmt|;
name|int
name|update_rp_iif
decl_stmt|;
name|int
name|update_src_iif
decl_stmt|;
name|if_set
name|new_pruned_oifs
decl_stmt|;
comment|/*      * Timing out of the global `unicast_routing_timer` and `data_rate_timer`      */
name|IF_TIMEOUT
argument_list|(
argument|unicast_routing_timer
argument_list|)
block|{
name|ucast_flag
operator|=
name|TRUE
expr_stmt|;
name|SET_TIMER
argument_list|(
name|unicast_routing_timer
argument_list|,
name|unicast_routing_check_interval
argument_list|)
expr_stmt|;
block|}
name|ELSE
block|{
name|ucast_flag
operator|=
name|FALSE
expr_stmt|;
block|}
name|IF_TIMEOUT
argument_list|(
argument|pim_data_rate_timer
argument_list|)
block|{
name|pim_data_rate_flag
operator|=
name|TRUE
expr_stmt|;
name|SET_TIMER
argument_list|(
name|pim_data_rate_timer
argument_list|,
name|pim_data_rate_check_interval
argument_list|)
expr_stmt|;
block|}
name|ELSE
block|{
name|pim_data_rate_flag
operator|=
name|FALSE
expr_stmt|;
block|}
name|IF_TIMEOUT
argument_list|(
argument|pim_reg_rate_timer
argument_list|)
block|{
name|pim_reg_rate_flag
operator|=
name|TRUE
expr_stmt|;
name|SET_TIMER
argument_list|(
name|pim_reg_rate_timer
argument_list|,
name|pim_reg_rate_check_interval
argument_list|)
expr_stmt|;
block|}
name|ELSE
block|{
name|pim_reg_rate_flag
operator|=
name|FALSE
expr_stmt|;
block|}
name|rate_flag
operator|=
name|pim_data_rate_flag
operator||
name|pim_reg_rate_flag
expr_stmt|;
comment|/* Scan the (*,*,RP) entries */
for|for
control|(
name|cand_rp_ptr
operator|=
name|cand_rp_list
init|;
name|cand_rp_ptr
operator|!=
operator|(
name|cand_rp_t
operator|*
operator|)
name|NULL
condition|;
name|cand_rp_ptr
operator|=
name|cand_rp_ptr
operator|->
name|next
control|)
block|{
name|rpentry_ptr
operator|=
name|cand_rp_ptr
operator|->
name|rpentry
expr_stmt|;
comment|/* 	 * Need to save only `incoming` and `upstream` to discover unicast 	 * route changes. `metric` and `preference` are not interesting for 	 * us. 	 */
name|rpentry_save
operator|.
name|incoming
operator|=
name|rpentry_ptr
operator|->
name|incoming
expr_stmt|;
name|rpentry_save
operator|.
name|upstream
operator|=
name|rpentry_ptr
operator|->
name|upstream
expr_stmt|;
name|update_rp_iif
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|ucast_flag
operator|==
name|TRUE
operator|)
operator|&&
operator|(
operator|!
name|inet6_equal
argument_list|(
operator|&
name|rpentry_ptr
operator|->
name|address
argument_list|,
operator|&
name|my_cand_rp_address
argument_list|)
operator|)
condition|)
block|{
comment|/* 	     * I am not the RP. If I was the RP, then the iif is register_vif 	     * and no need to reset it. 	     */
if|if
condition|(
name|set_incoming
argument_list|(
name|rpentry_ptr
argument_list|,
name|PIM_IIF_RP
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
comment|/* 		 * TODO: XXX: no route to that RP. Panic? There is a high 		 * probability the network is partitioning so immediately 		 * remapping to other RP is not a good idea. Better wait the 		 * Bootstrap mechanism to take care of it and provide me with 		 * correct Cand-RP-Set. 		 */
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rpentry_save
operator|.
name|upstream
operator|!=
name|rpentry_ptr
operator|->
name|upstream
operator|)
operator|||
operator|(
name|rpentry_save
operator|.
name|incoming
operator|!=
name|rpentry_ptr
operator|->
name|incoming
operator|)
condition|)
block|{
comment|/* 		     * Routing change has occur. Update all (*,G) and 		     * (S,G)RPbit iifs mapping to that RP 		     */
name|update_rp_iif
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|rp_action
operator|=
name|PIM_ACTION_NOTHING
expr_stmt|;
name|mrtentry_rp
operator|=
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|mrtlink
expr_stmt|;
if|if
condition|(
name|mrtentry_rp
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* outgoing interfaces timers */
name|change_flag
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
if|if
condition|(
name|IF_ISSET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_rp
operator|->
name|joined_oifs
argument_list|)
condition|)
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_rp->vif_timers[vifi]
argument_list|)
block|{
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_outif_timo
operator|++
expr_stmt|;
name|IF_CLR
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_rp
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|change_flag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|change_flag
operator|==
name|TRUE
operator|)
operator|||
operator|(
name|update_rp_iif
operator|==
name|TRUE
operator|)
condition|)
block|{
name|change_interfaces
argument_list|(
name|mrtentry_rp
argument_list|,
name|rpentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_rp
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_rp
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_rp
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_rp
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mrtentry_rp
operator|->
name|upstream
operator|=
name|rpentry_ptr
operator|->
name|upstream
expr_stmt|;
block|}
if|if
condition|(
name|rate_flag
operator|==
name|TRUE
condition|)
block|{
comment|/* Check the activity for this entry */
comment|/* 		 * XXX: the spec says to start monitoring first the total 		 * traffic for all senders for particular (*,*,RP) or (*,G) 		 * and if the total traffic exceeds some predefined 		 * threshold, then start monitoring the data traffic for each 		 * particular sender for this group: (*,G) or (*,*,RP). 		 * However, because the kernel cache/traffic info is of the 		 * form (S,G), it is easier if we are simply collecting (S,G) 		 * traffic all the time. 		 *  		 * For (*,*,RP) if the number of bytes received between the last 		 * check and now exceeds some precalculated value (based on 		 * interchecking period and datarate threshold AND if there 		 * are directly connected members (i.e. we are their last 		 * hop(e) router), then create (S,G) and start initiating 		 * (S,G) Join toward the source. The same applies for (*,G). 		 * The spec does not say that if the datarate goes below a 		 * given threshold, then will switch back to the shared tree, 		 * hence after a switch to the source-specific tree occurs, a 		 * source with low datarate, but periodically sending will 		 * keep the (S,G) states. 		 *  		 * If a source with kernel cache entry has been idle after the 		 * last time a check of the datarate for the whole routing 		 * table, then delete its kernel cache entry. 		 */
for|for
control|(
name|kernel_cache_ptr
operator|=
name|mrtentry_rp
operator|->
name|kernel_cache
init|;
name|kernel_cache_ptr
operator|!=
operator|(
name|kernel_cache_t
operator|*
operator|)
name|NULL
condition|;
name|kernel_cache_ptr
operator|=
name|kernel_cache_next
control|)
block|{
name|kernel_cache_next
operator|=
name|kernel_cache_ptr
operator|->
name|next
expr_stmt|;
name|curr_bytecnt
operator|=
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
expr_stmt|;
if|if
condition|(
name|k_get_sg_cnt
argument_list|(
name|udp_socket
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|source
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|group
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|sg_count
argument_list|)
operator|||
operator|(
name|curr_bytecnt
operator|==
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
operator|)
condition|)
block|{
comment|/* 			 * Either for some reason there is no such routing 			 * entry or that particular (s,g) was idle. Delete 			 * the routing entry from the kernel. 			 */
name|delete_single_kernel_cache
argument_list|(
name|mrtentry_rp
argument_list|,
name|kernel_cache_ptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		     * Check if the datarate was high enough to switch to 		     * source specific tree. 		     */
comment|/* Forwarder initiated switch */
name|did_switch_flag
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|curr_bytecnt
operator|+
name|pim_data_rate_bytes
operator|<
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
condition|)
block|{
if|if
condition|(
name|vif_forwarder
argument_list|(
operator|&
name|mrtentry_rp
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_rp
operator|->
name|oifs
argument_list|)
operator|==
name|TRUE
condition|)
block|{
ifdef|#
directive|ifdef
name|KERNEL_MFC_WC_G
comment|// TODO (one day... :))
if|if
condition|(
name|kernel_cache_ptr
operator|->
name|source
operator|==
name|IN6ADDR_ANY_N
condition|)
block|{
name|delete_single_kernel_cache
argument_list|(
name|mrtentry_rp
argument_list|,
name|kernel_cache_ptr
argument_list|)
expr_stmt|;
name|mrtentry_rp
operator|->
name|flags
operator||=
name|MRTF_MFC_CLONE_SG
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* KERNEL_MFC_WC_G */
name|pim6dstat
operator|.
name|pim6_trans_spt_forward
operator|++
expr_stmt|;
name|switch_shortest_path
argument_list|(
operator|&
name|kernel_cache_ptr
operator|->
name|source
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|group
argument_list|)
expr_stmt|;
name|did_switch_flag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* RP initiated switch */
if|if
condition|(
operator|(
name|did_switch_flag
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|curr_bytecnt
operator|+
name|pim_reg_rate_bytes
operator|<
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
operator|)
condition|)
block|{
if|if
condition|(
name|mrtentry_rp
operator|->
name|incoming
operator|==
name|reg_vif_num
condition|)
ifdef|#
directive|ifdef
name|KERNEL_MFC_WC_G
comment|// TODO (one day :))
if|if
condition|(
name|kernel_cache_ptr
operator|->
name|source
operator|==
name|IN6ADDR_ANY_N
condition|)
block|{
name|delete_single_kernel_cache
argument_list|(
name|mrtentry_rp
argument_list|,
name|kernel_cache_ptr
argument_list|)
expr_stmt|;
name|mrtentry_rp
operator|->
name|flags
operator||=
name|MRTF_MFC_CLONE_SG
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* KERNEL_MFC_WC_G */
name|pim6dstat
operator|.
name|pim6_trans_spt_rp
operator|++
expr_stmt|;
name|switch_shortest_path
argument_list|(
operator|&
name|kernel_cache_ptr
operator|->
name|source
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|group
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Join/Prune timer */
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_rp->jp_timer
argument_list|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Join/Prune timer expired"
argument_list|)
expr_stmt|;
name|rp_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_rp
argument_list|,
name|mrtentry_rp
operator|->
name|upstream
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"rp_action = %d"
argument_list|,
name|rp_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_action
operator|!=
name|PIM_ACTION_NOTHING
condition|)
name|add_jp_entry
argument_list|(
name|mrtentry_rp
operator|->
name|upstream
argument_list|,
name|pim_join_prune_holdtime
argument_list|,
operator|&
name|sockaddr6_d
argument_list|,
name|STAR_STAR_RP_MSK6LEN
argument_list|,
operator|&
name|mrtentry_rp
operator|->
name|source
operator|->
name|address
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
name|MRTF_RP
operator||
name|MRTF_WC
argument_list|,
name|rp_action
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|mrtentry_rp
operator|->
name|jp_timer
argument_list|,
name|pim_join_prune_period
argument_list|)
expr_stmt|;
block|}
comment|/* Assert timer */
if|if
condition|(
name|mrtentry_rp
operator|->
name|flags
operator|&
name|MRTF_ASSERTED
condition|)
block|{
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_rp->assert_timer
argument_list|)
block|{
comment|/* TODO: XXX: reset the upstream router now */
name|mrtentry_rp
operator|->
name|flags
operator|&=
operator|~
name|MRTF_ASSERTED
expr_stmt|;
block|}
block|}
comment|/* Register-Suppression timer */
comment|/* 	     * TODO: to reduce the kernel calls, if the timer is running, 	     * install a negative cache entry in the kernel? 	     */
comment|/* 	     * TODO: can we have Register-Suppression timer for (*,*,RP)? 	     * Currently no... 	     */
name|IF_TIMEOUT
argument_list|(
name|mrtentry_rp
operator|->
name|rs_timer
argument_list|)
expr_stmt|;
comment|/* routing entry */
if|if
condition|(
operator|(
name|TIMEOUT
argument_list|(
name|mrtentry_rp
operator|->
name|timer
argument_list|)
operator|)
operator|&&
operator|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_rp
operator|->
name|leaves
argument_list|)
operator|)
condition|)
block|{
name|pim6dstat
operator|.
name|pim6_rtentry_timo
operator|++
expr_stmt|;
name|delete_mrtentry
argument_list|(
name|mrtentry_rp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* mrtentry_rp != NULL */
comment|/* Just in case if that (*,*,RP) was deleted */
name|mrtentry_rp
operator|=
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|mrtlink
expr_stmt|;
comment|/* Check the (*,G) and (S,G) entries */
for|for
control|(
name|rp_grp_entry_ptr
operator|=
name|cand_rp_ptr
operator|->
name|rp_grp_next
init|;
name|rp_grp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|rp_grp_entry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|rp_grp_next
control|)
block|{
for|for
control|(
name|grpentry_ptr
operator|=
name|rp_grp_entry_ptr
operator|->
name|grplink
init|;
name|grpentry_ptr
operator|!=
operator|(
name|grpentry_t
operator|*
operator|)
name|NULL
condition|;
name|grpentry_ptr
operator|=
name|grpentry_ptr_next
control|)
block|{
name|grpentry_ptr_next
operator|=
name|grpentry_ptr
operator|->
name|rpnext
expr_stmt|;
name|mrtentry_grp
operator|=
name|grpentry_ptr
operator|->
name|grp_route
expr_stmt|;
name|mrtentry_srcs
operator|=
name|grpentry_ptr
operator|->
name|mrtlink
expr_stmt|;
name|grp_action
operator|=
name|PIM_ACTION_NOTHING
expr_stmt|;
if|if
condition|(
name|mrtentry_grp
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* The (*,G) entry */
comment|/* outgoing interfaces timers */
name|change_flag
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
if|if
condition|(
name|IF_ISSET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_grp
operator|->
name|joined_oifs
argument_list|)
condition|)
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_grp->vif_timers[vifi]
argument_list|)
block|{
name|IF_CLR
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_grp
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_outif_timo
operator|++
expr_stmt|;
name|change_flag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|change_flag
operator|==
name|TRUE
operator|)
operator|||
operator|(
name|update_rp_iif
operator|==
name|TRUE
operator|)
condition|)
block|{
name|change_interfaces
argument_list|(
name|mrtentry_grp
argument_list|,
name|rpentry_ptr
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_grp
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_grp
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_grp
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_grp
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mrtentry_grp
operator|->
name|upstream
operator|=
name|rpentry_ptr
operator|->
name|upstream
expr_stmt|;
block|}
comment|/* Check the sources activity */
if|if
condition|(
name|rate_flag
operator|==
name|TRUE
condition|)
block|{
for|for
control|(
name|kernel_cache_ptr
operator|=
name|mrtentry_grp
operator|->
name|kernel_cache
init|;
name|kernel_cache_ptr
operator|!=
operator|(
name|kernel_cache_t
operator|*
operator|)
name|NULL
condition|;
name|kernel_cache_ptr
operator|=
name|kernel_cache_next
control|)
block|{
name|kernel_cache_next
operator|=
name|kernel_cache_ptr
operator|->
name|next
expr_stmt|;
name|curr_bytecnt
operator|=
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
expr_stmt|;
if|if
condition|(
name|k_get_sg_cnt
argument_list|(
name|udp_socket
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|source
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|group
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|sg_count
argument_list|)
operator|||
operator|(
name|curr_bytecnt
operator|==
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
operator|)
condition|)
block|{
comment|/* 				 * Either for whatever reason there is no 				 * such routing entry or that particular 				 * (s,g) was idle. Delete the routing entry 				 * from the kernel. 				 */
name|delete_single_kernel_cache
argument_list|(
name|mrtentry_grp
argument_list|,
name|kernel_cache_ptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			     * Check if the datarate was high enough to 			     * switch to source specific tree. 			     */
comment|/* Forwarder initiated switch */
name|did_switch_flag
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|curr_bytecnt
operator|+
name|pim_data_rate_bytes
operator|<
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
condition|)
block|{
if|if
condition|(
name|vif_forwarder
argument_list|(
operator|&
name|mrtentry_grp
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_grp
operator|->
name|oifs
argument_list|)
operator|==
name|TRUE
condition|)
block|{
ifdef|#
directive|ifdef
name|KERNEL_MFC_WC_G
comment|// TODO
if|if
condition|(
name|kernel_cache_ptr
operator|->
name|source
operator|==
name|IN6ADDR_ANY_N
condition|)
block|{
name|delete_single_kernel_cache
argument_list|(
name|mrtentry_grp
argument_list|,
name|kernel_cache_ptr
argument_list|)
expr_stmt|;
name|mrtentry_grp
operator|->
name|flags
operator||=
name|MRTF_MFC_CLONE_SG
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* KERNEL_MFC_WC_G */
name|pim6dstat
operator|.
name|pim6_trans_spt_forward
operator|++
expr_stmt|;
name|switch_shortest_path
argument_list|(
operator|&
name|kernel_cache_ptr
operator|->
name|source
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|group
argument_list|)
expr_stmt|;
name|did_switch_flag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* RP initiated switch */
if|if
condition|(
operator|(
name|did_switch_flag
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|curr_bytecnt
operator|+
name|pim_reg_rate_bytes
operator|<
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
operator|)
condition|)
block|{
if|if
condition|(
name|mrtentry_grp
operator|->
name|incoming
operator|==
name|reg_vif_num
condition|)
ifdef|#
directive|ifdef
name|KERNEL_MFC_WC_G
comment|// TODO
if|if
condition|(
name|kernel_cache_ptr
operator|->
name|source
operator|==
name|IN6ADDR_ANY_N
condition|)
block|{
name|delete_single_kernel_cache
argument_list|(
name|mrtentry_grp
argument_list|,
name|kernel_cache_ptr
argument_list|)
expr_stmt|;
name|mrtentry_grp
operator|->
name|flags
operator||=
name|MRTF_MFC_CLONE_SG
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* KERNEL_MFC_WC_G */
name|pim6dstat
operator|.
name|pim6_trans_spt_rp
operator|++
expr_stmt|;
name|switch_shortest_path
argument_list|(
operator|&
name|kernel_cache_ptr
operator|->
name|source
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|group
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|dont_calc_action
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|rp_action
operator|!=
name|PIM_ACTION_NOTHING
condition|)
block|{
name|grp_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_grp
argument_list|,
name|mrtentry_grp
operator|->
name|upstream
argument_list|)
expr_stmt|;
name|dont_calc_action
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rp_action
operator|==
name|PIM_ACTION_JOIN
operator|)
operator|&&
operator|(
name|grp_action
operator|==
name|PIM_ACTION_PRUNE
operator|)
operator|)
operator|||
operator|(
operator|(
name|rp_action
operator|==
name|PIM_ACTION_PRUNE
operator|)
operator|&&
operator|(
name|grp_action
operator|==
name|PIM_ACTION_JOIN
operator|)
operator|)
condition|)
name|FIRE_TIMER
argument_list|(
name|mrtentry_grp
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
block|}
comment|/* Join/Prune timer */
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_grp->jp_timer
argument_list|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"Join/Prune timer expired"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dont_calc_action
operator|!=
name|TRUE
condition|)
name|grp_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_grp
argument_list|,
name|mrtentry_grp
operator|->
name|upstream
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"grp_action = %d"
argument_list|,
name|grp_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp_action
operator|!=
name|PIM_ACTION_NOTHING
condition|)
block|{
name|add_jp_entry
argument_list|(
name|mrtentry_grp
operator|->
name|upstream
argument_list|,
name|pim_join_prune_holdtime
argument_list|,
operator|&
name|mrtentry_grp
operator|->
name|group
operator|->
name|group
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
operator|&
name|cand_rp_ptr
operator|->
name|rpentry
operator|->
name|address
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
name|MRTF_RP
operator||
name|MRTF_WC
argument_list|,
name|grp_action
argument_list|)
expr_stmt|;
block|}
name|SET_TIMER
argument_list|(
name|mrtentry_grp
operator|->
name|jp_timer
argument_list|,
name|pim_join_prune_period
argument_list|)
expr_stmt|;
block|}
comment|/* Assert timer */
if|if
condition|(
name|mrtentry_grp
operator|->
name|flags
operator|&
name|MRTF_ASSERTED
condition|)
block|{
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_grp->assert_timer
argument_list|)
block|{
comment|/* TODO: XXX: reset the upstream router now */
name|mrtentry_grp
operator|->
name|flags
operator|&=
operator|~
name|MRTF_ASSERTED
expr_stmt|;
block|}
block|}
comment|/* Register-Suppression timer */
comment|/* 		     * TODO: to reduce the kernel calls, if the timer is 		     * running, install a negative cache entry in the kernel? 		     */
comment|/* 		     * TODO: currently cannot have Register-Suppression timer 		     * for (*,G) entry, but keep this around. 		     */
name|IF_TIMEOUT
argument_list|(
name|mrtentry_grp
operator|->
name|rs_timer
argument_list|)
expr_stmt|;
comment|/* routing entry */
if|if
condition|(
operator|(
name|TIMEOUT
argument_list|(
name|mrtentry_grp
operator|->
name|timer
argument_list|)
operator|)
operator|&&
operator|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_grp
operator|->
name|leaves
argument_list|)
operator|)
condition|)
block|{
name|pim6dstat
operator|.
name|pim6_rtentry_timo
operator|++
expr_stmt|;
name|delete_mrtentry
argument_list|(
name|mrtentry_grp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if (mrtentry_grp != NULL) */
comment|/* For all (S,G) for this group */
comment|/* XXX: mrtentry_srcs was set before */
for|for
control|(
init|;
name|mrtentry_srcs
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|;
name|mrtentry_srcs
operator|=
name|mrtentry_srcs_next
control|)
block|{
comment|/* routing entry */
name|mrtentry_srcs_next
operator|=
name|mrtentry_srcs
operator|->
name|grpnext
expr_stmt|;
comment|/* outgoing interfaces timers */
name|change_flag
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
if|if
condition|(
name|IF_ISSET
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|)
condition|)
block|{
comment|/* TODO: checking for reg_num_vif is slow! */
if|if
condition|(
name|vifi
operator|!=
name|reg_vif_num
condition|)
block|{
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_srcs->vif_timers[vifi]
argument_list|)
block|{
name|IF_CLR
argument_list|(
name|vifi
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|)
expr_stmt|;
name|change_flag
operator|=
name|TRUE
expr_stmt|;
name|uvifs
index|[
name|vifi
index|]
operator|.
name|uv_outif_timo
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
name|update_src_iif
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ucast_flag
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|mrtentry_srcs
operator|->
name|flags
operator|&
name|MRTF_RP
operator|)
condition|)
block|{
comment|/* iif toward the source */
name|srcentry_save
operator|.
name|incoming
operator|=
name|mrtentry_srcs
operator|->
name|source
operator|->
name|incoming
expr_stmt|;
name|srcentry_save
operator|.
name|upstream
operator|=
name|mrtentry_srcs
operator|->
name|source
operator|->
name|upstream
expr_stmt|;
if|if
condition|(
name|set_incoming
argument_list|(
name|mrtentry_srcs
operator|->
name|source
argument_list|,
name|PIM_IIF_SOURCE
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
comment|/* 				 * XXX: not in the spec! Cannot find route 				 * toward that source. This is bad. Delete 				 * the entry. 				 */
name|delete_mrtentry
argument_list|(
name|mrtentry_srcs
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* iif info found */
if|if
condition|(
operator|(
name|srcentry_save
operator|.
name|incoming
operator|!=
name|mrtentry_srcs
operator|->
name|incoming
operator|)
operator|||
operator|(
name|srcentry_save
operator|.
name|upstream
operator|!=
name|mrtentry_srcs
operator|->
name|upstream
operator|)
condition|)
block|{
comment|/* Route change has occur */
name|update_src_iif
operator|=
name|TRUE
expr_stmt|;
name|mrtentry_srcs
operator|->
name|incoming
operator|=
name|mrtentry_srcs
operator|->
name|source
operator|->
name|incoming
expr_stmt|;
name|mrtentry_srcs
operator|->
name|upstream
operator|=
name|mrtentry_srcs
operator|->
name|source
operator|->
name|upstream
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* (S,G)RPBit with iif toward RP */
if|if
condition|(
operator|(
name|rpentry_save
operator|.
name|upstream
operator|!=
name|mrtentry_srcs
operator|->
name|upstream
operator|)
operator|||
operator|(
name|rpentry_save
operator|.
name|incoming
operator|!=
name|mrtentry_srcs
operator|->
name|incoming
operator|)
condition|)
block|{
name|update_src_iif
operator|=
name|TRUE
expr_stmt|;
comment|/* XXX: a hack */
comment|/* XXX: setup the iif now! */
name|mrtentry_srcs
operator|->
name|incoming
operator|=
name|rpentry_ptr
operator|->
name|incoming
expr_stmt|;
name|mrtentry_srcs
operator|->
name|upstream
operator|=
name|rpentry_ptr
operator|->
name|upstream
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|change_flag
operator|==
name|TRUE
operator|)
operator|||
operator|(
name|update_src_iif
operator|==
name|TRUE
operator|)
condition|)
comment|/* Flush the changes */
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|mrtentry_srcs
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate_flag
operator|==
name|TRUE
condition|)
block|{
for|for
control|(
name|kernel_cache_ptr
operator|=
name|mrtentry_srcs
operator|->
name|kernel_cache
init|;
name|kernel_cache_ptr
operator|!=
operator|(
name|kernel_cache_t
operator|*
operator|)
name|NULL
condition|;
name|kernel_cache_ptr
operator|=
name|kernel_cache_next
control|)
block|{
name|kernel_cache_next
operator|=
name|kernel_cache_ptr
operator|->
name|next
expr_stmt|;
name|curr_bytecnt
operator|=
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
expr_stmt|;
if|if
condition|(
name|k_get_sg_cnt
argument_list|(
name|udp_socket
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|source
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|group
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|sg_count
argument_list|)
operator|||
operator|(
name|curr_bytecnt
operator|==
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
operator|)
condition|)
block|{
comment|/* 				 * Either for some reason there is no such 				 * routing entry or that particular (s,g) was 				 * idle. Delete the routing entry from the 				 * kernel. 				 */
name|delete_single_kernel_cache
argument_list|(
name|mrtentry_srcs
argument_list|,
name|kernel_cache_ptr
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			     * Check if the datarate was high enough to 			     * switch to source specific tree. Need to check 			     * only when we have (S,G)RPbit in the forwarder 			     * or the RP itself. 			     */
if|if
condition|(
operator|!
operator|(
name|mrtentry_srcs
operator|->
name|flags
operator|&
name|MRTF_RP
operator|)
condition|)
continue|continue;
comment|/* Forwarder initiated switch */
name|did_switch_flag
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|curr_bytecnt
operator|+
name|pim_data_rate_bytes
operator|<
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
condition|)
block|{
if|if
condition|(
name|vif_forwarder
argument_list|(
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|oifs
argument_list|)
operator|==
name|TRUE
condition|)
block|{
name|switch_shortest_path
argument_list|(
operator|&
name|kernel_cache_ptr
operator|->
name|source
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|group
argument_list|)
expr_stmt|;
name|did_switch_flag
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* RP initiated switch */
if|if
condition|(
operator|(
name|did_switch_flag
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|curr_bytecnt
operator|+
name|pim_reg_rate_bytes
operator|<
name|kernel_cache_ptr
operator|->
name|sg_count
operator|.
name|bytecnt
operator|)
condition|)
block|{
if|if
condition|(
name|mrtentry_srcs
operator|->
name|incoming
operator|==
name|reg_vif_num
condition|)
name|switch_shortest_path
argument_list|(
operator|&
name|kernel_cache_ptr
operator|->
name|source
argument_list|,
operator|&
name|kernel_cache_ptr
operator|->
name|group
argument_list|)
expr_stmt|;
block|}
comment|/* 			     * XXX: currentry the spec doesn't say to switch 			     * back to the shared tree if low datarate, but 			     * if needed to implement, the check must be done 			     * here. Don't forget to check whether I am a 			     * forwarder for that source. 			     */
block|}
block|}
name|mrtentry_wide
operator|=
name|mrtentry_srcs
operator|->
name|group
operator|->
name|grp_route
expr_stmt|;
if|if
condition|(
name|mrtentry_wide
operator|==
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
name|mrtentry_wide
operator|=
name|mrtentry_rp
expr_stmt|;
name|dont_calc_action
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|rp_action
operator|!=
name|PIM_ACTION_NOTHING
operator|)
operator|||
operator|(
name|grp_action
operator|!=
name|PIM_ACTION_NOTHING
operator|)
condition|)
block|{
name|src_action_rp
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_srcs
argument_list|,
name|rpentry_ptr
operator|->
name|upstream
argument_list|)
expr_stmt|;
name|src_action
operator|=
name|src_action_rp
expr_stmt|;
name|dont_calc_action
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|src_action_rp
operator|==
name|PIM_ACTION_JOIN
condition|)
block|{
if|if
condition|(
operator|(
name|grp_action
operator|==
name|PIM_ACTION_PRUNE
operator|)
operator|||
operator|(
name|rp_action
operator|==
name|PIM_ACTION_PRUNE
operator|)
condition|)
name|FIRE_TIMER
argument_list|(
name|mrtentry_srcs
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src_action_rp
operator|==
name|PIM_ACTION_PRUNE
condition|)
block|{
if|if
condition|(
operator|(
name|grp_action
operator|==
name|PIM_ACTION_JOIN
operator|)
operator|||
operator|(
name|rp_action
operator|==
name|PIM_ACTION_JOIN
operator|)
condition|)
name|FIRE_TIMER
argument_list|(
name|mrtentry_srcs
operator|->
name|jp_timer
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Join/Prune timer */
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_srcs->jp_timer
argument_list|)
block|{
if|if
condition|(
operator|(
name|dont_calc_action
operator|!=
name|TRUE
operator|)
operator|||
operator|(
name|rpentry_ptr
operator|->
name|upstream
operator|!=
name|mrtentry_srcs
operator|->
name|upstream
operator|)
condition|)
name|src_action
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_srcs
argument_list|,
name|mrtentry_srcs
operator|->
name|upstream
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"src_action = %d"
argument_list|,
name|src_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_action
operator|!=
name|PIM_ACTION_NOTHING
condition|)
name|add_jp_entry
argument_list|(
name|mrtentry_srcs
operator|->
name|upstream
argument_list|,
name|pim_join_prune_holdtime
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|group
operator|->
name|group
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|source
operator|->
name|address
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
name|mrtentry_srcs
operator|->
name|flags
operator|&
name|MRTF_RP
argument_list|,
name|src_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtentry_wide
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* 			     * Have both (S,G) and (*,G) (or (*,*,RP)). Check 			     * if need to send (S,G) PRUNE toward RP 			     */
if|if
condition|(
name|mrtentry_srcs
operator|->
name|upstream
operator|!=
name|mrtentry_wide
operator|->
name|upstream
condition|)
block|{
if|if
condition|(
name|dont_calc_action
operator|!=
name|TRUE
condition|)
name|src_action_rp
operator|=
name|join_or_prune
argument_list|(
name|mrtentry_srcs
argument_list|,
name|mrtentry_wide
operator|->
name|upstream
argument_list|)
expr_stmt|;
comment|/* 				 * XXX: TODO: do error check if src_action == 				 * PIM_ACTION_JOIN, which should be an error. 				 */
if|if
condition|(
name|src_action_rp
operator|==
name|PIM_ACTION_PRUNE
condition|)
block|{
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_JOIN_PRUNE
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"src_action = %d"
argument_list|,
name|src_action
argument_list|)
expr_stmt|;
name|add_jp_entry
argument_list|(
name|mrtentry_wide
operator|->
name|upstream
argument_list|,
name|pim_join_prune_holdtime
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|group
operator|->
name|group
argument_list|,
name|SINGLE_GRP_MSK6LEN
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|source
operator|->
name|address
argument_list|,
name|SINGLE_SRC_MSK6LEN
argument_list|,
name|MRTF_RP
argument_list|,
name|src_action_rp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SET_TIMER
argument_list|(
name|mrtentry_srcs
operator|->
name|jp_timer
argument_list|,
name|pim_join_prune_period
argument_list|)
expr_stmt|;
block|}
comment|/* Assert timer */
if|if
condition|(
name|mrtentry_srcs
operator|->
name|flags
operator|&
name|MRTF_ASSERTED
condition|)
block|{
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_srcs->assert_timer
argument_list|)
block|{
comment|/* TODO: XXX: reset the upstream router now */
name|mrtentry_srcs
operator|->
name|flags
operator|&=
operator|~
name|MRTF_ASSERTED
expr_stmt|;
block|}
block|}
comment|/* Register-Suppression timer */
comment|/* 		     * TODO: to reduce the kernel calls, if the timer is 		     * running, install a negative cache entry in the kernel? 		     */
name|IF_TIMER_SET
argument_list|(
argument|mrtentry_srcs->rs_timer
argument_list|)
block|{
name|IF_TIMEOUT
argument_list|(
argument|mrtentry_srcs->rs_timer
argument_list|)
block|{
comment|/* Start encapsulating the packets */
name|IF_COPY
argument_list|(
operator|&
name|mrtentry_srcs
operator|->
name|pruned_oifs
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|)
expr_stmt|;
name|IF_CLR
argument_list|(
name|reg_vif_num
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|)
expr_stmt|;
name|change_interfaces
argument_list|(
name|mrtentry_srcs
argument_list|,
name|mrtentry_srcs
operator|->
name|incoming
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|joined_oifs
argument_list|,
operator|&
name|new_pruned_oifs
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|asserted_oifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ELSE
block|{
comment|/* 			     * The register suppression timer is running. 			     * Check whether it is time to send 			     * PIM_NULL_REGISTER. 			     */
comment|/* TODO: XXX: TIMER implem. dependency! */
if|if
condition|(
name|mrtentry_srcs
operator|->
name|rs_timer
operator|<=
name|pim_register_probe_time
condition|)
block|{
comment|/* Time to send a PIM_NULL_REGISTER */
comment|/* 				 * XXX: a (bad) hack! This will be sending 				 * periodically NULL_REGISTERS between 				 * pim_register_probe_time and 0. Well, 				 * because PROBE_TIME is 5 secs , it will 				 * happen only once ( if granularity is 5 and prob 5!) 				 * , so it helps to avoid 				 * adding a flag to the routing entry whether 				 * a NULL_REGISTER was sent. 				 */
name|send_pim6_null_register
argument_list|(
name|mrtentry_srcs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* routing entry */
if|if
condition|(
name|TIMEOUT
argument_list|(
name|mrtentry_srcs
operator|->
name|timer
argument_list|)
condition|)
block|{
name|pim6dstat
operator|.
name|pim6_rtentry_timo
operator|++
expr_stmt|;
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|)
condition|)
block|{
name|delete_mrtentry
argument_list|(
name|mrtentry_srcs
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * XXX: if DR, Register suppressed, and leaf oif 			 * inherited from (*,G), the directly connected 			 * source is not active anymore, this (S,G) entry 			 * won't timeout. Check if the leaf oifs are 			 * inherited from (*,G); if true. delete the (S,G) 			 * entry. 			 */
if|if
condition|(
name|mrtentry_srcs
operator|->
name|group
operator|->
name|grp_route
operator|!=
operator|(
name|mrtentry_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|if_set
name|r_and
decl_stmt|,
name|r_xor
decl_stmt|;
name|vif_and
argument_list|(
operator|&
name|mrtentry_srcs
operator|->
name|group
operator|->
name|grp_route
operator|->
name|leaves
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|r_and
argument_list|)
expr_stmt|;
name|vif_xor
argument_list|(
operator|&
name|r_and
argument_list|,
operator|&
name|mrtentry_srcs
operator|->
name|leaves
argument_list|,
operator|&
name|r_xor
argument_list|)
expr_stmt|;
if|if
condition|(
name|IF_ISEMPTY
argument_list|(
operator|&
name|r_xor
argument_list|)
condition|)
block|{
name|delete_mrtentry
argument_list|(
name|mrtentry_srcs
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
comment|/* End of (S,G) loop */
block|}
comment|/* End of (*,G) loop */
block|}
block|}
comment|/* For all cand RPs */
comment|/* TODO: check again! */
for|for
control|(
name|vifi
operator|=
literal|0
operator|,
name|v
operator|=
operator|&
name|uvifs
index|[
literal|0
index|]
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|v
operator|++
control|)
block|{
comment|/* Send all pending Join/Prune messages */
for|for
control|(
name|pim_nbr_ptr
operator|=
name|v
operator|->
name|uv_pim_neighbors
init|;
name|pim_nbr_ptr
operator|!=
operator|(
name|pim_nbr_entry_t
operator|*
operator|)
name|NULL
condition|;
name|pim_nbr_ptr
operator|=
name|pim_nbr_ptr
operator|->
name|next
control|)
block|{
name|pack_and_send_jp6_message
argument_list|(
name|pim_nbr_ptr
argument_list|)
expr_stmt|;
block|}
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_MRT
argument_list|)
name|dump_pim_mrt
argument_list|(
name|log_fp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * TODO: timeout the RP-group mapping entries during the scan of the whole  * routing table?  */
end_comment

begin_function
name|void
name|age_misc
parameter_list|()
block|{
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_ptr
decl_stmt|;
name|rp_grp_entry_t
modifier|*
name|rp_grp_entry_next
decl_stmt|;
name|grp_mask_t
modifier|*
name|grp_mask_ptr
decl_stmt|;
name|grp_mask_t
modifier|*
name|grp_mask_next
decl_stmt|;
comment|/* Timeout the Cand-RP-set entries */
for|for
control|(
name|grp_mask_ptr
operator|=
name|grp_mask_list
init|;
name|grp_mask_ptr
operator|!=
operator|(
name|grp_mask_t
operator|*
operator|)
name|NULL
condition|;
name|grp_mask_ptr
operator|=
name|grp_mask_next
control|)
block|{
comment|/* 	 * If we timeout an entry, the grp_mask_ptr entry might be removed. 	 */
name|grp_mask_next
operator|=
name|grp_mask_ptr
operator|->
name|next
expr_stmt|;
for|for
control|(
name|rp_grp_entry_ptr
operator|=
name|grp_mask_ptr
operator|->
name|grp_rp_next
init|;
name|rp_grp_entry_ptr
operator|!=
operator|(
name|rp_grp_entry_t
operator|*
operator|)
name|NULL
condition|;
name|rp_grp_entry_ptr
operator|=
name|rp_grp_entry_next
control|)
block|{
name|rp_grp_entry_next
operator|=
name|rp_grp_entry_ptr
operator|->
name|grp_rp_next
expr_stmt|;
name|IF_TIMEOUT
argument_list|(
argument|rp_grp_entry_ptr->holdtime
argument_list|)
block|{
name|delete_rp_grp_entry
argument_list|(
operator|&
name|cand_rp_list
argument_list|,
operator|&
name|grp_mask_list
argument_list|,
name|rp_grp_entry_ptr
argument_list|)
expr_stmt|;
name|pim6dstat
operator|.
name|pim6_rpgrp_timo
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Cand-RP-Adv timer */
if|if
condition|(
name|cand_rp_flag
operator|==
name|TRUE
condition|)
block|{
name|IF_TIMEOUT
argument_list|(
argument|pim_cand_rp_adv_timer
argument_list|)
block|{
name|send_pim6_cand_rp_adv
argument_list|()
expr_stmt|;
name|SET_TIMER
argument_list|(
name|pim_cand_rp_adv_timer
argument_list|,
name|my_cand_rp_adv_period
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* bootstrap-timer */
name|IF_TIMEOUT
argument_list|(
argument|pim_bootstrap_timer
argument_list|)
block|{
name|pim6dstat
operator|.
name|pim6_bootstrap_timo
operator|++
expr_stmt|;
if|if
condition|(
name|cand_bsr_flag
operator|==
name|FALSE
condition|)
block|{
comment|/* 	     * If I am not Cand-BSR, start accepting Bootstrap messages from 	     * anyone. XXX: Even if the BSR has timeout, the existing 	     * Cand-RP-Set is kept. 	     */
name|curr_bsr_fragment_tag
operator|=
literal|0
expr_stmt|;
name|curr_bsr_priority
operator|=
literal|0
expr_stmt|;
comment|/* Lowest priority */
name|memset
argument_list|(
operator|&
name|curr_bsr_address
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|curr_bsr_address
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|curr_bsr_address
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|MASKLEN_TO_MASK6
argument_list|(
name|RP_DEFAULT_IPV6_HASHMASKLEN
argument_list|,
name|curr_bsr_hash_mask
argument_list|)
expr_stmt|;
name|SET_TIMER
argument_list|(
name|pim_bootstrap_timer
argument_list|,
name|PIM_BOOTSTRAP_TIMEOUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* I am Cand-BSR, so set the current BSR to me */
if|if
condition|(
name|inet6_equal
argument_list|(
operator|&
name|curr_bsr_address
argument_list|,
operator|&
name|my_bsr_address
argument_list|)
condition|)
block|{
name|SET_TIMER
argument_list|(
name|pim_bootstrap_timer
argument_list|,
name|my_bsr_period
argument_list|)
expr_stmt|;
name|send_pim6_bootstrap
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Short delay before becoming the BSR and start sending of 		 * the Cand-RP set (to reduce the transient control 		 * overhead). 		 */
name|SET_TIMER
argument_list|(
name|pim_bootstrap_timer
argument_list|,
name|bootstrap_initial_delay
argument_list|()
argument_list|)
expr_stmt|;
name|curr_bsr_fragment_tag
operator|=
name|RANDOM
argument_list|()
expr_stmt|;
name|curr_bsr_priority
operator|=
name|my_bsr_priority
expr_stmt|;
name|curr_bsr_address
operator|=
name|my_bsr_address
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|curr_bsr_hash_mask
argument_list|,
operator|&
name|my_bsr_hash_mask
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_BOOTSTRAP | DEBUG_PIM_CAND_RP
argument_list|)
name|dump_rp_set
argument_list|(
name|log_fp
argument_list|)
expr_stmt|;
comment|/* TODO: XXX: anything else to timeout */
block|}
end_function

end_unit

