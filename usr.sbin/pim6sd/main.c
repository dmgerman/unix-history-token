begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1998 by the University of Southern California.  *  All rights reserved.  *  *  Permission to use, copy, modify, and distribute this software and  *  its documentation in source and binary forms for lawful  *  purposes and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both  *  the copyright notice and this permission notice appear in supporting  *  documentation, and that any documentation, advertising materials,  *  and other materials related to such distribution and use acknowledge  *  that the software was developed by the University of Southern  *  California and/or Information Sciences Institute.  *  The name of the University of Southern California may not  *  be used to endorse or promote products derived from this software  *  without specific prior written permission.  *  *  THE UNIVERSITY OF SOUTHERN CALIFORNIA DOES NOT MAKE ANY REPRESENTATIONS  *  ABOUT THE SUITABILITY OF THIS SOFTWARE FOR ANY PURPOSE.  THIS SOFTWARE IS  *  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,  *  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND  *  NON-INFRINGEMENT.  *  *  IN NO EVENT SHALL USC, OR ANY OTHER CONTRIBUTOR BE LIABLE FOR ANY  *  SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES, WHETHER IN CONTRACT,  *  TORT, OR OTHER FORM OF ACTION, ARISING OUT OF OR IN CONNECTION WITH,  *  THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  *  Other copyrights might apply to parts of this software and are so  *  noted when applicable.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *  Questions concerning this software should be directed to  *  Mickael Hoerdt (hoerdt@clarinet.u-strasbg.fr) LSIIT Strasbourg.  *  */
end_comment

begin_comment
comment|/*  * This program has been derived from pim6dd.  * The pim6dd program is covered by the license in the accompanying file  * named "LICENSE.pim6dd".  */
end_comment

begin_comment
comment|/*  * This program has been derived from pimd.  * The pimd program is covered by the license in the accompanying file  * named "LICENSE.pimd".  *  */
end_comment

begin_comment
comment|/*  * Part of this program has been derived from mrouted.  * The mrouted program is covered by the license in the accompanying file  * named "LICENSE.mrouted".  *  * The mrouted program is COPYRIGHT 1989 by The Board of Trustees of  * Leland Stanford Junior University.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"mld6.h"
end_include

begin_include
include|#
directive|include
file|"pim6.h"
end_include

begin_include
include|#
directive|include
file|"vif.h"
end_include

begin_include
include|#
directive|include
file|"routesock.h"
end_include

begin_include
include|#
directive|include
file|"callout.h"
end_include

begin_include
include|#
directive|include
file|"mrt.h"
end_include

begin_include
include|#
directive|include
file|"timer.h"
end_include

begin_include
include|#
directive|include
file|"rp.h"
end_include

begin_include
include|#
directive|include
file|"kern.h"
end_include

begin_include
include|#
directive|include
file|"cfparse.h"
end_include

begin_decl_stmt
name|char
name|configfilename
index|[
literal|256
index|]
init|=
name|_PATH_PIM6D_CONF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|versionstring
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|logfilename
index|[
literal|256
index|]
init|=
name|_PATH_PIM6D_LOGFILE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TODO: not used static char 		genidfilename[] = _PATH_PIM6D_GENID; */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pidfilename
index|[]
init|=
name|_PATH_PIM6D_PID
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|log_fp
init|=
name|stderr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|foreground
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sighandled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GOT_SIGINT
value|0x01
end_define

begin_define
define|#
directive|define
name|GOT_SIGHUP
value|0x02
end_define

begin_define
define|#
directive|define
name|GOT_SIGUSR1
value|0x04
end_define

begin_define
define|#
directive|define
name|GOT_SIGUSR2
value|0x08
end_define

begin_define
define|#
directive|define
name|GOT_SIGALRM
value|0x10
end_define

begin_define
define|#
directive|define
name|GOT_SIGINFO
value|0x20
end_define

begin_define
define|#
directive|define
name|NHANDLERS
value|3
end_define

begin_struct
specifier|static
struct|struct
name|ihandler
block|{
name|int
name|fd
decl_stmt|;
comment|/* File descriptor               */
name|ihfunc_t
name|func
decl_stmt|;
comment|/* Function to call with&fd_set */
block|}
name|ihandlers
index|[
name|NHANDLERS
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|nhandlers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|debugname
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|nchars
decl_stmt|;
block|}
name|debugnames
index|[]
init|=
block|{
block|{
literal|"mld_proto"
block|,
name|DEBUG_MLD_PROTO
block|,
literal|5
block|}
block|,
block|{
literal|"mld_timer"
block|,
name|DEBUG_MLD_TIMER
block|,
literal|5
block|}
block|,
block|{
literal|"mld_member"
block|,
name|DEBUG_MLD_MEMBER
block|,
literal|5
block|}
block|,
block|{
literal|"mld"
block|,
name|DEBUG_MLD
block|,
literal|3
block|}
block|,
block|{
literal|"switch"
block|,
name|DEBUG_SWITCH
block|,
literal|2
block|}
block|,
block|{
literal|"trace"
block|,
name|DEBUG_TRACE
block|,
literal|2
block|}
block|,
block|{
literal|"mtrace"
block|,
name|DEBUG_TRACE
block|,
literal|2
block|}
block|,
block|{
literal|"traceroute"
block|,
name|DEBUG_TRACE
block|,
literal|2
block|}
block|,
block|{
literal|"timeout"
block|,
name|DEBUG_TIMEOUT
block|,
literal|2
block|}
block|,
block|{
literal|"callout"
block|,
name|DEBUG_TIMEOUT
block|,
literal|3
block|}
block|,
block|{
literal|"pkt"
block|,
name|DEBUG_PKT
block|,
literal|2
block|}
block|,
block|{
literal|"packets"
block|,
name|DEBUG_PKT
block|,
literal|2
block|}
block|,
block|{
literal|"interfaces"
block|,
name|DEBUG_IF
block|,
literal|2
block|}
block|,
block|{
literal|"vif"
block|,
name|DEBUG_IF
block|,
literal|1
block|}
block|,
block|{
literal|"kernel"
block|,
name|DEBUG_KERN
block|,
literal|2
block|}
block|,
block|{
literal|"cache"
block|,
name|DEBUG_MFC
block|,
literal|1
block|}
block|,
block|{
literal|"mfc"
block|,
name|DEBUG_MFC
block|,
literal|2
block|}
block|,
block|{
literal|"k_cache"
block|,
name|DEBUG_MFC
block|,
literal|2
block|}
block|,
block|{
literal|"k_mfc"
block|,
name|DEBUG_MFC
block|,
literal|2
block|}
block|,
block|{
literal|"rsrr"
block|,
name|DEBUG_RSRR
block|,
literal|2
block|}
block|,
block|{
literal|"pim_detail"
block|,
name|DEBUG_PIM_DETAIL
block|,
literal|5
block|}
block|,
block|{
literal|"pim_hello"
block|,
name|DEBUG_PIM_HELLO
block|,
literal|5
block|}
block|,
block|{
literal|"pim_neighbors"
block|,
name|DEBUG_PIM_HELLO
block|,
literal|5
block|}
block|,
block|{
literal|"pim_register"
block|,
name|DEBUG_PIM_REGISTER
block|,
literal|5
block|}
block|,
block|{
literal|"registers"
block|,
name|DEBUG_PIM_REGISTER
block|,
literal|2
block|}
block|,
block|{
literal|"pim_join_prune"
block|,
name|DEBUG_PIM_JOIN_PRUNE
block|,
literal|5
block|}
block|,
block|{
literal|"pim_j_p"
block|,
name|DEBUG_PIM_JOIN_PRUNE
block|,
literal|5
block|}
block|,
block|{
literal|"pim_jp"
block|,
name|DEBUG_PIM_JOIN_PRUNE
block|,
literal|5
block|}
block|,
block|{
literal|"pim_bootstrap"
block|,
name|DEBUG_PIM_BOOTSTRAP
block|,
literal|5
block|}
block|,
block|{
literal|"pim_bsr"
block|,
name|DEBUG_PIM_BOOTSTRAP
block|,
literal|5
block|}
block|,
block|{
literal|"bsr"
block|,
name|DEBUG_PIM_BOOTSTRAP
block|,
literal|1
block|}
block|,
block|{
literal|"bootstrap"
block|,
name|DEBUG_PIM_BOOTSTRAP
block|,
literal|1
block|}
block|,
block|{
literal|"pim_asserts"
block|,
name|DEBUG_PIM_ASSERT
block|,
literal|5
block|}
block|,
block|{
literal|"pim_cand_rp"
block|,
name|DEBUG_PIM_CAND_RP
block|,
literal|5
block|}
block|,
block|{
literal|"pim_c_rp"
block|,
name|DEBUG_PIM_CAND_RP
block|,
literal|5
block|}
block|,
block|{
literal|"pim_rp"
block|,
name|DEBUG_PIM_CAND_RP
block|,
literal|6
block|}
block|,
block|{
literal|"rp"
block|,
name|DEBUG_PIM_CAND_RP
block|,
literal|2
block|}
block|,
block|{
literal|"pim_routes"
block|,
name|DEBUG_PIM_MRT
block|,
literal|6
block|}
block|,
block|{
literal|"pim_routing"
block|,
name|DEBUG_PIM_MRT
block|,
literal|6
block|}
block|,
block|{
literal|"pim_mrt"
block|,
name|DEBUG_PIM_MRT
block|,
literal|5
block|}
block|,
block|{
literal|"pim_timers"
block|,
name|DEBUG_PIM_TIMER
block|,
literal|5
block|}
block|,
block|{
literal|"pim_rpf"
block|,
name|DEBUG_PIM_RPF
block|,
literal|6
block|}
block|,
block|{
literal|"rpf"
block|,
name|DEBUG_RPF
block|,
literal|3
block|}
block|,
block|{
literal|"pim"
block|,
name|DEBUG_PIM
block|,
literal|1
block|}
block|,
block|{
literal|"routes"
block|,
name|DEBUG_MRT
block|,
literal|1
block|}
block|,
block|{
literal|"routing"
block|,
name|DEBUG_MRT
block|,
literal|1
block|}
block|,
block|{
literal|"mrt"
block|,
name|DEBUG_MRT
block|,
literal|1
block|}
block|,
block|{
literal|"routers"
block|,
name|DEBUG_NEIGHBORS
block|,
literal|6
block|}
block|,
block|{
literal|"mrouters"
block|,
name|DEBUG_NEIGHBORS
block|,
literal|7
block|}
block|,
block|{
literal|"neighbors"
block|,
name|DEBUG_NEIGHBORS
block|,
literal|1
block|}
block|,
block|{
literal|"timers"
block|,
name|DEBUG_TIMER
block|,
literal|1
block|}
block|,
block|{
literal|"asserts"
block|,
name|DEBUG_ASSERT
block|,
literal|1
block|}
block|,
block|{
literal|"all"
block|,
name|DEBUG_ALL
block|,
literal|2
block|}
block|,
block|{
literal|"3"
block|,
literal|0xffffffff
block|,
literal|1
block|}
comment|/* compat. */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Forward declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|handler
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|timer
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restart
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* To shut up gcc -Wstrict-prototypes */
end_comment

begin_decl_stmt
name|int
decl|main
name|__P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|register_input_handler
parameter_list|(
name|fd
parameter_list|,
name|func
parameter_list|)
name|int
name|fd
decl_stmt|;
name|ihfunc_t
name|func
decl_stmt|;
block|{
if|if
condition|(
name|nhandlers
operator|>=
name|NHANDLERS
condition|)
return|return
operator|-
literal|1
return|;
name|ihandlers
index|[
name|nhandlers
index|]
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|ihandlers
index|[
name|nhandlers
operator|++
index|]
operator|.
name|func
operator|=
name|func
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|dummy
decl_stmt|,
name|dummysigalrm
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|,
name|difftime
decl_stmt|,
name|curtime
decl_stmt|,
name|lasttime
decl_stmt|,
modifier|*
name|timeout
decl_stmt|;
name|fd_set
name|rfds
decl_stmt|,
name|readers
decl_stmt|;
name|int
name|nfds
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|secs
decl_stmt|;
specifier|extern
name|char
name|todaysversion
index|[]
decl_stmt|;
name|struct
name|sigaction
name|sa
decl_stmt|;
name|struct
name|debugname
modifier|*
name|d
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|tmpd
decl_stmt|;
name|setlinebuf
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pim6sd: must be root\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|progname
condition|)
name|progname
operator|++
expr_stmt|;
else|else
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-d"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|*
operator|(
name|argv
operator|+
literal|1
operator|)
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|debugname
modifier|*
name|d
decl_stmt|;
name|int
name|no
init|=
literal|0
decl_stmt|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|*
name|argv
expr_stmt|;
name|q
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
name|no
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|debugnames
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|debugnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|debugnames
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
if|if
condition|(
name|len
operator|>=
name|d
operator|->
name|nchars
operator|&&
name|strncmp
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|debugnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|debugnames
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|int
name|j
init|=
literal|0xffffffff
decl_stmt|;
name|int
name|k
init|=
literal|0
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Valid debug levels: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|debugnames
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|debugnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|debugnames
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
operator|,
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|j
operator|&
name|d
operator|->
name|level
operator|)
operator|==
name|d
operator|->
name|level
condition|)
block|{
if|if
condition|(
name|k
operator|++
condition|)
name|putc
argument_list|(
literal|','
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|j
operator|&=
operator|~
name|d
operator|->
name|level
expr_stmt|;
block|}
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
if|if
condition|(
name|no
condition|)
block|{
name|debug
operator|&=
operator|~
name|d
operator|->
name|level
expr_stmt|;
name|no
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|debug
operator||=
name|d
operator|->
name|level
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
block|}
else|else
name|debug
operator|=
name|DEBUG_DEFAULT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-c"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|strcpy
argument_list|(
name|configfilename
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
goto|goto
name|usage
goto|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-f"
argument_list|)
operator|==
literal|0
condition|)
name|foreground
operator|=
literal|1
expr_stmt|;
else|else
goto|goto
name|usage
goto|;
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|usage
label|:
name|tmpd
operator|=
literal|0xffffffff
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: pim6sd [-c configfile] [-d [debug_level][,debug_level]]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"debug levels: "
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'('
expr_stmt|;
for|for
control|(
name|d
operator|=
name|debugnames
init|;
name|d
operator|<
name|debugnames
operator|+
sizeof|sizeof
argument_list|(
name|debugnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|debugnames
index|[
literal|0
index|]
argument_list|)
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|tmpd
operator|&
name|d
operator|->
name|level
operator|)
operator|==
name|d
operator|->
name|level
condition|)
block|{
name|tmpd
operator|&=
operator|~
name|d
operator|->
name|level
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c%s"
argument_list|,
name|c
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|c
operator|=
literal|','
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|!=
literal|0
condition|)
block|{
name|tmpd
operator|=
name|debug
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"debug level 0x%lx "
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'('
expr_stmt|;
for|for
control|(
name|d
operator|=
name|debugnames
init|;
name|d
operator|<
name|debugnames
operator|+
sizeof|sizeof
argument_list|(
name|debugnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|debugnames
index|[
literal|0
index|]
argument_list|)
condition|;
name|d
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|tmpd
operator|&
name|d
operator|->
name|level
operator|)
operator|==
name|d
operator|->
name|level
condition|)
block|{
name|tmpd
operator|&=
operator|~
name|d
operator|->
name|level
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c%s"
argument_list|,
name|c
argument_list|,
name|d
operator|->
name|name
argument_list|)
expr_stmt|;
name|c
operator|=
literal|','
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOG_DAEMON
operator|(
name|void
operator|)
name|openlog
argument_list|(
literal|"pim6sd"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
comment|//  (void) setlogmask(LOG_UPTO(LOG_NOTICE));
else|#
directive|else
operator|(
name|void
operator|)
name|openlog
argument_list|(
literal|"pim6sd"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOG_DAEMON */
comment|/* open a log file */
if|if
condition|(
operator|(
name|log_fp
operator|=
name|fopen
argument_list|(
name|logfilename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
name|errno
argument_list|,
literal|"fopen(%s)"
argument_list|,
name|logfilename
argument_list|)
expr_stmt|;
name|setlinebuf
argument_list|(
name|log_fp
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|versionstring
argument_list|,
literal|"pim6sd version %s"
argument_list|,
name|todaysversion
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|0
argument_list|,
literal|"%s starting"
argument_list|,
name|versionstring
argument_list|)
expr_stmt|;
comment|/*      * TODO: XXX: use a combination of time and hostid to initialize the      * random generator.      */
ifdef|#
directive|ifdef
name|SYSV
name|srand48
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|srandom
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_init
argument_list|()
expr_stmt|;
name|init_mld6
argument_list|()
expr_stmt|;
name|init_pim6
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ROUTING_SOCKETS
name|init_routesock
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_ROUTING_SOCKETS */
name|init_pim6_mrt
argument_list|()
expr_stmt|;
name|init_timers
argument_list|()
expr_stmt|;
comment|/* TODO: check the kernel DVMRP/MROUTED/PIM support version */
name|init_vifs
argument_list|()
expr_stmt|;
name|init_rp6_and_bsr6
argument_list|()
expr_stmt|;
comment|/* Must be after init_vifs() */
name|sa
operator|.
name|sa_handler
operator|=
name|handler
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
comment|/* Interrupt system calls */
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGHUP
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGUSR1
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGUSR2
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINFO
argument_list|,
operator|&
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|readers
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|mld6_socket
argument_list|,
operator|&
name|readers
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nhandlers
condition|;
name|i
operator|++
control|)
block|{
name|FD_SET
argument_list|(
name|ihandlers
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|readers
argument_list|)
expr_stmt|;
if|if
condition|(
name|ihandlers
index|[
name|i
index|]
operator|.
name|fd
operator|>=
name|nfds
condition|)
name|nfds
operator|=
name|ihandlers
index|[
name|i
index|]
operator|.
name|fd
operator|+
literal|1
expr_stmt|;
block|}
name|IF_DEBUG
argument_list|(
argument|DEBUG_IF
argument_list|)
name|dump_vifs
argument_list|(
name|log_fp
argument_list|)
expr_stmt|;
name|IF_DEBUG
argument_list|(
argument|DEBUG_PIM_MRT
argument_list|)
name|dump_pim_mrt
argument_list|(
name|log_fp
argument_list|)
expr_stmt|;
comment|/* schedule first timer interrupt */
name|timer_setTimer
argument_list|(
name|timer_interval
argument_list|,
name|timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|foreground
operator|==
literal|0
condition|)
block|{
comment|/* Detach from the terminal */
ifdef|#
directive|ifdef
name|TIOCNOTTY
name|int
name|t
decl_stmt|;
endif|#
directive|endif
comment|/* TIOCNOTTY */
if|if
condition|(
name|fork
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ROUTING_SOCKETS
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
operator|||
name|defined
argument_list|(
name|linux
argument_list|)
operator|(
name|void
operator|)
name|setpgrp
argument_list|()
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|TIOCNOTTY
name|t
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|t
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|setsid
argument_list|()
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"setsid"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* TIOCNOTTY */
endif|#
directive|endif
comment|/* SYSV */
block|}
comment|/* End of child process code */
name|fp
operator|=
name|fopen
argument_list|(
name|pidfilename
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/*      * Main receive loop.      */
name|dummy
operator|=
literal|0
expr_stmt|;
name|dummysigalrm
operator|=
name|SIGALRM
expr_stmt|;
name|difftime
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|curtime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lasttime
operator|=
name|curtime
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|readers
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rfds
argument_list|,
sizeof|sizeof
argument_list|(
name|rfds
argument_list|)
argument_list|)
expr_stmt|;
name|secs
operator|=
name|timer_nextTimer
argument_list|()
expr_stmt|;
if|if
condition|(
name|secs
operator|==
operator|-
literal|1
condition|)
name|timeout
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|timeout
operator|=
operator|&
name|tv
expr_stmt|;
name|timeout
operator|->
name|tv_sec
operator|=
name|secs
expr_stmt|;
name|timeout
operator|->
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sighandled
condition|)
block|{
if|if
condition|(
name|sighandled
operator|&
name|GOT_SIGINT
condition|)
block|{
name|sighandled
operator|&=
operator|~
name|GOT_SIGINT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sighandled
operator|&
name|GOT_SIGHUP
condition|)
block|{
name|sighandled
operator|&=
operator|~
name|GOT_SIGHUP
expr_stmt|;
name|restart
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sighandled
operator|&
name|GOT_SIGINFO
condition|)
block|{
name|sighandled
operator|&=
operator|~
name|GOT_SIGINFO
expr_stmt|;
name|dump_stat
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sighandled
operator|&
name|GOT_SIGUSR1
condition|)
block|{
name|sighandled
operator|&=
operator|~
name|GOT_SIGUSR1
expr_stmt|;
name|fdump
argument_list|(
name|SIGUSR1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sighandled
operator|&
name|GOT_SIGUSR2
condition|)
block|{
name|sighandled
operator|&=
operator|~
name|GOT_SIGUSR2
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|cdump
argument_list|(
name|SIGUSR2
argument_list|)
expr_stmt|;
else|#
directive|else
name|cfparse
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* reset debug level */
endif|#
directive|endif
block|}
if|if
condition|(
name|sighandled
operator|&
name|GOT_SIGALRM
condition|)
block|{
name|sighandled
operator|&=
operator|~
name|GOT_SIGALRM
expr_stmt|;
name|timer
argument_list|(
operator|&
name|dummysigalrm
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|select
argument_list|(
name|nfds
argument_list|,
operator|&
name|rfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|timeout
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
name|errno
argument_list|,
literal|"select failed"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * Handle timeout queue. 	 * 	 * If select + packet processing took more than 1 second, or if there is 	 * a timeout pending, age the timeout queue. 	 * 	 * If not, collect usec in difftime to make sure that the time doesn't 	 * drift too badly. 	 * 	 * If the timeout handlers took more than 1 second, age the timeout 	 * queue again.  XXX This introduces the potential for infinite 	 * loops! 	 */
do|do
block|{
comment|/* 	     * If the select timed out, then there's no other activity to 	     * account for and we don't need to call gettimeofday. 	     */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|curtime
operator|.
name|tv_sec
operator|=
name|lasttime
operator|.
name|tv_sec
operator|+
name|secs
expr_stmt|;
name|curtime
operator|.
name|tv_usec
operator|=
name|lasttime
operator|.
name|tv_usec
expr_stmt|;
name|n
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't do this next time through the loop */
block|}
else|else
name|gettimeofday
argument_list|(
operator|&
name|curtime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|difftime
operator|.
name|tv_sec
operator|=
name|curtime
operator|.
name|tv_sec
operator|-
name|lasttime
operator|.
name|tv_sec
expr_stmt|;
name|difftime
operator|.
name|tv_usec
operator|+=
name|curtime
operator|.
name|tv_usec
operator|-
name|lasttime
operator|.
name|tv_usec
expr_stmt|;
ifdef|#
directive|ifdef
name|TIMERDEBUG
name|IF_DEBUG
argument_list|(
argument|DEBUG_TIMEOUT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"TIMEOUT: secs %d, diff secs %d, diff usecs %d"
argument_list|,
name|secs
argument_list|,
name|difftime
operator|.
name|tv_sec
argument_list|,
name|difftime
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|difftime
operator|.
name|tv_usec
operator|>=
literal|1000000
condition|)
block|{
name|difftime
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|difftime
operator|.
name|tv_usec
operator|-=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
name|difftime
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|difftime
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|difftime
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
name|lasttime
operator|=
name|curtime
expr_stmt|;
if|if
condition|(
name|secs
operator|==
literal|0
operator|||
name|difftime
operator|.
name|tv_sec
operator|>
literal|0
condition|)
if|if
condition|(
name|secs
operator|==
literal|0
operator|||
name|difftime
operator|.
name|tv_sec
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TIMERDEBUG
name|IF_DEBUG
argument_list|(
argument|DEBUG_TIMEOUT
argument_list|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|0
argument_list|,
literal|"\taging callouts: secs %d, diff secs %d, diff usecs %d"
argument_list|,
name|secs
argument_list|,
name|difftime
operator|.
name|tv_sec
argument_list|,
name|difftime
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|age_callout_queue
argument_list|(
name|difftime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
block|}
name|secs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|difftime
operator|.
name|tv_sec
operator|>
literal|0
condition|)
do|;
comment|/* Handle sockets */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nhandlers
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|ihandlers
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|&
name|rfds
argument_list|)
condition|)
block|{
operator|(
operator|*
name|ihandlers
index|[
name|i
index|]
operator|.
name|func
operator|)
operator|(
name|ihandlers
index|[
name|i
index|]
operator|.
name|fd
operator|,
operator|&
name|rfds
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Main loop */
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"%s exiting"
argument_list|,
name|versionstring
argument_list|)
expr_stmt|;
name|cleanup
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The 'virtual_time' variable is initialized to a value that will cause the  * first invocation of timer() to send a probe or route report to all vifs  * and send group membership queries to all subnets for which this router is  * querier.  This first invocation occurs approximately timer_interval  * seconds after the router starts up.   Note that probes for neighbors and  * queries for group memberships are also sent at start-up time, as part of  * initial- ization.  This repetition after a short interval is desirable for  * quickly building up topology and membership information in the presence of  * possible packet loss.  *  * 'virtual_time' advances at a rate that is only a crude approximation of real  * time, because it does not take into account any time spent processing, and  * because the timer intervals are sometimes shrunk by a random amount to  * avoid unwanted synchronization with other routers.  */
end_comment

begin_decl_stmt
name|u_long
name|virtual_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Timer routine. Performs all perodic functions: aging interfaces, quering  * neighbors and members, etc... The granularity is equal to timer_interval.  * this granularity is configurable ( see file pim6sd.conf.sample)  */
end_comment

begin_function
specifier|static
name|void
name|timer
parameter_list|(
name|i
parameter_list|)
name|void
modifier|*
name|i
decl_stmt|;
block|{
name|age_vifs
argument_list|()
expr_stmt|;
comment|/* Timeout neighbors and groups         */
name|age_routes
argument_list|()
expr_stmt|;
comment|/* Timeout routing entries              */
name|age_misc
argument_list|()
expr_stmt|;
comment|/* Timeout the rest (Cand-RP list, etc) */
name|virtual_time
operator|+=
name|timer_interval
expr_stmt|;
name|timer_setTimer
argument_list|(
name|timer_interval
argument_list|,
name|timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Performs all necessary functions to quit gracefully  */
end_comment

begin_comment
comment|/* TODO: implement all necessary stuff */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|()
block|{
comment|/*      * TODO: XXX (not in the spec): if I am the BSR, somehow inform the other      * routers I am going down and need to elect another BSR? (probably by      * sending a the Cand-RP-set with my_priority=LOWEST?)      *      */
name|k_stop_pim
argument_list|(
name|mld6_socket
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signal handler.  Take note of the fact that the signal arrived so that the  * main loop can take care of it.  */
end_comment

begin_function
specifier|static
name|void
name|handler
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
name|SIGALRM
case|:
name|sighandled
operator||=
name|GOT_SIGALRM
expr_stmt|;
case|case
name|SIGINT
case|:
case|case
name|SIGTERM
case|:
name|sighandled
operator||=
name|GOT_SIGINT
expr_stmt|;
break|break;
case|case
name|SIGHUP
case|:
name|sighandled
operator||=
name|GOT_SIGHUP
expr_stmt|;
break|break;
case|case
name|SIGUSR1
case|:
name|sighandled
operator||=
name|GOT_SIGUSR1
expr_stmt|;
break|break;
case|case
name|SIGUSR2
case|:
name|sighandled
operator||=
name|GOT_SIGUSR2
expr_stmt|;
break|break;
case|case
name|SIGINFO
case|:
name|sighandled
operator||=
name|GOT_SIGINFO
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* TODO: not verified */
end_comment

begin_comment
comment|/*  * Restart the daemon  */
end_comment

begin_function
specifier|static
name|void
name|restart
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|0
argument_list|,
literal|"% restart"
argument_list|,
name|versionstring
argument_list|)
expr_stmt|;
comment|/*      * reset all the entries      */
comment|/*      * TODO: delete?     free_all_routes();      */
name|free_all_callouts
argument_list|()
expr_stmt|;
name|stop_all_vifs
argument_list|()
expr_stmt|;
name|nhandlers
operator|=
literal|0
expr_stmt|;
name|k_stop_pim
argument_list|(
name|mld6_socket
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|mld6_socket
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pim6_socket
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|udp_socket
argument_list|)
expr_stmt|;
comment|/*      * start processing again      */
name|init_mld6
argument_list|()
expr_stmt|;
name|init_pim6
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_ROUTING_SOCKETS
name|init_routesock
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_ROUTING_SOCKETS */
name|init_pim6_mrt
argument_list|()
expr_stmt|;
name|init_vifs
argument_list|()
expr_stmt|;
comment|/* schedule timer interrupts */
name|timer_setTimer
argument_list|(
name|timer_interval
argument_list|,
name|timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

