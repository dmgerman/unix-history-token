begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990, 1991, 1992, 1993, 1996  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1990, 1991, 1992, 1993, 1996\n\ The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * rarpd - Reverse ARP Daemon  *  * Usage:	rarpd -a [ -fsv ] [ hostname ]  *		rarpd [ -fsv ] interface [ hostname ]  *  * 'hostname' is optional solely for backwards compatibility with Sun's rarpd.  * Currently, the argument is ignored.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_if
if|#
directive|if
name|BSD
operator|>=
literal|199100
end_if

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_if
if|#
directive|if
name|BSD
operator|>=
literal|199200
end_if

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_if
if|#
directive|if
name|BSD
operator|>=
literal|199200
end_if

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|,
name|opterr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SUNOS4
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|HAVE_DIRENT_H
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DIRENT_H
end_ifdef

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Cast a struct sockaddr to a structaddr_in */
end_comment

begin_define
define|#
directive|define
name|SATOSIN
parameter_list|(
name|sa
parameter_list|)
value|((struct sockaddr_in *)(sa))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TFTP_DIR
end_ifndef

begin_define
define|#
directive|define
name|TFTP_DIR
value|"/tftpboot"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BSD
operator|>=
literal|199200
end_if

begin_define
define|#
directive|define
name|ARPSECS
value|(20 * 60)
end_define

begin_comment
comment|/* as per code in netinet/if_ether.c */
end_comment

begin_define
define|#
directive|define
name|REVARP_REQUEST
value|ARPOP_REVREQUEST
end_define

begin_define
define|#
directive|define
name|REVARP_REPLY
value|ARPOP_REVREPLY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ETHERTYPE_REVARP
end_ifndef

begin_define
define|#
directive|define
name|ETHERTYPE_REVARP
value|0x8035
end_define

begin_define
define|#
directive|define
name|REVARP_REQUEST
value|3
end_define

begin_define
define|#
directive|define
name|REVARP_REPLY
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Map field names in ether_arp struct.  What a pain in the neck.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS3
end_ifdef

begin_undef
undef|#
directive|undef
name|arp_sha
end_undef

begin_undef
undef|#
directive|undef
name|arp_spa
end_undef

begin_undef
undef|#
directive|undef
name|arp_tha
end_undef

begin_undef
undef|#
directive|undef
name|arp_tpa
end_undef

begin_define
define|#
directive|define
name|arp_sha
value|arp_xsha
end_define

begin_define
define|#
directive|define
name|arp_spa
value|arp_xspa
end_define

begin_define
define|#
directive|define
name|arp_tha
value|arp_xtha
end_define

begin_define
define|#
directive|define
name|arp_tpa
value|arp_xtpa
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
define|#
directive|define
name|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The structure for each interface.  */
end_comment

begin_struct
struct|struct
name|if_info
block|{
name|struct
name|if_info
modifier|*
name|ii_next
decl_stmt|;
name|int
name|ii_fd
decl_stmt|;
comment|/* BPF file descriptor */
name|u_long
name|ii_ipaddr
decl_stmt|;
comment|/* IP address of this interface */
name|u_long
name|ii_netmask
decl_stmt|;
comment|/* subnet or net mask */
name|u_char
name|ii_eaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* Ethernet address of this interface */
name|char
name|ii_ifname
index|[
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|ifreq
operator|*
block|)
literal|0
end_struct

begin_expr_stmt
unit|)
operator|->
name|ifr_name
end_expr_stmt

begin_expr_stmt
unit|)
operator|+
literal|1
expr|]
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/*  * The list of all interfaces that are being listened to.  rarp_loop()  * "selects" on the descriptors in this list.  */
end_comment

begin_decl_stmt
name|struct
name|if_info
modifier|*
name|iflist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verbose messages */
end_comment

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* inet datagram socket */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tftp_dir
init|=
name|TFTP_DIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tftp directory */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__P
end_ifndef

begin_define
define|#
directive|define
name|__P
parameter_list|(
name|protos
parameter_list|)
value|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|BSD
operator|<
literal|199200
end_if

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|ether_ntohost
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|init
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|init_one
name|__P
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|intoa
name|__P
argument_list|(
operator|(
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|ipaddrtonetmask
name|__P
argument_list|(
operator|(
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|eatoa
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rarp_bootable
name|__P
argument_list|(
operator|(
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|rarp_loop
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rarp_open
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|rarp_process
name|__P
argument_list|(
operator|(
expr|struct
name|if_info
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|rarp_reply
name|__P
argument_list|(
operator|(
expr|struct
name|if_info
operator|*
operator|,
expr|struct
name|ether_header
operator|*
operator|,
name|u_long
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|update_arptab
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|zero
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignore /tftpboot */
end_comment

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|op
decl_stmt|;
name|char
modifier|*
name|ifname
decl_stmt|,
modifier|*
name|hostname
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|int
name|aflag
init|=
literal|0
decl_stmt|;
comment|/* listen on "all" interfaces  */
name|int
name|fflag
init|=
literal|0
decl_stmt|;
comment|/* don't fork */
if|if
condition|(
operator|(
name|name
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|++
name|name
expr_stmt|;
else|else
name|name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'-'
condition|)
operator|++
name|name
expr_stmt|;
comment|/* 	 * All error reporting is done through syslogs. 	 */
name|openlog
argument_list|(
name|name
argument_list|,
name|LOG_PID
operator||
name|LOG_CONS
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"afsv"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'a'
case|:
operator|++
name|aflag
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|++
name|fflag
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|++
name|sflag
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|++
name|verbose
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|ifname
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|hostname
operator|=
name|ifname
condition|?
name|argv
index|[
name|optind
index|]
else|:
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|aflag
operator|&&
name|ifname
operator|)
operator|||
operator|(
operator|!
name|aflag
operator|&&
name|ifname
operator|==
name|NULL
operator|)
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|else
name|init
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fflag
condition|)
block|{
if|if
condition|(
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|rarp_loop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add to the interface list.  */
end_comment

begin_function
name|void
name|init_one
parameter_list|(
name|ifrp
parameter_list|,
name|target
parameter_list|)
specifier|register
name|struct
name|ifreq
modifier|*
name|ifrp
decl_stmt|;
specifier|register
name|char
modifier|*
name|target
decl_stmt|;
block|{
specifier|register
name|struct
name|if_info
modifier|*
name|ii
decl_stmt|;
specifier|register
name|struct
name|sockaddr_dl
modifier|*
name|ll
decl_stmt|;
name|int
name|family
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|family
operator|=
name|ifrp
operator|->
name|ifr_addr
operator|.
name|sa_family
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
if|#
directive|if
name|BSD
operator|>=
literal|199100
case|case
name|AF_LINK
case|:
endif|#
directive|endif
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|ifrp
operator|->
name|ifr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIOCGIFFLAGS: %.*s: %m"
argument_list|,
sizeof|sizeof
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|)
argument_list|,
name|ifrp
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifr
operator|.
name|ifr_flags
operator|&
operator|(
name|IFF_LOOPBACK
operator||
name|IFF_POINTOPOINT
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return;
break|break;
default|default:
return|return;
block|}
comment|/* Don't bother going any further if not the target interface */
if|if
condition|(
name|target
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|,
name|target
argument_list|,
sizeof|sizeof
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Look for interface in list */
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
operator|!=
name|NULL
condition|;
name|ii
operator|=
name|ii
operator|->
name|ii_next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|,
name|ii
operator|->
name|ii_ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Allocate a new one if not found */
if|if
condition|(
name|ii
operator|==
name|NULL
condition|)
block|{
name|ii
operator|=
operator|(
expr|struct
name|if_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ii
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|ii
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ii
argument_list|)
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_fd
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ii
operator|->
name|ii_ifname
argument_list|,
name|ifrp
operator|->
name|ifr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_ifname
index|[
sizeof|sizeof
argument_list|(
name|ii
operator|->
name|ii_ifname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ii
operator|->
name|ii_next
operator|=
name|iflist
expr_stmt|;
name|iflist
operator|=
name|ii
expr_stmt|;
block|}
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ipaddr SIOCGIFADDR: %s: %m"
argument_list|,
name|ii
operator|->
name|ii_ifname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ii
operator|->
name|ii_ipaddr
operator|=
name|SATOSIN
argument_list|(
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIOCGIFNETMASK: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ii
operator|->
name|ii_netmask
operator|=
name|SATOSIN
argument_list|(
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_netmask
operator|==
literal|0
condition|)
name|ii
operator|->
name|ii_netmask
operator|=
name|ipaddrtonetmask
argument_list|(
name|ii
operator|->
name|ii_ipaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_fd
operator|<
literal|0
condition|)
block|{
name|ii
operator|->
name|ii_fd
operator|=
name|rarp_open
argument_list|(
name|ii
operator|->
name|ii_ifname
argument_list|)
expr_stmt|;
if|#
directive|if
name|BSD
operator|<
literal|199100
comment|/* Use BPF descriptor to get ethernet address. */
if|if
condition|(
name|ioctl
argument_list|(
name|ii
operator|->
name|ii_fd
argument_list|,
name|SIOCGIFADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"eaddr SIOCGIFADDR: %s: %m"
argument_list|,
name|ii
operator|->
name|ii_ifname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|&
name|ifr
operator|.
name|ifr_addr
operator|.
name|sa_data
index|[
literal|0
index|]
argument_list|,
name|ii
operator|->
name|ii_eaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
if|#
directive|if
name|BSD
operator|>=
literal|199100
case|case
name|AF_LINK
case|:
name|ll
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|&
name|ifrp
operator|->
name|ifr_addr
expr_stmt|;
if|if
condition|(
name|ll
operator|->
name|sdl_type
operator|==
name|IFT_ETHER
condition|)
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|ll
argument_list|)
argument_list|,
name|ii
operator|->
name|ii_eaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize all "candidate" interfaces that are in the system  * configuration list.  A "candidate" is up, not loopback and not  * point to point.  */
end_comment

begin_function
name|void
name|init
parameter_list|(
name|target
parameter_list|)
name|char
modifier|*
name|target
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|struct
name|ifreq
modifier|*
name|ifrp
decl_stmt|,
modifier|*
name|ifend
decl_stmt|;
specifier|register
name|struct
name|if_info
modifier|*
name|ii
decl_stmt|,
modifier|*
name|nii
decl_stmt|,
modifier|*
name|lii
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
name|ibuf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
name|ibuf
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
operator|(
name|caddr_t
operator|)
name|ibuf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|u_int
operator|)
name|ifc
operator|.
name|ifc_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIOCGIFCONF: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ifrp
operator|=
name|ibuf
expr_stmt|;
name|ifend
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ibuf
operator|+
name|ifc
operator|.
name|ifc_len
operator|)
expr_stmt|;
while|while
condition|(
name|ifrp
operator|<
name|ifend
condition|)
block|{
name|init_one
argument_list|(
name|ifrp
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199100
name|n
operator|=
name|ifrp
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|+
sizeof|sizeof
argument_list|(
name|ifrp
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ifrp
argument_list|)
condition|)
name|n
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ifrp
argument_list|)
expr_stmt|;
name|ifrp
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ifrp
operator|+
name|n
operator|)
expr_stmt|;
else|#
directive|else
operator|++
name|ifrp
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Throw away incomplete interfaces */
name|lii
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
operator|!=
name|NULL
condition|;
name|ii
operator|=
name|nii
control|)
block|{
name|nii
operator|=
name|ii
operator|->
name|ii_next
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_ipaddr
operator|==
literal|0
operator|||
name|bcmp
argument_list|(
name|ii
operator|->
name|ii_eaddr
argument_list|,
name|zero
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lii
operator|==
name|NULL
condition|)
name|iflist
operator|=
name|nii
expr_stmt|;
else|else
name|lii
operator|->
name|ii_next
operator|=
name|nii
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|ii
operator|->
name|ii_fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ii
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lii
operator|=
name|ii
expr_stmt|;
block|}
comment|/* Verbose stuff */
if|if
condition|(
name|verbose
condition|)
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
operator|!=
name|NULL
condition|;
name|ii
operator|=
name|ii
operator|->
name|ii_next
control|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s %s 0x%08x %s"
argument_list|,
name|ii
operator|->
name|ii_ifname
argument_list|,
name|intoa
argument_list|(
name|ntohl
argument_list|(
name|ii
operator|->
name|ii_ipaddr
argument_list|)
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ii
operator|->
name|ii_netmask
argument_list|)
argument_list|,
name|eatoa
argument_list|(
name|ii
operator|->
name|ii_eaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: rarpd [-afnv] [interface]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_open
parameter_list|()
block|{
name|int
name|fd
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
name|device
index|[
sizeof|sizeof
expr|"/dev/bpf000"]
expr_stmt|;
comment|/* 	 * Go through all the minors and find one that isn't in use. 	 */
do|do
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
literal|"/dev/bpf%d"
argument_list|,
name|n
operator|++
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fd
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EBUSY
condition|)
do|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*  * Open a BPF file and attach it to the interface named 'device'.  * Set immediate mode, and set a filter that accepts only RARP requests.  */
end_comment

begin_function
name|int
name|rarp_open
parameter_list|(
name|device
parameter_list|)
name|char
modifier|*
name|device
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|u_int
name|dlt
decl_stmt|;
name|int
name|immediate
decl_stmt|;
specifier|static
name|struct
name|bpf_insn
name|insns
index|[]
init|=
block|{
name|BPF_STMT
argument_list|(
name|BPF_LD
operator||
name|BPF_H
operator||
name|BPF_ABS
argument_list|,
literal|12
argument_list|)
block|,
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator||
name|BPF_JEQ
operator||
name|BPF_K
argument_list|,
name|ETHERTYPE_REVARP
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
block|,
name|BPF_STMT
argument_list|(
name|BPF_LD
operator||
name|BPF_H
operator||
name|BPF_ABS
argument_list|,
literal|20
argument_list|)
block|,
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator||
name|BPF_JEQ
operator||
name|BPF_K
argument_list|,
name|REVARP_REQUEST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|,
name|BPF_STMT
argument_list|(
name|BPF_RET
operator||
name|BPF_K
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_arp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
block|,
name|BPF_STMT
argument_list|(
name|BPF_RET
operator||
name|BPF_K
argument_list|,
literal|0
argument_list|)
block|, 	}
decl_stmt|;
specifier|static
name|struct
name|bpf_program
name|filter
init|=
block|{
sizeof|sizeof
name|insns
operator|/
sizeof|sizeof
argument_list|(
name|insns
index|[
literal|0
index|]
argument_list|)
block|,
name|insns
block|}
decl_stmt|;
name|fd
operator|=
name|bpf_open
argument_list|()
expr_stmt|;
comment|/* 	 * Set immediate mode so packets are processed as they arrive. 	 */
name|immediate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCIMMEDIATE
argument_list|,
operator|&
name|immediate
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCIMMEDIATE: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETIF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCSETIF: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check that the data link layer is an Ethernet; this code won't 	 * work with anything else. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGDLT
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dlt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCGDLT: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dlt
operator|!=
name|DLT_EN10MB
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s is not an ethernet"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set filter program. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|filter
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCSETF: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*  * Perform various sanity checks on the RARP request packet.  Return  * false on failure and log the reason.  */
end_comment

begin_function
specifier|static
name|int
name|rarp_check
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
name|u_char
modifier|*
name|p
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|{
name|struct
name|ether_header
modifier|*
name|ep
init|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|ether_arp
modifier|*
name|ap
init|=
operator|(
expr|struct
name|ether_arp
operator|*
operator|)
operator|(
name|p
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"truncated request, got %d, expected %d"
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * XXX This test might be better off broken out... 	 */
if|if
condition|(
name|ntohs
argument_list|(
name|ep
operator|->
name|ether_type
argument_list|)
operator|!=
name|ETHERTYPE_REVARP
operator|||
name|ntohs
argument_list|(
name|ap
operator|->
name|arp_hrd
argument_list|)
operator|!=
name|ARPHRD_ETHER
operator|||
name|ntohs
argument_list|(
name|ap
operator|->
name|arp_op
argument_list|)
operator|!=
name|REVARP_REQUEST
operator|||
name|ntohs
argument_list|(
name|ap
operator|->
name|arp_pro
argument_list|)
operator|!=
name|ETHERTYPE_IP
operator|||
name|ap
operator|->
name|arp_hln
operator|!=
literal|6
operator|||
name|ap
operator|->
name|arp_pln
operator|!=
literal|4
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"request fails sanity check"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ether/arp sender address mismatch"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_tha
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ether/arp target address mismatch"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FD_SETSIZE
end_ifndef

begin_define
define|#
directive|define
name|FD_SET
parameter_list|(
name|n
parameter_list|,
name|fdp
parameter_list|)
value|((fdp)->fds_bits[0] |= (1<< (n)))
end_define

begin_define
define|#
directive|define
name|FD_ISSET
parameter_list|(
name|n
parameter_list|,
name|fdp
parameter_list|)
value|((fdp)->fds_bits[0]& (1<< (n)))
end_define

begin_define
define|#
directive|define
name|FD_ZERO
parameter_list|(
name|fdp
parameter_list|)
value|((fdp)->fds_bits[0] = 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Loop indefinitely listening for RARP requests on the  * interfaces in 'iflist'.  */
end_comment

begin_function
name|void
name|rarp_loop
parameter_list|()
block|{
name|u_char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|fd
decl_stmt|;
name|fd_set
name|fds
decl_stmt|,
name|listeners
decl_stmt|;
name|int
name|bufsize
decl_stmt|,
name|maxfd
init|=
literal|0
decl_stmt|;
name|struct
name|if_info
modifier|*
name|ii
decl_stmt|;
if|if
condition|(
name|iflist
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no interfaces"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|iflist
operator|->
name|ii_fd
argument_list|,
name|BIOCGBLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCGBLEN: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 		 * Find the highest numbered file descriptor for select(). 		 * Initialize the set of descriptors to listen to. 		 */
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
operator|!=
name|NULL
condition|;
name|ii
operator|=
name|ii
operator|->
name|ii_next
control|)
block|{
name|FD_SET
argument_list|(
name|ii
operator|->
name|ii_fd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_fd
operator|>
name|maxfd
condition|)
name|maxfd
operator|=
name|ii
operator|->
name|ii_fd
expr_stmt|;
block|}
name|listeners
operator|=
name|fds
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
operator|&
name|listeners
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Don't choke when we get ptraced */
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
operator|!=
name|NULL
condition|;
name|ii
operator|=
name|ii
operator|->
name|ii_next
control|)
block|{
name|fd
operator|=
name|ii
operator|->
name|ii_fd
expr_stmt|;
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|listeners
argument_list|)
condition|)
continue|continue;
name|again
label|:
name|cc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
comment|/* Don't choke when we get ptraced */
if|if
condition|(
name|cc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|again
goto|;
if|#
directive|if
name|defined
argument_list|(
name|SUNOS3
argument_list|)
operator|||
name|defined
argument_list|(
name|SUNOS4
argument_list|)
comment|/* 			 * Due to a SunOS bug, after 2^31 bytes, the 			 * file offset overflows and read fails with 			 * EINVAL.  The lseek() to 0 will fix things. 			 */
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
operator|&&
call|(
name|long
call|)
argument_list|(
name|tell
argument_list|(
name|fd
argument_list|)
operator|+
name|bufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"read: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Loop through the packet(s) */
define|#
directive|define
name|bhp
value|((struct bpf_hdr *)bp)
name|bp
operator|=
name|buf
expr_stmt|;
name|ep
operator|=
name|bp
operator|+
name|cc
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|ep
condition|)
block|{
specifier|register
name|u_int
name|caplen
decl_stmt|,
name|hdrlen
decl_stmt|;
name|caplen
operator|=
name|bhp
operator|->
name|bh_caplen
expr_stmt|;
name|hdrlen
operator|=
name|bhp
operator|->
name|bh_hdrlen
expr_stmt|;
if|if
condition|(
name|rarp_check
argument_list|(
name|bp
operator|+
name|hdrlen
argument_list|,
name|caplen
argument_list|)
condition|)
name|rarp_process
argument_list|(
name|ii
argument_list|,
name|bp
operator|+
name|hdrlen
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|BPF_WORDALIGN
argument_list|(
name|hdrlen
operator|+
name|caplen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|bhp
block|}
end_function

begin_comment
comment|/*  * True if this server can boot the host whose IP address is 'addr'.  * This check is made by looking in the tftp directory for the  * configuration file.  */
end_comment

begin_function
name|int
name|rarp_bootable
parameter_list|(
name|addr
parameter_list|)
name|u_long
name|addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_DIRENT_H
specifier|register
name|struct
name|dirent
modifier|*
name|dent
decl_stmt|;
else|#
directive|else
specifier|register
name|struct
name|direct
modifier|*
name|dent
decl_stmt|;
endif|#
directive|endif
specifier|register
name|DIR
modifier|*
name|d
decl_stmt|;
name|char
name|ipname
index|[
literal|9
index|]
decl_stmt|;
specifier|static
name|DIR
modifier|*
name|dd
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ipname
argument_list|,
literal|"%08X"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ntohl
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If directory is already open, rewind it.  Otherwise, open it. 	 */
if|if
condition|(
operator|(
name|d
operator|=
name|dd
operator|)
operator|!=
name|NULL
condition|)
name|rewinddir
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|chdir
argument_list|(
name|tftp_dir
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chdir: %s: %m"
argument_list|,
name|tftp_dir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"opendir: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dd
operator|=
name|d
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|dent
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|dent
operator|->
name|d_name
argument_list|,
name|ipname
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Given a list of IP addresses, 'alist', return the first address that  * is on network 'net'; 'netmask' is a mask indicating the network portion  * of the address.  */
end_comment

begin_function
name|u_long
name|choose_ipaddr
parameter_list|(
name|alist
parameter_list|,
name|net
parameter_list|,
name|netmask
parameter_list|)
name|u_long
modifier|*
modifier|*
name|alist
decl_stmt|;
name|u_long
name|net
decl_stmt|;
name|u_long
name|netmask
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|alist
condition|;
operator|++
name|alist
control|)
if|if
condition|(
operator|(
operator|*
operator|*
name|alist
operator|&
name|netmask
operator|)
operator|==
name|net
condition|)
return|return
operator|*
operator|*
name|alist
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Answer the RARP request in 'pkt', on the interface 'ii'.  'pkt' has  * already been checked for validity.  The reply is overlaid on the request.  */
end_comment

begin_function
name|void
name|rarp_process
parameter_list|(
name|ii
parameter_list|,
name|pkt
parameter_list|,
name|len
parameter_list|)
name|struct
name|if_info
modifier|*
name|ii
decl_stmt|;
name|u_char
modifier|*
name|pkt
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|{
name|struct
name|ether_header
modifier|*
name|ep
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|u_long
name|target_ipaddr
decl_stmt|;
name|char
name|ename
index|[
literal|256
index|]
decl_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|pkt
expr_stmt|;
comment|/* should this be arp_tha? */
if|if
condition|(
name|ether_ntohost
argument_list|(
name|ename
argument_list|,
operator|&
name|ep
operator|->
name|ether_shost
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot map %s to name"
argument_list|,
name|eatoa
argument_list|(
name|ep
operator|->
name|ether_shost
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|ename
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot map %s to IP address"
argument_list|,
name|ename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Choose correct address from list. 	 */
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot handle non IP addresses for %s"
argument_list|,
name|ename
argument_list|)
expr_stmt|;
return|return;
block|}
name|target_ipaddr
operator|=
name|choose_ipaddr
argument_list|(
operator|(
name|u_long
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
argument_list|,
name|ii
operator|->
name|ii_ipaddr
operator|&
name|ii
operator|->
name|ii_netmask
argument_list|,
name|ii
operator|->
name|ii_netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_ipaddr
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot find %s on net %s"
argument_list|,
name|ename
argument_list|,
name|intoa
argument_list|(
name|ntohl
argument_list|(
name|ii
operator|->
name|ii_ipaddr
operator|&
name|ii
operator|->
name|ii_netmask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sflag
operator|||
name|rarp_bootable
argument_list|(
name|target_ipaddr
argument_list|)
condition|)
name|rarp_reply
argument_list|(
name|ii
argument_list|,
name|ep
argument_list|,
name|target_ipaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s %s at %s DENIED (not bootable)"
argument_list|,
name|ii
operator|->
name|ii_ifname
argument_list|,
name|eatoa
argument_list|(
name|ep
operator|->
name|ether_shost
argument_list|)
argument_list|,
name|intoa
argument_list|(
name|ntohl
argument_list|(
name|target_ipaddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Poke the kernel arp tables with the ethernet/ip address combinataion  * given.  When processing a reply, we must do this so that the booting  * host (i.e. the guy running rarpd), won't try to ARP for the hardware  * address of the guy being booted (he cannot answer the ARP).  */
end_comment

begin_if
if|#
directive|if
name|BSD
operator|>=
literal|199200
end_if

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_inarp
name|sin_inarp
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_inarp
argument_list|)
block|,
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_dl
name|sin_dl
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_dl
argument_list|)
block|,
name|AF_LINK
block|,
literal|0
block|,
name|IFT_ETHER
block|,
literal|0
block|,
literal|6
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|rt_msghdr
name|rthdr
decl_stmt|;
name|char
name|rtspace
index|[
literal|512
index|]
decl_stmt|;
block|}
name|rtmsg
struct|;
end_struct

begin_function
name|void
name|update_arptab
parameter_list|(
name|ep
parameter_list|,
name|ipaddr
parameter_list|)
name|u_char
modifier|*
name|ep
decl_stmt|;
name|u_long
name|ipaddr
decl_stmt|;
block|{
specifier|register
name|int
name|cc
decl_stmt|;
specifier|register
name|struct
name|sockaddr_inarp
modifier|*
name|ar
decl_stmt|,
modifier|*
name|ar2
decl_stmt|;
specifier|register
name|struct
name|sockaddr_dl
modifier|*
name|ll
decl_stmt|,
modifier|*
name|ll2
decl_stmt|;
specifier|register
name|struct
name|rt_msghdr
modifier|*
name|rt
decl_stmt|;
specifier|register
name|int
name|xtype
decl_stmt|,
name|xindex
decl_stmt|;
specifier|static
name|pid_t
name|pid
decl_stmt|;
specifier|static
name|int
name|r
decl_stmt|,
name|seq
decl_stmt|;
specifier|static
name|init
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
block|{
name|r
operator|=
name|socket
argument_list|(
name|PF_ROUTE
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"raw route socket: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
operator|++
name|init
expr_stmt|;
block|}
name|ar
operator|=
operator|&
name|sin_inarp
expr_stmt|;
name|ar
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|ipaddr
expr_stmt|;
name|ll
operator|=
operator|&
name|sin_dl
expr_stmt|;
name|bcopy
argument_list|(
name|ep
argument_list|,
name|LLADDR
argument_list|(
name|ll
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Get the type and interface index */
name|rt
operator|=
operator|&
name|rtmsg
operator|.
name|rthdr
expr_stmt|;
name|bzero
argument_list|(
name|rt
argument_list|,
sizeof|sizeof
argument_list|(
name|rtmsg
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rtm_version
operator|=
name|RTM_VERSION
expr_stmt|;
name|rt
operator|->
name|rtm_addrs
operator|=
name|RTA_DST
expr_stmt|;
name|rt
operator|->
name|rtm_type
operator|=
name|RTM_GET
expr_stmt|;
name|rt
operator|->
name|rtm_seq
operator|=
operator|++
name|seq
expr_stmt|;
name|ar2
operator|=
operator|(
expr|struct
name|sockaddr_inarp
operator|*
operator|)
name|rtmsg
operator|.
name|rtspace
expr_stmt|;
name|bcopy
argument_list|(
name|ar
argument_list|,
name|ar2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rtm_msglen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|r
argument_list|,
name|rt
argument_list|,
name|rt
operator|->
name|rtm_msglen
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ESRCH
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rtmsg get write: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|cc
operator|=
name|read
argument_list|(
name|r
argument_list|,
name|rt
argument_list|,
sizeof|sizeof
argument_list|(
name|rtmsg
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cc
operator|>
literal|0
operator|&&
operator|(
name|rt
operator|->
name|rtm_seq
operator|!=
name|seq
operator|||
name|rt
operator|->
name|rtm_pid
operator|!=
name|pid
operator|)
condition|)
do|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rtmsg get read: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ll2
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ar2
operator|+
name|ar2
operator|->
name|sin_len
operator|)
expr_stmt|;
if|if
condition|(
name|ll2
operator|->
name|sdl_family
operator|!=
name|AF_LINK
condition|)
block|{
comment|/* 		 * XXX I think this means the ip address is not on a 		 * directly connected network (the family is AF_INET in 		 * this case). 		 */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bogus link family (%d) wrong net for %08X?\n"
argument_list|,
name|ll2
operator|->
name|sdl_family
argument_list|,
name|ipaddr
argument_list|)
expr_stmt|;
return|return;
block|}
name|xtype
operator|=
name|ll2
operator|->
name|sdl_type
expr_stmt|;
name|xindex
operator|=
name|ll2
operator|->
name|sdl_index
expr_stmt|;
comment|/* Set the new arp entry */
name|bzero
argument_list|(
name|rt
argument_list|,
sizeof|sizeof
argument_list|(
name|rtmsg
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rtm_version
operator|=
name|RTM_VERSION
expr_stmt|;
name|rt
operator|->
name|rtm_addrs
operator|=
name|RTA_DST
operator||
name|RTA_GATEWAY
expr_stmt|;
name|rt
operator|->
name|rtm_inits
operator|=
name|RTV_EXPIRE
expr_stmt|;
name|rt
operator|->
name|rtm_rmx
operator|.
name|rmx_expire
operator|=
name|time
argument_list|(
literal|0
argument_list|)
operator|+
name|ARPSECS
expr_stmt|;
name|rt
operator|->
name|rtm_flags
operator|=
name|RTF_HOST
operator||
name|RTF_STATIC
expr_stmt|;
name|rt
operator|->
name|rtm_type
operator|=
name|RTM_ADD
expr_stmt|;
name|rt
operator|->
name|rtm_seq
operator|=
operator|++
name|seq
expr_stmt|;
name|bcopy
argument_list|(
name|ar
argument_list|,
name|ar2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
argument_list|)
expr_stmt|;
name|ll2
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ar2
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ar2
argument_list|)
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|ll
argument_list|,
name|ll2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ll
argument_list|)
argument_list|)
expr_stmt|;
name|ll2
operator|->
name|sdl_type
operator|=
name|xtype
expr_stmt|;
name|ll2
operator|->
name|sdl_index
operator|=
name|xindex
expr_stmt|;
name|rt
operator|->
name|rtm_msglen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ar2
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ll2
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|r
argument_list|,
name|rt
argument_list|,
name|rt
operator|->
name|rtm_msglen
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rtmsg add write: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|cc
operator|=
name|read
argument_list|(
name|r
argument_list|,
name|rt
argument_list|,
sizeof|sizeof
argument_list|(
name|rtmsg
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cc
operator|>
literal|0
operator|&&
operator|(
name|rt
operator|->
name|rtm_seq
operator|!=
name|seq
operator|||
name|rt
operator|->
name|rtm_pid
operator|!=
name|pid
operator|)
condition|)
do|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rtmsg add read: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|update_arptab
parameter_list|(
name|ep
parameter_list|,
name|ipaddr
parameter_list|)
name|u_char
modifier|*
name|ep
decl_stmt|;
name|u_long
name|ipaddr
decl_stmt|;
block|{
name|struct
name|arpreq
name|request
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|request
operator|.
name|arp_flags
operator|=
literal|0
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|request
operator|.
name|arp_pa
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|ipaddr
expr_stmt|;
name|request
operator|.
name|arp_ha
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
argument_list|,
operator|(
name|char
operator|*
operator|)
name|request
operator|.
name|arp_ha
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSARP
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|request
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIOCSARP: %m"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Build a reverse ARP packet and sent it out on the interface.  * 'ep' points to a valid REVARP_REQUEST.  The REVARP_REPLY is built  * on top of the request, then written to the network.  *  * RFC 903 defines the ether_arp fields as follows.  The following comments  * are taken (more or less) straight from this document.  *  * REVARP_REQUEST  *  * arp_sha is the hardware address of the sender of the packet.  * arp_spa is undefined.  * arp_tha is the 'target' hardware address.  *   In the case where the sender wishes to determine his own  *   protocol address, this, like arp_sha, will be the hardware  *   address of the sender.  * arp_tpa is undefined.  *  * REVARP_REPLY  *  * arp_sha is the hardware address of the responder (the sender of the  *   reply packet).  * arp_spa is the protocol address of the responder (see the note below).  * arp_tha is the hardware address of the target, and should be the same as  *   that which was given in the request.  * arp_tpa is the protocol address of the target, that is, the desired address.  *  * Note that the requirement that arp_spa be filled in with the responder's  * protocol is purely for convenience.  For instance, if a system were to use  * both ARP and RARP, then the inclusion of the valid protocol-hardware  * address pair (arp_spa, arp_sha) may eliminate the need for a subsequent  * ARP request.  */
end_comment

begin_function
name|void
name|rarp_reply
parameter_list|(
name|ii
parameter_list|,
name|ep
parameter_list|,
name|ipaddr
parameter_list|,
name|len
parameter_list|)
name|struct
name|if_info
modifier|*
name|ii
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|ep
decl_stmt|;
name|u_long
name|ipaddr
decl_stmt|;
name|u_int
name|len
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|struct
name|ether_arp
modifier|*
name|ap
init|=
operator|(
expr|struct
name|ether_arp
operator|*
operator|)
operator|(
name|ep
operator|+
literal|1
operator|)
decl_stmt|;
name|update_arptab
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
name|ipaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Build the rarp reply by modifying the rarp request in place. 	 */
name|ap
operator|->
name|arp_op
operator|=
name|htons
argument_list|(
name|REVARP_REPLY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_BPF
name|ep
operator|->
name|ether_type
operator|=
name|ETHERTYPE_REVARP
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_dhost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ii
operator|->
name|ii_eaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_shost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ii
operator|->
name|ii_eaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ipaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|arp_tpa
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Target hardware is unchanged. */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ii
operator|->
name|ii_ipaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|arp_spa
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Zero possible garbage after packet. */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
operator|)
argument_list|,
name|len
operator|-
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|write
argument_list|(
name|ii
operator|->
name|ii_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ep
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|len
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"write: only %d of %d bytes written"
argument_list|,
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s %s at %s REPLIED"
argument_list|,
name|ii
operator|->
name|ii_ifname
argument_list|,
name|eatoa
argument_list|(
name|ap
operator|->
name|arp_tha
argument_list|)
argument_list|,
name|intoa
argument_list|(
name|ntohl
argument_list|(
name|ipaddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the netmask of an IP address.  This routine is used if  * SIOCGIFNETMASK doesn't work.  */
end_comment

begin_function
name|u_long
name|ipaddrtonetmask
parameter_list|(
name|addr
parameter_list|)
name|u_long
name|addr
decl_stmt|;
block|{
name|addr
operator|=
name|ntohl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|htonl
argument_list|(
name|IN_CLASSA_NET
argument_list|)
return|;
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|htonl
argument_list|(
name|IN_CLASSB_NET
argument_list|)
return|;
if|if
condition|(
name|IN_CLASSC
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|htonl
argument_list|(
name|IN_CLASSC_NET
argument_list|)
return|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unknown IP address class: %08X"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|htonl
argument_list|(
literal|0xffffffff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * A faster replacement for inet_ntoa().  */
end_comment

begin_function
name|char
modifier|*
name|intoa
parameter_list|(
name|addr
parameter_list|)
name|u_long
name|addr
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|u_int
name|byte
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
specifier|static
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
literal|".xxx.xxx.xxx.xxx"
argument_list|)
index|]
decl_stmt|;
name|cp
operator|=
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
expr_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
literal|4
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|--
name|cp
operator|=
name|byte
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|byte
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|byte
operator|>
literal|0
condition|)
block|{
operator|*
operator|--
name|cp
operator|=
name|byte
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|byte
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|byte
operator|>
literal|0
condition|)
operator|*
operator|--
name|cp
operator|=
name|byte
operator|+
literal|'0'
expr_stmt|;
block|}
operator|*
operator|--
name|cp
operator|=
literal|'.'
expr_stmt|;
name|addr
operator|>>=
literal|8
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
do|;
return|return
name|cp
operator|+
literal|1
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|eatoa
parameter_list|(
name|ea
parameter_list|)
specifier|register
name|u_char
modifier|*
name|ea
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
literal|"xx:xx:xx:xx:xx:xx"
argument_list|)
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%x:%x:%x:%x:%x:%x"
argument_list|,
name|ea
index|[
literal|0
index|]
argument_list|,
name|ea
index|[
literal|1
index|]
argument_list|,
name|ea
index|[
literal|2
index|]
argument_list|,
name|ea
index|[
literal|3
index|]
argument_list|,
name|ea
index|[
literal|4
index|]
argument_list|,
name|ea
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

end_unit

