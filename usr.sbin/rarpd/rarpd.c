begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990, 1991, 1992, 1993, 1996  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static const char copyright[] = "@(#) Copyright (c) 1990, 1991, 1992, 1993, 1996\n\ The Regents of the University of California.  All rights reserved.\n";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * rarpd - Reverse ARP Daemon  *  * Usage:	rarpd -a [-dfsv] [-t directory] [hostname]  *		rarpd [-dfsv] [-t directory] interface [hostname]  *  * 'hostname' is optional solely for backwards compatibility with Sun's rarpd.  * Currently, the argument is ignored.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* Cast a struct sockaddr to a struct sockaddr_in */
end_comment

begin_define
define|#
directive|define
name|SATOSIN
parameter_list|(
name|sa
parameter_list|)
value|((struct sockaddr_in *)(sa))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TFTP_DIR
end_ifndef

begin_define
define|#
directive|define
name|TFTP_DIR
value|"/tftpboot"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ARPSECS
value|(20 * 60)
end_define

begin_comment
comment|/* as per code in netinet/if_ether.c */
end_comment

begin_define
define|#
directive|define
name|REVARP_REQUEST
value|ARPOP_REVREQUEST
end_define

begin_define
define|#
directive|define
name|REVARP_REPLY
value|ARPOP_REVREPLY
end_define

begin_comment
comment|/*  * The structure for each interface.  */
end_comment

begin_struct
struct|struct
name|if_info
block|{
name|struct
name|if_info
modifier|*
name|ii_next
decl_stmt|;
name|int
name|ii_fd
decl_stmt|;
comment|/* BPF file descriptor */
name|in_addr_t
name|ii_ipaddr
decl_stmt|;
comment|/* IP address */
name|in_addr_t
name|ii_netmask
decl_stmt|;
comment|/* subnet or net mask */
name|u_char
name|ii_eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
comment|/* ethernet address */
name|char
name|ii_ifname
index|[
name|IF_NAMESIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The list of all interfaces that are being listened to.  rarp_loop()  * "selects" on the descriptors in this list.  */
end_comment

begin_decl_stmt
name|struct
name|if_info
modifier|*
name|iflist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verbose messages */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|tftp_dir
init|=
name|TFTP_DIR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tftp directory */
end_comment

begin_decl_stmt
name|int
name|dflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* messages to stdout/stderr, not syslog(3) */
end_comment

begin_decl_stmt
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignore /tftpboot */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|zero
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|bpf_open
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|in_addr_t
name|choose_ipaddr
parameter_list|(
name|in_addr_t
modifier|*
modifier|*
parameter_list|,
name|in_addr_t
parameter_list|,
name|in_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|eatoa
parameter_list|(
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expand_syslog_m
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|char
modifier|*
modifier|*
name|newfmt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_one
parameter_list|(
name|struct
name|ifaddrs
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|intoa
parameter_list|(
name|in_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|in_addr_t
name|ipaddrtonetmask
parameter_list|(
name|in_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|logmsg
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|__printflike
parameter_list|(
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|int
name|rarp_bootable
parameter_list|(
name|in_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rarp_check
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rarp_loop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rarp_open
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rarp_process
parameter_list|(
name|struct
name|if_info
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rarp_reply
parameter_list|(
name|struct
name|if_info
modifier|*
parameter_list|,
name|struct
name|ether_header
modifier|*
parameter_list|,
name|in_addr_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_arptab
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|in_addr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|op
decl_stmt|;
name|char
modifier|*
name|ifname
decl_stmt|,
modifier|*
name|hostname
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|int
name|aflag
init|=
literal|0
decl_stmt|;
comment|/* listen on "all" interfaces  */
name|int
name|fflag
init|=
literal|0
decl_stmt|;
comment|/* don't fork */
if|if
condition|(
operator|(
name|name
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|++
name|name
expr_stmt|;
else|else
name|name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'-'
condition|)
operator|++
name|name
expr_stmt|;
comment|/* 	 * All error reporting is done through syslog, unless -d is specified 	 */
name|openlog
argument_list|(
name|name
argument_list|,
name|LOG_PID
operator||
name|LOG_CONS
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"adfst:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'a'
case|:
operator|++
name|aflag
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|dflag
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|++
name|fflag
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|++
name|sflag
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tftp_dir
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
operator|++
name|verbose
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
name|ifname
operator|=
operator|(
name|aflag
operator|==
literal|0
operator|)
condition|?
name|argv
index|[
literal|0
index|]
else|:
name|NULL
expr_stmt|;
name|hostname
operator|=
name|ifname
condition|?
name|argv
index|[
literal|1
index|]
else|:
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|aflag
operator|&&
name|ifname
operator|)
operator|||
operator|(
operator|!
name|aflag
operator|&&
name|ifname
operator|==
name|NULL
operator|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|init
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fflag
condition|)
block|{
if|if
condition|(
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|rarp_loop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add to the interface list.  */
end_comment

begin_function
specifier|static
name|void
name|init_one
parameter_list|(
name|struct
name|ifaddrs
modifier|*
name|ifa
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|int
name|pass1
parameter_list|)
block|{
name|struct
name|if_info
modifier|*
name|ii
decl_stmt|,
modifier|*
name|ii2
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|ll
decl_stmt|;
name|int
name|family
decl_stmt|;
name|family
operator|=
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|pass1
condition|)
comment|/* Consider only AF_LINK during pass1. */
return|return;
comment|/* FALLTHROUGH */
case|case
name|AF_LINK
case|:
if|if
condition|(
operator|!
operator|(
name|ifa
operator|->
name|ifa_flags
operator|&
name|IFF_UP
operator|)
operator|||
operator|(
name|ifa
operator|->
name|ifa_flags
operator|&
operator|(
name|IFF_LOOPBACK
operator||
name|IFF_POINTOPOINT
operator|)
operator|)
condition|)
return|return;
break|break;
default|default:
return|return;
block|}
comment|/* Don't bother going any further if not the target interface */
if|if
condition|(
name|target
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|ifa
operator|->
name|ifa_name
argument_list|,
name|target
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Look for interface in list */
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
operator|!=
name|NULL
condition|;
name|ii
operator|=
name|ii
operator|->
name|ii_next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ifa
operator|->
name|ifa_name
argument_list|,
name|ii
operator|->
name|ii_ifname
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|pass1
operator|&&
name|ii
operator|!=
name|NULL
condition|)
comment|/* We've already seen that interface once. */
return|return;
comment|/* Allocate a new one if not found */
if|if
condition|(
name|ii
operator|==
name|NULL
condition|)
block|{
name|ii
operator|=
operator|(
expr|struct
name|if_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ii
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|==
name|NULL
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|ii
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ii
argument_list|)
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|ii
operator|->
name|ii_ifname
argument_list|,
name|ifa
operator|->
name|ifa_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ii
operator|->
name|ii_ifname
argument_list|)
argument_list|)
expr_stmt|;
name|ii
operator|->
name|ii_next
operator|=
name|iflist
expr_stmt|;
name|iflist
operator|=
name|ii
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pass1
operator|&&
name|ii
operator|->
name|ii_ipaddr
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Second AF_INET definition for that interface: clone 		 * the existing one, and work on that cloned one. 		 * This must be another IP address for this interface, 		 * so avoid killing the previous configuration. 		 */
name|ii2
operator|=
operator|(
expr|struct
name|if_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ii2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii2
operator|==
name|NULL
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|ii2
argument_list|,
name|ii
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ii2
argument_list|)
argument_list|)
expr_stmt|;
name|ii2
operator|->
name|ii_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|ii2
operator|->
name|ii_next
operator|=
name|iflist
expr_stmt|;
name|iflist
operator|=
name|ii2
expr_stmt|;
name|ii
operator|=
name|ii2
expr_stmt|;
block|}
switch|switch
condition|(
name|family
condition|)
block|{
case|case
name|AF_INET
case|:
name|ii
operator|->
name|ii_ipaddr
operator|=
name|SATOSIN
argument_list|(
name|ifa
operator|->
name|ifa_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ii
operator|->
name|ii_netmask
operator|=
name|SATOSIN
argument_list|(
name|ifa
operator|->
name|ifa_netmask
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_netmask
operator|==
literal|0
condition|)
name|ii
operator|->
name|ii_netmask
operator|=
name|ipaddrtonetmask
argument_list|(
name|ii
operator|->
name|ii_ipaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_fd
operator|<
literal|0
condition|)
name|ii
operator|->
name|ii_fd
operator|=
name|rarp_open
argument_list|(
name|ii
operator|->
name|ii_ifname
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_LINK
case|:
name|ll
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|ll
operator|->
name|sdl_type
operator|==
name|IFT_ETHER
condition|)
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|ll
argument_list|)
argument_list|,
name|ii
operator|->
name|ii_eaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize all "candidate" interfaces that are in the system  * configuration list.  A "candidate" is up, not loopback and not  * point to point.  */
end_comment

begin_function
specifier|static
name|void
name|init
parameter_list|(
name|char
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|if_info
modifier|*
name|ii
decl_stmt|,
modifier|*
name|nii
decl_stmt|,
modifier|*
name|lii
decl_stmt|;
name|struct
name|ifaddrs
modifier|*
name|ifhead
decl_stmt|,
modifier|*
name|ifa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|getifaddrs
argument_list|(
operator|&
name|ifhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getifaddrs: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We make two passes over the list we have got.  In the first 	 * one, we only collect AF_LINK interfaces, and initialize our 	 * list of interfaces from them.  In the second pass, we 	 * collect the actual IP addresses from the AF_INET 	 * interfaces, and allow for the same interface name to appear 	 * multiple times (in case of more than one IP address). 	 */
for|for
control|(
name|ifa
operator|=
name|ifhead
init|;
name|ifa
operator|!=
name|NULL
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
name|init_one
argument_list|(
name|ifa
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|ifa
operator|=
name|ifhead
init|;
name|ifa
operator|!=
name|NULL
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
name|init_one
argument_list|(
name|ifa
argument_list|,
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|freeifaddrs
argument_list|(
name|ifhead
argument_list|)
expr_stmt|;
comment|/* Throw away incomplete interfaces */
name|lii
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
operator|!=
name|NULL
condition|;
name|ii
operator|=
name|nii
control|)
block|{
name|nii
operator|=
name|ii
operator|->
name|ii_next
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_ipaddr
operator|==
literal|0
operator|||
name|bcmp
argument_list|(
name|ii
operator|->
name|ii_eaddr
argument_list|,
name|zero
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lii
operator|==
name|NULL
condition|)
name|iflist
operator|=
name|nii
expr_stmt|;
else|else
name|lii
operator|->
name|ii_next
operator|=
name|nii
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|ii
operator|->
name|ii_fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ii
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lii
operator|=
name|ii
expr_stmt|;
block|}
comment|/* Verbose stuff */
if|if
condition|(
name|verbose
condition|)
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
operator|!=
name|NULL
condition|;
name|ii
operator|=
name|ii
operator|->
name|ii_next
control|)
name|logmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s %s 0x%08x %s"
argument_list|,
name|ii
operator|->
name|ii_ifname
argument_list|,
name|intoa
argument_list|(
name|ntohl
argument_list|(
name|ii
operator|->
name|ii_ipaddr
argument_list|)
argument_list|)
argument_list|,
operator|(
name|in_addr_t
operator|)
name|ntohl
argument_list|(
name|ii
operator|->
name|ii_netmask
argument_list|)
argument_list|,
name|eatoa
argument_list|(
name|ii
operator|->
name|ii_eaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n"
argument_list|,
literal|"usage: rarpd -a [-dfsv] [-t directory]"
argument_list|,
literal|"       rarpd [-dfsv] [-t directory] interface"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_open
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
name|device
index|[
sizeof|sizeof
expr|"/dev/bpf000"]
expr_stmt|;
comment|/* 	 * Go through all the minors and find one that isn't in use. 	 */
do|do
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
literal|"/dev/bpf%d"
argument_list|,
name|n
operator|++
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|fd
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EBUSY
operator|)
condition|)
do|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*  * Open a BPF file and attach it to the interface named 'device'.  * Set immediate mode, and set a filter that accepts only RARP requests.  */
end_comment

begin_function
specifier|static
name|int
name|rarp_open
parameter_list|(
name|char
modifier|*
name|device
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|u_int
name|dlt
decl_stmt|;
name|int
name|immediate
decl_stmt|;
specifier|static
name|struct
name|bpf_insn
name|insns
index|[]
init|=
block|{
name|BPF_STMT
argument_list|(
name|BPF_LD
operator||
name|BPF_H
operator||
name|BPF_ABS
argument_list|,
literal|12
argument_list|)
block|,
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator||
name|BPF_JEQ
operator||
name|BPF_K
argument_list|,
name|ETHERTYPE_REVARP
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
block|,
name|BPF_STMT
argument_list|(
name|BPF_LD
operator||
name|BPF_H
operator||
name|BPF_ABS
argument_list|,
literal|20
argument_list|)
block|,
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator||
name|BPF_JEQ
operator||
name|BPF_K
argument_list|,
name|REVARP_REQUEST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|,
name|BPF_STMT
argument_list|(
name|BPF_RET
operator||
name|BPF_K
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_arp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
block|,
name|BPF_STMT
argument_list|(
name|BPF_RET
operator||
name|BPF_K
argument_list|,
literal|0
argument_list|)
block|, 	}
decl_stmt|;
specifier|static
name|struct
name|bpf_program
name|filter
init|=
block|{
sizeof|sizeof
name|insns
operator|/
sizeof|sizeof
argument_list|(
name|insns
index|[
literal|0
index|]
argument_list|)
block|,
name|insns
block|}
decl_stmt|;
name|fd
operator|=
name|bpf_open
argument_list|()
expr_stmt|;
comment|/* 	 * Set immediate mode so packets are processed as they arrive. 	 */
name|immediate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCIMMEDIATE
argument_list|,
operator|&
name|immediate
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCIMMEDIATE: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETIF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCSETIF: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check that the data link layer is an Ethernet; this code won't 	 * work with anything else. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGDLT
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dlt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCGDLT: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dlt
operator|!=
name|DLT_EN10MB
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s is not an ethernet"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set filter program. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|filter
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCSETF: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*  * Perform various sanity checks on the RARP request packet.  Return  * false on failure and log the reason.  */
end_comment

begin_function
specifier|static
name|int
name|rarp_check
parameter_list|(
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|ep
init|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|ether_arp
modifier|*
name|ap
init|=
operator|(
expr|struct
name|ether_arp
operator|*
operator|)
operator|(
name|p
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"truncated request, got %u, expected %lu"
argument_list|,
name|len
argument_list|,
call|(
name|u_long
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * XXX This test might be better off broken out... 	 */
if|if
condition|(
name|ntohs
argument_list|(
name|ep
operator|->
name|ether_type
argument_list|)
operator|!=
name|ETHERTYPE_REVARP
operator|||
name|ntohs
argument_list|(
name|ap
operator|->
name|arp_hrd
argument_list|)
operator|!=
name|ARPHRD_ETHER
operator|||
name|ntohs
argument_list|(
name|ap
operator|->
name|arp_op
argument_list|)
operator|!=
name|REVARP_REQUEST
operator|||
name|ntohs
argument_list|(
name|ap
operator|->
name|arp_pro
argument_list|)
operator|!=
name|ETHERTYPE_IP
operator|||
name|ap
operator|->
name|arp_hln
operator|!=
literal|6
operator|||
name|ap
operator|->
name|arp_pln
operator|!=
literal|4
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"request fails sanity check"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ether/arp sender address mismatch"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_tha
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ether/arp target address mismatch"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Loop indefinitely listening for RARP requests on the  * interfaces in 'iflist'.  */
end_comment

begin_function
specifier|static
name|void
name|rarp_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|fd
decl_stmt|;
name|fd_set
name|fds
decl_stmt|,
name|listeners
decl_stmt|;
name|int
name|bufsize
decl_stmt|,
name|maxfd
init|=
literal|0
decl_stmt|;
name|struct
name|if_info
modifier|*
name|ii
decl_stmt|;
if|if
condition|(
name|iflist
operator|==
name|NULL
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no interfaces"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|iflist
operator|->
name|ii_fd
argument_list|,
name|BIOCGBLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bufsize
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCGBLEN: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* 		 * Find the highest numbered file descriptor for select(). 		 * Initialize the set of descriptors to listen to. 		 */
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
operator|!=
name|NULL
condition|;
name|ii
operator|=
name|ii
operator|->
name|ii_next
control|)
block|{
name|FD_SET
argument_list|(
name|ii
operator|->
name|ii_fd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_fd
operator|>
name|maxfd
condition|)
name|maxfd
operator|=
name|ii
operator|->
name|ii_fd
expr_stmt|;
block|}
name|listeners
operator|=
name|fds
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
operator|&
name|listeners
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Don't choke when we get ptraced */
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
operator|!=
name|NULL
condition|;
name|ii
operator|=
name|ii
operator|->
name|ii_next
control|)
block|{
name|fd
operator|=
name|ii
operator|->
name|ii_fd
expr_stmt|;
if|if
condition|(
operator|!
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|listeners
argument_list|)
condition|)
continue|continue;
name|again
label|:
name|cc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
comment|/* Don't choke when we get ptraced */
if|if
condition|(
operator|(
name|cc
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
goto|goto
name|again
goto|;
comment|/* Loop through the packet(s) */
define|#
directive|define
name|bhp
value|((struct bpf_hdr *)bp)
name|bp
operator|=
name|buf
expr_stmt|;
name|ep
operator|=
name|bp
operator|+
name|cc
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|ep
condition|)
block|{
name|u_int
name|caplen
decl_stmt|,
name|hdrlen
decl_stmt|;
name|caplen
operator|=
name|bhp
operator|->
name|bh_caplen
expr_stmt|;
name|hdrlen
operator|=
name|bhp
operator|->
name|bh_hdrlen
expr_stmt|;
if|if
condition|(
name|rarp_check
argument_list|(
name|bp
operator|+
name|hdrlen
argument_list|,
name|caplen
argument_list|)
condition|)
name|rarp_process
argument_list|(
name|ii
argument_list|,
name|bp
operator|+
name|hdrlen
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|BPF_WORDALIGN
argument_list|(
name|hdrlen
operator|+
name|caplen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|bhp
block|}
end_function

begin_comment
comment|/*  * True if this server can boot the host whose IP address is 'addr'.  * This check is made by looking in the tftp directory for the  * configuration file.  */
end_comment

begin_function
specifier|static
name|int
name|rarp_bootable
parameter_list|(
name|in_addr_t
name|addr
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|dent
decl_stmt|;
name|DIR
modifier|*
name|d
decl_stmt|;
name|char
name|ipname
index|[
literal|9
index|]
decl_stmt|;
specifier|static
name|DIR
modifier|*
name|dd
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ipname
argument_list|,
literal|"%08X"
argument_list|,
operator|(
name|in_addr_t
operator|)
name|ntohl
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If directory is already open, rewind it.  Otherwise, open it. 	 */
if|if
condition|(
operator|(
name|d
operator|=
name|dd
operator|)
operator|!=
name|NULL
condition|)
name|rewinddir
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|chdir
argument_list|(
name|tftp_dir
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chdir: %s: %m"
argument_list|,
name|tftp_dir
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"opendir: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dd
operator|=
name|d
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|dent
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|dent
operator|->
name|d_name
argument_list|,
name|ipname
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Given a list of IP addresses, 'alist', return the first address that  * is on network 'net'; 'netmask' is a mask indicating the network portion  * of the address.  */
end_comment

begin_function
specifier|static
name|in_addr_t
name|choose_ipaddr
parameter_list|(
name|in_addr_t
modifier|*
modifier|*
name|alist
parameter_list|,
name|in_addr_t
name|net
parameter_list|,
name|in_addr_t
name|netmask
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|alist
condition|;
operator|++
name|alist
control|)
if|if
condition|(
operator|(
operator|*
operator|*
name|alist
operator|&
name|netmask
operator|)
operator|==
name|net
condition|)
return|return
operator|*
operator|*
name|alist
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Answer the RARP request in 'pkt', on the interface 'ii'.  'pkt' has  * already been checked for validity.  The reply is overlaid on the request.  */
end_comment

begin_function
specifier|static
name|void
name|rarp_process
parameter_list|(
name|struct
name|if_info
modifier|*
name|ii
parameter_list|,
name|u_char
modifier|*
name|pkt
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|ep
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|in_addr_t
name|target_ipaddr
decl_stmt|;
name|char
name|ename
index|[
literal|256
index|]
decl_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|pkt
expr_stmt|;
comment|/* should this be arp_tha? */
if|if
condition|(
name|ether_ntohost
argument_list|(
name|ename
argument_list|,
operator|(
expr|struct
name|ether_addr
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_shost
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot map %s to name"
argument_list|,
name|eatoa
argument_list|(
name|ep
operator|->
name|ether_shost
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|ename
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot map %s to IP address"
argument_list|,
name|ename
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Choose correct address from list. 	 */
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot handle non IP addresses for %s"
argument_list|,
name|ename
argument_list|)
expr_stmt|;
return|return;
block|}
name|target_ipaddr
operator|=
name|choose_ipaddr
argument_list|(
operator|(
name|in_addr_t
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
argument_list|,
name|ii
operator|->
name|ii_ipaddr
operator|&
name|ii
operator|->
name|ii_netmask
argument_list|,
name|ii
operator|->
name|ii_netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_ipaddr
operator|==
literal|0
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot find %s on net %s"
argument_list|,
name|ename
argument_list|,
name|intoa
argument_list|(
name|ntohl
argument_list|(
name|ii
operator|->
name|ii_ipaddr
operator|&
name|ii
operator|->
name|ii_netmask
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sflag
operator|||
name|rarp_bootable
argument_list|(
name|target_ipaddr
argument_list|)
condition|)
name|rarp_reply
argument_list|(
name|ii
argument_list|,
name|ep
argument_list|,
name|target_ipaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
name|logmsg
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s %s at %s DENIED (not bootable)"
argument_list|,
name|ii
operator|->
name|ii_ifname
argument_list|,
name|eatoa
argument_list|(
name|ep
operator|->
name|ether_shost
argument_list|)
argument_list|,
name|intoa
argument_list|(
name|ntohl
argument_list|(
name|target_ipaddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Poke the kernel arp tables with the ethernet/ip address combinataion  * given.  When processing a reply, we must do this so that the booting  * host (i.e. the guy running rarpd), won't try to ARP for the hardware  * address of the guy being booted (he cannot answer the ARP).  */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_inarp
name|sin_inarp
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_inarp
argument_list|)
block|,
name|AF_INET
block|,
literal|0
block|,
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_dl
name|sin_dl
init|=
block|{
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_dl
argument_list|)
block|,
name|AF_LINK
block|,
literal|0
block|,
name|IFT_ETHER
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|,
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|struct
name|rt_msghdr
name|rthdr
decl_stmt|;
name|char
name|rtspace
index|[
literal|512
index|]
decl_stmt|;
block|}
name|rtmsg
struct|;
end_struct

begin_function
specifier|static
name|void
name|update_arptab
parameter_list|(
name|u_char
modifier|*
name|ep
parameter_list|,
name|in_addr_t
name|ipaddr
parameter_list|)
block|{
name|struct
name|timespec
name|tp
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|struct
name|sockaddr_inarp
modifier|*
name|ar
decl_stmt|,
modifier|*
name|ar2
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|ll
decl_stmt|,
modifier|*
name|ll2
decl_stmt|;
name|struct
name|rt_msghdr
modifier|*
name|rt
decl_stmt|;
name|int
name|xtype
decl_stmt|,
name|xindex
decl_stmt|;
specifier|static
name|pid_t
name|pid
decl_stmt|;
name|int
name|r
decl_stmt|;
specifier|static
name|int
name|seq
decl_stmt|;
name|r
operator|=
name|socket
argument_list|(
name|PF_ROUTE
argument_list|,
name|SOCK_RAW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"raw route socket: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|ar
operator|=
operator|&
name|sin_inarp
expr_stmt|;
name|ar
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|ipaddr
expr_stmt|;
name|ll
operator|=
operator|&
name|sin_dl
expr_stmt|;
name|bcopy
argument_list|(
name|ep
argument_list|,
name|LLADDR
argument_list|(
name|ll
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* Get the type and interface index */
name|rt
operator|=
operator|&
name|rtmsg
operator|.
name|rthdr
expr_stmt|;
name|bzero
argument_list|(
name|rt
argument_list|,
sizeof|sizeof
argument_list|(
name|rtmsg
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rtm_version
operator|=
name|RTM_VERSION
expr_stmt|;
name|rt
operator|->
name|rtm_addrs
operator|=
name|RTA_DST
expr_stmt|;
name|rt
operator|->
name|rtm_type
operator|=
name|RTM_GET
expr_stmt|;
name|rt
operator|->
name|rtm_seq
operator|=
operator|++
name|seq
expr_stmt|;
name|ar2
operator|=
operator|(
expr|struct
name|sockaddr_inarp
operator|*
operator|)
name|rtmsg
operator|.
name|rtspace
expr_stmt|;
name|bcopy
argument_list|(
name|ar
argument_list|,
name|ar2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rtm_msglen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|write
argument_list|(
name|r
argument_list|,
name|rt
argument_list|,
name|rt
operator|->
name|rtm_msglen
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|ESRCH
operator|)
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rtmsg get write: %m"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|cc
operator|=
name|read
argument_list|(
name|r
argument_list|,
name|rt
argument_list|,
sizeof|sizeof
argument_list|(
name|rtmsg
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cc
operator|>
literal|0
operator|&&
operator|(
name|rt
operator|->
name|rtm_seq
operator|!=
name|seq
operator|||
name|rt
operator|->
name|rtm_pid
operator|!=
name|pid
operator|)
condition|)
do|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rtmsg get read: %m"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
name|ll2
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ar2
operator|+
name|ar2
operator|->
name|sin_len
operator|)
expr_stmt|;
if|if
condition|(
name|ll2
operator|->
name|sdl_family
operator|!=
name|AF_LINK
condition|)
block|{
comment|/* 		 * XXX I think this means the ip address is not on a 		 * directly connected network (the family is AF_INET in 		 * this case). 		 */
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bogus link family (%d) wrong net for %08X?\n"
argument_list|,
name|ll2
operator|->
name|sdl_family
argument_list|,
name|ipaddr
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
name|xtype
operator|=
name|ll2
operator|->
name|sdl_type
expr_stmt|;
name|xindex
operator|=
name|ll2
operator|->
name|sdl_index
expr_stmt|;
comment|/* Set the new arp entry */
name|bzero
argument_list|(
name|rt
argument_list|,
sizeof|sizeof
argument_list|(
name|rtmsg
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rtm_version
operator|=
name|RTM_VERSION
expr_stmt|;
name|rt
operator|->
name|rtm_addrs
operator|=
name|RTA_DST
operator||
name|RTA_GATEWAY
expr_stmt|;
name|rt
operator|->
name|rtm_inits
operator|=
name|RTV_EXPIRE
expr_stmt|;
name|clock_gettime
argument_list|(
name|CLOCK_MONOTONIC
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rtm_rmx
operator|.
name|rmx_expire
operator|=
name|tp
operator|.
name|tv_sec
operator|+
name|ARPSECS
expr_stmt|;
name|rt
operator|->
name|rtm_flags
operator|=
name|RTF_HOST
operator||
name|RTF_STATIC
expr_stmt|;
name|rt
operator|->
name|rtm_type
operator|=
name|RTM_ADD
expr_stmt|;
name|rt
operator|->
name|rtm_seq
operator|=
operator|++
name|seq
expr_stmt|;
name|bcopy
argument_list|(
name|ar
argument_list|,
name|ar2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ar
argument_list|)
argument_list|)
expr_stmt|;
name|ll2
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ar2
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ar2
argument_list|)
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|ll
argument_list|,
name|ll2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ll
argument_list|)
argument_list|)
expr_stmt|;
name|ll2
operator|->
name|sdl_type
operator|=
name|xtype
expr_stmt|;
name|ll2
operator|->
name|sdl_index
operator|=
name|xindex
expr_stmt|;
name|rt
operator|->
name|rtm_msglen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ar2
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ll2
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|write
argument_list|(
name|r
argument_list|,
name|rt
argument_list|,
name|rt
operator|->
name|rtm_msglen
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EEXIST
operator|)
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rtmsg add write: %m"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|cc
operator|=
name|read
argument_list|(
name|r
argument_list|,
name|rt
argument_list|,
sizeof|sizeof
argument_list|(
name|rtmsg
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|cc
operator|>
literal|0
operator|&&
operator|(
name|rt
operator|->
name|rtm_seq
operator|!=
name|seq
operator|||
name|rt
operator|->
name|rtm_pid
operator|!=
name|pid
operator|)
condition|)
do|;
name|close
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
operator|-
literal|1
condition|)
block|{
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rtmsg add read: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Build a reverse ARP packet and sent it out on the interface.  * 'ep' points to a valid REVARP_REQUEST.  The REVARP_REPLY is built  * on top of the request, then written to the network.  *  * RFC 903 defines the ether_arp fields as follows.  The following comments  * are taken (more or less) straight from this document.  *  * REVARP_REQUEST  *  * arp_sha is the hardware address of the sender of the packet.  * arp_spa is undefined.  * arp_tha is the 'target' hardware address.  *   In the case where the sender wishes to determine his own  *   protocol address, this, like arp_sha, will be the hardware  *   address of the sender.  * arp_tpa is undefined.  *  * REVARP_REPLY  *  * arp_sha is the hardware address of the responder (the sender of the  *   reply packet).  * arp_spa is the protocol address of the responder (see the note below).  * arp_tha is the hardware address of the target, and should be the same as  *   that which was given in the request.  * arp_tpa is the protocol address of the target, that is, the desired address.  *  * Note that the requirement that arp_spa be filled in with the responder's  * protocol is purely for convenience.  For instance, if a system were to use  * both ARP and RARP, then the inclusion of the valid protocol-hardware  * address pair (arp_spa, arp_sha) may eliminate the need for a subsequent  * ARP request.  */
end_comment

begin_function
specifier|static
name|void
name|rarp_reply
parameter_list|(
name|struct
name|if_info
modifier|*
name|ii
parameter_list|,
name|struct
name|ether_header
modifier|*
name|ep
parameter_list|,
name|in_addr_t
name|ipaddr
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|u_int
name|n
decl_stmt|;
name|struct
name|ether_arp
modifier|*
name|ap
init|=
operator|(
expr|struct
name|ether_arp
operator|*
operator|)
operator|(
name|ep
operator|+
literal|1
operator|)
decl_stmt|;
name|update_arptab
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
name|ipaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Build the rarp reply by modifying the rarp request in place. 	 */
name|ap
operator|->
name|arp_op
operator|=
name|htons
argument_list|(
name|REVARP_REPLY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_BPF
name|ep
operator|->
name|ether_type
operator|=
name|ETHERTYPE_REVARP
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_dhost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ii
operator|->
name|ii_eaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_shost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ii
operator|->
name|ii_eaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ipaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|arp_tpa
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Target hardware is unchanged. */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ii
operator|->
name|ii_ipaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|arp_spa
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Zero possible garbage after packet. */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
operator|)
argument_list|,
name|len
operator|-
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|write
argument_list|(
name|ii
operator|->
name|ii_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ep
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|len
condition|)
name|logmsg
argument_list|(
name|LOG_ERR
argument_list|,
literal|"write: only %d of %d bytes written"
argument_list|,
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|logmsg
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s %s at %s REPLIED"
argument_list|,
name|ii
operator|->
name|ii_ifname
argument_list|,
name|eatoa
argument_list|(
name|ap
operator|->
name|arp_tha
argument_list|)
argument_list|,
name|intoa
argument_list|(
name|ntohl
argument_list|(
name|ipaddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the netmask of an IP address.  This routine is used if  * SIOCGIFNETMASK doesn't work.  */
end_comment

begin_function
specifier|static
name|in_addr_t
name|ipaddrtonetmask
parameter_list|(
name|in_addr_t
name|addr
parameter_list|)
block|{
name|addr
operator|=
name|ntohl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|htonl
argument_list|(
name|IN_CLASSA_NET
argument_list|)
return|;
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|htonl
argument_list|(
name|IN_CLASSB_NET
argument_list|)
return|;
if|if
condition|(
name|IN_CLASSC
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|htonl
argument_list|(
name|IN_CLASSC_NET
argument_list|)
return|;
name|logmsg
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unknown IP address class: %08X"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|htonl
argument_list|(
literal|0xffffffff
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * A faster replacement for inet_ntoa().  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|intoa
parameter_list|(
name|in_addr_t
name|addr
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|u_int
name|byte
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|static
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
literal|".xxx.xxx.xxx.xxx"
argument_list|)
index|]
decl_stmt|;
name|cp
operator|=
operator|&
name|buf
index|[
sizeof|sizeof
name|buf
index|]
expr_stmt|;
operator|*
operator|--
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
literal|4
expr_stmt|;
do|do
block|{
name|byte
operator|=
name|addr
operator|&
literal|0xff
expr_stmt|;
operator|*
operator|--
name|cp
operator|=
name|byte
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|byte
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|byte
operator|>
literal|0
condition|)
block|{
operator|*
operator|--
name|cp
operator|=
name|byte
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
name|byte
operator|/=
literal|10
expr_stmt|;
if|if
condition|(
name|byte
operator|>
literal|0
condition|)
operator|*
operator|--
name|cp
operator|=
name|byte
operator|+
literal|'0'
expr_stmt|;
block|}
operator|*
operator|--
name|cp
operator|=
literal|'.'
expr_stmt|;
name|addr
operator|>>=
literal|8
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
operator|>
literal|0
condition|)
do|;
return|return
name|cp
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|eatoa
parameter_list|(
name|u_char
modifier|*
name|ea
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
literal|"xx:xx:xx:xx:xx:xx"
argument_list|)
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%x:%x:%x:%x:%x:%x"
argument_list|,
name|ea
index|[
literal|0
index|]
argument_list|,
name|ea
index|[
literal|1
index|]
argument_list|,
name|ea
index|[
literal|2
index|]
argument_list|,
name|ea
index|[
literal|3
index|]
argument_list|,
name|ea
index|[
literal|4
index|]
argument_list|,
name|ea
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|logmsg
parameter_list|(
name|int
name|pri
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|v
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|newfmt
decl_stmt|;
name|va_start
argument_list|(
name|v
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dflag
condition|)
block|{
if|if
condition|(
name|pri
operator|==
name|LOG_ERR
condition|)
name|fp
operator|=
name|stderr
expr_stmt|;
else|else
name|fp
operator|=
name|stdout
expr_stmt|;
if|if
condition|(
name|expand_syslog_m
argument_list|(
name|fmt
argument_list|,
operator|&
name|newfmt
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|vfprintf
argument_list|(
name|fp
argument_list|,
name|fmt
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vfprintf
argument_list|(
name|fp
argument_list|,
name|newfmt
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newfmt
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vsyslog
argument_list|(
name|pri
argument_list|,
name|fmt
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|expand_syslog_m
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|char
modifier|*
modifier|*
name|newfmt
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|p
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|str
operator|=
name|fmt
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|strstr
argument_list|(
name|str
argument_list|,
literal|"%m"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|np
argument_list|,
literal|"%s%.*s%s"
argument_list|,
name|p
argument_list|,
call|(
name|int
call|)
argument_list|(
name|m
operator|-
name|str
argument_list|)
argument_list|,
name|str
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|np
expr_stmt|;
name|str
operator|=
name|m
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\0'
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|np
argument_list|,
literal|"%s%s"
argument_list|,
name|p
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|p
operator|=
name|np
expr_stmt|;
block|}
operator|*
name|newfmt
operator|=
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

