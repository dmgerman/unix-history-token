begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that: (1) source code distributions  * retain the above copyright notice and this paragraph in its entirety, (2)  * distributions including binary code include the above copyright notice and  * this paragraph in its entirety in the documentation or other materials  * provided with the distribution, and (3) all advertising materials mentioning  * features or use of this software display the following acknowledgement:  * ``This product includes software developed by the University of California,  * Lawrence Berkeley Laboratory and its contributors.'' Neither the name of  * the University nor the names of its contributors may be used to endorse  * or promote products derived from this software without specific prior  * written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1990 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"@(#) $FreeBSD$ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * rarpd - Reverse ARP Daemon  *  * Usage:	rarpd -a [ -f ] [ hostname ]  *		rarpd [ -f ] interface [ hostname ]  *  * 'hostname' is optional solely for backwards compatibility with Sun's rarpd.  * Currently, the argument is ignored.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* SunOS 4.x defines this while 3.x does not. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__sys_types_h
end_ifdef

begin_define
define|#
directive|define
name|SUNOS4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SUNOS4
end_ifdef

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Map field names in ether_arp struct.  What a pain in the neck.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SUNOS4
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|arp_sha
end_undef

begin_undef
undef|#
directive|undef
name|arp_spa
end_undef

begin_undef
undef|#
directive|undef
name|arp_tha
end_undef

begin_undef
undef|#
directive|undef
name|arp_tpa
end_undef

begin_define
define|#
directive|define
name|arp_sha
value|arp_xsha
end_define

begin_define
define|#
directive|define
name|arp_spa
value|arp_xspa
end_define

begin_define
define|#
directive|define
name|arp_tha
value|arp_xtha
end_define

begin_define
define|#
directive|define
name|arp_tpa
value|arp_xtpa
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
define|#
directive|define
name|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ether_ntohost
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|ether_addr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The structure for each interface.  */
end_comment

begin_struct
struct|struct
name|if_info
block|{
name|int
name|ii_fd
decl_stmt|;
comment|/* BPF file descriptor */
name|u_char
name|ii_eaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* Ethernet address of this interface */
name|u_long
name|ii_ipaddr
decl_stmt|;
comment|/* IP address of this interface */
name|u_long
name|ii_netmask
decl_stmt|;
comment|/* subnet or net mask */
name|struct
name|if_info
modifier|*
name|ii_next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The list of all interfaces that are being listened to.  rarp_loop()  * "selects" on the descriptors in this list.  */
end_comment

begin_decl_stmt
name|struct
name|if_info
modifier|*
name|iflist
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|exit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|u_long
name|ipaddrtonetmask
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|init_one
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|init_all
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rarp_loop
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lookup_eaddr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|lookup_ipaddr
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|op
decl_stmt|,
name|pid
decl_stmt|;
name|char
modifier|*
name|ifname
decl_stmt|,
modifier|*
name|hostname
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|int
name|aflag
init|=
literal|0
decl_stmt|;
comment|/* listen on "all" interfaces  */
name|int
name|fflag
init|=
literal|0
decl_stmt|;
comment|/* don't fork */
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|,
name|opterr
decl_stmt|;
if|if
condition|(
name|name
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
condition|)
operator|++
name|name
expr_stmt|;
else|else
name|name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'-'
condition|)
operator|++
name|name
expr_stmt|;
comment|/* 	 * All error reporting is done through syslogs. 	 */
name|openlog
argument_list|(
name|name
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
name|opterr
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|op
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"af"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|'a'
case|:
operator|++
name|aflag
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|++
name|fflag
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|ifname
operator|=
name|argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
name|hostname
operator|=
name|ifname
condition|?
name|argv
index|[
name|optind
index|]
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|aflag
operator|&&
name|ifname
operator|)
operator|||
operator|(
operator|!
name|aflag
operator|&&
name|ifname
operator|==
literal|0
operator|)
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|aflag
condition|)
name|init_all
argument_list|()
expr_stmt|;
else|else
name|init_one
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fflag
condition|)
if|if
condition|(
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|rarp_loop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add 'ifname' to the interface list.  Lookup its IP address and network  * mask and Ethernet address, and open a BPF file for it.  */
end_comment

begin_function
name|void
name|init_one
parameter_list|(
name|ifname
parameter_list|)
name|char
modifier|*
name|ifname
decl_stmt|;
block|{
name|struct
name|if_info
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|if_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|ii_next
operator|=
name|iflist
expr_stmt|;
name|iflist
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|ii_fd
operator|=
name|rarp_open
argument_list|(
name|ifname
argument_list|)
expr_stmt|;
name|lookup_eaddr
argument_list|(
name|p
operator|->
name|ii_fd
argument_list|,
name|p
operator|->
name|ii_eaddr
argument_list|)
expr_stmt|;
name|lookup_ipaddr
argument_list|(
name|ifname
argument_list|,
operator|&
name|p
operator|->
name|ii_ipaddr
argument_list|,
operator|&
name|p
operator|->
name|ii_netmask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize all "candidate" interfaces that are in the system  * configuration list.  A "candidate" is up, not loopback and not  * point to point.  */
end_comment

begin_function
name|void
name|init_all
parameter_list|()
block|{
name|int
name|fd
decl_stmt|;
name|int
name|ifflags
decl_stmt|;
name|struct
name|ifreq
name|ibuf
index|[
literal|8
index|]
decl_stmt|,
name|tmp_ibuf
decl_stmt|,
modifier|*
name|ifptr
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
name|ibuf
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
operator|(
name|caddr_t
operator|)
name|ibuf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
operator|||
name|ifc
operator|.
name|ifc_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIOCGIFCONF: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ifptr
operator|=
name|ifc
operator|.
name|ifc_req
expr_stmt|;
name|ifflags
operator|=
name|ifptr
operator|->
name|ifr_flags
expr_stmt|;
name|n
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
name|ifc
operator|.
name|ifc_buf
operator|+
name|ifc
operator|.
name|ifc_len
operator|)
expr_stmt|;
while|while
condition|(
name|ifptr
operator|<
name|n
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ifptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp_ibuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFFLAGS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp_ibuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIOCGIFFLAGS: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifptr
operator|->
name|ifr_flags
operator|==
name|ifflags
operator|&&
operator|(
name|tmp_ibuf
operator|.
name|ifr_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_LOOPBACK
operator||
name|IFF_POINTOPOINT
operator|)
operator|)
operator|==
name|IFF_UP
condition|)
name|init_one
argument_list|(
name|ifptr
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifptr
operator|->
name|ifr_addr
operator|.
name|sa_len
condition|)
comment|/* Dohw! */
name|ifptr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ifptr
operator|+
name|ifptr
operator|->
name|ifr_addr
operator|.
name|sa_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
operator|)
expr_stmt|;
name|ifptr
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: rarpd [ -af ] [ interface ]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|int
name|bpf_open
parameter_list|()
block|{
name|int
name|fd
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|char
name|device
index|[
sizeof|sizeof
expr|"/dev/bpf000"]
expr_stmt|;
comment|/* 	 * Go through all the minors and find one that isn't in use. 	 */
do|do
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|device
argument_list|,
literal|"/dev/bpf%d"
argument_list|,
name|n
operator|++
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|device
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|fd
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EBUSY
condition|)
do|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*  * Open a BPF file and attach it to the interface named 'device'.  * Set immediate mode, and set a filter that accepts only RARP requests.  */
end_comment

begin_function
name|int
name|rarp_open
parameter_list|(
name|device
parameter_list|)
name|char
modifier|*
name|device
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|immediate
decl_stmt|,
name|link_type
decl_stmt|;
specifier|static
name|struct
name|bpf_insn
name|insns
index|[]
init|=
block|{
name|BPF_STMT
argument_list|(
name|BPF_LD
operator|+
name|BPF_H
operator|+
name|BPF_ABS
argument_list|,
literal|12
argument_list|)
block|,
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JEQ
operator|+
name|BPF_K
argument_list|,
name|ETHERTYPE_REVARP
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
block|,
name|BPF_STMT
argument_list|(
name|BPF_LD
operator|+
name|BPF_H
operator|+
name|BPF_ABS
argument_list|,
literal|20
argument_list|)
block|,
name|BPF_JUMP
argument_list|(
name|BPF_JMP
operator|+
name|BPF_JEQ
operator|+
name|BPF_K
argument_list|,
name|ARPOP_REVREQUEST
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
block|,
name|BPF_STMT
argument_list|(
name|BPF_RET
operator|+
name|BPF_K
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_arp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
block|,
name|BPF_STMT
argument_list|(
name|BPF_RET
operator|+
name|BPF_K
argument_list|,
literal|0
argument_list|)
block|,         }
decl_stmt|;
specifier|static
name|struct
name|bpf_program
name|filter
init|=
block|{
sizeof|sizeof
name|insns
operator|/
sizeof|sizeof
argument_list|(
name|insns
index|[
literal|0
index|]
argument_list|)
block|,
operator|(
expr|struct
name|bpf_insn
operator|*
operator|)
operator|&
name|insns
block|}
decl_stmt|;
name|fd
operator|=
name|bpf_open
argument_list|()
expr_stmt|;
comment|/* 	 * Set immediate mode so packets are processed as they arrive. 	 */
name|immediate
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCIMMEDIATE
argument_list|,
operator|&
name|immediate
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCIMMEDIATE: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|device
argument_list|,
sizeof|sizeof
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETIF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCSETIF: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check that the data link layer is an Ethernet; this code won't 	 * work with anything else. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCGDLT
argument_list|,
operator|&
name|link_type
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCGDLP: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|link_type
operator|!=
name|DLT_EN10MB
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s not on ethernet"
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set filter program. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|BIOCSETF
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|filter
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCSETF: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/*  * Perform various sanity checks on the RARP request packet.  Return  * false on failure and log the reason.  */
end_comment

begin_function
specifier|static
name|int
name|rarp_check
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|ether_header
modifier|*
name|ep
init|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|ether_arp
modifier|*
name|ap
init|=
operator|(
expr|struct
name|ether_arp
operator|*
operator|)
operator|(
name|p
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"truncated request"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * XXX This test might be better off broken out... 	 */
if|if
condition|(
name|ep
operator|->
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_REVARP
argument_list|)
operator|||
name|ap
operator|->
name|arp_hrd
operator|!=
name|htons
argument_list|(
name|ARPHRD_ETHER
argument_list|)
operator|||
name|ap
operator|->
name|arp_op
operator|!=
name|htons
argument_list|(
name|ARPOP_REVREQUEST
argument_list|)
operator|||
name|ap
operator|->
name|arp_pro
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
operator|||
name|ap
operator|->
name|arp_hln
operator|!=
literal|6
operator|||
name|ap
operator|->
name|arp_pln
operator|!=
literal|4
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"request fails sanity check"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ether/arp sender address mismatch"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_tha
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ether/arp target address mismatch"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FD_SETSIZE
end_ifndef

begin_define
define|#
directive|define
name|FD_SET
parameter_list|(
name|n
parameter_list|,
name|fdp
parameter_list|)
value|((fdp)->fds_bits[0] |= (1<< (n)))
end_define

begin_define
define|#
directive|define
name|FD_ISSET
parameter_list|(
name|n
parameter_list|,
name|fdp
parameter_list|)
value|((fdp)->fds_bits[0]& (1<< (n)))
end_define

begin_define
define|#
directive|define
name|FD_ZERO
parameter_list|(
name|fdp
parameter_list|)
value|((fdp)->fds_bits[0] = 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Loop indefinitely listening for RARP requests on the  * interfaces in 'iflist'.  */
end_comment

begin_function
name|void
name|rarp_loop
parameter_list|()
block|{
name|struct
name|bpf_hdr
modifier|*
name|bhp
decl_stmt|;
name|u_char
modifier|*
name|pkt
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|fd
decl_stmt|;
name|fd_set
name|fds
decl_stmt|,
name|listeners
decl_stmt|;
name|int
name|bufsize
decl_stmt|,
name|maxfd
init|=
literal|0
decl_stmt|;
name|struct
name|if_info
modifier|*
name|ii
decl_stmt|;
if|if
condition|(
name|iflist
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"no interfaces"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|iflist
operator|->
name|ii_fd
argument_list|,
name|BIOCGBLEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"BIOCGBLEN: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bhp
operator|=
operator|(
expr|struct
name|bpf_hdr
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|bufsize
argument_list|)
expr_stmt|;
comment|/* 	 * Find the highest numbered file descriptor for select(). 	 * Initialize the set of descriptors to listen to. 	 */
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
condition|;
name|ii
operator|=
name|ii
operator|->
name|ii_next
control|)
block|{
name|FD_SET
argument_list|(
name|ii
operator|->
name|ii_fd
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|ii
operator|->
name|ii_fd
operator|>
name|maxfd
condition|)
name|maxfd
operator|=
name|ii
operator|->
name|ii_fd
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|listeners
operator|=
name|fds
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|maxfd
operator|+
literal|1
argument_list|,
operator|&
name|listeners
argument_list|,
operator|(
expr|struct
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"select: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ii
operator|=
name|iflist
init|;
name|ii
condition|;
name|ii
operator|=
name|ii
operator|->
name|ii_next
control|)
block|{
name|fd
operator|=
name|ii
operator|->
name|ii_fd
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fd
argument_list|,
operator|&
name|listeners
argument_list|)
condition|)
block|{
name|again
label|:
name|cc
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bhp
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
comment|/* 				 * Due to a SunOS bug, after 2^31 bytes, the 				 * file offset overflows and read fails with 				 * EINVAL.  The lseek() to 0 will fix things. 				 */
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINVAL
operator|&&
call|(
name|long
call|)
argument_list|(
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
name|SEEK_CUR
argument_list|)
operator|+
name|bufsize
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"read: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pkt
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bhp
operator|+
name|bhp
operator|->
name|bh_hdrlen
expr_stmt|;
if|if
condition|(
name|rarp_check
argument_list|(
name|pkt
argument_list|,
operator|(
name|int
operator|)
name|bhp
operator|->
name|bh_datalen
argument_list|)
condition|)
name|rarp_process
argument_list|(
name|ii
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TFTP_DIR
end_ifndef

begin_define
define|#
directive|define
name|TFTP_DIR
value|"/tftpboot"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * True if this server can boot the host whose IP address is 'addr'.  * This check is made by looking in the tftp directory for the  * configuration file.  */
end_comment

begin_macro
name|rarp_bootable
argument_list|(
argument|addr
argument_list|)
end_macro

begin_decl_stmt
name|u_long
name|addr
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|SUNOS4
specifier|register
name|struct
name|dirent
modifier|*
name|dent
decl_stmt|;
else|#
directive|else
specifier|register
name|struct
name|direct
modifier|*
name|dent
decl_stmt|;
endif|#
directive|endif
specifier|register
name|DIR
modifier|*
name|d
decl_stmt|;
name|char
name|ipname
index|[
literal|9
index|]
decl_stmt|;
specifier|static
name|DIR
modifier|*
name|dd
init|=
literal|0
decl_stmt|;
comment|/* 	 * XXX   Need to htonl() the IP address or it'll 	 * come out backwards. 	 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ipname
argument_list|,
literal|"%08X"
argument_list|,
name|htonl
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If directory is already open, rewind it.  Otherwise, open it. 	 */
if|if
condition|(
name|d
operator|=
name|dd
condition|)
name|rewinddir
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|chdir
argument_list|(
name|TFTP_DIR
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"chdir: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|d
operator|=
name|opendir
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"opendir: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dd
operator|=
name|d
expr_stmt|;
block|}
while|while
condition|(
name|dent
operator|=
name|readdir
argument_list|(
name|d
argument_list|)
condition|)
if|if
condition|(
name|strncmp
argument_list|(
name|dent
operator|->
name|d_name
argument_list|,
name|ipname
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Given a list of IP addresses, 'alist', return the first address that  * is on network 'net'; 'netmask' is a mask indicating the network portion  * of the address.  */
end_comment

begin_function
name|u_long
name|choose_ipaddr
parameter_list|(
name|alist
parameter_list|,
name|net
parameter_list|,
name|netmask
parameter_list|)
name|u_long
modifier|*
modifier|*
name|alist
decl_stmt|;
name|u_long
name|net
decl_stmt|;
name|u_long
name|netmask
decl_stmt|;
block|{
for|for
control|(
init|;
operator|*
name|alist
condition|;
operator|++
name|alist
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|*
name|alist
operator|&
name|netmask
operator|)
operator|==
name|net
condition|)
return|return
operator|*
operator|*
name|alist
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * A one entry ip/ethernet address cache.  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|cache_ipaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|cache_eaddr
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Answer the RARP request in 'pkt', on the interface 'ii'.  'pkt' has  * already been checked for validity.  The reply is overlaid on the request.  */
end_comment

begin_macro
name|rarp_process
argument_list|(
argument|ii
argument_list|,
argument|pkt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|if_info
modifier|*
name|ii
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|pkt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ether_header
modifier|*
name|ep
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|u_long
name|target_ipaddr
decl_stmt|;
name|char
name|ename
index|[
literal|256
index|]
decl_stmt|;
name|ep
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|pkt
expr_stmt|;
comment|/* 	 * If the address in the one element cache, don't bother 	 * looking up names. 	 */
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cache_eaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_shost
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|target_ipaddr
operator|=
name|cache_ipaddr
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ether_ntohost
argument_list|(
name|ename
argument_list|,
operator|(
expr|struct
name|ether_addr
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_shost
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|ename
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 		 * Choose correct address from list. 		 */
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|!=
name|AF_INET
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot handle non IP addresses"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|target_ipaddr
operator|=
name|choose_ipaddr
argument_list|(
operator|(
name|u_long
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
argument_list|,
name|ii
operator|->
name|ii_ipaddr
operator|&
name|ii
operator|->
name|ii_netmask
argument_list|,
name|ii
operator|->
name|ii_netmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_ipaddr
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cannot find %s on %08x"
argument_list|,
name|ename
argument_list|,
name|ii
operator|->
name|ii_ipaddr
operator|&
name|ii
operator|->
name|ii_netmask
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cache_eaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cache_ipaddr
operator|=
name|target_ipaddr
expr_stmt|;
block|}
if|if
condition|(
name|rarp_bootable
argument_list|(
name|target_ipaddr
argument_list|)
condition|)
name|rarp_reply
argument_list|(
name|ii
argument_list|,
name|ep
argument_list|,
name|target_ipaddr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Lookup the ethernet address of the interface attached to the BPF  * file descriptor 'fd'; return it in 'eaddr'.  */
end_comment

begin_function
name|void
name|lookup_eaddr
parameter_list|(
name|fd
parameter_list|,
name|eaddr
parameter_list|)
name|int
name|fd
decl_stmt|;
name|u_char
modifier|*
name|eaddr
decl_stmt|;
block|{
name|struct
name|ifreq
name|ifr
decl_stmt|;
comment|/* Use BPF descriptor to get ethernet address. */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIOCGIFADDR: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
operator|.
name|ifr_addr
operator|.
name|sa_data
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|eaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup the IP address and network mask of the interface named 'ifname'.  */
end_comment

begin_function
name|void
name|lookup_ipaddr
parameter_list|(
name|ifname
parameter_list|,
name|addrp
parameter_list|,
name|netmaskp
parameter_list|)
name|char
modifier|*
name|ifname
decl_stmt|;
name|u_long
modifier|*
name|addrp
decl_stmt|;
name|u_long
modifier|*
name|netmaskp
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
comment|/* Use data gram socket to get IP address. */
if|if
condition|(
operator|(
name|fd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ifr
operator|.
name|ifr_name
argument_list|,
name|ifname
argument_list|,
sizeof|sizeof
name|ifr
operator|.
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIOCGIFADDR: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|addrp
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifr
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFNETMASK
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"SIOCGIFNETMASK"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|netmaskp
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifr
operator|.
name|ifr_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* 	 * If SIOCGIFNETMASK didn't work, figure out a mask from 	 * the IP address class. 	 */
if|if
condition|(
operator|*
name|netmaskp
operator|==
literal|0
condition|)
operator|*
name|netmaskp
operator|=
name|ipaddrtonetmask
argument_list|(
operator|*
name|addrp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Poke the kernel arp tables with the ethernet/ip address combinataion  * given.  When processing a reply, we must do this so that the booting  * host (i.e. the guy running rarpd), won't try to ARP for the hardware  * address of the guy being booted (he cannot answer the ARP).  */
end_comment

begin_macro
name|update_arptab
argument_list|(
argument|ep
argument_list|,
argument|ipaddr
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|ep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|ipaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|SIOCSARP
name|int
name|s
decl_stmt|;
name|struct
name|arpreq
name|request
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|request
operator|.
name|arp_flags
operator|=
literal|0
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|request
operator|.
name|arp_pa
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|ipaddr
expr_stmt|;
name|request
operator|.
name|arp_ha
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
argument_list|,
operator|(
name|char
operator|*
operator|)
name|request
operator|.
name|arp_ha
operator|.
name|sa_data
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCSARP
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|request
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"SIOCSARP: %m"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|arptab_set
argument_list|(
name|ep
argument_list|,
name|ipaddr
argument_list|)
operator|>
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't update arp table"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * Build a reverse ARP packet and sent it out on the interface.  * 'ep' points to a valid ARPOP_REVREQUEST.  The ARPOP_REVREPLY is built  * on top of the request, then written to the network.  *  * RFC 903 defines the ether_arp fields as follows.  The following comments  * are taken (more or less) straight from this document.  *  * ARPOP_REVREQUEST  *  * arp_sha is the hardware address of the sender of the packet.  * arp_spa is undefined.  * arp_tha is the 'target' hardware address.  *   In the case where the sender wishes to determine his own  *   protocol address, this, like arp_sha, will be the hardware  *   address of the sender.  * arp_tpa is undefined.  *  * ARPOP_REVREPLY  *  * arp_sha is the hardware address of the responder (the sender of the  *   reply packet).  * arp_spa is the protocol address of the responder (see the note below).  * arp_tha is the hardware address of the target, and should be the same as  *   that which was given in the request.  * arp_tpa is the protocol address of the target, that is, the desired address.  *  * Note that the requirement that arp_spa be filled in with the responder's  * protocol is purely for convenience.  For instance, if a system were to use  * both ARP and RARP, then the inclusion of the valid protocol-hardware  * address pair (arp_spa, arp_sha) may eliminate the need for a subsequent  * ARP request.  */
end_comment

begin_macro
name|rarp_reply
argument_list|(
argument|ii
argument_list|,
argument|ep
argument_list|,
argument|ipaddr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|if_info
modifier|*
name|ii
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ether_header
modifier|*
name|ep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|ipaddr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|struct
name|ether_arp
modifier|*
name|ap
init|=
operator|(
expr|struct
name|ether_arp
operator|*
operator|)
operator|(
name|ep
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|len
decl_stmt|,
name|raw_sock
decl_stmt|;
name|update_arptab
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
name|ipaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Build the rarp reply by modifying the rarp request in place. 	 */
name|ap
operator|->
name|arp_op
operator|=
name|htons
argument_list|(
name|ARPOP_REVREPLY
argument_list|)
expr_stmt|;
comment|/* 	 * XXX   Using htons(ETHERTYPE_REVARP) doesn't work: you wind 	 * up transmitting 0x3580 instead of the correct value of 	 * 0x8035. What makes no sense is that the NetBSD people 	 * do in fact use htons(ETHERTYPE_REVARP) in their rarpd. 	 * (Thank god for tcpdump or I would never have figured this 	 * out.) 	 */
name|ep
operator|->
name|ether_type
operator|=
name|ETHERTYPE_REVARP
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_dhost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ii
operator|->
name|ii_eaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ep
operator|->
name|ether_shost
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ii
operator|->
name|ii_eaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ap
operator|->
name|arp_sha
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ipaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|arp_tpa
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Target hardware is unchanged. */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ii
operator|->
name|ii_ipaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ap
operator|->
name|arp_spa
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ap
argument_list|)
expr_stmt|;
name|n
operator|=
name|write
argument_list|(
name|ii
operator|->
name|ii_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ep
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|len
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"write: only %d of %d bytes written"
argument_list|,
name|n
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Get the netmask of an IP address.  This routine is used if  * SIOCGIFNETMASK doesn't work.  */
end_comment

begin_function
name|u_long
name|ipaddrtonetmask
parameter_list|(
name|addr
parameter_list|)
name|u_long
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|IN_CLASSA_NET
return|;
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|IN_CLASSB_NET
return|;
if|if
condition|(
name|IN_CLASSC
argument_list|(
name|addr
argument_list|)
condition|)
return|return
name|IN_CLASSC_NET
return|;
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"unknown IP address class: %08X"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

end_unit

