begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ------+---------+---------+---------+---------+---------+---------+---------*  * Copyright (c) 2002   - Garance Alistair Drosehn<gad@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation  * are those of the authors and should not be interpreted as representing  * official policies, either expressed or implied, of the FreeBSD Project  * or FreeBSD, Inc.  *  * ------+---------+---------+---------+---------+---------+---------+---------*  */
end_comment

begin_include
include|#
directive|include
file|"lp.cdefs.h"
end_include

begin_comment
comment|/* A cross-platform version of<sys/cdefs.h> */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * movejobs.c - The lpc commands which move jobs around.  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_comment
comment|/* just for MAXNAMLEN, for job_cfname in lp.h! */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"lp.h"
end_include

begin_include
include|#
directive|include
file|"lpc.h"
end_include

begin_include
include|#
directive|include
file|"matchjobs.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/* Values for origcmd in tqbq_common() */
end_comment

begin_define
define|#
directive|define
name|IS_TOPQ
value|1
end_define

begin_define
define|#
directive|define
name|IS_BOTQ
value|2
end_define

begin_function_decl
specifier|static
name|int
name|process_jobs
parameter_list|(
name|int
name|_argc
parameter_list|,
name|char
modifier|*
name|_argv
index|[]
parameter_list|,
name|process_jqe
name|_process_rtn
parameter_list|,
name|void
modifier|*
name|myinfo
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|process_jqe
name|touch_jqe
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|tqbq_common
parameter_list|(
name|int
name|_argc
parameter_list|,
name|char
modifier|*
name|_argv
index|[]
parameter_list|,
name|int
name|_origcmd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * isdigit is defined to work on an 'int', in the range 0 to 255, plus EOF.  * Define a wrapper which can take 'char', either signed or unsigned.  */
end_comment

begin_define
define|#
directive|define
name|isdigitch
parameter_list|(
name|Anychar
parameter_list|)
value|isdigit(((int) Anychar)& 255)
end_define

begin_struct
struct|struct
name|touchjqe_info
block|{
comment|/* for topq/bottomq */
name|time_t
name|newtime
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|nitems
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|jobqueue
modifier|*
modifier|*
name|queue
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Process all the jobs, as specified by the user.  */
end_comment

begin_function
specifier|static
name|int
name|process_jobs
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|process_jqe
name|process_rtn
parameter_list|,
name|void
modifier|*
name|myinfo
parameter_list|)
block|{
name|struct
name|jobspec_hdr
name|jobs_wanted
decl_stmt|;
name|int
name|i
decl_stmt|,
name|matchcnt
decl_stmt|,
name|pjres
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|jobs_wanted
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|pjres
operator|=
name|parse_jobspec
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
operator|&
name|jobs_wanted
argument_list|)
expr_stmt|;
if|if
condition|(
name|pjres
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\tinvalid job specifier: %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|matchcnt
operator|=
name|scanq_jobspec
argument_list|(
name|nitems
argument_list|,
name|queue
argument_list|,
name|SCQ_JSORDER
argument_list|,
operator|&
name|jobs_wanted
argument_list|,
name|process_rtn
argument_list|,
name|myinfo
argument_list|)
expr_stmt|;
name|free_jobspec
argument_list|(
operator|&
name|jobs_wanted
argument_list|)
expr_stmt|;
return|return
operator|(
name|matchcnt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reposition the job by changing the modification time of the  * control file.  */
end_comment

begin_function
specifier|static
name|int
name|touch_jqe
parameter_list|(
name|void
modifier|*
name|myinfo
parameter_list|,
name|struct
name|jobqueue
modifier|*
name|jq
parameter_list|,
name|struct
name|jobspec
modifier|*
name|jspec
parameter_list|)
block|{
name|struct
name|timeval
name|tvp
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|touchjqe_info
modifier|*
name|touch_info
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * If the entire queue has been scanned for the current jobspec, 	 * then let the user know if there were no jobs matched by that 	 * specification. 	 */
if|if
condition|(
name|jq
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|jspec
operator|->
name|matchcnt
operator|==
literal|0
condition|)
block|{
name|format_jobspec
argument_list|(
name|jspec
argument_list|,
name|FMTJS_VERBOSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|jspec
operator|->
name|pluralfmt
condition|)
name|printf
argument_list|(
literal|"\tjobs %s are not in the queue\n"
argument_list|,
name|jspec
operator|->
name|fmtoutput
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tjob %s is not in the queue\n"
argument_list|,
name|jspec
operator|->
name|fmtoutput
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Do a little juggling with "matched" vs "processed", so a single 	 * job can be matched by multiple specifications, and yet it will 	 * be moved only once.  This is so, eg, 'topq lp 7 7' will not 	 * complain "job 7 is not in queue" for the second specification. 	 */
name|jq
operator|->
name|job_matched
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|jq
operator|->
name|job_processed
condition|)
block|{
name|printf
argument_list|(
literal|"\tmoved %s earlier\n"
argument_list|,
name|jq
operator|->
name|job_cfname
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|jq
operator|->
name|job_processed
operator|=
literal|1
expr_stmt|;
name|touch_info
operator|=
name|myinfo
expr_stmt|;
name|tvp
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|tvp
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
operator|++
name|touch_info
operator|->
name|newtime
expr_stmt|;
name|tvp
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|tvp
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|seteuid
argument_list|(
name|euid
argument_list|)
expr_stmt|;
name|ret
operator|=
name|utimes
argument_list|(
name|jq
operator|->
name|job_cfname
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
name|seteuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|jspec
operator|->
name|matcheduser
condition|)
name|printf
argument_list|(
literal|"\tmoved %s  (user %s)\n"
argument_list|,
name|jq
operator|->
name|job_cfname
argument_list|,
name|jspec
operator|->
name|matcheduser
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tmoved %s\n"
argument_list|,
name|jq
operator|->
name|job_cfname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put the specified jobs at the bottom of printer queue.  */
end_comment

begin_function
name|void
name|bottomq_cmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"usage: bottomq printer [jobspec ...]\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|--
name|argc
expr_stmt|;
comment|/* First argv was the command name */
operator|++
name|argv
expr_stmt|;
name|tqbq_common
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|IS_BOTQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Put the specified jobs at the top of printer queue.  */
end_comment

begin_function
name|void
name|topq_cmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"usage: topq printer [jobspec ...]\n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|--
name|argc
expr_stmt|;
comment|/* First argv was the command name */
operator|++
name|argv
expr_stmt|;
name|tqbq_common
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|IS_TOPQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Processing in common between topq and bottomq commands.  */
end_comment

begin_function
name|void
name|tqbq_common
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|int
name|origcmd
parameter_list|)
block|{
name|struct
name|printer
name|myprinter
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|struct
name|touchjqe_info
name|touch_info
decl_stmt|;
name|int
name|i
decl_stmt|,
name|movecnt
decl_stmt|,
name|setres
decl_stmt|;
name|pp
operator|=
name|setup_myprinter
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|myprinter
argument_list|,
name|SUMP_CHDIR_SD
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return;
operator|--
name|argc
expr_stmt|;
comment|/* Second argv was the printer name */
operator|++
name|argv
expr_stmt|;
name|nitems
operator|=
name|getq
argument_list|(
name|pp
argument_list|,
operator|&
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|nitems
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\tthere are no jobs in the queue\n"
argument_list|)
expr_stmt|;
name|free_printer
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * The only real difference between topq and bottomq is the 	 * initial value used for newtime. 	 */
switch|switch
condition|(
name|origcmd
condition|)
block|{
case|case
name|IS_BOTQ
case|:
comment|/* 		 * When moving jobs to the bottom of the queue, pick a 		 * starting value which is one second after the last job 		 * in the queue. 		*/
name|touch_info
operator|.
name|newtime
operator|=
name|queue
index|[
name|nitems
operator|-
literal|1
index|]
operator|->
name|job_time
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|IS_TOPQ
case|:
comment|/* 		 * When moving jobs to the top of the queue, the greatest 		 * number of jobs which could be moved is all the jobs 		 * that are in the queue.  Pick a starting value which 		 * leaves plenty of room for all existing jobs. 		 */
name|touch_info
operator|.
name|newtime
operator|=
name|queue
index|[
literal|0
index|]
operator|->
name|job_time
operator|-
name|nitems
operator|-
literal|5
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"\ninternal error in topq/bottomq processing.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|movecnt
operator|=
name|process_jobs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|touch_jqe
argument_list|,
operator|&
name|touch_info
argument_list|)
expr_stmt|;
comment|/* 	 * If any jobs were moved, then chmod the lock file to notify any 	 * active process for this queue that the queue has changed, so 	 * it will rescan the queue to find out the new job order.  	 */
if|if
condition|(
name|movecnt
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\tqueue order unchanged\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|setres
operator|=
name|set_qstate
argument_list|(
name|SQS_QCHANGED
argument_list|,
name|pp
operator|->
name|lock_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|setres
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"\t* queue order changed for %s, but the\n"
literal|"\t* attempt to set_qstate() failed [%d]!\n"
argument_list|,
name|pp
operator|->
name|printer
argument_list|,
name|setres
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|queue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|queue
argument_list|)
expr_stmt|;
name|free_printer
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

