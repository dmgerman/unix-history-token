begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-4-Clause  *  * Copyright (c) 1983, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char sccsid[] = "@(#)printcap.c	8.2 (Berkeley) 4/28/95";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"lp.cdefs.h"
end_include

begin_comment
comment|/* A cross-platform version of<sys/cdefs.h> */
end_comment

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* required for lp.h, but not used here */
end_comment

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_comment
comment|/* ditto */
end_comment

begin_include
include|#
directive|include
file|"lp.h"
end_include

begin_include
include|#
directive|include
file|"lp.local.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/*  * Routines and data used in processing the printcap file.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|printcapdb
index|[
literal|2
index|]
init|=
block|{
name|_PATH_PRINTCAP
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list for cget* */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|capdb_canonical_name
parameter_list|(
specifier|const
name|char
modifier|*
name|_bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capdb_getaltlog
parameter_list|(
name|char
modifier|*
name|_bp
parameter_list|,
specifier|const
name|char
modifier|*
name|_shrt
parameter_list|,
specifier|const
name|char
modifier|*
name|_lng
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capdb_getaltnum
parameter_list|(
name|char
modifier|*
name|_bp
parameter_list|,
specifier|const
name|char
modifier|*
name|_shrt
parameter_list|,
specifier|const
name|char
modifier|*
name|_lng
parameter_list|,
name|long
name|_dflt
parameter_list|,
name|long
modifier|*
name|_result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|capdb_getaltstr
parameter_list|(
name|char
modifier|*
name|_bp
parameter_list|,
specifier|const
name|char
modifier|*
name|_shrt
parameter_list|,
specifier|const
name|char
modifier|*
name|lng
parameter_list|,
specifier|const
name|char
modifier|*
name|_dflt
parameter_list|,
name|char
modifier|*
modifier|*
name|_result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getprintcap_int
parameter_list|(
name|char
modifier|*
name|_bp
parameter_list|,
name|struct
name|printer
modifier|*
name|_pp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Change the name of the printcap file.  Used by chkprintcap(8),  * but could be used by other members of the suite with appropriate  * security measures.  */
end_comment

begin_function
name|void
name|setprintcap
parameter_list|(
name|char
modifier|*
name|newfile
parameter_list|)
block|{
name|printcapdb
index|[
literal|0
index|]
operator|=
name|newfile
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the printcap database for printer `printer' into the  * struct printer pointed by `pp'.  Return values are as for  * cgetent(3): -1 means we could not find what we wanted, -2  * means a system error occurred (and errno is set), -3 if a  * reference (`tc=') loop was detected, and 0 means success.  *  * Copied from lpr; should add additional capabilities as they  * are required by the other programs in the suite so that  * printcap-reading is consistent across the entire family.  */
end_comment

begin_function
name|int
name|getprintcap
parameter_list|(
specifier|const
name|char
modifier|*
name|printer
parameter_list|,
name|struct
name|printer
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|XXX
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
comment|/* 	 * A bug in the declaration of cgetent(3) means that we have 	 * to hide the constness of its third argument. 	 */
name|XXX
operator|=
operator|(
name|char
operator|*
operator|)
name|printer
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|cgetent
argument_list|(
operator|&
name|bp
argument_list|,
name|printcapdb
argument_list|,
name|XXX
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|status
return|;
name|status
operator|=
name|getprintcap_int
argument_list|(
name|bp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Map the status values returned by cgetfirst/cgetnext into those  * used by cgetent, returning truth if there are more records to  * examine.  This points out what is arguably a bug in the cget*  * interface (or at least a nasty wart).  */
end_comment

begin_function
specifier|static
name|int
name|firstnextmap
parameter_list|(
name|int
modifier|*
name|status
parameter_list|)
block|{
switch|switch
condition|(
operator|*
name|status
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|0
return|;
case|case
literal|1
case|:
operator|*
name|status
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|2
case|:
operator|*
name|status
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
case|case
operator|-
literal|1
case|:
operator|*
name|status
operator|=
operator|-
literal|2
expr_stmt|;
return|return
literal|0
return|;
case|case
operator|-
literal|2
case|:
operator|*
name|status
operator|=
operator|-
literal|3
expr_stmt|;
return|return
literal|1
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Scan through the database of printers using cgetfirst/cgetnext.  * Return false of error or end-of-database; else true.  */
end_comment

begin_function
name|int
name|firstprinter
parameter_list|(
name|struct
name|printer
modifier|*
name|pp
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|init_printer
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|status
operator|=
name|cgetfirst
argument_list|(
operator|&
name|bp
argument_list|,
name|printcapdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstnextmap
argument_list|(
operator|&
name|status
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|status
expr_stmt|;
name|status
operator|=
name|getprintcap_int
argument_list|(
name|bp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|status
condition|)
operator|*
name|error
operator|=
name|status
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|nextprinter
parameter_list|(
name|struct
name|printer
modifier|*
name|pp
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|free_printer
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|status
operator|=
name|cgetnext
argument_list|(
operator|&
name|bp
argument_list|,
name|printcapdb
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstnextmap
argument_list|(
operator|&
name|status
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|error
condition|)
operator|*
name|error
operator|=
name|status
expr_stmt|;
name|status
operator|=
name|getprintcap_int
argument_list|(
name|bp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|status
condition|)
operator|*
name|error
operator|=
name|status
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|lastprinter
parameter_list|(
name|void
parameter_list|)
block|{
name|cgetclose
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This must match the order of declaration of enum filter in lp.h.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|filters
index|[]
init|=
block|{
literal|"cf"
block|,
literal|"df"
block|,
literal|"gf"
block|,
literal|"if"
block|,
literal|"nf"
block|,
literal|"of"
block|,
literal|"rf"
block|,
literal|"tf"
block|,
literal|"vf"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|longfilters
index|[]
init|=
block|{
literal|"filt.cifplot"
block|,
literal|"filt.dvi"
block|,
literal|"filt.plot"
block|,
literal|"filt.input"
block|,
literal|"filt.ditroff"
block|,
literal|"filt.output"
block|,
literal|"filt.fortran"
block|,
literal|"filt.troff"
block|,
literal|"filt.raster"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal routine for both getprintcap() and nextprinter().  * Actually parse the printcap entry using cget* functions.  * Also attempt to figure out the canonical name of the printer  * and store a malloced copy of it in pp->printer.  */
end_comment

begin_function
specifier|static
name|int
name|getprintcap_int
parameter_list|(
name|char
modifier|*
name|bp
parameter_list|,
name|struct
name|printer
modifier|*
name|pp
parameter_list|)
block|{
name|enum
name|lpd_filters
name|filt
decl_stmt|;
name|char
modifier|*
name|rp_name
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|pp
operator|->
name|printer
operator|=
name|capdb_canonical_name
argument_list|(
name|bp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|PCAPERR_OSERR
return|;
define|#
directive|define
name|CHK
parameter_list|(
name|x
parameter_list|)
value|do {if ((x) == PCAPERR_OSERR) return PCAPERR_OSERR;}while(0)
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"af"
argument_list|,
literal|"acct.file"
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|acct_file
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltnum
argument_list|(
name|bp
argument_list|,
literal|"br"
argument_list|,
literal|"tty.rate"
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|baud_rate
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltnum
argument_list|(
name|bp
argument_list|,
literal|"ct"
argument_list|,
literal|"remote.timeout"
argument_list|,
name|DEFTIMEOUT
argument_list|,
operator|&
name|pp
operator|->
name|conn_timeout
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltnum
argument_list|(
name|bp
argument_list|,
literal|"du"
argument_list|,
literal|"daemon.user"
argument_list|,
name|DEFUID
argument_list|,
operator|&
name|pp
operator|->
name|daemon_user
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"ff"
argument_list|,
literal|"job.formfeed"
argument_list|,
name|DEFFF
argument_list|,
operator|&
name|pp
operator|->
name|form_feed
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"lf"
argument_list|,
literal|"spool.log"
argument_list|,
name|_PATH_CONSOLE
argument_list|,
operator|&
name|pp
operator|->
name|log_file
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"lo"
argument_list|,
literal|"spool.lock"
argument_list|,
name|DEFLOCK
argument_list|,
operator|&
name|pp
operator|->
name|lock_file
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"lp"
argument_list|,
literal|"tty.device"
argument_list|,
name|_PATH_DEFDEVLP
argument_list|,
operator|&
name|pp
operator|->
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltnum
argument_list|(
name|bp
argument_list|,
literal|"mc"
argument_list|,
literal|"max.copies"
argument_list|,
name|DEFMAXCOPIES
argument_list|,
operator|&
name|pp
operator|->
name|max_copies
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"ms"
argument_list|,
literal|"tty.mode"
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|mode_set
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltnum
argument_list|(
name|bp
argument_list|,
literal|"mx"
argument_list|,
literal|"max.blocks"
argument_list|,
name|DEFMX
argument_list|,
operator|&
name|pp
operator|->
name|max_blocks
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltnum
argument_list|(
name|bp
argument_list|,
literal|"pc"
argument_list|,
literal|"acct.price"
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|price100
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltnum
argument_list|(
name|bp
argument_list|,
literal|"pl"
argument_list|,
literal|"page.length"
argument_list|,
name|DEFLENGTH
argument_list|,
operator|&
name|pp
operator|->
name|page_length
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltnum
argument_list|(
name|bp
argument_list|,
literal|"pw"
argument_list|,
literal|"page.width"
argument_list|,
name|DEFWIDTH
argument_list|,
operator|&
name|pp
operator|->
name|page_width
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltnum
argument_list|(
name|bp
argument_list|,
literal|"px"
argument_list|,
literal|"page.pwidth"
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|page_pwidth
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltnum
argument_list|(
name|bp
argument_list|,
literal|"py"
argument_list|,
literal|"page.plength"
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|page_plength
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"rg"
argument_list|,
literal|"daemon.restrictgrp"
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|restrict_grp
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"rm"
argument_list|,
literal|"remote.host"
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|remote_host
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"rp"
argument_list|,
literal|"remote.queue"
argument_list|,
name|DEFLP
argument_list|,
operator|&
name|pp
operator|->
name|remote_queue
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"sd"
argument_list|,
literal|"spool.dir"
argument_list|,
name|_PATH_DEFSPOOL
argument_list|,
operator|&
name|pp
operator|->
name|spool_dir
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"sr"
argument_list|,
literal|"stat.recv"
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|stat_recv
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"ss"
argument_list|,
literal|"stat.send"
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|stat_send
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"st"
argument_list|,
literal|"spool.status"
argument_list|,
name|DEFSTAT
argument_list|,
operator|&
name|pp
operator|->
name|status_file
argument_list|)
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"tr"
argument_list|,
literal|"job.trailer"
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|trailer
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|resend_copies
operator|=
name|capdb_getaltlog
argument_list|(
name|bp
argument_list|,
literal|"rc"
argument_list|,
literal|"remote.resend_copies"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|restricted
operator|=
name|capdb_getaltlog
argument_list|(
name|bp
argument_list|,
literal|"rs"
argument_list|,
literal|"daemon.restricted"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|short_banner
operator|=
name|capdb_getaltlog
argument_list|(
name|bp
argument_list|,
literal|"sb"
argument_list|,
literal|"banner.short"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|no_copies
operator|=
name|capdb_getaltlog
argument_list|(
name|bp
argument_list|,
literal|"sc"
argument_list|,
literal|"job.no_copies"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|no_formfeed
operator|=
name|capdb_getaltlog
argument_list|(
name|bp
argument_list|,
literal|"sf"
argument_list|,
literal|"job.no_formfeed"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|no_header
operator|=
name|capdb_getaltlog
argument_list|(
name|bp
argument_list|,
literal|"sh"
argument_list|,
literal|"banner.disable"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|header_last
operator|=
name|capdb_getaltlog
argument_list|(
name|bp
argument_list|,
literal|"hl"
argument_list|,
literal|"banner.last"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|rw
operator|=
name|capdb_getaltlog
argument_list|(
name|bp
argument_list|,
literal|"rw"
argument_list|,
literal|"tty.rw"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|tof
operator|=
operator|!
name|capdb_getaltlog
argument_list|(
name|bp
argument_list|,
literal|"fo"
argument_list|,
literal|"job.topofform"
argument_list|)
expr_stmt|;
comment|/* 	 * Decide if the remote printer name matches the local printer name. 	 * If no name is given then we assume they mean them to match. 	 * If a name is given see if the rp_name is one of the names for 	 * this printer. 	 */
name|pp
operator|->
name|rp_matches_local
operator|=
literal|1
expr_stmt|;
name|CHK
argument_list|(
operator|(
name|error
operator|=
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
literal|"rp"
argument_list|,
literal|"remote.queue"
argument_list|,
literal|0
argument_list|,
operator|&
name|rp_name
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|PCAPERR_NOTFOUND
operator|&&
name|rp_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cgetmatch
argument_list|(
name|bp
argument_list|,
name|rp_name
argument_list|)
operator|!=
literal|0
condition|)
name|pp
operator|->
name|rp_matches_local
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|rp_name
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Filters: 	 */
for|for
control|(
name|filt
operator|=
literal|0
init|;
name|filt
operator|<
name|LPF_COUNT
condition|;
name|filt
operator|++
control|)
block|{
name|CHK
argument_list|(
name|capdb_getaltstr
argument_list|(
name|bp
argument_list|,
name|filters
index|[
name|filt
index|]
argument_list|,
name|longfilters
index|[
name|filt
index|]
argument_list|,
literal|0
argument_list|,
operator|&
name|pp
operator|->
name|filters
index|[
name|filt
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Decode the error codes returned by cgetent() using the names we  * made up for them from "lp.h".  * This would have been much better done with Common Error,>sigh<.  * Perhaps this can be fixed in the next incarnation of cget*.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|pcaperr
parameter_list|(
name|int
name|error
parameter_list|)
block|{
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|PCAPERR_TCOPEN
case|:
return|return
literal|"unresolved tc= expansion"
return|;
case|case
name|PCAPERR_SUCCESS
case|:
return|return
literal|"no error"
return|;
case|case
name|PCAPERR_NOTFOUND
case|:
return|return
literal|"printer not found"
return|;
case|case
name|PCAPERR_OSERR
case|:
return|return
name|strerror
argument_list|(
name|errno
argument_list|)
return|;
case|case
name|PCAPERR_TCLOOP
case|:
return|return
literal|"loop detected in tc= expansion"
return|;
default|default:
return|return
literal|"unknown printcap error"
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize a `struct printer' to contain values harmless to  * the other routines in liblpr.  */
end_comment

begin_function
name|void
name|init_printer
parameter_list|(
name|struct
name|printer
modifier|*
name|pp
parameter_list|)
block|{
specifier|static
name|struct
name|printer
name|zero
decl_stmt|;
operator|*
name|pp
operator|=
name|zero
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the dynamically-allocated strings in a `struct printer'.  * Idempotent.  */
end_comment

begin_function
name|void
name|free_printer
parameter_list|(
name|struct
name|printer
modifier|*
name|pp
parameter_list|)
block|{
name|enum
name|lpd_filters
name|filt
decl_stmt|;
define|#
directive|define
name|cfree
parameter_list|(
name|x
parameter_list|)
value|do { if (x) free(x); } while(0)
name|cfree
argument_list|(
name|pp
operator|->
name|printer
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|acct_file
argument_list|)
expr_stmt|;
for|for
control|(
name|filt
operator|=
literal|0
init|;
name|filt
operator|<
name|LPF_COUNT
condition|;
name|filt
operator|++
control|)
name|cfree
argument_list|(
name|pp
operator|->
name|filters
index|[
name|filt
index|]
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|form_feed
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|log_file
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|lock_file
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|lp
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|restrict_grp
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|remote_host
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|remote_queue
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|spool_dir
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|stat_recv
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|stat_send
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|status_file
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|trailer
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|pp
operator|->
name|mode_set
argument_list|)
expr_stmt|;
name|init_printer
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*   * The following routines are part of what would be a sensible library   * interface to capability databases.  Maybe someday this will become  * the default.  */
end_comment

begin_comment
comment|/*  * It provides similar functionality to cgetstr(),  * except that it provides for both a long and a short  * capability name and allows for a default to be specified.  */
end_comment

begin_function
specifier|static
name|int
name|capdb_getaltstr
parameter_list|(
name|char
modifier|*
name|bp
parameter_list|,
specifier|const
name|char
modifier|*
name|shrt
parameter_list|,
specifier|const
name|char
modifier|*
name|lng
parameter_list|,
specifier|const
name|char
modifier|*
name|dflt
parameter_list|,
name|char
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|cgetstr
argument_list|(
name|bp
argument_list|,
operator|(
name|char
operator|*
operator|)
comment|/*XXX*/
name|lng
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>=
literal|0
operator|||
name|status
operator|==
name|PCAPERR_OSERR
condition|)
return|return
name|status
return|;
name|status
operator|=
name|cgetstr
argument_list|(
name|bp
argument_list|,
operator|(
name|char
operator|*
operator|)
comment|/*XXX*/
name|shrt
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>=
literal|0
operator|||
name|status
operator|==
name|PCAPERR_OSERR
condition|)
return|return
name|status
return|;
if|if
condition|(
name|dflt
condition|)
block|{
operator|*
name|result
operator|=
name|strdup
argument_list|(
name|dflt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|result
operator|==
name|NULL
condition|)
return|return
name|PCAPERR_OSERR
return|;
return|return
name|strlen
argument_list|(
operator|*
name|result
argument_list|)
return|;
block|}
return|return
name|PCAPERR_NOTFOUND
return|;
block|}
end_function

begin_comment
comment|/*  * The same, only for integers.  */
end_comment

begin_function
specifier|static
name|int
name|capdb_getaltnum
parameter_list|(
name|char
modifier|*
name|bp
parameter_list|,
specifier|const
name|char
modifier|*
name|shrt
parameter_list|,
specifier|const
name|char
modifier|*
name|lng
parameter_list|,
name|long
name|dflt
parameter_list|,
name|long
modifier|*
name|result
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|cgetnum
argument_list|(
name|bp
argument_list|,
operator|(
name|char
operator|*
operator|)
comment|/*XXX*/
name|lng
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
return|return
name|status
return|;
name|status
operator|=
name|cgetnum
argument_list|(
name|bp
argument_list|,
operator|(
name|char
operator|*
operator|)
comment|/*XXX*/
name|shrt
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
return|return
name|status
return|;
operator|*
name|result
operator|=
name|dflt
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Likewise for logical values.  There's no need for a default parameter  * because the default is always false.  */
end_comment

begin_function
specifier|static
name|int
name|capdb_getaltlog
parameter_list|(
name|char
modifier|*
name|bp
parameter_list|,
specifier|const
name|char
modifier|*
name|shrt
parameter_list|,
specifier|const
name|char
modifier|*
name|lng
parameter_list|)
block|{
if|if
condition|(
name|cgetcap
argument_list|(
name|bp
argument_list|,
operator|(
name|char
operator|*
operator|)
comment|/*XXX*/
name|lng
argument_list|,
literal|':'
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|cgetcap
argument_list|(
name|bp
argument_list|,
operator|(
name|char
operator|*
operator|)
comment|/*XXX*/
name|shrt
argument_list|,
literal|':'
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Also should be a part of a better cget* library.  * Given a capdb entry, attempt to figure out what its canonical name  * is, and return a malloced copy of it.  The canonical name is  * considered to be the first one listed.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|capdb_canonical_name
parameter_list|(
specifier|const
name|char
modifier|*
name|bp
parameter_list|)
block|{
name|char
modifier|*
name|retval
decl_stmt|;
specifier|const
name|char
modifier|*
name|nameend
decl_stmt|;
name|nameend
operator|=
name|strpbrk
argument_list|(
name|bp
argument_list|,
literal|"|:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameend
operator|==
name|NULL
condition|)
name|nameend
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|malloc
argument_list|(
name|nameend
operator|-
name|bp
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|retval
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncat
argument_list|(
name|retval
argument_list|,
name|bp
argument_list|,
name|nameend
operator|-
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

end_unit

