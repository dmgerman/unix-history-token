begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ------+---------+---------+---------+---------+---------+---------+---------*  * Copyright (c) 2001  - Garance Alistair Drosehn<gad@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *   1. Redistributions of source code must retain the above copyright  *      notice, this list of conditions and the following disclaimer.  *   2. Redistributions in binary form must reproduce the above copyright  *      notice, this list of conditions and the following disclaimer in the  *      documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation  * are those of the authors and should not be interpreted as representing  * official policies, either expressed or implied, of the FreeBSD Project.  *  * ------+---------+---------+---------+---------+---------+---------+---------*  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * ctlinfo - This collection of routines will know everything there is to  * know about the information inside a control file ('cf*') which is used  * to describe a print job in lpr& friends.  The eventual goal is that it  * will be the ONLY source file to know what's inside these control-files.  */
end_comment

begin_comment
comment|/*  * Some define's useful for debuging.  * TRIGGERTEST_FNAME and DEBUGREADCF_FNAME, allow us to do testing on  * a per-spool-directory basis.  */
end_comment

begin_comment
comment|/* #define TRIGGERTEST_FNAME "LpdTestRenameTF" */
end_comment

begin_comment
comment|/* #define DEBUGREADCF_FNAME "LpdDebugReadCF" */
end_comment

begin_comment
comment|/* #define LEAVE_TMPCF_FILES 1 */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"ctlinfo.h"
end_include

begin_struct
struct|struct
name|cjprivate
block|{
name|struct
name|cjobinfo
name|pub
decl_stmt|;
name|char
modifier|*
name|cji_buff
decl_stmt|;
comment|/* buffer for getline */
name|char
modifier|*
name|cji_eobuff
decl_stmt|;
comment|/* last byte IN the buffer */
name|FILE
modifier|*
name|cji_fstream
decl_stmt|;
name|int
name|cji_buffsize
decl_stmt|;
comment|/* # bytes in the buffer */
name|int
name|cji_dumpit
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|roundup
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((((x)+((y)-1))/(y))*(y))
end_define

begin_comment
comment|/*  * This has to be large enough to fit the maximum length of a single line  * in a control-file, including the leading 'command id', a trailing '\n'  * and ending '\0'.  The max size of an 'U'nlink line, for instance, is  * 1 ('U') + PATH_MAX (filename) + 2 ('\n\0').  The maximum 'H'ost line is  * 1 ('H') + NI_MAXHOST (remote hostname) + 2 ('\n\0').  Other lines can be  * even longer than those.  So, pick some nice, large, arbitrary value.  */
end_comment

begin_define
define|#
directive|define
name|CTI_LINEMAX
value|PATH_MAX+NI_MAXHOST+5
end_define

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|from_host
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* client's machine name */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|from_ip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* client machine's IP address */
end_comment

begin_function_decl
name|__BEGIN_DECLS
name|void
name|ctl_dumpcji
parameter_list|(
name|FILE
modifier|*
name|_dbg_stream
parameter_list|,
specifier|const
name|char
modifier|*
name|_heading
parameter_list|,
name|struct
name|cjobinfo
modifier|*
name|_cjinf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|ctl_getline
parameter_list|(
name|struct
name|cjobinfo
modifier|*
name|_cjinf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ctl_rewindcf
parameter_list|(
name|struct
name|cjobinfo
modifier|*
name|_cjinf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctl_rmjob
parameter_list|(
specifier|const
name|char
modifier|*
name|_ptrname
parameter_list|,
specifier|const
name|char
modifier|*
name|_cfname
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__END_DECLS
comment|/*  * Here are some things which might be needed when compiling this under  * platforms other than FreeBSD.  */
ifndef|#
directive|ifndef
name|__FreeBSD__
ifndef|#
directive|ifndef
name|NAME_MAX
define|#
directive|define
name|NAME_MAX
value|255
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NI_MAXHOST
define|#
directive|define
name|NI_MAXHOST
value|1025
endif|#
directive|endif
ifndef|#
directive|ifndef
name|PATH_MAX
define|#
directive|define
name|PATH_MAX
value|1024
endif|#
directive|endif
name|__BEGIN_DECLS
name|char
modifier|*
name|strdup
parameter_list|(
specifier|const
name|char
modifier|*
name|_src
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|size_t
name|strlcpy
parameter_list|(
name|char
modifier|*
name|_dst
parameter_list|,
specifier|const
name|char
modifier|*
name|_src
parameter_list|,
name|size_t
name|_siz
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|__END_DECLS
endif|#
directive|endif
comment|/*  *	Control-files (cf*) have the following format.  *  *	Each control-file describes a single job.  It will list one or more  *	"datafiles" (df*) which should be copied to some printer.  Usually  *	there is only one datafile per job.  For the curious, RFC 1179 is an  *	informal and out-of-date description of lpr/lpd circa 1990.  *  *	Each line in the file gives an attribute of the job as a whole, or one  *	of the datafiles in the job, or a "command" indicating something to do  *	with one of the datafiles.  Each line starts with an 'id' that indicates  *	what that line is there for.  The 'id' is historically a single byte,  *	but may be multiple bytes (obviously it would be best if multi-byte ids  *	started with some letter not already used as a single-byte id!).  *	After the 'id', the remainder of the line will be the value of the  *	indicated attribute, or a name of the datafile to be operated on.  *  *	In the following lists of ids, the ids with a '!' in front of them are  *	NOT explicitly supported by this version of lpd, or at least "not yet  *	supported".  They are only listed for reference purposes, so people  *	won't be tempted to reuse the same id for a different purpose.  *  *	The following are attributes of the job which should not appear more  *	than once in a control file.  Only the 'H' and 'P' lines are required  *	by the RFC, but some implementations of lpr won't even get that right.  *  *	! A   - [used by lprNG]  *	  B   - As far as I know, this is never used as a single-byte id.  *		Therefore, I intend to use it for multi-byte id codes.  *	  C   - "class name" to display on banner page (this is sometimes  *		used to hold options for print filters)  *	! D   - [in lprNG, "timestamp" of when the job was submitted]  *	! E   - "environment variables" to set [some versions of linux]  *	  H   - "host name" of machine where the original 'lpr' was done  *	  I   - "indent", the amount to indent output  *	  J   - "job name" to display on banner page  *	  L   - "literal" user's name as it should be displayed on the  *		banner page (it is the existence of an 'L' line which  *		indicates that a job should have a banner page).  *	  M   - "mail", userid to mail to when done printing (with email  *		going to 'M'@'H', so to speak).  *	  P   - "person", the user's login name (e.g. for accounting)  *	! Q   - [used by lprNG for queue-name]  *	  R   - "resolution" in dpi, for some laser printer queues  *	  T   - "title" for files sent thru 'pr'  *	  W   - "width" to use for printing plain-text files  *	  Z   - In BSD, "locale" to use for datafiles sent thru 'pr'.  *		(this BSD usage should move to a different id...)  *		[in lprNG - this line holds the "Z options"]  *	  1   - "R font file" for files sent thru troff  *	  2   - "I font file" for files sent thru troff  *	  3   - "B font file" for files sent thru troff  *	  4   - "S font file" for files sent thru troff  *  *	The following are attributes attached to a datafile, and thus may  *	appear multiple times in a control file (once per datafile):  *  *	  N   - "name" of file (for display purposes, used by 'lpq')  *	  S   - "stat() info" used for symbolic link ('lpr -s')  *		security checks.  *  *	The following indicate actions to take on a given datafile.  The same  *	datafile may appear on more than one "print this file" command in the  *	control file.  Note that ALL ids with lowercase letters are expected  *	to be actions to "print this file":  *  *	  c   - "file name", cifplot file to print.  This action appears  *		when the user has requested 'lpr -c'.  *	  d   - "file name", dvi file to print, user requested 'lpr -d'  *	  f   - "file name", a plain-text file to print = "standard"  *	  g   - "file name", plot(1G) file to print, ie 'lpr -g'  *	  l   - "file name", text file with control chars which should  *		be printed literally, ie 'lpr -l'  (note: some printers  *		take this id as a request to print a postscript file,  *		and because of *that* some OS's use 'l' to indicate  *		that a datafile is a postscript file)  *	  n   - "file name", ditroff(1) file to print, ie 'lpr -n'  *	  o   - "file name", a postscript file to print.  This id is  *		described in the original RFC, but not much has been  *		done with it.  This 'lpr' does not generate control  *		lines with 'o'-actions, but lpd's printjob processing  *		will treat it the same as 'l'.  *	  p   - "file name", text file to print with pr(1), ie 'lpr -p'  *	  t   - "file name", troff(1) file to print, ie 'lpr -t'  *	  v   - "file name", plain raster file to print  *  *	  U   - "file name" of datafile to unlink (ie, remove file  *		from spool directory.  To be done in a 'Pass 2',  *		AFTER having processed all datafiles in the job).  *  */
name|void
name|ctl_freeinf
parameter_list|(
name|struct
name|cjobinfo
modifier|*
name|cjinf
parameter_list|)
block|{
define|#
directive|define
name|FREESTR
parameter_list|(
name|xStr
parameter_list|)
define|\
value|if (xStr != NULL) { \ 		free(xStr); \ 		xStr = NULL;\ 	}
name|struct
name|cjprivate
modifier|*
name|cpriv
decl_stmt|;
if|if
condition|(
name|cjinf
operator|==
name|NULL
condition|)
return|return;
name|cpriv
operator|=
name|cjinf
operator|->
name|cji_priv
expr_stmt|;
if|if
condition|(
operator|(
name|cpriv
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cpriv
operator|!=
name|cpriv
operator|->
name|pub
operator|.
name|cji_priv
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"in ctl_freeinf(%p): invalid cjinf (cpriv %p)"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cjinf
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cpriv
argument_list|)
expr_stmt|;
return|return;
block|}
name|FREESTR
argument_list|(
name|cpriv
operator|->
name|pub
operator|.
name|cji_accthost
argument_list|)
expr_stmt|;
name|FREESTR
argument_list|(
name|cpriv
operator|->
name|pub
operator|.
name|cji_acctuser
argument_list|)
expr_stmt|;
name|FREESTR
argument_list|(
name|cpriv
operator|->
name|pub
operator|.
name|cji_class
argument_list|)
expr_stmt|;
name|FREESTR
argument_list|(
name|cpriv
operator|->
name|pub
operator|.
name|cji_curqueue
argument_list|)
expr_stmt|;
comment|/* [cpriv->pub.cji_fname is part of cpriv-malloced area] */
name|FREESTR
argument_list|(
name|cpriv
operator|->
name|pub
operator|.
name|cji_jobname
argument_list|)
expr_stmt|;
name|FREESTR
argument_list|(
name|cpriv
operator|->
name|pub
operator|.
name|cji_mailto
argument_list|)
expr_stmt|;
name|FREESTR
argument_list|(
name|cpriv
operator|->
name|pub
operator|.
name|cji_username
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpriv
operator|->
name|cji_fstream
operator|!=
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|cpriv
operator|->
name|cji_fstream
argument_list|)
expr_stmt|;
name|cpriv
operator|->
name|cji_fstream
operator|=
name|NULL
expr_stmt|;
block|}
name|cjinf
operator|->
name|cji_priv
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|cpriv
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FREESTR
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGREADCF_FNAME
end_ifdef

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|ctl_dbgfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stat
name|ctl_dbgstat
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|ctl_dbgline
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|cjobinfo
modifier|*
name|ctl_readcf
parameter_list|(
specifier|const
name|char
modifier|*
name|ptrname
parameter_list|,
specifier|const
name|char
modifier|*
name|cfname
parameter_list|)
block|{
name|int
name|id
decl_stmt|;
name|char
modifier|*
name|lbuff
decl_stmt|;
name|void
modifier|*
name|cstart
decl_stmt|;
name|FILE
modifier|*
name|cfile
decl_stmt|;
name|struct
name|cjprivate
modifier|*
name|cpriv
decl_stmt|;
name|struct
name|cjobinfo
modifier|*
name|cjinf
decl_stmt|;
name|size_t
name|msize
decl_stmt|,
name|sroom
decl_stmt|,
name|sroom2
decl_stmt|;
name|cfile
operator|=
name|fopen
argument_list|(
name|cfname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfile
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: ctl_readcf error fopen(%s): %s"
argument_list|,
name|ptrname
argument_list|,
name|cfname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sroom
operator|=
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cjprivate
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|sroom2
operator|=
name|sroom
operator|+
name|strlen
argument_list|(
name|cfname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|sroom2
operator|=
name|roundup
argument_list|(
name|sroom2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|msize
operator|=
name|sroom2
operator|+
name|CTI_LINEMAX
expr_stmt|;
name|msize
operator|=
name|roundup
argument_list|(
name|msize
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|cstart
operator|=
name|malloc
argument_list|(
name|msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstart
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|cstart
argument_list|,
literal|0
argument_list|,
name|msize
argument_list|)
expr_stmt|;
name|cpriv
operator|=
operator|(
expr|struct
name|cjprivate
operator|*
operator|)
name|cstart
expr_stmt|;
name|cpriv
operator|->
name|pub
operator|.
name|cji_priv
operator|=
name|cpriv
expr_stmt|;
name|cpriv
operator|->
name|pub
operator|.
name|cji_fname
operator|=
operator|(
name|char
operator|*
operator|)
name|cstart
operator|+
name|sroom
expr_stmt|;
name|strcpy
argument_list|(
name|cpriv
operator|->
name|pub
operator|.
name|cji_fname
argument_list|,
name|cfname
argument_list|)
expr_stmt|;
name|cpriv
operator|->
name|cji_buff
operator|=
operator|(
name|char
operator|*
operator|)
name|cstart
operator|+
name|sroom2
expr_stmt|;
name|cpriv
operator|->
name|cji_buffsize
operator|=
call|(
name|int
call|)
argument_list|(
name|msize
operator|-
name|sroom2
argument_list|)
expr_stmt|;
name|cpriv
operator|->
name|cji_eobuff
operator|=
operator|(
name|char
operator|*
operator|)
name|cstart
operator|+
name|msize
operator|-
literal|1
expr_stmt|;
name|cpriv
operator|->
name|cji_fstream
operator|=
name|cfile
expr_stmt|;
name|cpriv
operator|->
name|pub
operator|.
name|cji_curqueue
operator|=
name|strdup
argument_list|(
name|ptrname
argument_list|)
expr_stmt|;
name|ctl_dbgline
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGREADCF_FNAME
name|ctl_dbgfile
operator|=
name|NULL
expr_stmt|;
name|id
operator|=
name|stat
argument_list|(
name|DEBUGREADCF_FNAME
argument_list|,
operator|&
name|ctl_dbgstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* the file exists in this spool directory, write some simple 		 * debugging info to it */
name|ctl_dbgfile
operator|=
name|fopen
argument_list|(
name|DEBUGREADCF_FNAME
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_dbgfile
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|ctl_dbgfile
argument_list|,
literal|"%s: s=%p r=%ld e=%p %p->%s\n"
argument_list|,
name|ptrname
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cpriv
argument_list|,
operator|(
name|long
operator|)
name|sroom
argument_list|,
name|cpriv
operator|->
name|cji_eobuff
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_fname
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_fname
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Copy job-attribute values from control file to the struct of 	 * "public" information.  In some cases, it is invalid for the 	 * value to be a null-string, so that is ignored. 	 */
name|cjinf
operator|=
operator|&
operator|(
name|cpriv
operator|->
name|pub
operator|)
expr_stmt|;
name|lbuff
operator|=
name|ctl_getline
argument_list|(
name|cjinf
argument_list|)
expr_stmt|;
while|while
condition|(
name|lbuff
operator|!=
name|NULL
condition|)
block|{
name|id
operator|=
operator|*
name|lbuff
operator|++
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
literal|'C'
case|:
name|cpriv
operator|->
name|pub
operator|.
name|cji_class
operator|=
name|strdup
argument_list|(
name|lbuff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
if|if
condition|(
operator|*
name|lbuff
operator|==
literal|'\0'
condition|)
break|break;
name|cpriv
operator|->
name|pub
operator|.
name|cji_accthost
operator|=
name|strdup
argument_list|(
name|lbuff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|cpriv
operator|->
name|pub
operator|.
name|cji_jobname
operator|=
name|strdup
argument_list|(
name|lbuff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|cpriv
operator|->
name|pub
operator|.
name|cji_username
operator|=
name|strdup
argument_list|(
name|lbuff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* 			 * No valid mail-to address would start with a minus. 			 * If this one does, it is probably some trickster who 			 * is trying to trigger options on sendmail.  Ignore. 			 */
if|if
condition|(
operator|*
name|lbuff
operator|==
literal|'-'
condition|)
break|break;
if|if
condition|(
operator|*
name|lbuff
operator|==
literal|'\0'
condition|)
break|break;
name|cpriv
operator|->
name|pub
operator|.
name|cji_mailto
operator|=
name|strdup
argument_list|(
name|lbuff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* don't allow userid's with a leading minus, either */
if|if
condition|(
operator|*
name|lbuff
operator|==
literal|'-'
condition|)
break|break;
if|if
condition|(
operator|*
name|lbuff
operator|==
literal|'\0'
condition|)
break|break;
name|cpriv
operator|->
name|pub
operator|.
name|cji_acctuser
operator|=
name|strdup
argument_list|(
name|lbuff
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|islower
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|cpriv
operator|->
name|pub
operator|.
name|cji_dfcount
operator|++
expr_stmt|;
block|}
break|break;
block|}
name|lbuff
operator|=
name|ctl_getline
argument_list|(
name|cjinf
argument_list|)
expr_stmt|;
block|}
comment|/* the 'H'ost and 'P'erson fields are *always* supposed to be there */
if|if
condition|(
name|cpriv
operator|->
name|pub
operator|.
name|cji_accthost
operator|==
name|NULL
condition|)
name|cpriv
operator|->
name|pub
operator|.
name|cji_accthost
operator|=
name|strdup
argument_list|(
literal|".na."
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpriv
operator|->
name|pub
operator|.
name|cji_acctuser
operator|==
name|NULL
condition|)
name|cpriv
operator|->
name|pub
operator|.
name|cji_acctuser
operator|=
name|strdup
argument_list|(
literal|".na."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGREADCF_FNAME
if|if
condition|(
name|ctl_dbgfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cpriv
operator|->
name|cji_dumpit
condition|)
name|ctl_dumpcji
argument_list|(
name|ctl_dbgfile
argument_list|,
literal|"end readcf"
argument_list|,
operator|&
operator|(
name|cpriv
operator|->
name|pub
operator|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|ctl_dbgfile
argument_list|)
expr_stmt|;
name|ctl_dbgfile
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|&
operator|(
name|cpriv
operator|->
name|pub
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine renames the temporary control file as received from some  * other (remote) host.  That file will almost always with `tfA*', because  * recvjob.c creates the file by changing `c' to `t' in the original name  * for the control file.  Now if you read the RFC, you would think that all  * control filenames start with `cfA*'.  However, it seems there are some  * implementations which send control filenames which start with `cf'  * followed by *any* letter, so this routine can not assume what the third  * letter will (or will not) be.  Sigh.  *  * So this will rewrite the temporary file to `rf*' (correcting any lines  * which need correcting), rename that `rf*' file to `cf*', and then remove  * the original `tf*' temporary file.  *  * The *main* purpose of this routine is to be paranoid about the contents  * of that control file.  It is partially meant to protect against people  * TRYING to cause trouble (perhaps after breaking into root of some host  * that this host will accept print jobs from).  The fact that we're willing  * to print jobs from some remote host does not mean that we should blindly  * do anything that host tells us to do.  *  * This is also meant to protect us from errors in other implementations of  * lpr, particularly since we may want to use some values from the control  * file as environment variables when it comes time to print, or as parameters  * to commands which will be exec'ed, or values in statistics records.  *  * This may also do some "conversions" between how different versions of  * lpr or lprNG define the contents of various lines in a control file.  *  * If there is an error, it returns a pointer to a descriptive error message.  * Error messages which are RETURNED (as opposed to syslog-ed) do not include  * the printer-queue name.  Let the caller add that if it is wanted.  */
end_comment

begin_function
name|char
modifier|*
name|ctl_renametf
parameter_list|(
specifier|const
name|char
modifier|*
name|ptrname
parameter_list|,
specifier|const
name|char
modifier|*
name|tfname
parameter_list|)
block|{
name|int
name|chk3rd
decl_stmt|,
name|newfd
decl_stmt|,
name|nogood
decl_stmt|,
name|res
decl_stmt|;
name|FILE
modifier|*
name|newcf
decl_stmt|;
name|struct
name|cjobinfo
modifier|*
name|cjinf
decl_stmt|;
name|char
modifier|*
name|lbuff
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
name|tfname2
index|[
name|NAME_MAX
operator|+
literal|1
index|]
decl_stmt|,
name|cfname2
index|[
name|NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|errm
index|[
name|CTI_LINEMAX
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|TRIGGERTEST_FNAME
name|struct
name|stat
name|tstat
decl_stmt|;
name|res
operator|=
name|stat
argument_list|(
name|TRIGGERTEST_FNAME
argument_list|,
operator|&
name|tstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * if the trigger file does NOT exist in this spool directory, 		 * then do the exact same steps that the pre-ctlinfo code had 		 * been doing.  Ie, very little. 		 */
name|strlcpy
argument_list|(
name|cfname2
argument_list|,
name|tfname
argument_list|,
sizeof|sizeof
argument_list|(
name|cfname2
argument_list|)
argument_list|)
expr_stmt|;
name|cfname2
index|[
literal|0
index|]
operator|=
literal|'c'
expr_stmt|;
name|res
operator|=
name|link
argument_list|(
name|tfname
argument_list|,
name|cfname2
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|errm
argument_list|,
sizeof|sizeof
argument_list|(
name|errm
argument_list|)
argument_list|,
literal|"ctl_renametf error link(%s,%s): %s"
argument_list|,
name|tfname
argument_list|,
name|cfname2
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|errm
argument_list|)
return|;
block|}
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
name|cjinf
operator|=
name|NULL
expr_stmt|;
comment|/* in case of early jump to error_ret */
name|newcf
operator|=
name|NULL
expr_stmt|;
comment|/* in case of early jump to error_ret */
operator|*
name|errm
operator|=
literal|'\0'
expr_stmt|;
comment|/* in case of early jump to error_ret */
name|chk3rd
operator|=
name|tfname
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tfname
index|[
literal|0
index|]
operator|!=
literal|'t'
operator|)
operator|||
operator|(
name|tfname
index|[
literal|1
index|]
operator|!=
literal|'f'
operator|)
operator|||
operator|(
operator|!
name|isalpha
argument_list|(
name|chk3rd
argument_list|)
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|errm
argument_list|,
sizeof|sizeof
argument_list|(
name|errm
argument_list|)
argument_list|,
literal|"ctl_renametf invalid filename: %s"
argument_list|,
name|tfname
argument_list|)
expr_stmt|;
goto|goto
name|error_ret
goto|;
block|}
name|cjinf
operator|=
name|ctl_readcf
argument_list|(
name|ptrname
argument_list|,
name|tfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cjinf
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|errm
argument_list|,
sizeof|sizeof
argument_list|(
name|errm
argument_list|)
argument_list|,
literal|"ctl_renametf error cti_readcf(%s)"
argument_list|,
name|tfname
argument_list|)
expr_stmt|;
goto|goto
name|error_ret
goto|;
block|}
comment|/* 	 * This uses open+fdopen instead of fopen because that combination 	 * gives us greater control over file-creation issues. 	 */
name|strlcpy
argument_list|(
name|tfname2
argument_list|,
name|tfname
argument_list|,
sizeof|sizeof
argument_list|(
name|tfname2
argument_list|)
argument_list|)
expr_stmt|;
name|tfname2
index|[
literal|0
index|]
operator|=
literal|'r'
expr_stmt|;
comment|/* rf<letter><job><hostname> */
name|newfd
operator|=
name|open
argument_list|(
name|tfname2
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfd
operator|==
operator|-
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|errm
argument_list|,
sizeof|sizeof
argument_list|(
name|errm
argument_list|)
argument_list|,
literal|"ctl_renametf error open(%s): %s"
argument_list|,
name|tfname2
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error_ret
goto|;
block|}
name|newcf
operator|=
name|fdopen
argument_list|(
name|newfd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcf
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|errm
argument_list|,
sizeof|sizeof
argument_list|(
name|errm
argument_list|)
argument_list|,
literal|"ctl_renametf error fopen(%s): %s"
argument_list|,
name|tfname2
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error_ret
goto|;
block|}
comment|/* 	 * Do extra sanity checks on some key job-attribute fields, and 	 * write them out first (thus making sure they are written in the 	 * order we generally expect them to be in). 	 */
comment|/* 	 * Some lpr implementations on PC's set a null-string for their 	 * hostname.  A MacOS 10 system which has not correctly setup 	 * /etc/hostconfig will claim a hostname of 'localhost'.  Anything 	 * with blanks in it would be an invalid value for hostname.  For 	 * any of these invalid hostname values, replace the given value 	 * with the name of the host that this job is coming from. 	 */
name|nogood
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cjinf
operator|->
name|cji_accthost
operator|==
name|NULL
condition|)
name|nogood
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cjinf
operator|->
name|cji_accthost
argument_list|,
literal|".na."
argument_list|)
operator|==
literal|0
condition|)
name|nogood
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cjinf
operator|->
name|cji_accthost
argument_list|,
literal|"localhost"
argument_list|)
operator|==
literal|0
condition|)
name|nogood
operator|=
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|cp
operator|=
name|cjinf
operator|->
name|cji_accthost
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|<=
literal|' '
condition|)
block|{
name|nogood
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|nogood
condition|)
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"H%s\n"
argument_list|,
name|from_host
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"H%s\n"
argument_list|,
name|cjinf
operator|->
name|cji_accthost
argument_list|)
expr_stmt|;
comment|/* 	 * Now do some sanity checks on the 'P' (original userid) value.  Note 	 * that the 'P'erson line is the second line which is ALWAYS supposed 	 * to be present in a control file. 	 * 	 * There is no particularly good value to use for replacements, but 	 * at least make sure the value is something reasonable to use in 	 * environment variables and statistics records.  Again, some PC 	 * implementations send a null-string for a value.  Various Mac 	 * implementations will set whatever string the user has set for 	 * their 'Owner Name', which usually includes blanks, etc. 	 */
name|nogood
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cjinf
operator|->
name|cji_acctuser
operator|==
name|NULL
condition|)
name|nogood
operator|=
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|cp
operator|=
name|cjinf
operator|->
name|cji_acctuser
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|<=
literal|' '
condition|)
operator|*
name|cp
operator|=
literal|'_'
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nogood
condition|)
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"P%s\n"
argument_list|,
literal|".na."
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"P%s\n"
argument_list|,
name|cjinf
operator|->
name|cji_acctuser
argument_list|)
expr_stmt|;
comment|/* No need for sanity checks on class, jobname, "literal" user. */
if|if
condition|(
name|cjinf
operator|->
name|cji_class
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"C%s\n"
argument_list|,
name|cjinf
operator|->
name|cji_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|cjinf
operator|->
name|cji_jobname
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"J%s\n"
argument_list|,
name|cjinf
operator|->
name|cji_jobname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cjinf
operator|->
name|cji_username
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"L%s\n"
argument_list|,
name|cjinf
operator|->
name|cji_username
argument_list|)
expr_stmt|;
comment|/* 	 * This should probably add more sanity checks on mailto value. 	 * Note that if the mailto value is "wrong", then there's no good 	 * way to know what the "correct" value would be, and we should not 	 * semd email to some random address.  At least for now, just ignore 	 * any invalid values. 	 */
name|nogood
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cjinf
operator|->
name|cji_mailto
operator|==
name|NULL
condition|)
name|nogood
operator|=
literal|1
expr_stmt|;
else|else
block|{
for|for
control|(
name|cp
operator|=
name|cjinf
operator|->
name|cji_acctuser
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|<=
literal|' '
condition|)
block|{
name|nogood
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|nogood
condition|)
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"M%s\n"
argument_list|,
name|cjinf
operator|->
name|cji_mailto
argument_list|)
expr_stmt|;
comment|/* 	 * Now go thru the old control file, copying all information which 	 * hasn't already been written into the new file. 	 */
name|ctl_rewindcf
argument_list|(
name|cjinf
argument_list|)
expr_stmt|;
name|lbuff
operator|=
name|ctl_getline
argument_list|(
name|cjinf
argument_list|)
expr_stmt|;
while|while
condition|(
name|lbuff
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|lbuff
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'H'
case|:
case|case
literal|'P'
case|:
case|case
literal|'C'
case|:
case|case
literal|'J'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
comment|/* already wrote values for these to the newcf */
break|break;
case|case
literal|'N'
case|:
comment|/* see comments under 'U'... */
if|if
condition|(
name|cjinf
operator|->
name|cji_dfcount
operator|==
literal|0
condition|)
block|{
comment|/* in this case, 'N's will be done in 'U' */
break|break;
block|}
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"%s\n"
argument_list|,
name|lbuff
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* 			 * check for the very common case where the remote 			 * host had to process 'lpr -s -r', but it did not 			 * remove the Unlink line from the control file. 			 * Such Unlink lines will legitimately have a '/' in 			 * them, but it is the original lpr host which would 			 * have done the unlink of such files, and not any 			 * host receiving that job. 			 */
name|slash
operator|=
name|strchr
argument_list|(
name|lbuff
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
break|break;
comment|/* skip this line */
block|}
comment|/* 			 * Okay, another kind of broken lpr implementation 			 * is one which send datafiles, and Unlink's those 			 * datafiles, but never includes any PRINT request 			 * for those files.  Experimentation shows that one 			 * copy of those datafiles should be printed with a 			 * format of 'f'.  If this is an example of such a 			 * screwed-up control file, fix it here. 			 */
if|if
condition|(
name|cjinf
operator|->
name|cji_dfcount
operator|==
literal|0
condition|)
block|{
name|lbuff
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|lbuff
argument_list|,
literal|"df"
argument_list|,
operator|(
name|size_t
operator|)
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"f%s\n"
argument_list|,
name|lbuff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"U%s\n"
argument_list|,
name|lbuff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"N%s\n"
argument_list|,
name|lbuff
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"%s\n"
argument_list|,
name|lbuff
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|newcf
argument_list|,
literal|"%s\n"
argument_list|,
name|lbuff
argument_list|)
expr_stmt|;
break|break;
block|}
name|lbuff
operator|=
name|ctl_getline
argument_list|(
name|cjinf
argument_list|)
expr_stmt|;
block|}
name|ctl_freeinf
argument_list|(
name|cjinf
argument_list|)
expr_stmt|;
name|cjinf
operator|=
name|NULL
expr_stmt|;
name|res
operator|=
name|fclose
argument_list|(
name|newcf
argument_list|)
expr_stmt|;
name|newcf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|errm
argument_list|,
sizeof|sizeof
argument_list|(
name|errm
argument_list|)
argument_list|,
literal|"ctl_renametf error fclose(%s): %s"
argument_list|,
name|tfname2
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error_ret
goto|;
block|}
name|strlcpy
argument_list|(
name|cfname2
argument_list|,
name|tfname
argument_list|,
sizeof|sizeof
argument_list|(
name|cfname2
argument_list|)
argument_list|)
expr_stmt|;
name|cfname2
index|[
literal|0
index|]
operator|=
literal|'c'
expr_stmt|;
comment|/* rename new file to 'cfA*' */
name|res
operator|=
name|link
argument_list|(
name|tfname2
argument_list|,
name|cfname2
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|errm
argument_list|,
sizeof|sizeof
argument_list|(
name|errm
argument_list|)
argument_list|,
literal|"ctl_renametf error link(%s,%s): %s"
argument_list|,
name|tfname2
argument_list|,
name|cfname2
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error_ret
goto|;
block|}
comment|/* All the important work is done.  Now just remove temp files */
ifdef|#
directive|ifdef
name|LEAVE_TMPCF_FILES
block|{
name|struct
name|stat
name|tfstat
decl_stmt|;
name|size_t
name|size1
decl_stmt|;
name|tfstat
operator|.
name|st_size
operator|=
literal|1
expr_stmt|;
comment|/* certainly invalid value */
name|res
operator|=
name|stat
argument_list|(
name|tfname
argument_list|,
operator|&
name|tfstat
argument_list|)
expr_stmt|;
name|size1
operator|=
name|tfstat
operator|.
name|st_size
expr_stmt|;
name|tfstat
operator|.
name|st_size
operator|=
literal|2
expr_stmt|;
comment|/* certainly invalid value */
name|res
operator|=
name|stat
argument_list|(
name|tfname2
argument_list|,
operator|&
name|tfstat
argument_list|)
expr_stmt|;
comment|/* if the sizes do not match, or either stat call failed, 		 * then do not remove the temp files, but return "all OK". 		 * This is just so I can see what this routine had changed. 		 */
if|if
condition|(
name|size1
operator|!=
name|tfstat
operator|.
name|st_size
condition|)
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tfname2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|error_ret
label|:
if|if
condition|(
name|cjinf
operator|!=
name|NULL
condition|)
name|ctl_freeinf
argument_list|(
name|cjinf
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcf
operator|!=
name|NULL
condition|)
name|fclose
argument_list|(
name|newcf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errm
operator|!=
literal|'\0'
condition|)
return|return
name|strdup
argument_list|(
name|errm
argument_list|)
return|;
return|return
name|strdup
argument_list|(
literal|"ctl_renametf internal (missed) error"
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ctl_rewindcf
parameter_list|(
name|struct
name|cjobinfo
modifier|*
name|cjinf
parameter_list|)
block|{
name|struct
name|cjprivate
modifier|*
name|cpriv
decl_stmt|;
if|if
condition|(
name|cjinf
operator|==
name|NULL
condition|)
return|return;
name|cpriv
operator|=
name|cjinf
operator|->
name|cji_priv
expr_stmt|;
if|if
condition|(
operator|(
name|cpriv
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cpriv
operator|!=
name|cpriv
operator|->
name|pub
operator|.
name|cji_priv
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"in ctl_rewindcf(%p): invalid cjinf (cpriv %p)"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cjinf
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cpriv
argument_list|)
expr_stmt|;
return|return;
block|}
name|rewind
argument_list|(
name|cpriv
operator|->
name|cji_fstream
argument_list|)
expr_stmt|;
comment|/* assume no errors... :-) */
block|}
end_function

begin_function
name|char
modifier|*
name|ctl_rmjob
parameter_list|(
specifier|const
name|char
modifier|*
name|ptrname
parameter_list|,
specifier|const
name|char
modifier|*
name|cfname
parameter_list|)
block|{
name|struct
name|cjobinfo
modifier|*
name|cjinf
decl_stmt|;
name|char
modifier|*
name|lbuff
decl_stmt|;
name|char
name|errm
index|[
name|CTI_LINEMAX
index|]
decl_stmt|;
name|cjinf
operator|=
name|ctl_readcf
argument_list|(
name|ptrname
argument_list|,
name|cfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cjinf
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|errm
argument_list|,
sizeof|sizeof
argument_list|(
name|errm
argument_list|)
argument_list|,
literal|"ctl_renametf error cti_readcf(%s)"
argument_list|,
name|cfname
argument_list|)
expr_stmt|;
return|return
name|strdup
argument_list|(
name|errm
argument_list|)
return|;
block|}
name|ctl_rewindcf
argument_list|(
name|cjinf
argument_list|)
expr_stmt|;
name|lbuff
operator|=
name|ctl_getline
argument_list|(
name|cjinf
argument_list|)
expr_stmt|;
while|while
condition|(
name|lbuff
operator|!=
name|NULL
condition|)
block|{
comment|/* obviously we need to fill in the following... */
switch|switch
condition|(
name|lbuff
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'S'
case|:
break|break;
case|case
literal|'U'
case|:
break|break;
default|default:
break|break;
block|}
name|lbuff
operator|=
name|ctl_getline
argument_list|(
name|cjinf
argument_list|)
expr_stmt|;
block|}
name|ctl_freeinf
argument_list|(
name|cjinf
argument_list|)
expr_stmt|;
name|cjinf
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * The following routine was originally written to pin down a bug.  It is  * no longer needed for that problem, but may be useful to keep around for  * other debugging.  */
end_comment

begin_function
name|void
name|ctl_dumpcji
parameter_list|(
name|FILE
modifier|*
name|dbg_stream
parameter_list|,
specifier|const
name|char
modifier|*
name|heading
parameter_list|,
name|struct
name|cjobinfo
modifier|*
name|cjinf
parameter_list|)
block|{
define|#
directive|define
name|PRINTSTR
parameter_list|(
name|xHdr
parameter_list|,
name|xStr
parameter_list|)
define|\
value|astr = xStr; \ 	ctl_dbgline++; \ 	fprintf(dbg_stream, "%4d] %12s = ", ctl_dbgline, xHdr); \ 	if (astr == NULL) \ 		fprintf(dbg_stream, "NULL\n"); \ 	else \ 		fprintf(dbg_stream, "%p -> %s\n", astr, astr)
name|struct
name|cjprivate
modifier|*
name|cpriv
decl_stmt|;
name|char
modifier|*
name|astr
decl_stmt|;
if|if
condition|(
name|cjinf
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|dbg_stream
argument_list|,
literal|"ctl_dumpcji: ptr to cjobinfo for '%s' is NULL\n"
argument_list|,
name|heading
argument_list|)
expr_stmt|;
return|return;
block|}
name|cpriv
operator|=
name|cjinf
operator|->
name|cji_priv
expr_stmt|;
name|fprintf
argument_list|(
name|dbg_stream
argument_list|,
literal|"ctl_dumpcji: Dump '%s' of cjobinfo at %p->%p\n"
argument_list|,
name|heading
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cjinf
argument_list|,
name|cpriv
operator|->
name|cji_buff
argument_list|)
expr_stmt|;
name|PRINTSTR
argument_list|(
literal|"accthost.H"
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_accthost
argument_list|)
expr_stmt|;
name|PRINTSTR
argument_list|(
literal|"acctuser.P"
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_acctuser
argument_list|)
expr_stmt|;
name|PRINTSTR
argument_list|(
literal|"class.C"
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_class
argument_list|)
expr_stmt|;
name|PRINTSTR
argument_list|(
literal|"cf-qname"
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_curqueue
argument_list|)
expr_stmt|;
name|PRINTSTR
argument_list|(
literal|"cf-fname"
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_fname
argument_list|)
expr_stmt|;
name|PRINTSTR
argument_list|(
literal|"jobname.J"
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_jobname
argument_list|)
expr_stmt|;
name|PRINTSTR
argument_list|(
literal|"mailto.M"
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_mailto
argument_list|)
expr_stmt|;
name|PRINTSTR
argument_list|(
literal|"hdruser.L"
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_username
argument_list|)
expr_stmt|;
name|ctl_dbgline
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|dbg_stream
argument_list|,
literal|"%4d] %12s = "
argument_list|,
name|ctl_dbgline
argument_list|,
literal|"*cjprivate"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpriv
operator|->
name|pub
operator|.
name|cji_priv
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|dbg_stream
argument_list|,
literal|"NULL !!\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dbg_stream
argument_list|,
literal|"%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cpriv
operator|->
name|pub
operator|.
name|cji_priv
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbg_stream
argument_list|,
literal|"|- - - - --> Dump '%s' complete\n"
argument_list|,
name|heading
argument_list|)
expr_stmt|;
comment|/* flush output for the benefit of anyone doing a 'tail -f' */
name|fflush
argument_list|(
name|dbg_stream
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PRINTSTR
block|}
end_function

begin_comment
comment|/*  * This routine reads in the next line from the control-file, and removes  * the trailing newline character.  *  * Historical note: Earlier versions of this routine did tab-expansion for  * ALL lines read in, which did not make any sense for most of the lines  * in a control file.  For the lines where tab-expansion is useful, it will  * now have to be done by the calling routine.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ctl_getline
parameter_list|(
name|struct
name|cjobinfo
modifier|*
name|cjinf
parameter_list|)
block|{
name|char
modifier|*
name|strp
decl_stmt|,
modifier|*
name|nl
decl_stmt|;
name|struct
name|cjprivate
modifier|*
name|cpriv
decl_stmt|;
if|if
condition|(
name|cjinf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|cpriv
operator|=
name|cjinf
operator|->
name|cji_priv
expr_stmt|;
if|if
condition|(
operator|(
name|cpriv
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cpriv
operator|!=
name|cpriv
operator|->
name|pub
operator|.
name|cji_priv
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"in ctl_getline(%p): invalid cjinf (cpriv %p)"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cjinf
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cpriv
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|strp
operator|=
name|fgets
argument_list|(
name|cpriv
operator|->
name|cji_buff
argument_list|,
name|cpriv
operator|->
name|cji_buffsize
argument_list|,
name|cpriv
operator|->
name|cji_fstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|strp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: ctl_getline error fgets(%s): %s"
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_curqueue
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_fname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|nl
operator|=
name|strchr
argument_list|(
name|strp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|!=
name|NULL
condition|)
operator|*
name|nl
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGREADCF_FNAME
comment|/* I'd like to find out if the previous work to expand tabs was ever 	 * really used, and if so, on what lines and for what reason. 	 * Yes, all this work probably means I'm obsessed about this 'tab' 	 * issue, but isn't programming a matter of obsession? 	 */
block|{
name|int
name|tabcnt
decl_stmt|;
name|char
modifier|*
name|ch
decl_stmt|;
name|tabcnt
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|strp
expr_stmt|;
for|for
control|(
name|ch
operator|=
name|strp
init|;
operator|*
name|ch
operator|!=
literal|'\0'
condition|;
name|ch
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|ch
operator|==
literal|'\t'
condition|)
name|tabcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tabcnt
operator|&&
operator|(
name|ctl_dbgfile
operator|!=
name|NULL
operator|)
condition|)
block|{
name|cpriv
operator|->
name|cji_dumpit
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|ctl_dbgfile
argument_list|,
literal|"%s: tabs=%d '%s'\n"
argument_list|,
name|cpriv
operator|->
name|pub
operator|.
name|cji_fname
argument_list|,
name|tabcnt
argument_list|,
name|cpriv
operator|->
name|cji_buff
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|strp
return|;
block|}
end_function

end_unit

