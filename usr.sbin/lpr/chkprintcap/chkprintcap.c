begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1997 Massachusetts Institute of Technology  *  * Permission to use, copy, modify, and distribute this software and  * its documentation for any purpose and without fee is hereby  * granted, provided that both the above copyright notice and this  * permission notice appear in all copies, that both the above  * copyright notice and this permission notice appear in all  * supporting documentation, and that the name of M.I.T. not be used  * in advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  M.I.T. makes  * no representations about the suitability of this software for any  * purpose.  It is provided "as is" without express or implied  * warranty.  *   * THIS SOFTWARE IS PROVIDED BY M.I.T. ``AS IS''.  M.I.T. DISCLAIMS  * ALL EXPRESS OR IMPLIED WARRANTIES WITH REGARD TO THIS SOFTWARE,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT  * SHALL M.I.T. BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT  * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"Copyright (C) 1997, Massachusetts Institute of Technology\r\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: chkprintcap.c,v 1.1 1997/12/02 20:45:11 wollman Exp $"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* needed for lp.h but not used here */
end_comment

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_comment
comment|/* ditto */
end_comment

begin_include
include|#
directive|include
file|"lp.h"
end_include

begin_include
include|#
directive|include
file|"lp.local.h"
end_include

begin_function_decl
specifier|static
name|void
name|check_spool_dirs
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|interpret_error
parameter_list|(
specifier|const
name|struct
name|printer
modifier|*
name|pp
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_spool_dir
parameter_list|(
specifier|const
name|struct
name|printer
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_spool_dir
parameter_list|(
specifier|const
name|struct
name|printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
name|st
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
name|void
argument_list|)
name|__dead2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|problems
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of problems encountered */
end_comment

begin_comment
comment|/*  * chkprintcap - check the printcap file for syntactic and semantic errors  * Returns the number of problems found.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|error
decl_stmt|,
name|makedirs
decl_stmt|,
name|more
decl_stmt|;
name|struct
name|printer
name|myprinter
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|makedirs
operator|=
literal|0
expr_stmt|;
name|pp
operator|=
operator|&
name|myprinter
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"df:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|makedirs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|setprintcap
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|more
operator|=
name|firstprinter
argument_list|(
name|pp
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|interpret_error
argument_list|(
name|pp
argument_list|,
name|error
argument_list|)
operator|&&
name|more
condition|)
goto|goto
name|next
goto|;
while|while
condition|(
name|more
condition|)
block|{
name|struct
name|stat
name|stab
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|pp
operator|->
name|spool_dir
argument_list|,
operator|&
name|stab
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
operator|&&
name|makedirs
condition|)
block|{
name|make_spool_dir
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|problems
operator|++
expr_stmt|;
name|warn
argument_list|(
literal|"%s: %s"
argument_list|,
name|pp
operator|->
name|printer
argument_list|,
name|pp
operator|->
name|spool_dir
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|note_spool_dir
argument_list|(
name|pp
argument_list|,
operator|&
name|stab
argument_list|)
expr_stmt|;
block|}
comment|/* Make other validity checks here... */
name|next
label|:
name|more
operator|=
name|nextprinter
argument_list|(
name|pp
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|interpret_error
argument_list|(
name|pp
argument_list|,
name|error
argument_list|)
operator|&&
name|more
condition|)
goto|goto
name|next
goto|;
block|}
name|check_spool_dirs
argument_list|()
expr_stmt|;
return|return
name|problems
return|;
block|}
end_function

begin_comment
comment|/*  * Interpret the error code.  Returns 1 if we should skip to the next  * record (as this record is unlikely to make sense).  If the problem  * is very severe, exit.  Otherwise, return zero.  */
end_comment

begin_function
specifier|static
name|int
name|interpret_error
parameter_list|(
specifier|const
name|struct
name|printer
modifier|*
name|pp
parameter_list|,
name|int
name|error
parameter_list|)
block|{
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|PCAPERR_OSERR
case|:
name|err
argument_list|(
operator|++
name|problems
argument_list|,
literal|"reading printer database"
argument_list|)
expr_stmt|;
case|case
name|PCAPERR_TCLOOP
case|:
operator|++
name|problems
expr_stmt|;
name|warnx
argument_list|(
literal|"%s: loop detected in tc= expansion"
argument_list|,
name|pp
operator|->
name|printer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|PCAPERR_TCOPEN
case|:
name|warnx
argument_list|(
literal|"%s: unresolved tc= expansion"
argument_list|,
name|pp
operator|->
name|printer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|PCAPERR_SUCCESS
case|:
break|break;
default|default:
name|errx
argument_list|(
operator|++
name|problems
argument_list|,
literal|"unknown printcap library error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Keep the list of spool directories.  Note that we don't whine  * until all spool directories are noted, so that all of the more serious  * problems are noted first.  We keep the list sorted by st_dev and  * st_ino, so that the problem spool directories can be noted in  * a single loop.  */
end_comment

begin_struct
struct|struct
name|dirlist
block|{
name|LIST_ENTRY
argument_list|(
argument|dirlist
argument_list|)
name|link
expr_stmt|;
name|struct
name|stat
name|stab
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|printer
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|dirlist
argument_list|)
name|dirlist
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|lessp
parameter_list|(
specifier|const
name|struct
name|dirlist
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|dirlist
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|stab
operator|.
name|st_dev
operator|==
name|b
operator|->
name|stab
operator|.
name|st_dev
condition|)
return|return
name|a
operator|->
name|stab
operator|.
name|st_ino
operator|<
name|b
operator|->
name|stab
operator|.
name|st_ino
return|;
return|return
name|a
operator|->
name|stab
operator|.
name|st_dev
operator|<
name|b
operator|->
name|stab
operator|.
name|st_dev
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|equal
parameter_list|(
specifier|const
name|struct
name|dirlist
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|dirlist
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
operator|(
name|a
operator|->
name|stab
operator|.
name|st_dev
operator|==
name|b
operator|->
name|stab
operator|.
name|st_dev
operator|)
operator|&&
operator|(
name|a
operator|->
name|stab
operator|.
name|st_ino
operator|==
name|b
operator|->
name|stab
operator|.
name|st_ino
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|note_spool_dir
parameter_list|(
specifier|const
name|struct
name|printer
modifier|*
name|pp
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|dirlist
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp2
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|dp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
name|err
argument_list|(
operator|++
name|problems
argument_list|,
literal|"malloc(%lu)"
argument_list|,
operator|(
name|u_long
operator|)
sizeof|sizeof
expr|*
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|stab
operator|=
operator|*
name|st
expr_stmt|;
name|dp
operator|->
name|printer
operator|=
name|strdup
argument_list|(
name|pp
operator|->
name|printer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|printer
operator|==
literal|0
condition|)
name|err
argument_list|(
operator|++
name|problems
argument_list|,
literal|"malloc(%lu)"
argument_list|,
name|strlen
argument_list|(
name|pp
operator|->
name|printer
argument_list|)
operator|+
literal|1UL
argument_list|)
expr_stmt|;
name|dp
operator|->
name|path
operator|=
name|strdup
argument_list|(
name|pp
operator|->
name|spool_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|path
operator|==
literal|0
condition|)
name|err
argument_list|(
operator|++
name|problems
argument_list|,
literal|"malloc(%lu)"
argument_list|,
name|strlen
argument_list|(
name|pp
operator|->
name|spool_dir
argument_list|)
operator|+
literal|1UL
argument_list|)
expr_stmt|;
name|last
operator|=
literal|0
expr_stmt|;
name|dp2
operator|=
name|dirlist
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|dp2
operator|&&
name|lessp
argument_list|(
name|dp
argument_list|,
name|dp2
argument_list|)
condition|)
block|{
name|last
operator|=
name|dp2
expr_stmt|;
name|dp2
operator|=
name|dp2
operator|->
name|link
operator|.
name|le_next
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|last
argument_list|,
name|dp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|dirlist
argument_list|,
name|dp
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|check_spool_dirs
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dirlist
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp2
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|dirlist
operator|.
name|lh_first
init|;
name|dp
condition|;
name|dp
operator|=
name|dp2
control|)
block|{
name|dp2
operator|=
name|dp
operator|->
name|link
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
name|dp2
operator|!=
literal|0
operator|&&
name|equal
argument_list|(
name|dp
argument_list|,
name|dp2
argument_list|)
condition|)
block|{
operator|++
name|problems
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|path
argument_list|,
name|dp2
operator|->
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s and %s share the same spool, %s"
argument_list|,
name|dp
operator|->
name|printer
argument_list|,
name|dp2
operator|->
name|printer
argument_list|,
name|dp
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"%s (%s) and %s (%s) are the same "
literal|"directory"
argument_list|,
name|dp
operator|->
name|path
argument_list|,
name|dp
operator|->
name|printer
argument_list|,
name|dp2
operator|->
name|path
argument_list|,
name|dp2
operator|->
name|printer
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Should probably check owners and modes here. */
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SPOOL_DIR_MODE
end_ifndef

begin_define
define|#
directive|define
name|SPOOL_DIR_MODE
value|(S_IRUSR | S_IWUSR | S_IXUSR \ 			 | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|make_spool_dir
parameter_list|(
specifier|const
name|struct
name|printer
modifier|*
name|pp
parameter_list|)
block|{
name|char
modifier|*
name|sd
init|=
name|pp
operator|->
name|spool_dir
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
name|struct
name|stat
name|stab
decl_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|sd
argument_list|,
name|S_IRUSR
operator||
name|S_IXUSR
argument_list|)
operator|<
literal|0
condition|)
block|{
name|problems
operator|++
expr_stmt|;
name|warn
argument_list|(
literal|"%s: mkdir %s"
argument_list|,
name|pp
operator|->
name|printer
argument_list|,
name|sd
argument_list|)
expr_stmt|;
return|return;
block|}
name|gr
operator|=
name|getgrnam
argument_list|(
literal|"daemon"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|==
literal|0
condition|)
name|errx
argument_list|(
operator|++
name|problems
argument_list|,
literal|"cannot locate daemon group"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chown
argument_list|(
name|sd
argument_list|,
name|pp
operator|->
name|daemon_user
argument_list|,
name|gr
operator|->
name|gr_gid
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|++
name|problems
expr_stmt|;
name|warn
argument_list|(
literal|"%s: cannot change ownership to %ld:%ld"
argument_list|,
name|sd
argument_list|,
operator|(
name|long
operator|)
name|pp
operator|->
name|daemon_user
argument_list|,
operator|(
name|long
operator|)
name|gr
operator|->
name|gr_gid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chmod
argument_list|(
name|sd
argument_list|,
name|SPOOL_DIR_MODE
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|++
name|problems
expr_stmt|;
name|warn
argument_list|(
literal|"%s: cannot change mode to %lo"
argument_list|,
name|sd
argument_list|,
operator|(
name|long
operator|)
name|SPOOL_DIR_MODE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
argument_list|(
name|sd
argument_list|,
operator|&
name|stab
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
operator|++
name|problems
argument_list|,
literal|"stat: %s"
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|note_spool_dir
argument_list|(
name|pp
argument_list|,
operator|&
name|stab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:\n\tchkprintcap [-d] [-f printcapfile]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

