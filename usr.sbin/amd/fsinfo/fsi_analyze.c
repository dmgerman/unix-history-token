begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Jan-Simon Pendry  * Copyright (c) 1989 Imperial College of Science, Technology& Medicine  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)fsi_analyze.c	8.1 (Berkeley) 6/6/93  *  * $Id$  *  */
end_comment

begin_comment
comment|/*  * Analyze filesystem declarations  *  * Note: most of this is magic!  */
end_comment

begin_include
include|#
directive|include
file|"../fsinfo/fsinfo.h"
end_include

begin_decl_stmt
name|char
modifier|*
name|disk_fs_strings
index|[]
init|=
block|{
literal|"fstype"
block|,
literal|"opts"
block|,
literal|"dumpset"
block|,
literal|"passno"
block|,
literal|"freq"
block|,
literal|"mount"
block|,
literal|"log"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mount_strings
index|[]
init|=
block|{
literal|"volname"
block|,
literal|"exportfs"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fsmount_strings
index|[]
init|=
block|{
literal|"as"
block|,
literal|"volname"
block|,
literal|"fstype"
block|,
literal|"opts"
block|,
literal|"from"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|host_strings
index|[]
init|=
block|{
literal|"host"
block|,
literal|"netif"
block|,
literal|"config"
block|,
literal|"arch"
block|,
literal|"cluster"
block|,
literal|"os"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ether_if_strings
index|[]
init|=
block|{
literal|"inaddr"
block|,
literal|"netmask"
block|,
literal|"hwaddr"
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Strip off the trailing part of a domain  * to produce a short-form domain relative  * to the local host domain.  * Note that this has no effect if the domain  * names do not have the same number of  * components.  If that restriction proves  * to be a problem then the loop needs recoding  * to skip from right to left and do partial  * matches along the way -- ie more expensive.  */
end_comment

begin_function
name|void
name|domain_strip
parameter_list|(
name|otherdom
parameter_list|,
name|localdom
parameter_list|)
name|char
modifier|*
name|otherdom
decl_stmt|,
decl|*
name|localdom
decl_stmt|;
end_function

begin_block
block|{
ifdef|#
directive|ifdef
name|PARTIAL_DOMAINS
name|char
modifier|*
name|p1
init|=
name|otherdom
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|p2
init|=
name|localdom
operator|-
literal|1
decl_stmt|;
do|do
block|{
if|if
condition|(
name|p1
operator|=
name|strchr
argument_list|(
name|p1
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
condition|)
if|if
condition|(
name|p2
operator|=
name|strchr
argument_list|(
name|p2
operator|+
literal|1
argument_list|,
literal|'.'
argument_list|)
condition|)
if|if
condition|(
name|STREQ
argument_list|(
name|p1
operator|+
literal|1
argument_list|,
name|p2
operator|+
literal|1
argument_list|)
condition|)
block|{
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|p1
operator|&&
name|p2
condition|)
do|;
else|#
directive|else
name|char
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
if|if
condition|(
operator|(
name|p1
operator|=
name|strchr
argument_list|(
name|otherdom
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|(
name|p2
operator|=
name|strchr
argument_list|(
name|localdom
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|p1
operator|+
literal|1
argument_list|,
name|p2
operator|+
literal|1
argument_list|)
operator|==
literal|0
operator|)
condition|)
operator|*
name|p1
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
comment|/* PARTIAL_DOMAINS */
block|}
end_block

begin_comment
comment|/*  * Take a little-endian domain name and  * transform into a big-endian Un*x pathname.  * For example: kiska.doc.ic -> ic/doc/kiska  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|compute_hostpath
parameter_list|(
name|hn
parameter_list|)
name|char
modifier|*
name|hn
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|strdup
argument_list|(
name|hn
argument_list|)
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|domain_strip
argument_list|(
name|p
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|path
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
name|d
operator|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
operator|*
name|d
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|d
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|path
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|d
condition|)
do|;
name|log
argument_list|(
literal|"hostpath of '%s' is '%s'"
argument_list|,
name|hn
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|dict_ent
modifier|*
name|find_volname
parameter_list|(
name|nn
parameter_list|)
name|char
modifier|*
name|nn
decl_stmt|;
block|{
name|dict_ent
modifier|*
name|de
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|strdup
argument_list|(
name|nn
argument_list|)
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
do|do
block|{
name|log
argument_list|(
literal|"Searching for volname %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|de
operator|=
name|dict_locate
argument_list|(
name|dict_of_volnames
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|strrchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|de
operator|&&
name|q
condition|)
do|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|de
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|show_required
argument_list|(
argument|l
argument_list|,
argument|mask
argument_list|,
argument|info
argument_list|,
argument|hostname
argument_list|,
argument|strings
argument_list|)
name|ioloc
operator|*
name|l
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|strings
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|log
argument_list|(
literal|"mask left for %s:%s is %#x"
argument_list|,
name|hostname
argument_list|,
name|info
argument_list|,
name|mask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|strings
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ISSET
argument_list|(
name|mask
argument_list|,
name|i
argument_list|)
condition|)
name|lerror
argument_list|(
name|l
argument_list|,
literal|"%s:%s needs field \"%s\""
argument_list|,
name|hostname
argument_list|,
name|info
argument_list|,
name|strings
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Check and fill in "exportfs" details.  * Make sure the m_exported field references  * the most local node with an "exportfs" entry.  */
end_comment

begin_function
specifier|static
name|int
name|check_exportfs
parameter_list|(
name|q
parameter_list|,
name|e
parameter_list|)
name|qelem
modifier|*
name|q
decl_stmt|;
name|mount
modifier|*
name|e
decl_stmt|;
block|{
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|ITER
argument_list|(
argument|mp
argument_list|,
argument|mount
argument_list|,
argument|q
argument_list|)
block|{
if|if
condition|(
name|ISSET
argument_list|(
name|mp
operator|->
name|m_mask
argument_list|,
name|DM_EXPORTFS
argument_list|)
condition|)
block|{
if|if
condition|(
name|e
condition|)
name|lwarning
argument_list|(
name|mp
operator|->
name|m_ioloc
argument_list|,
literal|"%s has duplicate exportfs data"
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_exported
operator|=
name|mp
expr_stmt|;
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|mp
operator|->
name|m_mask
argument_list|,
name|DM_VOLNAME
argument_list|)
condition|)
name|set_mount
argument_list|(
name|mp
argument_list|,
name|DM_VOLNAME
argument_list|,
name|strdup
argument_list|(
name|mp
operator|->
name|m_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_exported
operator|=
name|e
expr_stmt|;
block|}
comment|/* 		 * Recursively descend the mount tree 		 */
if|if
condition|(
name|mp
operator|->
name|m_mount
condition|)
name|errors
operator|+=
name|check_exportfs
argument_list|(
name|mp
operator|->
name|m_mount
argument_list|,
name|mp
operator|->
name|m_exported
argument_list|)
expr_stmt|;
comment|/* 		 * If a volume name has been specified, but this node and none 		 * of its parents has been exported, report an error. 		 */
if|if
condition|(
name|ISSET
argument_list|(
name|mp
operator|->
name|m_mask
argument_list|,
name|DM_VOLNAME
argument_list|)
operator|&&
operator|!
name|mp
operator|->
name|m_exported
condition|)
block|{
name|lerror
argument_list|(
name|mp
operator|->
name|m_ioloc
argument_list|,
literal|"%s has a volname but no exportfs data"
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
block|}
return|return
name|errors
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|analyze_dkmount_tree
parameter_list|(
name|q
parameter_list|,
name|parent
parameter_list|,
name|dk
parameter_list|)
name|qelem
modifier|*
name|q
decl_stmt|;
name|mount
modifier|*
name|parent
decl_stmt|;
name|disk_fs
modifier|*
name|dk
decl_stmt|;
block|{
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|ITER
argument_list|(
argument|mp
argument_list|,
argument|mount
argument_list|,
argument|q
argument_list|)
block|{
name|log
argument_list|(
literal|"Mount %s:"
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|char
name|n
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|n
argument_list|,
literal|"%s/%s"
argument_list|,
name|parent
operator|->
name|m_name
argument_list|,
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|->
name|m_name
operator|==
literal|'/'
condition|)
name|lerror
argument_list|(
name|mp
operator|->
name|m_ioloc
argument_list|,
literal|"sub-directory %s of %s starts with '/'"
argument_list|,
name|mp
operator|->
name|m_name
argument_list|,
name|parent
operator|->
name|m_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|mp
operator|->
name|m_name
argument_list|,
literal|"default"
argument_list|)
condition|)
name|lwarning
argument_list|(
name|mp
operator|->
name|m_ioloc
argument_list|,
literal|"sub-directory of %s is named \"default\""
argument_list|,
name|parent
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"Changing name %s to %s"
argument_list|,
name|mp
operator|->
name|m_name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_name
operator|=
name|strdup
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|mp
operator|->
name|m_name_len
operator|=
name|strlen
argument_list|(
name|mp
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_parent
operator|=
name|parent
expr_stmt|;
name|mp
operator|->
name|m_dk
operator|=
name|dk
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_mount
condition|)
name|analyze_dkmount_tree
argument_list|(
name|mp
operator|->
name|m_mount
argument_list|,
name|mp
argument_list|,
name|dk
argument_list|)
expr_stmt|;
block|}
return|return
name|errors
return|;
block|}
end_function

begin_comment
comment|/*  * The mount tree is a singleton list  * containing the top-level mount  * point for a disk.  */
end_comment

begin_function
specifier|static
name|int
name|analyze_dkmounts
parameter_list|(
name|dk
parameter_list|,
name|q
parameter_list|)
name|disk_fs
modifier|*
name|dk
decl_stmt|;
name|qelem
modifier|*
name|q
decl_stmt|;
block|{
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|mount
modifier|*
name|mp
decl_stmt|,
modifier|*
name|mp2
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* 	 * First scan the list of subdirs to make 	 * sure there is only one - and remember it 	 */
if|if
condition|(
name|q
condition|)
block|{
name|ITER
argument_list|(
argument|mp
argument_list|,
argument|mount
argument_list|,
argument|q
argument_list|)
block|{
name|mp2
operator|=
name|mp
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Check... 	 */
if|if
condition|(
name|i
operator|<
literal|1
condition|)
block|{
name|lerror
argument_list|(
name|dk
operator|->
name|d_ioloc
argument_list|,
literal|"%s:%s has no mount point"
argument_list|,
name|dk
operator|->
name|d_host
operator|->
name|h_hostname
argument_list|,
name|dk
operator|->
name|d_dev
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|lerror
argument_list|(
name|dk
operator|->
name|d_ioloc
argument_list|,
literal|"%s:%s has more than one mount point"
argument_list|,
name|dk
operator|->
name|d_host
operator|->
name|h_hostname
argument_list|,
name|dk
operator|->
name|d_dev
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
comment|/* 	 * Now see if a default mount point is required 	 */
if|if
condition|(
name|STREQ
argument_list|(
name|mp2
operator|->
name|m_name
argument_list|,
literal|"default"
argument_list|)
condition|)
block|{
if|if
condition|(
name|ISSET
argument_list|(
name|mp2
operator|->
name|m_mask
argument_list|,
name|DM_VOLNAME
argument_list|)
condition|)
block|{
name|char
name|nbuf
index|[
literal|1024
index|]
decl_stmt|;
name|compute_automount_point
argument_list|(
name|nbuf
argument_list|,
name|dk
operator|->
name|d_host
argument_list|,
name|mp2
operator|->
name|m_volname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mp2
operator|->
name|m_name
argument_list|)
expr_stmt|;
name|mp2
operator|->
name|m_name
operator|=
name|strdup
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"%s:%s has default mount on %s"
argument_list|,
name|dk
operator|->
name|d_host
operator|->
name|h_hostname
argument_list|,
name|dk
operator|->
name|d_dev
argument_list|,
name|mp2
operator|->
name|m_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lerror
argument_list|(
name|dk
operator|->
name|d_ioloc
argument_list|,
literal|"no volname given for %s:%s"
argument_list|,
name|dk
operator|->
name|d_host
operator|->
name|h_hostname
argument_list|,
name|dk
operator|->
name|d_dev
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Fill in the disk mount point 	 */
if|if
condition|(
operator|!
name|errors
operator|&&
name|mp2
operator|&&
name|mp2
operator|->
name|m_name
condition|)
name|dk
operator|->
name|d_mountpt
operator|=
name|strdup
argument_list|(
name|mp2
operator|->
name|m_name
argument_list|)
expr_stmt|;
else|else
name|dk
operator|->
name|d_mountpt
operator|=
name|strdup
argument_list|(
literal|"error"
argument_list|)
expr_stmt|;
comment|/* 	 * Analyze the mount tree 	 */
name|errors
operator|+=
name|analyze_dkmount_tree
argument_list|(
name|q
argument_list|,
literal|0
argument_list|,
name|dk
argument_list|)
expr_stmt|;
comment|/* 	 * Analyze the export tree 	 */
name|errors
operator|+=
name|check_exportfs
argument_list|(
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|errors
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fixup_required_disk_info
parameter_list|(
name|dp
parameter_list|)
name|disk_fs
modifier|*
name|dp
decl_stmt|;
block|{
comment|/* 	 * "fstype" 	 */
if|if
condition|(
name|ISSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_FSTYPE
argument_list|)
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|dp
operator|->
name|d_fstype
argument_list|,
literal|"swap"
argument_list|)
condition|)
block|{
comment|/* 			 * Fixup for a swap device 			 */
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_PASSNO
argument_list|)
condition|)
block|{
name|dp
operator|->
name|d_passno
operator|=
literal|0
expr_stmt|;
name|BITSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_PASSNO
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|d_freq
operator|!=
literal|0
condition|)
block|{
name|lwarning
argument_list|(
name|dp
operator|->
name|d_ioloc
argument_list|,
literal|"Pass number for %s:%s is non-zero"
argument_list|,
name|dp
operator|->
name|d_host
operator|->
name|h_hostname
argument_list|,
name|dp
operator|->
name|d_dev
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * "freq" 			 */
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_FREQ
argument_list|)
condition|)
block|{
name|dp
operator|->
name|d_freq
operator|=
literal|0
expr_stmt|;
name|BITSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_FREQ
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|d_freq
operator|!=
literal|0
condition|)
block|{
name|lwarning
argument_list|(
name|dp
operator|->
name|d_ioloc
argument_list|,
literal|"dump frequency for %s:%s is non-zero"
argument_list|,
name|dp
operator|->
name|d_host
operator|->
name|h_hostname
argument_list|,
name|dp
operator|->
name|d_dev
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * "opts" 			 */
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_OPTS
argument_list|)
condition|)
name|set_disk_fs
argument_list|(
name|dp
argument_list|,
name|DF_OPTS
argument_list|,
name|strdup
argument_list|(
literal|"swap"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * "mount" 			 */
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_MOUNT
argument_list|)
condition|)
block|{
name|qelem
modifier|*
name|q
init|=
name|new_que
argument_list|()
decl_stmt|;
name|mount
modifier|*
name|m
init|=
name|new_mount
argument_list|()
decl_stmt|;
name|m
operator|->
name|m_name
operator|=
name|strdup
argument_list|(
literal|"swap"
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_mount
operator|=
name|new_que
argument_list|()
expr_stmt|;
name|ins_que
argument_list|(
operator|&
name|m
operator|->
name|m_q
argument_list|,
name|q
operator|->
name|q_back
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_mount
operator|=
name|q
expr_stmt|;
name|BITSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_MOUNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lerror
argument_list|(
name|dp
operator|->
name|d_ioloc
argument_list|,
literal|"%s: mount field specified for swap partition"
argument_list|,
name|dp
operator|->
name|d_host
operator|->
name|h_hostname
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|dp
operator|->
name|d_fstype
argument_list|,
literal|"export"
argument_list|)
condition|)
block|{
comment|/* 			 * "passno" 			 */
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_PASSNO
argument_list|)
condition|)
block|{
name|dp
operator|->
name|d_passno
operator|=
literal|0
expr_stmt|;
name|BITSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_PASSNO
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|d_passno
operator|!=
literal|0
condition|)
block|{
name|lwarning
argument_list|(
name|dp
operator|->
name|d_ioloc
argument_list|,
literal|"pass number for %s:%s is non-zero"
argument_list|,
name|dp
operator|->
name|d_host
operator|->
name|h_hostname
argument_list|,
name|dp
operator|->
name|d_dev
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * "freq" 			 */
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_FREQ
argument_list|)
condition|)
block|{
name|dp
operator|->
name|d_freq
operator|=
literal|0
expr_stmt|;
name|BITSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_FREQ
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|d_freq
operator|!=
literal|0
condition|)
block|{
name|lwarning
argument_list|(
name|dp
operator|->
name|d_ioloc
argument_list|,
literal|"dump frequency for %s:%s is non-zero"
argument_list|,
name|dp
operator|->
name|d_host
operator|->
name|h_hostname
argument_list|,
name|dp
operator|->
name|d_dev
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * "opts" 			 */
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|dp
operator|->
name|d_mask
argument_list|,
name|DF_OPTS
argument_list|)
condition|)
name|set_disk_fs
argument_list|(
name|dp
argument_list|,
name|DF_OPTS
argument_list|,
name|strdup
argument_list|(
literal|"rw,defaults"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fixup_required_mount_info
parameter_list|(
name|fp
parameter_list|,
name|de
parameter_list|)
name|fsmount
modifier|*
name|fp
decl_stmt|;
name|dict_ent
modifier|*
name|de
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|fp
operator|->
name|f_mask
argument_list|,
name|FM_FROM
argument_list|)
condition|)
block|{
if|if
condition|(
name|de
operator|->
name|de_count
operator|!=
literal|1
condition|)
block|{
name|lerror
argument_list|(
name|fp
operator|->
name|f_ioloc
argument_list|,
literal|"ambiguous mount: %s is a replicated filesystem"
argument_list|,
name|fp
operator|->
name|f_volname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dict_data
modifier|*
name|dd
decl_stmt|;
name|mount
modifier|*
name|mp
init|=
literal|0
decl_stmt|;
name|ITER
argument_list|(
argument|dd
argument_list|,
argument|dict_data
argument_list|,
argument|&de->de_q
argument_list|)
block|{
name|mp
operator|=
operator|(
name|mount
operator|*
operator|)
name|dd
operator|->
name|dd_data
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|mp
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fp
operator|->
name|f_ref
operator|=
name|mp
expr_stmt|;
name|set_fsmount
argument_list|(
name|fp
argument_list|,
name|FM_FROM
argument_list|,
name|mp
operator|->
name|m_dk
operator|->
name|d_host
operator|->
name|h_hostname
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"set: %s comes from %s"
argument_list|,
name|fp
operator|->
name|f_volname
argument_list|,
name|fp
operator|->
name|f_from
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|fp
operator|->
name|f_mask
argument_list|,
name|FM_FSTYPE
argument_list|)
condition|)
block|{
name|set_fsmount
argument_list|(
name|fp
argument_list|,
name|FM_FSTYPE
argument_list|,
name|strdup
argument_list|(
literal|"nfs"
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"set: fstype is %s"
argument_list|,
name|fp
operator|->
name|f_fstype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|fp
operator|->
name|f_mask
argument_list|,
name|FM_OPTS
argument_list|)
condition|)
block|{
name|set_fsmount
argument_list|(
name|fp
argument_list|,
name|FM_OPTS
argument_list|,
name|strdup
argument_list|(
literal|"rw,nosuid,grpid,defaults"
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"set: opts are %s"
argument_list|,
name|fp
operator|->
name|f_opts
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|fp
operator|->
name|f_mask
argument_list|,
name|FM_LOCALNAME
argument_list|)
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|f_ref
condition|)
block|{
name|set_fsmount
argument_list|(
name|fp
argument_list|,
name|FM_LOCALNAME
argument_list|,
name|strdup
argument_list|(
name|fp
operator|->
name|f_volname
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"set: localname is %s"
argument_list|,
name|fp
operator|->
name|f_localname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lerror
argument_list|(
name|fp
operator|->
name|f_ioloc
argument_list|,
literal|"cannot determine localname since volname %s is not uniquely defined"
argument_list|,
name|fp
operator|->
name|f_volname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * For each disk on a host  * analyze the mount information  * and fill in any derivable  * details.  */
end_comment

begin_function
specifier|static
name|void
name|analyze_drives
parameter_list|(
name|hp
parameter_list|)
name|host
modifier|*
name|hp
decl_stmt|;
block|{
name|qelem
modifier|*
name|q
init|=
name|hp
operator|->
name|h_disk_fs
decl_stmt|;
name|disk_fs
modifier|*
name|dp
decl_stmt|;
name|ITER
argument_list|(
argument|dp
argument_list|,
argument|disk_fs
argument_list|,
argument|q
argument_list|)
block|{
name|int
name|req
decl_stmt|;
name|log
argument_list|(
literal|"Disk %s:"
argument_list|,
name|dp
operator|->
name|d_dev
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_host
operator|=
name|hp
expr_stmt|;
name|fixup_required_disk_info
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|req
operator|=
operator|~
name|dp
operator|->
name|d_mask
operator|&
name|DF_REQUIRED
expr_stmt|;
if|if
condition|(
name|req
condition|)
name|show_required
argument_list|(
name|dp
operator|->
name|d_ioloc
argument_list|,
name|req
argument_list|,
name|dp
operator|->
name|d_dev
argument_list|,
name|hp
operator|->
name|h_hostname
argument_list|,
name|disk_fs_strings
argument_list|)
expr_stmt|;
name|analyze_dkmounts
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|d_mount
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check that all static mounts make sense and  * that the source volumes exist.  */
end_comment

begin_function
specifier|static
name|void
name|analyze_mounts
parameter_list|(
name|hp
parameter_list|)
name|host
modifier|*
name|hp
decl_stmt|;
block|{
name|qelem
modifier|*
name|q
init|=
name|hp
operator|->
name|h_mount
decl_stmt|;
name|fsmount
modifier|*
name|fp
decl_stmt|;
name|int
name|netbootp
init|=
literal|0
decl_stmt|;
name|ITER
argument_list|(
argument|fp
argument_list|,
argument|fsmount
argument_list|,
argument|q
argument_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|nn
init|=
name|strdup
argument_list|(
name|fp
operator|->
name|f_volname
argument_list|)
decl_stmt|;
name|int
name|req
decl_stmt|;
name|dict_ent
modifier|*
name|de
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|matched
init|=
literal|0
decl_stmt|;
do|do
block|{
name|p
operator|=
literal|0
expr_stmt|;
name|de
operator|=
name|find_volname
argument_list|(
name|nn
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"Mount: %s (trying %s)"
argument_list|,
name|fp
operator|->
name|f_volname
argument_list|,
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
name|de
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
comment|/* 				 * Check that the from field is really exporting 				 * the filesystem requested. 				 */
if|if
condition|(
name|ISSET
argument_list|(
name|fp
operator|->
name|f_mask
argument_list|,
name|FM_FROM
argument_list|)
condition|)
block|{
name|dict_data
modifier|*
name|dd
decl_stmt|;
name|mount
modifier|*
name|mp2
init|=
literal|0
decl_stmt|;
name|ITER
argument_list|(
argument|dd
argument_list|,
argument|dict_data
argument_list|,
argument|&de->de_q
argument_list|)
block|{
name|mount
modifier|*
name|mp
init|=
operator|(
name|mount
operator|*
operator|)
name|dd
operator|->
name|dd_data
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|mp
operator|->
name|m_dk
operator|->
name|d_host
operator|->
name|h_hostname
argument_list|,
name|fp
operator|->
name|f_from
argument_list|)
condition|)
block|{
name|mp2
operator|=
name|mp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|mp2
condition|)
block|{
name|fp
operator|->
name|f_ref
operator|=
name|mp2
expr_stmt|;
name|matched
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|matched
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|p
operator|=
name|strrchr
argument_list|(
name|nn
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|de
operator|&&
name|p
condition|)
do|;
name|free
argument_list|(
name|nn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|lerror
argument_list|(
name|fp
operator|->
name|f_ioloc
argument_list|,
literal|"volname %s unknown"
argument_list|,
name|fp
operator|->
name|f_volname
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matched
condition|)
block|{
name|fixup_required_mount_info
argument_list|(
name|fp
argument_list|,
name|de
argument_list|)
expr_stmt|;
name|req
operator|=
operator|~
name|fp
operator|->
name|f_mask
operator|&
name|FM_REQUIRED
expr_stmt|;
if|if
condition|(
name|req
condition|)
block|{
name|show_required
argument_list|(
name|fp
operator|->
name|f_ioloc
argument_list|,
name|req
argument_list|,
name|fp
operator|->
name|f_volname
argument_list|,
name|hp
operator|->
name|h_hostname
argument_list|,
name|fsmount_strings
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fp
operator|->
name|f_localname
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|h_netroot
operator|=
name|fp
expr_stmt|;
name|netbootp
operator||=
name|FM_NETROOT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fp
operator|->
name|f_localname
argument_list|,
literal|"swap"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hp
operator|->
name|h_netswap
operator|=
name|fp
expr_stmt|;
name|netbootp
operator||=
name|FM_NETSWAP
expr_stmt|;
block|}
block|}
else|else
block|{
name|lerror
argument_list|(
name|fp
operator|->
name|f_ioloc
argument_list|,
literal|"volname %s not exported from %s"
argument_list|,
name|fp
operator|->
name|f_volname
argument_list|,
name|fp
operator|->
name|f_from
condition|?
name|fp
operator|->
name|f_from
else|:
literal|"anywhere"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|netbootp
operator|&&
operator|(
name|netbootp
operator|!=
name|FM_NETBOOT
operator|)
condition|)
name|lerror
argument_list|(
name|hp
operator|->
name|h_ioloc
argument_list|,
literal|"network booting requires both root and swap areas"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|analyze_hosts
parameter_list|(
name|q
parameter_list|)
name|qelem
modifier|*
name|q
decl_stmt|;
block|{
name|host
modifier|*
name|hp
decl_stmt|;
name|show_area_being_processed
argument_list|(
literal|"analyze hosts"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* 	 * Check all drives 	 */
name|ITER
argument_list|(
argument|hp
argument_list|,
argument|host
argument_list|,
argument|q
argument_list|)
block|{
name|log
argument_list|(
literal|"disks on host %s"
argument_list|,
name|hp
operator|->
name|h_hostname
argument_list|)
expr_stmt|;
name|show_new
argument_list|(
literal|"ana-host"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_hostpath
operator|=
name|compute_hostpath
argument_list|(
name|hp
operator|->
name|h_hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_disk_fs
condition|)
name|analyze_drives
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
name|show_area_being_processed
argument_list|(
literal|"analyze mounts"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* 	 * Check static mounts 	 */
name|ITER
argument_list|(
argument|hp
argument_list|,
argument|host
argument_list|,
argument|q
argument_list|)
block|{
name|log
argument_list|(
literal|"mounts on host %s"
argument_list|,
name|hp
operator|->
name|h_hostname
argument_list|)
expr_stmt|;
name|show_new
argument_list|(
literal|"ana-mount"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_mount
condition|)
name|analyze_mounts
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check an automount request  */
end_comment

begin_function
specifier|static
name|void
name|analyze_automount
parameter_list|(
name|ap
parameter_list|)
name|automount
modifier|*
name|ap
decl_stmt|;
block|{
name|dict_ent
modifier|*
name|de
init|=
name|find_volname
argument_list|(
name|ap
operator|->
name|a_volname
argument_list|)
decl_stmt|;
if|if
condition|(
name|de
condition|)
block|{
name|ap
operator|->
name|a_mounted
operator|=
name|de
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|ap
operator|->
name|a_volname
argument_list|,
name|ap
operator|->
name|a_name
argument_list|)
condition|)
name|lerror
argument_list|(
name|ap
operator|->
name|a_ioloc
argument_list|,
literal|"unknown volname %s automounted"
argument_list|,
name|ap
operator|->
name|a_volname
argument_list|)
expr_stmt|;
else|else
name|lerror
argument_list|(
name|ap
operator|->
name|a_ioloc
argument_list|,
literal|"unknown volname %s automounted on %s"
argument_list|,
name|ap
operator|->
name|a_volname
argument_list|,
name|ap
operator|->
name|a_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|analyze_automount_tree
parameter_list|(
name|q
parameter_list|,
name|pref
parameter_list|,
name|lvl
parameter_list|)
name|qelem
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|pref
decl_stmt|;
name|int
name|lvl
decl_stmt|;
block|{
name|automount
modifier|*
name|ap
decl_stmt|;
name|ITER
argument_list|(
argument|ap
argument_list|,
argument|automount
argument_list|,
argument|q
argument_list|)
block|{
name|char
name|nname
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|lvl
operator|>
literal|0
operator|||
name|ap
operator|->
name|a_mount
condition|)
if|if
condition|(
name|ap
operator|->
name|a_name
index|[
literal|1
index|]
operator|&&
name|strchr
argument_list|(
name|ap
operator|->
name|a_name
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
condition|)
name|lerror
argument_list|(
name|ap
operator|->
name|a_ioloc
argument_list|,
literal|"not allowed '/' in a directory name"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|nname
argument_list|,
literal|"%s/%s"
argument_list|,
name|pref
argument_list|,
name|ap
operator|->
name|a_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
operator|->
name|a_name
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_name
operator|=
name|strdup
argument_list|(
name|nname
index|[
literal|1
index|]
operator|==
literal|'/'
condition|?
name|nname
operator|+
literal|1
else|:
name|nname
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"automount point %s:"
argument_list|,
name|ap
operator|->
name|a_name
argument_list|)
expr_stmt|;
name|show_new
argument_list|(
literal|"ana-automount"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_mount
condition|)
block|{
name|analyze_automount_tree
argument_list|(
name|ap
operator|->
name|a_mount
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|lvl
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|a_volname
condition|)
block|{
name|log
argument_list|(
literal|"\tautomount from %s"
argument_list|,
name|ap
operator|->
name|a_volname
argument_list|)
expr_stmt|;
name|analyze_automount
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|a_symlink
condition|)
block|{
name|log
argument_list|(
literal|"\tsymlink to %s"
argument_list|,
name|ap
operator|->
name|a_symlink
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|->
name|a_volname
operator|=
name|strdup
argument_list|(
name|ap
operator|->
name|a_name
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"\timplicit automount from %s"
argument_list|,
name|ap
operator|->
name|a_volname
argument_list|)
expr_stmt|;
name|analyze_automount
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|analyze_automounts
parameter_list|(
name|q
parameter_list|)
name|qelem
modifier|*
name|q
decl_stmt|;
block|{
name|auto_tree
modifier|*
name|tp
decl_stmt|;
name|show_area_being_processed
argument_list|(
literal|"analyze automount"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* 	 * q is a list of automounts 	 */
name|ITER
argument_list|(
argument|tp
argument_list|,
argument|auto_tree
argument_list|,
argument|q
argument_list|)
name|analyze_automount_tree
argument_list|(
name|tp
operator|->
name|t_mount
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

