begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 Jan-Simon Pendry  * Copyright (c) 1990 Imperial College of Science, Technology& Medicine  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: map.c,v 1.1.1.1 1994/05/26 05:22:00 rgrimes Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)map.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"am.h"
end_include

begin_comment
comment|/*  * Generation Numbers.  *  * Generation numbers are allocated to every node created  * by amd.  When a filehandle is computed and sent to the  * kernel, the generation number makes sure that it is safe  * to reallocate a node slot even when the kernel has a cached  * reference to its old incarnation.  * No garbage collection is done, since it is assumed that  * there is no way that 2^32 generation numbers could ever  * be allocated by a single run of amd - there is simply  * not enough cpu time available.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|am_gen
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial generation number */
end_comment

begin_define
define|#
directive|define
name|new_gen
parameter_list|()
value|(am_gen++)
end_define

begin_decl_stmt
name|am_node
modifier|*
modifier|*
name|exported_ap
init|=
operator|(
name|am_node
operator|*
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exported_ap_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|first_free_map
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First available free slot */
end_comment

begin_decl_stmt
name|int
name|last_used_map
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last unavailable used slot */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timeout_mp_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Id from last call to timeout */
end_comment

begin_comment
comment|/*  * This is the default attributes field which  * is copied into every new node to be created.  * The individual filesystem fs_init() routines  * patch the copy to represent the particular  * details for the relevant filesystem type  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fattr
name|gen_fattr
init|=
block|{
name|NFLNK
block|,
comment|/* type */
name|NFSMODE_LNK
operator||
literal|0777
block|,
comment|/* mode */
literal|1
block|,
comment|/* nlink */
literal|0
block|,
comment|/* uid */
literal|0
block|,
comment|/* gid */
literal|0
block|,
comment|/* size */
literal|4096
block|,
comment|/* blocksize */
literal|0
block|,
comment|/* rdev */
literal|1
block|,
comment|/* blocks */
literal|0
block|,
comment|/* fsid */
literal|0
block|,
comment|/* fileid */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* atime */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* mtime */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* ctime */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Resize exported_ap map  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exported_ap_realloc_map
name|P
argument_list|(
operator|(
name|int
name|nsize
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|exported_ap_realloc_map
parameter_list|(
name|nsize
parameter_list|)
name|int
name|nsize
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * If a second realloc occasionally causes Amd to die 	 * in then include this check. 	 */
if|if
condition|(
name|exported_ap_size
operator|!=
literal|0
condition|)
comment|/* XXX */
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* 	 * this shouldn't happen, but... 	 */
if|if
condition|(
name|nsize
operator|<
literal|0
operator|||
name|nsize
operator|==
name|exported_ap_size
condition|)
return|return
literal|0
return|;
name|exported_ap
operator|=
operator|(
name|am_node
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|voidp
operator|)
name|exported_ap
argument_list|,
name|nsize
operator|*
sizeof|sizeof
argument_list|(
name|am_node
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsize
operator|>
name|exported_ap_size
condition|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|exported_ap
operator|+
name|exported_ap_size
operator|)
argument_list|,
operator|(
name|nsize
operator|-
name|exported_ap_size
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|am_node
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|exported_ap_size
operator|=
name|nsize
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * The root of the mount tree.  */
end_comment

begin_decl_stmt
name|am_node
modifier|*
name|root_node
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a new mount slot and create  * a new node.  * Fills in the map number of the node,  * but leaves everything else uninitialised.  */
end_comment

begin_function
name|am_node
modifier|*
name|exported_ap_alloc
parameter_list|(
name|P_void
parameter_list|)
block|{
name|am_node
modifier|*
name|mp
decl_stmt|,
modifier|*
modifier|*
name|mpp
decl_stmt|;
comment|/* 	 * First check if there are any slots left, realloc if needed 	 */
if|if
condition|(
name|first_free_map
operator|>=
name|exported_ap_size
condition|)
if|if
condition|(
operator|!
name|exported_ap_realloc_map
argument_list|(
name|exported_ap_size
operator|+
name|NEXP_AP
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Grab the next free slot 	 */
name|mpp
operator|=
name|exported_ap
operator|+
name|first_free_map
expr_stmt|;
name|mp
operator|=
operator|*
name|mpp
operator|=
name|ALLOC
argument_list|(
name|am_node
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_mapno
operator|=
name|first_free_map
operator|++
expr_stmt|;
comment|/* 	 * Update free pointer 	 */
while|while
condition|(
name|first_free_map
operator|<
name|exported_ap_size
operator|&&
name|exported_ap
index|[
name|first_free_map
index|]
condition|)
name|first_free_map
operator|++
expr_stmt|;
if|if
condition|(
name|first_free_map
operator|>
name|last_used_map
condition|)
name|last_used_map
operator|=
name|first_free_map
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Shrink exported_ap if reasonable 	 */
if|if
condition|(
name|last_used_map
operator|<
name|exported_ap_size
operator|-
operator|(
name|NEXP_AP
operator|+
name|NEXP_AP_MARGIN
operator|)
condition|)
name|exported_ap_realloc_map
argument_list|(
name|exported_ap_size
operator|-
name|NEXP_AP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*dlog("alloc_exp: last_used_map = %d, first_free_map = %d\n", 		last_used_map, first_free_map);*/
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|mp
return|;
block|}
end_function

begin_comment
comment|/*  * Free a mount slot  */
end_comment

begin_decl_stmt
name|void
name|exported_ap_free
name|P
argument_list|(
operator|(
name|am_node
operator|*
name|mp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|exported_ap_free
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
comment|/* 	 * Sanity check 	 */
if|if
condition|(
operator|!
name|mp
condition|)
return|return;
comment|/* 	 * Zero the slot pointer to avoid double free's 	 */
name|exported_ap
index|[
name|mp
operator|->
name|am_mapno
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Update the free and last_used indices 	 */
if|if
condition|(
name|mp
operator|->
name|am_mapno
operator|==
name|last_used_map
condition|)
while|while
condition|(
name|last_used_map
operator|>=
literal|0
operator|&&
name|exported_ap
index|[
name|last_used_map
index|]
operator|==
literal|0
condition|)
operator|--
name|last_used_map
expr_stmt|;
if|if
condition|(
name|first_free_map
operator|>
name|mp
operator|->
name|am_mapno
condition|)
name|first_free_map
operator|=
name|mp
operator|->
name|am_mapno
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*dlog("free_exp: last_used_map = %d, first_free_map = %d\n", 		last_used_map, first_free_map);*/
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 	 * Free the mount node 	 */
name|free
argument_list|(
operator|(
name|voidp
operator|)
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert mp into the correct place,  * where p_mp is its parent node.  * A new node gets placed as the youngest sibling  * of any other children, and the parent's child  * pointer is adjusted to point to the new child node.  */
end_comment

begin_function
name|void
name|insert_am
parameter_list|(
name|mp
parameter_list|,
name|p_mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
name|am_node
modifier|*
name|p_mp
decl_stmt|;
block|{
comment|/* 	 * If this is going in at the root then flag it 	 * so that it cannot be unmounted by amq. 	 */
if|if
condition|(
name|p_mp
operator|==
name|root_node
condition|)
name|mp
operator|->
name|am_flags
operator||=
name|AMF_ROOT
expr_stmt|;
comment|/* 	 * Fill in n-way links 	 */
name|mp
operator|->
name|am_parent
operator|=
name|p_mp
expr_stmt|;
name|mp
operator|->
name|am_osib
operator|=
name|p_mp
operator|->
name|am_child
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_osib
condition|)
name|mp
operator|->
name|am_osib
operator|->
name|am_ysib
operator|=
name|mp
expr_stmt|;
name|p_mp
operator|->
name|am_child
operator|=
name|mp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove am from its place in the mount tree  */
end_comment

begin_function
name|void
name|remove_am
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
comment|/* 	 * 1.  Consistency check 	 */
if|if
condition|(
name|mp
operator|->
name|am_child
operator|&&
name|mp
operator|->
name|am_parent
condition|)
block|{
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"children of \"%s\" still exist - deleting anyway"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 2.  Update parent's child pointer 	 */
if|if
condition|(
name|mp
operator|->
name|am_parent
operator|&&
name|mp
operator|->
name|am_parent
operator|->
name|am_child
operator|==
name|mp
condition|)
name|mp
operator|->
name|am_parent
operator|->
name|am_child
operator|=
name|mp
operator|->
name|am_osib
expr_stmt|;
comment|/* 	 * 3.  Unlink from sibling chain 	 */
if|if
condition|(
name|mp
operator|->
name|am_ysib
condition|)
name|mp
operator|->
name|am_ysib
operator|->
name|am_osib
operator|=
name|mp
operator|->
name|am_osib
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_osib
condition|)
name|mp
operator|->
name|am_osib
operator|->
name|am_ysib
operator|=
name|mp
operator|->
name|am_ysib
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute a new time to live value for a node.  */
end_comment

begin_function
name|void
name|new_ttl
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
name|mp
operator|->
name|am_timeo_w
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
name|clocktime
argument_list|()
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|atime
operator|.
name|seconds
operator|=
name|mp
operator|->
name|am_ttl
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|+=
name|mp
operator|->
name|am_timeo
expr_stmt|;
comment|/* sun's -tl option */
block|}
end_function

begin_decl_stmt
name|void
name|mk_fattr
name|P
argument_list|(
operator|(
name|am_node
operator|*
name|mp
operator|,
name|ftype
name|vntype
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|mk_fattr
parameter_list|(
name|mp
parameter_list|,
name|vntype
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
name|ftype
name|vntype
decl_stmt|;
block|{
switch|switch
condition|(
name|vntype
condition|)
block|{
case|case
name|NFDIR
case|:
name|mp
operator|->
name|am_fattr
operator|.
name|type
operator|=
name|NFDIR
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|mode
operator|=
name|NFSMODE_DIR
operator||
literal|0555
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|nlink
operator|=
literal|2
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|size
operator|=
literal|512
expr_stmt|;
break|break;
case|case
name|NFLNK
case|:
name|mp
operator|->
name|am_fattr
operator|.
name|type
operator|=
name|NFLNK
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|mode
operator|=
name|NFSMODE_LNK
operator||
literal|0777
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|nlink
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|size
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|plog
argument_list|(
name|XLOG_FATAL
argument_list|,
literal|"Unknown fattr type %d - ignored"
argument_list|,
name|vntype
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialise an allocated mount node.  * It is assumed that the mount node was bzero'd  * before getting here so anything that would  * be set to zero isn't done here.  */
end_comment

begin_function
name|void
name|init_map
parameter_list|(
name|mp
parameter_list|,
name|dir
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|dir
decl_stmt|;
block|{
comment|/* mp->am_mapno initalised by exported_ap_alloc */
name|mp
operator|->
name|am_mnt
operator|=
name|new_mntfs
argument_list|()
expr_stmt|;
name|mp
operator|->
name|am_name
operator|=
name|strdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_path
operator|=
name|strdup
argument_list|(
name|dir
argument_list|)
expr_stmt|;
comment|/*mp->am_link = 0;*/
comment|/*mp->am_parent = 0;*/
comment|/*mp->am_ysib = 0;*/
comment|/*mp->am_osib = 0;*/
comment|/*mp->am_child = 0;*/
comment|/*mp->am_flags = 0;*/
comment|/*mp->am_error = 0;*/
name|mp
operator|->
name|am_gen
operator|=
name|new_gen
argument_list|()
expr_stmt|;
comment|/*mp->am_pref = 0;*/
name|mp
operator|->
name|am_timeo
operator|=
name|am_timeo
expr_stmt|;
name|mp
operator|->
name|am_attr
operator|.
name|status
operator|=
name|NFS_OK
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|=
name|gen_fattr
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|fsid
operator|=
literal|42
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|fileid
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|atime
operator|.
name|seconds
operator|=
name|clocktime
argument_list|()
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|atime
operator|.
name|useconds
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|am_fattr
operator|.
name|mtime
operator|=
name|mp
operator|->
name|am_fattr
operator|.
name|ctime
operator|=
name|mp
operator|->
name|am_fattr
operator|.
name|atime
expr_stmt|;
name|new_ttl
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_stats
operator|.
name|s_mtime
operator|=
name|mp
operator|->
name|am_fattr
operator|.
name|atime
operator|.
name|seconds
expr_stmt|;
comment|/*mp->am_private = 0;*/
block|}
end_function

begin_comment
comment|/*  * Free a mount node.  * The node must be already unmounted.  */
end_comment

begin_function
name|void
name|free_map
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
name|remove_am
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_link
condition|)
name|free
argument_list|(
name|mp
operator|->
name|am_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_name
condition|)
name|free
argument_list|(
name|mp
operator|->
name|am_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_path
condition|)
name|free
argument_list|(
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_pref
condition|)
name|free
argument_list|(
name|mp
operator|->
name|am_pref
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|am_mnt
condition|)
name|free_mntfs
argument_list|(
name|mp
operator|->
name|am_mnt
argument_list|)
expr_stmt|;
name|exported_ap_free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert from file handle to  * automount node.  */
end_comment

begin_function
name|am_node
modifier|*
name|fh_to_mp3
parameter_list|(
name|fhp
parameter_list|,
name|rp
parameter_list|,
name|c_or_d
parameter_list|)
name|nfs_fh
modifier|*
name|fhp
decl_stmt|;
name|int
modifier|*
name|rp
decl_stmt|;
name|int
name|c_or_d
decl_stmt|;
block|{
name|struct
name|am_fh
modifier|*
name|fp
init|=
operator|(
expr|struct
name|am_fh
operator|*
operator|)
name|fhp
decl_stmt|;
name|am_node
modifier|*
name|ap
init|=
literal|0
decl_stmt|;
comment|/* 	 * Check process id matches 	 * If it doesn't then it is probably 	 * from an old kernel cached filehandle 	 * which is now out of date. 	 */
if|if
condition|(
name|fp
operator|->
name|fhh_pid
operator|!=
name|mypid
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Make sure the index is valid before 	 * exported_ap is referenced. 	 */
if|if
condition|(
name|fp
operator|->
name|fhh_id
operator|<
literal|0
operator|||
name|fp
operator|->
name|fhh_id
operator|>=
name|exported_ap_size
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * Get hold of the supposed mount node 	 */
name|ap
operator|=
name|exported_ap
index|[
name|fp
operator|->
name|fhh_id
index|]
expr_stmt|;
comment|/* 	 * If it exists then maybe... 	 */
if|if
condition|(
name|ap
condition|)
block|{
comment|/* 		 * Check the generation number in the node 		 * matches the one from the kernel.  If not 		 * then the old node has been timed out and 		 * a new one allocated. 		 */
if|if
condition|(
name|ap
operator|->
name|am_gen
operator|!=
name|fp
operator|->
name|fhh_gen
condition|)
block|{
name|ap
operator|=
literal|0
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* 		 * If the node is hung then locate a new node 		 * for it.  This implements the replicated filesystem 		 * retries. 		 */
if|if
condition|(
name|ap
operator|->
name|am_mnt
operator|&&
name|FSRV_ISDOWN
argument_list|(
name|ap
operator|->
name|am_mnt
operator|->
name|mf_server
argument_list|)
operator|&&
name|ap
operator|->
name|am_parent
condition|)
block|{
name|int
name|error
decl_stmt|;
name|am_node
modifier|*
name|orig_ap
init|=
name|ap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"fh_to_mp3: %s (%s) is hung:- call lookup"
argument_list|,
name|orig_ap
operator|->
name|am_path
argument_list|,
name|orig_ap
operator|->
name|am_mnt
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 			 * Update modify time of parent node. 			 * With any luck the kernel will re-stat 			 * the child node and get new information. 			 */
name|orig_ap
operator|->
name|am_fattr
operator|.
name|mtime
operator|.
name|seconds
operator|=
name|clocktime
argument_list|()
expr_stmt|;
comment|/* 			 * Call the parent's lookup routine for an object 			 * with the same name.  This may return -1 in error 			 * if a mount is in progress.  In any case, if no 			 * mount node is returned the error code is propagated 			 * to the caller. 			 */
if|if
condition|(
name|c_or_d
operator|==
name|VLOOK_CREATE
condition|)
block|{
name|ap
operator|=
call|(
modifier|*
name|orig_ap
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_ops
operator|->
name|lookuppn
call|)
argument_list|(
name|orig_ap
operator|->
name|am_parent
argument_list|,
name|orig_ap
operator|->
name|am_name
argument_list|,
operator|&
name|error
argument_list|,
name|c_or_d
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ap
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ESTALE
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|<
literal|0
operator|&&
name|amd_state
operator|==
name|Finishing
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
operator|*
name|rp
operator|=
name|error
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 			 * Update last access to original node.  This 			 * avoids timing it out and so sending ESTALE 			 * back to the kernel. 			 * XXX - Not sure we need this anymore (jsp, 90/10/6). 			 */
name|new_ttl
argument_list|(
name|orig_ap
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Disallow references to objects being unmounted, unless 		 * they are automount points. 		 */
if|if
condition|(
name|ap
operator|->
name|am_mnt
operator|&&
operator|(
name|ap
operator|->
name|am_mnt
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
operator|)
operator|&&
operator|!
operator|(
name|ap
operator|->
name|am_flags
operator|&
name|AMF_ROOT
operator|)
condition|)
block|{
if|if
condition|(
name|amd_state
operator|==
name|Finishing
condition|)
operator|*
name|rp
operator|=
name|ENOENT
expr_stmt|;
else|else
operator|*
name|rp
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|new_ttl
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|drop
label|:
if|if
condition|(
operator|!
name|ap
operator|||
operator|!
name|ap
operator|->
name|am_mnt
condition|)
block|{
comment|/* 		 * If we are shutting down then it is likely 		 * that this node has disappeared because of 		 * a fast timeout.  To avoid things thrashing 		 * just pretend it doesn't exist at all.  If 		 * ESTALE is returned, some NFS clients just 		 * keep retrying (stupid or what - if it's 		 * stale now, what's it going to be in 5 minutes?) 		 */
if|if
condition|(
name|amd_state
operator|==
name|Finishing
condition|)
operator|*
name|rp
operator|=
name|ENOENT
expr_stmt|;
else|else
operator|*
name|rp
operator|=
name|ESTALE
expr_stmt|;
name|amd_stats
operator|.
name|d_stale
operator|++
expr_stmt|;
block|}
return|return
name|ap
return|;
block|}
end_function

begin_function
name|am_node
modifier|*
name|fh_to_mp
parameter_list|(
name|fhp
parameter_list|)
name|nfs_fh
modifier|*
name|fhp
decl_stmt|;
block|{
name|int
name|dummy
decl_stmt|;
return|return
name|fh_to_mp2
argument_list|(
name|fhp
argument_list|,
operator|&
name|dummy
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert from automount node to  * file handle.  */
end_comment

begin_function
name|void
name|mp_to_fh
parameter_list|(
name|mp
parameter_list|,
name|fhp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
name|struct
name|nfs_fh
modifier|*
name|fhp
decl_stmt|;
block|{
name|struct
name|am_fh
modifier|*
name|fp
init|=
operator|(
expr|struct
name|am_fh
operator|*
operator|)
name|fhp
decl_stmt|;
comment|/* 	 * Take the process id 	 */
name|fp
operator|->
name|fhh_pid
operator|=
name|mypid
expr_stmt|;
comment|/* 	 * .. the map number 	 */
name|fp
operator|->
name|fhh_id
operator|=
name|mp
operator|->
name|am_mapno
expr_stmt|;
comment|/* 	 * .. and the generation number 	 */
name|fp
operator|->
name|fhh_gen
operator|=
name|mp
operator|->
name|am_gen
expr_stmt|;
comment|/* 	 * .. to make a "unique" triple that will never 	 * be reallocated except across reboots (which doesn't matter) 	 * or if we are unlucky enough to be given the same 	 * pid as a previous amd (very unlikely). 	 */
block|}
end_function

begin_decl_stmt
specifier|static
name|am_node
modifier|*
name|find_ap2
name|P
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|am_node
operator|*
name|mp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|am_node
modifier|*
name|find_ap2
parameter_list|(
name|dir
parameter_list|,
name|mp
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
if|if
condition|(
name|mp
condition|)
block|{
name|am_node
modifier|*
name|mp2
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mp
operator|->
name|am_path
argument_list|,
name|dir
argument_list|)
operator|==
literal|0
condition|)
return|return
name|mp
return|;
if|if
condition|(
operator|(
name|mp
operator|->
name|am_mnt
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
operator|&&
name|strcmp
argument_list|(
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mount
argument_list|,
name|dir
argument_list|)
operator|==
literal|0
condition|)
return|return
name|mp
return|;
name|mp2
operator|=
name|find_ap2
argument_list|(
name|dir
argument_list|,
name|mp
operator|->
name|am_osib
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp2
condition|)
return|return
name|mp2
return|;
return|return
name|find_ap2
argument_list|(
name|dir
argument_list|,
name|mp
operator|->
name|am_child
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Find the mount node corresponding  * to dir.  dir can match either the  * automount path or, if the node is  * mounted, the mount location.  */
end_comment

begin_decl_stmt
name|am_node
modifier|*
name|find_ap
name|P
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|am_node
modifier|*
name|find_ap
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
operator|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_ROOT
operator|)
condition|)
block|{
name|mp
operator|=
name|find_ap2
argument_list|(
name|dir
argument_list|,
name|exported_ap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
condition|)
return|return
name|mp
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Find the mount node corresponding  * to the mntfs structure.  */
end_comment

begin_decl_stmt
name|am_node
modifier|*
name|find_mf
name|P
argument_list|(
operator|(
name|mntfs
operator|*
name|mf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|am_node
modifier|*
name|find_mf
parameter_list|(
name|mf
parameter_list|)
name|mntfs
modifier|*
name|mf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
name|mp
operator|->
name|am_mnt
operator|==
name|mf
condition|)
return|return
name|mp
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get the filehandle for a particular named directory.  * This is used during the bootstrap to tell the kernel  * the filehandles of the initial automount points.  */
end_comment

begin_function
name|nfs_fh
modifier|*
name|root_fh
parameter_list|(
name|dir
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
block|{
specifier|static
name|nfs_fh
name|nfh
decl_stmt|;
name|am_node
modifier|*
name|mp
init|=
name|root_ap
argument_list|(
name|dir
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|mp_to_fh
argument_list|(
name|mp
argument_list|,
operator|&
name|nfh
argument_list|)
expr_stmt|;
comment|/* 		 * Patch up PID to match main server... 		 */
if|if
condition|(
operator|!
name|foreground
condition|)
block|{
name|long
name|pid
init|=
name|getppid
argument_list|()
decl_stmt|;
operator|(
operator|(
expr|struct
name|am_fh
operator|*
operator|)
operator|&
name|nfh
operator|)
operator|->
name|fhh_pid
operator|=
name|pid
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"root_fh substitutes pid %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|&
name|nfh
return|;
block|}
comment|/* 	 * Should never get here... 	 */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Can't find root filehandle for %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|am_node
modifier|*
name|root_ap
parameter_list|(
name|dir
parameter_list|,
name|path
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|path
decl_stmt|;
block|{
name|am_node
modifier|*
name|mp
init|=
name|find_ap
argument_list|(
name|dir
argument_list|)
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
name|mp
operator|->
name|am_parent
operator|==
name|root_node
condition|)
return|return
name|mp
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Timeout all nodes waiting on  * a given Fserver.  */
end_comment

begin_decl_stmt
name|void
name|map_flush_srvr
name|P
argument_list|(
operator|(
name|fserver
operator|*
name|fs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|map_flush_srvr
parameter_list|(
name|fs
parameter_list|)
name|fserver
modifier|*
name|fs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mp
operator|&&
name|mp
operator|->
name|am_mnt
operator|&&
name|mp
operator|->
name|am_mnt
operator|->
name|mf_server
operator|==
name|fs
condition|)
block|{
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"Flushed %s; dependent on %s"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|fs
operator|->
name|fs_host
argument_list|)
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
name|clocktime
argument_list|()
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|done
condition|)
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mount a top level automount node  * by calling lookup in the parent  * (root) node which will cause the  * automount node to be automounted.  */
end_comment

begin_decl_stmt
name|int
name|mount_auto_node
name|P
argument_list|(
operator|(
name|char
operator|*
name|dir
operator|,
name|voidp
name|arg
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|mount_auto_node
parameter_list|(
name|dir
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
name|voidp
name|arg
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|afs_ops
operator|.
name|lookuppn
argument_list|(
operator|(
name|am_node
operator|*
operator|)
name|arg
argument_list|,
name|dir
argument_list|,
operator|&
name|error
argument_list|,
name|VLOOK_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|errno
operator|=
name|error
expr_stmt|;
comment|/* XXX */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Could not mount %s: %m"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Cause all the top-level mount nodes  * to be automounted  */
end_comment

begin_decl_stmt
name|int
name|mount_exported
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|mount_exported
parameter_list|()
block|{
comment|/* 	 * Iterate over all the nodes to be started 	 */
return|return
name|root_keyiter
argument_list|(
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
operator|)
name|mount_auto_node
argument_list|,
name|root_node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct top-level node  */
end_comment

begin_decl_stmt
name|void
name|make_root_node
name|P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|make_root_node
parameter_list|()
block|{
name|mntfs
modifier|*
name|root_mnt
decl_stmt|;
name|char
modifier|*
name|rootmap
init|=
name|ROOT_MAP
decl_stmt|;
name|root_node
operator|=
name|exported_ap_alloc
argument_list|()
expr_stmt|;
comment|/* 	 * Allocate a new map 	 */
name|init_map
argument_list|(
name|root_node
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a new mounted filesystem 	 */
name|root_mnt
operator|=
name|find_mntfs
argument_list|(
operator|&
name|root_ops
argument_list|,
operator|(
name|am_opts
operator|*
operator|)
literal|0
argument_list|,
literal|""
argument_list|,
name|rootmap
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Replace the initial null reference 	 */
name|free_mntfs
argument_list|(
name|root_node
operator|->
name|am_mnt
argument_list|)
expr_stmt|;
name|root_node
operator|->
name|am_mnt
operator|=
name|root_mnt
expr_stmt|;
comment|/* 	 * Initialise the root 	 */
if|if
condition|(
name|root_mnt
operator|->
name|mf_ops
operator|->
name|fs_init
condition|)
call|(
modifier|*
name|root_mnt
operator|->
name|mf_ops
operator|->
name|fs_init
call|)
argument_list|(
name|root_mnt
argument_list|)
expr_stmt|;
comment|/* 	 * Mount the root 	 */
name|root_mnt
operator|->
name|mf_error
operator|=
call|(
modifier|*
name|root_mnt
operator|->
name|mf_ops
operator|->
name|mount_fs
call|)
argument_list|(
name|root_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cause all the nodes to be unmounted by timing  * them out.  */
end_comment

begin_function
name|void
name|umount_exported
parameter_list|(
name|P_void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
condition|)
block|{
comment|/* 				 * If this node is being unmounted then 				 * just ignore it.  However, this could 				 * prevent amd from finishing if the 				 * unmount gets blocked since the am_node 				 * will never be free'd.  am_unmounted needs 				 * telling about this possibility. - XXX 				 */
continue|continue;
block|}
if|if
condition|(
name|mf
operator|&&
operator|!
operator|(
name|mf
operator|->
name|mf_ops
operator|->
name|fs_flags
operator|&
name|FS_DIRECTORY
operator|)
condition|)
block|{
comment|/* 				 * When shutting down this had better 				 * look like a directory, otherwise it 				 * can't be unmounted! 				 */
name|mk_fattr
argument_list|(
name|mp
argument_list|,
name|NFDIR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|--
name|immediate_abort
operator|<
literal|0
operator|&&
operator|!
operator|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_ROOT
operator|)
operator|&&
name|mp
operator|->
name|am_parent
operator|)
operator|||
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_RESTART
operator|)
condition|)
block|{
comment|/* 				 * Just throw this node away without 				 * bothering to unmount it.  If the 				 * server is not known to be up then 				 * don't discard the mounted on directory 				 * or Amd might hang... 				 */
if|if
condition|(
name|mf
operator|->
name|mf_server
operator|&&
operator|(
name|mf
operator|->
name|mf_server
operator|->
name|fs_flags
operator|&
operator|(
name|FSF_DOWN
operator||
name|FSF_VALID
operator|)
operator|)
operator|!=
name|FSF_VALID
condition|)
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_MKMNT
expr_stmt|;
name|am_unmounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Any other node gets forcibly 				 * timed out 				 */
name|mp
operator|->
name|am_flags
operator|&=
operator|~
name|AMF_NOTIMEOUT
expr_stmt|;
name|mp
operator|->
name|am_mnt
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_RSTKEEP
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|am_timeo
operator|=
literal|1
expr_stmt|;
name|mp
operator|->
name|am_timeo_w
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|unmount_node
name|P
argument_list|(
operator|(
name|am_node
operator|*
name|mp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|unmount_node
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ERROR
operator|)
operator|||
name|mf
operator|->
name|mf_refc
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Just unlink 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_ERROR
condition|)
name|dlog
argument_list|(
literal|"No-op unmount of error node %s"
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Unmounting %s (%s)"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|,
name|mf
operator|->
name|mf_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|error
operator|=
call|(
modifier|*
name|mf
operator|->
name|mf_ops
operator|->
name|umount_fs
call|)
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|errno
operator|=
name|error
expr_stmt|;
comment|/* XXX */
name|dlog
argument_list|(
literal|"%s: unmount: %m"
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FLUSH_KERNEL_NAME_CACHE
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|flush_kernel_name_cache
name|P
argument_list|(
operator|(
name|am_node
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|flush_kernel_name_cache
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
name|int
name|islink
init|=
operator|(
name|mp
operator|->
name|am_mnt
operator|->
name|mf_fattr
operator|.
name|type
operator|==
name|NFLNK
operator|)
decl_stmt|;
name|int
name|isdir
init|=
operator|(
name|mp
operator|->
name|am_mnt
operator|->
name|mf_fattr
operator|.
name|type
operator|==
name|NFDIR
operator|)
decl_stmt|;
name|int
name|elog
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|islink
condition|)
block|{
if|if
condition|(
name|unlink
argument_list|(
name|mp
operator|->
name|am_path
argument_list|)
operator|<
literal|0
condition|)
name|elog
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdir
condition|)
block|{
if|if
condition|(
name|rmdir
argument_list|(
name|mp
operator|->
name|am_path
argument_list|)
operator|<
literal|0
condition|)
name|elog
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|elog
condition|)
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"failed to clear \"%s\" from dnlc: %m"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FLUSH_KERNEL_NAME_CACHE */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unmount_node_wrap
name|P
argument_list|(
operator|(
name|voidp
name|vp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|unmount_node_wrap
parameter_list|(
name|vp
parameter_list|)
name|voidp
name|vp
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|FLUSH_KERNEL_NAME_CACHE
return|return
name|unmount_node
argument_list|(
operator|(
name|am_node
operator|*
operator|)
name|vp
argument_list|)
return|;
else|#
directive|else
comment|/* FLUSH_KERNEL_NAME_CACHE */
comment|/* 	 * This code should just say: 	 * return unmount_node((am_node *) vp); 	 * 	 * However... 	 * The kernel keeps a cached copy of filehandles, 	 * and doesn't ever uncache them (apparently).  So 	 * when Amd times out a node the kernel will have a 	 * stale filehandle.  When the kernel next uses the 	 * filehandle it gets ESTALE. 	 * 	 * The workaround: 	 * Arrange that when a node is removed an unlink or 	 * rmdir is done on that path so that the kernel 	 * cache is done.  Yes - yuck. 	 * 	 * This can all be removed (and the background 	 * unmount flag in sfs_ops) if/when the kernel does 	 * something smarter. 	 * 	 * If the unlink or rmdir failed then just log a warning, 	 * don't fail the unmount.  This can occur if the kernel 	 * client code decides that the object is still referenced 	 * and should be renamed rather than discarded. 	 * 	 * There is still a race condition here... 	 * if another process is trying to access the same 	 * filesystem at the time we get here, then 	 * it will block, since the MF_UNMOUNTING flag will 	 * be set.  That may, or may not, cause the entire 	 * system to deadlock.  Hmmm... 	 */
name|am_node
modifier|*
name|mp
init|=
operator|(
name|am_node
operator|*
operator|)
name|vp
decl_stmt|;
name|int
name|isauto
init|=
name|mp
operator|->
name|am_parent
operator|&&
operator|(
name|mp
operator|->
name|am_parent
operator|->
name|am_mnt
operator|->
name|mf_fattr
operator|.
name|type
operator|==
name|NFDIR
operator|)
decl_stmt|;
name|int
name|error
init|=
name|unmount_node
argument_list|(
name|mp
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|isauto
operator|&&
operator|(
name|int
operator|)
name|amd_state
operator|<
operator|(
name|int
operator|)
name|Finishing
condition|)
name|flush_kernel_name_cache
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* FLUSH_KERNEL_NAME_CACHE */
block|}
end_function

begin_function
specifier|static
name|void
name|free_map_if_success
parameter_list|(
name|rc
parameter_list|,
name|term
parameter_list|,
name|closure
parameter_list|)
name|int
name|rc
decl_stmt|;
name|int
name|term
decl_stmt|;
name|voidp
name|closure
decl_stmt|;
block|{
name|am_node
modifier|*
name|mp
init|=
operator|(
name|am_node
operator|*
operator|)
name|closure
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
comment|/* 	 * Not unmounting any more 	 */
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_UNMOUNTING
expr_stmt|;
comment|/* 	 * If a timeout was defered because the underlying filesystem 	 * was busy then arrange for a timeout as soon as possible. 	 */
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_WANTTIMO
condition|)
block|{
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_WANTTIMO
expr_stmt|;
name|reschedule_timeout_mp
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|term
condition|)
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"unmount for %s got signal %d"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
comment|/* 		 * dbx likes to put a trap on exit(). 		 * Pretend it succeeded for now... 		 */
if|if
condition|(
name|term
operator|==
name|SIGTRAP
condition|)
block|{
name|am_unmounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
name|amd_stats
operator|.
name|d_uerr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rc
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|EBUSY
condition|)
block|{
name|plog
argument_list|(
name|XLOG_STATS
argument_list|,
literal|"\"%s\" on %s still active"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mf
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errno
operator|=
name|rc
expr_stmt|;
comment|/* XXX */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"%s: unmount: %m"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
block|}
name|amd_stats
operator|.
name|d_uerr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|am_unmounted
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wakeup anything waiting for this mount 	 */
name|wakeup
argument_list|(
operator|(
name|voidp
operator|)
name|mf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unmount_mp
parameter_list|(
name|mp
parameter_list|)
name|am_node
modifier|*
name|mp
decl_stmt|;
block|{
name|int
name|was_backgrounded
init|=
literal|0
decl_stmt|;
name|mntfs
modifier|*
name|mf
init|=
name|mp
operator|->
name|am_mnt
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|plog
argument_list|(
name|XLOG_INFO
argument_list|,
literal|"\"%s\" on %s timed out"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* notdef */
if|if
condition|(
operator|(
name|mf
operator|->
name|mf_ops
operator|->
name|fs_flags
operator|&
name|FS_UBACKGROUND
operator|)
operator|&&
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_MOUNTED
operator|)
condition|)
block|{
if|if
condition|(
name|mf
operator|->
name|mf_refc
operator|==
literal|1
operator|&&
operator|!
name|FSRV_ISUP
argument_list|(
name|mf
operator|->
name|mf_server
argument_list|)
condition|)
block|{
comment|/* 			 * Don't try to unmount from a server that is known to be down 			 */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_LOGDOWN
operator|)
condition|)
block|{
comment|/* Only log this once, otherwise gets a bit boring */
name|plog
argument_list|(
name|XLOG_STATS
argument_list|,
literal|"file server %s is down - timeout of \"%s\" ignored"
argument_list|,
name|mf
operator|->
name|mf_server
operator|->
name|fs_host
argument_list|,
name|mp
operator|->
name|am_path
argument_list|)
expr_stmt|;
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_LOGDOWN
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Clear logdown flag - since the server must be up */
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_LOGDOWN
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"\"%s\" on %s timed out"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
comment|/*dlog("Will background the unmount attempt");*/
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 			 * Note that we are unmounting this node 			 */
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_UNMOUNTING
expr_stmt|;
name|run_task
argument_list|(
name|unmount_node_wrap
argument_list|,
operator|(
name|voidp
operator|)
name|mp
argument_list|,
name|free_map_if_success
argument_list|,
operator|(
name|voidp
operator|)
name|mp
argument_list|)
expr_stmt|;
name|was_backgrounded
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"unmount attempt backgrounded"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"\"%s\" on %s timed out"
argument_list|,
name|mp
operator|->
name|am_path
argument_list|,
name|mp
operator|->
name|am_mnt
operator|->
name|mf_mount
argument_list|)
expr_stmt|;
name|dlog
argument_list|(
literal|"Trying unmount in foreground"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_UNMOUNTING
expr_stmt|;
name|free_map_if_success
argument_list|(
name|unmount_node
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|voidp
operator|)
name|mp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"unmount attempt done"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
return|return
name|was_backgrounded
return|;
block|}
end_function

begin_function
name|void
name|timeout_mp
parameter_list|()
block|{
define|#
directive|define
name|NEVER
value|(time_t) 0
define|#
directive|define
name|smallest_t
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
define|\
value|(t1 != NEVER ? (t2 != NEVER ? (t1< t2 ? t1 : t2) : t1) : t2)
define|#
directive|define
name|IGNORE_FLAGS
value|(MFF_MOUNTING|MFF_UNMOUNTING|MFF_RESTART)
name|int
name|i
decl_stmt|;
name|time_t
name|t
init|=
name|NEVER
decl_stmt|;
name|time_t
name|now
init|=
name|clocktime
argument_list|()
decl_stmt|;
name|int
name|backoff
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Timing out automount points..."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
for|for
control|(
name|i
operator|=
name|last_used_map
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|am_node
modifier|*
name|mp
init|=
name|exported_ap
index|[
name|i
index|]
decl_stmt|;
name|mntfs
modifier|*
name|mf
decl_stmt|;
comment|/* 		 * Just continue if nothing mounted, or can't be timed out. 		 */
if|if
condition|(
operator|!
name|mp
operator|||
operator|(
name|mp
operator|->
name|am_flags
operator|&
name|AMF_NOTIMEOUT
operator|)
condition|)
continue|continue;
comment|/* 		 * Pick up mounted filesystem 		 */
name|mf
operator|=
name|mp
operator|->
name|am_mnt
expr_stmt|;
if|if
condition|(
operator|!
name|mf
condition|)
continue|continue;
comment|/* 		 * Don't delete last reference to a restarted filesystem. 		 */
if|if
condition|(
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_RSTKEEP
operator|)
operator|&&
name|mf
operator|->
name|mf_refc
operator|==
literal|1
condition|)
continue|continue;
comment|/* 		 * If there is action on this filesystem then ignore it 		 */
if|if
condition|(
operator|!
operator|(
name|mf
operator|->
name|mf_flags
operator|&
name|IGNORE_FLAGS
operator|)
condition|)
block|{
name|int
name|expired
init|=
literal|0
decl_stmt|;
name|mf
operator|->
name|mf_flags
operator|&=
operator|~
name|MFF_WANTTIMO
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*dlog("t is initially @%d, zero in %d secs", t, t - now);*/
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|now
operator|>=
name|mp
operator|->
name|am_ttl
condition|)
block|{
if|if
condition|(
operator|!
name|backoff
condition|)
block|{
name|expired
operator|=
literal|1
expr_stmt|;
comment|/* 					 * Move the ttl forward to avoid thrashing effects 					 * on the next call to timeout! 					 */
comment|/* sun's -tw option */
if|if
condition|(
name|mp
operator|->
name|am_timeo_w
operator|<
literal|4
operator|*
name|am_timeo_w
condition|)
name|mp
operator|->
name|am_timeo_w
operator|+=
name|am_timeo_w
expr_stmt|;
name|mp
operator|->
name|am_ttl
operator|=
name|now
operator|+
name|mp
operator|->
name|am_timeo_w
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Just backoff this unmount for 					 * a couple of seconds to avoid 					 * many multiple unmounts being 					 * started in parallel. 					 */
name|mp
operator|->
name|am_ttl
operator|=
name|now
operator|+
name|backoff
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* 			 * If the next ttl is smallest, use that 			 */
name|t
operator|=
name|smallest_t
argument_list|(
name|t
argument_list|,
name|mp
operator|->
name|am_ttl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*dlog("after ttl t is @%d, zero in %d secs", t, t - now);*/
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
operator|!
name|mp
operator|->
name|am_child
operator|&&
name|mf
operator|->
name|mf_error
operator|>=
literal|0
operator|&&
name|expired
condition|)
block|{
comment|/* 				 * If the unmount was backgrounded then 				 * bump the backoff counter. 				 */
if|if
condition|(
name|unmount_mp
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|backoff
operator|=
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*dlog("backing off subsequent unmounts by at least %d seconds", backoff);*/
endif|#
directive|endif
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|mf
operator|->
name|mf_flags
operator|&
name|MFF_UNMOUNTING
condition|)
block|{
name|mf
operator|->
name|mf_flags
operator||=
name|MFF_WANTTIMO
expr_stmt|;
block|}
block|}
if|if
condition|(
name|t
operator|==
name|NEVER
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"No further timeouts"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|t
operator|=
name|now
operator|+
name|ONE_HOUR
expr_stmt|;
block|}
comment|/* 	 * Sanity check to avoid runaways. 	 * Absolutely should never get this but 	 * if you do without this trap amd will thrash. 	 */
if|if
condition|(
name|t
operator|<=
name|now
condition|)
block|{
name|t
operator|=
name|now
operator|+
literal|6
expr_stmt|;
comment|/* XXX */
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
literal|"Got a zero interval in timeout_mp()!"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX - when shutting down, make things happen faster 	 */
if|if
condition|(
operator|(
name|int
operator|)
name|amd_state
operator|>=
operator|(
name|int
operator|)
name|Finishing
condition|)
name|t
operator|=
name|now
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Next mount timeout in %ds"
argument_list|,
name|t
operator|-
name|now
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|timeout_mp_id
operator|=
name|timeout
argument_list|(
name|t
operator|-
name|now
argument_list|,
name|timeout_mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|NEVER
undef|#
directive|undef
name|smallest_t
undef|#
directive|undef
name|IGNORE_FLAGS
block|}
end_function

begin_comment
comment|/*  * Cause timeout_mp to be called soonest  */
end_comment

begin_function
name|void
name|reschedule_timeout_mp
parameter_list|()
block|{
if|if
condition|(
name|timeout_mp_id
condition|)
name|untimeout
argument_list|(
name|timeout_mp_id
argument_list|)
expr_stmt|;
name|timeout_mp_id
operator|=
name|timeout
argument_list|(
literal|0
argument_list|,
name|timeout_mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

