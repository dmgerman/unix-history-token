begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989 Jan-Simon Pendry  * Copyright (c) 1989 Imperial College of Science, Technology& Medicine  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)opts.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"am.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|getenv
name|P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * static copy of the options with  * which to play  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|am_opts
name|fs_static
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|opt_host
init|=
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|opt_hostd
init|=
name|hostd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|nullstr
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|opt_key
init|=
name|nullstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|opt_map
init|=
name|nullstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|opt_path
init|=
name|nullstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vars
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Length of longest option name  */
end_comment

begin_define
define|#
directive|define
name|NLEN
value|16
end_define

begin_comment
comment|/* conservative */
end_comment

begin_define
define|#
directive|define
name|S
parameter_list|(
name|x
parameter_list|)
value|(x) , (sizeof(x)-1)
end_define

begin_struct
specifier|static
struct|struct
name|opt
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of the option */
name|int
name|nlen
decl_stmt|;
comment|/* Length of option name */
name|char
modifier|*
modifier|*
name|optp
decl_stmt|;
comment|/* Pointer to option value string */
name|char
modifier|*
modifier|*
name|sel_p
decl_stmt|;
comment|/* Pointer to selector value string */
block|}
name|opt_fields
index|[]
init|=
block|{
comment|/* Options in something corresponding to frequency of use */
block|{
name|S
argument_list|(
literal|"opts"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_opts
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"host"
argument_list|)
block|,
literal|0
block|,
operator|&
name|opt_host
block|}
block|,
block|{
name|S
argument_list|(
literal|"hostd"
argument_list|)
block|,
literal|0
block|,
operator|&
name|opt_hostd
block|}
block|,
block|{
name|S
argument_list|(
literal|"type"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_type
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"rhost"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_rhost
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"rfs"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_rfs
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"fs"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_fs
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"key"
argument_list|)
block|,
literal|0
block|,
operator|&
name|opt_key
block|}
block|,
block|{
name|S
argument_list|(
literal|"map"
argument_list|)
block|,
literal|0
block|,
operator|&
name|opt_map
block|}
block|,
block|{
name|S
argument_list|(
literal|"sublink"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_sublink
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"arch"
argument_list|)
block|,
literal|0
block|,
operator|&
name|arch
block|}
block|,
block|{
name|S
argument_list|(
literal|"dev"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_dev
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"pref"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_pref
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"path"
argument_list|)
block|,
literal|0
block|,
operator|&
name|opt_path
block|}
block|,
block|{
name|S
argument_list|(
literal|"autodir"
argument_list|)
block|,
literal|0
block|,
operator|&
name|auto_dir
block|}
block|,
block|{
name|S
argument_list|(
literal|"delay"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_delay
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"domain"
argument_list|)
block|,
literal|0
block|,
operator|&
name|hostdomain
block|}
block|,
block|{
name|S
argument_list|(
literal|"karch"
argument_list|)
block|,
literal|0
block|,
operator|&
name|karch
block|}
block|,
block|{
name|S
argument_list|(
literal|"cluster"
argument_list|)
block|,
literal|0
block|,
operator|&
name|cluster
block|}
block|,
block|{
name|S
argument_list|(
literal|"wire"
argument_list|)
block|,
literal|0
block|,
operator|&
name|wire
block|}
block|,
block|{
name|S
argument_list|(
literal|"byte"
argument_list|)
block|,
literal|0
block|,
operator|&
name|endian
block|}
block|,
block|{
name|S
argument_list|(
literal|"os"
argument_list|)
block|,
literal|0
block|,
operator|&
name|op_sys
block|}
block|,
block|{
name|S
argument_list|(
literal|"remopts"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_remopts
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"mount"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_mount
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"unmount"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_unmount
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"cache"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_cache
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"user"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_user
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"group"
argument_list|)
block|,
operator|&
name|fs_static
operator|.
name|opt_group
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"var0"
argument_list|)
block|,
operator|&
name|vars
index|[
literal|0
index|]
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"var1"
argument_list|)
block|,
operator|&
name|vars
index|[
literal|1
index|]
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"var2"
argument_list|)
block|,
operator|&
name|vars
index|[
literal|2
index|]
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"var3"
argument_list|)
block|,
operator|&
name|vars
index|[
literal|3
index|]
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"var4"
argument_list|)
block|,
operator|&
name|vars
index|[
literal|4
index|]
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"var5"
argument_list|)
block|,
operator|&
name|vars
index|[
literal|5
index|]
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"var6"
argument_list|)
block|,
operator|&
name|vars
index|[
literal|6
index|]
block|,
literal|0
block|}
block|,
block|{
name|S
argument_list|(
literal|"var7"
argument_list|)
block|,
operator|&
name|vars
index|[
literal|7
index|]
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|opt_apply
name|opt_apply
typedef|;
end_typedef

begin_struct
struct|struct
name|opt_apply
block|{
name|char
modifier|*
modifier|*
name|opt
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Specially expand the remote host name first  */
end_comment

begin_decl_stmt
specifier|static
name|opt_apply
name|rhost_expansion
index|[]
init|=
block|{
block|{
operator|&
name|fs_static
operator|.
name|opt_rhost
block|,
literal|"${host}"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of options which need to be expanded  * Note that this the order here _may_ be important.  */
end_comment

begin_decl_stmt
specifier|static
name|opt_apply
name|expansions
index|[]
init|=
block|{
comment|/*	{&fs_static.opt_dir, 0 },	*/
block|{
operator|&
name|fs_static
operator|.
name|opt_sublink
block|,
literal|0
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_rfs
block|,
literal|"${path}"
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_fs
block|,
literal|"${autodir}/${rhost}${rfs}"
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_opts
block|,
literal|"rw"
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_remopts
block|,
literal|"${opts}"
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_mount
block|,
literal|0
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_unmount
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of options which need to be free'ed before re-use  */
end_comment

begin_decl_stmt
specifier|static
name|opt_apply
name|to_free
index|[]
init|=
block|{
block|{
operator|&
name|fs_static
operator|.
name|fs_glob
block|,
literal|0
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|fs_local
block|,
literal|0
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|fs_mtab
block|,
literal|0
block|}
block|,
comment|/*	{&fs_static.opt_dir, 0 },	*/
block|{
operator|&
name|fs_static
operator|.
name|opt_sublink
block|,
literal|0
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_rfs
block|,
literal|0
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_fs
block|,
literal|0
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_rhost
block|,
literal|0
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_opts
block|,
literal|0
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_remopts
block|,
literal|0
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_mount
block|,
literal|0
block|}
block|,
block|{
operator|&
name|fs_static
operator|.
name|opt_unmount
block|,
literal|0
block|}
block|,
block|{
operator|&
name|vars
index|[
literal|0
index|]
block|,
literal|0
block|}
block|,
block|{
operator|&
name|vars
index|[
literal|1
index|]
block|,
literal|0
block|}
block|,
block|{
operator|&
name|vars
index|[
literal|2
index|]
block|,
literal|0
block|}
block|,
block|{
operator|&
name|vars
index|[
literal|3
index|]
block|,
literal|0
block|}
block|,
block|{
operator|&
name|vars
index|[
literal|4
index|]
block|,
literal|0
block|}
block|,
block|{
operator|&
name|vars
index|[
literal|5
index|]
block|,
literal|0
block|}
block|,
block|{
operator|&
name|vars
index|[
literal|6
index|]
block|,
literal|0
block|}
block|,
block|{
operator|&
name|vars
index|[
literal|7
index|]
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Skip to next option in the string  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|opt
name|P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|opt
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|cp
init|=
operator|*
name|p
decl_stmt|;
name|char
modifier|*
name|dp
init|=
name|cp
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|cp
decl_stmt|;
name|top
label|:
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|';'
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\"'
condition|)
block|{
comment|/* 			 * Skip past string 			 */
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|'\"'
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Skip past any remaining ';'s 	 */
while|while
condition|(
operator|*
name|cp
operator|==
literal|';'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* 	 * If we have a zero length string 	 * and there are more fields, then 	 * parse the next one.  This allows 	 * sequences of empty fields. 	 */
if|if
condition|(
operator|*
name|cp
operator|&&
name|dp
operator|==
name|s
condition|)
goto|goto
name|top
goto|;
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|p
operator|=
name|cp
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|eval_opts
name|P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|eval_opts
parameter_list|(
name|opts
parameter_list|,
name|mapkey
parameter_list|)
name|char
modifier|*
name|opts
decl_stmt|;
name|char
modifier|*
name|mapkey
decl_stmt|;
block|{
comment|/* 	 * Fill in the global structure fs_static by 	 * cracking the string opts.  opts may be 	 * scribbled on at will. 	 */
name|char
modifier|*
name|o
init|=
name|opts
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|;
comment|/* 	 * For each user-specified option 	 */
while|while
condition|(
operator|*
operator|(
name|f
operator|=
name|opt
argument_list|(
operator|&
name|o
argument_list|)
operator|)
condition|)
block|{
name|struct
name|opt
modifier|*
name|op
decl_stmt|;
enum|enum
name|vs_opt
block|{
name|OldSyn
block|,
name|SelEQ
block|,
name|SelNE
block|,
name|VarAss
block|}
name|vs_opt
enum|;
name|char
modifier|*
name|eq
init|=
name|strchr
argument_list|(
name|f
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
name|char
modifier|*
name|opt
decl_stmt|;
if|if
condition|(
operator|!
name|eq
operator|||
name|eq
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|eq
operator|==
name|f
condition|)
block|{
comment|/* 			 * No value, just continue 			 */
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"key %s: No value component in \"%s\""
argument_list|,
name|mapkey
argument_list|,
name|f
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Check what type of operation is happening 		 * !=, =!  is SelNE 		 * == is SelEQ 		 * := is VarAss 		 * = is OldSyn (either SelEQ or VarAss) 		 */
if|if
condition|(
name|eq
index|[
operator|-
literal|1
index|]
operator|==
literal|'!'
condition|)
block|{
comment|/* != */
name|vs_opt
operator|=
name|SelNE
expr_stmt|;
name|eq
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opt
operator|=
name|eq
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
index|[
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
comment|/* := */
name|vs_opt
operator|=
name|VarAss
expr_stmt|;
name|eq
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opt
operator|=
name|eq
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
block|{
comment|/* == */
name|vs_opt
operator|=
name|SelEQ
expr_stmt|;
name|eq
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opt
operator|=
name|eq
operator|+
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
index|[
literal|1
index|]
operator|==
literal|'!'
condition|)
block|{
comment|/* =! */
name|vs_opt
operator|=
name|SelNE
expr_stmt|;
name|eq
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opt
operator|=
name|eq
operator|+
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* = */
name|vs_opt
operator|=
name|OldSyn
expr_stmt|;
name|eq
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opt
operator|=
name|eq
operator|+
literal|1
expr_stmt|;
block|}
comment|/* 		 * For each recognised option 		 */
for|for
control|(
name|op
operator|=
name|opt_fields
init|;
name|op
operator|->
name|name
condition|;
name|op
operator|++
control|)
block|{
comment|/* 			 * Check whether they match 			 */
if|if
condition|(
name|FSTREQ
argument_list|(
name|op
operator|->
name|name
argument_list|,
name|f
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|vs_opt
condition|)
block|{
if|#
directive|if
name|AMD_COMPAT
operator|<=
literal|5000108
case|case
name|OldSyn
case|:
name|plog
argument_list|(
name|XLOG_WARNING
argument_list|,
literal|"key %s: Old syntax selector found: %s=%s"
argument_list|,
name|mapkey
argument_list|,
name|f
argument_list|,
name|opt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|op
operator|->
name|sel_p
condition|)
block|{
operator|*
name|op
operator|->
name|optp
operator|=
name|opt
expr_stmt|;
break|break;
block|}
comment|/* fall through ... */
endif|#
directive|endif
comment|/* 5000108 */
case|case
name|SelEQ
case|:
case|case
name|SelNE
case|:
if|if
condition|(
name|op
operator|->
name|sel_p
operator|&&
operator|(
name|STREQ
argument_list|(
operator|*
name|op
operator|->
name|sel_p
argument_list|,
name|opt
argument_list|)
operator|==
operator|(
name|vs_opt
operator|==
name|SelNE
operator|)
operator|)
condition|)
block|{
name|plog
argument_list|(
name|XLOG_MAP
argument_list|,
literal|"key %s: map selector %s (=%s) did not %smatch %s"
argument_list|,
name|mapkey
argument_list|,
name|op
operator|->
name|name
argument_list|,
operator|*
name|op
operator|->
name|sel_p
argument_list|,
name|vs_opt
operator|==
name|SelNE
condition|?
literal|"not "
else|:
literal|""
argument_list|,
name|opt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|VarAss
case|:
if|if
condition|(
name|op
operator|->
name|sel_p
condition|)
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"key %s: Can't assign to a selector (%s)"
argument_list|,
name|mapkey
argument_list|,
name|op
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|op
operator|->
name|optp
operator|=
name|opt
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|op
operator|->
name|name
condition|)
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"key %s: Unrecognised key/option \"%s\""
argument_list|,
name|mapkey
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Free an option  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|free_op
name|P
argument_list|(
operator|(
name|opt_apply
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|free_op
parameter_list|(
name|p
parameter_list|,
name|b
parameter_list|)
name|opt_apply
modifier|*
name|p
decl_stmt|;
name|int
name|b
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|p
operator|->
name|opt
condition|)
block|{
name|free
argument_list|(
operator|*
name|p
operator|->
name|opt
argument_list|)
expr_stmt|;
operator|*
name|p
operator|->
name|opt
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Normalize slashes in the string.  */
end_comment

begin_decl_stmt
name|void
name|normalize_slash
name|P
argument_list|(
operator|(
name|char
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|normalize_slash
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|f
init|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
name|char
modifier|*
name|f0
init|=
name|f
decl_stmt|;
if|if
condition|(
name|f
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|f
decl_stmt|;
do|do
block|{
comment|/* assert(*f == '/'); */
if|if
condition|(
name|f
operator|==
name|f0
operator|&&
name|f
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|f
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* copy double slash iff first */
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
expr_stmt|;
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* copy a single / across */
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
expr_stmt|;
block|}
comment|/* assert(f[-1] == '/'); */
comment|/* skip past more /'s */
while|while
condition|(
operator|*
name|f
operator|==
literal|'/'
condition|)
name|f
operator|++
expr_stmt|;
comment|/* assert(*f != '/'); */
comment|/* keep copying up to next / */
while|while
condition|(
operator|*
name|f
operator|&&
operator|*
name|f
operator|!=
literal|'/'
condition|)
block|{
operator|*
name|t
operator|++
operator|=
operator|*
name|f
operator|++
expr_stmt|;
block|}
comment|/* assert(*f == 0 || *f == '/'); */
block|}
do|while
condition|(
operator|*
name|f
condition|)
do|;
operator|*
name|t
operator|=
literal|0
expr_stmt|;
comment|/* derived from fix by Steven Glassman */
block|}
block|}
end_function

begin_comment
comment|/*  * Macro-expand an option.  Note that this does not  * handle recursive expansions.  They will go badly wrong.  * If sel is true then old expand selectors, otherwise  * don't expand selectors.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|expand_op
name|P
argument_list|(
operator|(
name|opt_apply
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|expand_op
parameter_list|(
name|p
parameter_list|,
name|sel_p
parameter_list|)
name|opt_apply
modifier|*
name|p
decl_stmt|;
name|int
name|sel_p
decl_stmt|;
block|{
comment|/*  * The BUFSPACE macros checks that there is enough space  * left in the expansion buffer.  If there isn't then we  * give up completely.  This is done to avoid crashing the  * automounter itself (which would be a bad thing to do).  */
define|#
directive|define
name|BUFSPACE
parameter_list|(
name|ep
parameter_list|,
name|len
parameter_list|)
value|(((ep) + (len))< expbuf+MAXPATHLEN)
specifier|static
name|char
name|expand_error
index|[]
init|=
literal|"No space to expand \"%s\""
decl_stmt|;
name|char
name|expbuf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|nbuf
index|[
name|NLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|ep
init|=
name|expbuf
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|*
name|p
operator|->
name|opt
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|char
modifier|*
name|cp_orig
init|=
operator|*
name|p
operator|->
name|opt
decl_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|struct
name|opt
modifier|*
name|op
decl_stmt|;
while|while
condition|(
name|dp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'$'
argument_list|)
condition|)
block|{
name|char
name|ch
decl_stmt|;
comment|/* 		 * First copy up to the $ 		 */
block|{
name|int
name|len
init|=
name|dp
operator|-
name|cp
decl_stmt|;
if|if
condition|(
name|BUFSPACE
argument_list|(
name|ep
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|ep
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
name|expand_error
argument_list|,
operator|*
name|p
operator|->
name|opt
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|cp
operator|=
name|dp
operator|+
literal|1
expr_stmt|;
name|ch
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|BUFSPACE
argument_list|(
name|ep
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|ep
operator|++
operator|=
literal|'$'
expr_stmt|;
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
name|expand_error
argument_list|,
operator|*
name|p
operator|->
name|opt
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'{'
condition|)
block|{
comment|/* Expansion... */
enum|enum
block|{
name|E_All
block|,
name|E_Dir
block|,
name|E_File
block|,
name|E_Domain
block|,
name|E_Host
block|}
name|todo
enum|;
comment|/* 			 * Find closing brace 			 */
name|char
modifier|*
name|br_p
init|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'}'
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* 			 * Check we found it 			 */
if|if
condition|(
operator|!
name|br_p
condition|)
block|{
comment|/* 				 * Just give up 				 */
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"No closing '}' in \"%s\""
argument_list|,
operator|*
name|p
operator|->
name|opt
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|len
operator|=
name|br_p
operator|-
name|cp
expr_stmt|;
comment|/* 			 * Figure out which part of the variable to grab. 			 */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
comment|/* 				 * Just take the last component 				 */
name|todo
operator|=
name|E_File
expr_stmt|;
name|cp
operator|++
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|br_p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* 				 * Take all but the last component 				 */
name|todo
operator|=
name|E_Dir
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
comment|/* 				 * Take domain name 				 */
name|todo
operator|=
name|E_Domain
expr_stmt|;
name|cp
operator|++
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|br_p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* 				 * Take host name 				 */
name|todo
operator|=
name|E_Host
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Take the whole lot 				 */
name|todo
operator|=
name|E_All
expr_stmt|;
block|}
comment|/* 			 * Truncate if too long.  Since it won't 			 * match anyway it doesn't matter that 			 * it has been cut short. 			 */
if|if
condition|(
name|len
operator|>
name|NLEN
condition|)
name|len
operator|=
name|NLEN
expr_stmt|;
comment|/* 			 * Put the string into another buffer so 			 * we can do comparisons. 			 */
name|strncpy
argument_list|(
name|nbuf
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 			 * Advance cp 			 */
name|cp
operator|=
name|br_p
operator|+
literal|1
expr_stmt|;
comment|/* 			 * Search the option array 			 */
for|for
control|(
name|op
operator|=
name|opt_fields
init|;
name|op
operator|->
name|name
condition|;
name|op
operator|++
control|)
block|{
comment|/* 				 * Check for match 				 */
if|if
condition|(
name|len
operator|==
name|op
operator|->
name|nlen
operator|&&
name|STREQ
argument_list|(
name|op
operator|->
name|name
argument_list|,
name|nbuf
argument_list|)
condition|)
block|{
name|char
name|xbuf
index|[
name|NLEN
operator|+
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
comment|/* 					 * Found expansion.  Copy 					 * the correct value field. 					 */
if|if
condition|(
operator|!
operator|(
operator|!
name|op
operator|->
name|sel_p
operator|==
operator|!
name|sel_p
operator|)
condition|)
block|{
comment|/* 						 * Copy the string across unexpanded 						 */
name|sprintf
argument_list|(
name|xbuf
argument_list|,
literal|"${%s%s%s}"
argument_list|,
name|todo
operator|==
name|E_File
condition|?
literal|"/"
else|:
name|todo
operator|==
name|E_Domain
condition|?
literal|"."
else|:
literal|""
argument_list|,
name|nbuf
argument_list|,
name|todo
operator|==
name|E_Dir
condition|?
literal|"/"
else|:
name|todo
operator|==
name|E_Host
condition|?
literal|"."
else|:
literal|""
argument_list|)
expr_stmt|;
name|val
operator|=
name|xbuf
expr_stmt|;
comment|/* 						 * Make sure expansion doesn't 						 * munge the value! 						 */
name|todo
operator|=
name|E_All
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|->
name|sel_p
condition|)
block|{
name|val
operator|=
operator|*
name|op
operator|->
name|sel_p
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
operator|*
name|op
operator|->
name|optp
expr_stmt|;
block|}
if|if
condition|(
name|val
condition|)
block|{
comment|/* 						 * Do expansion: 						 * ${/var} means take just the last part 						 * ${var/} means take all but the last part 						 * ${.var} means take all but first part 						 * ${var.} means take just the first part 						 * ${var} means take the whole lot 						 */
name|int
name|vlen
init|=
name|strlen
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|char
modifier|*
name|vptr
init|=
name|val
decl_stmt|;
switch|switch
condition|(
name|todo
condition|)
block|{
case|case
name|E_Dir
case|:
name|vptr
operator|=
name|strrchr
argument_list|(
name|val
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|vptr
condition|)
name|vlen
operator|=
name|vptr
operator|-
name|val
expr_stmt|;
name|vptr
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|E_File
case|:
name|vptr
operator|=
name|strrchr
argument_list|(
name|val
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|vptr
condition|)
block|{
name|vptr
operator|++
expr_stmt|;
name|vlen
operator|=
name|strlen
argument_list|(
name|vptr
argument_list|)
expr_stmt|;
block|}
else|else
name|vptr
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|E_Domain
case|:
name|vptr
operator|=
name|strchr
argument_list|(
name|val
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|vptr
condition|)
block|{
name|vptr
operator|++
expr_stmt|;
name|vlen
operator|=
name|strlen
argument_list|(
name|vptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vptr
operator|=
literal|""
expr_stmt|;
name|vlen
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|E_Host
case|:
name|vptr
operator|=
name|strchr
argument_list|(
name|val
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|vptr
condition|)
name|vlen
operator|=
name|vptr
operator|-
name|val
expr_stmt|;
name|vptr
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|E_All
case|:
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/*dlog("Expanding \"%s\" to \"%s\"", nbuf, val);*/
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|BUFSPACE
argument_list|(
name|ep
argument_list|,
name|vlen
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|ep
argument_list|,
name|vptr
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|vlen
expr_stmt|;
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
name|expand_error
argument_list|,
operator|*
name|p
operator|->
name|opt
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 					 * Done with this variable 					 */
break|break;
block|}
block|}
comment|/* 			 * Check that the search was succesful 			 */
if|if
condition|(
operator|!
name|op
operator|->
name|name
condition|)
block|{
comment|/* 				 * If it wasn't then scan the 				 * environment for that name 				 * and use any value found 				 */
name|char
modifier|*
name|env
init|=
name|getenv
argument_list|(
name|nbuf
argument_list|)
decl_stmt|;
if|if
condition|(
name|env
condition|)
block|{
name|int
name|vlen
init|=
name|strlen
argument_list|(
name|env
argument_list|)
decl_stmt|;
if|if
condition|(
name|BUFSPACE
argument_list|(
name|ep
argument_list|,
name|vlen
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|ep
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|vlen
expr_stmt|;
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
name|expand_error
argument_list|,
operator|*
name|p
operator|->
name|opt
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|Debug
argument_list|(
argument|D_STR
argument_list|)
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"Environment gave \"%s\" -> \"%s\""
argument_list|,
name|nbuf
argument_list|,
name|env
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"Unknown sequence \"${%s}\""
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * Error, error 			 */
name|plog
argument_list|(
name|XLOG_USER
argument_list|,
literal|"Unknown $ sequence in \"%s\""
argument_list|,
operator|*
name|p
operator|->
name|opt
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
comment|/* 	 * Handle common case - no expansion 	 */
if|if
condition|(
name|cp
operator|==
operator|*
name|p
operator|->
name|opt
condition|)
block|{
operator|*
name|p
operator|->
name|opt
operator|=
name|strdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Finish off the expansion 		 */
if|if
condition|(
name|BUFSPACE
argument_list|(
name|ep
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|ep
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/*ep += strlen(ep);*/
block|}
else|else
block|{
name|plog
argument_list|(
name|XLOG_ERROR
argument_list|,
name|expand_error
argument_list|,
operator|*
name|p
operator|->
name|opt
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Save the exansion 		 */
operator|*
name|p
operator|->
name|opt
operator|=
name|strdup
argument_list|(
name|expbuf
argument_list|)
expr_stmt|;
block|}
name|normalize_slash
argument_list|(
operator|*
name|p
operator|->
name|opt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|Debug
argument_list|(
argument|D_STR
argument_list|)
block|{
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"Expansion of \"%s\"..."
argument_list|,
name|cp_orig
argument_list|)
expr_stmt|;
name|plog
argument_list|(
name|XLOG_DEBUG
argument_list|,
literal|"... is \"%s\""
argument_list|,
operator|*
name|p
operator|->
name|opt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
block|}
end_function

begin_comment
comment|/*  * Wrapper for expand_op  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|expand_opts
name|P
argument_list|(
operator|(
name|opt_apply
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|expand_opts
parameter_list|(
name|p
parameter_list|,
name|sel_p
parameter_list|)
name|opt_apply
modifier|*
name|p
decl_stmt|;
name|int
name|sel_p
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|p
operator|->
name|opt
condition|)
block|{
name|expand_op
argument_list|(
name|p
argument_list|,
name|sel_p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|val
condition|)
block|{
comment|/* 		 * Do double expansion, remembering 		 * to free the string from the first 		 * expansion... 		 */
name|char
modifier|*
name|s
init|=
operator|*
name|p
operator|->
name|opt
operator|=
name|expand_key
argument_list|(
name|p
operator|->
name|val
argument_list|)
decl_stmt|;
name|expand_op
argument_list|(
name|p
argument_list|,
name|sel_p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Apply a function to a list of options  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|apply_opts
argument_list|(
name|op
argument_list|,
name|ppp
argument_list|,
name|b
argument_list|)
name|void
argument_list|(
operator|*
name|op
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|opt_apply
name|ppp
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|opt_apply
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|ppp
init|;
name|pp
operator|->
name|opt
condition|;
name|pp
operator|++
control|)
call|(
modifier|*
name|op
call|)
argument_list|(
name|pp
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Free the option table  */
end_comment

begin_function
name|void
name|free_opts
parameter_list|(
name|fo
parameter_list|)
name|am_opts
modifier|*
name|fo
decl_stmt|;
block|{
comment|/* 	 * Copy in the structure we are playing with 	 */
name|fs_static
operator|=
operator|*
name|fo
expr_stmt|;
comment|/* 	 * Free previously allocated memory 	 */
name|apply_opts
argument_list|(
name|free_op
argument_list|,
name|to_free
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Expand lookup key  */
end_comment

begin_function
name|char
modifier|*
name|expand_key
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
block|{
name|opt_apply
name|oa
decl_stmt|;
name|oa
operator|.
name|opt
operator|=
operator|&
name|key
expr_stmt|;
name|oa
operator|.
name|val
operator|=
literal|0
expr_stmt|;
name|expand_opts
argument_list|(
operator|&
name|oa
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_comment
comment|/*  * Remove trailing /'s from a string  * unless the string is a single / (Steven Glassman)  */
end_comment

begin_decl_stmt
name|void
name|deslashify
name|P
argument_list|(
operator|(
name|char
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|deslashify
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|&&
operator|*
name|s
condition|)
block|{
name|char
modifier|*
name|sl
init|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
operator|--
name|sl
operator|==
literal|'/'
operator|&&
name|sl
operator|>
name|s
condition|)
operator|*
name|sl
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|eval_fs_opts
parameter_list|(
name|fo
parameter_list|,
name|opts
parameter_list|,
name|g_opts
parameter_list|,
name|path
parameter_list|,
name|key
parameter_list|,
name|map
parameter_list|)
name|am_opts
modifier|*
name|fo
decl_stmt|;
name|char
modifier|*
name|opts
decl_stmt|,
decl|*
name|g_opts
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|key
decl_stmt|,
modifier|*
name|map
decl_stmt|;
end_function

begin_block
block|{
name|int
name|ok
init|=
name|TRUE
decl_stmt|;
name|free_opts
argument_list|(
name|fo
argument_list|)
expr_stmt|;
comment|/* 	 * Clear out the option table 	 */
name|bzero
argument_list|(
operator|(
name|voidp
operator|)
operator|&
name|fs_static
argument_list|,
sizeof|sizeof
argument_list|(
name|fs_static
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|voidp
operator|)
name|vars
argument_list|,
sizeof|sizeof
argument_list|(
name|vars
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|voidp
operator|)
name|fo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fo
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set key, map& path before expansion 	 */
name|opt_key
operator|=
name|key
expr_stmt|;
name|opt_map
operator|=
name|map
expr_stmt|;
name|opt_path
operator|=
name|path
expr_stmt|;
comment|/* 	 * Expand global options 	 */
name|fs_static
operator|.
name|fs_glob
operator|=
name|expand_key
argument_list|(
name|g_opts
argument_list|)
expr_stmt|;
comment|/* 	 * Expand local options 	 */
name|fs_static
operator|.
name|fs_local
operator|=
name|expand_key
argument_list|(
name|opts
argument_list|)
expr_stmt|;
comment|/* 	 * Expand default (global) options 	 */
if|if
condition|(
operator|!
name|eval_opts
argument_list|(
name|fs_static
operator|.
name|fs_glob
argument_list|,
name|key
argument_list|)
condition|)
name|ok
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Expand local options 	 */
if|if
condition|(
name|ok
operator|&&
operator|!
name|eval_opts
argument_list|(
name|fs_static
operator|.
name|fs_local
argument_list|,
name|key
argument_list|)
condition|)
name|ok
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Normalise remote host name. 	 * 1.  Expand variables 	 * 2.  Normalize relative to host tables 	 * 3.  Strip local domains from the remote host 	 *     name before using it in other expansions. 	 *     This makes mount point names and other things 	 *     much shorter, while allowing cross domain 	 *     sharing of mount maps. 	 */
name|apply_opts
argument_list|(
name|expand_opts
argument_list|,
name|rhost_expansion
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|&&
name|fs_static
operator|.
name|opt_rhost
operator|&&
operator|*
name|fs_static
operator|.
name|opt_rhost
condition|)
name|host_normalize
argument_list|(
operator|&
name|fs_static
operator|.
name|opt_rhost
argument_list|)
expr_stmt|;
comment|/* 	 * Macro expand the options. 	 * Do this regardless of whether we are accepting 	 * this mount - otherwise nasty things happen 	 * with memory allocation. 	 */
name|apply_opts
argument_list|(
name|expand_opts
argument_list|,
name|expansions
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * Strip trailing slashes from local pathname... 	 */
name|deslashify
argument_list|(
name|fs_static
operator|.
name|opt_fs
argument_list|)
expr_stmt|;
comment|/* 	 * ok... copy the data back out. 	 */
operator|*
name|fo
operator|=
name|fs_static
expr_stmt|;
comment|/* 	 * Clear defined options 	 */
name|opt_key
operator|=
name|opt_map
operator|=
name|opt_path
operator|=
name|nullstr
expr_stmt|;
return|return
name|ok
return|;
block|}
end_block

end_unit

