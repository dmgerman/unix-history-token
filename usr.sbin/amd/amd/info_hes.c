begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Jan-Simon Pendry  * Copyright (c) 1989 Imperial College of Science, Technology& Medicine  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Jan-Simon Pendry at Imperial College, London.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)info_hes.c	8.1 (Berkeley) 6/6/93  *  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Get info from Hesiod  *  * Zone transfer code from Bruce Cole<cole@cs.wisc.edu>  */
end_comment

begin_include
include|#
directive|include
file|"am.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_HESIOD_MAPS
end_ifdef

begin_include
include|#
directive|include
file|<hesiod.h>
end_include

begin_define
define|#
directive|define
name|HES_PREFIX
value|"hesiod."
end_define

begin_define
define|#
directive|define
name|HES_PREFLEN
value|7
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_HESIOD_RELOAD
end_ifdef

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_comment
comment|/*  * Patch up broken system include files  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|C_HS
end_ifndef

begin_define
define|#
directive|define
name|C_HS
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|T_TXT
end_ifndef

begin_define
define|#
directive|define
name|T_TXT
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|soacnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|hs_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|servernum
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAS_HESIOD_RELOAD */
end_comment

begin_comment
comment|/*  * No easy way to probe the server - check the map name begins with "hesiod."  */
end_comment

begin_decl_stmt
name|int
name|hesiod_init
name|P
argument_list|(
operator|(
name|char
operator|*
name|map
operator|,
name|time_t
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|hesiod_init
parameter_list|(
name|map
parameter_list|,
name|tp
parameter_list|)
name|char
modifier|*
name|map
decl_stmt|;
name|time_t
modifier|*
name|tp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hesiod_init(%s)"
argument_list|,
name|map
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|tp
operator|=
literal|0
expr_stmt|;
return|return
name|strncmp
argument_list|(
name|map
argument_list|,
name|HES_PREFIX
argument_list|,
name|HES_PREFLEN
argument_list|)
operator|==
literal|0
condition|?
literal|0
else|:
name|ENOENT
return|;
block|}
end_function

begin_comment
comment|/*  * Make Hesiod name.  Skip past the "hesiod."  * at the start of the map name and append  * ".automount".  The net effect is that a lookup  * of /defaults in hesiod.home will result in a  * call to hes_resolve("/defaults", "home.automount");  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_define
define|#
directive|define
name|MAKE_HES_NAME
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
value|sprintf(dest, "%s%s", src + HES_PREFLEN, ".automount")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Do a Hesiod nameserver call.  * Modify time is ignored by Hesiod - XXX  */
end_comment

begin_decl_stmt
name|int
name|hesiod_search
name|P
argument_list|(
operator|(
name|mnt_map
operator|*
name|m
operator|,
name|char
operator|*
name|map
operator|,
name|char
operator|*
name|key
operator|,
name|char
operator|*
operator|*
name|pval
operator|,
name|time_t
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|hesiod_search
parameter_list|(
name|m
parameter_list|,
name|map
parameter_list|,
name|key
parameter_list|,
name|pval
parameter_list|,
name|tp
parameter_list|)
name|mnt_map
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|map
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
modifier|*
name|pval
decl_stmt|;
name|time_t
modifier|*
name|tp
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|char
name|hes_key
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|rvec
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hesiod_search(m=%x, map=%s, key=%s, pval=%x tp=%x)"
argument_list|,
name|m
argument_list|,
name|map
argument_list|,
name|key
argument_list|,
name|pval
argument_list|,
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*MAKE_HES_NAME(hes_map, map);*/
name|sprintf
argument_list|(
name|hes_key
argument_list|,
literal|"%s.%s"
argument_list|,
name|key
argument_list|,
name|map
operator|+
name|HES_PREFLEN
argument_list|)
expr_stmt|;
comment|/* 	 * Call the resolver 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hesiod_search: hes_resolve(%s, %s)"
argument_list|,
name|hes_key
argument_list|,
literal|"automount"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_HESIOD_RELOAD
if|if
condition|(
name|debug_flags
operator|&
name|D_FULL
condition|)
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|rvec
operator|=
name|hes_resolve
argument_list|(
name|hes_key
argument_list|,
literal|"automount"
argument_list|)
expr_stmt|;
comment|/* 	 * If a reply was forthcoming then return 	 * it (and free subsequent replies) 	 */
if|if
condition|(
name|rvec
operator|&&
operator|*
name|rvec
condition|)
block|{
operator|*
name|pval
operator|=
operator|*
name|rvec
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|rvec
condition|)
name|free
argument_list|(
operator|*
name|rvec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Otherwise reflect the hesiod error into a Un*x error 	 */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hesiod_search: Error: %d"
argument_list|,
name|hes_error
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|hes_error
argument_list|()
condition|)
block|{
case|case
name|HES_ER_NOTFOUND
case|:
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
case|case
name|HES_ER_CONFIG
case|:
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|HES_ER_NET
case|:
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hesiod_search: Returning: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_HESIOD_RELOAD
end_ifdef

begin_comment
comment|/*  * Zone transfer...  */
end_comment

begin_define
define|#
directive|define
name|MAXHSNS
value|8
end_define

begin_define
define|#
directive|define
name|MAX_NSADDR
value|16
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|hs_domain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mnt_map
modifier|*
name|hs_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hs_nscount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|nsaddr_list
index|[
name|MAX_NSADDR
index|]
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hesiod_reload
name|P
argument_list|(
operator|(
name|mnt_map
operator|*
name|m
operator|,
name|char
operator|*
name|map
operator|,
name|void
argument_list|(
operator|*
name|fn
argument_list|)
argument_list|()
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hesiod_reload
argument_list|(
name|m
argument_list|,
name|map
argument_list|,
name|fn
argument_list|)
name|mnt_map
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|map
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|char
modifier|*
name|zone_name
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|short
name|domainlen
decl_stmt|;
name|int
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hesiod_reload (%x %s %x)"
argument_list|,
name|m
argument_list|,
name|map
argument_list|,
name|fn
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|status
operator|=
name|res_init
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hesiod_reload: res_init failed with %d"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|status
operator|)
return|;
block|}
name|_res
operator|.
name|retrans
operator|=
literal|90
expr_stmt|;
name|hs_map
operator|=
name|m
expr_stmt|;
name|domainlen
operator|=
name|strlen
argument_list|(
name|hostdomain
argument_list|)
expr_stmt|;
name|zone_name
operator|=
name|hes_to_bind
argument_list|(
name|map
operator|+
name|HES_PREFLEN
argument_list|,
literal|"automount"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|zone_name
operator|==
literal|'.'
condition|)
name|zone_name
operator|++
expr_stmt|;
name|hs_domain
operator|=
name|zone_name
expr_stmt|;
comment|/* Traverse the DNS tree until we find an SOA we can transfer from. 	 (Our initial zone_name is likely to just be a subtree of a 	 real zone). */
do|do
block|{
comment|/* If we can't find any NS records, go up a level in the 		   DNS tree */
if|if
condition|(
name|hs_get_ns_list
argument_list|(
name|zone_name
argument_list|)
operator|==
literal|0
operator|&&
name|hs_zone_transfer
argument_list|(
name|zone_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Move up DNS tree by one component */
if|if
condition|(
name|cp
operator|=
name|strchr
argument_list|(
name|zone_name
argument_list|,
literal|'.'
argument_list|)
condition|)
name|zone_name
operator|=
operator|++
name|cp
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
name|strlen
argument_list|(
name|zone_name
argument_list|)
operator|>=
name|domainlen
condition|)
do|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hesiod_reload: Giving up on %s"
argument_list|,
name|hs_domain
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_macro
name|hs_zone_transfer
argument_list|(
argument|domain
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
decl_stmt|,
name|len
decl_stmt|;
name|char
name|buf
index|[
name|PACKETSZ
index|]
decl_stmt|;
comment|/* Want to make sure ansbuf is well alligned */
name|long
name|ansbuf
index|[
name|PACKETSZ
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_zone_transfer (%s)"
argument_list|,
name|domain
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|len
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|domain
argument_list|,
name|C_HS
argument_list|,
name|T_AXFR
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|PACKETSZ
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_zone_transfer: res_mkquery failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|hs_res_send
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ansbuf
argument_list|,
name|PACKETSZ
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_zone_transfer: hs_res_send failed.  status %d errno %d"
argument_list|,
name|status
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|hs_server_addr
parameter_list|(
name|ns
parameter_list|)
value|((struct in_addr *) nsaddr_list[ns])
end_define

begin_macro
name|hs_res_send
argument_list|(
argument|buf
argument_list|,
argument|buflen
argument_list|,
argument|answer
argument_list|,
argument|anslen
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|buflen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|answer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|anslen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|retry
decl_stmt|,
name|ns
decl_stmt|;
name|u_short
name|id
decl_stmt|,
name|len
decl_stmt|;
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|buf
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
specifier|static
name|int
name|s
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|sockaddr_in
name|server
decl_stmt|;
name|soacnt
operator|=
literal|0
expr_stmt|;
name|id
operator|=
name|hp
operator|->
name|id
expr_stmt|;
comment|/* 	 * Send request, RETRY times, or until successful 	 */
for|for
control|(
name|retry
operator|=
name|_res
operator|.
name|retry
init|;
name|retry
operator|>
literal|0
condition|;
name|retry
operator|--
control|)
block|{
for|for
control|(
name|ns
operator|=
literal|0
init|;
name|ns
operator|<
name|hs_nscount
condition|;
name|ns
operator|++
control|)
block|{
name|hs_timeout
operator|.
name|tv_sec
operator|=
operator|(
name|_res
operator|.
name|retrans
operator|<<
operator|(
name|_res
operator|.
name|retry
operator|-
name|retry
operator|)
operator|)
operator|/
name|hs_nscount
expr_stmt|;
if|if
condition|(
name|hs_timeout
operator|.
name|tv_sec
operator|<=
literal|0
condition|)
name|hs_timeout
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|hs_timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
continue|continue;
block|}
name|servernum
operator|=
name|ns
expr_stmt|;
name|bcopy
argument_list|(
name|hs_server_addr
argument_list|(
name|ns
argument_list|)
argument_list|,
operator|&
name|server
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|server
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|server
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|&
name|server
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 			 * Send length& message 			 */
name|len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|buflen
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|len
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|buflen
expr_stmt|;
if|if
condition|(
name|writev
argument_list|(
name|s
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|len
argument_list|)
operator|+
name|buflen
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
name|status
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|s
operator|!=
operator|-
literal|1
operator|&&
name|soacnt
operator|<
literal|2
operator|&&
name|status
operator|!=
operator|-
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|=
name|hs_readresp
argument_list|(
name|s
argument_list|,
name|answer
argument_list|,
name|anslen
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|status
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* There was a permanent error transfering this 				   zone.  Give up. */
if|if
condition|(
name|s
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|s
operator|==
operator|-
literal|1
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Returns:    0: Success    -1: Error    -2: Permanent failure */
end_comment

begin_macro
name|hs_readresp
argument_list|(
argument|s
argument_list|,
argument|answer
argument_list|,
argument|anslen
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|answer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|anslen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|len
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|answer
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|!=
literal|0
operator|&&
operator|(
name|n
operator|=
name|hs_res_vcread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
operator|&
name|hs_timeout
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|answer
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
operator|)
operator|>
name|anslen
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_readresp: response too long: %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
name|len
operator|!=
literal|0
operator|&&
operator|(
name|n
operator|=
name|hs_res_vcread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
operator|&
name|hs_timeout
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|hs_parse
argument_list|(
name|answer
argument_list|,
name|answer
operator|+
name|PACKETSZ
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|hs_res_vcread
argument_list|(
argument|sock
argument_list|,
argument|buf
argument_list|,
argument|buflen
argument_list|,
argument|timeout
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sock
decl_stmt|,
name|buflen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
modifier|*
name|timeout
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|hs_res_selwait
argument_list|(
name|sock
argument_list|,
name|timeout
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
operator|(
name|read
argument_list|(
name|sock
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_macro
name|hs_res_selwait
argument_list|(
argument|sock
argument_list|,
argument|timeout
argument_list|)
end_macro

begin_decl_stmt
name|int
name|sock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
modifier|*
name|timeout
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fd_set
name|dsmask
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
comment|/* 	 * Wait for reply 	 */
name|FD_ZERO
argument_list|(
operator|&
name|dsmask
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sock
argument_list|,
operator|&
name|dsmask
argument_list|)
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|sock
operator|+
literal|1
argument_list|,
operator|&
name|dsmask
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
name|NULL
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Returns:    0: Success    -1: Error    -2: Permanent failure */
end_comment

begin_macro
name|hs_parse
argument_list|(
argument|msg
argument_list|,
argument|eom
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
name|int
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|;
name|char
name|key
index|[
name|PACKETSZ
index|]
decl_stmt|;
name|char
modifier|*
name|key_cpy
decl_stmt|,
modifier|*
name|value
decl_stmt|,
modifier|*
name|hs_make_value
argument_list|()
decl_stmt|;
name|short
name|type
decl_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
name|hp
operator|->
name|opcode
operator|!=
name|QUERY
condition|)
block|{
name|char
name|dq
index|[
literal|20
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Bad response (%d) from nameserver %s"
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|inet_dquad
argument_list|(
name|dq
argument_list|,
name|hs_server_addr
argument_list|(
name|servernum
argument_list|)
operator|->
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|=
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
while|while
condition|(
name|qdcount
operator|--
operator|>
literal|0
condition|)
name|cp
operator|+=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|+
name|QFIXEDSZ
expr_stmt|;
if|if
condition|(
name|soacnt
operator|==
literal|0
operator|&&
name|ancount
operator|==
literal|0
condition|)
block|{
comment|/* XXX We should look for NS records to find SOA */
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"No SOA found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
while|while
condition|(
name|ancount
operator|--
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|key
argument_list|,
name|PACKETSZ
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
operator|)
operator|==
name|T_SOA
condition|)
block|{
name|soacnt
operator|++
expr_stmt|;
block|}
name|cp
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|len
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
comment|/* Check to see if key is in our domain */
if|if
condition|(
name|type
operator|==
name|T_TXT
operator|&&
name|hs_strip_our_domain
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|value
operator|=
name|hs_make_value
argument_list|(
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|key_cpy
operator|=
name|strdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_parse: Parsed key: %s, value: %s"
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mapc_add_kv
argument_list|(
name|hs_map
argument_list|,
name|key_cpy
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Check to see if the domain name in the supplied argument matches    hs_domain.  Strip hs_domain from supplied argument if so. */
end_comment

begin_macro
name|hs_strip_our_domain
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|end_pos
decl_stmt|;
name|short
name|targ_len
decl_stmt|,
name|cur_len
decl_stmt|;
name|targ_len
operator|=
name|strlen
argument_list|(
name|hs_domain
argument_list|)
expr_stmt|;
name|cur_len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_len
operator|<=
name|targ_len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|end_pos
operator|=
operator|&
name|name
index|[
name|cur_len
operator|-
name|targ_len
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|end_pos
argument_list|,
name|hs_domain
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
operator|--
name|end_pos
operator|!=
literal|'.'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|end_pos
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MAXDATA
value|8*1024
end_define

begin_function
name|char
modifier|*
name|hs_make_value
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|cpcpy
decl_stmt|,
modifier|*
name|valuep
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|nextcnt
decl_stmt|,
name|totalcnt
decl_stmt|,
name|lencpy
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|char
modifier|*
name|dbgname
decl_stmt|;
name|dbgname
operator|=
operator|&
name|cp
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|lencpy
operator|=
name|len
expr_stmt|;
name|cpcpy
operator|=
name|cp
expr_stmt|;
name|totalcnt
operator|=
literal|0
expr_stmt|;
name|cnt
operator|=
operator|*
name|cpcpy
operator|++
expr_stmt|;
while|while
condition|(
name|cnt
condition|)
block|{
name|totalcnt
operator|+=
name|cnt
expr_stmt|;
name|lencpy
operator|-=
name|cnt
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|lencpy
operator|==
literal|0
condition|)
break|break;
name|nextcnt
operator|=
name|cpcpy
index|[
name|cnt
index|]
expr_stmt|;
name|cpcpy
operator|=
operator|&
name|cpcpy
index|[
name|cnt
operator|+
literal|1
index|]
expr_stmt|;
name|cnt
operator|=
name|nextcnt
expr_stmt|;
block|}
if|if
condition|(
name|totalcnt
operator|<
literal|1
operator|||
name|totalcnt
operator|>
name|MAXDATA
operator|||
name|totalcnt
operator|>
name|len
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"TXT RR not of expected length (%d %d): %s"
argument_list|,
name|totalcnt
argument_list|,
name|len
argument_list|,
name|dbgname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Allocate null terminated string */
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|totalcnt
operator|+
literal|1
argument_list|)
expr_stmt|;
name|value
index|[
name|totalcnt
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cnt
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|valuep
operator|=
name|value
expr_stmt|;
while|while
condition|(
name|cnt
condition|)
block|{
name|bcopy
argument_list|(
name|cp
argument_list|,
name|valuep
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|len
operator|-=
name|cnt
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
name|valuep
operator|=
operator|&
name|valuep
index|[
name|cnt
index|]
expr_stmt|;
name|nextcnt
operator|=
name|cp
index|[
name|cnt
index|]
expr_stmt|;
name|cp
operator|=
operator|&
name|cp
index|[
name|cnt
operator|+
literal|1
index|]
expr_stmt|;
name|cnt
operator|=
name|nextcnt
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_macro
name|hs_make_ns_query
argument_list|(
argument|domain
argument_list|,
argument|ansbuf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ansbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|status
decl_stmt|,
name|len
decl_stmt|;
name|char
name|buf
index|[
name|PACKETSZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|domain
argument_list|,
name|C_HS
argument_list|,
name|T_NS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|PACKETSZ
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_get_ns_list: res_mkquery failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|res_send
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ansbuf
argument_list|,
name|PACKETSZ
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_get_ns_list: res_send failed.  status %d errno %d"
argument_list|,
name|status
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|add_address
parameter_list|(
name|addr
parameter_list|)
name|struct
name|in_addr
modifier|*
name|addr
decl_stmt|;
block|{
name|char
name|dq
index|[
literal|20
index|]
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|nsaddr_list
index|[
name|hs_nscount
operator|++
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Adding NS address %s"
argument_list|,
name|inet_dquad
argument_list|(
name|dq
argument_list|,
name|addr
operator|->
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
block|}
end_function

begin_macro
name|hs_get_ns_list
argument_list|(
argument|domain
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|int
name|qdcount
decl_stmt|,
name|nscount
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|len
decl_stmt|;
name|char
name|key
index|[
name|PACKETSZ
index|]
decl_stmt|,
name|name
index|[
name|PACKETSZ
index|]
decl_stmt|,
name|msg
index|[
name|PACKETSZ
index|]
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
specifier|register
name|long
modifier|*
modifier|*
name|hptr
decl_stmt|;
name|struct
name|hostent
modifier|*
name|ghp
decl_stmt|;
name|int
name|numns
decl_stmt|;
name|char
name|nsname
index|[
name|MAXHSNS
index|]
index|[
name|MAXDATA
index|]
decl_stmt|;
name|int
name|nshaveaddr
index|[
name|MAXHSNS
index|]
decl_stmt|,
name|i
decl_stmt|;
name|short
name|type
decl_stmt|;
if|if
condition|(
name|hs_make_ns_query
argument_list|(
name|domain
argument_list|,
name|msg
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|numns
operator|=
name|hs_nscount
operator|=
literal|0
expr_stmt|;
name|eom
operator|=
operator|&
name|msg
index|[
name|PACKETSZ
index|]
expr_stmt|;
name|bzero
argument_list|(
name|nsname
argument_list|,
sizeof|sizeof
argument_list|(
name|nsname
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
name|hp
operator|->
name|opcode
operator|!=
name|QUERY
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"Bad response (%d) from nameserver %#x"
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|hs_server_addr
argument_list|(
name|servernum
argument_list|)
operator|->
name|s_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|=
name|msg
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
while|while
condition|(
name|qdcount
operator|--
operator|>
literal|0
condition|)
name|cp
operator|+=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|+
name|QFIXEDSZ
expr_stmt|;
name|nscount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|+
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
operator|+
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_get_ns_list: Processing %d response records"
argument_list|,
name|nscount
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|nscount
condition|;
name|nscount
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|key
argument_list|,
name|PACKETSZ
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
name|cp
operator|+=
name|n
expr_stmt|;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|len
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_get_ns_list: Record type: %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_NS
case|:
if|if
condition|(
name|numns
operator|>=
name|MAXHSNS
operator|||
name|strcasecmp
argument_list|(
name|domain
argument_list|,
name|key
argument_list|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|name
argument_list|,
name|PACKETSZ
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_get_ns_list: NS name: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numns
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|numns
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_get_ns_list: Saving name %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strncpy
argument_list|(
name|nsname
index|[
name|numns
index|]
argument_list|,
name|name
argument_list|,
name|MAXDATA
argument_list|)
expr_stmt|;
name|nshaveaddr
index|[
name|numns
index|]
operator|=
literal|0
expr_stmt|;
name|numns
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|T_A
case|:
if|if
condition|(
name|hs_nscount
operator|==
name|MAX_NSADDR
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|,
name|domain
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nshaveaddr
index|[
name|i
index|]
operator|++
expr_stmt|;
name|add_address
argument_list|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|hs_nscount
operator|==
name|MAX_NSADDR
condition|)
break|break;
name|cp
operator|+=
name|len
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"hs_get_ns_list: Found %d NS records"
argument_list|,
name|numns
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nshaveaddr
index|[
name|i
index|]
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ghp
operator|=
name|gethostbyname
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|hptr
operator|=
operator|(
name|long
operator|*
operator|*
operator|)
name|ghp
operator|->
name|h_addr_list
init|;
operator|*
name|hptr
operator|&&
name|hs_nscount
operator|<
name|MAX_NSADDR
condition|;
name|hptr
operator|++
control|)
block|{
name|add_address
argument_list|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|*
name|hptr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hs_nscount
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|dlog
argument_list|(
literal|"No NS records found for %s"
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
endif|DEBUG
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAS_HESIOD_RELOAD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAS_HESIOD_MAPS */
end_comment

end_unit

