begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Edward Tomasz Napierala under sponsorship  * from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<openssl/err.h>
end_include

begin_include
include|#
directive|include
file|<openssl/md5.h>
end_include

begin_include
include|#
directive|include
file|<openssl/rand.h>
end_include

begin_include
include|#
directive|include
file|"ctld.h"
end_include

begin_include
include|#
directive|include
file|"iscsi_proto.h"
end_include

begin_function_decl
specifier|static
name|void
name|login_send_error
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|,
name|char
name|class
parameter_list|,
name|char
name|detail
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|login_set_nsg
parameter_list|(
name|struct
name|pdu
modifier|*
name|response
parameter_list|,
name|int
name|nsg
parameter_list|)
block|{
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr
decl_stmt|;
name|assert
argument_list|(
name|nsg
operator|==
name|BHSLR_STAGE_SECURITY_NEGOTIATION
operator|||
name|nsg
operator|==
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
operator|||
name|nsg
operator|==
name|BHSLR_STAGE_FULL_FEATURE_PHASE
argument_list|)
expr_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr
operator|->
name|bhslr_flags
operator|&=
literal|0xFC
expr_stmt|;
name|bhslr
operator|->
name|bhslr_flags
operator||=
name|nsg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|login_csg
parameter_list|(
specifier|const
name|struct
name|pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|iscsi_bhs_login_request
modifier|*
name|bhslr
decl_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_request
operator|*
operator|)
name|request
operator|->
name|pdu_bhs
expr_stmt|;
return|return
operator|(
operator|(
name|bhslr
operator|->
name|bhslr_flags
operator|&
literal|0x0C
operator|)
operator|>>
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_set_csg
parameter_list|(
name|struct
name|pdu
modifier|*
name|response
parameter_list|,
name|int
name|csg
parameter_list|)
block|{
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr
decl_stmt|;
name|assert
argument_list|(
name|csg
operator|==
name|BHSLR_STAGE_SECURITY_NEGOTIATION
operator|||
name|csg
operator|==
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
operator|||
name|csg
operator|==
name|BHSLR_STAGE_FULL_FEATURE_PHASE
argument_list|)
expr_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr
operator|->
name|bhslr_flags
operator|&=
literal|0xF3
expr_stmt|;
name|bhslr
operator|->
name|bhslr_flags
operator||=
name|csg
operator|<<
literal|2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pdu
modifier|*
name|login_receive
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|,
name|bool
name|initial
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|iscsi_bhs_login_request
modifier|*
name|bhslr
decl_stmt|;
name|request
operator|=
name|pdu_new
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|pdu_receive
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|request
operator|->
name|pdu_bhs
operator|->
name|bhs_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|!=
name|ISCSI_BHS_OPCODE_LOGIN_REQUEST
condition|)
block|{
comment|/* 		 * The first PDU in session is special - if we receive any PDU 		 * different than login request, we have to drop the connection 		 * without sending response ("A target receiving any PDU 		 * except a Login request before the Login Phase is started MUST 		 * immediately terminate the connection on which the PDU 		 * was received.") 		 */
if|if
condition|(
name|initial
operator|==
name|false
condition|)
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x0b
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"protocol error: received invalid opcode 0x%x"
argument_list|,
name|request
operator|->
name|pdu_bhs
operator|->
name|bhs_opcode
argument_list|)
expr_stmt|;
block|}
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_request
operator|*
operator|)
name|request
operator|->
name|pdu_bhs
expr_stmt|;
comment|/* 	 * XXX: Implement the C flag some day. 	 */
if|if
condition|(
operator|(
name|bhslr
operator|->
name|bhslr_flags
operator|&
name|BHSLR_FLAGS_CONTINUE
operator|)
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x03
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with unsupported \"C\" flag"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bhslr
operator|->
name|bhslr_version_max
operator|!=
literal|0x00
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with unsupported "
literal|"Version-max 0x%x"
argument_list|,
name|bhslr
operator|->
name|bhslr_version_max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bhslr
operator|->
name|bhslr_version_min
operator|!=
literal|0x00
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with unsupported "
literal|"Version-min 0x%x"
argument_list|,
name|bhslr
operator|->
name|bhslr_version_min
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|bhslr
operator|->
name|bhslr_cmdsn
argument_list|)
operator|<
name|conn
operator|->
name|conn_cmdsn
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with decreasing CmdSN: "
literal|"was %d, is %d"
argument_list|,
name|conn
operator|->
name|conn_cmdsn
argument_list|,
name|ntohl
argument_list|(
name|bhslr
operator|->
name|bhslr_cmdsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initial
operator|==
name|false
operator|&&
name|ntohl
argument_list|(
name|bhslr
operator|->
name|bhslr_expstatsn
argument_list|)
operator|!=
name|conn
operator|->
name|conn_statsn
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with wrong ExpStatSN: "
literal|"is %d, should be %d"
argument_list|,
name|ntohl
argument_list|(
name|bhslr
operator|->
name|bhslr_expstatsn
argument_list|)
argument_list|,
name|conn
operator|->
name|conn_statsn
argument_list|)
expr_stmt|;
block|}
name|conn
operator|->
name|conn_cmdsn
operator|=
name|ntohl
argument_list|(
name|bhslr
operator|->
name|bhslr_cmdsn
argument_list|)
expr_stmt|;
return|return
operator|(
name|request
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pdu
modifier|*
name|login_new_response
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|connection
modifier|*
name|conn
decl_stmt|;
name|struct
name|iscsi_bhs_login_request
modifier|*
name|bhslr
decl_stmt|;
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr2
decl_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_request
operator|*
operator|)
name|request
operator|->
name|pdu_bhs
expr_stmt|;
name|conn
operator|=
name|request
operator|->
name|pdu_connection
expr_stmt|;
name|response
operator|=
name|pdu_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhslr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_opcode
operator|=
name|ISCSI_BHS_OPCODE_LOGIN_RESPONSE
expr_stmt|;
name|login_set_csg
argument_list|(
name|response
argument_list|,
name|BHSLR_STAGE_SECURITY_NEGOTIATION
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bhslr2
operator|->
name|bhslr_isid
argument_list|,
name|bhslr
operator|->
name|bhslr_isid
argument_list|,
sizeof|sizeof
argument_list|(
name|bhslr2
operator|->
name|bhslr_isid
argument_list|)
argument_list|)
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_initiator_task_tag
operator|=
name|bhslr
operator|->
name|bhslr_initiator_task_tag
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_statsn
operator|=
name|htonl
argument_list|(
name|conn
operator|->
name|conn_statsn
operator|++
argument_list|)
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_expcmdsn
operator|=
name|htonl
argument_list|(
name|conn
operator|->
name|conn_cmdsn
argument_list|)
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_maxcmdsn
operator|=
name|htonl
argument_list|(
name|conn
operator|->
name|conn_cmdsn
argument_list|)
expr_stmt|;
return|return
operator|(
name|response
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_send_error
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|,
name|char
name|class
parameter_list|,
name|char
name|detail
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr2
decl_stmt|;
name|log_debugx
argument_list|(
literal|"sending Login Response PDU with failure class 0x%x/0x%x; "
literal|"see next line for reason"
argument_list|,
name|class
argument_list|,
name|detail
argument_list|)
expr_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhslr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_status_class
operator|=
name|class
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_status_detail
operator|=
name|detail
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|login_list_contains
parameter_list|(
specifier|const
name|char
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|)
block|{
name|char
modifier|*
name|tofree
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|tofree
operator|=
name|str
operator|=
name|checked_strdup
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|what
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|login_list_prefers
parameter_list|(
specifier|const
name|char
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|choice1
parameter_list|,
specifier|const
name|char
modifier|*
name|choice2
parameter_list|)
block|{
name|char
modifier|*
name|tofree
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|tofree
operator|=
name|str
operator|=
name|checked_strdup
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|choice1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|choice2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|login_hex2int
parameter_list|(
specifier|const
name|char
name|hex
parameter_list|)
block|{
switch|switch
condition|(
name|hex
condition|)
block|{
case|case
literal|'0'
case|:
return|return
operator|(
literal|0x00
operator|)
return|;
case|case
literal|'1'
case|:
return|return
operator|(
literal|0x01
operator|)
return|;
case|case
literal|'2'
case|:
return|return
operator|(
literal|0x02
operator|)
return|;
case|case
literal|'3'
case|:
return|return
operator|(
literal|0x03
operator|)
return|;
case|case
literal|'4'
case|:
return|return
operator|(
literal|0x04
operator|)
return|;
case|case
literal|'5'
case|:
return|return
operator|(
literal|0x05
operator|)
return|;
case|case
literal|'6'
case|:
return|return
operator|(
literal|0x06
operator|)
return|;
case|case
literal|'7'
case|:
return|return
operator|(
literal|0x07
operator|)
return|;
case|case
literal|'8'
case|:
return|return
operator|(
literal|0x08
operator|)
return|;
case|case
literal|'9'
case|:
return|return
operator|(
literal|0x09
operator|)
return|;
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
return|return
operator|(
literal|0x0a
operator|)
return|;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
return|return
operator|(
literal|0x0b
operator|)
return|;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
return|return
operator|(
literal|0x0c
operator|)
return|;
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
return|return
operator|(
literal|0x0d
operator|)
return|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
return|return
operator|(
literal|0x0e
operator|)
return|;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
return|return
operator|(
literal|0x0f
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX: Review this _carefully_.  */
end_comment

begin_function
specifier|static
name|int
name|login_hex2bin
parameter_list|(
specifier|const
name|char
modifier|*
name|hex
parameter_list|,
name|char
modifier|*
modifier|*
name|binp
parameter_list|,
name|size_t
modifier|*
name|bin_lenp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|hex_len
decl_stmt|,
name|nibble
decl_stmt|;
name|bool
name|lo
init|=
name|true
decl_stmt|;
comment|/* As opposed to 'hi'. */
name|char
modifier|*
name|bin
decl_stmt|;
name|size_t
name|bin_off
decl_stmt|,
name|bin_len
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|hex
argument_list|,
literal|"0x"
argument_list|,
name|strlen
argument_list|(
literal|"0x"
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log_warnx
argument_list|(
literal|"malformed variable, should start with \"0x\""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|hex
operator|+=
name|strlen
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
name|hex_len
operator|=
name|strlen
argument_list|(
name|hex
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex_len
operator|<
literal|1
condition|)
block|{
name|log_warnx
argument_list|(
literal|"malformed variable; doesn't contain anything "
literal|"but \"0x\""
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bin_len
operator|=
name|hex_len
operator|/
literal|2
operator|+
name|hex_len
operator|%
literal|2
expr_stmt|;
name|bin
operator|=
name|calloc
argument_list|(
name|bin_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
operator|==
name|NULL
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"calloc"
argument_list|)
expr_stmt|;
name|bin_off
operator|=
name|bin_len
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|hex_len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|nibble
operator|=
name|login_hex2int
argument_list|(
name|hex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nibble
operator|<
literal|0
condition|)
block|{
name|log_warnx
argument_list|(
literal|"malformed variable, invalid char \"%c\""
argument_list|,
name|hex
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|assert
argument_list|(
name|bin_off
operator|<
name|bin_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|lo
condition|)
block|{
name|bin
index|[
name|bin_off
index|]
operator|=
name|nibble
expr_stmt|;
name|lo
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|bin
index|[
name|bin_off
index|]
operator||=
name|nibble
operator|<<
literal|4
expr_stmt|;
name|bin_off
operator|--
expr_stmt|;
name|lo
operator|=
name|true
expr_stmt|;
block|}
block|}
operator|*
name|binp
operator|=
name|bin
expr_stmt|;
operator|*
name|bin_lenp
operator|=
name|bin_len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|login_bin2hex
parameter_list|(
specifier|const
name|char
modifier|*
name|bin
parameter_list|,
name|size_t
name|bin_len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|hex
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
name|ch
decl_stmt|;
name|size_t
name|hex_len
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|hex_len
operator|=
name|bin_len
operator|*
literal|2
operator|+
literal|3
expr_stmt|;
comment|/* +2 for "0x", +1 for '\0'. */
name|hex
operator|=
name|malloc
argument_list|(
name|hex_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|hex
operator|==
name|NULL
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|hex
expr_stmt|;
name|tmp
operator|+=
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bin_len
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|bin
index|[
name|i
index|]
expr_stmt|;
name|tmp
operator|+=
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%02x"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|hex
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_compute_md5
parameter_list|(
specifier|const
name|char
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|secret
parameter_list|,
specifier|const
name|void
modifier|*
name|challenge
parameter_list|,
name|size_t
name|challenge_len
parameter_list|,
name|void
modifier|*
name|response
parameter_list|,
name|size_t
name|response_len
parameter_list|)
block|{
name|MD5_CTX
name|ctx
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|assert
argument_list|(
name|response_len
operator|==
name|MD5_DIGEST_LENGTH
argument_list|)
expr_stmt|;
name|MD5_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|secret
argument_list|,
name|strlen
argument_list|(
name|secret
argument_list|)
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|challenge
argument_list|,
name|challenge_len
argument_list|)
expr_stmt|;
name|rv
operator|=
name|MD5_Final
argument_list|(
name|response
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
condition|)
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"MD5_Final"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|LOGIN_CHALLENGE_LEN
value|1024
end_define

begin_function
specifier|static
name|struct
name|pdu
modifier|*
name|login_receive_chap_a
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|keys
modifier|*
name|request_keys
decl_stmt|;
specifier|const
name|char
modifier|*
name|chap_a
decl_stmt|;
name|request
operator|=
name|login_receive
argument_list|(
name|conn
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|request_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_load
argument_list|(
name|request_keys
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|chap_a
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"CHAP_A"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chap_a
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU without CHAP_A"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|login_list_contains
argument_list|(
name|chap_a
argument_list|,
literal|"5"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU with unsupported CHAP_A "
literal|"\"%s\""
argument_list|,
name|chap_a
argument_list|)
expr_stmt|;
block|}
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
return|return
operator|(
name|request
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_send_chap_c
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|,
specifier|const
name|unsigned
name|char
name|id
parameter_list|,
specifier|const
name|void
modifier|*
name|challenge
parameter_list|,
specifier|const
name|size_t
name|challenge_len
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|keys
modifier|*
name|response_keys
decl_stmt|;
name|char
modifier|*
name|chap_c
decl_stmt|,
name|chap_i
index|[
literal|4
index|]
decl_stmt|;
name|chap_c
operator|=
name|login_bin2hex
argument_list|(
name|challenge
argument_list|,
name|challenge_len
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|chap_i
argument_list|,
sizeof|sizeof
argument_list|(
name|chap_i
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|response_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"CHAP_A"
argument_list|,
literal|"5"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"CHAP_I"
argument_list|,
name|chap_i
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"CHAP_C"
argument_list|,
name|chap_c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chap_c
argument_list|)
expr_stmt|;
name|keys_save
argument_list|(
name|response_keys
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|response_keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pdu
modifier|*
name|login_receive_chap_r
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|,
name|struct
name|auth_group
modifier|*
name|ag
parameter_list|,
specifier|const
name|unsigned
name|char
name|id
parameter_list|,
specifier|const
name|void
modifier|*
name|challenge
parameter_list|,
specifier|const
name|size_t
name|challenge_len
parameter_list|,
specifier|const
name|struct
name|auth
modifier|*
modifier|*
name|cap
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|keys
modifier|*
name|request_keys
decl_stmt|;
specifier|const
name|char
modifier|*
name|chap_n
decl_stmt|,
modifier|*
name|chap_r
decl_stmt|;
name|char
modifier|*
name|response_bin
decl_stmt|,
name|expected_response_bin
index|[
name|MD5_DIGEST_LENGTH
index|]
decl_stmt|;
name|size_t
name|response_bin_len
decl_stmt|;
specifier|const
name|struct
name|auth
modifier|*
name|auth
decl_stmt|;
name|int
name|error
decl_stmt|;
name|request
operator|=
name|login_receive
argument_list|(
name|conn
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|request_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_load
argument_list|(
name|request_keys
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|chap_n
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"CHAP_N"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chap_n
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU without CHAP_N"
argument_list|)
expr_stmt|;
block|}
name|chap_r
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"CHAP_R"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chap_r
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU without CHAP_R"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|login_hex2bin
argument_list|(
name|chap_r
argument_list|,
operator|&
name|response_bin
argument_list|,
operator|&
name|response_bin_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU with malformed CHAP_R"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Verify the response. 	 */
name|assert
argument_list|(
name|ag
operator|->
name|ag_type
operator|==
name|AG_TYPE_CHAP
operator|||
name|ag
operator|->
name|ag_type
operator|==
name|AG_TYPE_CHAP_MUTUAL
argument_list|)
expr_stmt|;
name|auth
operator|=
name|auth_find
argument_list|(
name|ag
argument_list|,
name|chap_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login with invalid user \"%s\""
argument_list|,
name|chap_n
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|auth
operator|->
name|a_secret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|auth
operator|->
name|a_secret
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|login_compute_md5
argument_list|(
name|id
argument_list|,
name|auth
operator|->
name|a_secret
argument_list|,
name|challenge
argument_list|,
name|challenge_len
argument_list|,
name|expected_response_bin
argument_list|,
sizeof|sizeof
argument_list|(
name|expected_response_bin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|response_bin
argument_list|,
name|expected_response_bin
argument_list|,
sizeof|sizeof
argument_list|(
name|expected_response_bin
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"CHAP authentication failed for user \"%s\""
argument_list|,
name|auth
operator|->
name|a_user
argument_list|)
expr_stmt|;
block|}
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|response_bin
argument_list|)
expr_stmt|;
operator|*
name|cap
operator|=
name|auth
expr_stmt|;
return|return
operator|(
name|request
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_send_chap_success
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|,
specifier|const
name|struct
name|auth
modifier|*
name|auth
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|keys
modifier|*
name|request_keys
decl_stmt|,
modifier|*
name|response_keys
decl_stmt|;
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr2
decl_stmt|;
specifier|const
name|char
modifier|*
name|chap_i
decl_stmt|,
modifier|*
name|chap_c
decl_stmt|;
name|char
modifier|*
name|chap_r
decl_stmt|,
modifier|*
name|challenge
decl_stmt|,
name|response_bin
index|[
name|MD5_DIGEST_LENGTH
index|]
decl_stmt|;
name|size_t
name|challenge_len
decl_stmt|;
name|unsigned
name|char
name|id
decl_stmt|;
name|int
name|error
decl_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhslr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_flags
operator||=
name|BHSLR_FLAGS_TRANSIT
expr_stmt|;
name|login_set_nsg
argument_list|(
name|response
argument_list|,
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
argument_list|)
expr_stmt|;
comment|/* 	 * Actually, one more thing: mutual authentication. 	 */
name|request_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_load
argument_list|(
name|request_keys
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|chap_i
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"CHAP_I"
argument_list|)
expr_stmt|;
name|chap_c
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"CHAP_C"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chap_i
operator|!=
name|NULL
operator|||
name|chap_c
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|chap_i
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator requested target "
literal|"authentication, but didn't send CHAP_I"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chap_c
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator requested target "
literal|"authentication, but didn't send CHAP_C"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auth
operator|->
name|a_auth_group
operator|->
name|ag_type
operator|!=
name|AG_TYPE_CHAP_MUTUAL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator requests target authentication "
literal|"for user \"%s\", but mutual user/secret "
literal|"is not set"
argument_list|,
name|auth
operator|->
name|a_user
argument_list|)
expr_stmt|;
block|}
name|id
operator|=
name|strtoul
argument_list|(
name|chap_i
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|error
operator|=
name|login_hex2bin
argument_list|(
name|chap_c
argument_list|,
operator|&
name|challenge
argument_list|,
operator|&
name|challenge_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU with malformed "
literal|"CHAP_C"
argument_list|)
expr_stmt|;
block|}
name|log_debugx
argument_list|(
literal|"performing mutual authentication as user \"%s\""
argument_list|,
name|auth
operator|->
name|a_mutual_user
argument_list|)
expr_stmt|;
name|login_compute_md5
argument_list|(
name|id
argument_list|,
name|auth
operator|->
name|a_mutual_secret
argument_list|,
name|challenge
argument_list|,
name|challenge_len
argument_list|,
name|response_bin
argument_list|,
sizeof|sizeof
argument_list|(
name|response_bin
argument_list|)
argument_list|)
expr_stmt|;
name|chap_r
operator|=
name|login_bin2hex
argument_list|(
name|response_bin
argument_list|,
sizeof|sizeof
argument_list|(
name|response_bin
argument_list|)
argument_list|)
expr_stmt|;
name|response_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"CHAP_N"
argument_list|,
name|auth
operator|->
name|a_mutual_user
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"CHAP_R"
argument_list|,
name|chap_r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chap_r
argument_list|)
expr_stmt|;
name|keys_save
argument_list|(
name|response_keys
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|response_keys
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"initiator did not request target authentication"
argument_list|)
expr_stmt|;
block|}
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_chap
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|,
name|struct
name|auth_group
modifier|*
name|ag
parameter_list|)
block|{
specifier|const
name|struct
name|auth
modifier|*
name|auth
decl_stmt|;
name|struct
name|pdu
modifier|*
name|request
decl_stmt|;
name|char
name|challenge_bin
index|[
name|LOGIN_CHALLENGE_LEN
index|]
decl_stmt|;
name|unsigned
name|char
name|id
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* 	 * Receive CHAP_A PDU. 	 */
name|log_debugx
argument_list|(
literal|"beginning CHAP authentication; waiting for CHAP_A"
argument_list|)
expr_stmt|;
name|request
operator|=
name|login_receive_chap_a
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|/* 	 * Generate the challenge. 	 */
name|rv
operator|=
name|RAND_bytes
argument_list|(
name|challenge_bin
argument_list|,
sizeof|sizeof
argument_list|(
name|challenge_bin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x03
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"RAND_bytes failed: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|RAND_bytes
argument_list|(
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|1
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x03
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"RAND_bytes failed: %s"
argument_list|,
name|ERR_error_string
argument_list|(
name|ERR_get_error
argument_list|()
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Send the challenge. 	 */
name|log_debugx
argument_list|(
literal|"sending CHAP_C, binary challenge size is %zd bytes"
argument_list|,
sizeof|sizeof
argument_list|(
name|challenge_bin
argument_list|)
argument_list|)
expr_stmt|;
name|login_send_chap_c
argument_list|(
name|request
argument_list|,
name|id
argument_list|,
name|challenge_bin
argument_list|,
sizeof|sizeof
argument_list|(
name|challenge_bin
argument_list|)
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|request
argument_list|)
expr_stmt|;
comment|/* 	 * Receive CHAP_N/CHAP_R PDU and authenticate. 	 */
name|log_debugx
argument_list|(
literal|"waiting for CHAP_N/CHAP_R"
argument_list|)
expr_stmt|;
name|request
operator|=
name|login_receive_chap_r
argument_list|(
name|conn
argument_list|,
name|ag
argument_list|,
name|id
argument_list|,
name|challenge_bin
argument_list|,
sizeof|sizeof
argument_list|(
name|challenge_bin
argument_list|)
argument_list|,
operator|&
name|auth
argument_list|)
expr_stmt|;
comment|/* 	 * Yay, authentication succeeded! 	 */
name|log_debugx
argument_list|(
literal|"authentication succeeded for user \"%s\"; "
literal|"transitioning to Negotiation Phase"
argument_list|,
name|auth
operator|->
name|a_user
argument_list|)
expr_stmt|;
name|login_send_chap_success
argument_list|(
name|request
argument_list|,
name|auth
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|request
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_negotiate_key
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|bool
name|skipped_security
parameter_list|,
name|struct
name|keys
modifier|*
name|response_keys
parameter_list|)
block|{
name|int
name|which
decl_stmt|,
name|tmp
decl_stmt|;
name|struct
name|connection
modifier|*
name|conn
decl_stmt|;
name|conn
operator|=
name|request
operator|->
name|pdu_connection
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"InitiatorName"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|skipped_security
condition|)
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator resent InitiatorName"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SessionType"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|skipped_security
condition|)
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator resent SessionType"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"TargetName"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|skipped_security
condition|)
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator resent TargetName"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"InitiatorAlias"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|conn
operator|->
name|conn_initiator_alias
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|conn
operator|->
name|conn_initiator_alias
argument_list|)
expr_stmt|;
name|conn
operator|->
name|conn_initiator_alias
operator|=
name|checked_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"Irrelevant"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Ignore. */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"HeaderDigest"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We don't handle digests for discovery sessions. 		 */
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_DISCOVERY
condition|)
block|{
name|log_debugx
argument_list|(
literal|"discovery session; digests disabled"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
return|return;
block|}
name|which
operator|=
name|login_list_prefers
argument_list|(
name|value
argument_list|,
literal|"CRC32C"
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|1
case|:
name|log_debugx
argument_list|(
literal|"initiator prefers CRC32C "
literal|"for header digest; we'll use it"
argument_list|)
expr_stmt|;
name|conn
operator|->
name|conn_header_digest
operator|=
name|CONN_DIGEST_CRC32C
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"CRC32C"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|log_debugx
argument_list|(
literal|"initiator prefers not to do "
literal|"header digest; we'll comply"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_warnx
argument_list|(
literal|"initiator sent unrecognized "
literal|"HeaderDigest value \"%s\"; will use None"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DataDigest"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_DISCOVERY
condition|)
block|{
name|log_debugx
argument_list|(
literal|"discovery session; digests disabled"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
return|return;
block|}
name|which
operator|=
name|login_list_prefers
argument_list|(
name|value
argument_list|,
literal|"CRC32C"
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|1
case|:
name|log_debugx
argument_list|(
literal|"initiator prefers CRC32C "
literal|"for data digest; we'll use it"
argument_list|)
expr_stmt|;
name|conn
operator|->
name|conn_data_digest
operator|=
name|CONN_DIGEST_CRC32C
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"CRC32C"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|log_debugx
argument_list|(
literal|"initiator prefers not to do "
literal|"data digest; we'll comply"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_warnx
argument_list|(
literal|"initiator sent unrecognized "
literal|"DataDigest value \"%s\"; will use None"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MaxConnections"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"InitialR2T"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"Yes"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ImmediateData"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_DISCOVERY
condition|)
block|{
name|log_debugx
argument_list|(
literal|"discovery session; ImmediateData irrelevant"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"Irrelevant"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"Yes"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|conn
operator|->
name|conn_immediate_data
operator|=
name|true
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"Yes"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conn
operator|->
name|conn_immediate_data
operator|=
name|false
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"No"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MaxRecvDataSegmentLength"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmp
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received invalid "
literal|"MaxRecvDataSegmentLength"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|>
name|MAX_DATA_SEGMENT_LENGTH
condition|)
block|{
name|log_debugx
argument_list|(
literal|"capping MaxRecvDataSegmentLength "
literal|"from %d to %d"
argument_list|,
name|tmp
argument_list|,
name|MAX_DATA_SEGMENT_LENGTH
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|MAX_DATA_SEGMENT_LENGTH
expr_stmt|;
block|}
name|conn
operator|->
name|conn_max_data_segment_length
operator|=
name|tmp
expr_stmt|;
name|keys_add_int
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MaxBurstLength"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmp
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received invalid MaxBurstLength"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|>
name|MAX_BURST_LENGTH
condition|)
block|{
name|log_debugx
argument_list|(
literal|"capping MaxBurstLength from %d to %d"
argument_list|,
name|tmp
argument_list|,
name|MAX_BURST_LENGTH
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|MAX_BURST_LENGTH
expr_stmt|;
block|}
name|conn
operator|->
name|conn_max_burst_length
operator|=
name|tmp
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"FirstBurstLength"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmp
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received invalid "
literal|"FirstBurstLength"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|>
name|MAX_DATA_SEGMENT_LENGTH
condition|)
block|{
name|log_debugx
argument_list|(
literal|"capping FirstBurstLength from %d to %d"
argument_list|,
name|tmp
argument_list|,
name|MAX_DATA_SEGMENT_LENGTH
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|MAX_DATA_SEGMENT_LENGTH
expr_stmt|;
block|}
comment|/* 		 * We don't pass the value to the kernel; it only enforces 		 * hardcoded limit anyway. 		 */
name|keys_add_int
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DefaultTime2Wait"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DefaultTime2Retain"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MaxOutstandingR2T"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DataPDUInOrder"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"Yes"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DataSequenceInOrder"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"Yes"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ErrorRecoveryLevel"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"OFMarker"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"No"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"IFMarker"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"No"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"unknown key \"%s\"; responding "
literal|"with NotUnderstood"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"NotUnderstood"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|login_negotiate
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|,
name|struct
name|pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr2
decl_stmt|;
name|struct
name|keys
modifier|*
name|request_keys
decl_stmt|,
modifier|*
name|response_keys
decl_stmt|;
name|char
modifier|*
name|portal_group_tag
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|;
name|bool
name|skipped_security
decl_stmt|;
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
block|{
name|log_debugx
argument_list|(
literal|"beginning operational parameter negotiation; "
literal|"waiting for Login PDU"
argument_list|)
expr_stmt|;
name|request
operator|=
name|login_receive
argument_list|(
name|conn
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|skipped_security
operator|=
name|false
expr_stmt|;
block|}
else|else
name|skipped_security
operator|=
name|true
expr_stmt|;
name|request_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_load
argument_list|(
name|request_keys
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhslr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_flags
operator||=
name|BHSLR_FLAGS_TRANSIT
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_tsih
operator|=
name|htons
argument_list|(
literal|0xbadd
argument_list|)
expr_stmt|;
name|login_set_csg
argument_list|(
name|response
argument_list|,
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
argument_list|)
expr_stmt|;
name|login_set_nsg
argument_list|(
name|response
argument_list|,
name|BHSLR_STAGE_FULL_FEATURE_PHASE
argument_list|)
expr_stmt|;
name|response_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|skipped_security
operator|&&
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NORMAL
condition|)
block|{
if|if
condition|(
name|conn
operator|->
name|conn_target
operator|->
name|t_alias
operator|!=
name|NULL
condition|)
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"TargetAlias"
argument_list|,
name|conn
operator|->
name|conn_target
operator|->
name|t_alias
argument_list|)
expr_stmt|;
name|rv
operator|=
name|asprintf
argument_list|(
operator|&
name|portal_group_tag
argument_list|,
literal|"%d"
argument_list|,
name|conn
operator|->
name|conn_portal
operator|->
name|p_portal_group
operator|->
name|pg_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"TargetPortalGroupTag"
argument_list|,
name|portal_group_tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|portal_group_tag
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KEYS_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|request_keys
operator|->
name|keys_names
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|login_negotiate_key
argument_list|(
name|request
argument_list|,
name|request_keys
operator|->
name|keys_names
index|[
name|i
index|]
argument_list|,
name|request_keys
operator|->
name|keys_values
index|[
name|i
index|]
argument_list|,
name|skipped_security
argument_list|,
name|response_keys
argument_list|)
expr_stmt|;
block|}
name|log_debugx
argument_list|(
literal|"operational parameter negotiation done; "
literal|"transitioning to Full Feature Phase"
argument_list|)
expr_stmt|;
name|keys_save
argument_list|(
name|response_keys
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|response_keys
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|login
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|request
decl_stmt|,
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_login_request
modifier|*
name|bhslr
decl_stmt|;
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr2
decl_stmt|;
name|struct
name|keys
modifier|*
name|request_keys
decl_stmt|,
modifier|*
name|response_keys
decl_stmt|;
name|struct
name|auth_group
modifier|*
name|ag
decl_stmt|;
specifier|const
name|char
modifier|*
name|initiator_name
decl_stmt|,
modifier|*
name|initiator_alias
decl_stmt|,
modifier|*
name|session_type
decl_stmt|,
modifier|*
name|target_name
decl_stmt|,
modifier|*
name|auth_method
decl_stmt|;
name|char
modifier|*
name|portal_group_tag
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* 	 * Handle the initial Login Request - figure out required authentication 	 * method and either transition to the next phase, if no authentication 	 * is required, or call appropriate authentication code. 	 */
name|log_debugx
argument_list|(
literal|"beginning Login Phase; waiting for Login PDU"
argument_list|)
expr_stmt|;
name|request
operator|=
name|login_receive
argument_list|(
name|conn
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_request
operator|*
operator|)
name|request
operator|->
name|pdu_bhs
expr_stmt|;
if|if
condition|(
name|bhslr
operator|->
name|bhslr_tsih
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with non-zero TSIH"
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|conn
operator|->
name|conn_initiator_isid
argument_list|,
name|bhslr
operator|->
name|bhslr_isid
argument_list|,
sizeof|sizeof
argument_list|(
name|conn
operator|->
name|conn_initiator_isid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Implement the C flag some day. 	 */
name|request_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_load
argument_list|(
name|request_keys
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|conn
operator|->
name|conn_initiator_name
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|initiator_name
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"InitiatorName"
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiator_name
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU without InitiatorName"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid_iscsi_name
argument_list|(
name|initiator_name
argument_list|)
operator|==
name|false
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with invalid InitiatorName"
argument_list|)
expr_stmt|;
block|}
name|conn
operator|->
name|conn_initiator_name
operator|=
name|checked_strdup
argument_list|(
name|initiator_name
argument_list|)
expr_stmt|;
name|log_set_peer_name
argument_list|(
name|conn
operator|->
name|conn_initiator_name
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: This doesn't work (does nothing) because of Capsicum. 	 */
name|setproctitle
argument_list|(
literal|"%s (%s)"
argument_list|,
name|conn
operator|->
name|conn_initiator_addr
argument_list|,
name|conn
operator|->
name|conn_initiator_name
argument_list|)
expr_stmt|;
name|initiator_alias
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"InitiatorAlias"
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiator_alias
operator|!=
name|NULL
condition|)
name|conn
operator|->
name|conn_initiator_alias
operator|=
name|checked_strdup
argument_list|(
name|initiator_alias
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NONE
argument_list|)
expr_stmt|;
name|session_type
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"SessionType"
argument_list|)
expr_stmt|;
if|if
condition|(
name|session_type
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|session_type
argument_list|,
literal|"Normal"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|conn
operator|->
name|conn_session_type
operator|=
name|CONN_SESSION_TYPE_NORMAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|session_type
argument_list|,
literal|"Discovery"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|conn
operator|->
name|conn_session_type
operator|=
name|CONN_SESSION_TYPE_DISCOVERY
expr_stmt|;
block|}
else|else
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with invalid "
literal|"SessionType \"%s\""
argument_list|,
name|session_type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|conn
operator|->
name|conn_session_type
operator|=
name|CONN_SESSION_TYPE_NORMAL
expr_stmt|;
name|assert
argument_list|(
name|conn
operator|->
name|conn_target
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NORMAL
condition|)
block|{
name|target_name
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"TargetName"
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_name
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU without TargetName"
argument_list|)
expr_stmt|;
block|}
name|conn
operator|->
name|conn_target
operator|=
name|target_find
argument_list|(
name|conn
operator|->
name|conn_portal
operator|->
name|p_portal_group
operator|->
name|pg_conf
argument_list|,
name|target_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|conn_target
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"requested target \"%s\" not found"
argument_list|,
name|target_name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * At this point we know what kind of authentication we need. 	 */
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NORMAL
condition|)
block|{
name|ag
operator|=
name|conn
operator|->
name|conn_target
operator|->
name|t_auth_group
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_name
operator|!=
name|NULL
condition|)
block|{
name|log_debugx
argument_list|(
literal|"initiator requests to connect "
literal|"to target \"%s\"; auth-group \"%s\""
argument_list|,
name|conn
operator|->
name|conn_target
operator|->
name|t_name
argument_list|,
name|conn
operator|->
name|conn_target
operator|->
name|t_auth_group
operator|->
name|ag_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"initiator requests to connect "
literal|"to target \"%s\""
argument_list|,
name|conn
operator|->
name|conn_target
operator|->
name|t_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assert
argument_list|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_DISCOVERY
argument_list|)
expr_stmt|;
name|ag
operator|=
name|conn
operator|->
name|conn_portal
operator|->
name|p_portal_group
operator|->
name|pg_discovery_auth_group
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_name
operator|!=
name|NULL
condition|)
block|{
name|log_debugx
argument_list|(
literal|"initiator requests "
literal|"discovery session; auth-group \"%s\""
argument_list|,
name|ag
operator|->
name|ag_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"initiator requests discovery session"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Enforce initiator-name and initiator-portal. 	 */
if|if
condition|(
name|auth_name_defined
argument_list|(
name|ag
argument_list|)
condition|)
block|{
if|if
condition|(
name|auth_name_find
argument_list|(
name|ag
argument_list|,
name|initiator_name
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator does not match allowed "
literal|"initiator names"
argument_list|)
expr_stmt|;
block|}
name|log_debugx
argument_list|(
literal|"initiator matches allowed initiator names"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"auth-group does not define initiator name "
literal|"restrictions"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auth_portal_defined
argument_list|(
name|ag
argument_list|)
condition|)
block|{
if|if
condition|(
name|auth_portal_find
argument_list|(
name|ag
argument_list|,
operator|&
name|conn
operator|->
name|conn_initiator_sa
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator does not match allowed "
literal|"initiator portals"
argument_list|)
expr_stmt|;
block|}
name|log_debugx
argument_list|(
literal|"initiator matches allowed initiator portals"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"auth-group does not define initiator portal "
literal|"restrictions"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Let's see if the initiator intends to do any kind of authentication 	 * at all. 	 */
if|if
condition|(
name|login_csg
argument_list|(
name|request
argument_list|)
operator|==
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
condition|)
block|{
if|if
condition|(
name|ag
operator|->
name|ag_type
operator|!=
name|AG_TYPE_NO_AUTHENTICATION
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator skipped the authentication, "
literal|"but authentication is required"
argument_list|)
expr_stmt|;
block|}
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
name|log_debugx
argument_list|(
literal|"initiator skipped the authentication, "
literal|"and we don't need it; proceeding with negotiation"
argument_list|)
expr_stmt|;
name|login_negotiate
argument_list|(
name|conn
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ag
operator|->
name|ag_type
operator|==
name|AG_TYPE_NO_AUTHENTICATION
condition|)
block|{
comment|/* 		 * Initiator might want to to authenticate, 		 * but we don't need it. 		 */
name|log_debugx
argument_list|(
literal|"authentication not required; "
literal|"transitioning to operational parameter negotiation"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bhslr
operator|->
name|bhslr_flags
operator|&
name|BHSLR_FLAGS_TRANSIT
operator|)
operator|==
literal|0
condition|)
name|log_warnx
argument_list|(
literal|"initiator did not set the \"T\" flag; "
literal|"transitioning anyway"
argument_list|)
expr_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhslr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_flags
operator||=
name|BHSLR_FLAGS_TRANSIT
expr_stmt|;
name|login_set_nsg
argument_list|(
name|response
argument_list|,
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
argument_list|)
expr_stmt|;
name|response_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
comment|/* 		 * Required by Linux initiator. 		 */
name|auth_method
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"AuthMethod"
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_method
operator|!=
name|NULL
operator|&&
name|login_list_contains
argument_list|(
name|auth_method
argument_list|,
literal|"None"
argument_list|)
condition|)
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"AuthMethod"
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NORMAL
condition|)
block|{
if|if
condition|(
name|conn
operator|->
name|conn_target
operator|->
name|t_alias
operator|!=
name|NULL
condition|)
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"TargetAlias"
argument_list|,
name|conn
operator|->
name|conn_target
operator|->
name|t_alias
argument_list|)
expr_stmt|;
name|rv
operator|=
name|asprintf
argument_list|(
operator|&
name|portal_group_tag
argument_list|,
literal|"%d"
argument_list|,
name|conn
operator|->
name|conn_portal
operator|->
name|p_portal_group
operator|->
name|pg_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"TargetPortalGroupTag"
argument_list|,
name|portal_group_tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|portal_group_tag
argument_list|)
expr_stmt|;
block|}
name|keys_save
argument_list|(
name|response_keys
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|response_keys
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
name|login_negotiate
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ag
operator|->
name|ag_type
operator|==
name|AG_TYPE_DENY
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"auth-type is \"deny\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ag
operator|->
name|ag_type
operator|==
name|AG_TYPE_UNKNOWN
condition|)
block|{
comment|/* 		 * This can happen with empty auth-group. 		 */
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"auth-type not set, denying access"
argument_list|)
expr_stmt|;
block|}
name|log_debugx
argument_list|(
literal|"CHAP authentication required"
argument_list|)
expr_stmt|;
name|auth_method
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"AuthMethod"
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_method
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU without AuthMethod"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX: This should be Reject, not just a login failure (5.3.2). 	 */
if|if
condition|(
name|login_list_contains
argument_list|(
name|auth_method
argument_list|,
literal|"CHAP"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator requests unsupported AuthMethod \"%s\" "
literal|"instead of \"CHAP\""
argument_list|,
name|auth_method
argument_list|)
expr_stmt|;
block|}
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|response_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"AuthMethod"
argument_list|,
literal|"CHAP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NORMAL
condition|)
block|{
if|if
condition|(
name|conn
operator|->
name|conn_target
operator|->
name|t_alias
operator|!=
name|NULL
condition|)
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"TargetAlias"
argument_list|,
name|conn
operator|->
name|conn_target
operator|->
name|t_alias
argument_list|)
expr_stmt|;
name|rv
operator|=
name|asprintf
argument_list|(
operator|&
name|portal_group_tag
argument_list|,
literal|"%d"
argument_list|,
name|conn
operator|->
name|conn_portal
operator|->
name|p_portal_group
operator|->
name|pg_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<=
literal|0
condition|)
name|log_err
argument_list|(
literal|1
argument_list|,
literal|"asprintf"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"TargetPortalGroupTag"
argument_list|,
name|portal_group_tag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|portal_group_tag
argument_list|)
expr_stmt|;
block|}
name|keys_save
argument_list|(
name|response_keys
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|response_keys
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
name|login_chap
argument_list|(
name|conn
argument_list|,
name|ag
argument_list|)
expr_stmt|;
name|login_negotiate
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

