begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Edward Tomasz Napierala under sponsorship  * from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|"ctld.h"
end_include

begin_include
include|#
directive|include
file|"iscsi_proto.h"
end_include

begin_function_decl
specifier|static
name|void
name|login_send_error
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|,
name|char
name|class
parameter_list|,
name|char
name|detail
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|login_set_nsg
parameter_list|(
name|struct
name|pdu
modifier|*
name|response
parameter_list|,
name|int
name|nsg
parameter_list|)
block|{
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr
decl_stmt|;
name|assert
argument_list|(
name|nsg
operator|==
name|BHSLR_STAGE_SECURITY_NEGOTIATION
operator|||
name|nsg
operator|==
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
operator|||
name|nsg
operator|==
name|BHSLR_STAGE_FULL_FEATURE_PHASE
argument_list|)
expr_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr
operator|->
name|bhslr_flags
operator|&=
literal|0xFC
expr_stmt|;
name|bhslr
operator|->
name|bhslr_flags
operator||=
name|nsg
expr_stmt|;
name|bhslr
operator|->
name|bhslr_flags
operator||=
name|BHSLR_FLAGS_TRANSIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|login_csg
parameter_list|(
specifier|const
name|struct
name|pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|iscsi_bhs_login_request
modifier|*
name|bhslr
decl_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_request
operator|*
operator|)
name|request
operator|->
name|pdu_bhs
expr_stmt|;
return|return
operator|(
operator|(
name|bhslr
operator|->
name|bhslr_flags
operator|&
literal|0x0C
operator|)
operator|>>
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_set_csg
parameter_list|(
name|struct
name|pdu
modifier|*
name|response
parameter_list|,
name|int
name|csg
parameter_list|)
block|{
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr
decl_stmt|;
name|assert
argument_list|(
name|csg
operator|==
name|BHSLR_STAGE_SECURITY_NEGOTIATION
operator|||
name|csg
operator|==
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
operator|||
name|csg
operator|==
name|BHSLR_STAGE_FULL_FEATURE_PHASE
argument_list|)
expr_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr
operator|->
name|bhslr_flags
operator|&=
literal|0xF3
expr_stmt|;
name|bhslr
operator|->
name|bhslr_flags
operator||=
name|csg
operator|<<
literal|2
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pdu
modifier|*
name|login_receive
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|,
name|bool
name|initial
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|iscsi_bhs_login_request
modifier|*
name|bhslr
decl_stmt|;
name|request
operator|=
name|pdu_new
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|pdu_receive
argument_list|(
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|request
operator|->
name|pdu_bhs
operator|->
name|bhs_opcode
operator|&
operator|~
name|ISCSI_BHS_OPCODE_IMMEDIATE
operator|)
operator|!=
name|ISCSI_BHS_OPCODE_LOGIN_REQUEST
condition|)
block|{
comment|/* 		 * The first PDU in session is special - if we receive any PDU 		 * different than login request, we have to drop the connection 		 * without sending response ("A target receiving any PDU 		 * except a Login request before the Login Phase is started MUST 		 * immediately terminate the connection on which the PDU 		 * was received.") 		 */
if|if
condition|(
name|initial
operator|==
name|false
condition|)
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x0b
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"protocol error: received invalid opcode 0x%x"
argument_list|,
name|request
operator|->
name|pdu_bhs
operator|->
name|bhs_opcode
argument_list|)
expr_stmt|;
block|}
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_request
operator|*
operator|)
name|request
operator|->
name|pdu_bhs
expr_stmt|;
comment|/* 	 * XXX: Implement the C flag some day. 	 */
if|if
condition|(
operator|(
name|bhslr
operator|->
name|bhslr_flags
operator|&
name|BHSLR_FLAGS_CONTINUE
operator|)
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x03
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with unsupported \"C\" flag"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bhslr
operator|->
name|bhslr_version_max
operator|!=
literal|0x00
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with unsupported "
literal|"Version-max 0x%x"
argument_list|,
name|bhslr
operator|->
name|bhslr_version_max
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bhslr
operator|->
name|bhslr_version_min
operator|!=
literal|0x00
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with unsupported "
literal|"Version-min 0x%x"
argument_list|,
name|bhslr
operator|->
name|bhslr_version_min
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ISCSI_SNLT
argument_list|(
name|ntohl
argument_list|(
name|bhslr
operator|->
name|bhslr_cmdsn
argument_list|)
argument_list|,
name|conn
operator|->
name|conn_cmdsn
argument_list|)
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with decreasing CmdSN: "
literal|"was %u, is %u"
argument_list|,
name|conn
operator|->
name|conn_cmdsn
argument_list|,
name|ntohl
argument_list|(
name|bhslr
operator|->
name|bhslr_cmdsn
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|initial
operator|==
name|false
operator|&&
name|ntohl
argument_list|(
name|bhslr
operator|->
name|bhslr_expstatsn
argument_list|)
operator|!=
name|conn
operator|->
name|conn_statsn
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with wrong ExpStatSN: "
literal|"is %u, should be %u"
argument_list|,
name|ntohl
argument_list|(
name|bhslr
operator|->
name|bhslr_expstatsn
argument_list|)
argument_list|,
name|conn
operator|->
name|conn_statsn
argument_list|)
expr_stmt|;
block|}
name|conn
operator|->
name|conn_cmdsn
operator|=
name|ntohl
argument_list|(
name|bhslr
operator|->
name|bhslr_cmdsn
argument_list|)
expr_stmt|;
return|return
operator|(
name|request
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pdu
modifier|*
name|login_new_response
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|connection
modifier|*
name|conn
decl_stmt|;
name|struct
name|iscsi_bhs_login_request
modifier|*
name|bhslr
decl_stmt|;
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr2
decl_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_request
operator|*
operator|)
name|request
operator|->
name|pdu_bhs
expr_stmt|;
name|conn
operator|=
name|request
operator|->
name|pdu_connection
expr_stmt|;
name|response
operator|=
name|pdu_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhslr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_opcode
operator|=
name|ISCSI_BHS_OPCODE_LOGIN_RESPONSE
expr_stmt|;
name|login_set_csg
argument_list|(
name|response
argument_list|,
name|BHSLR_STAGE_SECURITY_NEGOTIATION
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bhslr2
operator|->
name|bhslr_isid
argument_list|,
name|bhslr
operator|->
name|bhslr_isid
argument_list|,
sizeof|sizeof
argument_list|(
name|bhslr2
operator|->
name|bhslr_isid
argument_list|)
argument_list|)
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_initiator_task_tag
operator|=
name|bhslr
operator|->
name|bhslr_initiator_task_tag
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_statsn
operator|=
name|htonl
argument_list|(
name|conn
operator|->
name|conn_statsn
operator|++
argument_list|)
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_expcmdsn
operator|=
name|htonl
argument_list|(
name|conn
operator|->
name|conn_cmdsn
argument_list|)
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_maxcmdsn
operator|=
name|htonl
argument_list|(
name|conn
operator|->
name|conn_cmdsn
argument_list|)
expr_stmt|;
return|return
operator|(
name|response
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_send_error
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|,
name|char
name|class
parameter_list|,
name|char
name|detail
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr2
decl_stmt|;
name|log_debugx
argument_list|(
literal|"sending Login Response PDU with failure class 0x%x/0x%x; "
literal|"see next line for reason"
argument_list|,
name|class
argument_list|,
name|detail
argument_list|)
expr_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhslr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_status_class
operator|=
name|class
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_status_detail
operator|=
name|detail
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|login_list_contains
parameter_list|(
specifier|const
name|char
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|)
block|{
name|char
modifier|*
name|tofree
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|tofree
operator|=
name|str
operator|=
name|checked_strdup
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|what
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|login_list_prefers
parameter_list|(
specifier|const
name|char
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|choice1
parameter_list|,
specifier|const
name|char
modifier|*
name|choice2
parameter_list|)
block|{
name|char
modifier|*
name|tofree
decl_stmt|,
modifier|*
name|str
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|tofree
operator|=
name|str
operator|=
name|checked_strdup
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|str
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|choice1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|choice2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
block|}
name|free
argument_list|(
name|tofree
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pdu
modifier|*
name|login_receive_chap_a
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|keys
modifier|*
name|request_keys
decl_stmt|;
specifier|const
name|char
modifier|*
name|chap_a
decl_stmt|;
name|request
operator|=
name|login_receive
argument_list|(
name|conn
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|request_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_load
argument_list|(
name|request_keys
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|chap_a
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"CHAP_A"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chap_a
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU without CHAP_A"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|login_list_contains
argument_list|(
name|chap_a
argument_list|,
literal|"5"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU with unsupported CHAP_A "
literal|"\"%s\""
argument_list|,
name|chap_a
argument_list|)
expr_stmt|;
block|}
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
return|return
operator|(
name|request
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_send_chap_c
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|,
name|struct
name|chap
modifier|*
name|chap
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|keys
modifier|*
name|response_keys
decl_stmt|;
name|char
modifier|*
name|chap_c
decl_stmt|,
modifier|*
name|chap_i
decl_stmt|;
name|chap_c
operator|=
name|chap_get_challenge
argument_list|(
name|chap
argument_list|)
expr_stmt|;
name|chap_i
operator|=
name|chap_get_id
argument_list|(
name|chap
argument_list|)
expr_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|response_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"CHAP_A"
argument_list|,
literal|"5"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"CHAP_I"
argument_list|,
name|chap_i
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"CHAP_C"
argument_list|,
name|chap_c
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chap_i
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chap_c
argument_list|)
expr_stmt|;
name|keys_save
argument_list|(
name|response_keys
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|response_keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pdu
modifier|*
name|login_receive_chap_r
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|,
name|struct
name|auth_group
modifier|*
name|ag
parameter_list|,
name|struct
name|chap
modifier|*
name|chap
parameter_list|,
specifier|const
name|struct
name|auth
modifier|*
modifier|*
name|authp
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|request
decl_stmt|;
name|struct
name|keys
modifier|*
name|request_keys
decl_stmt|;
specifier|const
name|char
modifier|*
name|chap_n
decl_stmt|,
modifier|*
name|chap_r
decl_stmt|;
specifier|const
name|struct
name|auth
modifier|*
name|auth
decl_stmt|;
name|int
name|error
decl_stmt|;
name|request
operator|=
name|login_receive
argument_list|(
name|conn
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|request_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_load
argument_list|(
name|request_keys
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|chap_n
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"CHAP_N"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chap_n
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU without CHAP_N"
argument_list|)
expr_stmt|;
block|}
name|chap_r
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"CHAP_R"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chap_r
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU without CHAP_R"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|chap_receive
argument_list|(
name|chap
argument_list|,
name|chap_r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU with malformed CHAP_R"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Verify the response. 	 */
name|assert
argument_list|(
name|ag
operator|->
name|ag_type
operator|==
name|AG_TYPE_CHAP
operator|||
name|ag
operator|->
name|ag_type
operator|==
name|AG_TYPE_CHAP_MUTUAL
argument_list|)
expr_stmt|;
name|auth
operator|=
name|auth_find
argument_list|(
name|ag
argument_list|,
name|chap_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login with invalid user \"%s\""
argument_list|,
name|chap_n
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|auth
operator|->
name|a_secret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|auth
operator|->
name|a_secret
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|chap_authenticate
argument_list|(
name|chap
argument_list|,
name|auth
operator|->
name|a_secret
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"CHAP authentication failed for user \"%s\""
argument_list|,
name|auth
operator|->
name|a_user
argument_list|)
expr_stmt|;
block|}
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
operator|*
name|authp
operator|=
name|auth
expr_stmt|;
return|return
operator|(
name|request
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_send_chap_success
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|,
specifier|const
name|struct
name|auth
modifier|*
name|auth
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|keys
modifier|*
name|request_keys
decl_stmt|,
modifier|*
name|response_keys
decl_stmt|;
name|struct
name|rchap
modifier|*
name|rchap
decl_stmt|;
specifier|const
name|char
modifier|*
name|chap_i
decl_stmt|,
modifier|*
name|chap_c
decl_stmt|;
name|char
modifier|*
name|chap_r
decl_stmt|;
name|int
name|error
decl_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|login_set_nsg
argument_list|(
name|response
argument_list|,
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
argument_list|)
expr_stmt|;
comment|/* 	 * Actually, one more thing: mutual authentication. 	 */
name|request_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_load
argument_list|(
name|request_keys
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|chap_i
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"CHAP_I"
argument_list|)
expr_stmt|;
name|chap_c
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"CHAP_C"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chap_i
operator|!=
name|NULL
operator|||
name|chap_c
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|chap_i
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator requested target "
literal|"authentication, but didn't send CHAP_I"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chap_c
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator requested target "
literal|"authentication, but didn't send CHAP_C"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auth
operator|->
name|a_auth_group
operator|->
name|ag_type
operator|!=
name|AG_TYPE_CHAP_MUTUAL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator requests target authentication "
literal|"for user \"%s\", but mutual user/secret "
literal|"is not set"
argument_list|,
name|auth
operator|->
name|a_user
argument_list|)
expr_stmt|;
block|}
name|log_debugx
argument_list|(
literal|"performing mutual authentication as user \"%s\""
argument_list|,
name|auth
operator|->
name|a_mutual_user
argument_list|)
expr_stmt|;
name|rchap
operator|=
name|rchap_new
argument_list|(
name|auth
operator|->
name|a_mutual_secret
argument_list|)
expr_stmt|;
name|error
operator|=
name|rchap_receive
argument_list|(
name|rchap
argument_list|,
name|chap_i
argument_list|,
name|chap_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received CHAP Login PDU with malformed "
literal|"CHAP_I or CHAP_C"
argument_list|)
expr_stmt|;
block|}
name|chap_r
operator|=
name|rchap_get_response
argument_list|(
name|rchap
argument_list|)
expr_stmt|;
name|rchap_delete
argument_list|(
name|rchap
argument_list|)
expr_stmt|;
name|response_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"CHAP_N"
argument_list|,
name|auth
operator|->
name|a_mutual_user
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"CHAP_R"
argument_list|,
name|chap_r
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|chap_r
argument_list|)
expr_stmt|;
name|keys_save
argument_list|(
name|response_keys
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|response_keys
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"initiator did not request target authentication"
argument_list|)
expr_stmt|;
block|}
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_chap
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|,
name|struct
name|auth_group
modifier|*
name|ag
parameter_list|)
block|{
specifier|const
name|struct
name|auth
modifier|*
name|auth
decl_stmt|;
name|struct
name|chap
modifier|*
name|chap
decl_stmt|;
name|struct
name|pdu
modifier|*
name|request
decl_stmt|;
comment|/* 	 * Receive CHAP_A PDU. 	 */
name|log_debugx
argument_list|(
literal|"beginning CHAP authentication; waiting for CHAP_A"
argument_list|)
expr_stmt|;
name|request
operator|=
name|login_receive_chap_a
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|/* 	 * Generate the challenge. 	 */
name|chap
operator|=
name|chap_new
argument_list|()
expr_stmt|;
comment|/* 	 * Send the challenge. 	 */
name|log_debugx
argument_list|(
literal|"sending CHAP_C, binary challenge size is %zd bytes"
argument_list|,
sizeof|sizeof
argument_list|(
name|chap
operator|->
name|chap_challenge
argument_list|)
argument_list|)
expr_stmt|;
name|login_send_chap_c
argument_list|(
name|request
argument_list|,
name|chap
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|request
argument_list|)
expr_stmt|;
comment|/* 	 * Receive CHAP_N/CHAP_R PDU and authenticate. 	 */
name|log_debugx
argument_list|(
literal|"waiting for CHAP_N/CHAP_R"
argument_list|)
expr_stmt|;
name|request
operator|=
name|login_receive_chap_r
argument_list|(
name|conn
argument_list|,
name|ag
argument_list|,
name|chap
argument_list|,
operator|&
name|auth
argument_list|)
expr_stmt|;
comment|/* 	 * Yay, authentication succeeded! 	 */
name|log_debugx
argument_list|(
literal|"authentication succeeded for user \"%s\"; "
literal|"transitioning to Negotiation Phase"
argument_list|,
name|auth
operator|->
name|a_user
argument_list|)
expr_stmt|;
name|login_send_chap_success
argument_list|(
name|request
argument_list|,
name|auth
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|request
argument_list|)
expr_stmt|;
comment|/* 	 * Leave username and CHAP information for discovery(). 	 */
name|conn
operator|->
name|conn_user
operator|=
name|auth
operator|->
name|a_user
expr_stmt|;
name|conn
operator|->
name|conn_chap
operator|=
name|chap
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_negotiate_key
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|bool
name|skipped_security
parameter_list|,
name|struct
name|keys
modifier|*
name|response_keys
parameter_list|)
block|{
name|int
name|which
decl_stmt|;
name|size_t
name|tmp
decl_stmt|;
name|struct
name|connection
modifier|*
name|conn
decl_stmt|;
name|conn
operator|=
name|request
operator|->
name|pdu_connection
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"InitiatorName"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|skipped_security
condition|)
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator resent InitiatorName"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"SessionType"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|skipped_security
condition|)
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator resent SessionType"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"TargetName"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|skipped_security
condition|)
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator resent TargetName"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"InitiatorAlias"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|conn
operator|->
name|conn_initiator_alias
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|conn
operator|->
name|conn_initiator_alias
argument_list|)
expr_stmt|;
name|conn
operator|->
name|conn_initiator_alias
operator|=
name|checked_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"Irrelevant"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Ignore. */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"HeaderDigest"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We don't handle digests for discovery sessions. 		 */
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_DISCOVERY
condition|)
block|{
name|log_debugx
argument_list|(
literal|"discovery session; digests disabled"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
return|return;
block|}
name|which
operator|=
name|login_list_prefers
argument_list|(
name|value
argument_list|,
literal|"CRC32C"
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|1
case|:
name|log_debugx
argument_list|(
literal|"initiator prefers CRC32C "
literal|"for header digest; we'll use it"
argument_list|)
expr_stmt|;
name|conn
operator|->
name|conn_header_digest
operator|=
name|CONN_DIGEST_CRC32C
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"CRC32C"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|log_debugx
argument_list|(
literal|"initiator prefers not to do "
literal|"header digest; we'll comply"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_warnx
argument_list|(
literal|"initiator sent unrecognized "
literal|"HeaderDigest value \"%s\"; will use None"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DataDigest"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_DISCOVERY
condition|)
block|{
name|log_debugx
argument_list|(
literal|"discovery session; digests disabled"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
return|return;
block|}
name|which
operator|=
name|login_list_prefers
argument_list|(
name|value
argument_list|,
literal|"CRC32C"
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|1
case|:
name|log_debugx
argument_list|(
literal|"initiator prefers CRC32C "
literal|"for data digest; we'll use it"
argument_list|)
expr_stmt|;
name|conn
operator|->
name|conn_data_digest
operator|=
name|CONN_DIGEST_CRC32C
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"CRC32C"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|log_debugx
argument_list|(
literal|"initiator prefers not to do "
literal|"data digest; we'll comply"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|log_warnx
argument_list|(
literal|"initiator sent unrecognized "
literal|"DataDigest value \"%s\"; will use None"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MaxConnections"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"InitialR2T"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"Yes"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ImmediateData"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_DISCOVERY
condition|)
block|{
name|log_debugx
argument_list|(
literal|"discovery session; ImmediateData irrelevant"
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"Irrelevant"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"Yes"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|conn
operator|->
name|conn_immediate_data
operator|=
name|true
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"Yes"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conn
operator|->
name|conn_immediate_data
operator|=
name|false
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"No"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MaxRecvDataSegmentLength"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmp
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received invalid "
literal|"MaxRecvDataSegmentLength"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|>
name|conn
operator|->
name|conn_data_segment_limit
condition|)
block|{
name|log_debugx
argument_list|(
literal|"capping MaxRecvDataSegmentLength "
literal|"from %zd to %zd"
argument_list|,
name|tmp
argument_list|,
name|conn
operator|->
name|conn_data_segment_limit
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|conn
operator|->
name|conn_data_segment_limit
expr_stmt|;
block|}
name|conn
operator|->
name|conn_max_data_segment_length
operator|=
name|tmp
expr_stmt|;
name|keys_add_int
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
name|conn
operator|->
name|conn_data_segment_limit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MaxBurstLength"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmp
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received invalid MaxBurstLength"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|>
name|MAX_BURST_LENGTH
condition|)
block|{
name|log_debugx
argument_list|(
literal|"capping MaxBurstLength from %zd to %d"
argument_list|,
name|tmp
argument_list|,
name|MAX_BURST_LENGTH
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|MAX_BURST_LENGTH
expr_stmt|;
block|}
name|conn
operator|->
name|conn_max_burst_length
operator|=
name|tmp
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"FirstBurstLength"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmp
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|<=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received invalid "
literal|"FirstBurstLength"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|>
name|conn
operator|->
name|conn_data_segment_limit
condition|)
block|{
name|log_debugx
argument_list|(
literal|"capping FirstBurstLength from %zd to %zd"
argument_list|,
name|tmp
argument_list|,
name|conn
operator|->
name|conn_data_segment_limit
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|conn
operator|->
name|conn_data_segment_limit
expr_stmt|;
block|}
comment|/* 		 * We don't pass the value to the kernel; it only enforces 		 * hardcoded limit anyway. 		 */
name|keys_add_int
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DefaultTime2Wait"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DefaultTime2Retain"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"MaxOutstandingR2T"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DataPDUInOrder"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"Yes"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"DataSequenceInOrder"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"Yes"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"ErrorRecoveryLevel"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"0"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"OFMarker"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"No"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"IFMarker"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"No"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"unknown key \"%s\"; responding "
literal|"with NotUnderstood"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
name|name
argument_list|,
literal|"NotUnderstood"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|login_redirect
parameter_list|(
name|struct
name|pdu
modifier|*
name|request
parameter_list|,
specifier|const
name|char
modifier|*
name|target_address
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr2
decl_stmt|;
name|struct
name|keys
modifier|*
name|response_keys
decl_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|login_set_csg
argument_list|(
name|response
argument_list|,
name|login_csg
argument_list|(
name|request
argument_list|)
argument_list|)
expr_stmt|;
name|bhslr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_status_class
operator|=
literal|0x01
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_status_detail
operator|=
literal|0x01
expr_stmt|;
name|response_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"TargetAddress"
argument_list|,
name|target_address
argument_list|)
expr_stmt|;
name|keys_save
argument_list|(
name|response_keys
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|response_keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|login_portal_redirect
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|,
name|struct
name|pdu
modifier|*
name|request
parameter_list|)
block|{
specifier|const
name|struct
name|portal_group
modifier|*
name|pg
decl_stmt|;
name|pg
operator|=
name|conn
operator|->
name|conn_portal
operator|->
name|p_portal_group
expr_stmt|;
if|if
condition|(
name|pg
operator|->
name|pg_redirection
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|log_debugx
argument_list|(
literal|"portal-group \"%s\" configured to redirect to %s"
argument_list|,
name|pg
operator|->
name|pg_name
argument_list|,
name|pg
operator|->
name|pg_redirection
argument_list|)
expr_stmt|;
name|login_redirect
argument_list|(
name|request
argument_list|,
name|pg
operator|->
name|pg_redirection
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|login_target_redirect
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|,
name|struct
name|pdu
modifier|*
name|request
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|target_address
decl_stmt|;
name|assert
argument_list|(
name|conn
operator|->
name|conn_portal
operator|->
name|p_portal_group
operator|->
name|pg_redirection
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|conn_target
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|target_address
operator|=
name|conn
operator|->
name|conn_target
operator|->
name|t_redirection
expr_stmt|;
if|if
condition|(
name|target_address
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|log_debugx
argument_list|(
literal|"target \"%s\" configured to redirect to %s"
argument_list|,
name|conn
operator|->
name|conn_target
operator|->
name|t_name
argument_list|,
name|target_address
argument_list|)
expr_stmt|;
name|login_redirect
argument_list|(
name|request
argument_list|,
name|target_address
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_negotiate
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|,
name|struct
name|pdu
modifier|*
name|request
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_login_response
modifier|*
name|bhslr2
decl_stmt|;
name|struct
name|keys
modifier|*
name|request_keys
decl_stmt|,
modifier|*
name|response_keys
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|redirected
decl_stmt|,
name|skipped_security
decl_stmt|;
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NORMAL
condition|)
block|{
comment|/* 		 * Query the kernel for MaxDataSegmentLength it can handle. 		 * In case of offload, it depends on hardware capabilities. 		 */
name|assert
argument_list|(
name|conn
operator|->
name|conn_target
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|kernel_limits
argument_list|(
name|conn
operator|->
name|conn_portal
operator|->
name|p_portal_group
operator|->
name|pg_offload
argument_list|,
operator|&
name|conn
operator|->
name|conn_data_segment_limit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conn
operator|->
name|conn_data_segment_limit
operator|=
name|MAX_DATA_SEGMENT_LENGTH
expr_stmt|;
block|}
if|if
condition|(
name|request
operator|==
name|NULL
condition|)
block|{
name|log_debugx
argument_list|(
literal|"beginning operational parameter negotiation; "
literal|"waiting for Login PDU"
argument_list|)
expr_stmt|;
name|request
operator|=
name|login_receive
argument_list|(
name|conn
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|skipped_security
operator|=
name|false
expr_stmt|;
block|}
else|else
name|skipped_security
operator|=
name|true
expr_stmt|;
comment|/* 	 * RFC 3720, 10.13.5.  Status-Class and Status-Detail, says 	 * the redirection SHOULD be accepted by the initiator before 	 * authentication, but MUST be be accepted afterwards; that's 	 * why we're doing it here and not earlier. 	 */
name|redirected
operator|=
name|login_target_redirect
argument_list|(
name|conn
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|redirected
condition|)
block|{
name|log_debugx
argument_list|(
literal|"initiator redirected; exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|request_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_load
argument_list|(
name|request_keys
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|bhslr2
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_response
operator|*
operator|)
name|response
operator|->
name|pdu_bhs
expr_stmt|;
name|bhslr2
operator|->
name|bhslr_tsih
operator|=
name|htons
argument_list|(
literal|0xbadd
argument_list|)
expr_stmt|;
name|login_set_csg
argument_list|(
name|response
argument_list|,
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
argument_list|)
expr_stmt|;
name|login_set_nsg
argument_list|(
name|response
argument_list|,
name|BHSLR_STAGE_FULL_FEATURE_PHASE
argument_list|)
expr_stmt|;
name|response_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|skipped_security
operator|&&
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NORMAL
condition|)
block|{
if|if
condition|(
name|conn
operator|->
name|conn_target
operator|->
name|t_alias
operator|!=
name|NULL
condition|)
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"TargetAlias"
argument_list|,
name|conn
operator|->
name|conn_target
operator|->
name|t_alias
argument_list|)
expr_stmt|;
name|keys_add_int
argument_list|(
name|response_keys
argument_list|,
literal|"TargetPortalGroupTag"
argument_list|,
name|conn
operator|->
name|conn_portal
operator|->
name|p_portal_group
operator|->
name|pg_tag
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KEYS_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|request_keys
operator|->
name|keys_names
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|login_negotiate_key
argument_list|(
name|request
argument_list|,
name|request_keys
operator|->
name|keys_names
index|[
name|i
index|]
argument_list|,
name|request_keys
operator|->
name|keys_values
index|[
name|i
index|]
argument_list|,
name|skipped_security
argument_list|,
name|response_keys
argument_list|)
expr_stmt|;
block|}
name|log_debugx
argument_list|(
literal|"operational parameter negotiation done; "
literal|"transitioning to Full Feature Phase"
argument_list|)
expr_stmt|;
name|keys_save
argument_list|(
name|response_keys
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|response_keys
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|login_wait_transition
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|request
decl_stmt|,
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_login_request
modifier|*
name|bhslr
decl_stmt|;
name|log_debugx
argument_list|(
literal|"waiting for state transition request"
argument_list|)
expr_stmt|;
name|request
operator|=
name|login_receive
argument_list|(
name|conn
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_request
operator|*
operator|)
name|request
operator|->
name|pdu_bhs
expr_stmt|;
if|if
condition|(
operator|(
name|bhslr
operator|->
name|bhslr_flags
operator|&
name|BHSLR_FLAGS_TRANSIT
operator|)
operator|==
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"got no \"T\" flag after answering AuthMethod"
argument_list|)
expr_stmt|;
block|}
name|pdu_delete
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|log_debugx
argument_list|(
literal|"got state transition request"
argument_list|)
expr_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|login_set_nsg
argument_list|(
name|response
argument_list|,
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
argument_list|)
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|login_negotiate
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|login
parameter_list|(
name|struct
name|connection
modifier|*
name|conn
parameter_list|)
block|{
name|struct
name|pdu
modifier|*
name|request
decl_stmt|,
modifier|*
name|response
decl_stmt|;
name|struct
name|iscsi_bhs_login_request
modifier|*
name|bhslr
decl_stmt|;
name|struct
name|keys
modifier|*
name|request_keys
decl_stmt|,
modifier|*
name|response_keys
decl_stmt|;
name|struct
name|auth_group
modifier|*
name|ag
decl_stmt|;
name|struct
name|portal_group
modifier|*
name|pg
decl_stmt|;
specifier|const
name|char
modifier|*
name|initiator_name
decl_stmt|,
modifier|*
name|initiator_alias
decl_stmt|,
modifier|*
name|session_type
decl_stmt|,
modifier|*
name|target_name
decl_stmt|,
modifier|*
name|auth_method
decl_stmt|;
name|bool
name|redirected
decl_stmt|,
name|fail
decl_stmt|,
name|trans
decl_stmt|;
comment|/* 	 * Handle the initial Login Request - figure out required authentication 	 * method and either transition to the next phase, if no authentication 	 * is required, or call appropriate authentication code. 	 */
name|log_debugx
argument_list|(
literal|"beginning Login Phase; waiting for Login PDU"
argument_list|)
expr_stmt|;
name|request
operator|=
name|login_receive
argument_list|(
name|conn
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|bhslr
operator|=
operator|(
expr|struct
name|iscsi_bhs_login_request
operator|*
operator|)
name|request
operator|->
name|pdu_bhs
expr_stmt|;
if|if
condition|(
name|bhslr
operator|->
name|bhslr_tsih
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with non-zero TSIH"
argument_list|)
expr_stmt|;
block|}
name|pg
operator|=
name|conn
operator|->
name|conn_portal
operator|->
name|p_portal_group
expr_stmt|;
name|memcpy
argument_list|(
name|conn
operator|->
name|conn_initiator_isid
argument_list|,
name|bhslr
operator|->
name|bhslr_isid
argument_list|,
sizeof|sizeof
argument_list|(
name|conn
operator|->
name|conn_initiator_isid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Implement the C flag some day. 	 */
name|request_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|keys_load
argument_list|(
name|request_keys
argument_list|,
name|request
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|conn
operator|->
name|conn_initiator_name
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|initiator_name
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"InitiatorName"
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiator_name
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU without InitiatorName"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|valid_iscsi_name
argument_list|(
name|initiator_name
argument_list|)
operator|==
name|false
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with invalid InitiatorName"
argument_list|)
expr_stmt|;
block|}
name|conn
operator|->
name|conn_initiator_name
operator|=
name|checked_strdup
argument_list|(
name|initiator_name
argument_list|)
expr_stmt|;
name|log_set_peer_name
argument_list|(
name|conn
operator|->
name|conn_initiator_name
argument_list|)
expr_stmt|;
name|setproctitle
argument_list|(
literal|"%s (%s)"
argument_list|,
name|conn
operator|->
name|conn_initiator_addr
argument_list|,
name|conn
operator|->
name|conn_initiator_name
argument_list|)
expr_stmt|;
name|redirected
operator|=
name|login_portal_redirect
argument_list|(
name|conn
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|redirected
condition|)
block|{
name|log_debugx
argument_list|(
literal|"initiator redirected; exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|initiator_alias
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"InitiatorAlias"
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiator_alias
operator|!=
name|NULL
condition|)
name|conn
operator|->
name|conn_initiator_alias
operator|=
name|checked_strdup
argument_list|(
name|initiator_alias
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NONE
argument_list|)
expr_stmt|;
name|session_type
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"SessionType"
argument_list|)
expr_stmt|;
if|if
condition|(
name|session_type
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|session_type
argument_list|,
literal|"Normal"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|conn
operator|->
name|conn_session_type
operator|=
name|CONN_SESSION_TYPE_NORMAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|session_type
argument_list|,
literal|"Discovery"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|conn
operator|->
name|conn_session_type
operator|=
name|CONN_SESSION_TYPE_DISCOVERY
expr_stmt|;
block|}
else|else
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU with invalid "
literal|"SessionType \"%s\""
argument_list|,
name|session_type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|conn
operator|->
name|conn_session_type
operator|=
name|CONN_SESSION_TYPE_NORMAL
expr_stmt|;
name|assert
argument_list|(
name|conn
operator|->
name|conn_target
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NORMAL
condition|)
block|{
name|target_name
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"TargetName"
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_name
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"received Login PDU without TargetName"
argument_list|)
expr_stmt|;
block|}
name|conn
operator|->
name|conn_port
operator|=
name|port_find_in_pg
argument_list|(
name|pg
argument_list|,
name|target_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|conn_port
operator|==
name|NULL
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"requested target \"%s\" not found"
argument_list|,
name|target_name
argument_list|)
expr_stmt|;
block|}
name|conn
operator|->
name|conn_target
operator|=
name|conn
operator|->
name|conn_port
operator|->
name|p_target
expr_stmt|;
block|}
comment|/* 	 * At this point we know what kind of authentication we need. 	 */
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NORMAL
condition|)
block|{
name|ag
operator|=
name|conn
operator|->
name|conn_port
operator|->
name|p_auth_group
expr_stmt|;
if|if
condition|(
name|ag
operator|==
name|NULL
condition|)
name|ag
operator|=
name|conn
operator|->
name|conn_target
operator|->
name|t_auth_group
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_name
operator|!=
name|NULL
condition|)
block|{
name|log_debugx
argument_list|(
literal|"initiator requests to connect "
literal|"to target \"%s\"; auth-group \"%s\""
argument_list|,
name|conn
operator|->
name|conn_target
operator|->
name|t_name
argument_list|,
name|ag
operator|->
name|ag_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"initiator requests to connect "
literal|"to target \"%s\""
argument_list|,
name|conn
operator|->
name|conn_target
operator|->
name|t_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assert
argument_list|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_DISCOVERY
argument_list|)
expr_stmt|;
name|ag
operator|=
name|pg
operator|->
name|pg_discovery_auth_group
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_name
operator|!=
name|NULL
condition|)
block|{
name|log_debugx
argument_list|(
literal|"initiator requests "
literal|"discovery session; auth-group \"%s\""
argument_list|,
name|ag
operator|->
name|ag_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"initiator requests discovery session"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ag
operator|->
name|ag_type
operator|==
name|AG_TYPE_DENY
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"auth-type is \"deny\""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ag
operator|->
name|ag_type
operator|==
name|AG_TYPE_UNKNOWN
condition|)
block|{
comment|/* 		 * This can happen with empty auth-group. 		 */
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"auth-type not set, denying access"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enforce initiator-name and initiator-portal. 	 */
if|if
condition|(
name|auth_name_check
argument_list|(
name|ag
argument_list|,
name|initiator_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator does not match allowed initiator names"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auth_portal_check
argument_list|(
name|ag
argument_list|,
operator|&
name|conn
operator|->
name|conn_initiator_sa
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator does not match allowed "
literal|"initiator portals"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Let's see if the initiator intends to do any kind of authentication 	 * at all. 	 */
if|if
condition|(
name|login_csg
argument_list|(
name|request
argument_list|)
operator|==
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
condition|)
block|{
if|if
condition|(
name|ag
operator|->
name|ag_type
operator|!=
name|AG_TYPE_NO_AUTHENTICATION
condition|)
block|{
name|login_send_error
argument_list|(
name|request
argument_list|,
literal|0x02
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|log_errx
argument_list|(
literal|1
argument_list|,
literal|"initiator skipped the authentication, "
literal|"but authentication is required"
argument_list|)
expr_stmt|;
block|}
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
name|log_debugx
argument_list|(
literal|"initiator skipped the authentication, "
literal|"and we don't need it; proceeding with negotiation"
argument_list|)
expr_stmt|;
name|login_negotiate
argument_list|(
name|conn
argument_list|,
name|request
argument_list|)
expr_stmt|;
return|return;
block|}
name|fail
operator|=
name|false
expr_stmt|;
name|response
operator|=
name|login_new_response
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|response_keys
operator|=
name|keys_new
argument_list|()
expr_stmt|;
name|trans
operator|=
operator|(
name|bhslr
operator|->
name|bhslr_flags
operator|&
name|BHSLR_FLAGS_TRANSIT
operator|)
operator|!=
literal|0
expr_stmt|;
name|auth_method
operator|=
name|keys_find
argument_list|(
name|request_keys
argument_list|,
literal|"AuthMethod"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ag
operator|->
name|ag_type
operator|==
name|AG_TYPE_NO_AUTHENTICATION
condition|)
block|{
name|log_debugx
argument_list|(
literal|"authentication not required"
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_method
operator|==
name|NULL
operator|||
name|login_list_contains
argument_list|(
name|auth_method
argument_list|,
literal|"None"
argument_list|)
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"AuthMethod"
argument_list|,
literal|"None"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_warnx
argument_list|(
literal|"initiator requests "
literal|"AuthMethod \"%s\" instead of \"None\""
argument_list|,
name|auth_method
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"AuthMethod"
argument_list|,
literal|"Reject"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|trans
condition|)
name|login_set_nsg
argument_list|(
name|response
argument_list|,
name|BHSLR_STAGE_OPERATIONAL_NEGOTIATION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_debugx
argument_list|(
literal|"CHAP authentication required"
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_method
operator|==
name|NULL
operator|||
name|login_list_contains
argument_list|(
name|auth_method
argument_list|,
literal|"CHAP"
argument_list|)
condition|)
block|{
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"AuthMethod"
argument_list|,
literal|"CHAP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log_warnx
argument_list|(
literal|"initiator requests unsupported "
literal|"AuthMethod \"%s\" instead of \"CHAP\""
argument_list|,
name|auth_method
argument_list|)
expr_stmt|;
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"AuthMethod"
argument_list|,
literal|"Reject"
argument_list|)
expr_stmt|;
name|fail
operator|=
name|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conn
operator|->
name|conn_session_type
operator|==
name|CONN_SESSION_TYPE_NORMAL
condition|)
block|{
if|if
condition|(
name|conn
operator|->
name|conn_target
operator|->
name|t_alias
operator|!=
name|NULL
condition|)
name|keys_add
argument_list|(
name|response_keys
argument_list|,
literal|"TargetAlias"
argument_list|,
name|conn
operator|->
name|conn_target
operator|->
name|t_alias
argument_list|)
expr_stmt|;
name|keys_add_int
argument_list|(
name|response_keys
argument_list|,
literal|"TargetPortalGroupTag"
argument_list|,
name|pg
operator|->
name|pg_tag
argument_list|)
expr_stmt|;
block|}
name|keys_save
argument_list|(
name|response_keys
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|pdu_send
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|response
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|response_keys
argument_list|)
expr_stmt|;
name|pdu_delete
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|keys_delete
argument_list|(
name|request_keys
argument_list|)
expr_stmt|;
if|if
condition|(
name|fail
condition|)
block|{
name|log_debugx
argument_list|(
literal|"sent reject for AuthMethod; exiting"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ag
operator|->
name|ag_type
operator|!=
name|AG_TYPE_NO_AUTHENTICATION
condition|)
block|{
name|login_chap
argument_list|(
name|conn
argument_list|,
name|ag
argument_list|)
expr_stmt|;
name|login_negotiate
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trans
condition|)
block|{
name|login_negotiate
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|login_wait_transition
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

