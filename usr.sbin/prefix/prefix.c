begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD__
operator|>=
literal|3
end_if

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__>= 3 */
end_comment

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|DEF_ADVVALIDLIFETIME
value|2592000
end_define

begin_define
define|#
directive|define
name|DEF_ADVPREFERREDLIFETIME
value|604800
end_define

begin_decl_stmt
name|struct
name|in6_prefixreq
name|prereq
init|=
block|{
block|{
name|NULL
block|}
block|,
comment|/* interface name */
name|PR_ORIG_STATIC
block|,
literal|64
block|,
comment|/* default plen */
literal|2592000
block|,
comment|/* vltime=30days */
literal|604800
block|,
comment|/* pltime=7days */
comment|/* ra onlink=1 autonomous=1 */
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prefix */
end_comment

begin_decl_stmt
name|struct
name|in6_rrenumreq
name|rrreq
init|=
block|{
block|{
name|NULL
block|}
block|,
comment|/* interface name */
name|PR_ORIG_STATIC
block|,
comment|/* default origin */
literal|64
block|,
comment|/* default match len */
literal|0
block|,
comment|/* default min match len */
literal|128
block|,
comment|/* default max match len */
literal|0
block|,
comment|/* default uselen */
literal|0
block|,
comment|/* default keeplen */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* default raflag mask */
literal|2592000
block|,
comment|/* vltime=30days */
literal|604800
block|,
comment|/* pltime=7days */
comment|/* ra onlink=1 autonomous=1 */
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|}
block|,
block|{
name|NULL
block|}
block|,
comment|/* match prefix */
block|{
name|NULL
block|}
comment|/* use prefix */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|)
value|((caddr_t)&x)
end_define

begin_struct
struct|struct
name|prefix_cmds
block|{
specifier|const
name|char
modifier|*
name|errmsg
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|req
decl_stmt|;
block|}
name|prcmds
index|[]
init|=
block|{
block|{
literal|"SIOCSIFPREFIX_IN6 failed"
block|,
name|SIOCSIFPREFIX_IN6
block|,
name|C
argument_list|(
argument|prereq
argument_list|)
block|}
block|,
block|{
literal|"SIOCDIFPREFIX_IN6 failed"
block|,
name|SIOCDIFPREFIX_IN6
block|,
name|C
argument_list|(
argument|prereq
argument_list|)
block|}
block|,
block|{
literal|"SIOCAIFPREFIX_IN6 failed"
block|,
name|SIOCAIFPREFIX_IN6
block|,
name|C
argument_list|(
argument|rrreq
argument_list|)
block|}
block|,
block|{
literal|"SIOCCIFPREFIX_IN6 failed"
block|,
name|SIOCCIFPREFIX_IN6
block|,
name|C
argument_list|(
argument|rrreq
argument_list|)
block|}
block|,
block|{
literal|"SIOCSGIFPREFIX_IN6 failed"
block|,
name|SIOCSGIFPREFIX_IN6
block|,
name|C
argument_list|(
argument|rrreq
argument_list|)
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PREF_CMD_SET
value|0
end_define

begin_define
define|#
directive|define
name|PREF_CMD_DELETE
value|1
end_define

begin_define
define|#
directive|define
name|PREF_CMD_ADD
value|2
end_define

begin_define
define|#
directive|define
name|PREF_CMD_CHANGE
value|3
end_define

begin_define
define|#
directive|define
name|PREF_CMD_SETGLOBAL
value|4
end_define

begin_define
define|#
directive|define
name|PREF_CMD_MAX
value|5
end_define

begin_decl_stmt
name|u_int
name|prcmd
init|=
name|PREF_CMD_SET
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default command */
end_comment

begin_decl_stmt
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|newprefix_setdel
decl_stmt|,
name|newprefix_match
decl_stmt|,
name|newprefix_use
decl_stmt|,
name|newprefix_uselen
decl_stmt|,
name|newprefix_keeplen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|Perror
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|cmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prefix
name|__P
argument_list|(
operator|(
name|int
name|argc
operator|,
name|char
operator|*
specifier|const
operator|*
name|argv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|usage
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|setlifetime
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|atime
operator|,
name|u_int32_t
operator|*
name|btime
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|all
decl_stmt|,
name|explicit_prefix
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|void
name|c_func
name|__P
typedef|((const
name|char
modifier|*
name|cmd
typedef|,
name|int
name|arg
typedef|));
end_typedef

begin_decl_stmt
name|c_func
name|set_vltime
decl_stmt|,
name|set_pltime
decl_stmt|,
name|set_raf_onlink
decl_stmt|,
name|set_raf_auto
decl_stmt|,
name|set_rrf_decrvalid
decl_stmt|,
name|set_rrf_decrprefd
decl_stmt|,
name|get_setdelprefix
decl_stmt|,
name|get_matchprefix
decl_stmt|,
name|get_useprefix
decl_stmt|,
name|set_matchlen
decl_stmt|,
name|set_match_minlen
decl_stmt|,
name|set_match_maxlen
decl_stmt|,
name|set_use_uselen
decl_stmt|,
name|set_use_keeplen
decl_stmt|,
name|set_prefix_cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|getprefixlen
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|getprefix
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NEXTARG
value|0xffffff
end_define

begin_struct
specifier|const
struct|struct
name|cmd
block|{
specifier|const
name|char
modifier|*
name|c_name
decl_stmt|;
name|int
name|c_parameter
decl_stmt|;
comment|/* NEXTARG means next argv */
name|void
argument_list|(
argument|*c_func
argument_list|)
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
block|}
name|cmds
index|[]
init|=
block|{
block|{
literal|"set"
block|,
name|PREF_CMD_SET
block|,
name|set_prefix_cmd
block|}
block|,
block|{
literal|"delete"
block|,
name|PREF_CMD_DELETE
block|,
name|set_prefix_cmd
block|}
block|,
block|{
literal|"prefixlen"
block|,
name|NEXTARG
block|,
name|getprefixlen
block|}
block|,
block|{
literal|"add"
block|,
name|PREF_CMD_ADD
block|,
name|set_prefix_cmd
block|}
block|,
block|{
literal|"change"
block|,
name|PREF_CMD_CHANGE
block|,
name|set_prefix_cmd
block|}
block|,
block|{
literal|"setglobal"
block|,
name|PREF_CMD_SETGLOBAL
block|,
name|set_prefix_cmd
block|}
block|,
block|{
literal|"matchpr"
block|,
name|NEXTARG
block|,
name|get_matchprefix
block|}
block|,
block|{
literal|"usepr"
block|,
name|NEXTARG
block|,
name|get_useprefix
block|}
block|,
block|{
literal|"mp_len"
block|,
name|NEXTARG
block|,
name|set_matchlen
block|}
block|,
block|{
literal|"mp_minlen"
block|,
name|NEXTARG
block|,
name|set_match_minlen
block|}
block|,
block|{
literal|"mp_maxlen"
block|,
name|NEXTARG
block|,
name|set_match_maxlen
block|}
block|,
block|{
literal|"up_uselen"
block|,
name|NEXTARG
block|,
name|set_use_uselen
block|}
block|,
block|{
literal|"up_keeplen"
block|,
name|NEXTARG
block|,
name|set_use_keeplen
block|}
block|,
block|{
literal|"vltime"
block|,
name|NEXTARG
block|,
name|set_vltime
block|}
block|,
block|{
literal|"pltime"
block|,
name|NEXTARG
block|,
name|set_pltime
block|}
block|,
block|{
literal|"raf_onlink"
block|,
literal|1
block|,
name|set_raf_onlink
block|}
block|,
block|{
literal|"-raf_onlink"
block|,
literal|0
block|,
name|set_raf_onlink
block|}
block|,
block|{
literal|"raf_auto"
block|,
literal|1
block|,
name|set_raf_auto
block|}
block|,
block|{
literal|"-raf_auto"
block|,
literal|0
block|,
name|set_raf_auto
block|}
block|,
block|{
literal|"rrf_decrvalid"
block|,
literal|1
block|,
name|set_rrf_decrvalid
block|}
block|,
block|{
literal|"-rrf_decrvalid"
block|,
literal|0
block|,
name|set_rrf_decrvalid
block|}
block|,
block|{
literal|"rrf_decrprefd"
block|,
literal|1
block|,
name|set_rrf_decrprefd
block|}
block|,
block|{
literal|"-rrf_decrprefd"
block|,
literal|0
block|,
name|set_rrf_decrprefd
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|get_setdelprefix
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
literal|"usage: prefix interface prefix_value [parameters] [set|delete]\n"
literal|"       prefix interface\n"
literal|"                matchpr matchpr_value mp_len mp_len_value\n"
literal|"                usepr usepr_value up_uselen up_uselen_value\n"
literal|"                [parameters] [add|change|setglobal]\n"
literal|"       prefix -a [-d] [-u]\n"
literal|"                matchpr matchpr_value mp_len mp_len_value\n"
literal|"                usepr usepr_value up_uselen up_uselen_value\n"
literal|"                [parameters] [add|change|setglobal]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|downonly
decl_stmt|,
name|uponly
decl_stmt|;
name|int
name|foundit
init|=
literal|0
decl_stmt|;
name|int
name|addrcount
decl_stmt|;
name|struct
name|if_msghdr
modifier|*
name|ifm
decl_stmt|,
modifier|*
name|nextifm
decl_stmt|;
name|struct
name|ifa_msghdr
modifier|*
name|ifam
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|lim
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|size_t
name|needed
decl_stmt|;
name|int
name|mib
index|[
literal|6
index|]
decl_stmt|;
comment|/* Parse leading line options */
name|all
operator|=
name|downonly
operator|=
name|uponly
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"adu"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* scan all interfaces */
name|all
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* restrict scan to "down" interfaces */
name|downonly
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* restrict scan to "up" interfaces */
name|uponly
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* nonsense.. */
if|if
condition|(
name|uponly
operator|&&
name|downonly
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|all
condition|)
block|{
comment|/* not listing, need an argument */
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
operator|*
name|argv
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_NET
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|PF_ROUTE
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|AF_INET6
expr_stmt|;
comment|/* address family */
name|mib
index|[
literal|4
index|]
operator|=
name|NET_RT_IFLIST
expr_stmt|;
name|mib
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|,
operator|&
name|needed
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"iflist-sysctl-estimate"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|needed
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|buf
argument_list|,
operator|&
name|needed
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"actual retrieval of interface table"
argument_list|)
expr_stmt|;
name|lim
operator|=
name|buf
operator|+
name|needed
expr_stmt|;
name|next
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|next
operator|<
name|lim
condition|)
block|{
name|ifm
operator|=
operator|(
expr|struct
name|if_msghdr
operator|*
operator|)
name|next
expr_stmt|;
if|if
condition|(
name|ifm
operator|->
name|ifm_type
operator|==
name|RTM_IFINFO
condition|)
block|{
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
name|ifm
operator|+
literal|1
operator|)
expr_stmt|;
name|flags
operator|=
name|ifm
operator|->
name|ifm_flags
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"out of sync parsing NET_RT_IFLIST\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expected %d, got %d\n"
argument_list|,
name|RTM_IFINFO
argument_list|,
name|ifm
operator|->
name|ifm_type
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"msglen = %d\n"
argument_list|,
name|ifm
operator|->
name|ifm_msglen
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"buf:%p, next:%p, lim:%p\n"
argument_list|,
name|buf
argument_list|,
name|next
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|next
operator|+=
name|ifm
operator|->
name|ifm_msglen
expr_stmt|;
name|ifam
operator|=
name|NULL
expr_stmt|;
name|addrcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|next
operator|<
name|lim
condition|)
block|{
name|nextifm
operator|=
operator|(
expr|struct
name|if_msghdr
operator|*
operator|)
name|next
expr_stmt|;
if|if
condition|(
name|nextifm
operator|->
name|ifm_type
operator|!=
name|RTM_NEWADDR
condition|)
break|break;
if|if
condition|(
name|ifam
operator|==
name|NULL
condition|)
name|ifam
operator|=
operator|(
expr|struct
name|ifa_msghdr
operator|*
operator|)
name|nextifm
expr_stmt|;
name|addrcount
operator|++
expr_stmt|;
name|next
operator|+=
name|nextifm
operator|->
name|ifm_msglen
expr_stmt|;
block|}
if|if
condition|(
name|all
condition|)
block|{
if|if
condition|(
name|uponly
condition|)
if|if
condition|(
operator|(
name|flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* not up */
if|if
condition|(
name|downonly
condition|)
if|if
condition|(
name|flags
operator|&
name|IFF_UP
condition|)
continue|continue;
comment|/* not down */
name|strncpy
argument_list|(
name|name
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|,
name|sdl
operator|->
name|sdl_nlen
argument_list|)
expr_stmt|;
name|name
index|[
name|sdl
operator|->
name|sdl_nlen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|!=
name|sdl
operator|->
name|sdl_nlen
condition|)
continue|continue;
comment|/* not same len */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|sdl
operator|->
name|sdl_data
argument_list|,
name|sdl
operator|->
name|sdl_nlen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* not same name */
block|}
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
name|prefix
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|else {
comment|/* TODO: print prefix status by sysctl */
block|}
endif|#
directive|endif
if|if
condition|(
name|all
operator|==
literal|0
condition|)
block|{
name|foundit
operator|++
expr_stmt|;
comment|/* flag it as 'done' */
break|break;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|all
operator|==
literal|0
operator|&&
name|foundit
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"interface %s does not exist"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|prefix
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
specifier|const
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
specifier|register
specifier|const
name|struct
name|cmd
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|cmds
init|;
name|p
operator|->
name|c_name
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|p
operator|->
name|c_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
operator|->
name|c_func
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|c_parameter
operator|==
name|NEXTARG
condition|)
block|{
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"'%s' requires argument"
argument_list|,
name|p
operator|->
name|c_name
argument_list|)
expr_stmt|;
call|(
modifier|*
name|p
operator|->
name|c_func
call|)
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
else|else
call|(
modifier|*
name|p
operator|->
name|c_func
call|)
argument_list|(
operator|*
name|argv
argument_list|,
name|p
operator|->
name|c_parameter
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|prcmd
operator|>
name|PREF_CMD_MAX
condition|)
block|{
name|Perror
argument_list|(
literal|"ioctl: unknown prefix cmd"
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|prcmd
operator|==
name|PREF_CMD_SET
operator|||
name|prcmd
operator|==
name|PREF_CMD_DELETE
condition|)
block|{
if|if
condition|(
operator|!
name|newprefix_setdel
condition|)
name|usage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* ADD|CHANGE|SETGLOBAL */
if|if
condition|(
operator|!
name|newprefix_match
condition|)
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newprefix_use
condition|)
name|rrreq
operator|.
name|irr_u_uselen
operator|=
literal|0
expr_stmt|;
comment|/* make clear that no use_prefix */
elseif|else
if|if
condition|(
name|newprefix_keeplen
operator|==
name|NULL
operator|&&
name|rrreq
operator|.
name|irr_u_uselen
operator|<
literal|64
condition|)
comment|/* init keeplen to make uselen + keeplen equal 64 */
name|rrreq
operator|.
name|irr_u_keeplen
operator|=
literal|64
operator|-
name|rrreq
operator|.
name|irr_u_uselen
expr_stmt|;
if|if
condition|(
name|explicit_prefix
operator|==
literal|0
condition|)
block|{
comment|/* Aggregatable address architecture defines all prefixes 		   are 64. So, it is convenient to set prefixlen to 64 if 		   it is not specified. */
name|getprefixlen
argument_list|(
literal|"64"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|prcmds
index|[
name|prcmd
index|]
operator|.
name|req
argument_list|,
name|name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|prcmds
index|[
name|prcmd
index|]
operator|.
name|cmd
argument_list|,
name|prcmds
index|[
name|prcmd
index|]
operator|.
name|req
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|all
operator|&&
name|errno
operator|==
name|EADDRNOTAVAIL
condition|)
goto|goto
name|end
goto|;
name|Perror
argument_list|(
name|prcmds
index|[
name|prcmd
index|]
operator|.
name|errmsg
argument_list|)
expr_stmt|;
block|}
name|end
label|:
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PREFIX
value|0
end_define

begin_define
define|#
directive|define
name|MPREFIX
value|1
end_define

begin_define
define|#
directive|define
name|UPREFIX
value|2
end_define

begin_function
name|void
name|Perror
parameter_list|(
name|cmd
parameter_list|)
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENXIO
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: no such interface"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|EPERM
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: permission denied"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SIN6
parameter_list|(
name|x
parameter_list|)
value|((struct sockaddr_in6 *)&(x))
end_define

begin_decl_stmt
name|struct
name|sockaddr_in6
modifier|*
name|sin6tab
index|[]
init|=
block|{
name|SIN6
argument_list|(
name|prereq
operator|.
name|ipr_prefix
argument_list|)
block|,
name|SIN6
argument_list|(
name|rrreq
operator|.
name|irr_matchprefix
argument_list|)
block|,
name|SIN6
argument_list|(
argument|rrreq.irr_useprefix
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|getprefixlen
parameter_list|(
specifier|const
name|char
modifier|*
name|plen
parameter_list|,
name|int
name|unused
parameter_list|)
block|{
name|int
name|len
init|=
name|atoi
argument_list|(
name|plen
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|<
literal|0
operator|)
operator|||
operator|(
name|len
operator|>
literal|128
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: bad value"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
comment|/* set plen for prereq */
name|prereq
operator|.
name|ipr_plen
operator|=
name|len
expr_stmt|;
name|explicit_prefix
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getprefix
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|which
parameter_list|)
block|{
specifier|register
name|struct
name|sockaddr_in6
modifier|*
name|sin
init|=
name|sin6tab
index|[
name|which
index|]
decl_stmt|;
comment|/* 	 * Delay the ioctl to set the interface prefix until flags are all set. 	 * The prefix interpretation may depend on the flags, 	 * and the flags may change when the prefix is set. 	 */
name|sin
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|prefix
argument_list|,
operator|&
name|sin
operator|->
name|sin6_addr
argument_list|)
operator|!=
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: bad value"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|get_setdelprefix
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|unused
parameter_list|)
block|{
name|newprefix_setdel
operator|++
expr_stmt|;
name|getprefix
argument_list|(
name|prefix
argument_list|,
name|PREFIX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|get_matchprefix
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|unused
parameter_list|)
block|{
name|newprefix_match
operator|++
expr_stmt|;
name|prcmd
operator|=
operator|(
name|prcmd
operator|==
name|PREF_CMD_SET
operator|)
condition|?
name|PREF_CMD_ADD
else|:
name|prcmd
expr_stmt|;
name|getprefix
argument_list|(
name|prefix
argument_list|,
name|MPREFIX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|get_useprefix
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|int
name|unused
parameter_list|)
block|{
name|newprefix_use
operator|++
expr_stmt|;
if|if
condition|(
name|newprefix_uselen
operator|==
literal|0
condition|)
name|rrreq
operator|.
name|irr_u_uselen
operator|=
literal|64
expr_stmt|;
name|getprefix
argument_list|(
name|prefix
argument_list|,
name|UPREFIX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_plen
parameter_list|(
specifier|const
name|char
modifier|*
name|plen
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|atoi
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|<
literal|0
operator|)
operator|||
operator|(
name|len
operator|>
literal|128
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: bad value"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
name|void
name|set_matchlen
parameter_list|(
specifier|const
name|char
modifier|*
name|plen
parameter_list|,
name|int
name|unused
parameter_list|)
block|{
name|rrreq
operator|.
name|irr_m_len
operator|=
name|get_plen
argument_list|(
name|plen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_match_minlen
parameter_list|(
specifier|const
name|char
modifier|*
name|plen
parameter_list|,
name|int
name|unused
parameter_list|)
block|{
name|rrreq
operator|.
name|irr_m_minlen
operator|=
name|get_plen
argument_list|(
name|plen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_match_maxlen
parameter_list|(
specifier|const
name|char
modifier|*
name|plen
parameter_list|,
name|int
name|unused
parameter_list|)
block|{
name|rrreq
operator|.
name|irr_m_maxlen
operator|=
name|get_plen
argument_list|(
name|plen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_use_uselen
parameter_list|(
specifier|const
name|char
modifier|*
name|plen
parameter_list|,
name|int
name|unused
parameter_list|)
block|{
name|newprefix_uselen
operator|++
expr_stmt|;
name|rrreq
operator|.
name|irr_u_uselen
operator|=
name|get_plen
argument_list|(
name|plen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_use_keeplen
parameter_list|(
specifier|const
name|char
modifier|*
name|plen
parameter_list|,
name|int
name|unused
parameter_list|)
block|{
name|newprefix_keeplen
operator|++
expr_stmt|;
name|rrreq
operator|.
name|irr_u_keeplen
operator|=
name|get_plen
argument_list|(
name|plen
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_vltime
parameter_list|(
specifier|const
name|char
modifier|*
name|ltime
parameter_list|,
name|int
name|unused
parameter_list|)
block|{
name|setlifetime
argument_list|(
name|ltime
argument_list|,
operator|&
name|prereq
operator|.
name|ipr_vltime
argument_list|)
expr_stmt|;
name|rrreq
operator|.
name|irr_vltime
operator|=
name|prereq
operator|.
name|ipr_vltime
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_pltime
parameter_list|(
specifier|const
name|char
modifier|*
name|ltime
parameter_list|,
name|int
name|unused
parameter_list|)
block|{
name|setlifetime
argument_list|(
name|ltime
argument_list|,
operator|&
name|prereq
operator|.
name|ipr_pltime
argument_list|)
expr_stmt|;
name|rrreq
operator|.
name|irr_pltime
operator|=
name|prereq
operator|.
name|ipr_pltime
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_raf_onlink
parameter_list|(
specifier|const
name|char
modifier|*
name|unused
parameter_list|,
name|int
name|value
parameter_list|)
block|{
comment|/* raflagmask is only meaningful when newprefix_rrenum */
name|rrreq
operator|.
name|irr_raflagmask
operator|.
name|onlink
operator|=
literal|1
expr_stmt|;
name|prereq
operator|.
name|ipr_flags
operator|.
name|prf_ra
operator|.
name|onlink
operator|=
name|rrreq
operator|.
name|irr_flags
operator|.
name|prf_ra
operator|.
name|onlink
operator|=
name|value
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_raf_auto
parameter_list|(
specifier|const
name|char
modifier|*
name|unused
parameter_list|,
name|int
name|value
parameter_list|)
block|{
comment|/* only meaningful when newprefix_rrenum */
name|rrreq
operator|.
name|irr_raflagmask
operator|.
name|autonomous
operator|=
literal|1
expr_stmt|;
name|prereq
operator|.
name|ipr_flags
operator|.
name|prf_ra
operator|.
name|autonomous
operator|=
name|rrreq
operator|.
name|irr_flags
operator|.
name|prf_ra
operator|.
name|autonomous
operator|=
name|value
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_rrf_decrvalid
parameter_list|(
specifier|const
name|char
modifier|*
name|unused
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|prereq
operator|.
name|ipr_flags
operator|.
name|prf_rr
operator|.
name|decrvalid
operator|=
name|rrreq
operator|.
name|irr_flags
operator|.
name|prf_rr
operator|.
name|decrvalid
operator|=
name|value
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_rrf_decrprefd
parameter_list|(
specifier|const
name|char
modifier|*
name|unused
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|prereq
operator|.
name|ipr_flags
operator|.
name|prf_rr
operator|.
name|decrprefd
operator|=
name|rrreq
operator|.
name|irr_flags
operator|.
name|prf_rr
operator|.
name|decrprefd
operator|=
name|value
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_prefix_cmd
parameter_list|(
specifier|const
name|char
modifier|*
name|unused
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|prcmd
operator|=
name|cmd
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setlifetime
parameter_list|(
specifier|const
name|char
modifier|*
name|atime
parameter_list|,
name|u_int32_t
modifier|*
name|btime
parameter_list|)
block|{
name|int
name|days
init|=
literal|0
decl_stmt|,
name|hours
init|=
literal|0
decl_stmt|,
name|minutes
init|=
literal|0
decl_stmt|,
name|seconds
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|ttime
decl_stmt|;
name|char
modifier|*
name|check
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|atime
argument_list|,
literal|"infinity"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|btime
operator|=
literal|0xffffffff
expr_stmt|;
return|return;
block|}
name|ttime
operator|=
name|strtoul
argument_list|(
name|atime
argument_list|,
operator|&
name|check
argument_list|,
literal|10
argument_list|)
operator|&
literal|0xffffffff
expr_stmt|;
if|if
condition|(
operator|*
name|check
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|btime
operator|=
name|ttime
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|atime
argument_list|,
literal|"d%2dh%2dm%2ds%2d"
argument_list|,
operator|&
name|days
argument_list|,
operator|&
name|hours
argument_list|,
operator|&
name|minutes
argument_list|,
operator|&
name|seconds
argument_list|)
operator|<
literal|0
condition|)
block|{
name|Perror
argument_list|(
literal|"wrong time format: valid is d00h00m00s00, \n"
literal|"where 00 can be any octal number, \n"
literal|"\'d\' is for days, \'h\' is for hours, \n"
literal|"\'m\' is for minutes, and \'s\' is for seconds \n"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|btime
operator|=
literal|0
expr_stmt|;
operator|*
name|btime
operator|+=
name|seconds
expr_stmt|;
operator|*
name|btime
operator|+=
name|minutes
operator|*
literal|60
expr_stmt|;
operator|*
name|btime
operator|+=
name|hours
operator|*
literal|3600
expr_stmt|;
operator|*
name|btime
operator|+=
name|days
operator|*
literal|86400
expr_stmt|;
return|return;
block|}
end_function

end_unit

