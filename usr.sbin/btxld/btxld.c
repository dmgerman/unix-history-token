begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998 Robert Nordier  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|"btx.h"
end_include

begin_include
include|#
directive|include
file|"elfh.h"
end_include

begin_define
define|#
directive|define
name|BTX_PATH
value|"/sys/boot/i386/btx"
end_define

begin_define
define|#
directive|define
name|I_LDR
value|0
end_define

begin_comment
comment|/* BTX loader */
end_comment

begin_define
define|#
directive|define
name|I_BTX
value|1
end_define

begin_comment
comment|/* BTX kernel */
end_comment

begin_define
define|#
directive|define
name|I_CLNT
value|2
end_define

begin_comment
comment|/* Client program */
end_comment

begin_define
define|#
directive|define
name|F_BIN
value|0
end_define

begin_comment
comment|/* Binary */
end_comment

begin_define
define|#
directive|define
name|F_AOUT
value|1
end_define

begin_comment
comment|/* ZMAGIC a.out */
end_comment

begin_define
define|#
directive|define
name|F_ELF
value|2
end_define

begin_comment
comment|/* 32-bit ELF */
end_comment

begin_define
define|#
directive|define
name|F_CNT
value|3
end_define

begin_comment
comment|/* Number of formats */
end_comment

begin_define
define|#
directive|define
name|IMPURE
value|1
end_define

begin_comment
comment|/* Writable text */
end_comment

begin_define
define|#
directive|define
name|MAXU32
value|0xffffffff
end_define

begin_comment
comment|/* Maximum unsigned 32-bit quantity */
end_comment

begin_define
define|#
directive|define
name|align
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(((x) + (y) - 1)& ~((y) - 1))
end_define

begin_struct
struct|struct
name|hdr
block|{
name|uint32_t
name|fmt
decl_stmt|;
comment|/* Format */
name|uint32_t
name|flags
decl_stmt|;
comment|/* Bit flags */
name|uint32_t
name|size
decl_stmt|;
comment|/* Size of file */
name|uint32_t
name|text
decl_stmt|;
comment|/* Size of text segment */
name|uint32_t
name|data
decl_stmt|;
comment|/* Size of data segment */
name|uint32_t
name|bss
decl_stmt|;
comment|/* Size of bss segment */
name|uint32_t
name|org
decl_stmt|;
comment|/* Program origin */
name|uint32_t
name|entry
decl_stmt|;
comment|/* Program entry point */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|fmtlist
index|[]
init|=
block|{
literal|"bin"
block|,
literal|"aout"
block|,
literal|"elf"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|binfo
index|[]
init|=
literal|"kernel: ver=%u.%02u size=%x load=%x entry=%x map=%uM "
literal|"pgctl=%x:%x\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|cinfo
index|[]
init|=
literal|"client: fmt=%s size=%x text=%x data=%x bss=%x entry=%x\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|oinfo
index|[]
init|=
literal|"output: fmt=%s size=%x text=%x data=%x org=%x entry=%x\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|lname
init|=
name|BTX_PATH
literal|"/btxldr/btxldr"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BTX loader */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bname
init|=
name|BTX_PATH
literal|"/btx/btx"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BTX kernel */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|oname
init|=
literal|"a.out"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output filename */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ppage
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First page present */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wpage
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First page writable */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|format
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output format */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|centry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Client entry address */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|lentry
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Loader entry address */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Eflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Client entry option */
end_comment

begin_decl_stmt
specifier|static
name|int
name|quiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inhibit warnings */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Display information */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|tname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary output file */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current input file */
end_comment

begin_function_decl
specifier|static
name|void
name|cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|btxld
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|getbtx
parameter_list|(
name|int
parameter_list|,
name|struct
name|btx_hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gethdr
parameter_list|(
name|int
parameter_list|,
name|struct
name|hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|puthdr
parameter_list|(
name|int
parameter_list|,
name|struct
name|hdr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|,
name|off_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|readx
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|off_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|writex
parameter_list|(
name|int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seekx
parameter_list|(
name|int
parameter_list|,
name|off_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|optfmt
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|optaddr
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|optpage
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|Warn
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * A link editor for BTX clients.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"qvb:E:e:f:l:o:P:W:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|bname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|centry
operator|=
name|optaddr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|Eflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|lentry
operator|=
name|optaddr
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|format
operator|=
name|optfmt
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|oname
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|ppage
operator|=
name|optpage
argument_list|(
name|optarg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|wpage
operator|=
name|optpage
argument_list|(
name|optarg
argument_list|,
name|BTX_MAXCWR
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|atexit
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
name|btxld
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up after errors.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|tname
condition|)
name|remove
argument_list|(
name|tname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read the input files; write the output file; display information.  */
end_comment

begin_function
specifier|static
name|void
name|btxld
parameter_list|(
specifier|const
name|char
modifier|*
name|iname
parameter_list|)
block|{
name|char
name|name
index|[
name|FILENAME_MAX
index|]
decl_stmt|;
name|struct
name|btx_hdr
name|btx
decl_stmt|;
name|struct
name|hdr
name|ihdr
decl_stmt|,
name|ohdr
decl_stmt|;
name|unsigned
name|int
name|ldr_size
decl_stmt|,
name|cwr
decl_stmt|;
name|int
name|fdi
index|[
literal|3
index|]
decl_stmt|,
name|fdo
decl_stmt|,
name|i
decl_stmt|;
name|ldr_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|I_LDR
init|;
name|i
operator|<=
name|I_CLNT
condition|;
name|i
operator|++
control|)
block|{
name|fname
operator|=
name|i
operator|==
name|I_LDR
condition|?
name|lname
else|:
name|i
operator|==
name|I_BTX
condition|?
name|bname
else|:
name|iname
expr_stmt|;
if|if
condition|(
operator|(
name|fdi
index|[
name|i
index|]
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|I_LDR
case|:
name|gethdr
argument_list|(
name|fdi
index|[
name|i
index|]
argument_list|,
operator|&
name|ihdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ihdr
operator|.
name|fmt
operator|!=
name|F_BIN
condition|)
name|Warn
argument_list|(
name|fname
argument_list|,
literal|"Loader format is %s; processing as %s"
argument_list|,
name|fmtlist
index|[
name|ihdr
operator|.
name|fmt
index|]
argument_list|,
name|fmtlist
index|[
name|F_BIN
index|]
argument_list|)
expr_stmt|;
name|ldr_size
operator|=
name|ihdr
operator|.
name|size
expr_stmt|;
break|break;
case|case
name|I_BTX
case|:
name|getbtx
argument_list|(
name|fdi
index|[
name|i
index|]
argument_list|,
operator|&
name|btx
argument_list|)
expr_stmt|;
break|break;
case|case
name|I_CLNT
case|:
name|gethdr
argument_list|(
name|fdi
index|[
name|i
index|]
argument_list|,
operator|&
name|ihdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ihdr
operator|.
name|org
operator|&&
name|ihdr
operator|.
name|org
operator|!=
name|BTX_PGSIZE
condition|)
name|Warn
argument_list|(
name|fname
argument_list|,
literal|"Client origin is 0x%x; expecting 0 or 0x%x"
argument_list|,
name|ihdr
operator|.
name|org
argument_list|,
name|BTX_PGSIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|&
name|ohdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ohdr
argument_list|)
argument_list|)
expr_stmt|;
name|ohdr
operator|.
name|fmt
operator|=
name|format
expr_stmt|;
name|ohdr
operator|.
name|text
operator|=
name|ldr_size
expr_stmt|;
name|ohdr
operator|.
name|data
operator|=
name|btx
operator|.
name|btx_textsz
operator|+
name|ihdr
operator|.
name|size
expr_stmt|;
name|ohdr
operator|.
name|org
operator|=
name|lentry
expr_stmt|;
name|ohdr
operator|.
name|entry
operator|=
name|lentry
expr_stmt|;
name|cwr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wpage
operator|>
literal|0
operator|||
operator|(
name|wpage
operator|==
operator|-
literal|1
operator|&&
operator|!
operator|(
name|ihdr
operator|.
name|flags
operator|&
name|IMPURE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|wpage
operator|>
literal|0
condition|)
name|cwr
operator|=
name|wpage
expr_stmt|;
else|else
block|{
name|cwr
operator|=
name|howmany
argument_list|(
name|ihdr
operator|.
name|text
argument_list|,
name|BTX_PGSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwr
operator|>
name|BTX_MAXCWR
condition|)
name|cwr
operator|=
name|BTX_MAXCWR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ppage
operator|>
literal|0
operator|||
operator|(
name|ppage
operator|&&
name|wpage
operator|&&
name|ihdr
operator|.
name|org
operator|>=
name|BTX_PGSIZE
operator|)
condition|)
block|{
name|btx
operator|.
name|btx_flags
operator||=
name|BTX_MAPONE
expr_stmt|;
if|if
condition|(
operator|!
name|cwr
condition|)
name|cwr
operator|++
expr_stmt|;
block|}
name|btx
operator|.
name|btx_pgctl
operator|-=
name|cwr
expr_stmt|;
name|btx
operator|.
name|btx_entry
operator|=
name|Eflag
condition|?
name|centry
else|:
name|ihdr
operator|.
name|entry
expr_stmt|;
if|if
condition|(
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s.tmp"
argument_list|,
name|oname
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|name
argument_list|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"%s: Filename too long"
argument_list|,
name|oname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdo
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_WRONLY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tname
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|puthdr
argument_list|(
name|fdo
argument_list|,
operator|&
name|ohdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|I_LDR
init|;
name|i
operator|<=
name|I_CLNT
condition|;
name|i
operator|++
control|)
block|{
name|fname
operator|=
name|i
operator|==
name|I_LDR
condition|?
name|lname
else|:
name|i
operator|==
name|I_BTX
condition|?
name|bname
else|:
name|iname
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|I_LDR
case|:
name|copy
argument_list|(
name|fdi
index|[
name|i
index|]
argument_list|,
name|fdo
argument_list|,
name|ldr_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|seekx
argument_list|(
name|fdo
argument_list|,
name|ohdr
operator|.
name|size
operator|+=
name|ohdr
operator|.
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|I_BTX
case|:
name|writex
argument_list|(
name|fdo
argument_list|,
operator|&
name|btx
argument_list|,
sizeof|sizeof
argument_list|(
name|btx
argument_list|)
argument_list|)
expr_stmt|;
name|copy
argument_list|(
name|fdi
index|[
name|i
index|]
argument_list|,
name|fdo
argument_list|,
name|btx
operator|.
name|btx_textsz
operator|-
sizeof|sizeof
argument_list|(
name|btx
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|btx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|I_CLNT
case|:
name|copy
argument_list|(
name|fdi
index|[
name|i
index|]
argument_list|,
name|fdo
argument_list|,
name|ihdr
operator|.
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|fdo
argument_list|,
name|ohdr
operator|.
name|size
operator|+=
name|ohdr
operator|.
name|data
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fdi
index|[
name|i
index|]
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|close
argument_list|(
name|fdo
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tname
argument_list|,
name|oname
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s: Can't rename to %s"
argument_list|,
name|tname
argument_list|,
name|oname
argument_list|)
expr_stmt|;
name|tname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
name|binfo
argument_list|,
name|btx
operator|.
name|btx_majver
argument_list|,
name|btx
operator|.
name|btx_minver
argument_list|,
name|btx
operator|.
name|btx_textsz
argument_list|,
name|BTX_ORIGIN
argument_list|(
name|btx
argument_list|)
argument_list|,
name|BTX_ENTRY
argument_list|(
name|btx
argument_list|)
argument_list|,
name|BTX_MAPPED
argument_list|(
name|btx
argument_list|)
operator|*
name|BTX_PGSIZE
operator|/
literal|0x100000
argument_list|,
operator|!
operator|!
operator|(
name|btx
operator|.
name|btx_flags
operator|&
name|BTX_MAPONE
operator|)
argument_list|,
name|BTX_MAPPED
argument_list|(
name|btx
argument_list|)
operator|-
name|btx
operator|.
name|btx_pgctl
operator|-
name|BTX_PGBASE
operator|/
name|BTX_PGSIZE
operator|-
name|BTX_MAPPED
argument_list|(
name|btx
argument_list|)
operator|*
literal|4
operator|/
name|BTX_PGSIZE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|cinfo
argument_list|,
name|fmtlist
index|[
name|ihdr
operator|.
name|fmt
index|]
argument_list|,
name|ihdr
operator|.
name|size
argument_list|,
name|ihdr
operator|.
name|text
argument_list|,
name|ihdr
operator|.
name|data
argument_list|,
name|ihdr
operator|.
name|bss
argument_list|,
name|ihdr
operator|.
name|entry
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|oinfo
argument_list|,
name|fmtlist
index|[
name|ohdr
operator|.
name|fmt
index|]
argument_list|,
name|ohdr
operator|.
name|size
argument_list|,
name|ohdr
operator|.
name|text
argument_list|,
name|ohdr
operator|.
name|data
argument_list|,
name|ohdr
operator|.
name|org
argument_list|,
name|ohdr
operator|.
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Read BTX file header.  */
end_comment

begin_function
specifier|static
name|void
name|getbtx
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|btx_hdr
modifier|*
name|btx
parameter_list|)
block|{
if|if
condition|(
name|readx
argument_list|(
name|fd
argument_list|,
name|btx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|btx
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|btx
argument_list|)
operator|||
name|btx
operator|->
name|btx_magic
index|[
literal|0
index|]
operator|!=
name|BTX_MAG0
operator|||
name|btx
operator|->
name|btx_magic
index|[
literal|1
index|]
operator|!=
name|BTX_MAG1
operator|||
name|btx
operator|->
name|btx_magic
index|[
literal|2
index|]
operator|!=
name|BTX_MAG2
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: Not a BTX kernel"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get file size and read a.out or ELF header.  */
end_comment

begin_function
specifier|static
name|void
name|gethdr
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
specifier|const
name|struct
name|exec
modifier|*
name|ex
decl_stmt|;
specifier|const
name|Elf32_Ehdr
modifier|*
name|ee
decl_stmt|;
specifier|const
name|Elf32_Phdr
modifier|*
name|ep
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|fmt
decl_stmt|,
name|x
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|memset
argument_list|(
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|>
name|MAXU32
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: Too big"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|size
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|hdr
operator|->
name|size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
for|for
control|(
name|fmt
operator|=
name|F_CNT
operator|-
literal|1
init|;
operator|!
name|hdr
operator|->
name|fmt
operator|&&
name|fmt
condition|;
name|fmt
operator|--
control|)
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|F_AOUT
case|:
name|ex
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|size
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
operator|&&
operator|!
name|N_BADMAG
argument_list|(
operator|*
name|ex
argument_list|)
condition|)
block|{
name|hdr
operator|->
name|fmt
operator|=
name|fmt
expr_stmt|;
name|x
operator|=
name|N_GETMAGIC
argument_list|(
operator|*
name|ex
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|OMAGIC
operator|||
name|x
operator|==
name|NMAGIC
condition|)
block|{
if|if
condition|(
name|x
operator|==
name|NMAGIC
condition|)
name|Warn
argument_list|(
name|fname
argument_list|,
literal|"Treating %s NMAGIC as OMAGIC"
argument_list|,
name|fmtlist
index|[
name|fmt
index|]
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|flags
operator||=
name|IMPURE
expr_stmt|;
block|}
name|hdr
operator|->
name|text
operator|=
name|ex
operator|->
name|a_text
expr_stmt|;
name|hdr
operator|->
name|data
operator|=
name|ex
operator|->
name|a_data
expr_stmt|;
name|hdr
operator|->
name|bss
operator|=
name|ex
operator|->
name|a_bss
expr_stmt|;
name|hdr
operator|->
name|entry
operator|=
name|ex
operator|->
name|a_entry
expr_stmt|;
if|if
condition|(
name|ex
operator|->
name|a_entry
operator|>=
name|BTX_PGSIZE
condition|)
name|hdr
operator|->
name|org
operator|=
name|BTX_PGSIZE
expr_stmt|;
block|}
break|break;
case|case
name|F_ELF
case|:
name|ee
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|size
operator|>=
sizeof|sizeof
argument_list|(
name|Elf32_Ehdr
argument_list|)
operator|&&
name|IS_ELF
argument_list|(
operator|*
name|ee
argument_list|)
condition|)
block|{
name|hdr
operator|->
name|fmt
operator|=
name|fmt
expr_stmt|;
for|for
control|(
name|n
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ee
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|p
operator|+
name|ee
operator|->
name|e_phoff
operator|+
name|ee
operator|->
name|e_phentsize
operator|*
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|p_type
operator|==
name|PT_LOAD
condition|)
switch|switch
condition|(
name|n
operator|++
condition|)
block|{
case|case
literal|0
case|:
name|hdr
operator|->
name|text
operator|=
name|ep
operator|->
name|p_filesz
expr_stmt|;
name|hdr
operator|->
name|org
operator|=
name|ep
operator|->
name|p_paddr
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|p_flags
operator|&
name|PF_W
condition|)
name|hdr
operator|->
name|flags
operator||=
name|IMPURE
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|hdr
operator|->
name|data
operator|=
name|ep
operator|->
name|p_filesz
expr_stmt|;
name|hdr
operator|->
name|bss
operator|=
name|ep
operator|->
name|p_memsz
operator|-
name|ep
operator|->
name|p_filesz
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|Warn
argument_list|(
name|fname
argument_list|,
literal|"Ignoring extra %s PT_LOAD segments"
argument_list|,
name|fmtlist
index|[
name|fmt
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|hdr
operator|->
name|entry
operator|=
name|ee
operator|->
name|e_entry
expr_stmt|;
block|}
block|}
if|if
condition|(
name|munmap
argument_list|(
name|p
argument_list|,
name|hdr
operator|->
name|size
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a.out or ELF header.  */
end_comment

begin_function
specifier|static
name|void
name|puthdr
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|exec
name|ex
decl_stmt|;
name|struct
name|elfh
name|eh
decl_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|fmt
condition|)
block|{
case|case
name|F_AOUT
case|:
name|memset
argument_list|(
operator|&
name|ex
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
name|N_SETMAGIC
argument_list|(
name|ex
argument_list|,
name|ZMAGIC
argument_list|,
name|MID_ZERO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|text
operator|=
name|N_ALIGN
argument_list|(
name|ex
argument_list|,
name|hdr
operator|->
name|text
argument_list|)
expr_stmt|;
name|ex
operator|.
name|a_text
operator|=
name|hdr
operator|->
name|text
expr_stmt|;
name|hdr
operator|->
name|data
operator|=
name|N_ALIGN
argument_list|(
name|ex
argument_list|,
name|hdr
operator|->
name|data
argument_list|)
expr_stmt|;
name|ex
operator|.
name|a_data
operator|=
name|hdr
operator|->
name|data
expr_stmt|;
name|ex
operator|.
name|a_entry
operator|=
name|hdr
operator|->
name|entry
expr_stmt|;
name|writex
argument_list|(
name|fd
argument_list|,
operator|&
name|ex
argument_list|,
sizeof|sizeof
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|size
operator|=
name|N_ALIGN
argument_list|(
name|ex
argument_list|,
sizeof|sizeof
argument_list|(
name|ex
argument_list|)
argument_list|)
expr_stmt|;
name|seekx
argument_list|(
name|fd
argument_list|,
name|hdr
operator|->
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_ELF
case|:
name|eh
operator|=
name|elfhdr
expr_stmt|;
name|eh
operator|.
name|e
operator|.
name|e_entry
operator|=
name|hdr
operator|->
name|entry
expr_stmt|;
name|eh
operator|.
name|p
index|[
literal|0
index|]
operator|.
name|p_vaddr
operator|=
name|eh
operator|.
name|p
index|[
literal|0
index|]
operator|.
name|p_paddr
operator|=
name|hdr
operator|->
name|org
expr_stmt|;
name|eh
operator|.
name|p
index|[
literal|0
index|]
operator|.
name|p_filesz
operator|=
name|eh
operator|.
name|p
index|[
literal|0
index|]
operator|.
name|p_memsz
operator|=
name|hdr
operator|->
name|text
expr_stmt|;
name|eh
operator|.
name|p
index|[
literal|1
index|]
operator|.
name|p_offset
operator|=
name|eh
operator|.
name|p
index|[
literal|0
index|]
operator|.
name|p_offset
operator|+
name|eh
operator|.
name|p
index|[
literal|0
index|]
operator|.
name|p_filesz
expr_stmt|;
name|eh
operator|.
name|p
index|[
literal|1
index|]
operator|.
name|p_vaddr
operator|=
name|eh
operator|.
name|p
index|[
literal|1
index|]
operator|.
name|p_paddr
operator|=
name|align
argument_list|(
name|eh
operator|.
name|p
index|[
literal|0
index|]
operator|.
name|p_paddr
operator|+
name|eh
operator|.
name|p
index|[
literal|0
index|]
operator|.
name|p_memsz
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|eh
operator|.
name|p
index|[
literal|1
index|]
operator|.
name|p_filesz
operator|=
name|eh
operator|.
name|p
index|[
literal|1
index|]
operator|.
name|p_memsz
operator|=
name|hdr
operator|->
name|data
expr_stmt|;
name|eh
operator|.
name|sh
index|[
literal|2
index|]
operator|.
name|sh_addr
operator|=
name|eh
operator|.
name|p
index|[
literal|0
index|]
operator|.
name|p_vaddr
expr_stmt|;
name|eh
operator|.
name|sh
index|[
literal|2
index|]
operator|.
name|sh_offset
operator|=
name|eh
operator|.
name|p
index|[
literal|0
index|]
operator|.
name|p_offset
expr_stmt|;
name|eh
operator|.
name|sh
index|[
literal|2
index|]
operator|.
name|sh_size
operator|=
name|eh
operator|.
name|p
index|[
literal|0
index|]
operator|.
name|p_filesz
expr_stmt|;
name|eh
operator|.
name|sh
index|[
literal|3
index|]
operator|.
name|sh_addr
operator|=
name|eh
operator|.
name|p
index|[
literal|1
index|]
operator|.
name|p_vaddr
expr_stmt|;
name|eh
operator|.
name|sh
index|[
literal|3
index|]
operator|.
name|sh_offset
operator|=
name|eh
operator|.
name|p
index|[
literal|1
index|]
operator|.
name|p_offset
expr_stmt|;
name|eh
operator|.
name|sh
index|[
literal|3
index|]
operator|.
name|sh_size
operator|=
name|eh
operator|.
name|p
index|[
literal|1
index|]
operator|.
name|p_filesz
expr_stmt|;
name|writex
argument_list|(
name|fd
argument_list|,
operator|&
name|eh
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Safe copy from input file to output file.  */
end_comment

begin_function
specifier|static
name|void
name|copy
parameter_list|(
name|int
name|fdi
parameter_list|,
name|int
name|fdo
parameter_list|,
name|size_t
name|nbyte
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|size_t
name|n
decl_stmt|;
while|while
condition|(
name|nbyte
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|)
operator|>
name|nbyte
condition|)
name|n
operator|=
name|nbyte
expr_stmt|;
if|if
condition|(
name|readx
argument_list|(
name|fdi
argument_list|,
name|buf
argument_list|,
name|n
argument_list|,
name|offset
argument_list|)
operator|!=
name|n
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"%s: Short read"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|writex
argument_list|(
name|fdo
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|nbyte
operator|-=
name|n
expr_stmt|;
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Safe read from input file.  */
end_comment

begin_function
specifier|static
name|size_t
name|readx
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbyte
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|ssize_t
name|n
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
operator|&&
name|lseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|offset
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|nbyte
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Safe write to output file.  */
end_comment

begin_function
specifier|static
name|void
name|writex
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|nbyte
parameter_list|)
block|{
name|ssize_t
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|nbyte
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|nbyte
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"%s: Short write"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Safe seek in output file.  */
end_comment

begin_function
specifier|static
name|void
name|seekx
parameter_list|(
name|int
name|fd
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|offset
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert an option argument to a format code.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|optfmt
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|F_CNT
operator|&&
name|strcmp
argument_list|(
name|arg
argument_list|,
name|fmtlist
index|[
name|i
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
name|F_CNT
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: Unknown format"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an option argument to an address.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|optaddr
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|long
name|x
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|strtoul
argument_list|(
name|arg
argument_list|,
operator|&
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|!
operator|*
name|arg
operator|||
operator|*
name|s
operator|||
name|x
operator|>
name|MAXU32
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: Illegal address"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an option argument to a page number.  */
end_comment

begin_function
specifier|static
name|int
name|optpage
parameter_list|(
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|long
name|x
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|strtol
argument_list|(
name|arg
argument_list|,
operator|&
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|!
operator|*
name|arg
operator|||
operator|*
name|s
operator|||
name|x
operator|<
literal|0
operator|||
name|x
operator|>
name|hi
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: Illegal page number"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/*  * Display a warning.  */
end_comment

begin_function
specifier|static
name|void
name|Warn
parameter_list|(
specifier|const
name|char
modifier|*
name|locus
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|asprintf
argument_list|(
operator|&
name|s
argument_list|,
literal|"%s: Warning: %s"
argument_list|,
name|locus
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vwarnx
argument_list|(
name|s
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Display usage information.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n"
argument_list|,
literal|"usage: btxld [-qv] [-b file] [-E address] [-e address] [-f format]"
argument_list|,
literal|"             [-l file] [-o filename] [-P page] [-W page] file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

