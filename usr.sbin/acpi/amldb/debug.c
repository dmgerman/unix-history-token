begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Takanori Watanabe  * Copyright (c) 1999, 2000 Mitsuru IWASAKI<iwasaki@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: debug.c,v 1.19 2000/08/16 18:15:00 iwasaki Exp $  *	$FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_name.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_amlmem.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_status.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_env.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_obj.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_evalobj.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_parse.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_region.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_store.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_common.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_function
specifier|static
name|int
name|print_named_object
parameter_list|(
name|struct
name|aml_name
modifier|*
name|name
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|aml_print_curname
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* always return success to continue the search */
block|}
end_function

begin_function
name|void
name|aml_dbgr
parameter_list|(
name|struct
name|aml_environ
modifier|*
name|env1
parameter_list|,
name|struct
name|aml_environ
modifier|*
name|env2
parameter_list|)
block|{
define|#
directive|define
name|CMDBUFLEN
value|512
define|#
directive|define
name|ARGBUFLEN
value|512
specifier|static
name|char
name|lastcommand
index|[
name|CMDBUFLEN
index|]
decl_stmt|;
name|char
name|commandline
index|[
name|CMDBUFLEN
index|]
decl_stmt|;
name|char
name|argbuf
index|[
literal|7
index|]
index|[
name|ARGBUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|method
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|struct
name|aml_name
modifier|*
name|name
decl_stmt|;
name|union
name|aml_object
name|argv
index|[
literal|7
index|]
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|fputs
argument_list|(
literal|"AML>"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|commandline
argument_list|,
literal|512
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|commandline
index|[
literal|512
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* safety */
if|if
condition|(
name|feof
argument_list|(
name|stdin
argument_list|)
condition|)
block|{
name|commandline
index|[
literal|0
index|]
operator|=
literal|'q'
expr_stmt|;
block|}
if|if
condition|(
name|commandline
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
block|{
name|memcpy
argument_list|(
name|commandline
argument_list|,
name|lastcommand
argument_list|,
sizeof|sizeof
name|commandline
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|lastcommand
argument_list|,
name|commandline
argument_list|,
sizeof|sizeof
name|commandline
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|commandline
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'s'
case|:
if|if
condition|(
name|env2
operator|!=
name|NULL
condition|)
block|{
name|env2
operator|->
name|stat
operator|=
name|aml_stat_step
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'n'
case|:
name|env1
operator|->
name|stat
operator|=
name|aml_stat_step
expr_stmt|;
return|return;
case|case
literal|'c'
case|:
name|env1
operator|->
name|stat
operator|=
name|aml_stat_none
expr_stmt|;
return|return;
case|case
literal|'q'
case|:
name|env1
operator|->
name|stat
operator|=
name|aml_stat_panic
expr_stmt|;
return|return;
case|case
literal|'t'
case|:
comment|/* NULL terminate */
name|ptr
operator|=
operator|&
name|commandline
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|ptr
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
name|ptr
operator|++
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* move pointer to object name */
name|ptr
operator|=
operator|&
name|commandline
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
comment|/* show current tree if no argument */
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|aml_showtree
argument_list|(
name|env1
operator|->
name|curname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|show_variables
goto|;
block|}
comment|/* start from root? */
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|ptr
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|aml_showtree
argument_list|(
name|aml_get_rootname
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|show_variables
goto|;
block|}
if|if
condition|(
operator|(
name|name
operator|=
name|aml_find_from_namespace
argument_list|(
name|aml_get_rootname
argument_list|()
argument_list|,
name|ptr
argument_list|)
operator|)
condition|)
block|{
name|aml_showtree
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|show_variables
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|name
operator|=
name|aml_find_from_namespace
argument_list|(
name|env1
operator|->
name|curname
argument_list|,
name|ptr
argument_list|)
operator|)
condition|)
block|{
name|aml_showtree
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|show_variables
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|aml_name
modifier|*
name|tmp
init|=
name|aml_local_stack_getArgX
argument_list|(
name|NULL
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
operator|||
name|tmp
operator|->
name|property
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|printf
argument_list|(
literal|"  Arg%d    "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|aml_showobject
argument_list|(
name|tmp
operator|->
name|property
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|aml_name
modifier|*
name|tmp
init|=
name|aml_local_stack_getLocalX
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
operator|||
name|tmp
operator|->
name|property
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
name|printf
argument_list|(
literal|"  Local%d  "
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|aml_showobject
argument_list|(
name|tmp
operator|->
name|property
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
name|aml_debug_prompt_reginput
operator|=
operator|(
name|aml_debug_prompt_reginput
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|aml_debug_prompt_reginput
condition|)
name|fputs
argument_list|(
literal|"REGION INPUT ON\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"REGION INPUT OFF\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|aml_debug_prompt_regoutput
operator|=
operator|(
name|aml_debug_prompt_regoutput
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|aml_debug_prompt_regoutput
condition|)
name|fputs
argument_list|(
literal|"REGION OUTPUT ON\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|fputs
argument_list|(
literal|"REGION OUTPUT OFF\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|memman_statistics
argument_list|(
name|aml_memman
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* NULL terminate */
name|ptr
operator|=
operator|&
name|commandline
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|ptr
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
name|ptr
operator|++
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* move pointer to method name */
name|ptr
operator|=
operator|&
name|commandline
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
name|name
operator|=
name|aml_find_from_namespace
argument_list|(
name|aml_get_rootname
argument_list|()
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%d:aml_dbgr: not found name %s\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|name
operator|->
name|property
operator|==
name|NULL
operator|||
name|name
operator|->
name|property
operator|->
name|type
operator|!=
name|aml_t_method
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%d:aml_dbgr: not method %s\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
block|}
name|aml_showobject
argument_list|(
name|name
operator|->
name|property
argument_list|)
expr_stmt|;
name|method
operator|=
name|ptr
expr_stmt|;
name|argnum
operator|=
name|name
operator|->
name|property
operator|->
name|meth
operator|.
name|argnum
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|argnum
condition|)
block|{
name|fputs
argument_list|(
literal|"  Enter argument values "
literal|"(ex. number 1 / string foo). "
literal|"'q' to quit.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
comment|/* get and parse argument values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argnum
condition|;
name|i
operator|++
control|)
block|{
name|retry
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Arg%d ? "
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
name|argbuf
index|[
name|i
index|]
argument_list|,
name|ARGBUFLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|argbuf
index|[
name|i
index|]
index|[
name|ARGBUFLEN
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|argbuf
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'q'
condition|)
block|{
goto|goto
name|finish_execution
goto|;
block|}
if|if
condition|(
name|argbuf
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
block|{
goto|goto
name|retry
goto|;
block|}
comment|/* move pointer to the value */
name|ptr
operator|=
operator|&
name|argbuf
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|ptr
index|[
literal|0
index|]
operator|!=
literal|' '
operator|&&
name|ptr
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
block|{
goto|goto
name|retry
goto|;
block|}
switch|switch
condition|(
name|argbuf
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'n'
case|:
name|argv
index|[
name|i
index|]
operator|.
name|type
operator|=
name|aml_t_num
expr_stmt|;
name|np
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|ptr
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
block|{
name|argv
index|[
name|i
index|]
operator|.
name|num
operator|.
name|number
operator|=
name|strtoq
argument_list|(
name|ptr
argument_list|,
operator|&
name|ep
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|argv
index|[
name|i
index|]
operator|.
name|num
operator|.
name|number
operator|=
name|strtoq
argument_list|(
name|ptr
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|np
operator|==
name|ep
condition|)
block|{
name|fputs
argument_list|(
literal|"Wrong value for number.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
break|break;
case|case
literal|'s'
case|:
name|argv
index|[
name|i
index|]
operator|.
name|type
operator|=
name|aml_t_string
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|.
name|str
operator|.
name|needfree
operator|=
literal|0
expr_stmt|;
name|argv
index|[
name|i
index|]
operator|.
name|str
operator|.
name|string
operator|=
name|ptr
expr_stmt|;
comment|/* NULL ternimate */
while|while
condition|(
name|ptr
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
block|}
name|ptr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
default|default:
name|fputs
argument_list|(
literal|"Invalid data type "
literal|"(supports number or string only)\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
name|bzero
argument_list|(
name|lastcommand
argument_list|,
sizeof|sizeof
name|lastcommand
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"==== Running %s. ====\n"
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|aml_local_stack_push
argument_list|(
name|aml_local_stack_create
argument_list|()
argument_list|)
expr_stmt|;
name|retval
operator|=
name|aml_invoke_method_by_name
argument_list|(
name|method
argument_list|,
name|argnum
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|aml_showobject
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|aml_local_stack_delete
argument_list|(
name|aml_local_stack_pop
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"==== %s finished. ====\n"
argument_list|,
name|method
argument_list|)
expr_stmt|;
name|finish_execution
label|:
break|break;
case|case
literal|'f'
case|:
comment|/* NULL terminate */
name|ptr
operator|=
operator|&
name|commandline
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|ptr
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
name|ptr
operator|++
expr_stmt|;
name|ptr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* move pointer to object name */
name|ptr
operator|=
operator|&
name|commandline
index|[
literal|1
index|]
expr_stmt|;
while|while
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|' '
condition|)
name|ptr
operator|++
expr_stmt|;
name|aml_apply_foreach_found_objects
argument_list|(
name|aml_get_rootname
argument_list|()
argument_list|,
name|ptr
argument_list|,
name|print_named_object
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|fputs
argument_list|(
literal|"s	Single step\n"
literal|"n	Step program\n"
literal|"c	Continue program being debugged\n"
literal|"q	Quit method execution\n"
literal|"t	Show local name space tree and variables\n"
literal|"i	Toggle region input prompt\n"
literal|"o	Toggle region output prompt\n"
literal|"m	Show memory management statistics\n"
literal|"r	Run specified method\n"
literal|"f	Find named objects from namespace.\n"
literal|"h	Show this messsage\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

end_unit

