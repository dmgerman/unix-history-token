begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Takanori Watanabe  * Copyright (c) 1999, 2000 Yasuo Yokoyama  * Copyright (c) 1999, 2000 Mitsuru IWASAKI<iwasaki@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: aml_name.c,v 1.15 2000/08/16 18:14:53 iwasaki Exp $  *	$FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_amlmem.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_common.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_env.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpi/aml/aml_name.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_KERNEL */
end_comment

begin_function_decl
specifier|static
name|struct
name|aml_name
modifier|*
name|aml_find_name
parameter_list|(
name|struct
name|aml_name
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|aml_name
modifier|*
name|aml_new_name
parameter_list|(
name|struct
name|aml_name
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|aml_delete_name
parameter_list|(
name|struct
name|aml_name
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|aml_name
name|rootname
init|=
block|{
literal|"\\"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|aml_name_group
name|root_group
init|=
block|{
name|AML_NAME_GROUP_ROOT
block|,
operator|&
name|rootname
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|aml_name_group
modifier|*
name|name_group_list
init|=
operator|&
name|root_group
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|aml_local_stack
modifier|*
name|stack_top
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|aml_name
modifier|*
name|aml_get_rootname
parameter_list|()
block|{
return|return
operator|(
operator|&
name|rootname
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|aml_name
modifier|*
name|aml_find_name
parameter_list|(
name|struct
name|aml_name
modifier|*
name|parent
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|aml_name
modifier|*
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|parent
condition|)
name|parent
operator|=
operator|&
name|rootname
expr_stmt|;
for|for
control|(
name|result
operator|=
name|parent
operator|->
name|child
init|;
name|result
condition|;
name|result
operator|=
name|result
operator|->
name|brother
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|result
operator|->
name|name
argument_list|,
name|name
argument_list|,
literal|4
argument_list|)
condition|)
break|break;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse given namesppace expression and find a first matched object  * under given level of the tree by depth first search.  */
end_comment

begin_function
name|struct
name|aml_name
modifier|*
name|aml_find_from_namespace
parameter_list|(
name|struct
name|aml_name
modifier|*
name|parent
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|aml_name
modifier|*
name|result
decl_stmt|;
name|ptr
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|!
name|parent
condition|)
name|parent
operator|=
operator|&
name|rootname
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
name|parent
operator|=
operator|&
name|rootname
expr_stmt|;
block|}
for|for
control|(
name|len
operator|=
literal|0
init|;
name|ptr
index|[
name|len
index|]
operator|!=
literal|'.'
operator|&&
name|ptr
index|[
name|len
index|]
operator|!=
literal|'\0'
condition|;
name|len
operator|++
control|)
empty_stmt|;
for|for
control|(
name|result
operator|=
name|parent
operator|->
name|child
init|;
name|result
condition|;
name|result
operator|=
name|result
operator|->
name|brother
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|result
operator|->
name|name
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|ptr
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
name|ptr
index|[
name|len
operator|+
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|(
name|result
operator|)
return|;
block|}
name|ptr
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|ptr
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ptr
operator|++
expr_stmt|;
return|return
operator|(
name|aml_find_from_namespace
argument_list|(
name|result
argument_list|,
name|ptr
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_aml_apply_foreach_found_objects
parameter_list|(
name|struct
name|aml_name
modifier|*
name|parent
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|shallow
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|aml_name
modifier|*
parameter_list|,
name|va_list
parameter_list|)
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|struct
name|aml_name
modifier|*
name|child
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|child
operator|=
name|ptr
operator|=
name|NULL
expr_stmt|;
comment|/* function to apply must be specified */
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
for|for
control|(
name|child
operator|=
name|parent
operator|->
name|child
init|;
name|child
condition|;
name|child
operator|=
name|child
operator|->
name|brother
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|child
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|/* if function call was failed, stop searching */
if|if
condition|(
name|func
argument_list|(
name|child
argument_list|,
name|ap
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
block|}
block|}
if|if
condition|(
name|shallow
operator|==
literal|1
condition|)
block|{
return|return;
block|}
for|for
control|(
name|ptr
operator|=
name|parent
operator|->
name|child
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|brother
control|)
block|{
comment|/* do more searching */
name|_aml_apply_foreach_found_objects
argument_list|(
name|ptr
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|func
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find named objects as many as possible under given level of  * namespace, and apply given callback function for each  * named objects found.  If the callback function returns non-zero  * value, then the search terminates immediately.  * Note that object name expression is used as forward substring match,  * not exact match.  The name expression "_L" will match for objects  * which have name starting with "_L" such as "\_SB_.LID_._LID" and  * "\_GPE._L00" and so on. The name expression can include parent object  * name in it like "\_GPE._L".  In this case, GPE X level wake handlers  * will be found under "\_GPE" in shallow level.  */
end_comment

begin_function
name|void
name|aml_apply_foreach_found_objects
parameter_list|(
name|struct
name|aml_name
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|aml_name
modifier|*
parameter_list|,
name|va_list
parameter_list|)
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|has_dot
decl_stmt|,
name|last_is_dot
decl_stmt|,
name|shallow
decl_stmt|;
name|struct
name|aml_name
modifier|*
name|child
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|shallow
operator|=
literal|0
expr_stmt|;
name|parent
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
name|name
operator|++
expr_stmt|;
name|parent
operator|=
operator|&
name|rootname
expr_stmt|;
name|shallow
operator|=
literal|1
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|last_is_dot
operator|=
literal|0
expr_stmt|;
comment|/* the last dot should be ignored */
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|last_is_dot
operator|=
literal|1
expr_stmt|;
block|}
name|has_dot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
name|has_dot
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* try to parse expression and find any matched object. */
if|if
condition|(
name|has_dot
operator|==
literal|1
condition|)
block|{
name|child
operator|=
name|aml_find_from_namespace
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* 		 * we have at least one object matched, search all objects 		 * under upper level of the found object. 		 */
name|parent
operator|=
name|child
operator|->
name|parent
expr_stmt|;
comment|/* find the last `.' */
for|for
control|(
name|name
operator|=
name|name
operator|+
name|len
operator|-
literal|1
init|;
operator|*
name|name
operator|!=
literal|'.'
condition|;
name|name
operator|--
control|)
empty_stmt|;
name|name
operator|++
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|last_is_dot
expr_stmt|;
name|shallow
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|4
condition|)
block|{
return|return;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|_aml_apply_foreach_found_objects
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|shallow
argument_list|,
name|func
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|aml_name_group
modifier|*
name|aml_new_name_group
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|struct
name|aml_name_group
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|memman_alloc
argument_list|(
name|aml_memman
argument_list|,
name|memid_aml_name_group
argument_list|)
expr_stmt|;
name|result
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|result
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|next
operator|=
name|name_group_list
expr_stmt|;
name|name_group_list
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|aml_delete_name_group
parameter_list|(
name|struct
name|aml_name_group
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|aml_name_group
modifier|*
name|previous
decl_stmt|;
name|previous
operator|=
name|name_group_list
expr_stmt|;
if|if
condition|(
name|previous
operator|==
name|target
condition|)
name|name_group_list
operator|=
name|target
operator|->
name|next
expr_stmt|;
else|else
block|{
while|while
condition|(
name|previous
operator|&&
name|previous
operator|->
name|next
operator|!=
name|target
condition|)
name|previous
operator|=
name|previous
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|previous
condition|)
name|previous
operator|->
name|next
operator|=
name|target
operator|->
name|next
expr_stmt|;
block|}
name|target
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|head
condition|)
name|aml_delete_name
argument_list|(
name|target
operator|->
name|head
argument_list|)
expr_stmt|;
name|memman_free
argument_list|(
name|aml_memman
argument_list|,
name|memid_aml_name_group
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|aml_name
modifier|*
name|aml_new_name
parameter_list|(
name|struct
name|aml_name
modifier|*
name|parent
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|aml_name
modifier|*
name|newname
decl_stmt|;
if|if
condition|(
operator|(
name|newname
operator|=
name|aml_find_name
argument_list|(
name|parent
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|newname
operator|)
return|;
name|newname
operator|=
name|memman_alloc
argument_list|(
name|aml_memman
argument_list|,
name|memid_aml_name
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|newname
operator|->
name|name
argument_list|,
name|name
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|newname
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|newname
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
name|newname
operator|->
name|property
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|parent
operator|->
name|child
condition|)
name|newname
operator|->
name|brother
operator|=
name|parent
operator|->
name|child
expr_stmt|;
else|else
name|newname
operator|->
name|brother
operator|=
name|NULL
expr_stmt|;
name|parent
operator|->
name|child
operator|=
name|newname
expr_stmt|;
name|newname
operator|->
name|chain
operator|=
name|name_group_list
operator|->
name|head
expr_stmt|;
name|name_group_list
operator|->
name|head
operator|=
name|newname
expr_stmt|;
return|return
operator|(
name|newname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE:  * aml_delete_name() doesn't maintain aml_name_group::{head,tail}.  */
end_comment

begin_function
specifier|static
name|void
name|aml_delete_name
parameter_list|(
name|struct
name|aml_name
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|aml_name
modifier|*
name|next
decl_stmt|;
name|struct
name|aml_name
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
init|;
name|target
condition|;
name|target
operator|=
name|next
control|)
block|{
name|next
operator|=
name|target
operator|->
name|chain
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|child
condition|)
block|{
name|target
operator|->
name|chain
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|target
operator|->
name|brother
condition|)
block|{
if|if
condition|(
name|target
operator|->
name|parent
condition|)
block|{
if|if
condition|(
name|target
operator|->
name|parent
operator|->
name|child
operator|==
name|target
condition|)
block|{
name|target
operator|->
name|parent
operator|->
name|child
operator|=
name|target
operator|->
name|brother
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
name|target
operator|->
name|parent
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|ptr
operator|&&
name|ptr
operator|->
name|brother
operator|!=
name|target
condition|)
name|ptr
operator|=
name|ptr
operator|->
name|brother
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|ptr
operator|->
name|brother
operator|=
name|target
operator|->
name|brother
expr_stmt|;
block|}
name|target
operator|->
name|brother
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|target
operator|->
name|parent
condition|)
block|{
name|target
operator|->
name|parent
operator|->
name|child
operator|=
name|NULL
expr_stmt|;
block|}
name|aml_free_object
argument_list|(
operator|&
name|target
operator|->
name|property
argument_list|)
expr_stmt|;
name|memman_free
argument_list|(
name|aml_memman
argument_list|,
name|memid_aml_name
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|AML_SEARCH_NAME
value|0
end_define

begin_define
define|#
directive|define
name|AML_CREATE_NAME
value|1
end_define

begin_function_decl
specifier|static
name|struct
name|aml_name
modifier|*
name|aml_nameman
parameter_list|(
name|struct
name|aml_environ
modifier|*
parameter_list|,
name|u_int8_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|aml_name
modifier|*
name|aml_search_name
parameter_list|(
name|struct
name|aml_environ
modifier|*
name|env
parameter_list|,
name|u_int8_t
modifier|*
name|dp
parameter_list|)
block|{
return|return
operator|(
name|aml_nameman
argument_list|(
name|env
argument_list|,
name|dp
argument_list|,
name|AML_SEARCH_NAME
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|aml_name
modifier|*
name|aml_create_name
parameter_list|(
name|struct
name|aml_environ
modifier|*
name|env
parameter_list|,
name|u_int8_t
modifier|*
name|dp
parameter_list|)
block|{
return|return
operator|(
name|aml_nameman
argument_list|(
name|env
argument_list|,
name|dp
argument_list|,
name|AML_CREATE_NAME
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|aml_name
modifier|*
name|aml_nameman
parameter_list|(
name|struct
name|aml_environ
modifier|*
name|env
parameter_list|,
name|u_int8_t
modifier|*
name|dp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|segcount
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|aml_name
modifier|*
name|newname
decl_stmt|,
modifier|*
name|curname
decl_stmt|;
name|struct
name|aml_name
modifier|*
argument_list|(
operator|*
name|searchfunc
argument_list|)
argument_list|(
expr|struct
name|aml_name
operator|*
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
define|#
directive|define
name|CREATECHECK
parameter_list|()
value|do {						\ 	if (newname == NULL) {						\ 		AML_DEBUGPRINT("ERROR CANNOT FIND NAME\n");		\ 		env->stat = aml_stat_panic;				\ 		return (NULL);						\ 	}								\ } while(0)
name|searchfunc
operator|=
operator|(
name|flag
operator|==
name|AML_CREATE_NAME
operator|)
condition|?
name|aml_new_name
else|:
name|aml_find_name
expr_stmt|;
name|newname
operator|=
name|env
operator|->
name|curname
expr_stmt|;
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
name|newname
operator|=
operator|&
name|rootname
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|'^'
condition|)
block|{
while|while
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|'^'
condition|)
block|{
name|newname
operator|=
name|newname
operator|->
name|parent
expr_stmt|;
name|CREATECHECK
argument_list|()
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|0x00
condition|)
block|{
comment|/* NullName */
name|dp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|0x2e
condition|)
block|{
comment|/* DualNamePrefix */
name|newname
operator|=
call|(
modifier|*
name|searchfunc
call|)
argument_list|(
name|newname
argument_list|,
name|dp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|CREATECHECK
argument_list|()
expr_stmt|;
name|newname
operator|=
call|(
modifier|*
name|searchfunc
call|)
argument_list|(
name|newname
argument_list|,
name|dp
operator|+
literal|5
argument_list|)
expr_stmt|;
name|CREATECHECK
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
index|[
literal|0
index|]
operator|==
literal|0x2f
condition|)
block|{
comment|/* MultiNamePrefix */
name|segcount
operator|=
name|dp
index|[
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dp
operator|+=
literal|2
init|;
name|i
operator|<
name|segcount
condition|;
name|i
operator|++
operator|,
name|dp
operator|+=
literal|4
control|)
block|{
name|newname
operator|=
call|(
modifier|*
name|searchfunc
call|)
argument_list|(
name|newname
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|CREATECHECK
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|flag
operator|==
name|AML_CREATE_NAME
condition|)
block|{
comment|/* NameSeg */
name|newname
operator|=
name|aml_new_name
argument_list|(
name|newname
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|CREATECHECK
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|curname
operator|=
name|newname
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|newname
operator|=
name|aml_find_name
argument_list|(
name|curname
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newname
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
name|curname
operator|==
operator|&
name|rootname
condition|)
break|break;
name|curname
operator|=
name|curname
operator|->
name|parent
expr_stmt|;
block|}
block|}
return|return
operator|(
name|newname
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|CREATECHECK
end_undef

begin_function
name|struct
name|aml_local_stack
modifier|*
name|aml_local_stack_create
parameter_list|()
block|{
name|struct
name|aml_local_stack
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|memman_alloc
argument_list|(
name|aml_memman
argument_list|,
name|memid_aml_local_stack
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aml_local_stack
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|aml_local_stack_push
parameter_list|(
name|struct
name|aml_local_stack
modifier|*
name|stack
parameter_list|)
block|{
name|stack
operator|->
name|next
operator|=
name|stack_top
expr_stmt|;
name|stack_top
operator|=
name|stack
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|aml_local_stack
modifier|*
name|aml_local_stack_pop
parameter_list|()
block|{
name|struct
name|aml_local_stack
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|stack_top
expr_stmt|;
name|stack_top
operator|=
name|result
operator|->
name|next
expr_stmt|;
name|result
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|aml_local_stack_delete
parameter_list|(
name|struct
name|aml_local_stack
modifier|*
name|stack
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|aml_free_object
argument_list|(
operator|&
name|stack
operator|->
name|localvalue
index|[
name|i
index|]
operator|.
name|property
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|aml_free_object
argument_list|(
operator|&
name|stack
operator|->
name|argumentvalue
index|[
name|i
index|]
operator|.
name|property
argument_list|)
expr_stmt|;
name|aml_delete_name
argument_list|(
name|stack
operator|->
name|temporary
argument_list|)
expr_stmt|;
name|memman_free
argument_list|(
name|aml_memman
argument_list|,
name|memid_aml_local_stack
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|aml_name
modifier|*
name|aml_local_stack_getLocalX
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|stack_top
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|stack_top
operator|->
name|localvalue
index|[
name|index
index|]
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|aml_name
modifier|*
name|aml_local_stack_getArgX
parameter_list|(
name|struct
name|aml_local_stack
modifier|*
name|stack
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
operator|!
name|stack
condition|)
name|stack
operator|=
name|stack_top
expr_stmt|;
if|if
condition|(
name|stack
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|&
name|stack
operator|->
name|argumentvalue
index|[
name|index
index|]
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|aml_name
modifier|*
name|aml_create_local_object
parameter_list|()
block|{
name|struct
name|aml_name
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|memman_alloc
argument_list|(
name|aml_memman
argument_list|,
name|memid_aml_name
argument_list|)
expr_stmt|;
name|result
operator|->
name|child
operator|=
name|result
operator|->
name|brother
operator|=
name|result
operator|->
name|parent
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|property
operator|=
name|NULL
expr_stmt|;
name|result
operator|->
name|chain
operator|=
name|stack_top
operator|->
name|temporary
expr_stmt|;
name|stack_top
operator|->
name|temporary
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

end_unit

