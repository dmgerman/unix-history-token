begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Robert Elz at The University of Melbourne.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static const char copyright[] = "@(#) Copyright (c) 1980, 1990, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char sccsid[] = "@(#)edquota.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Disk quota editor.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fstab.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/* Let's be paranoid about block size */
end_comment

begin_if
if|#
directive|if
literal|10
operator|>
name|DEV_BSHIFT
end_if

begin_define
define|#
directive|define
name|dbtokb
parameter_list|(
name|db
parameter_list|)
define|\
value|((off_t)(db)>> (10-DEV_BSHIFT))
end_define

begin_elif
elif|#
directive|elif
literal|10
operator|<
name|DEV_BSHIFT
end_elif

begin_define
define|#
directive|define
name|dbtokb
parameter_list|(
name|db
parameter_list|)
define|\
value|((off_t)(db)<< (DEV_BSHIFT-10))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dbtokb
parameter_list|(
name|db
parameter_list|)
value|(db)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|const
name|char
modifier|*
name|qfextension
index|[]
init|=
name|INITQFNAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tmpfil
index|[]
init|=
name|_PATH_TMP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|hflag
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|quotause
block|{
name|struct
name|quotause
modifier|*
name|next
decl_stmt|;
name|struct
name|quotafile
modifier|*
name|qf
decl_stmt|;
name|struct
name|dqblk
name|dqblk
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
name|fsname
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FOUND
value|0x01
end_define

begin_function_decl
name|int
name|alldigits
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cvtatos
parameter_list|(
name|uint64_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|uint64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|cvtstoa
parameter_list|(
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint64_t
name|cvtblkval
parameter_list|(
name|uint64_t
parameter_list|,
name|char
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint64_t
name|cvtinoval
parameter_list|(
name|uint64_t
parameter_list|,
name|char
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|editit
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|fmthumanvalblks
parameter_list|(
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|fmthumanvalinos
parameter_list|(
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|freeprivs
parameter_list|(
name|struct
name|quotause
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|getentry
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|quotause
modifier|*
name|getprivs
parameter_list|(
name|long
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|putprivs
parameter_list|(
name|long
parameter_list|,
name|struct
name|quotause
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|readprivs
parameter_list|(
name|struct
name|quotause
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|readtimes
parameter_list|(
name|struct
name|quotause
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|writetimes
parameter_list|(
name|struct
name|quotause
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|writeprivs
parameter_list|(
name|struct
name|quotause
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|,
modifier|*
name|protoprivs
decl_stmt|,
modifier|*
name|curprivs
decl_stmt|;
name|long
name|id
decl_stmt|,
name|protoid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|quotatype
decl_stmt|,
name|range
decl_stmt|,
name|tmpfd
decl_stmt|;
name|uid_t
name|startuid
decl_stmt|,
name|enduid
decl_stmt|;
name|uint64_t
name|lim
decl_stmt|;
name|char
modifier|*
name|protoname
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|endpt
decl_stmt|,
modifier|*
name|oldoptarg
decl_stmt|;
name|int
name|eflag
init|=
literal|0
decl_stmt|,
name|tflag
init|=
literal|0
decl_stmt|,
name|pflag
init|=
literal|0
decl_stmt|,
name|ch
decl_stmt|;
name|char
modifier|*
name|fspath
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|MAXLOGNAME
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"permission denied"
argument_list|)
expr_stmt|;
name|quotatype
operator|=
name|USRQUOTA
expr_stmt|;
name|protoprivs
operator|=
name|NULL
expr_stmt|;
name|curprivs
operator|=
name|NULL
expr_stmt|;
name|protoname
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ughtf:p:e:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
name|fspath
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|eflag
condition|)
block|{
name|warnx
argument_list|(
literal|"cannot specify both -e and -p"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* not reached */
block|}
name|protoname
operator|=
name|optarg
expr_stmt|;
name|pflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|quotatype
operator|=
name|GRPQUOTA
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|hflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|quotatype
operator|=
name|USRQUOTA
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|pflag
condition|)
block|{
name|warnx
argument_list|(
literal|"cannot specify both -e and -p"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* not reached */
block|}
if|if
condition|(
operator|(
name|qup
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qup
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|oldoptarg
operator|=
name|optarg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cp
operator|=
name|optarg
init|;
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|optarg
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cp
operator|!=
name|oldoptarg
condition|)
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|=
literal|':'
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"incorrect quota specification: "
literal|"%s"
argument_list|,
name|oldoptarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* Not Reached */
block|}
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|strlcpy
argument_list|(
name|qup
operator|->
name|fsname
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|qup
operator|->
name|fsname
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|lim
operator|=
name|strtoll
argument_list|(
name|cp
argument_list|,
operator|&
name|endpt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|=
name|cvtblkval
argument_list|(
name|lim
argument_list|,
operator|*
name|endpt
argument_list|,
literal|"block soft limit"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|2
case|:
name|lim
operator|=
name|strtoll
argument_list|(
name|cp
argument_list|,
operator|&
name|endpt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bhardlimit
operator|=
name|cvtblkval
argument_list|(
name|lim
argument_list|,
operator|*
name|endpt
argument_list|,
literal|"block hard limit"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|3
case|:
name|lim
operator|=
name|strtoll
argument_list|(
name|cp
argument_list|,
operator|&
name|endpt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
operator|=
name|cvtinoval
argument_list|(
name|lim
argument_list|,
operator|*
name|endpt
argument_list|,
literal|"inode soft limit"
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|4
case|:
name|lim
operator|=
name|strtoll
argument_list|(
name|cp
argument_list|,
operator|&
name|endpt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_ihardlimit
operator|=
name|cvtinoval
argument_list|(
name|lim
argument_list|,
operator|*
name|endpt
argument_list|,
literal|"inode hard limit"
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|warnx
argument_list|(
literal|"incorrect quota specification: "
literal|"%s"
argument_list|,
name|oldoptarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
comment|/* Not Reached */
block|}
block|}
if|if
condition|(
name|protoprivs
operator|==
name|NULL
condition|)
block|{
name|protoprivs
operator|=
name|curprivs
operator|=
name|qup
expr_stmt|;
block|}
else|else
block|{
name|curprivs
operator|->
name|next
operator|=
name|qup
expr_stmt|;
name|curprivs
operator|=
name|qup
expr_stmt|;
block|}
name|eflag
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* Not Reached */
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|pflag
operator|||
name|eflag
condition|)
block|{
if|if
condition|(
name|pflag
condition|)
block|{
if|if
condition|(
operator|(
name|protoid
operator|=
name|getentry
argument_list|(
name|protoname
argument_list|,
name|quotatype
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|protoprivs
operator|=
name|getprivs
argument_list|(
name|protoid
argument_list|,
name|quotatype
argument_list|,
name|fspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|protoprivs
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|qup
operator|=
name|protoprivs
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|argc
operator|--
operator|>
literal|0
condition|;
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|strspn
argument_list|(
operator|*
name|argv
argument_list|,
literal|"0123456789-"
argument_list|)
operator|==
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
operator|*
name|argv
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|startuid
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|enduid
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|enduid
operator|<
name|startuid
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"ending uid (%d) must be>= starting uid (%d) when using uid ranges"
argument_list|,
name|enduid
argument_list|,
name|startuid
argument_list|)
expr_stmt|;
name|range
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|startuid
operator|=
name|enduid
operator|=
literal|0
expr_stmt|;
name|range
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|startuid
operator|<=
name|enduid
condition|;
name|startuid
operator|++
control|)
block|{
if|if
condition|(
name|range
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|startuid
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|getentry
argument_list|(
name|buf
argument_list|,
name|quotatype
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pflag
condition|)
block|{
name|putprivs
argument_list|(
name|id
argument_list|,
name|protoprivs
argument_list|)
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|qup
operator|=
name|protoprivs
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
name|curprivs
operator|=
name|getprivs
argument_list|(
name|id
argument_list|,
name|quotatype
argument_list|,
name|qup
operator|->
name|fsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|curprivs
operator|==
name|NULL
condition|)
continue|continue;
name|curprivs
operator|->
name|dqblk
operator|=
name|qup
operator|->
name|dqblk
expr_stmt|;
name|putprivs
argument_list|(
name|id
argument_list|,
name|curprivs
argument_list|)
expr_stmt|;
name|freeprivs
argument_list|(
name|curprivs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|pflag
condition|)
name|freeprivs
argument_list|(
name|protoprivs
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|tmpfd
operator|=
name|mkstemp
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|fchown
argument_list|(
name|tmpfd
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tflag
condition|)
block|{
if|if
condition|(
operator|(
name|protoprivs
operator|=
name|getprivs
argument_list|(
literal|0
argument_list|,
name|quotatype
argument_list|,
name|fspath
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|writetimes
argument_list|(
name|protoprivs
argument_list|,
name|tmpfd
argument_list|,
name|quotatype
argument_list|)
operator|!=
literal|0
operator|&&
name|editit
argument_list|(
name|tmpfil
argument_list|)
operator|&&
name|readtimes
argument_list|(
name|protoprivs
argument_list|,
name|tmpfil
argument_list|)
condition|)
name|putprivs
argument_list|(
literal|0L
argument_list|,
name|protoprivs
argument_list|)
expr_stmt|;
name|freeprivs
argument_list|(
name|protoprivs
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|id
operator|=
name|getentry
argument_list|(
operator|*
name|argv
argument_list|,
name|quotatype
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|(
name|curprivs
operator|=
name|getprivs
argument_list|(
name|id
argument_list|,
name|quotatype
argument_list|,
name|fspath
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeprivs
argument_list|(
name|curprivs
argument_list|,
name|tmpfd
argument_list|,
operator|*
name|argv
argument_list|,
name|quotatype
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|editit
argument_list|(
name|tmpfil
argument_list|)
operator|&&
name|readprivs
argument_list|(
name|curprivs
argument_list|,
name|tmpfil
argument_list|)
condition|)
name|putprivs
argument_list|(
name|id
argument_list|,
name|curprivs
argument_list|)
expr_stmt|;
name|freeprivs
argument_list|(
name|curprivs
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n"
argument_list|,
literal|"usage: edquota [-uh] [-f fspath] [-p username] username ..."
argument_list|,
literal|"       edquota [-u] -e fspath[:bslim[:bhlim[:islim[:ihlim]]]] [-e ...]"
argument_list|,
literal|"               username ..."
argument_list|,
literal|"       edquota -g [-h] [-f fspath] [-p groupname] groupname ..."
argument_list|,
literal|"       edquota -g -e fspath[:bslim[:bhlim[:islim[:ihlim]]]] [-e ...]"
argument_list|,
literal|"               groupname ..."
argument_list|,
literal|"       edquota [-u] -t [-f fspath]"
argument_list|,
literal|"       edquota -g -t [-f fspath]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine converts a name for a particular quota type to  * an identifier. This routine must agree with the kernel routine  * getinoquota as to the interpretation of quota types.  */
end_comment

begin_function
name|int
name|getentry
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|quotatype
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
if|if
condition|(
name|alldigits
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|atoi
argument_list|(
name|name
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|quotatype
condition|)
block|{
case|case
name|USRQUOTA
case|:
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
condition|)
return|return
operator|(
name|pw
operator|->
name|pw_uid
operator|)
return|;
name|warnx
argument_list|(
literal|"%s: no such user"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
name|GRPQUOTA
case|:
if|if
condition|(
operator|(
name|gr
operator|=
name|getgrnam
argument_list|(
name|name
argument_list|)
operator|)
condition|)
return|return
operator|(
name|gr
operator|->
name|gr_gid
operator|)
return|;
name|warnx
argument_list|(
literal|"%s: no such group"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"%d: unknown quota type"
argument_list|,
name|quotatype
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
break|break;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Collect the requested quota information.  */
end_comment

begin_function
name|struct
name|quotause
modifier|*
name|getprivs
parameter_list|(
name|long
name|id
parameter_list|,
name|int
name|quotatype
parameter_list|,
name|char
modifier|*
name|fspath
parameter_list|)
block|{
name|struct
name|quotafile
modifier|*
name|qf
decl_stmt|;
name|struct
name|fstab
modifier|*
name|fs
decl_stmt|;
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|,
modifier|*
name|quptail
decl_stmt|;
name|struct
name|quotause
modifier|*
name|quphead
decl_stmt|;
name|setfsent
argument_list|()
expr_stmt|;
name|quphead
operator|=
name|quptail
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|fs
operator|=
name|getfsent
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|fspath
operator|&&
operator|*
name|fspath
operator|&&
name|strcmp
argument_list|(
name|fspath
argument_list|,
name|fs
operator|->
name|fs_spec
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|fspath
argument_list|,
name|fs
operator|->
name|fs_file
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|fs
operator|->
name|fs_vfstype
argument_list|,
literal|"ufs"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|qf
operator|=
name|quota_open
argument_list|(
name|fs
argument_list|,
name|quotatype
argument_list|,
name|O_CREAT
operator||
name|O_RDWR
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EOPNOTSUPP
condition|)
name|warn
argument_list|(
literal|"cannot open quotas on %s"
argument_list|,
name|fs
operator|->
name|fs_file
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|qup
operator|=
operator|(
expr|struct
name|quotause
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qup
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|qup
operator|->
name|qf
operator|=
name|qf
expr_stmt|;
name|strncpy
argument_list|(
name|qup
operator|->
name|fsname
argument_list|,
name|fs
operator|->
name|fs_file
argument_list|,
sizeof|sizeof
argument_list|(
name|qup
operator|->
name|fsname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|quota_read
argument_list|(
name|qf
argument_list|,
operator|&
name|qup
operator|->
name|dqblk
argument_list|,
name|id
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"cannot read quotas on %s"
argument_list|,
name|fs
operator|->
name|fs_file
argument_list|)
expr_stmt|;
name|freeprivs
argument_list|(
name|qup
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|quphead
operator|==
name|NULL
condition|)
name|quphead
operator|=
name|qup
expr_stmt|;
else|else
name|quptail
operator|->
name|next
operator|=
name|qup
expr_stmt|;
name|quptail
operator|=
name|qup
expr_stmt|;
name|qup
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|quphead
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"No quotas on %s"
argument_list|,
name|fspath
condition|?
name|fspath
else|:
literal|"any filesystems"
argument_list|)
expr_stmt|;
block|}
name|endfsent
argument_list|()
expr_stmt|;
return|return
operator|(
name|quphead
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Store the requested quota information.  */
end_comment

begin_function
name|void
name|putprivs
parameter_list|(
name|long
name|id
parameter_list|,
name|struct
name|quotause
modifier|*
name|quplist
parameter_list|)
block|{
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
if|if
condition|(
name|quota_write_limits
argument_list|(
name|qup
operator|->
name|qf
argument_list|,
operator|&
name|qup
operator|->
name|dqblk
argument_list|,
name|id
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|qup
operator|->
name|fsname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take a list of priviledges and get it edited.  */
end_comment

begin_function
name|int
name|editit
parameter_list|(
name|char
modifier|*
name|tmpf
parameter_list|)
block|{
name|long
name|omask
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|status
decl_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGQUIT
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGHUP
argument_list|)
argument_list|)
expr_stmt|;
name|top
label|:
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPROCLIM
condition|)
block|{
name|warnx
argument_list|(
literal|"you have too many processes"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|warn
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|ed
decl_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ed
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|ed
operator|=
name|_PATH_VI
expr_stmt|;
name|execlp
argument_list|(
name|ed
argument_list|,
name|ed
argument_list|,
name|tmpf
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ed
argument_list|)
expr_stmt|;
block|}
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a quotause list to an ASCII file.  */
end_comment

begin_function
name|int
name|writeprivs
parameter_list|(
name|struct
name|quotause
modifier|*
name|quplist
parameter_list|,
name|int
name|outfd
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|quotatype
parameter_list|)
block|{
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|ftruncate
argument_list|(
name|outfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|outfd
argument_list|,
literal|0
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fdopen
argument_list|(
name|dup
argument_list|(
name|outfd
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|tmpfil
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Quotas for %s %s:\n"
argument_list|,
name|qfextension
index|[
name|quotatype
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s: in use: %s, "
argument_list|,
name|qup
operator|->
name|fsname
argument_list|,
name|fmthumanvalblks
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curblocks
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"limits (soft = %s, "
argument_list|,
name|fmthumanvalblks
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"hard = %s)\n"
argument_list|,
name|fmthumanvalblks
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bhardlimit
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"\tinodes in use: %s, "
argument_list|,
name|fmthumanvalinos
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curinodes
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"limits (soft = %s, "
argument_list|,
name|fmthumanvalinos
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"hard = %s)\n"
argument_list|,
name|fmthumanvalinos
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_ihardlimit
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|fmthumanvalblks
parameter_list|(
name|int64_t
name|blocks
parameter_list|)
block|{
specifier|static
name|char
name|numbuf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|hflag
condition|)
block|{
name|humanize_number
argument_list|(
name|numbuf
argument_list|,
name|blocks
operator|<
literal|0
condition|?
literal|7
else|:
literal|6
argument_list|,
name|dbtob
argument_list|(
name|blocks
argument_list|)
argument_list|,
literal|""
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_NOSPACE
argument_list|)
expr_stmt|;
return|return
operator|(
name|numbuf
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|numbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|numbuf
argument_list|)
argument_list|,
literal|"%juk"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dbtokb
argument_list|(
name|blocks
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|numbuf
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|fmthumanvalinos
parameter_list|(
name|int64_t
name|inos
parameter_list|)
block|{
specifier|static
name|char
name|numbuf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|hflag
condition|)
block|{
name|humanize_number
argument_list|(
name|numbuf
argument_list|,
name|inos
operator|<
literal|0
condition|?
literal|7
else|:
literal|6
argument_list|,
name|inos
argument_list|,
literal|""
argument_list|,
name|HN_AUTOSCALE
argument_list|,
name|HN_NOSPACE
operator||
name|HN_DIVISOR_1000
argument_list|)
expr_stmt|;
return|return
operator|(
name|numbuf
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|numbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|numbuf
argument_list|)
argument_list|,
literal|"%ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|inos
argument_list|)
expr_stmt|;
return|return
operator|(
name|numbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Merge changes to an ASCII file into a quotause list.  */
end_comment

begin_function
name|int
name|readprivs
parameter_list|(
name|struct
name|quotause
modifier|*
name|quplist
parameter_list|,
name|char
modifier|*
name|inname
parameter_list|)
block|{
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|uintmax_t
name|hardlimit
decl_stmt|,
name|softlimit
decl_stmt|,
name|curitems
decl_stmt|;
name|char
name|hardunits
decl_stmt|,
name|softunits
decl_stmt|,
name|curitemunits
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|dqblk
name|dqblk
decl_stmt|;
name|char
modifier|*
name|fsp
decl_stmt|,
name|line1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|line2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|inname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't re-read temp file!!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Discard title line, then read pairs of lines to process. 	 */
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|line1
argument_list|,
sizeof|sizeof
argument_list|(
name|line1
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line1
argument_list|,
sizeof|sizeof
argument_list|(
name|line1
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
operator|&&
name|fgets
argument_list|(
name|line2
argument_list|,
sizeof|sizeof
argument_list|(
name|line2
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fsp
operator|=
name|strtok
argument_list|(
name|line1
argument_list|,
literal|" \t:"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: bad format"
argument_list|,
name|line1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: bad format"
argument_list|,
name|fsp
argument_list|,
operator|&
name|fsp
index|[
name|strlen
argument_list|(
name|fsp
argument_list|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cnt
operator|=
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|" in use: %ju%c, limits (soft = %ju%c, hard = %ju%c)"
argument_list|,
operator|&
name|curitems
argument_list|,
operator|&
name|curitemunits
argument_list|,
operator|&
name|softlimit
argument_list|,
operator|&
name|softunits
argument_list|,
operator|&
name|hardlimit
argument_list|,
operator|&
name|hardunits
argument_list|)
expr_stmt|;
comment|/* 		 * The next three check for old-style input formats. 		 */
if|if
condition|(
name|cnt
operator|!=
literal|6
condition|)
name|cnt
operator|=
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|" in use: %ju%c, limits (soft = %ju%c hard = %ju%c"
argument_list|,
operator|&
name|curitems
argument_list|,
operator|&
name|curitemunits
argument_list|,
operator|&
name|softlimit
argument_list|,
operator|&
name|softunits
argument_list|,
operator|&
name|hardlimit
argument_list|,
operator|&
name|hardunits
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|6
condition|)
name|cnt
operator|=
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|" in use: %ju%c, limits (soft = %ju%c hard = %ju%c)"
argument_list|,
operator|&
name|curitems
argument_list|,
operator|&
name|curitemunits
argument_list|,
operator|&
name|softlimit
argument_list|,
operator|&
name|softunits
argument_list|,
operator|&
name|hardlimit
argument_list|,
operator|&
name|hardunits
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|6
condition|)
name|cnt
operator|=
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|" in use: %ju%c, limits (soft = %ju%c, hard = %ju%c"
argument_list|,
operator|&
name|curitems
argument_list|,
operator|&
name|curitemunits
argument_list|,
operator|&
name|softlimit
argument_list|,
operator|&
name|softunits
argument_list|,
operator|&
name|hardlimit
argument_list|,
operator|&
name|hardunits
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|6
condition|)
block|{
name|warnx
argument_list|(
literal|"%s:%s: bad format"
argument_list|,
name|fsp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dqblk
operator|.
name|dqb_curblocks
operator|=
name|cvtblkval
argument_list|(
name|curitems
argument_list|,
name|curitemunits
argument_list|,
literal|"current block count"
argument_list|)
expr_stmt|;
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|=
name|cvtblkval
argument_list|(
name|softlimit
argument_list|,
name|softunits
argument_list|,
literal|"block soft limit"
argument_list|)
expr_stmt|;
name|dqblk
operator|.
name|dqb_bhardlimit
operator|=
name|cvtblkval
argument_list|(
name|hardlimit
argument_list|,
name|hardunits
argument_list|,
literal|"block hard limit"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strtok
argument_list|(
name|line2
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: bad format"
argument_list|,
name|fsp
argument_list|,
name|line2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cnt
operator|=
name|sscanf
argument_list|(
operator|&
name|cp
index|[
literal|7
index|]
argument_list|,
literal|" in use: %ju%c limits (soft = %ju%c, hard = %ju%c)"
argument_list|,
operator|&
name|curitems
argument_list|,
operator|&
name|curitemunits
argument_list|,
operator|&
name|softlimit
argument_list|,
operator|&
name|softunits
argument_list|,
operator|&
name|hardlimit
argument_list|,
operator|&
name|hardunits
argument_list|)
expr_stmt|;
comment|/* 		 * The next three check for old-style input formats. 		 */
if|if
condition|(
name|cnt
operator|!=
literal|6
condition|)
name|cnt
operator|=
name|sscanf
argument_list|(
operator|&
name|cp
index|[
literal|7
index|]
argument_list|,
literal|" in use: %ju%c limits (soft = %ju%c hard = %ju%c"
argument_list|,
operator|&
name|curitems
argument_list|,
operator|&
name|curitemunits
argument_list|,
operator|&
name|softlimit
argument_list|,
operator|&
name|softunits
argument_list|,
operator|&
name|hardlimit
argument_list|,
operator|&
name|hardunits
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|6
condition|)
name|cnt
operator|=
name|sscanf
argument_list|(
operator|&
name|cp
index|[
literal|7
index|]
argument_list|,
literal|" in use: %ju%c limits (soft = %ju%c hard = %ju%c)"
argument_list|,
operator|&
name|curitems
argument_list|,
operator|&
name|curitemunits
argument_list|,
operator|&
name|softlimit
argument_list|,
operator|&
name|softunits
argument_list|,
operator|&
name|hardlimit
argument_list|,
operator|&
name|hardunits
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|6
condition|)
name|cnt
operator|=
name|sscanf
argument_list|(
operator|&
name|cp
index|[
literal|7
index|]
argument_list|,
literal|" in use: %ju%c limits (soft = %ju%c, hard = %ju%c"
argument_list|,
operator|&
name|curitems
argument_list|,
operator|&
name|curitemunits
argument_list|,
operator|&
name|softlimit
argument_list|,
operator|&
name|softunits
argument_list|,
operator|&
name|hardlimit
argument_list|,
operator|&
name|hardunits
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|6
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: bad format cnt %d"
argument_list|,
name|fsp
argument_list|,
operator|&
name|cp
index|[
literal|7
index|]
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dqblk
operator|.
name|dqb_curinodes
operator|=
name|cvtinoval
argument_list|(
name|curitems
argument_list|,
name|curitemunits
argument_list|,
literal|"current inode count"
argument_list|)
expr_stmt|;
name|dqblk
operator|.
name|dqb_isoftlimit
operator|=
name|cvtinoval
argument_list|(
name|softlimit
argument_list|,
name|softunits
argument_list|,
literal|"inode soft limit"
argument_list|)
expr_stmt|;
name|dqblk
operator|.
name|dqb_ihardlimit
operator|=
name|cvtinoval
argument_list|(
name|hardlimit
argument_list|,
name|hardunits
argument_list|,
literal|"inode hard limit"
argument_list|)
expr_stmt|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fsp
argument_list|,
name|qup
operator|->
name|fsname
argument_list|)
condition|)
continue|continue;
comment|/* 			 * Cause time limit to be reset when the quota 			 * is next used if previously had no soft limit 			 * or were under it, but now have a soft limit 			 * and are over it. 			 */
if|if
condition|(
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|&&
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curblocks
operator|>=
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|&&
operator|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|==
literal|0
operator|||
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curblocks
operator|<
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|)
condition|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dqblk
operator|.
name|dqb_isoftlimit
operator|&&
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curinodes
operator|>=
name|dqblk
operator|.
name|dqb_isoftlimit
operator|&&
operator|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
operator|==
literal|0
operator|||
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curinodes
operator|<
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
operator|)
condition|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|=
name|dqblk
operator|.
name|dqb_bsoftlimit
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bhardlimit
operator|=
name|dqblk
operator|.
name|dqb_bhardlimit
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
operator|=
name|dqblk
operator|.
name|dqb_isoftlimit
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_ihardlimit
operator|=
name|dqblk
operator|.
name|dqb_ihardlimit
expr_stmt|;
name|qup
operator|->
name|flags
operator||=
name|FOUND
expr_stmt|;
comment|/* Humanized input returns only approximate counts */
if|if
condition|(
name|hflag
operator|||
operator|(
name|dqblk
operator|.
name|dqb_curblocks
operator|==
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curblocks
operator|&&
name|dqblk
operator|.
name|dqb_curinodes
operator|==
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curinodes
operator|)
condition|)
break|break;
name|warnx
argument_list|(
literal|"%s: cannot change current allocation"
argument_list|,
name|fsp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * Disable quotas for any filesystems that have not been found. 	 */
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
if|if
condition|(
name|qup
operator|->
name|flags
operator|&
name|FOUND
condition|)
block|{
name|qup
operator|->
name|flags
operator|&=
operator|~
name|FOUND
expr_stmt|;
continue|continue;
block|}
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bhardlimit
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_ihardlimit
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a quotause list to an ASCII file of grace times.  */
end_comment

begin_function
name|int
name|writetimes
parameter_list|(
name|struct
name|quotause
modifier|*
name|quplist
parameter_list|,
name|int
name|outfd
parameter_list|,
name|int
name|quotatype
parameter_list|)
block|{
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|ftruncate
argument_list|(
name|outfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|outfd
argument_list|,
literal|0
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fdopen
argument_list|(
name|dup
argument_list|(
name|outfd
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|tmpfil
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Time units may be: days, hours, minutes, or seconds\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Grace period before enforcing soft limits for %ss:\n"
argument_list|,
name|qfextension
index|[
name|quotatype
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s: block grace period: %s, "
argument_list|,
name|qup
operator|->
name|fsname
argument_list|,
name|cvtstoa
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"file grace period: %s\n"
argument_list|,
name|cvtstoa
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Merge changes of grace times in an ASCII file into a quotause list.  */
end_comment

begin_function
name|int
name|readtimes
parameter_list|(
name|struct
name|quotause
modifier|*
name|quplist
parameter_list|,
name|char
modifier|*
name|inname
parameter_list|)
block|{
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|uintmax_t
name|itime
decl_stmt|,
name|btime
decl_stmt|,
name|iseconds
decl_stmt|,
name|bseconds
decl_stmt|;
name|char
modifier|*
name|fsp
decl_stmt|,
name|bunits
index|[
literal|10
index|]
decl_stmt|,
name|iunits
index|[
literal|10
index|]
decl_stmt|,
name|line1
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|inname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't re-read temp file!!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Discard two title lines, then read lines to process. 	 */
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|line1
argument_list|,
sizeof|sizeof
argument_list|(
name|line1
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|line1
argument_list|,
sizeof|sizeof
argument_list|(
name|line1
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line1
argument_list|,
sizeof|sizeof
argument_list|(
name|line1
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fsp
operator|=
name|strtok
argument_list|(
name|line1
argument_list|,
literal|" \t:"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: bad format"
argument_list|,
name|line1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: bad format"
argument_list|,
name|fsp
argument_list|,
operator|&
name|fsp
index|[
name|strlen
argument_list|(
name|fsp
argument_list|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cnt
operator|=
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|" block grace period: %ju %s file grace period: %ju %s"
argument_list|,
operator|&
name|btime
argument_list|,
name|bunits
argument_list|,
operator|&
name|itime
argument_list|,
name|iunits
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|4
condition|)
block|{
name|warnx
argument_list|(
literal|"%s:%s: bad format"
argument_list|,
name|fsp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|cvtatos
argument_list|(
name|btime
argument_list|,
name|bunits
argument_list|,
operator|&
name|bseconds
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cvtatos
argument_list|(
name|itime
argument_list|,
name|iunits
argument_list|,
operator|&
name|iseconds
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fsp
argument_list|,
name|qup
operator|->
name|fsname
argument_list|)
condition|)
continue|continue;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
operator|=
name|bseconds
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
operator|=
name|iseconds
expr_stmt|;
name|qup
operator|->
name|flags
operator||=
name|FOUND
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * reset default grace periods for any filesystems 	 * that have not been found. 	 */
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
if|if
condition|(
name|qup
operator|->
name|flags
operator|&
name|FOUND
condition|)
block|{
name|qup
operator|->
name|flags
operator|&=
operator|~
name|FOUND
expr_stmt|;
continue|continue;
block|}
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert seconds to ASCII times.  */
end_comment

begin_function
name|char
modifier|*
name|cvtstoa
parameter_list|(
name|uint64_t
name|secs
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|secs
operator|%
operator|(
literal|24
operator|*
literal|60
operator|*
literal|60
operator|)
operator|==
literal|0
condition|)
block|{
name|secs
operator|/=
literal|24
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ju day%s"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|secs
argument_list|,
name|secs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|secs
operator|%
operator|(
literal|60
operator|*
literal|60
operator|)
operator|==
literal|0
condition|)
block|{
name|secs
operator|/=
literal|60
operator|*
literal|60
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ju hour%s"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|secs
argument_list|,
name|secs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|secs
operator|%
literal|60
operator|==
literal|0
condition|)
block|{
name|secs
operator|/=
literal|60
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ju minute%s"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|secs
argument_list|,
name|secs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ju second%s"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|secs
argument_list|,
name|secs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert ASCII input times to seconds.  */
end_comment

begin_function
name|int
name|cvtatos
parameter_list|(
name|uint64_t
name|period
parameter_list|,
name|char
modifier|*
name|units
parameter_list|,
name|uint64_t
modifier|*
name|seconds
parameter_list|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|units
argument_list|,
literal|"second"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|seconds
operator|=
name|period
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|units
argument_list|,
literal|"minute"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|seconds
operator|=
name|period
operator|*
literal|60
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|units
argument_list|,
literal|"hour"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|seconds
operator|=
name|period
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|units
argument_list|,
literal|"day"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|seconds
operator|=
name|period
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"%s: bad units, specify %s\n"
argument_list|,
name|units
argument_list|,
literal|"days, hours, minutes, or seconds"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a limit to number of disk blocks.  */
end_comment

begin_function
name|uint64_t
name|cvtblkval
parameter_list|(
name|uint64_t
name|limit
parameter_list|,
name|char
name|units
parameter_list|,
specifier|const
name|char
modifier|*
name|itemname
parameter_list|)
block|{
switch|switch
condition|(
name|units
condition|)
block|{
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
name|limit
operator|=
name|btodb
argument_list|(
name|limit
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* historic behavior */
case|case
literal|','
case|:
comment|/* historic behavior */
case|case
literal|')'
case|:
comment|/* historic behavior */
case|case
literal|'K'
case|:
case|case
literal|'k'
case|:
name|limit
operator|*=
name|btodb
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
name|limit
operator|*=
name|btodb
argument_list|(
literal|1048576
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'g'
case|:
name|limit
operator|*=
name|btodb
argument_list|(
literal|1073741824
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
case|case
literal|'t'
case|:
name|limit
operator|*=
name|btodb
argument_list|(
literal|1099511627776
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
name|limit
operator|*=
name|btodb
argument_list|(
literal|1125899906842624
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|limit
operator|*=
name|btodb
argument_list|(
literal|1152921504606846976
argument_list|)
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|errx
argument_list|(
literal|2
argument_list|,
literal|"No space permitted between value and units for %s\n"
argument_list|,
name|itemname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|2
argument_list|,
literal|"%ju%c: unknown units for %s, specify "
literal|"none, K, M, G, T, P, or E\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|limit
argument_list|,
name|units
argument_list|,
name|itemname
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|limit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a limit to number of inodes.  */
end_comment

begin_function
name|uint64_t
name|cvtinoval
parameter_list|(
name|uint64_t
name|limit
parameter_list|,
name|char
name|units
parameter_list|,
specifier|const
name|char
modifier|*
name|itemname
parameter_list|)
block|{
switch|switch
condition|(
name|units
condition|)
block|{
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
case|case
literal|'\0'
case|:
comment|/* historic behavior */
case|case
literal|','
case|:
comment|/* historic behavior */
case|case
literal|')'
case|:
comment|/* historic behavior */
break|break;
case|case
literal|'K'
case|:
case|case
literal|'k'
case|:
name|limit
operator|*=
literal|1000
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
name|limit
operator|*=
literal|1000000
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'g'
case|:
name|limit
operator|*=
literal|1000000000
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
case|case
literal|'t'
case|:
name|limit
operator|*=
literal|1000000000000
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
case|case
literal|'p'
case|:
name|limit
operator|*=
literal|1000000000000000
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
case|case
literal|'e'
case|:
name|limit
operator|*=
literal|1000000000000000000
expr_stmt|;
break|break;
case|case
literal|' '
case|:
name|errx
argument_list|(
literal|2
argument_list|,
literal|"No space permitted between value and units for %s\n"
argument_list|,
name|itemname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|2
argument_list|,
literal|"%ju%c: unknown units for %s, specify "
literal|"none, K, M, G, T, P, or E\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|limit
argument_list|,
name|units
argument_list|,
name|itemname
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|limit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a list of quotause structures.  */
end_comment

begin_function
name|void
name|freeprivs
parameter_list|(
name|struct
name|quotause
modifier|*
name|quplist
parameter_list|)
block|{
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|,
modifier|*
name|nextqup
decl_stmt|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|nextqup
control|)
block|{
name|quota_close
argument_list|(
name|qup
operator|->
name|qf
argument_list|)
expr_stmt|;
name|nextqup
operator|=
name|qup
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|qup
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check whether a string is completely composed of digits.  */
end_comment

begin_function
name|int
name|alldigits
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

