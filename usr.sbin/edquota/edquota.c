begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Robert Elz at The University of Melbourne.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static const char copyright[] = "@(#) Copyright (c) 1980, 1990, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char sccsid[] = "@(#)edquota.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Disk quota editor.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fstab.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|const
name|char
modifier|*
name|qfname
init|=
name|QUOTAFILENAME
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|qfextension
index|[]
init|=
name|INITQFNAMES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|quotagroup
init|=
name|QUOTAGROUP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tmpfil
index|[]
init|=
name|_PATH_TMP
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|quotause
block|{
name|struct
name|quotause
modifier|*
name|next
decl_stmt|;
name|long
name|flags
decl_stmt|;
name|struct
name|dqblk
name|dqblk
decl_stmt|;
name|char
name|fsname
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|qfname
index|[
literal|1
index|]
decl_stmt|;
comment|/* actually longer */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FOUND
value|0x01
end_define

begin_function_decl
name|int
name|alldigits
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cvtatos
parameter_list|(
name|time_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|time_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|cvtstoa
parameter_list|(
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|editit
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|freeprivs
parameter_list|(
name|struct
name|quotause
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|getentry
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|quotause
modifier|*
name|getprivs
parameter_list|(
name|long
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hasquota
parameter_list|(
name|struct
name|fstab
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|putprivs
parameter_list|(
name|long
parameter_list|,
name|int
parameter_list|,
name|struct
name|quotause
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|readprivs
parameter_list|(
name|struct
name|quotause
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|readtimes
parameter_list|(
name|struct
name|quotause
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|writetimes
parameter_list|(
name|struct
name|quotause
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|writeprivs
parameter_list|(
name|struct
name|quotause
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|,
modifier|*
name|protoprivs
decl_stmt|,
modifier|*
name|curprivs
decl_stmt|;
name|long
name|id
decl_stmt|,
name|protoid
decl_stmt|;
name|long
name|long
name|lim
decl_stmt|;
name|int
name|i
decl_stmt|,
name|quotatype
decl_stmt|,
name|range
decl_stmt|,
name|tmpfd
decl_stmt|;
name|uid_t
name|startuid
decl_stmt|,
name|enduid
decl_stmt|;
name|u_int32_t
modifier|*
name|limp
decl_stmt|;
name|char
modifier|*
name|protoname
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|oldoptarg
decl_stmt|;
name|int
name|eflag
init|=
literal|0
decl_stmt|,
name|tflag
init|=
literal|0
decl_stmt|,
name|pflag
init|=
literal|0
decl_stmt|,
name|ch
decl_stmt|;
name|char
modifier|*
name|fspath
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|MAXLOGNAME
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
name|getuid
argument_list|()
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"permission denied"
argument_list|)
expr_stmt|;
name|quotatype
operator|=
name|USRQUOTA
expr_stmt|;
name|protoprivs
operator|=
name|NULL
expr_stmt|;
name|curprivs
operator|=
name|NULL
expr_stmt|;
name|protoname
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ugtf:p:e:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
name|fspath
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|protoname
operator|=
name|optarg
expr_stmt|;
name|pflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|quotatype
operator|=
name|GRPQUOTA
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|quotatype
operator|=
name|USRQUOTA
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
operator|(
name|qup
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|qup
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|qup
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|qup
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|oldoptarg
operator|=
name|optarg
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|optarg
init|;
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|optarg
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cp
operator|!=
name|oldoptarg
condition|)
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|=
literal|':'
expr_stmt|;
name|limp
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
name|strlcpy
argument_list|(
name|qup
operator|->
name|fsname
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|qup
operator|->
name|fsname
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|limp
operator|=
operator|&
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|limp
operator|=
operator|&
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bhardlimit
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|limp
operator|=
operator|&
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|limp
operator|=
operator|&
name|qup
operator|->
name|dqblk
operator|.
name|dqb_ihardlimit
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"incorrect quota specification: "
literal|"%s"
argument_list|,
name|oldoptarg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
break|break;
comment|/* XXX: report an error */
block|}
if|if
condition|(
name|limp
operator|!=
name|NULL
condition|)
block|{
name|lim
operator|=
name|strtoll
argument_list|(
name|cp
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|lim
operator|<
literal|0
operator|||
name|lim
operator|>
name|UINT_MAX
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid limit value: "
literal|"%lld"
argument_list|,
name|lim
argument_list|)
expr_stmt|;
operator|*
name|limp
operator|=
operator|(
name|u_int32_t
operator|)
name|lim
expr_stmt|;
block|}
block|}
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|=
name|btodb
argument_list|(
operator|(
name|off_t
operator|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bhardlimit
operator|=
name|btodb
argument_list|(
operator|(
name|off_t
operator|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bhardlimit
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|protoprivs
operator|==
name|NULL
condition|)
block|{
name|protoprivs
operator|=
name|curprivs
operator|=
name|qup
expr_stmt|;
block|}
else|else
block|{
name|curprivs
operator|->
name|next
operator|=
name|qup
expr_stmt|;
name|curprivs
operator|=
name|qup
expr_stmt|;
block|}
name|eflag
operator|++
expr_stmt|;
name|pflag
operator|++
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|pflag
condition|)
block|{
if|if
condition|(
name|protoprivs
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|protoid
operator|=
name|getentry
argument_list|(
name|protoname
argument_list|,
name|quotatype
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|protoprivs
operator|=
name|getprivs
argument_list|(
name|protoid
argument_list|,
name|quotatype
argument_list|,
name|fspath
argument_list|)
expr_stmt|;
for|for
control|(
name|qup
operator|=
name|protoprivs
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|argc
operator|--
operator|>
literal|0
condition|;
name|argv
operator|++
control|)
block|{
if|if
condition|(
name|strspn
argument_list|(
operator|*
name|argv
argument_list|,
literal|"0123456789-"
argument_list|)
operator|==
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
operator|*
name|argv
argument_list|,
literal|'-'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|startuid
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|enduid
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|enduid
operator|<
name|startuid
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"ending uid (%d) must be>= starting uid (%d) when using uid ranges"
argument_list|,
name|enduid
argument_list|,
name|startuid
argument_list|)
expr_stmt|;
name|range
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|startuid
operator|=
name|enduid
operator|=
literal|0
expr_stmt|;
name|range
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|startuid
operator|<=
name|enduid
condition|;
name|startuid
operator|++
control|)
block|{
if|if
condition|(
name|range
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|startuid
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|=
name|getentry
argument_list|(
name|buf
argument_list|,
name|quotatype
argument_list|)
operator|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|eflag
condition|)
block|{
for|for
control|(
name|qup
operator|=
name|protoprivs
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
name|curprivs
operator|=
name|getprivs
argument_list|(
name|id
argument_list|,
name|quotatype
argument_list|,
name|qup
operator|->
name|fsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|curprivs
operator|==
name|NULL
condition|)
continue|continue;
name|strcpy
argument_list|(
name|qup
operator|->
name|qfname
argument_list|,
name|curprivs
operator|->
name|qfname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|qup
operator|->
name|fsname
argument_list|,
name|curprivs
operator|->
name|fsname
argument_list|)
expr_stmt|;
block|}
block|}
name|putprivs
argument_list|(
name|id
argument_list|,
name|quotatype
argument_list|,
name|protoprivs
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|tmpfd
operator|=
name|mkstemp
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|fchown
argument_list|(
name|tmpfd
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tflag
condition|)
block|{
name|protoprivs
operator|=
name|getprivs
argument_list|(
literal|0
argument_list|,
name|quotatype
argument_list|,
name|fspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|writetimes
argument_list|(
name|protoprivs
argument_list|,
name|tmpfd
argument_list|,
name|quotatype
argument_list|)
operator|==
literal|0
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|editit
argument_list|(
name|tmpfil
argument_list|)
operator|&&
name|readtimes
argument_list|(
name|protoprivs
argument_list|,
name|tmpfil
argument_list|)
condition|)
name|putprivs
argument_list|(
literal|0L
argument_list|,
name|quotatype
argument_list|,
name|protoprivs
argument_list|)
expr_stmt|;
name|freeprivs
argument_list|(
name|protoprivs
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|argc
operator|>
literal|0
condition|;
name|argc
operator|--
operator|,
name|argv
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|id
operator|=
name|getentry
argument_list|(
operator|*
name|argv
argument_list|,
name|quotatype
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|curprivs
operator|=
name|getprivs
argument_list|(
name|id
argument_list|,
name|quotatype
argument_list|,
name|fspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|writeprivs
argument_list|(
name|curprivs
argument_list|,
name|tmpfd
argument_list|,
operator|*
name|argv
argument_list|,
name|quotatype
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|editit
argument_list|(
name|tmpfil
argument_list|)
operator|&&
name|readprivs
argument_list|(
name|curprivs
argument_list|,
name|tmpfil
argument_list|)
condition|)
name|putprivs
argument_list|(
name|id
argument_list|,
name|quotatype
argument_list|,
name|curprivs
argument_list|)
expr_stmt|;
name|freeprivs
argument_list|(
name|curprivs
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpfil
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n%s\n%s\n%s\n%s\n%s\n%s\n"
argument_list|,
literal|"usage: edquota [-u] [-f fspath] [-p username] username ..."
argument_list|,
literal|"       edquota [-u] -e fspath[:bslim[:bhlim[:islim[:ihlim]]]] [-e ...]"
argument_list|,
literal|"               username ..."
argument_list|,
literal|"       edquota -g [-f fspath] [-p groupname] groupname ..."
argument_list|,
literal|"       edquota -g -e fspath[:bslim[:bhlim[:islim[:ihlim]]]] [-e ...]"
argument_list|,
literal|"               groupname ..."
argument_list|,
literal|"       edquota [-u] -t [-f fspath]"
argument_list|,
literal|"       edquota -g -t [-f fspath]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine converts a name for a particular quota type to  * an identifier. This routine must agree with the kernel routine  * getinoquota as to the interpretation of quota types.  */
end_comment

begin_function
name|int
name|getentry
parameter_list|(
name|name
parameter_list|,
name|quotatype
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|quotatype
decl_stmt|;
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|group
modifier|*
name|gr
decl_stmt|;
if|if
condition|(
name|alldigits
argument_list|(
name|name
argument_list|)
condition|)
return|return
operator|(
name|atoi
argument_list|(
name|name
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|quotatype
condition|)
block|{
case|case
name|USRQUOTA
case|:
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|name
argument_list|)
operator|)
condition|)
return|return
operator|(
name|pw
operator|->
name|pw_uid
operator|)
return|;
name|warnx
argument_list|(
literal|"%s: no such user"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|GRPQUOTA
case|:
if|if
condition|(
operator|(
name|gr
operator|=
name|getgrnam
argument_list|(
name|name
argument_list|)
operator|)
condition|)
return|return
operator|(
name|gr
operator|->
name|gr_gid
operator|)
return|;
name|warnx
argument_list|(
literal|"%s: no such group"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"%d: unknown quota type"
argument_list|,
name|quotatype
argument_list|)
expr_stmt|;
break|break;
block|}
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Collect the requested quota information.  */
end_comment

begin_function
name|struct
name|quotause
modifier|*
name|getprivs
parameter_list|(
name|id
parameter_list|,
name|quotatype
parameter_list|,
name|fspath
parameter_list|)
specifier|register
name|long
name|id
decl_stmt|;
name|int
name|quotatype
decl_stmt|;
name|char
modifier|*
name|fspath
decl_stmt|;
block|{
specifier|register
name|struct
name|fstab
modifier|*
name|fs
decl_stmt|;
specifier|register
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|,
modifier|*
name|quptail
decl_stmt|;
name|struct
name|quotause
modifier|*
name|quphead
decl_stmt|;
name|int
name|qcmd
decl_stmt|,
name|qupsize
decl_stmt|,
name|fd
decl_stmt|;
name|char
modifier|*
name|qfpathname
decl_stmt|;
specifier|static
name|int
name|warned
init|=
literal|0
decl_stmt|;
name|setfsent
argument_list|()
expr_stmt|;
name|quphead
operator|=
name|quptail
operator|=
name|NULL
expr_stmt|;
name|qcmd
operator|=
name|QCMD
argument_list|(
name|Q_GETQUOTA
argument_list|,
name|quotatype
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|fs
operator|=
name|getfsent
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|fspath
operator|&&
operator|*
name|fspath
operator|&&
name|strcmp
argument_list|(
name|fspath
argument_list|,
name|fs
operator|->
name|fs_spec
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|fspath
argument_list|,
name|fs
operator|->
name|fs_file
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|fs
operator|->
name|fs_vfstype
argument_list|,
literal|"ufs"
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|hasquota
argument_list|(
name|fs
argument_list|,
name|quotatype
argument_list|,
operator|&
name|qfpathname
argument_list|)
condition|)
continue|continue;
name|qupsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|qup
argument_list|)
operator|+
name|strlen
argument_list|(
name|qfpathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qup
operator|=
operator|(
expr|struct
name|quotause
operator|*
operator|)
name|malloc
argument_list|(
name|qupsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|quotactl
argument_list|(
name|fs
operator|->
name|fs_file
argument_list|,
name|qcmd
argument_list|,
name|id
argument_list|,
operator|&
name|qup
operator|->
name|dqblk
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EOPNOTSUPP
operator|&&
operator|!
name|warned
condition|)
block|{
name|warned
operator|++
expr_stmt|;
name|warnx
argument_list|(
literal|"warning: quotas are not compiled into this kernel"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|qfpathname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|qfpathname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0640
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|qfpathname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qup
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|warnx
argument_list|(
literal|"creating quota file %s"
argument_list|,
name|qfpathname
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fchown
argument_list|(
name|fd
argument_list|,
name|getuid
argument_list|()
argument_list|,
name|getentry
argument_list|(
name|quotagroup
argument_list|,
name|GRPQUOTA
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fchmod
argument_list|(
name|fd
argument_list|,
literal|0640
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|id
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dqblk
argument_list|)
argument_list|,
name|L_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"seek error on %s"
argument_list|,
name|qfpathname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qup
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|qup
operator|->
name|dqblk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dqblk
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* EOF */
comment|/* 				 * Convert implicit 0 quota (EOF) 				 * into an explicit one (zero'ed dqblk) 				 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|qup
operator|->
name|dqblk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dqblk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
expr|struct
name|dqblk
argument_list|)
case|:
comment|/* OK */
break|break;
default|default:
comment|/* ERROR */
name|warn
argument_list|(
literal|"read error in %s"
argument_list|,
name|qfpathname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|qup
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|qup
operator|->
name|qfname
argument_list|,
name|qfpathname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|qup
operator|->
name|fsname
argument_list|,
name|fs
operator|->
name|fs_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|quphead
operator|==
name|NULL
condition|)
name|quphead
operator|=
name|qup
expr_stmt|;
else|else
name|quptail
operator|->
name|next
operator|=
name|qup
expr_stmt|;
name|quptail
operator|=
name|qup
expr_stmt|;
name|qup
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|endfsent
argument_list|()
expr_stmt|;
return|return
operator|(
name|quphead
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Store the requested quota information.  */
end_comment

begin_function
name|void
name|putprivs
parameter_list|(
name|id
parameter_list|,
name|quotatype
parameter_list|,
name|quplist
parameter_list|)
name|long
name|id
decl_stmt|;
name|int
name|quotatype
decl_stmt|;
name|struct
name|quotause
modifier|*
name|quplist
decl_stmt|;
block|{
specifier|register
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|;
name|int
name|qcmd
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|dqblk
name|dqbuf
decl_stmt|;
name|qcmd
operator|=
name|QCMD
argument_list|(
name|Q_SETQUOTA
argument_list|,
name|quotatype
argument_list|)
expr_stmt|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
if|if
condition|(
name|quotactl
argument_list|(
name|qup
operator|->
name|fsname
argument_list|,
name|qcmd
argument_list|,
name|id
argument_list|,
operator|&
name|qup
operator|->
name|dqblk
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|qup
operator|->
name|qfname
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|qup
operator|->
name|qfname
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|id
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dqblk
argument_list|)
argument_list|,
name|L_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"seek error on %s"
argument_list|,
name|qup
operator|->
name|qfname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|dqbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dqblk
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* EOF */
comment|/* 			 * Convert implicit 0 quota (EOF) 			 * into an explicit one (zero'ed dqblk) 			 */
name|bzero
argument_list|(
operator|&
name|dqbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dqblk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
sizeof|sizeof
argument_list|(
expr|struct
name|dqblk
argument_list|)
case|:
comment|/* OK */
break|break;
default|default:
comment|/* ERROR */
name|warn
argument_list|(
literal|"read error in %s"
argument_list|,
name|qup
operator|->
name|qfname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Reset time limit if have a soft limit and were 		 * previously under it, but are now over it 		 * or if there previously was no soft limit, but  		 * now have one and are over it. 		 */
if|if
condition|(
name|dqbuf
operator|.
name|dqb_bsoftlimit
operator|&&
name|id
operator|!=
literal|0
operator|&&
name|dqbuf
operator|.
name|dqb_curblocks
operator|<
name|dqbuf
operator|.
name|dqb_bsoftlimit
operator|&&
name|dqbuf
operator|.
name|dqb_curblocks
operator|>=
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
condition|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dqbuf
operator|.
name|dqb_bsoftlimit
operator|==
literal|0
operator|&&
name|id
operator|!=
literal|0
operator|&&
name|dqbuf
operator|.
name|dqb_curblocks
operator|>=
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
condition|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dqbuf
operator|.
name|dqb_isoftlimit
operator|&&
name|id
operator|!=
literal|0
operator|&&
name|dqbuf
operator|.
name|dqb_curinodes
operator|<
name|dqbuf
operator|.
name|dqb_isoftlimit
operator|&&
name|dqbuf
operator|.
name|dqb_curinodes
operator|>=
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
condition|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dqbuf
operator|.
name|dqb_isoftlimit
operator|==
literal|0
operator|&&
name|id
operator|!=
literal|0
operator|&&
name|dqbuf
operator|.
name|dqb_curinodes
operator|>=
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
condition|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curinodes
operator|=
name|dqbuf
operator|.
name|dqb_curinodes
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curblocks
operator|=
name|dqbuf
operator|.
name|dqb_curblocks
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|id
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dqblk
argument_list|)
argument_list|,
name|L_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"seek error on %s"
argument_list|,
name|qup
operator|->
name|qfname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|qup
operator|->
name|dqblk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dqblk
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|dqblk
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|qup
operator|->
name|qfname
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Take a list of priviledges and get it edited.  */
end_comment

begin_function
name|int
name|editit
parameter_list|(
name|tmpf
parameter_list|)
name|char
modifier|*
name|tmpf
decl_stmt|;
block|{
name|long
name|omask
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|status
decl_stmt|;
name|omask
operator|=
name|sigblock
argument_list|(
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGQUIT
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGHUP
argument_list|)
argument_list|)
expr_stmt|;
name|top
label|:
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EPROCLIM
condition|)
block|{
name|warnx
argument_list|(
literal|"you have too many processes"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|warn
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
specifier|register
specifier|const
name|char
modifier|*
name|ed
decl_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ed
operator|=
name|getenv
argument_list|(
literal|"EDITOR"
argument_list|)
operator|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
name|ed
operator|=
name|_PATH_VI
expr_stmt|;
name|execlp
argument_list|(
name|ed
argument_list|,
name|ed
argument_list|,
name|tmpf
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ed
argument_list|)
expr_stmt|;
block|}
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sigsetmask
argument_list|(
name|omask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|||
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a quotause list to an ASCII file.  */
end_comment

begin_function
name|int
name|writeprivs
parameter_list|(
name|quplist
parameter_list|,
name|outfd
parameter_list|,
name|name
parameter_list|,
name|quotatype
parameter_list|)
name|struct
name|quotause
modifier|*
name|quplist
decl_stmt|;
name|int
name|outfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|quotatype
decl_stmt|;
block|{
specifier|register
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|ftruncate
argument_list|(
name|outfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|outfd
argument_list|,
literal|0
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fdopen
argument_list|(
name|dup
argument_list|(
name|outfd
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|tmpfil
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Quotas for %s %s:\n"
argument_list|,
name|qfextension
index|[
name|quotatype
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s: %s %lu, limits (soft = %lu, hard = %lu)\n"
argument_list|,
name|qup
operator|->
name|fsname
argument_list|,
literal|"kbytes in use:"
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|dbtob
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curblocks
argument_list|)
operator|/
literal|1024
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|dbtob
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
argument_list|)
operator|/
literal|1024
argument_list|)
argument_list|,
call|(
name|unsigned
name|long
call|)
argument_list|(
name|dbtob
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bhardlimit
argument_list|)
operator|/
literal|1024
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s %lu, limits (soft = %lu, hard = %lu)\n"
argument_list|,
literal|"\tinodes in use:"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curinodes
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_ihardlimit
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Merge changes to an ASCII file into a quotause list.  */
end_comment

begin_function
name|int
name|readprivs
parameter_list|(
name|quplist
parameter_list|,
name|inname
parameter_list|)
name|struct
name|quotause
modifier|*
name|quplist
decl_stmt|;
name|char
modifier|*
name|inname
decl_stmt|;
block|{
specifier|register
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|unsigned
name|long
name|bhardlimit
decl_stmt|,
name|bsoftlimit
decl_stmt|,
name|curblocks
decl_stmt|;
name|unsigned
name|long
name|ihardlimit
decl_stmt|,
name|isoftlimit
decl_stmt|,
name|curinodes
decl_stmt|;
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|dqblk
name|dqblk
decl_stmt|;
name|char
modifier|*
name|fsp
decl_stmt|,
name|line1
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|line2
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|inname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't re-read temp file!!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Discard title line, then read pairs of lines to process. 	 */
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|line1
argument_list|,
sizeof|sizeof
argument_list|(
name|line1
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line1
argument_list|,
sizeof|sizeof
argument_list|(
name|line1
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
operator|&&
name|fgets
argument_list|(
name|line2
argument_list|,
sizeof|sizeof
argument_list|(
name|line2
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fsp
operator|=
name|strtok
argument_list|(
name|line1
argument_list|,
literal|" \t:"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: bad format"
argument_list|,
name|line1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: bad format"
argument_list|,
name|fsp
argument_list|,
operator|&
name|fsp
index|[
name|strlen
argument_list|(
name|fsp
argument_list|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cnt
operator|=
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|" kbytes in use: %lu, limits (soft = %lu, hard = %lu)"
argument_list|,
operator|&
name|curblocks
argument_list|,
operator|&
name|bsoftlimit
argument_list|,
operator|&
name|bhardlimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|3
condition|)
block|{
name|warnx
argument_list|(
literal|"%s:%s: bad format"
argument_list|,
name|fsp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dqblk
operator|.
name|dqb_curblocks
operator|=
name|btodb
argument_list|(
operator|(
name|off_t
operator|)
name|curblocks
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|=
name|btodb
argument_list|(
operator|(
name|off_t
operator|)
name|bsoftlimit
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|dqblk
operator|.
name|dqb_bhardlimit
operator|=
name|btodb
argument_list|(
operator|(
name|off_t
operator|)
name|bhardlimit
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strtok
argument_list|(
name|line2
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: bad format"
argument_list|,
name|fsp
argument_list|,
name|line2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cnt
operator|=
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"\tinodes in use: %lu, limits (soft = %lu, hard = %lu)"
argument_list|,
operator|&
name|curinodes
argument_list|,
operator|&
name|isoftlimit
argument_list|,
operator|&
name|ihardlimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|3
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: bad format"
argument_list|,
name|fsp
argument_list|,
name|line2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dqblk
operator|.
name|dqb_curinodes
operator|=
name|curinodes
expr_stmt|;
name|dqblk
operator|.
name|dqb_isoftlimit
operator|=
name|isoftlimit
expr_stmt|;
name|dqblk
operator|.
name|dqb_ihardlimit
operator|=
name|ihardlimit
expr_stmt|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fsp
argument_list|,
name|qup
operator|->
name|fsname
argument_list|)
condition|)
continue|continue;
comment|/* 			 * Cause time limit to be reset when the quota 			 * is next used if previously had no soft limit 			 * or were under it, but now have a soft limit 			 * and are over it. 			 */
if|if
condition|(
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|&&
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curblocks
operator|>=
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|&&
operator|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|==
literal|0
operator|||
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curblocks
operator|<
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|)
condition|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dqblk
operator|.
name|dqb_isoftlimit
operator|&&
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curinodes
operator|>=
name|dqblk
operator|.
name|dqb_isoftlimit
operator|&&
operator|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
operator|==
literal|0
operator|||
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curinodes
operator|<
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
operator|)
condition|)
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|=
name|dqblk
operator|.
name|dqb_bsoftlimit
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bhardlimit
operator|=
name|dqblk
operator|.
name|dqb_bhardlimit
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
operator|=
name|dqblk
operator|.
name|dqb_isoftlimit
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_ihardlimit
operator|=
name|dqblk
operator|.
name|dqb_ihardlimit
expr_stmt|;
name|qup
operator|->
name|flags
operator||=
name|FOUND
expr_stmt|;
if|if
condition|(
name|dqblk
operator|.
name|dqb_curblocks
operator|==
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curblocks
operator|&&
name|dqblk
operator|.
name|dqb_curinodes
operator|==
name|qup
operator|->
name|dqblk
operator|.
name|dqb_curinodes
condition|)
break|break;
name|warnx
argument_list|(
literal|"%s: cannot change current allocation"
argument_list|,
name|fsp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * Disable quotas for any filesystems that have not been found. 	 */
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
if|if
condition|(
name|qup
operator|->
name|flags
operator|&
name|FOUND
condition|)
block|{
name|qup
operator|->
name|flags
operator|&=
operator|~
name|FOUND
expr_stmt|;
continue|continue;
block|}
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bsoftlimit
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_bhardlimit
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_isoftlimit
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_ihardlimit
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a quotause list to an ASCII file of grace times.  */
end_comment

begin_function
name|int
name|writetimes
parameter_list|(
name|quplist
parameter_list|,
name|outfd
parameter_list|,
name|quotatype
parameter_list|)
name|struct
name|quotause
modifier|*
name|quplist
decl_stmt|;
name|int
name|outfd
decl_stmt|;
name|int
name|quotatype
decl_stmt|;
block|{
specifier|register
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|ftruncate
argument_list|(
name|outfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|outfd
argument_list|,
literal|0
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fdopen
argument_list|(
name|dup
argument_list|(
name|outfd
argument_list|)
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|tmpfil
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Time units may be: days, hours, minutes, or seconds\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"Grace period before enforcing soft limits for %ss:\n"
argument_list|,
name|qfextension
index|[
name|quotatype
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"%s: block grace period: %s, "
argument_list|,
name|qup
operator|->
name|fsname
argument_list|,
name|cvtstoa
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fd
argument_list|,
literal|"file grace period: %s\n"
argument_list|,
name|cvtstoa
argument_list|(
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Merge changes of grace times in an ASCII file into a quotause list.  */
end_comment

begin_function
name|int
name|readtimes
parameter_list|(
name|quplist
parameter_list|,
name|inname
parameter_list|)
name|struct
name|quotause
modifier|*
name|quplist
decl_stmt|;
name|char
modifier|*
name|inname
decl_stmt|;
block|{
specifier|register
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|;
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|time_t
name|itime
decl_stmt|,
name|btime
decl_stmt|,
name|iseconds
decl_stmt|,
name|bseconds
decl_stmt|;
name|long
name|l_itime
decl_stmt|,
name|l_btime
decl_stmt|;
name|char
modifier|*
name|fsp
decl_stmt|,
name|bunits
index|[
literal|10
index|]
decl_stmt|,
name|iunits
index|[
literal|10
index|]
decl_stmt|,
name|line1
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fd
operator|=
name|fopen
argument_list|(
name|inname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"can't re-read temp file!!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Discard two title lines, then read lines to process. 	 */
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|line1
argument_list|,
sizeof|sizeof
argument_list|(
name|line1
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|line1
argument_list|,
sizeof|sizeof
argument_list|(
name|line1
argument_list|)
argument_list|,
name|fd
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line1
argument_list|,
sizeof|sizeof
argument_list|(
name|line1
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|fsp
operator|=
name|strtok
argument_list|(
name|line1
argument_list|,
literal|" \t:"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: bad format"
argument_list|,
name|line1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: %s: bad format"
argument_list|,
name|fsp
argument_list|,
operator|&
name|fsp
index|[
name|strlen
argument_list|(
name|fsp
argument_list|)
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cnt
operator|=
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|" block grace period: %ld %s file grace period: %ld %s"
argument_list|,
operator|&
name|l_btime
argument_list|,
name|bunits
argument_list|,
operator|&
name|l_itime
argument_list|,
name|iunits
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|!=
literal|4
condition|)
block|{
name|warnx
argument_list|(
literal|"%s:%s: bad format"
argument_list|,
name|fsp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|btime
operator|=
name|l_btime
expr_stmt|;
name|itime
operator|=
name|l_itime
expr_stmt|;
if|if
condition|(
name|cvtatos
argument_list|(
name|btime
argument_list|,
name|bunits
argument_list|,
operator|&
name|bseconds
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cvtatos
argument_list|(
name|itime
argument_list|,
name|iunits
argument_list|,
operator|&
name|iseconds
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|fsp
argument_list|,
name|qup
operator|->
name|fsname
argument_list|)
condition|)
continue|continue;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
operator|=
name|bseconds
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
operator|=
name|iseconds
expr_stmt|;
name|qup
operator|->
name|flags
operator||=
name|FOUND
expr_stmt|;
break|break;
block|}
block|}
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * reset default grace periods for any filesystems 	 * that have not been found. 	 */
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|qup
operator|->
name|next
control|)
block|{
if|if
condition|(
name|qup
operator|->
name|flags
operator|&
name|FOUND
condition|)
block|{
name|qup
operator|->
name|flags
operator|&=
operator|~
name|FOUND
expr_stmt|;
continue|continue;
block|}
name|qup
operator|->
name|dqblk
operator|.
name|dqb_btime
operator|=
literal|0
expr_stmt|;
name|qup
operator|->
name|dqblk
operator|.
name|dqb_itime
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert seconds to ASCII times.  */
end_comment

begin_function
name|char
modifier|*
name|cvtstoa
parameter_list|(
name|secs
parameter_list|)
name|time_t
name|secs
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|secs
operator|%
operator|(
literal|24
operator|*
literal|60
operator|*
literal|60
operator|)
operator|==
literal|0
condition|)
block|{
name|secs
operator|/=
literal|24
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld day%s"
argument_list|,
operator|(
name|long
operator|)
name|secs
argument_list|,
name|secs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|secs
operator|%
operator|(
literal|60
operator|*
literal|60
operator|)
operator|==
literal|0
condition|)
block|{
name|secs
operator|/=
literal|60
operator|*
literal|60
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld hour%s"
argument_list|,
operator|(
name|long
operator|)
name|secs
argument_list|,
name|secs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|secs
operator|%
literal|60
operator|==
literal|0
condition|)
block|{
name|secs
operator|/=
literal|60
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld minute%s"
argument_list|,
operator|(
name|long
operator|)
name|secs
argument_list|,
name|secs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld second%s"
argument_list|,
operator|(
name|long
operator|)
name|secs
argument_list|,
name|secs
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert ASCII input times to seconds.  */
end_comment

begin_function
name|int
name|cvtatos
parameter_list|(
name|period
parameter_list|,
name|units
parameter_list|,
name|seconds
parameter_list|)
name|time_t
name|period
decl_stmt|;
name|char
modifier|*
name|units
decl_stmt|;
name|time_t
modifier|*
name|seconds
decl_stmt|;
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|units
argument_list|,
literal|"second"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|seconds
operator|=
name|period
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|units
argument_list|,
literal|"minute"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|seconds
operator|=
name|period
operator|*
literal|60
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|units
argument_list|,
literal|"hour"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|seconds
operator|=
name|period
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
elseif|else
if|if
condition|(
name|bcmp
argument_list|(
name|units
argument_list|,
literal|"day"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|seconds
operator|=
name|period
operator|*
literal|24
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s: bad units, specify %s\n"
argument_list|,
name|units
argument_list|,
literal|"days, hours, minutes, or seconds"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a list of quotause structures.  */
end_comment

begin_function
name|void
name|freeprivs
parameter_list|(
name|quplist
parameter_list|)
name|struct
name|quotause
modifier|*
name|quplist
decl_stmt|;
block|{
specifier|register
name|struct
name|quotause
modifier|*
name|qup
decl_stmt|,
modifier|*
name|nextqup
decl_stmt|;
for|for
control|(
name|qup
operator|=
name|quplist
init|;
name|qup
condition|;
name|qup
operator|=
name|nextqup
control|)
block|{
name|nextqup
operator|=
name|qup
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|qup
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check whether a string is completely composed of digits.  */
end_comment

begin_function
name|int
name|alldigits
parameter_list|(
name|s
parameter_list|)
specifier|register
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|s
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
operator|*
name|s
operator|++
operator|)
condition|)
do|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a particular quota is to be enabled.  */
end_comment

begin_function
name|int
name|hasquota
parameter_list|(
name|fs
parameter_list|,
name|type
parameter_list|,
name|qfnamep
parameter_list|)
name|struct
name|fstab
modifier|*
name|fs
decl_stmt|;
name|int
name|type
decl_stmt|;
name|char
modifier|*
modifier|*
name|qfnamep
decl_stmt|;
block|{
name|char
modifier|*
name|opt
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|statfs
name|sfb
decl_stmt|;
specifier|static
name|char
name|initname
decl_stmt|,
name|usrname
index|[
literal|100
index|]
decl_stmt|,
name|grpname
index|[
literal|100
index|]
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|initname
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|usrname
argument_list|,
sizeof|sizeof
argument_list|(
name|usrname
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|qfextension
index|[
name|USRQUOTA
index|]
argument_list|,
name|qfname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|grpname
argument_list|,
sizeof|sizeof
argument_list|(
name|grpname
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|qfextension
index|[
name|GRPQUOTA
index|]
argument_list|,
name|qfname
argument_list|)
expr_stmt|;
name|initname
operator|=
literal|1
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|fs
operator|->
name|fs_mntops
argument_list|)
expr_stmt|;
for|for
control|(
name|opt
operator|=
name|strtok
argument_list|(
name|buf
argument_list|,
literal|","
argument_list|)
init|;
name|opt
condition|;
name|opt
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|","
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|opt
argument_list|,
literal|'='
argument_list|)
operator|)
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|USRQUOTA
operator|&&
name|strcmp
argument_list|(
name|opt
argument_list|,
name|usrname
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|type
operator|==
name|GRPQUOTA
operator|&&
name|strcmp
argument_list|(
name|opt
argument_list|,
name|grpname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|opt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|cp
condition|)
operator|*
name|qfnamep
operator|=
name|cp
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%s/%s.%s"
argument_list|,
name|fs
operator|->
name|fs_file
argument_list|,
name|qfname
argument_list|,
name|qfextension
index|[
name|type
index|]
argument_list|)
expr_stmt|;
operator|*
name|qfnamep
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|statfs
argument_list|(
name|fs
operator|->
name|fs_file
argument_list|,
operator|&
name|sfb
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"cannot statfs mount point %s"
argument_list|,
name|fs
operator|->
name|fs_file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|fs
operator|->
name|fs_file
argument_list|,
name|sfb
operator|.
name|f_mntonname
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s not mounted for %s quotas"
argument_list|,
name|fs
operator|->
name|fs_file
argument_list|,
name|type
operator|==
name|USRQUOTA
condition|?
literal|"user"
else|:
literal|"group"
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

