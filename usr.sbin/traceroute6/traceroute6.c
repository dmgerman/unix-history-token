begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$KAME: traceroute6.c,v 1.68 2004/01/25 11:16:12 suz Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Van Jacobson.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1990, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)traceroute.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * traceroute host  - trace the route ip packets follow going to "host".  *  * Attempt to trace the route an ip packet would follow to some  * internet host.  We find out intermediate hops by launching probe  * packets with a small ttl (time to live) then listening for an  * icmp "time exceeded" reply from a gateway.  We start our probes  * with a ttl of one and increase by one until we get an icmp "port  * unreachable" (which means we got to "host") or hit a max (which  * defaults to 30 hops& can be changed with the -m flag).  Three  * probes (change with -q flag) are sent at each ttl setting and a  * line is printed showing the ttl, address of the gateway and  * round trip time of each probe.  If the probe answers come from  * different gateways, the address of each responding system will  * be printed.  If there is no response within a 5 sec. timeout  * interval (changed with the -w flag), a "*" is printed for that  * probe.  *  * Probe packets are UDP format.  We don't want the destination  * host to process them so the destination port is set to an  * unlikely value (if some clod on the destination is using that  * value, it can be changed with the -p flag).  *  * A sample use might be:  *  *     [yak 71]% traceroute nis.nsf.net.  *     traceroute to nis.nsf.net (35.1.1.48), 30 hops max, 56 byte packet  *      1  helios.ee.lbl.gov (128.3.112.1)  19 ms  19 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  39 ms  *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  39 ms  39 ms  39 ms  *      6  128.32.197.4 (128.32.197.4)  40 ms  59 ms  59 ms  *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  59 ms  *      8  129.140.70.13 (129.140.70.13)  99 ms  99 ms  80 ms  *      9  129.140.71.6 (129.140.71.6)  139 ms  239 ms  319 ms  *     10  129.140.81.7 (129.140.81.7)  220 ms  199 ms  199 ms  *     11  nic.merit.edu (35.1.1.48)  239 ms  239 ms  239 ms  *  * Note that lines 2& 3 are the same.  This is due to a buggy  * kernel on the 2nd hop system -- lbl-csam.arpa -- that forwards  * packets with a zero ttl.  *  * A more interesting example is:  *  *     [yak 72]% traceroute allspice.lcs.mit.edu.  *     traceroute to allspice.lcs.mit.edu (18.26.0.115), 30 hops max  *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  19 ms  19 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  19 ms  39 ms  39 ms  *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  20 ms  39 ms  39 ms  *      6  128.32.197.4 (128.32.197.4)  59 ms  119 ms  39 ms  *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  39 ms  *      8  129.140.70.13 (129.140.70.13)  80 ms  79 ms  99 ms  *      9  129.140.71.6 (129.140.71.6)  139 ms  139 ms  159 ms  *     10  129.140.81.7 (129.140.81.7)  199 ms  180 ms  300 ms  *     11  129.140.72.17 (129.140.72.17)  300 ms  239 ms  239 ms  *     12  * * *  *     13  128.121.54.72 (128.121.54.72)  259 ms  499 ms  279 ms  *     14  * * *  *     15  * * *  *     16  * * *  *     17  * * *  *     18  ALLSPICE.LCS.MIT.EDU (18.26.0.115)  339 ms  279 ms  279 ms  *  * (I start to see why I'm having so much trouble with mail to  * MIT.)  Note that the gateways 12, 14, 15, 16& 17 hops away  * either don't send ICMP "time exceeded" messages or send them  * with a ttl too small to reach us.  14 - 17 are running the  * MIT C Gateway code that doesn't send "time exceeded"s.  God  * only knows what's going on with 12.  *  * The silent gateway 12 in the above may be the result of a bug in  * the 4.[23]BSD network code (and its derivatives):  4.x (x<= 3)  * sends an unreachable message using whatever ttl remains in the  * original datagram.  Since, for gateways, the remaining ttl is  * zero, the icmp "time exceeded" is guaranteed to not make it back  * to us.  The behavior of this bug is slightly more interesting  * when it appears on the destination system:  *  *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  39 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  39 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  19 ms  *      5  ccn-nerif35.Berkeley.EDU (128.32.168.35)  39 ms  39 ms  39 ms  *      6  csgw.Berkeley.EDU (128.32.133.254)  39 ms  59 ms  39 ms  *      7  * * *  *      8  * * *  *      9  * * *  *     10  * * *  *     11  * * *  *     12  * * *  *     13  rip.Berkeley.EDU (128.32.131.22)  59 ms !  39 ms !  39 ms !  *  * Notice that there are 12 "gateways" (13 is the final  * destination) and exactly the last half of them are "missing".  * What's really happening is that rip (a Sun-3 running Sun OS3.5)  * is using the ttl from our arriving datagram as the ttl in its  * icmp reply.  So, the reply will time out on the return path  * (with no notice sent to anyone since icmp's aren't sent for  * icmp's) until we probe with a ttl that's at least twice the path  * length.  I.e., rip is really only 7 hops away.  A reply that  * returns with a ttl of 1 is a clue this problem exists.  * Traceroute prints a "!" after the time if the ttl is<= 1.  * Since vendors ship a lot of obsolete (DEC's Ultrix, Sun 3.x) or  * non-standard (HPUX) software, expect to see this problem  * frequently and/or take care picking the target host of your  * probes.  *  * Other possible annotations after the time are !H, !N, !P (got a host,  * network or protocol unreachable, respectively), !S or !F (source  * route failed or fragmentation needed -- neither of these should  * ever occur and the associated gateway is busted if you see one).  If  * almost all the probes result in some kind of unreachable, traceroute  * will give up and exit.  *  * Notes  * -----  * This program must be run by root or be setuid.  (I suggest that  * you *don't* make it setuid -- casual use could result in a lot  * of unnecessary traffic on our poor, congested nets.)  *  * This program requires a kernel mod that does not appear in any  * system available from Berkeley:  A raw ip socket using proto  * IPPROTO_RAW must interpret the data sent as an ip datagram (as  * opposed to data to be wrapped in an ip datagram).  See the README  * file that came with the source to this program for a description  * of the mods I made to /sys/netinet/raw_ip.c.  Your mileage may  * vary.  But, again, ANY 4.x (x< 4) BSD KERNEL WILL HAVE TO BE  * MODIFIED TO RUN THIS PROGRAM.  *  * The udp port usage may appear bizarre (well, ok, it is bizarre).  * The problem is that an icmp message only contains 8 bytes of  * data from the original datagram.  8 bytes is the size of a udp  * header so, if we want to associate replies with the original  * datagram, the necessary information must be encoded into the  * udp header (the ip id could be used but there's no way to  * interlock with the kernel's assignment of ip id's and, anyway,  * it would have taken a lot more kernel hacking to allow this  * code to set the ip id).  So, to allow two or more users to  * use traceroute simultaneously, we use this task's pid as the  * source port (the high bit is set to move the port number out  * of the "likely" range).  To keep track of which probe is being  * replied to (so times and/or hop counts don't get confused by a  * reply that was delayed in transit), we increment the destination  * port number before each probe.  *  * Don't use this as a coding example.  I was trying to find a  * routing problem and this code sort-of popped out after 48 hours  * without sleep.  I was amazed it ever compiled, much less ran.  *  * I stole the idea for this program from Steve Deering.  Since  * the first release, I've learned that had I attended the right  * IETF working group meetings, I also could have stolen it from Guy  * Almes or Matt Mathis.  I don't know (or care) who came up with  * the idea first.  I envy the originators' perspicacity and I'm  * glad they didn't keep the idea a secret.  *  * Tim Seaver, Ken Adelman and C. Philip Wood provided bug fixes and/or  * enhancements to the original distribution.  *  * I've hacked up a round-trip-route version of this that works by  * sending a loose-source-routed udp datagram through the destination  * back to yourself.  Unfortunately, SO many gateways botch source  * routing, the thing is almost worthless.  Maybe one day...  *  *  -- Van Jacobson (van@helios.ee.lbl.gov)  *     Tue Dec 20 03:50:13 PST 1988  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POLL
end_ifdef

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DUMMY_PORT
value|10010
end_define

begin_define
define|#
directive|define
name|MAXPACKET
value|65535
end_define

begin_comment
comment|/* max ip packet size */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_GETIPNODEBYNAME
end_ifndef

begin_define
define|#
directive|define
name|getipnodebyname
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|,
name|u
parameter_list|)
value|gethostbyname2((x), (y))
end_define

begin_define
define|#
directive|define
name|freehostent
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * format of a (udp) probe packet.  */
end_comment

begin_struct
struct|struct
name|tv32
block|{
name|u_int32_t
name|tv32_sec
decl_stmt|;
name|u_int32_t
name|tv32_usec
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|opacket
block|{
name|u_char
name|seq
decl_stmt|;
comment|/* sequence number of this packet */
name|u_char
name|hops
decl_stmt|;
comment|/* hop limit of the packet */
name|u_char
name|pad
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|tv32
name|tv
decl_stmt|;
comment|/* time packet left */
block|}
name|__attribute__
argument_list|(
operator|(
name|__packed__
operator|)
argument_list|)
struct|;
end_struct

begin_decl_stmt
name|u_char
name|packet
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last inbound (icmp) packet */
end_comment

begin_decl_stmt
name|struct
name|opacket
modifier|*
name|outpacket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last output (udp) packet */
end_comment

begin_decl_stmt
name|int
decl|main
name|__P
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|wait_for_reply
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_POLICY_IPSEC
end_ifdef

begin_decl_stmt
name|int
name|setpolicy
name|__P
argument_list|(
operator|(
name|int
name|so
operator|,
name|char
operator|*
name|policy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|send_probe
name|__P
argument_list|(
operator|(
name|int
operator|,
name|u_long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|udphdr
modifier|*
name|get_udphdr
name|__P
argument_list|(
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|,
name|u_char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|get_hoplim
name|__P
argument_list|(
operator|(
expr|struct
name|msghdr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|deltaT
name|__P
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|,
expr|struct
name|timeval
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pr_type
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|packet_ok
name|__P
argument_list|(
operator|(
expr|struct
name|msghdr
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|print
name|__P
argument_list|(
operator|(
expr|struct
name|msghdr
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|inetname
name|__P
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|usage
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rcvsock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receive (icmp) socket file descriptor */
end_comment

begin_decl_stmt
name|int
name|sndsock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* send (udp) socket file descriptor */
end_comment

begin_decl_stmt
name|struct
name|msghdr
name|rcvmhdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iovec
name|rcviov
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rcvhlim
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in6_pktinfo
modifier|*
name|rcvpktinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in6
name|Src
decl_stmt|,
name|Dst
decl_stmt|,
name|Rcv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|datalen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How much data */
end_comment

begin_define
define|#
directive|define
name|ICMP6ECHOLEN
value|8
end_define

begin_comment
comment|/* XXX: 2064 = 127(max hops in type 0 rthdr) * sizeof(ip6_hdr) + 16(margin) */
end_comment

begin_decl_stmt
name|char
name|rtbuf
index|[
literal|2064
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_RFC2292BIS
end_ifdef

begin_decl_stmt
name|struct
name|ip6_rthdr
modifier|*
name|rth
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|cmsghdr
modifier|*
name|cmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|source
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|nprobes
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|first_hop
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|max_hops
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16_t
name|srcport
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int16_t
name|port
init|=
literal|32768
operator|+
literal|666
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start udp dest port # for probe packets */
end_comment

begin_decl_stmt
name|u_int16_t
name|ident
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket options */
end_comment

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|waittime
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time to wait for response (in seconds) */
end_comment

begin_decl_stmt
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print addresses numerically */
end_comment

begin_decl_stmt
name|int
name|useicmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print both numerical address& hostname */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|mib
index|[
literal|4
index|]
init|=
block|{
name|CTL_NET
block|,
name|PF_INET6
block|,
name|IPPROTO_IPV6
block|,
name|IPV6CTL_DEFHLIM
block|}
decl_stmt|;
name|char
name|hbuf
index|[
name|NI_MAXHOST
index|]
decl_stmt|,
name|src0
index|[
name|NI_MAXHOST
index|]
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|,
name|on
init|=
literal|1
decl_stmt|,
name|seq
decl_stmt|,
name|rcvcmsglen
decl_stmt|,
name|error
decl_stmt|,
name|minlen
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|;
specifier|static
name|u_char
modifier|*
name|rcvcmsgbuf
decl_stmt|;
name|u_long
name|probe
decl_stmt|,
name|hops
decl_stmt|,
name|lport
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* 	 * Receive ICMP 	 */
if|if
condition|(
operator|(
name|rcvsock
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_ICMPV6
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket(ICMPv6)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* revoke privs */
name|seteuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sysctl
argument_list|(
name|mib
argument_list|,
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mib
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|max_hops
operator|=
name|i
expr_stmt|;
comment|/* specify to tell receiving interface */
ifdef|#
directive|ifdef
name|IPV6_RECVPKTINFO
if|if
condition|(
name|setsockopt
argument_list|(
name|rcvsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_RECVPKTINFO
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setsockopt(IPV6_RECVPKTINFO)"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* old adv. API */
if|if
condition|(
name|setsockopt
argument_list|(
name|rcvsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_PKTINFO
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setsockopt(IPV6_PKTINFO)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* specify to tell value of hoplimit field of received IP6 hdr */
ifdef|#
directive|ifdef
name|IPV6_RECVHOPLIMIT
if|if
condition|(
name|setsockopt
argument_list|(
name|rcvsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_RECVHOPLIMIT
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setsockopt(IPV6_RECVHOPLIMIT)"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* old adv. API */
if|if
condition|(
name|setsockopt
argument_list|(
name|rcvsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_HOPLIMIT
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"setsockopt(IPV6_HOPLIMIT)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|seq
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"df:g:Ilm:np:q:rs:w:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'d'
case|:
name|options
operator||=
name|SO_DEBUG
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|ep
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|first_hop
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|!
operator|*
name|optarg
operator|||
operator|*
name|ep
operator|||
name|first_hop
operator|>
literal|255
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: invalid min hoplimit.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'g'
case|:
name|hp
operator|=
name|getipnodebyname
argument_list|(
name|optarg
argument_list|,
name|AF_INET6
argument_list|,
literal|0
argument_list|,
operator|&
name|h_errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: unknown host %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_RFC2292BIS
if|if
condition|(
name|rth
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * XXX: We can't detect the number of 				 * intermediate nodes yet. 				 */
if|if
condition|(
operator|(
name|rth
operator|=
name|inet6_rth_init
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rtbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rtbuf
argument_list|)
argument_list|,
name|IPV6_RTHDR_TYPE_0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"inet6_rth_init failed.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inet6_rth_add
argument_list|(
operator|(
name|void
operator|*
operator|)
name|rth
argument_list|,
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"inet6_rth_add failed for %s\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* old advanced API */
if|if
condition|(
name|cmsg
operator|==
name|NULL
condition|)
name|cmsg
operator|=
name|inet6_rthdr_init
argument_list|(
name|rtbuf
argument_list|,
name|IPV6_RTHDR_TYPE_0
argument_list|)
expr_stmt|;
name|inet6_rthdr_add
argument_list|(
name|cmsg
argument_list|,
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
argument_list|,
name|IPV6_RTHDR_LOOSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freehostent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|useicmp
operator|++
expr_stmt|;
name|ident
operator|=
name|htons
argument_list|(
name|getpid
argument_list|()
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* same as ping6 */
break|break;
case|case
literal|'l'
case|:
name|lflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|ep
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|max_hops
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|!
operator|*
name|optarg
operator|||
operator|*
name|ep
operator|||
name|max_hops
operator|>
literal|255
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: invalid max hoplimit.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|ep
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|lport
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|!
operator|*
name|optarg
operator|||
operator|*
name|ep
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: invalid port.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lport
operator|==
literal|0
operator|||
name|lport
operator|!=
operator|(
name|lport
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: port out of range.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|port
operator|=
name|lport
operator|&
literal|0xffff
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|ep
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|nprobes
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|!
operator|*
name|optarg
operator|||
operator|*
name|ep
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: invalid nprobes.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nprobes
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: nprobes must be>0.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|options
operator||=
name|SO_DONTROUTE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* 			 * set the ip source address of the outbound 			 * probe (e.g., on a multi-homed host). 			 */
name|source
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|ep
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|waittime
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|!
operator|*
name|optarg
operator|||
operator|*
name|ep
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: invalid wait time.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|waittime
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: wait must be>= 1 sec.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|max_hops
operator|<
name|first_hop
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: max hoplimit must be larger than first hoplimit.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|1
operator|||
name|argc
operator|>
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
if|#
directive|if
literal|1
name|setvbuf
argument_list|(
name|stdout
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_RAW
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|IPPROTO_ICMPV6
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_CANONNAME
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
operator|*
name|argv
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: %s\n"
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|ai_addrlen
operator|!=
sizeof|sizeof
argument_list|(
name|Dst
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: size of sockaddr mismatch\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|Dst
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|res
operator|->
name|ai_canonname
condition|?
name|strdup
argument_list|(
name|res
operator|->
name|ai_canonname
argument_list|)
else|:
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|!
name|hostname
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: not enough core\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|ai_next
condition|)
block|{
if|if
condition|(
name|getnameinfo
argument_list|(
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|,
name|hbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
operator|!=
literal|0
condition|)
name|strlcpy
argument_list|(
name|hbuf
argument_list|,
literal|"?"
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: Warning: %s has multiple "
literal|"addresses; using %s\n"
argument_list|,
name|hostname
argument_list|,
name|hbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|++
name|argv
condition|)
block|{
name|ep
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|datalen
operator|=
name|strtoul
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|||
operator|!
operator|*
name|argv
operator|||
operator|*
name|ep
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: invalid packet length.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|useicmp
condition|)
name|minlen
operator|=
name|ICMP6ECHOLEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tv32
argument_list|)
expr_stmt|;
else|else
name|minlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|opacket
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
operator|<
name|minlen
condition|)
name|datalen
operator|=
name|minlen
expr_stmt|;
elseif|else
if|if
condition|(
name|datalen
operator|>=
name|MAXPACKET
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: packet size must be %d<= s< %ld.\n"
argument_list|,
name|minlen
argument_list|,
operator|(
name|long
operator|)
name|MAXPACKET
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|outpacket
operator|=
operator|(
expr|struct
name|opacket
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outpacket
condition|)
block|{
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|outpacket
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
comment|/* initialize msghdr for receiving packets */
name|rcviov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|packet
expr_stmt|;
name|rcviov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|packet
argument_list|)
expr_stmt|;
name|rcvmhdr
operator|.
name|msg_name
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|Rcv
expr_stmt|;
name|rcvmhdr
operator|.
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|Rcv
argument_list|)
expr_stmt|;
name|rcvmhdr
operator|.
name|msg_iov
operator|=
name|rcviov
expr_stmt|;
name|rcvmhdr
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|rcvcmsglen
operator|=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
operator|+
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rcvcmsgbuf
operator|=
name|malloc
argument_list|(
name|rcvcmsglen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6: malloc failed\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rcvmhdr
operator|.
name|msg_control
operator|=
operator|(
name|caddr_t
operator|)
name|rcvcmsgbuf
expr_stmt|;
name|rcvmhdr
operator|.
name|msg_controllen
operator|=
name|rcvcmsglen
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|SO_DEBUG
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|rcvsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DEBUG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|SO_DONTROUTE
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|rcvsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DONTROUTE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
ifdef|#
directive|ifdef
name|IPSEC_POLICY_IPSEC
comment|/* 	 * do not raise error even if setsockopt fails, kernel may have ipsec 	 * turned off. 	 */
if|if
condition|(
name|setpolicy
argument_list|(
name|rcvsock
argument_list|,
literal|"in bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|setpolicy
argument_list|(
name|rcvsock
argument_list|,
literal|"out bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|level
init|=
name|IPSEC_LEVEL_NONE
decl_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|rcvsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_ESP_TRANS_LEVEL
argument_list|,
operator|&
name|level
argument_list|,
sizeof|sizeof
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|rcvsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_ESP_NETWORK_LEVEL
argument_list|,
operator|&
name|level
argument_list|,
sizeof|sizeof
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IP_AUTH_TRANS_LEVEL
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|rcvsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_AUTH_TRANS_LEVEL
argument_list|,
operator|&
name|level
argument_list|,
sizeof|sizeof
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|rcvsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_AUTH_LEVEL
argument_list|,
operator|&
name|level
argument_list|,
sizeof|sizeof
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IP_AUTH_NETWORK_LEVEL
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|rcvsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_AUTH_NETWORK_LEVEL
argument_list|,
operator|&
name|level
argument_list|,
sizeof|sizeof
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/*IPSEC_POLICY_IPSEC*/
endif|#
directive|endif
comment|/*IPSEC*/
comment|/* 	 * Send UDP or ICMP 	 */
if|if
condition|(
name|useicmp
condition|)
block|{
name|sndsock
operator|=
name|rcvsock
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sndsock
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket(SOCK_DGRAM)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SO_SNDBUF
name|i
operator|=
name|datalen
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"setsockopt(SO_SNDBUF)"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SO_SNDBUF */
if|if
condition|(
name|options
operator|&
name|SO_DEBUG
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DEBUG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|SO_DONTROUTE
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DONTROUTE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_RFC2292BIS
if|if
condition|(
name|rth
condition|)
block|{
comment|/* XXX: there is no library to finalize the header... */
name|rth
operator|->
name|ip6r_len
operator|=
name|rth
operator|->
name|ip6r_segleft
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_RTHDR
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rth
argument_list|,
operator|(
name|rth
operator|->
name|ip6r_len
operator|+
literal|1
operator|)
operator|<<
literal|3
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setsockopt(IPV6_RTHDR): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* old advanced API */
if|if
condition|(
name|cmsg
operator|!=
name|NULL
condition|)
block|{
name|inet6_rthdr_lasthop
argument_list|(
name|cmsg
argument_list|,
name|IPV6_RTHDR_LOOSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_PKTOPTIONS
argument_list|,
name|rtbuf
argument_list|,
name|cmsg
operator|->
name|cmsg_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setsockopt(IPV6_PKTOPTIONS): %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* USE_RFC2292BIS */
ifdef|#
directive|ifdef
name|IPSEC
ifdef|#
directive|ifdef
name|IPSEC_POLICY_IPSEC
comment|/* 	 * do not raise error even if setsockopt fails, kernel may have ipsec 	 * turned off. 	 */
if|if
condition|(
name|setpolicy
argument_list|(
name|sndsock
argument_list|,
literal|"in bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|setpolicy
argument_list|(
name|sndsock
argument_list|,
literal|"out bypass"
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|int
name|level
init|=
name|IPSEC_LEVEL_BYPASS
decl_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_ESP_TRANS_LEVEL
argument_list|,
operator|&
name|level
argument_list|,
sizeof|sizeof
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_ESP_NETWORK_LEVEL
argument_list|,
operator|&
name|level
argument_list|,
sizeof|sizeof
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IP_AUTH_TRANS_LEVEL
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_AUTH_TRANS_LEVEL
argument_list|,
operator|&
name|level
argument_list|,
sizeof|sizeof
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_AUTH_LEVEL
argument_list|,
operator|&
name|level
argument_list|,
sizeof|sizeof
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IP_AUTH_NETWORK_LEVEL
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_AUTH_NETWORK_LEVEL
argument_list|,
operator|&
name|level
argument_list|,
sizeof|sizeof
argument_list|(
name|level
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/*IPSEC_POLICY_IPSEC*/
endif|#
directive|endif
comment|/*IPSEC*/
comment|/* 	 * Source selection 	 */
name|bzero
argument_list|(
operator|&
name|Src
argument_list|,
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
condition|)
block|{
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|AF_INET6
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
comment|/*dummy*/
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|source
argument_list|,
literal|"0"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"traceroute6: %s: %s\n"
argument_list|,
name|source
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|->
name|ai_addrlen
operator|>
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"traceroute6: %s: %s\n"
argument_list|,
name|source
argument_list|,
name|gai_strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|Src
argument_list|,
name|res
operator|->
name|ai_addr
argument_list|,
name|res
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sockaddr_in6
name|Nxt
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|socklen_t
name|len
decl_stmt|;
name|Nxt
operator|=
name|Dst
expr_stmt|;
name|Nxt
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
name|DUMMY_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmsg
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|inet6_rthdr_getaddr
argument_list|(
name|cmsg
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|Nxt
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|Nxt
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dummy
operator|=
name|socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|dummy
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Nxt
argument_list|,
name|Nxt
operator|.
name|sin6_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|dummy
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Src
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"getsockname"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Src
argument_list|,
name|Src
operator|.
name|sin6_len
argument_list|,
name|src0
argument_list|,
sizeof|sizeof
argument_list|(
name|src0
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getnameinfo failed for source\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|source
operator|=
name|src0
expr_stmt|;
name|close
argument_list|(
name|dummy
argument_list|)
expr_stmt|;
block|}
name|Src
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sndsock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Src
argument_list|,
name|Src
operator|.
name|sin6_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|{
name|socklen_t
name|len
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|Src
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sndsock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Src
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"getsockname"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|srcport
operator|=
name|ntohs
argument_list|(
name|Src
operator|.
name|sin6_port
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Message to users 	 */
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Dst
argument_list|,
name|Dst
operator|.
name|sin6_len
argument_list|,
name|hbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
condition|)
name|strlcpy
argument_list|(
name|hbuf
argument_list|,
literal|"(invalid)"
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute6"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" to %s (%s)"
argument_list|,
name|hostname
argument_list|,
name|hbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" from %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", %lu hops max, %lu byte packets\n"
argument_list|,
name|max_hops
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_hop
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"Skipping %lu intermediate hops\n"
argument_list|,
name|first_hop
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Main loop 	 */
for|for
control|(
name|hops
operator|=
name|first_hop
init|;
name|hops
operator|<=
name|max_hops
condition|;
operator|++
name|hops
control|)
block|{
name|struct
name|in6_addr
name|lastaddr
decl_stmt|;
name|int
name|got_there
init|=
literal|0
decl_stmt|;
name|int
name|unreachable
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"%2lu "
argument_list|,
name|hops
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|lastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|lastaddr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|probe
operator|=
literal|0
init|;
name|probe
operator|<
name|nprobes
condition|;
operator|++
name|probe
control|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|timeval
name|t1
decl_stmt|,
name|t2
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|send_probe
argument_list|(
operator|++
name|seq
argument_list|,
name|hops
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|=
name|wait_for_reply
argument_list|(
name|rcvsock
argument_list|,
operator|&
name|rcvmhdr
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|packet_ok
argument_list|(
operator|&
name|rcvmhdr
argument_list|,
name|cc
argument_list|,
name|seq
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|Rcv
operator|.
name|sin6_addr
argument_list|,
operator|&
name|lastaddr
argument_list|)
condition|)
block|{
name|print
argument_list|(
operator|&
name|rcvmhdr
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|lastaddr
operator|=
name|Rcv
operator|.
name|sin6_addr
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  %.3f ms"
argument_list|,
name|deltaT
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|-
literal|1
condition|)
block|{
case|case
name|ICMP6_DST_UNREACH_NOROUTE
case|:
operator|++
name|unreachable
expr_stmt|;
name|printf
argument_list|(
literal|" !N"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP6_DST_UNREACH_ADMIN
case|:
operator|++
name|unreachable
expr_stmt|;
name|printf
argument_list|(
literal|" !P"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP6_DST_UNREACH_NOTNEIGHBOR
case|:
operator|++
name|unreachable
expr_stmt|;
name|printf
argument_list|(
literal|" !S"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP6_DST_UNREACH_ADDR
case|:
operator|++
name|unreachable
expr_stmt|;
name|printf
argument_list|(
literal|" !A"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP6_DST_UNREACH_NOPORT
case|:
if|if
condition|(
name|rcvhlim
operator|>=
literal|0
operator|&&
name|rcvhlim
operator|<=
literal|1
condition|)
name|printf
argument_list|(
literal|" !"
argument_list|)
expr_stmt|;
operator|++
name|got_there
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" *"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_there
operator|||
operator|(
name|unreachable
operator|>
literal|0
operator|&&
name|unreachable
operator|>=
operator|(
operator|(
name|nprobes
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
operator|)
condition|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|wait_for_reply
parameter_list|(
name|sock
parameter_list|,
name|mhdr
parameter_list|)
name|int
name|sock
decl_stmt|;
name|struct
name|msghdr
modifier|*
name|mhdr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HAVE_POLL
name|struct
name|pollfd
name|pfd
index|[
literal|1
index|]
decl_stmt|;
name|int
name|cc
init|=
literal|0
decl_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|sock
expr_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|pfd
index|[
literal|0
index|]
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|poll
argument_list|(
name|pfd
argument_list|,
literal|1
argument_list|,
name|waittime
operator|*
literal|1000
argument_list|)
operator|>
literal|0
condition|)
name|cc
operator|=
name|recvmsg
argument_list|(
name|rcvsock
argument_list|,
name|mhdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
else|#
directive|else
name|fd_set
modifier|*
name|fdsp
decl_stmt|;
name|struct
name|timeval
name|wait
decl_stmt|;
name|int
name|cc
init|=
literal|0
decl_stmt|,
name|fdsn
decl_stmt|;
name|fdsn
operator|=
name|howmany
argument_list|(
name|sock
operator|+
literal|1
argument_list|,
name|NFDBITS
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdsp
operator|=
operator|(
name|fd_set
operator|*
operator|)
name|malloc
argument_list|(
name|fdsn
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fdsp
argument_list|,
literal|0
argument_list|,
name|fdsn
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sock
argument_list|,
name|fdsp
argument_list|)
expr_stmt|;
name|wait
operator|.
name|tv_sec
operator|=
name|waittime
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|sock
operator|+
literal|1
argument_list|,
name|fdsp
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|wait
argument_list|)
operator|>
literal|0
condition|)
name|cc
operator|=
name|recvmsg
argument_list|(
name|rcvsock
argument_list|,
name|mhdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fdsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC_POLICY_IPSEC
end_ifdef

begin_function
name|int
name|setpolicy
parameter_list|(
name|so
parameter_list|,
name|policy
parameter_list|)
name|int
name|so
decl_stmt|;
name|char
modifier|*
name|policy
decl_stmt|;
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|ipsec_set_policy
argument_list|(
name|policy
argument_list|,
name|strlen
argument_list|(
name|policy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|ipsec_strerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|so
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_IPSEC_POLICY
argument_list|,
name|buf
argument_list|,
name|ipsec_get_policylen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|send_probe
parameter_list|(
name|seq
parameter_list|,
name|hops
parameter_list|)
name|int
name|seq
decl_stmt|;
name|u_long
name|hops
decl_stmt|;
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|tv32
name|tv32
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|hops
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_UNICAST_HOPS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"setsockopt IPV6_UNICAST_HOPS"
argument_list|)
expr_stmt|;
block|}
name|Dst
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
name|port
operator|+
name|seq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tv32
operator|.
name|tv32_sec
operator|=
name|htonl
argument_list|(
name|tv
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|tv32
operator|.
name|tv32_usec
operator|=
name|htonl
argument_list|(
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
if|if
condition|(
name|useicmp
condition|)
block|{
name|struct
name|icmp6_hdr
modifier|*
name|icp
init|=
operator|(
expr|struct
name|icmp6_hdr
operator|*
operator|)
name|outpacket
decl_stmt|;
name|icp
operator|->
name|icmp6_type
operator|=
name|ICMP6_ECHO_REQUEST
expr_stmt|;
name|icp
operator|->
name|icmp6_code
operator|=
literal|0
expr_stmt|;
name|icp
operator|->
name|icmp6_cksum
operator|=
literal|0
expr_stmt|;
name|icp
operator|->
name|icmp6_id
operator|=
name|ident
expr_stmt|;
name|icp
operator|->
name|icmp6_seq
operator|=
name|htons
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|tv32
argument_list|,
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
name|outpacket
operator|+
name|ICMP6ECHOLEN
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tv32
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|opacket
modifier|*
name|op
init|=
name|outpacket
decl_stmt|;
name|op
operator|->
name|seq
operator|=
name|seq
expr_stmt|;
name|op
operator|->
name|hops
operator|=
name|hops
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|tv32
argument_list|,
operator|&
name|op
operator|->
name|tv
argument_list|,
sizeof|sizeof
name|tv32
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|sendto
argument_list|(
name|sndsock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|outpacket
argument_list|,
name|datalen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Dst
argument_list|,
name|Dst
operator|.
name|sin6_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|!=
name|datalen
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"sendto"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"traceroute6: wrote %s %lu chars, ret=%d\n"
argument_list|,
name|hostname
argument_list|,
name|datalen
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|get_hoplim
parameter_list|(
name|mhdr
parameter_list|)
name|struct
name|msghdr
modifier|*
name|mhdr
decl_stmt|;
block|{
name|struct
name|cmsghdr
modifier|*
name|cm
decl_stmt|;
for|for
control|(
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|CMSG_FIRSTHDR
argument_list|(
name|mhdr
argument_list|)
init|;
name|cm
condition|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|CMSG_NXTHDR
argument_list|(
name|mhdr
argument_list|,
name|cm
argument_list|)
control|)
block|{
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|IPPROTO_IPV6
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|IPV6_HOPLIMIT
operator|&&
name|cm
operator|->
name|cmsg_len
operator|==
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
condition|)
return|return
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|double
name|deltaT
parameter_list|(
name|t1p
parameter_list|,
name|t2p
parameter_list|)
name|struct
name|timeval
modifier|*
name|t1p
decl_stmt|,
decl|*
name|t2p
decl_stmt|;
end_function

begin_block
block|{
name|double
name|dt
decl_stmt|;
name|dt
operator|=
call|(
name|double
call|)
argument_list|(
name|t2p
operator|->
name|tv_sec
operator|-
name|t1p
operator|->
name|tv_sec
argument_list|)
operator|*
literal|1000.0
operator|+
call|(
name|double
call|)
argument_list|(
name|t2p
operator|->
name|tv_usec
operator|-
name|t1p
operator|->
name|tv_usec
argument_list|)
operator|/
literal|1000.0
expr_stmt|;
return|return
operator|(
name|dt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Convert an ICMP "type" field to a printable string.  */
end_comment

begin_function
name|char
modifier|*
name|pr_type
parameter_list|(
name|t0
parameter_list|)
name|int
name|t0
decl_stmt|;
block|{
name|u_char
name|t
init|=
name|t0
operator|&
literal|0xff
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|ICMP6_DST_UNREACH
case|:
name|cp
operator|=
literal|"Destination Unreachable"
expr_stmt|;
break|break;
case|case
name|ICMP6_PACKET_TOO_BIG
case|:
name|cp
operator|=
literal|"Packet Too Big"
expr_stmt|;
break|break;
case|case
name|ICMP6_TIME_EXCEEDED
case|:
name|cp
operator|=
literal|"Time Exceeded"
expr_stmt|;
break|break;
case|case
name|ICMP6_PARAM_PROB
case|:
name|cp
operator|=
literal|"Parameter Problem"
expr_stmt|;
break|break;
case|case
name|ICMP6_ECHO_REQUEST
case|:
name|cp
operator|=
literal|"Echo Request"
expr_stmt|;
break|break;
case|case
name|ICMP6_ECHO_REPLY
case|:
name|cp
operator|=
literal|"Echo Reply"
expr_stmt|;
break|break;
case|case
name|ICMP6_MEMBERSHIP_QUERY
case|:
name|cp
operator|=
literal|"Group Membership Query"
expr_stmt|;
break|break;
case|case
name|ICMP6_MEMBERSHIP_REPORT
case|:
name|cp
operator|=
literal|"Group Membership Report"
expr_stmt|;
break|break;
case|case
name|ICMP6_MEMBERSHIP_REDUCTION
case|:
name|cp
operator|=
literal|"Group Membership Reduction"
expr_stmt|;
break|break;
case|case
name|ND_ROUTER_SOLICIT
case|:
name|cp
operator|=
literal|"Router Solicitation"
expr_stmt|;
break|break;
case|case
name|ND_ROUTER_ADVERT
case|:
name|cp
operator|=
literal|"Router Advertisement"
expr_stmt|;
break|break;
case|case
name|ND_NEIGHBOR_SOLICIT
case|:
name|cp
operator|=
literal|"Neighbor Solicitation"
expr_stmt|;
break|break;
case|case
name|ND_NEIGHBOR_ADVERT
case|:
name|cp
operator|=
literal|"Neighbor Advertisement"
expr_stmt|;
break|break;
case|case
name|ND_REDIRECT
case|:
name|cp
operator|=
literal|"Redirect"
expr_stmt|;
break|break;
default|default:
name|cp
operator|=
literal|"Unknown"
expr_stmt|;
break|break;
block|}
return|return
name|cp
return|;
block|}
end_function

begin_function
name|int
name|packet_ok
parameter_list|(
name|mhdr
parameter_list|,
name|cc
parameter_list|,
name|seq
parameter_list|)
name|struct
name|msghdr
modifier|*
name|mhdr
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|int
name|seq
decl_stmt|;
block|{
name|struct
name|icmp6_hdr
modifier|*
name|icp
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|from
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|mhdr
operator|->
name|msg_name
decl_stmt|;
name|u_char
name|type
decl_stmt|,
name|code
decl_stmt|;
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|mhdr
operator|->
name|msg_iov
index|[
literal|0
index|]
operator|.
name|iov_base
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
decl_stmt|;
name|int
modifier|*
name|hlimp
decl_stmt|;
name|char
name|hbuf
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|OLDRAWSOCKET
name|int
name|hlen
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OLDRAWSOCKET
name|ip
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|buf
expr_stmt|;
name|hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|from
argument_list|,
name|from
operator|->
name|sin6_len
argument_list|,
name|hbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
operator|!=
literal|0
condition|)
name|strlcpy
argument_list|(
name|hbuf
argument_list|,
literal|"invalid"
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"packet too short (%d bytes) from %s\n"
argument_list|,
name|cc
argument_list|,
name|hbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cc
operator|-=
name|hlen
expr_stmt|;
name|icp
operator|=
operator|(
expr|struct
name|icmp6_hdr
operator|*
operator|)
operator|(
name|buf
operator|+
name|hlen
operator|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|cc
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|from
argument_list|,
name|from
operator|->
name|sin6_len
argument_list|,
name|hbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
operator|!=
literal|0
condition|)
name|strlcpy
argument_list|(
name|hbuf
argument_list|,
literal|"invalid"
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data too short (%d bytes) from %s\n"
argument_list|,
name|cc
argument_list|,
name|hbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|icp
operator|=
operator|(
expr|struct
name|icmp6_hdr
operator|*
operator|)
name|buf
expr_stmt|;
endif|#
directive|endif
comment|/* get optional information via advanced API */
name|rcvpktinfo
operator|=
name|NULL
expr_stmt|;
name|hlimp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|CMSG_FIRSTHDR
argument_list|(
name|mhdr
argument_list|)
init|;
name|cm
condition|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|CMSG_NXTHDR
argument_list|(
name|mhdr
argument_list|,
name|cm
argument_list|)
control|)
block|{
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|IPPROTO_IPV6
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|IPV6_PKTINFO
operator|&&
name|cm
operator|->
name|cmsg_len
operator|==
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
condition|)
name|rcvpktinfo
operator|=
operator|(
expr|struct
name|in6_pktinfo
operator|*
operator|)
operator|(
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|IPPROTO_IPV6
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|IPV6_HOPLIMIT
operator|&&
name|cm
operator|->
name|cmsg_len
operator|==
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
condition|)
name|hlimp
operator|=
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rcvpktinfo
operator|==
name|NULL
operator|||
name|hlimp
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"failed to get received hop limit or packet info"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|return(0);
else|#
directive|else
name|rcvhlim
operator|=
literal|0
expr_stmt|;
comment|/*XXX*/
endif|#
directive|endif
block|}
else|else
name|rcvhlim
operator|=
operator|*
name|hlimp
expr_stmt|;
name|type
operator|=
name|icp
operator|->
name|icmp6_type
expr_stmt|;
name|code
operator|=
name|icp
operator|->
name|icmp6_code
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|ICMP6_TIME_EXCEEDED
operator|&&
name|code
operator|==
name|ICMP6_TIME_EXCEED_TRANSIT
operator|)
operator|||
name|type
operator|==
name|ICMP6_DST_UNREACH
condition|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|hip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|up
decl_stmt|;
name|hip
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|icp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|up
operator|=
name|get_udphdr
argument_list|(
name|hip
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|(
name|buf
operator|+
name|cc
operator|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|warnx
argument_list|(
literal|"failed to get upper layer header"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|useicmp
operator|&&
operator|(
operator|(
expr|struct
name|icmp6_hdr
operator|*
operator|)
name|up
operator|)
operator|->
name|icmp6_id
operator|==
name|ident
operator|&&
operator|(
operator|(
expr|struct
name|icmp6_hdr
operator|*
operator|)
name|up
operator|)
operator|->
name|icmp6_seq
operator|==
name|htons
argument_list|(
name|seq
argument_list|)
condition|)
return|return
operator|(
name|type
operator|==
name|ICMP6_TIME_EXCEEDED
condition|?
operator|-
literal|1
else|:
name|code
operator|+
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|useicmp
operator|&&
name|up
operator|->
name|uh_sport
operator|==
name|htons
argument_list|(
name|srcport
argument_list|)
operator|&&
name|up
operator|->
name|uh_dport
operator|==
name|htons
argument_list|(
name|port
operator|+
name|seq
argument_list|)
condition|)
return|return
operator|(
name|type
operator|==
name|ICMP6_TIME_EXCEEDED
condition|?
operator|-
literal|1
else|:
name|code
operator|+
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|useicmp
operator|&&
name|type
operator|==
name|ICMP6_ECHO_REPLY
condition|)
block|{
if|if
condition|(
name|icp
operator|->
name|icmp6_id
operator|==
name|ident
operator|&&
name|icp
operator|->
name|icmp6_seq
operator|==
name|htons
argument_list|(
name|seq
argument_list|)
condition|)
return|return
operator|(
name|ICMP6_DST_UNREACH_NOPORT
operator|+
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|char
name|sbuf
index|[
name|NI_MAXHOST
operator|+
literal|1
index|]
decl_stmt|,
name|dbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|u_int8_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|from
argument_list|,
name|from
operator|->
name|sin6_len
argument_list|,
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
operator|!=
literal|0
condition|)
name|strlcpy
argument_list|(
name|sbuf
argument_list|,
literal|"invalid"
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%d bytes from %s to %s"
argument_list|,
name|cc
argument_list|,
name|sbuf
argument_list|,
name|rcvpktinfo
condition|?
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|rcvpktinfo
operator|->
name|ipi6_addr
argument_list|,
name|dbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dbuf
argument_list|)
argument_list|)
else|:
literal|"?"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": icmp type %d (%s) code %d\n"
argument_list|,
name|type
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|icp
operator|->
name|icmp6_code
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|icp
operator|+
literal|1
operator|)
expr_stmt|;
define|#
directive|define
name|WIDTH
value|16
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
name|WIDTH
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%04x:"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|%
name|WIDTH
operator|==
name|WIDTH
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cc
operator|%
name|WIDTH
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Increment pointer until find the UDP or ICMP header.  */
end_comment

begin_function
name|struct
name|udphdr
modifier|*
name|get_udphdr
parameter_list|(
name|ip6
parameter_list|,
name|lim
parameter_list|)
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|u_char
modifier|*
name|lim
decl_stmt|;
block|{
name|u_char
modifier|*
name|cp
init|=
operator|(
name|u_char
operator|*
operator|)
name|ip6
decl_stmt|,
name|nh
decl_stmt|;
name|int
name|hlen
decl_stmt|;
if|if
condition|(
name|cp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
operator|>=
name|lim
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|nh
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|lim
operator|-
name|cp
operator|>=
literal|8
condition|)
block|{
switch|switch
condition|(
name|nh
condition|)
block|{
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_TCP
case|:
return|return
operator|(
name|NULL
operator|)
return|;
case|case
name|IPPROTO_ICMPV6
case|:
return|return
operator|(
name|useicmp
condition|?
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|cp
else|:
name|NULL
operator|)
return|;
case|case
name|IPPROTO_UDP
case|:
return|return
operator|(
name|useicmp
condition|?
name|NULL
else|:
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|cp
operator|)
return|;
case|case
name|IPPROTO_FRAGMENT
case|:
name|hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
name|nh
operator|=
operator|(
operator|(
expr|struct
name|ip6_frag
operator|*
operator|)
name|cp
operator|)
operator|->
name|ip6f_nxt
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
name|hlen
operator|=
operator|(
operator|(
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
name|cp
operator|)
operator|->
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
name|nh
operator|=
operator|(
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
name|cp
operator|)
operator|->
name|ip6e_nxt
expr_stmt|;
break|break;
default|default:
name|hlen
operator|=
operator|(
operator|(
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
name|cp
operator|)
operator|->
name|ip6e_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|nh
operator|=
operator|(
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
name|cp
operator|)
operator|->
name|ip6e_nxt
expr_stmt|;
break|break;
block|}
name|cp
operator|+=
name|hlen
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print
parameter_list|(
name|mhdr
parameter_list|,
name|cc
parameter_list|)
name|struct
name|msghdr
modifier|*
name|mhdr
decl_stmt|;
name|int
name|cc
decl_stmt|;
block|{
name|struct
name|sockaddr_in6
modifier|*
name|from
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|mhdr
operator|->
name|msg_name
decl_stmt|;
name|char
name|hbuf
index|[
name|NI_MAXHOST
index|]
decl_stmt|;
if|if
condition|(
name|getnameinfo
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|from
argument_list|,
name|from
operator|->
name|sin6_len
argument_list|,
name|hbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
operator|!=
literal|0
condition|)
name|strlcpy
argument_list|(
name|hbuf
argument_list|,
literal|"invalid"
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|hbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lflag
condition|)
name|printf
argument_list|(
literal|" %s (%s)"
argument_list|,
name|inetname
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|from
argument_list|)
argument_list|,
name|hbuf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inetname
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|from
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
ifdef|#
directive|ifdef
name|OLDRAWSOCKET
name|printf
argument_list|(
literal|" %d bytes to %s"
argument_list|,
name|cc
argument_list|,
name|rcvpktinfo
condition|?
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|rcvpktinfo
operator|->
name|ipi6_addr
argument_list|,
name|hbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|)
else|:
literal|"?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|" %d bytes of data to %s"
argument_list|,
name|cc
argument_list|,
name|rcvpktinfo
condition|?
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|rcvpktinfo
operator|->
name|ipi6_addr
argument_list|,
name|hbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|)
else|:
literal|"?"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Construct an Internet address representation.  * If the nflag has been supplied, give  * numeric value, otherwise try for symbolic name.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|inetname
parameter_list|(
name|sa
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
block|{
specifier|static
name|char
name|line
index|[
name|NI_MAXHOST
index|]
decl_stmt|,
name|domain
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|first
operator|&&
operator|!
name|nflag
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|domain
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|domain
argument_list|,
name|cp
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|domain
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|nflag
condition|)
block|{
if|if
condition|(
name|getnameinfo
argument_list|(
name|sa
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NAMEREQD
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|domain
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|line
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
condition|)
return|return
name|cp
return|;
if|if
condition|(
name|getnameinfo
argument_list|(
name|sa
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|,
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NI_NUMERICHOST
argument_list|)
operator|!=
literal|0
condition|)
name|strlcpy
argument_list|(
name|line
argument_list|,
literal|"invalid"
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|line
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: traceroute6 [-dIlnrv] [-f firsthop] [-g gateway] [-m hoplimit]\n"
literal|"       [-p port] [-q probes] [-s src] [-w waittime] target [datalen]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

