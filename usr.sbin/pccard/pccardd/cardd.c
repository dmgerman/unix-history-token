begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995 Andrew McRae.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: cardd.c,v 1.24 1998/02/04 20:19:39 guido Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_include
include|#
directive|include
file|"cardd.h"
end_include

begin_function_decl
specifier|static
name|struct
name|card_config
modifier|*
name|assign_driver
parameter_list|(
name|struct
name|card
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|assign_io
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_slot
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|card_inserted
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|card_removed
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pr_cmd
parameter_list|(
name|struct
name|cmd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_ether
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *	Dump configuration file data.  */
end_comment

begin_function
name|void
name|dump_config_file
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|card
modifier|*
name|cp
decl_stmt|;
name|struct
name|card_config
modifier|*
name|confp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|cards
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"Card manuf %s, vers %s\n"
argument_list|,
name|cp
operator|->
name|manuf
argument_list|,
name|cp
operator|->
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Configuration entries:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|confp
operator|=
name|cp
operator|->
name|config
init|;
name|confp
condition|;
name|confp
operator|=
name|confp
operator|->
name|next
control|)
name|printf
argument_list|(
literal|"\tIndex code = 0x%x, driver name = %s\n"
argument_list|,
name|confp
operator|->
name|index
argument_list|,
name|confp
operator|->
name|driver
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|insert
condition|)
block|{
name|printf
argument_list|(
literal|"Insert commands are:\n"
argument_list|)
expr_stmt|;
name|pr_cmd
argument_list|(
name|cp
operator|->
name|insert
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|remove
condition|)
block|{
name|printf
argument_list|(
literal|"Remove commands are:\n"
argument_list|)
expr_stmt|;
name|pr_cmd
argument_list|(
name|cp
operator|->
name|remove
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pr_cmd
parameter_list|(
name|struct
name|cmd
modifier|*
name|cp
parameter_list|)
block|{
while|while
condition|(
name|cp
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|cp
operator|->
name|line
argument_list|)
expr_stmt|;
name|cp
operator|=
name|cp
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	readslots - read all the PCMCIA slots, and build  *	a list of the slots.  */
end_comment

begin_function
name|void
name|readslots
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|name
index|[
literal|128
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|slot
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSLOT
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
name|CARD_DEVICE
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
continue|continue;
name|sp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|sp
operator|->
name|name
operator|=
name|newstr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sp
operator|->
name|slot
operator|=
name|i
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|empty
expr_stmt|;
comment|/* Check to see if the controller memory has been set up. */
if|if
condition|(
name|slots
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|mem
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCRWMEM
argument_list|,
operator|&
name|mem
argument_list|)
condition|)
name|logerr
argument_list|(
literal|"ioctl (PIOCRWMEM)"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|logmsg
argument_list|(
literal|"mem=0x%x\n"
argument_list|,
name|mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
block|{
name|mem
operator|=
name|alloc_memory
argument_list|(
literal|4
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
name|die
argument_list|(
literal|"can't allocate memory for controller access"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCRWMEM
argument_list|,
operator|&
name|mem
argument_list|)
condition|)
name|logerr
argument_list|(
literal|"ioctl (PIOCRWMEM)"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"%p %p\n"
argument_list|,
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|next
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|->
name|next
operator|=
name|slots
expr_stmt|;
name|slots
operator|=
name|sp
expr_stmt|;
name|slot_change
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	slot_change - Card status has changed.  *	read new state and process.  */
end_comment

begin_function
name|void
name|slot_change
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|slotstate
name|state
decl_stmt|;
name|current_slot
operator|=
name|sp
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCGSTATE
argument_list|,
operator|&
name|state
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|"ioctl (PIOCGSTATE)"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|state
operator|.
name|state
operator|==
name|sp
operator|->
name|state
condition|)
name|logmsg
argument_list|(
literal|"State same as before, continuing anyway"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|state
operator|.
name|state
condition|)
block|{
case|case
name|empty
case|:
case|case
name|noslot
case|:
name|card_removed
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|filled
case|:
comment|/* 		 * If state was already filled, fake a removal first to get 		 * our state in sync with the kernel. This happens when the 		 * systems resumes and we only get to process the state  		 * change from suspend to empty after inserted() has run. 		 * In that case the kernel state is perfectly normal. 		 * 		 * The reason for not doing nothing is that the kernel 		 * has to be informed again about IRQ and IO window. 		 */
if|if
condition|(
name|state
operator|.
name|state
operator|==
name|sp
operator|->
name|state
condition|)
name|card_removed
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|card_inserted
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|suspend
case|:
comment|/* ignored */
break|break;
block|}
name|sp
operator|->
name|state
operator|=
name|state
operator|.
name|state
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	card_removed - card has been removed from slot.  *	Execute the remove commands, and clear the slot's state.  *	Execute the device commands, then the driver commands  *	and then the card commands. This is the reverse  *	order to the insertion commands  */
end_comment

begin_function
name|void
name|card_removed
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|card
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|cis
condition|)
name|freecis
argument_list|(
name|sp
operator|->
name|cis
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|config
condition|)
block|{
name|sp
operator|->
name|config
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|sp
operator|->
name|card
operator|)
operator|!=
literal|0
condition|)
name|execute
argument_list|(
name|cp
operator|->
name|remove
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cis
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|config
operator|=
literal|0
expr_stmt|;
comment|/* release io */
name|bit_nset
argument_list|(
name|io_avail
argument_list|,
name|sp
operator|->
name|io
operator|.
name|addr
argument_list|,
name|sp
operator|->
name|io
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * card_inserted - Card has been inserted;  *	- Read the CIS  *	- match the card type.  *	- Match the driver and allocate a driver instance.  *	- Allocate I/O ports, memory and IRQ.  *	- Set up the slot.  *	- assign the driver (if failed, then terminate).  *	- Run the card commands.  *	- Run the driver commands  *	- Run the device commands  */
end_comment

begin_function
name|void
name|card_inserted
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|card
modifier|*
name|cp
decl_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cis
operator|=
name|readcis
argument_list|(
name|sp
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cis
operator|==
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"Error reading CIS on %s\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|dumpcis(sp->cis);
endif|#
directive|endif
for|for
control|(
name|cp
operator|=
name|cards
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|next
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|->
name|manuf
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|manuf
argument_list|,
name|CIS_MAXSTR
argument_list|)
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|cp
operator|->
name|version
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|vers
argument_list|,
name|CIS_MAXSTR
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|sp
operator|->
name|card
operator|=
name|cp
expr_stmt|;
if|#
directive|if
literal|0
block|reset_slot(sp);
endif|#
directive|endif
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"No card in database for \"%s\"(\"%s\")"
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|manuf
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|vers
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cp
operator|->
name|ether
condition|)
name|read_ether
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|config
operator|=
name|assign_driver
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|config
operator|==
literal|0
condition|)
block|{
name|execute
argument_list|(
name|cp
operator|->
name|insert
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|assign_io
argument_list|(
name|sp
argument_list|)
condition|)
block|{
name|logmsg
argument_list|(
literal|"Resource allocation failure for %s"
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|manuf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * 	 * Once assigned, set up the I/O& mem contexts, set up the 	 * windows, and then attach the driver. 	 */
if|if
condition|(
name|setup_slot
argument_list|(
name|sp
argument_list|)
condition|)
name|execute
argument_list|(
name|cp
operator|->
name|insert
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|else 		reset_slot(sp);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	read_ether - read ethernet address from card. Offset is  *	the offset into the attribute memory of the card.  */
end_comment

begin_function
specifier|static
name|void
name|read_ether
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|unsigned
name|char
name|net_addr
index|[
literal|12
index|]
decl_stmt|;
name|lseek
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|sp
operator|->
name|card
operator|->
name|ether
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|net_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|net_addr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|net_addr
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|"read err on net addr"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|eaddr
index|[
literal|0
index|]
operator|=
name|net_addr
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|eaddr
index|[
literal|1
index|]
operator|=
name|net_addr
index|[
literal|2
index|]
expr_stmt|;
name|sp
operator|->
name|eaddr
index|[
literal|2
index|]
operator|=
name|net_addr
index|[
literal|4
index|]
expr_stmt|;
name|sp
operator|->
name|eaddr
index|[
literal|3
index|]
operator|=
name|net_addr
index|[
literal|6
index|]
expr_stmt|;
name|sp
operator|->
name|eaddr
index|[
literal|4
index|]
operator|=
name|net_addr
index|[
literal|8
index|]
expr_stmt|;
name|sp
operator|->
name|eaddr
index|[
literal|5
index|]
operator|=
name|net_addr
index|[
literal|10
index|]
expr_stmt|;
name|logmsg
argument_list|(
literal|"Ether=%02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|0
index|]
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|1
index|]
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|2
index|]
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|3
index|]
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|4
index|]
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	assign_driver - Assign driver to card.  *	First, see if an existing driver is already setup.  */
end_comment

begin_function
specifier|static
name|struct
name|card_config
modifier|*
name|assign_driver
parameter_list|(
name|struct
name|card
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|driver
modifier|*
name|drvp
decl_stmt|;
name|struct
name|card_config
modifier|*
name|conf
decl_stmt|;
for|for
control|(
name|conf
operator|=
name|cp
operator|->
name|config
init|;
name|conf
condition|;
name|conf
operator|=
name|conf
operator|->
name|next
control|)
if|if
condition|(
name|conf
operator|->
name|inuse
operator|==
literal|0
operator|&&
name|conf
operator|->
name|driver
operator|->
name|card
operator|==
name|cp
operator|&&
name|conf
operator|->
name|driver
operator|->
name|config
operator|==
name|conf
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|logmsg
argument_list|(
literal|"Found existing driver (%s) for %s\n"
argument_list|,
name|conf
operator|->
name|driver
operator|->
name|name
argument_list|,
name|cp
operator|->
name|manuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|conf
operator|)
return|;
block|}
comment|/* 	 * New driver must be allocated. Find one that matches the 	 * any configurations not in use. 	 */
for|for
control|(
name|conf
operator|=
name|cp
operator|->
name|config
init|;
name|conf
condition|;
name|conf
operator|=
name|conf
operator|->
name|next
control|)
if|if
condition|(
name|conf
operator|->
name|inuse
operator|==
literal|0
operator|&&
name|conf
operator|->
name|driver
operator|->
name|card
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|conf
operator|==
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"No free configuration for card %s"
argument_list|,
name|cp
operator|->
name|manuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now we have a free driver and a matching configuration. 	 * Before assigning and allocating everything, check to 	 * see if a device class can be allocated to this. 	 */
name|drvp
operator|=
name|conf
operator|->
name|driver
expr_stmt|;
comment|/* If none available, then we can't use this card. */
if|if
condition|(
name|drvp
operator|->
name|inuse
condition|)
block|{
name|logmsg
argument_list|(
literal|"Driver already being used for %s"
argument_list|,
name|cp
operator|->
name|manuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Allocate a free IRQ if none has been specified */
if|if
condition|(
name|conf
operator|->
name|irq
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pool_irq
index|[
name|i
index|]
condition|)
block|{
name|conf
operator|->
name|irq
operator|=
name|i
expr_stmt|;
name|pool_irq
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|conf
operator|->
name|irq
operator|==
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"Failed to allocate IRQ for %s\n"
argument_list|,
name|cp
operator|->
name|manuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Allocate I/O and memory resources. */
block|for (ap = drvp->io; ap; ap = ap->next) { 		if (ap->addr == 0&& ap->size) { 			int     i = bit_fns(io_avail, IOPORTS, ap->size);  			if (i< 0) { 				logmsg("Failed to allocate I/O ports for %s\n", 				    cp->manuf); 				return (0); 			} 			ap->addr = i; 			bit_nclear(io_avail, i, ap->size); 		} 	} 	for (ap = drvp->mem; ap; ap = ap->next) { 		if (ap->addr == 0&& ap->size) { 			ap->addr = alloc_memory(ap->size); 			if (ap->addr == 0) { 				logmsg("Failed to allocate memory for %s\n", 				    cp->manuf); 				return (0); 			} 		} 	}
endif|#
directive|endif
comment|/* 0 */
name|drvp
operator|->
name|card
operator|=
name|cp
expr_stmt|;
name|drvp
operator|->
name|config
operator|=
name|conf
expr_stmt|;
name|drvp
operator|->
name|inuse
operator|=
literal|1
expr_stmt|;
name|conf
operator|->
name|inuse
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|conf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	assign_io - Allocate resources to slot matching the  *	configuration index selected.  */
end_comment

begin_function
specifier|static
name|int
name|assign_io
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|cis
modifier|*
name|cis
decl_stmt|;
name|struct
name|cis_config
modifier|*
name|cisconf
decl_stmt|,
modifier|*
name|defconf
decl_stmt|;
name|cis
operator|=
name|sp
operator|->
name|cis
expr_stmt|;
name|defconf
operator|=
name|cis
operator|->
name|def_config
expr_stmt|;
for|for
control|(
name|cisconf
operator|=
name|cis
operator|->
name|conf
init|;
name|cisconf
condition|;
name|cisconf
operator|=
name|cisconf
operator|->
name|next
control|)
if|if
condition|(
name|cisconf
operator|->
name|id
operator|==
name|sp
operator|->
name|config
operator|->
name|index
condition|)
break|break;
if|if
condition|(
name|cisconf
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sp
operator|->
name|card_config
operator|=
name|cisconf
expr_stmt|;
comment|/* 	 * Found a matching configuration. Now look at the I/O, memory and IRQ 	 * to create the desired parameters. Look at memory first. 	 */
if|if
condition|(
name|cisconf
operator|->
name|memspace
operator|||
operator|(
name|defconf
operator|&&
name|defconf
operator|->
name|memspace
operator|)
condition|)
block|{
name|struct
name|cis_memblk
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|cisconf
operator|->
name|mem
expr_stmt|;
if|if
condition|(
operator|!
name|cisconf
operator|->
name|memspace
condition|)
name|mp
operator|=
name|defconf
operator|->
name|mem
expr_stmt|;
name|sp
operator|->
name|mem
operator|.
name|size
operator|=
name|mp
operator|->
name|length
expr_stmt|;
name|sp
operator|->
name|mem
operator|.
name|cardaddr
operator|=
name|mp
operator|->
name|address
expr_stmt|;
comment|/* For now, we allocate our own memory from the pool. */
name|sp
operator|->
name|mem
operator|.
name|addr
operator|=
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|mem
expr_stmt|;
comment|/* 		 * Host memory address is required. Allocate one 		 * from our pool. 		 */
if|if
condition|(
name|sp
operator|->
name|mem
operator|.
name|size
operator|&&
name|sp
operator|->
name|mem
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|mem
operator|.
name|addr
operator|=
name|alloc_memory
argument_list|(
name|mp
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|mem
operator|.
name|addr
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|mem
operator|=
name|sp
operator|->
name|mem
operator|.
name|addr
expr_stmt|;
block|}
name|sp
operator|->
name|mem
operator|.
name|cardaddr
operator|=
literal|0x4000
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|logmsg
argument_list|(
literal|"Using mem addr 0x%x, size %d, card addr 0x%x\n"
argument_list|,
name|sp
operator|->
name|mem
operator|.
name|addr
argument_list|,
name|sp
operator|->
name|mem
operator|.
name|size
argument_list|,
name|sp
operator|->
name|mem
operator|.
name|cardaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Now look at I/O. */
name|bzero
argument_list|(
operator|&
name|sp
operator|->
name|io
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cisconf
operator|->
name|iospace
operator|||
operator|(
name|defconf
operator|&&
name|defconf
operator|->
name|iospace
operator|)
condition|)
block|{
name|struct
name|cis_config
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|cisconf
expr_stmt|;
if|if
condition|(
operator|!
name|cisconf
operator|->
name|iospace
condition|)
name|cp
operator|=
name|defconf
expr_stmt|;
comment|/*  		* If # of I/O lines decoded == 10, then card does its  		* own decoding.  		*  		* If an I/O block exists, then use it.  		* If no address (but a length) is available, allocate  		* from the pool.  		*/
if|if
condition|(
name|cp
operator|->
name|io
condition|)
block|{
name|sp
operator|->
name|io
operator|.
name|addr
operator|=
name|cp
operator|->
name|io
operator|->
name|addr
expr_stmt|;
name|sp
operator|->
name|io
operator|.
name|size
operator|=
name|cp
operator|->
name|io
operator|->
name|size
expr_stmt|;
block|}
else|else
comment|/* 			 * No I/O block, assume the address lines 			 * decode gives the size. 			 */
name|sp
operator|->
name|io
operator|.
name|size
operator|=
literal|1
operator|<<
name|cp
operator|->
name|io_addr
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|io
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
name|int
name|i
init|=
name|bit_fns
argument_list|(
name|io_avail
argument_list|,
name|IOPORTS
argument_list|,
name|sp
operator|->
name|io
operator|.
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sp
operator|->
name|io
operator|.
name|addr
operator|=
name|i
expr_stmt|;
block|}
name|bit_nclear
argument_list|(
name|io_avail
argument_list|,
name|sp
operator|->
name|io
operator|.
name|addr
argument_list|,
name|sp
operator|->
name|io
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* Set up the size to take into account the decode lines. */
name|sp
operator|->
name|io
operator|.
name|cardaddr
operator|=
name|cp
operator|->
name|io_addr
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|io_bus
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|sp
operator|->
name|io
operator|.
name|flags
operator|=
name|IODF_WS
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sp
operator|->
name|io
operator|.
name|flags
operator|=
name|IODF_WS
operator||
name|IODF_CS16
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sp
operator|->
name|io
operator|.
name|flags
operator|=
name|IODF_WS
operator||
name|IODF_CS16
operator||
name|IODF_16BIT
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|logmsg
argument_list|(
literal|"Using I/O addr 0x%x, size %d\n"
argument_list|,
name|sp
operator|->
name|io
operator|.
name|addr
argument_list|,
name|sp
operator|->
name|io
operator|.
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sp
operator|->
name|irq
operator|=
name|sp
operator|->
name|config
operator|->
name|irq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	setup_slot - Allocate the I/O and memory contexts  *	return true if completed OK.  */
end_comment

begin_function
specifier|static
name|int
name|setup_slot
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|mem_desc
name|mem
decl_stmt|;
name|struct
name|io_desc
name|io
decl_stmt|;
name|struct
name|dev_desc
name|drv
decl_stmt|;
name|struct
name|driver
modifier|*
name|drvp
init|=
name|sp
operator|->
name|config
operator|->
name|driver
decl_stmt|;
name|char
name|c
decl_stmt|;
name|off_t
name|offs
decl_stmt|;
name|int
name|rw_flags
decl_stmt|;
name|memset
argument_list|(
operator|&
name|io
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|io
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|drv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|drv
argument_list|)
expr_stmt|;
name|offs
operator|=
name|sp
operator|->
name|cis
operator|->
name|reg_addr
expr_stmt|;
name|rw_flags
operator|=
name|MDF_ATTR
expr_stmt|;
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCRWFLAG
argument_list|,
operator|&
name|rw_flags
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|offs
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0x80
expr_stmt|;
name|write
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
name|sp
operator|->
name|card
operator|->
name|reset_time
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|offs
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0x00
expr_stmt|;
name|write
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
name|sp
operator|->
name|card
operator|->
name|reset_time
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|offs
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|c
operator|=
name|sp
operator|->
name|config
operator|->
name|index
expr_stmt|;
name|c
operator||=
literal|0x40
expr_stmt|;
name|write
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|logmsg
argument_list|(
literal|"Setting config reg at offs 0x%lx to 0x%x, Reset time = %d ms\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offs
argument_list|,
name|c
argument_list|,
name|sp
operator|->
name|card
operator|->
name|reset_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
name|sp
operator|->
name|card
operator|->
name|reset_time
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* If other config registers exist, set them up. */
if|if
condition|(
name|sp
operator|->
name|cis
operator|->
name|ccrs
operator|&
literal|2
condition|)
block|{
comment|/* CCSR */
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cis
operator|->
name|def_config
operator|&&
name|sp
operator|->
name|cis
operator|->
name|def_config
operator|->
name|misc_valid
operator|&&
operator|(
name|sp
operator|->
name|cis
operator|->
name|def_config
operator|->
name|misc
operator|&
literal|0x8
operator|)
condition|)
name|c
operator||=
literal|0x08
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|card_config
operator|->
name|io_bus
operator|==
literal|1
condition|)
name|c
operator||=
literal|0x20
expr_stmt|;
name|lseek
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|offs
operator|+
literal|2
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mem
operator|.
name|window
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|mem
operator|.
name|addr
condition|)
block|{
name|mem
operator|.
name|window
operator|=
literal|0
expr_stmt|;
name|mem
operator|.
name|flags
operator|=
name|sp
operator|->
name|mem
operator|.
name|flags
operator||
name|MDF_ACTIVE
operator||
name|MDF_16BITS
expr_stmt|;
name|mem
operator|.
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|sp
operator|->
name|mem
operator|.
name|addr
expr_stmt|;
name|mem
operator|.
name|card
operator|=
name|sp
operator|->
name|mem
operator|.
name|cardaddr
expr_stmt|;
name|mem
operator|.
name|size
operator|=
name|sp
operator|->
name|mem
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCSMEM
argument_list|,
operator|&
name|mem
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|"ioctl (PIOCSMEM)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|io
operator|.
name|window
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|io
operator|.
name|size
condition|)
block|{
name|io
operator|.
name|flags
operator|=
name|sp
operator|->
name|io
operator|.
name|flags
expr_stmt|;
name|io
operator|.
name|start
operator|=
name|sp
operator|->
name|io
operator|.
name|addr
expr_stmt|;
name|io
operator|.
name|size
operator|=
name|sp
operator|->
name|io
operator|.
name|size
expr_stmt|;
if|#
directive|if
literal|0
block|io.start = sp->io.addr& ~((1<< sp->io.cardaddr) - 1); 		io.size = 1<< sp->io.cardaddr; 		if (io.start< 0x100) { 			io.start = 0x100; 			io.size = 0x300; 		}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|logmsg
argument_list|(
literal|"Assigning I/O window %d, start 0x%x, size 0x%x flags 0x%x\n"
argument_list|,
name|io
operator|.
name|window
argument_list|,
name|io
operator|.
name|start
argument_list|,
name|io
operator|.
name|size
argument_list|,
name|io
operator|.
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|io
operator|.
name|flags
operator||=
name|IODF_ACTIVE
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCSIO
argument_list|,
operator|&
name|io
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|"ioctl (PIOCSIO)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|strcpy
argument_list|(
name|drv
operator|.
name|name
argument_list|,
name|drvp
operator|->
name|kernel
argument_list|)
expr_stmt|;
name|drv
operator|.
name|unit
operator|=
name|drvp
operator|->
name|unit
expr_stmt|;
name|drv
operator|.
name|irqmask
operator|=
literal|1
operator|<<
name|sp
operator|->
name|irq
expr_stmt|;
name|drv
operator|.
name|flags
operator|=
literal|0x80
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|mem
operator|.
name|size
condition|)
block|{
name|drv
operator|.
name|mem
operator|=
name|sp
operator|->
name|mem
operator|.
name|addr
expr_stmt|;
name|drv
operator|.
name|memsize
operator|=
name|sp
operator|->
name|mem
operator|.
name|size
expr_stmt|;
block|}
else|else
block|{
name|drv
operator|.
name|mem
operator|=
literal|0
expr_stmt|;
name|drv
operator|.
name|memsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|io
operator|.
name|size
condition|)
name|drv
operator|.
name|iobase
operator|=
name|sp
operator|->
name|io
operator|.
name|addr
expr_stmt|;
else|else
name|drv
operator|.
name|iobase
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|logmsg
argument_list|(
literal|"Assign %s%d, io 0x%x, mem 0x%lx, %d bytes, irq %d, flags %x\n"
argument_list|,
name|drv
operator|.
name|name
argument_list|,
name|drv
operator|.
name|unit
argument_list|,
name|drv
operator|.
name|iobase
argument_list|,
name|drv
operator|.
name|mem
argument_list|,
name|drv
operator|.
name|memsize
argument_list|,
name|sp
operator|->
name|irq
argument_list|,
name|drv
operator|.
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the driver fails to be connected to the device, 	 * then it may mean that the driver did not recognise it. 	 */
name|memcpy
argument_list|(
name|drv
operator|.
name|misc
argument_list|,
name|sp
operator|->
name|eaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCSDRV
argument_list|,
operator|&
name|drv
argument_list|)
condition|)
block|{
name|logmsg
argument_list|(
literal|"driver allocation failed for %s"
argument_list|,
name|sp
operator|->
name|card
operator|->
name|manuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

