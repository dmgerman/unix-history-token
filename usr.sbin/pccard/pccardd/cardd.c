begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995 Andrew McRae.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"cardd.h"
end_include

begin_function_decl
specifier|static
name|struct
name|card_config
modifier|*
name|assign_driver
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|,
name|struct
name|card
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|assign_io
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setup_slot
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|card_inserted
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|card_removed
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pr_cmd
parameter_list|(
name|struct
name|cmd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_ether
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|read_ether_attr2
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|slot
modifier|*
name|slots
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Dump configuration file data.  */
end_comment

begin_function
name|void
name|dump_config_file
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|card
modifier|*
name|cp
decl_stmt|;
name|struct
name|card_config
modifier|*
name|confp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|cards
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"Card manuf %s, vers %s\n"
argument_list|,
name|cp
operator|->
name|manuf
argument_list|,
name|cp
operator|->
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Configuration entries:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|confp
operator|=
name|cp
operator|->
name|config
init|;
name|confp
condition|;
name|confp
operator|=
name|confp
operator|->
name|next
control|)
block|{
name|printf
argument_list|(
literal|"\tIndex code = "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|confp
operator|->
name|index_type
condition|)
block|{
case|case
name|DEFAULT_INDEX
case|:
name|printf
argument_list|(
literal|"default"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTO_INDEX
case|:
name|printf
argument_list|(
literal|"auto"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"0x%x"
argument_list|,
name|confp
operator|->
name|index
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|", driver name = %s\n"
argument_list|,
name|confp
operator|->
name|driver
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|insert
condition|)
block|{
name|printf
argument_list|(
literal|"Insert commands are:\n"
argument_list|)
expr_stmt|;
name|pr_cmd
argument_list|(
name|cp
operator|->
name|insert
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|remove
condition|)
block|{
name|printf
argument_list|(
literal|"Remove commands are:\n"
argument_list|)
expr_stmt|;
name|pr_cmd
argument_list|(
name|cp
operator|->
name|remove
argument_list|)
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pr_cmd
parameter_list|(
name|struct
name|cmd
modifier|*
name|cp
parameter_list|)
block|{
while|while
condition|(
name|cp
condition|)
block|{
name|printf
argument_list|(
literal|"\t%s\n"
argument_list|,
name|cp
operator|->
name|line
argument_list|)
expr_stmt|;
name|cp
operator|=
name|cp
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	readslots - read all the PCMCIA slots, and build  *	a list of the slots.  */
end_comment

begin_function
name|struct
name|slot
modifier|*
name|readslots
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|name
index|[
literal|128
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|;
name|struct
name|slot
modifier|*
name|sp
decl_stmt|;
name|slots
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSLOT
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
name|CARD_DEVICE
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
continue|continue;
name|sp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|sp
operator|->
name|name
operator|=
name|newstr
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|sp
operator|->
name|slot
operator|=
name|i
expr_stmt|;
comment|/* Check to see if the controller memory has been set up. */
if|if
condition|(
name|slots
operator|==
literal|0
condition|)
block|{
name|unsigned
name|long
name|mem
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCRWMEM
argument_list|,
operator|&
name|mem
argument_list|)
condition|)
name|logerr
argument_list|(
literal|"ioctl (PIOCRWMEM)"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|logmsg
argument_list|(
literal|"mem=0x%x\n"
argument_list|,
name|mem
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
block|{
name|mem
operator|=
name|alloc_memory
argument_list|(
literal|4
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|mem
operator|==
literal|0
condition|)
name|die
argument_list|(
literal|"can't allocate memory for "
literal|"controller access"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCRWMEM
argument_list|,
operator|&
name|mem
argument_list|)
condition|)
name|logerr
argument_list|(
literal|"ioctl (PIOCRWMEM)"
argument_list|)
expr_stmt|;
block|}
block|}
name|sp
operator|->
name|next
operator|=
name|slots
expr_stmt|;
name|slots
operator|=
name|sp
expr_stmt|;
name|slot_change
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|slots
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	slot_change - Card status has changed.  *	read new state and process.  */
end_comment

begin_function
name|void
name|slot_change
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|slotstate
name|state
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCGSTATE
argument_list|,
operator|&
name|state
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|"ioctl (PIOCGSTATE)"
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|state
operator|.
name|state
condition|)
block|{
case|case
name|empty
case|:
case|case
name|inactive
case|:
case|case
name|noslot
case|:
comment|/* Debounce potentially incorrectly reported removals */
if|if
condition|(
name|state
operator|.
name|laststate
operator|==
name|filled
operator|||
name|state
operator|.
name|laststate
operator|==
name|suspend
condition|)
name|card_removed
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|filled
case|:
comment|/* KLUDGE: if we were suspended, remove card */
if|if
condition|(
name|state
operator|.
name|laststate
operator|==
name|suspend
condition|)
name|card_removed
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|card_inserted
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|suspend
case|:
comment|/* ignored */
break|break;
block|}
name|sp
operator|->
name|state
operator|=
name|state
operator|.
name|state
expr_stmt|;
name|stat_changed
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	card_removed - card has been removed from slot.  *	Execute the remove commands, and clear the slot's state.  *	Execute the device commands, then the driver commands  *	and then the card commands. This is the reverse  *	order to the insertion commands  */
end_comment

begin_function
name|void
name|card_removed
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|card
modifier|*
name|cp
decl_stmt|;
name|struct
name|allocblk
modifier|*
name|sio
decl_stmt|;
name|int
name|in_use
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|config
operator|&&
name|sp
operator|->
name|config
operator|->
name|driver
operator|&&
name|sp
operator|->
name|card
condition|)
name|logmsg
argument_list|(
literal|"%s%d: %s removed."
argument_list|,
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|kernel
argument_list|,
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|unit
argument_list|,
name|sp
operator|->
name|card
operator|->
name|logstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cis
condition|)
name|freecis
argument_list|(
name|sp
operator|->
name|cis
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|config
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|config
operator|->
name|inuse
operator|&&
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|inuse
condition|)
name|in_use
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|config
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|sp
operator|->
name|card
operator|)
operator|!=
literal|0
operator|&&
name|in_use
condition|)
name|execute
argument_list|(
name|cp
operator|->
name|remove
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cis
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|config
operator|=
literal|0
expr_stmt|;
comment|/* release io */
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|IO_ASSIGNED
condition|)
for|for
control|(
name|sio
operator|=
operator|&
name|sp
operator|->
name|io
init|;
name|sio
condition|;
name|sio
operator|=
name|sio
operator|->
name|next
control|)
if|if
condition|(
name|sio
operator|->
name|addr
operator|&&
name|sio
operator|->
name|size
condition|)
name|bit_nset
argument_list|(
name|io_avail
argument_list|,
name|sio
operator|->
name|addr
argument_list|,
name|sio
operator|->
name|addr
operator|+
name|sio
operator|->
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* release irq */
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|IRQ_ASSIGNED
condition|)
if|if
condition|(
name|sp
operator|->
name|irq
operator|>=
literal|1
operator|&&
name|sp
operator|->
name|irq
operator|<=
literal|15
condition|)
name|pool_irq
index|[
name|sp
operator|->
name|irq
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CIS string comparison */
end_comment

begin_define
define|#
directive|define
name|REGCOMP_FLAGS
value|(REG_EXTENDED | REG_NOSUB)
end_define

begin_define
define|#
directive|define
name|REGEXEC_FLAGS
value|(0)
end_define

begin_function
specifier|static
name|int
name|cis_strcmp
parameter_list|(
name|char
modifier|*
name|db
parameter_list|,
name|char
modifier|*
name|cis
parameter_list|)
block|{
name|int
name|res
decl_stmt|,
name|err
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|regex_t
name|rx
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|db
operator|||
operator|!
name|cis
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|n
operator|=
name|strlen
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|2
operator|&&
name|db
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|db
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
comment|/* matching by regex */
name|db
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise, matching by strncmp() */
if|if
condition|(
name|n
operator|!=
name|strlen
argument_list|(
name|cis
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|strncmp
argument_list|(
name|db
argument_list|,
name|cis
argument_list|,
name|n
argument_list|)
return|;
block|}
name|p
operator|=
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
operator|+
literal|1
argument_list|,
name|db
argument_list|,
name|n
operator|-
literal|2
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'^'
expr_stmt|;
name|db
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|regcomp
argument_list|(
operator|&
name|rx
argument_list|,
name|p
argument_list|,
name|REGCOMP_FLAGS
argument_list|)
operator|)
condition|)
block|{
name|regerror
argument_list|(
name|err
argument_list|,
operator|&
name|rx
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|logmsg
argument_list|(
literal|"Warning: REGEX error for\"%s\" -- %s\n"
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|rx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|res
operator|=
name|regexec
argument_list|(
operator|&
name|rx
argument_list|,
name|cis
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|REGEXEC_FLAGS
argument_list|)
expr_stmt|;
name|regfree
argument_list|(
operator|&
name|rx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * card_inserted - Card has been inserted;  *	- Read the CIS  *	- match the card type.  *	- Match the driver and allocate a driver instance.  *	- Allocate I/O ports, memory and IRQ.  *	- Set up the slot.  *	- assign the driver (if failed, then terminate).  *	- Run the card commands.  *	- Run the driver commands  *	- Run the device commands  */
end_comment

begin_function
name|void
name|card_inserted
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|card
modifier|*
name|cp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|usleep
argument_list|(
name|pccard_init_sleep
argument_list|)
expr_stmt|;
name|sp
operator|->
name|cis
operator|=
name|readcis
argument_list|(
name|sp
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cis
operator|==
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"Error reading CIS on %s\n"
argument_list|,
name|sp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|dumpcis(sp->cis);
endif|#
directive|endif
for|for
control|(
name|cp
operator|=
name|cards
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|cp
operator|->
name|deftype
condition|)
block|{
case|case
name|DT_VERS
case|:
if|if
condition|(
name|cis_strcmp
argument_list|(
name|cp
operator|->
name|manuf
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|manuf
argument_list|)
operator|==
literal|0
operator|&&
name|cis_strcmp
argument_list|(
name|cp
operator|->
name|version
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|vers
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|add_info1
operator|!=
name|NULL
operator|&&
name|cis_strcmp
argument_list|(
name|cp
operator|->
name|add_info1
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|add_info1
argument_list|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|cp
operator|->
name|add_info2
operator|!=
name|NULL
operator|&&
name|cis_strcmp
argument_list|(
name|cp
operator|->
name|add_info2
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|add_info2
argument_list|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|logmsg
argument_list|(
literal|"Card \"%s\"(\"%s\") "
literal|"[%s] [%s] "
literal|"matched \"%s\" (\"%s\") "
literal|"[%s] [%s] "
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|manuf
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|vers
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|add_info1
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|add_info2
argument_list|,
name|cp
operator|->
name|manuf
argument_list|,
name|cp
operator|->
name|version
argument_list|,
name|cp
operator|->
name|add_info1
argument_list|,
name|cp
operator|->
name|add_info2
argument_list|)
expr_stmt|;
goto|goto
name|escape
goto|;
block|}
break|break;
case|case
name|DT_FUNC
case|:
if|if
condition|(
name|cp
operator|->
name|func_id
operator|==
name|sp
operator|->
name|cis
operator|->
name|func_id1
condition|)
block|{
name|logmsg
argument_list|(
literal|"Card \"%s\"(\"%s\") "
literal|"[%s] [%s] "
literal|"has function ID %d\n"
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|manuf
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|vers
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|add_info1
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|add_info2
argument_list|,
name|cp
operator|->
name|func_id
argument_list|)
expr_stmt|;
goto|goto
name|escape
goto|;
block|}
break|break;
default|default:
name|logmsg
argument_list|(
literal|"Unknown deftype %d\n"
argument_list|,
name|cp
operator|->
name|deftype
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|"cardd.c:card_inserted()"
argument_list|)
expr_stmt|;
block|}
block|}
name|escape
label|:
name|sp
operator|->
name|card
operator|=
name|cp
expr_stmt|;
if|#
directive|if
literal|0
block|reset_slot(sp);
endif|#
directive|endif
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"No card in database for \"%s\"(\"%s\")"
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|manuf
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|vers
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Copy CIS_MANUF_ID and CIS_FUNC_EXT from "struct cis" 	 * to "struct slot"  	 */
if|if
condition|(
name|sp
operator|->
name|cis
operator|->
name|lan_nid
operator|&&
name|sp
operator|->
name|cis
operator|->
name|lan_nid
index|[
literal|0
index|]
operator|==
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|eaddr
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|sp
operator|->
name|cis
operator|->
name|lan_nid
operator|+
literal|1
argument_list|,
name|sp
operator|->
name|eaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|eaddr
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|EADDR_CONFIGED
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|sp
operator|->
name|eaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|eaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|cis
operator|->
name|manufacturer
operator|&&
name|sp
operator|->
name|cis
operator|->
name|product
condition|)
block|{
name|sp
operator|->
name|manufacturer
operator|=
name|sp
operator|->
name|cis
operator|->
name|manufacturer
expr_stmt|;
name|sp
operator|->
name|product
operator|=
name|sp
operator|->
name|cis
operator|->
name|product
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cis
operator|->
name|prodext
condition|)
block|{
name|sp
operator|->
name|prodext
operator|=
name|sp
operator|->
name|cis
operator|->
name|prodext
expr_stmt|;
comment|/* For xe driver */
block|}
block|}
else|else
block|{
name|sp
operator|->
name|manufacturer
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|product
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|prodext
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|ether
condition|)
block|{
name|struct
name|ether
modifier|*
name|e
init|=
literal|0
decl_stmt|;
name|e
operator|=
name|cp
operator|->
name|ether
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|type
condition|)
block|{
case|case
name|ETHTYPE_ATTR2
case|:
name|read_ether_attr2
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|read_ether
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|config
operator|=
name|assign_driver
argument_list|(
name|sp
argument_list|,
name|cp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|err
operator|=
name|assign_io
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
name|char
modifier|*
name|reason
decl_stmt|;
switch|switch
condition|(
name|err
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|reason
operator|=
literal|"specified CIS was not found"
expr_stmt|;
break|break;
case|case
operator|-
literal|2
case|:
name|reason
operator|=
literal|"memory block allocation failed"
expr_stmt|;
break|break;
case|case
operator|-
literal|3
case|:
name|reason
operator|=
literal|"I/O block allocation failed"
expr_stmt|;
break|break;
case|case
operator|-
literal|4
case|:
name|reason
operator|=
literal|"requires more than one memory window"
expr_stmt|;
break|break;
default|default:
name|reason
operator|=
literal|"Unknown"
expr_stmt|;
break|break;
block|}
name|logmsg
argument_list|(
literal|"Resource allocation failure for \"%s\"(\"%s\") "
literal|"[%s] [%s]; Reason %s\n"
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|manuf
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|vers
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|add_info1
argument_list|,
name|sp
operator|->
name|cis
operator|->
name|add_info2
argument_list|,
name|reason
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * 	 * Once assigned, set up the I/O& mem contexts, set up the 	 * windows, and then attach the driver. 	 */
if|if
condition|(
name|setup_slot
argument_list|(
name|sp
argument_list|)
condition|)
name|execute
argument_list|(
name|cp
operator|->
name|insert
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|else 		reset_slot(sp);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	read_ether - read ethernet address from card. Offset is  *	the offset into the attribute memory of the card.  */
end_comment

begin_function
specifier|static
name|void
name|read_ether
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|unsigned
name|char
name|net_addr
index|[
literal|12
index|]
decl_stmt|;
name|int
name|flags
init|=
name|MDF_ATTR
decl_stmt|;
comment|/* attribute memory */
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCRWFLAG
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|sp
operator|->
name|card
operator|->
name|ether
operator|->
name|value
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|net_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|net_addr
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|net_addr
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|"read err on net addr"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|eaddr
index|[
literal|0
index|]
operator|=
name|net_addr
index|[
literal|0
index|]
expr_stmt|;
name|sp
operator|->
name|eaddr
index|[
literal|1
index|]
operator|=
name|net_addr
index|[
literal|2
index|]
expr_stmt|;
name|sp
operator|->
name|eaddr
index|[
literal|2
index|]
operator|=
name|net_addr
index|[
literal|4
index|]
expr_stmt|;
name|sp
operator|->
name|eaddr
index|[
literal|3
index|]
operator|=
name|net_addr
index|[
literal|6
index|]
expr_stmt|;
name|sp
operator|->
name|eaddr
index|[
literal|4
index|]
operator|=
name|net_addr
index|[
literal|8
index|]
expr_stmt|;
name|sp
operator|->
name|eaddr
index|[
literal|5
index|]
operator|=
name|net_addr
index|[
literal|10
index|]
expr_stmt|;
name|logmsg
argument_list|(
literal|"Ether=%02x:%02x:%02x:%02x:%02x:%02x\n"
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|0
index|]
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|1
index|]
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|2
index|]
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|3
index|]
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|4
index|]
argument_list|,
name|sp
operator|->
name|eaddr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|EADDR_CONFIGED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *      Megahertz X-Jack Ethernet uses unique way to get/set MAC  *      address of the card.  */
end_comment

begin_function
specifier|static
name|void
name|read_ether_attr2
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|hexaddr
decl_stmt|;
name|hexaddr
operator|=
name|sp
operator|->
name|cis
operator|->
name|add_info2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|sp
operator|->
name|eaddr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hexaddr
condition|)
return|return;
if|if
condition|(
name|strlen
argument_list|(
name|hexaddr
argument_list|)
operator|!=
literal|12
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|isxdigit
argument_list|(
name|hexaddr
index|[
name|i
index|]
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|u_int
name|d
decl_stmt|;
name|char
name|s
index|[
literal|3
index|]
decl_stmt|;
name|s
index|[
literal|0
index|]
operator|=
name|hexaddr
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
name|hexaddr
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
expr_stmt|;
name|s
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|s
argument_list|,
literal|"%x"
argument_list|,
operator|&
name|d
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
name|sp
operator|->
name|eaddr
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|eaddr
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|d
expr_stmt|;
block|}
name|sp
operator|->
name|flags
operator||=
name|EADDR_CONFIGED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	assign_driver - Assign driver to card.  *	First, see if an existing driver is already setup.  */
end_comment

begin_function
specifier|static
name|struct
name|card_config
modifier|*
name|assign_driver
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|,
name|struct
name|card
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|driver
modifier|*
name|drvp
decl_stmt|;
name|struct
name|card_config
modifier|*
name|conf
decl_stmt|;
name|struct
name|pccard_resource
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|irqmin
decl_stmt|,
name|irqmax
decl_stmt|;
for|for
control|(
name|conf
operator|=
name|cp
operator|->
name|config
init|;
name|conf
condition|;
name|conf
operator|=
name|conf
operator|->
name|next
control|)
if|if
condition|(
name|conf
operator|->
name|inuse
operator|==
literal|0
operator|&&
name|conf
operator|->
name|driver
operator|->
name|card
operator|==
name|cp
operator|&&
name|conf
operator|->
name|driver
operator|->
name|config
operator|==
name|conf
operator|&&
name|conf
operator|->
name|driver
operator|->
name|inuse
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug_level
operator|>
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"Found existing driver (%s) for %s\n"
argument_list|,
name|conf
operator|->
name|driver
operator|->
name|name
argument_list|,
name|cp
operator|->
name|manuf
argument_list|)
expr_stmt|;
block|}
name|conf
operator|->
name|driver
operator|->
name|inuse
operator|=
literal|1
expr_stmt|;
name|conf
operator|->
name|inuse
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|conf
operator|)
return|;
block|}
comment|/* 	 * New driver must be allocated. Find the first configuration 	 * not in use. 	 */
for|for
control|(
name|conf
operator|=
name|cp
operator|->
name|config
init|;
name|conf
condition|;
name|conf
operator|=
name|conf
operator|->
name|next
control|)
if|if
condition|(
name|conf
operator|->
name|inuse
operator|==
literal|0
operator|&&
name|conf
operator|->
name|driver
operator|->
name|inuse
comment|/*card*/
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|conf
operator|==
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"No free configuration for card %s"
argument_list|,
name|cp
operator|->
name|manuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Now we have a free driver and a matching configuration. 	 * Before assigning and allocating everything, check to 	 * see if a device class can be allocated to this. 	 */
name|drvp
operator|=
name|conf
operator|->
name|driver
expr_stmt|;
comment|/* If none available, then we can't use this card. */
if|if
condition|(
name|drvp
operator|->
name|inuse
condition|)
block|{
name|logmsg
argument_list|(
literal|"Driver already being used for %s"
argument_list|,
name|cp
operator|->
name|manuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Allocate a free IRQ if none has been specified.  When we're 	 * sharing interrupts (cardbus bridge case), then we'll use what 	 * the kernel tells us to use, reguardless of what the user 	 * configured.  Asking the kernel for IRQ 0 is our way of asking 	 * if we should use a shared interrupt. 	 */
name|res
operator|.
name|type
operator|=
name|SYS_RES_IRQ
expr_stmt|;
name|res
operator|.
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|conf
operator|->
name|irq
operator|==
literal|0
condition|)
block|{
name|irqmin
operator|=
literal|1
expr_stmt|;
name|irqmax
operator|=
literal|15
expr_stmt|;
block|}
else|else
block|{
name|irqmin
operator|=
name|irqmax
operator|=
name|conf
operator|->
name|irq
expr_stmt|;
name|conf
operator|->
name|irq
operator|=
literal|0
expr_stmt|;
comment|/* Make sure we get it. */
block|}
name|res
operator|.
name|min
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|max
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCSRESOURCE
argument_list|,
operator|&
name|res
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl (PIOCSRESOURCE)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|resource_addr
operator|!=
operator|~
literal|0ul
condition|)
block|{
name|conf
operator|->
name|irq
operator|=
name|res
operator|.
name|resource_addr
expr_stmt|;
name|pool_irq
index|[
name|conf
operator|->
name|irq
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|irqmin
init|;
name|i
operator|<=
name|irqmax
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Skip irqs not in the pool. 			 */
if|if
condition|(
name|pool_irq
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * -I forces us to use the interrupt, so use it. 			 */
if|if
condition|(
operator|!
name|use_kern_irq
condition|)
block|{
name|conf
operator|->
name|irq
operator|=
name|i
expr_stmt|;
name|pool_irq
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 			 * Ask the kernel if we have an free irq. 			 */
name|res
operator|.
name|min
operator|=
name|i
expr_stmt|;
name|res
operator|.
name|max
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCSRESOURCE
argument_list|,
operator|&
name|res
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl (PIOCSRESOURCE)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|resource_addr
operator|==
operator|~
literal|0ul
condition|)
continue|continue;
comment|/* 			 * res.resource_addr might be the kernel's 			 * better idea than i, so we have to check to 			 * see if that's in use too.  If not, mark it 			 * in use and break out of the loop.  I'm not 			 * sure this can happen when IRQ 0 above fails, 			 * but the test is cheap enough. 			 */
if|if
condition|(
name|pool_irq
index|[
name|res
operator|.
name|resource_addr
index|]
operator|==
literal|0
condition|)
continue|continue;
name|conf
operator|->
name|irq
operator|=
name|res
operator|.
name|resource_addr
expr_stmt|;
name|pool_irq
index|[
name|conf
operator|->
name|irq
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|conf
operator|->
name|irq
operator|==
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"Failed to allocate IRQ for %s\n"
argument_list|,
name|cp
operator|->
name|manuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|drvp
operator|->
name|card
operator|=
name|cp
expr_stmt|;
name|drvp
operator|->
name|config
operator|=
name|conf
expr_stmt|;
name|drvp
operator|->
name|inuse
operator|=
literal|1
expr_stmt|;
name|conf
operator|->
name|inuse
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|conf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Auto select config index  */
end_comment

begin_function
specifier|static
name|struct
name|cis_config
modifier|*
name|assign_card_index
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|,
name|struct
name|cis
modifier|*
name|cis
parameter_list|)
block|{
name|struct
name|cis_config
modifier|*
name|cp
decl_stmt|;
name|struct
name|cis_ioblk
modifier|*
name|cio
decl_stmt|;
name|struct
name|pccard_resource
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
name|res
operator|.
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cis
operator|->
name|conf
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|cp
operator|->
name|iospace
operator|||
operator|!
name|cp
operator|->
name|io
condition|)
continue|continue;
for|for
control|(
name|cio
operator|=
name|cp
operator|->
name|io
init|;
name|cio
condition|;
name|cio
operator|=
name|cio
operator|->
name|next
control|)
block|{
name|res
operator|.
name|size
operator|=
name|cio
operator|->
name|size
expr_stmt|;
name|res
operator|.
name|min
operator|=
name|cio
operator|->
name|addr
expr_stmt|;
name|res
operator|.
name|max
operator|=
name|res
operator|.
name|min
operator|+
name|cio
operator|->
name|size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCSRESOURCE
argument_list|,
operator|&
name|res
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl (PIOCSRESOURCE)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|resource_addr
operator|!=
name|cio
operator|->
name|addr
condition|)
goto|goto
name|next
goto|;
for|for
control|(
name|i
operator|=
name|cio
operator|->
name|addr
init|;
name|i
operator|<
name|cio
operator|->
name|addr
operator|+
name|cio
operator|->
name|size
operator|-
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|bit_test
argument_list|(
name|io_avail
argument_list|,
name|i
argument_list|)
condition|)
goto|goto
name|next
goto|;
block|}
return|return
name|cp
return|;
comment|/* found */
name|next
label|:
block|}
return|return
name|cis
operator|->
name|def_config
return|;
block|}
end_function

begin_comment
comment|/*  *	assign_io - Allocate resources to slot matching the  *	configuration index selected.  */
end_comment

begin_function
specifier|static
name|int
name|assign_io
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|cis
modifier|*
name|cis
decl_stmt|;
name|struct
name|cis_config
modifier|*
name|cisconf
decl_stmt|,
modifier|*
name|defconf
decl_stmt|;
name|cis
operator|=
name|sp
operator|->
name|cis
expr_stmt|;
name|defconf
operator|=
name|cis
operator|->
name|def_config
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|config
operator|->
name|index_type
condition|)
block|{
case|case
name|DEFAULT_INDEX
case|:
comment|/* default */
name|cisconf
operator|=
name|defconf
expr_stmt|;
name|sp
operator|->
name|config
operator|->
name|index
operator|=
name|cisconf
operator|->
name|id
expr_stmt|;
break|break;
case|case
name|AUTO_INDEX
case|:
comment|/* auto */
name|cisconf
operator|=
name|assign_card_index
argument_list|(
name|sp
argument_list|,
name|cis
argument_list|)
expr_stmt|;
if|if
condition|(
name|cisconf
condition|)
name|sp
operator|->
name|config
operator|->
name|index
operator|=
name|cisconf
operator|->
name|id
expr_stmt|;
break|break;
default|default:
comment|/* normal, use index value */
for|for
control|(
name|cisconf
operator|=
name|cis
operator|->
name|conf
init|;
name|cisconf
condition|;
name|cisconf
operator|=
name|cisconf
operator|->
name|next
control|)
if|if
condition|(
name|cisconf
operator|->
name|id
operator|==
name|sp
operator|->
name|config
operator|->
name|index
condition|)
break|break;
block|}
if|if
condition|(
name|cisconf
operator|==
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"Config id %d not present in this card"
argument_list|,
name|sp
operator|->
name|config
operator|->
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sp
operator|->
name|card_config
operator|=
name|cisconf
expr_stmt|;
comment|/* 	 * Found a matching configuration. Now look at the I/O, memory and IRQ 	 * to create the desired parameters. Look at memory first. 	 */
comment|/* Skip ed cards in PIO mode */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|name
argument_list|,
literal|"ed"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|config
operator|->
name|flags
operator|&
literal|0x10
operator|)
condition|)
goto|goto
name|memskip
goto|;
if|if
condition|(
name|cisconf
operator|->
name|memspace
operator|||
operator|(
name|defconf
operator|&&
name|defconf
operator|->
name|memspace
operator|)
condition|)
block|{
name|struct
name|cis_memblk
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|cisconf
operator|->
name|mem
expr_stmt|;
comment|/*  		 * Currently we do not handle the presence of multiple windows. 		 * Then again neither does the interface to the kernel! 		 * See setup_slot() and readcis.c:cis_conf() 		 */
if|if
condition|(
name|cisconf
operator|->
name|memwins
operator|>
literal|1
condition|)
block|{
name|logmsg
argument_list|(
literal|"Card requires %d memory windows."
argument_list|,
name|cisconf
operator|->
name|memwins
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cisconf
operator|->
name|memspace
condition|)
name|mp
operator|=
name|defconf
operator|->
name|mem
expr_stmt|;
name|sp
operator|->
name|mem
operator|.
name|size
operator|=
name|mp
operator|->
name|length
expr_stmt|;
name|sp
operator|->
name|mem
operator|.
name|cardaddr
operator|=
name|mp
operator|->
name|address
expr_stmt|;
comment|/* For now, we allocate our own memory from the pool. */
name|sp
operator|->
name|mem
operator|.
name|addr
operator|=
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|mem
expr_stmt|;
comment|/* 		 * Host memory address is required. Allocate one 		 * from our pool. 		 */
if|if
condition|(
name|sp
operator|->
name|mem
operator|.
name|size
operator|&&
name|sp
operator|->
name|mem
operator|.
name|addr
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|mem
operator|.
name|addr
operator|=
name|alloc_memory
argument_list|(
name|mp
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|mem
operator|.
name|addr
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|mem
operator|=
name|sp
operator|->
name|mem
operator|.
name|addr
expr_stmt|;
block|}
comment|/* Driver specific set up */
if|if
condition|(
name|strncmp
argument_list|(
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|name
argument_list|,
literal|"ed"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|mem
operator|.
name|cardaddr
operator|=
literal|0x4000
expr_stmt|;
name|sp
operator|->
name|mem
operator|.
name|flags
operator|=
name|MDF_ACTIVE
operator||
name|MDF_16BITS
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|mem
operator|.
name|flags
operator|=
name|MDF_ACTIVE
operator||
name|MDF_16BITS
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|mem
operator|.
name|flags
operator|&
name|MDF_ACTIVE
condition|)
name|sp
operator|->
name|flags
operator||=
name|MEM_ASSIGNED
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"Using mem addr 0x%x, size %d, card addr 0x%x, flags 0x%x\n"
argument_list|,
name|sp
operator|->
name|mem
operator|.
name|addr
argument_list|,
name|sp
operator|->
name|mem
operator|.
name|size
argument_list|,
name|sp
operator|->
name|mem
operator|.
name|cardaddr
argument_list|,
name|sp
operator|->
name|mem
operator|.
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
name|memskip
label|:
comment|/* Now look at I/O. */
name|bzero
argument_list|(
operator|&
name|sp
operator|->
name|io
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|io
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cisconf
operator|->
name|iospace
operator|||
operator|(
name|defconf
operator|&&
name|defconf
operator|->
name|iospace
operator|)
operator|||
name|sp
operator|->
name|card
operator|->
name|iosize
condition|)
block|{
name|struct
name|cis_config
modifier|*
name|cp
decl_stmt|;
name|struct
name|cis_ioblk
modifier|*
name|cio
decl_stmt|;
name|struct
name|allocblk
modifier|*
name|sio
decl_stmt|;
name|int
name|x
decl_stmt|,
name|xmax
decl_stmt|;
name|int
name|iosize
decl_stmt|;
name|cp
operator|=
name|cisconf
expr_stmt|;
if|if
condition|(
operator|!
name|cisconf
operator|->
name|iospace
condition|)
name|cp
operator|=
name|defconf
expr_stmt|;
name|iosize
operator|=
name|sp
operator|->
name|card
operator|->
name|iosize
expr_stmt|;
comment|/* iosize auto */
if|if
condition|(
name|iosize
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|io
condition|)
name|iosize
operator|=
name|cp
operator|->
name|io
operator|->
name|size
expr_stmt|;
else|else
name|iosize
operator|=
literal|1
operator|<<
name|cp
operator|->
name|io_addr
expr_stmt|;
block|}
comment|/*  		* If # of I/O lines decoded == 10, then card does its  		* own decoding.  		*  		* If an I/O block exists, then use it.  		* If no address (but a length) is available, allocate  		* from the pool.  		*/
name|cio
operator|=
name|cp
operator|->
name|io
expr_stmt|;
name|sio
operator|=
operator|&
operator|(
name|sp
operator|->
name|io
operator|)
expr_stmt|;
name|xmax
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|iosize
operator|==
literal|0
operator|&&
name|cio
condition|)
name|xmax
operator|=
name|cisconf
operator|->
name|io_blks
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|xmax
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|iosize
condition|)
block|{
name|sio
operator|->
name|addr
operator|=
literal|0
expr_stmt|;
name|sio
operator|->
name|size
operator|=
name|iosize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cio
condition|)
block|{
name|sio
operator|->
name|addr
operator|=
name|cio
operator|->
name|addr
expr_stmt|;
name|sio
operator|->
name|size
operator|=
name|cio
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * No I/O block, assume the address lines 				 * decode gives the size. 				 */
name|sio
operator|->
name|size
operator|=
literal|1
operator|<<
name|cp
operator|->
name|io_addr
expr_stmt|;
block|}
if|if
condition|(
name|sio
operator|->
name|addr
operator|==
literal|0
condition|)
block|{
name|struct
name|pccard_resource
name|res
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|res
operator|.
name|type
operator|=
name|SYS_RES_IOPORT
expr_stmt|;
name|res
operator|.
name|size
operator|=
name|sio
operator|->
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IOPORTS
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|bit_fns
argument_list|(
name|io_avail
argument_list|,
name|IOPORTS
argument_list|,
name|i
argument_list|,
name|sio
operator|->
name|size
argument_list|,
name|sio
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|&
operator|(
name|sio
operator|->
name|size
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|res
operator|.
name|min
operator|=
name|j
expr_stmt|;
name|res
operator|.
name|max
operator|=
name|j
operator|+
name|sio
operator|->
name|size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCSRESOURCE
argument_list|,
operator|&
name|res
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"ioctl (PIOCSRESOURCE)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|resource_addr
operator|==
name|j
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
else|else
block|{
name|sio
operator|->
name|addr
operator|=
name|j
expr_stmt|;
block|}
block|}
name|bit_nclear
argument_list|(
name|io_avail
argument_list|,
name|sio
operator|->
name|addr
argument_list|,
name|sio
operator|->
name|addr
operator|+
name|sio
operator|->
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|IO_ASSIGNED
expr_stmt|;
comment|/* Set up the size to take into account the decode lines. */
name|sio
operator|->
name|cardaddr
operator|=
name|cp
operator|->
name|io_addr
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|io_bus
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|sio
operator|->
name|flags
operator|=
name|IODF_WS
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sio
operator|->
name|flags
operator|=
name|IODF_WS
operator||
name|IODF_CS16
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sio
operator|->
name|flags
operator|=
name|IODF_WS
operator||
name|IODF_CS16
operator||
name|IODF_16BIT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|debug_level
operator|>
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"Using I/O addr 0x%x, size %d\n"
argument_list|,
name|sio
operator|->
name|addr
argument_list|,
name|sio
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cio
operator|&&
name|cio
operator|->
name|next
condition|)
block|{
name|sio
operator|->
name|next
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sio
argument_list|)
argument_list|)
expr_stmt|;
name|sio
operator|=
name|sio
operator|->
name|next
expr_stmt|;
name|cio
operator|=
name|cio
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
name|sp
operator|->
name|irq
operator|=
name|sp
operator|->
name|config
operator|->
name|irq
expr_stmt|;
name|sp
operator|->
name|flags
operator||=
name|IRQ_ASSIGNED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	setup_slot - Allocate the I/O and memory contexts  *	return true if completed OK.  */
end_comment

begin_function
specifier|static
name|int
name|setup_slot
parameter_list|(
name|struct
name|slot
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|mem_desc
name|mem
decl_stmt|;
name|struct
name|io_desc
name|io
decl_stmt|;
name|struct
name|dev_desc
name|drv
decl_stmt|;
name|struct
name|driver
modifier|*
name|drvp
init|=
name|sp
operator|->
name|config
operator|->
name|driver
decl_stmt|;
name|struct
name|allocblk
modifier|*
name|sio
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|c
decl_stmt|;
name|off_t
name|offs
decl_stmt|;
name|int
name|rw_flags
decl_stmt|;
name|int
name|iowin
decl_stmt|;
name|memset
argument_list|(
operator|&
name|io
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|io
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|drv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|drv
argument_list|)
expr_stmt|;
name|offs
operator|=
name|sp
operator|->
name|cis
operator|->
name|reg_addr
expr_stmt|;
name|rw_flags
operator|=
name|MDF_ATTR
expr_stmt|;
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCRWFLAG
argument_list|,
operator|&
name|rw_flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|RESET_MAY_BE_HARMFUL
name|lseek
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|offs
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0x80
expr_stmt|;
name|write
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
name|sp
operator|->
name|card
operator|->
name|reset_time
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|offs
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0x00
expr_stmt|;
name|write
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
name|sp
operator|->
name|card
operator|->
name|reset_time
operator|*
literal|1000
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lseek
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|offs
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|c
operator|=
name|sp
operator|->
name|config
operator|->
name|index
expr_stmt|;
name|c
operator||=
literal|0x40
expr_stmt|;
name|write
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_level
operator|>
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"Setting config reg at offs 0x%lx to 0x%x, "
literal|"Reset time = %d ms\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|offs
argument_list|,
name|c
argument_list|,
name|sp
operator|->
name|card
operator|->
name|reset_time
argument_list|)
expr_stmt|;
block|}
name|usleep
argument_list|(
name|pccard_init_sleep
argument_list|)
expr_stmt|;
name|usleep
argument_list|(
name|sp
operator|->
name|card
operator|->
name|reset_time
operator|*
literal|1000
argument_list|)
expr_stmt|;
comment|/* If other config registers exist, set them up. */
if|if
condition|(
name|sp
operator|->
name|cis
operator|->
name|ccrs
operator|&
literal|2
condition|)
block|{
comment|/* CCSR */
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|cis
operator|->
name|def_config
operator|&&
name|sp
operator|->
name|cis
operator|->
name|def_config
operator|->
name|misc_valid
operator|&&
operator|(
name|sp
operator|->
name|cis
operator|->
name|def_config
operator|->
name|misc
operator|&
literal|0x8
operator|)
condition|)
name|c
operator||=
literal|0x08
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|card_config
operator|->
name|io_bus
operator|==
literal|1
condition|)
name|c
operator||=
literal|0x20
expr_stmt|;
name|lseek
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|offs
operator|+
literal|2
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|MEM_ASSIGNED
condition|)
block|{
name|mem
operator|.
name|window
operator|=
literal|0
expr_stmt|;
name|mem
operator|.
name|flags
operator|=
name|sp
operator|->
name|mem
operator|.
name|flags
expr_stmt|;
name|mem
operator|.
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|sp
operator|->
name|mem
operator|.
name|addr
expr_stmt|;
name|mem
operator|.
name|card
operator|=
name|sp
operator|->
name|mem
operator|.
name|cardaddr
expr_stmt|;
name|mem
operator|.
name|size
operator|=
name|sp
operator|->
name|mem
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCSMEM
argument_list|,
operator|&
name|mem
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|"ioctl (PIOCSMEM)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|IO_ASSIGNED
condition|)
block|{
for|for
control|(
name|iowin
operator|=
literal|0
operator|,
name|sio
operator|=
operator|&
operator|(
name|sp
operator|->
name|io
operator|)
init|;
name|iowin
operator|<=
literal|1
condition|;
name|iowin
operator|++
control|)
block|{
name|io
operator|.
name|window
operator|=
name|iowin
expr_stmt|;
if|if
condition|(
name|sio
operator|->
name|size
condition|)
block|{
name|io
operator|.
name|flags
operator|=
name|sio
operator|->
name|flags
expr_stmt|;
name|io
operator|.
name|start
operator|=
name|sio
operator|->
name|addr
expr_stmt|;
name|io
operator|.
name|size
operator|=
name|sio
operator|->
name|size
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|io.start = sp->io.addr& ~((1<< sp->io.cardaddr) - 1); 		io.size = 1<< sp->io.cardaddr; 		if (io.start< 0x100) { 			io.start = 0x100; 			io.size = 0x300; 		}
endif|#
directive|endif
if|if
condition|(
name|debug_level
operator|>
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"Assigning I/O window %d, start 0x%x, "
literal|"size 0x%x flags 0x%x\n"
argument_list|,
name|io
operator|.
name|window
argument_list|,
name|io
operator|.
name|start
argument_list|,
name|io
operator|.
name|size
argument_list|,
name|io
operator|.
name|flags
argument_list|)
expr_stmt|;
block|}
name|io
operator|.
name|flags
operator||=
name|IODF_ACTIVE
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCSIO
argument_list|,
operator|&
name|io
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|"ioctl (PIOCSIO)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCGIO
argument_list|,
operator|&
name|io
argument_list|)
condition|)
block|{
name|logerr
argument_list|(
literal|"ioctl (PIOCGIO)"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|io
operator|.
name|start
operator|!=
name|sio
operator|->
name|addr
condition|)
block|{
name|logmsg
argument_list|(
literal|"I/O base address changed from 0x%x to 0x%x\n"
argument_list|,
name|sio
operator|->
name|addr
argument_list|,
name|io
operator|.
name|start
argument_list|)
expr_stmt|;
name|sio
operator|->
name|addr
operator|=
name|io
operator|.
name|start
expr_stmt|;
block|}
if|if
condition|(
name|sio
operator|->
name|next
condition|)
name|sio
operator|=
name|sio
operator|->
name|next
expr_stmt|;
else|else
break|break;
block|}
block|}
name|strcpy
argument_list|(
name|drv
operator|.
name|name
argument_list|,
name|drvp
operator|->
name|kernel
argument_list|)
expr_stmt|;
name|drv
operator|.
name|unit
operator|=
name|drvp
operator|->
name|unit
expr_stmt|;
name|drv
operator|.
name|irqmask
operator|=
literal|1
operator|<<
name|sp
operator|->
name|irq
expr_stmt|;
name|drv
operator|.
name|flags
operator|=
name|sp
operator|->
name|config
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|MEM_ASSIGNED
condition|)
block|{
name|drv
operator|.
name|mem
operator|=
name|sp
operator|->
name|mem
operator|.
name|addr
expr_stmt|;
name|drv
operator|.
name|memsize
operator|=
name|sp
operator|->
name|mem
operator|.
name|size
expr_stmt|;
block|}
else|else
block|{
name|drv
operator|.
name|mem
operator|=
literal|0
expr_stmt|;
name|drv
operator|.
name|memsize
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|flags
operator|&
name|IO_ASSIGNED
condition|)
name|drv
operator|.
name|iobase
operator|=
name|sp
operator|->
name|io
operator|.
name|addr
expr_stmt|;
else|else
name|drv
operator|.
name|iobase
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_DESC_HAS_SIZE
name|drv
operator|.
name|iosize
operator|=
name|sp
operator|->
name|io
operator|.
name|size
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|debug_level
operator|>
literal|0
condition|)
block|{
name|logmsg
argument_list|(
literal|"Assign %s%d, io 0x%x-0x%x, mem 0x%lx, %d bytes, "
literal|"irq %d, flags %x\n"
argument_list|,
name|drv
operator|.
name|name
argument_list|,
name|drv
operator|.
name|unit
argument_list|,
name|drv
operator|.
name|iobase
argument_list|,
name|drv
operator|.
name|iobase
operator|+
name|sp
operator|->
name|io
operator|.
name|size
operator|-
literal|1
argument_list|,
name|drv
operator|.
name|mem
argument_list|,
name|drv
operator|.
name|memsize
argument_list|,
name|sp
operator|->
name|irq
argument_list|,
name|drv
operator|.
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Copy CIS_MANUF_ID from "struct slot" to "struct dev_desc" 	 * This means moving CIS_MANUF_ID to kernel driver area. 	 */
name|drv
operator|.
name|manufacturer
operator|=
name|sp
operator|->
name|manufacturer
expr_stmt|;
name|drv
operator|.
name|product
operator|=
name|sp
operator|->
name|product
expr_stmt|;
name|drv
operator|.
name|prodext
operator|=
name|sp
operator|->
name|prodext
expr_stmt|;
comment|/* 	 * If the driver fails to be connected to the device, 	 * then it may mean that the driver did not recognise it. 	 */
name|memcpy
argument_list|(
name|drv
operator|.
name|misc
argument_list|,
name|sp
operator|->
name|eaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sp
operator|->
name|fd
argument_list|,
name|PIOCSDRV
argument_list|,
operator|&
name|drv
argument_list|)
condition|)
block|{
name|logmsg
argument_list|(
literal|"driver allocation failed for %s(%s): %s"
argument_list|,
name|sp
operator|->
name|card
operator|->
name|manuf
argument_list|,
name|sp
operator|->
name|card
operator|->
name|version
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|drv
operator|.
name|name
index|[
sizeof|sizeof
argument_list|(
name|drv
operator|.
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|drv
operator|.
name|name
argument_list|,
name|drvp
operator|->
name|kernel
argument_list|,
sizeof|sizeof
argument_list|(
name|drv
operator|.
name|name
argument_list|)
argument_list|)
condition|)
block|{
name|drvp
operator|->
name|kernel
operator|=
name|newstr
argument_list|(
name|drv
operator|.
name|name
argument_list|)
expr_stmt|;
name|p
operator|=
name|drvp
operator|->
name|kernel
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
block|{
name|drvp
operator|->
name|unit
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
name|logmsg
argument_list|(
literal|"%s%d: %s inserted."
argument_list|,
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|kernel
argument_list|,
name|sp
operator|->
name|config
operator|->
name|driver
operator|->
name|unit
argument_list|,
name|sp
operator|->
name|card
operator|->
name|logstr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

