begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Sun RPC is a product of Sun Microsystems, Inc. and is provided for  * unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify Sun RPC without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *   * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE  * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR  * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  *   * Sun RPC is provided with no support and without any obligation on the  * part of Sun Microsystems, Inc. to assist in its use, correction,  * modification or enhancement.  *   * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC  * OR ANY PART THEREOF.  *   * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *   * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)keyserv.c	1.15	94/04/25 SMI";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986 - 1991 by Sun Microsystems, Inc.  */
end_comment

begin_comment
comment|/*  * Keyserver  * Store secret keys per uid. Do public key encryption and decryption  * operations. Generate "random" keys.  * Do not talk to anything but a local root  * process on the local transport only  */
end_comment

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<rpc/des_crypt.h>
end_include

begin_include
include|#
directive|include
file|<rpc/des.h>
end_include

begin_include
include|#
directive|include
file|<rpc/key_prot.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/crypt.h>
end_include

begin_include
include|#
directive|include
file|"keyserv.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NGROUPS
end_ifndef

begin_define
define|#
directive|define
name|NGROUPS
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|KEYSERVSOCK
end_ifndef

begin_define
define|#
directive|define
name|KEYSERVSOCK
value|"/var/run/keyservsock"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|randomize
parameter_list|(
name|des_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getrootkey
parameter_list|(
name|des_block
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|root_auth
parameter_list|(
name|SVCXPRT
modifier|*
parameter_list|,
name|struct
name|svc_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|debugging
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|debugging
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|keyprogram
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|des_block
name|masterkey
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
name|ROOTKEY
index|[]
init|=
literal|"/etc/.rootkey"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hack to allow the keyserver to use AUTH_DES (for authenticated  * NIS+ calls, for example).  The only functions that get called  * are key_encryptsession_pk, key_decryptsession_pk, and key_gendes.  *  * The approach is to have the keyserver fill in pointers to local  * implementations of these functions, and to call those in key_call().  */
end_comment

begin_function_decl
specifier|extern
name|cryptkeyres
modifier|*
function_decl|(
modifier|*
name|__key_encryptsession_pk_LOCAL
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|cryptkeyres
modifier|*
function_decl|(
modifier|*
name|__key_decryptsession_pk_LOCAL
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|des_block
modifier|*
function_decl|(
modifier|*
name|__key_gendes_LOCAL
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|__des_crypt_LOCAL
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|cryptkeyres
modifier|*
name|key_encrypt_pk_2_svc_prog
parameter_list|(
name|uid_t
parameter_list|,
name|cryptkeyarg2
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|cryptkeyres
modifier|*
name|key_decrypt_pk_2_svc_prog
parameter_list|(
name|uid_t
parameter_list|,
name|cryptkeyarg2
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|des_block
modifier|*
name|key_gen_1_svc_prog
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|svc_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|nflag
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|warn
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|localhandle
decl_stmt|;
specifier|register
name|SVCXPRT
modifier|*
name|transp
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|nconf
init|=
name|NULL
decl_stmt|;
name|__key_encryptsession_pk_LOCAL
operator|=
operator|&
name|key_encrypt_pk_2_svc_prog
expr_stmt|;
name|__key_decryptsession_pk_LOCAL
operator|=
operator|&
name|key_decrypt_pk_2_svc_prog
expr_stmt|;
name|__key_gendes_LOCAL
operator|=
operator|&
name|key_gen_1_svc_prog
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ndDvp:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|pk_nodefaultkeys
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|debugging
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|warn
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|path
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|load_des
argument_list|(
name|warn
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|__des_crypt_LOCAL
operator|=
name|_my_crypt
expr_stmt|;
if|if
condition|(
name|svc_auth_reg
argument_list|(
name|AUTH_DES
argument_list|,
name|_svcauth_des
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"failed to register AUTH_DES authenticator"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Initialize 	 */
operator|(
name|void
operator|)
name|umask
argument_list|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|geteuid
argument_list|()
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"keyserv must be run as root"
argument_list|)
expr_stmt|;
name|setmodulus
argument_list|(
name|HEXMODULUS
argument_list|)
expr_stmt|;
name|getrootkey
argument_list|(
operator|&
name|masterkey
argument_list|,
name|nflag
argument_list|)
expr_stmt|;
name|rpcb_unset
argument_list|(
name|KEY_PROG
argument_list|,
name|KEY_VERS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rpcb_unset
argument_list|(
name|KEY_PROG
argument_list|,
name|KEY_VERS2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|svc_create
argument_list|(
name|keyprogram
argument_list|,
name|KEY_PROG
argument_list|,
name|KEY_VERS
argument_list|,
literal|"netpath"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unable to create service\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|svc_create
argument_list|(
name|keyprogram
argument_list|,
name|KEY_PROG
argument_list|,
name|KEY_VERS2
argument_list|,
literal|"netpath"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unable to create service\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|localhandle
operator|=
name|setnetconfig
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|nconf
operator|=
name|getnetconfig
argument_list|(
name|localhandle
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nconf
operator|->
name|nc_protofmly
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|nconf
operator|->
name|nc_protofmly
argument_list|,
name|NC_LOOPBACK
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|nconf
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"getnetconfig: %s"
argument_list|,
name|nc_sperror
argument_list|()
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|KEYSERVSOCK
argument_list|)
expr_stmt|;
name|rpcb_unset
argument_list|(
name|CRYPT_PROG
argument_list|,
name|CRYPT_VERS
argument_list|,
name|nconf
argument_list|)
expr_stmt|;
name|transp
operator|=
name|svcunix_create
argument_list|(
name|RPC_ANYSOCK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|KEYSERVSOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|transp
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"cannot create AF_LOCAL service"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_reg
argument_list|(
name|transp
argument_list|,
name|KEY_PROG
argument_list|,
name|KEY_VERS
argument_list|,
name|keyprogram
argument_list|,
name|nconf
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to register (KEY_PROG, KEY_VERS, unix)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_reg
argument_list|(
name|transp
argument_list|,
name|KEY_PROG
argument_list|,
name|KEY_VERS2
argument_list|,
name|keyprogram
argument_list|,
name|nconf
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to register (KEY_PROG, KEY_VERS2, unix)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_reg
argument_list|(
name|transp
argument_list|,
name|CRYPT_PROG
argument_list|,
name|CRYPT_VERS
argument_list|,
name|crypt_prog_1
argument_list|,
name|nconf
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to register (CRYPT_PROG, CRYPT_VERS, unix)"
argument_list|)
expr_stmt|;
name|endnetconfig
argument_list|(
name|localhandle
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|066
argument_list|)
expr_stmt|;
comment|/* paranoia */
if|if
condition|(
operator|!
name|debugging
condition|)
block|{
name|daemon
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|svc_run
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * In the event that we don't get a root password, we try to  * randomize the master key the best we can  */
end_comment

begin_function
specifier|static
name|void
name|randomize
parameter_list|(
name|master
parameter_list|)
name|des_block
modifier|*
name|master
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|__FreeBSD__
name|int
name|i
decl_stmt|;
name|int
name|seed
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|seed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|shift
operator|=
name|i
operator|%
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|seed
operator|^=
operator|(
name|tv
operator|.
name|tv_usec
operator|<<
name|shift
operator|)
operator||
operator|(
name|tv
operator|.
name|tv_usec
operator|>>
operator|(
literal|32
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|KEYSERV_RANDOM
ifdef|#
directive|ifdef
name|__FreeBSD__
name|master
operator|->
name|key
operator|.
name|low
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|master
operator|->
name|key
operator|.
name|high
operator|=
name|arc4random
argument_list|()
expr_stmt|;
else|#
directive|else
name|srandom
argument_list|(
name|seed
argument_list|)
expr_stmt|;
name|master
operator|->
name|key
operator|.
name|low
operator|=
name|random
argument_list|()
expr_stmt|;
name|master
operator|->
name|key
operator|.
name|high
operator|=
name|random
argument_list|()
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* use stupid dangerous bad rand() */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|sranddev
argument_list|()
expr_stmt|;
else|#
directive|else
name|srand
argument_list|(
name|seed
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|master
operator|->
name|key
operator|.
name|low
operator|=
name|rand
argument_list|()
expr_stmt|;
name|master
operator|->
name|key
operator|.
name|high
operator|=
name|rand
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Try to get root's secret key, by prompting if terminal is a tty, else trying  * from standard input.  * Returns 1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|getrootkey
parameter_list|(
name|master
parameter_list|,
name|prompt
parameter_list|)
name|des_block
modifier|*
name|master
decl_stmt|;
name|int
name|prompt
decl_stmt|;
block|{
name|char
modifier|*
name|passwd
decl_stmt|;
name|char
name|name
index|[
name|MAXNETNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|secret
index|[
name|HEXKEYBYTES
index|]
decl_stmt|;
name|key_netstarg
name|netstore
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|prompt
condition|)
block|{
comment|/* 		 * Read secret key out of ROOTKEY 		 */
name|fd
operator|=
name|open
argument_list|(
name|ROOTKEY
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|randomize
argument_list|(
name|master
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|secret
argument_list|,
name|HEXKEYBYTES
argument_list|)
operator|<
name|HEXKEYBYTES
condition|)
block|{
name|warnx
argument_list|(
literal|"the key read from %s was too short"
argument_list|,
name|ROOTKEY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getnetname
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"failed to generate host's netname when establishing root's key"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|netstore
operator|.
name|st_priv_key
argument_list|,
name|secret
argument_list|,
name|HEXKEYBYTES
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|netstore
operator|.
name|st_pub_key
argument_list|,
literal|0
argument_list|,
name|HEXKEYBYTES
argument_list|)
expr_stmt|;
name|netstore
operator|.
name|st_netname
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|pk_netput
argument_list|(
literal|0
argument_list|,
operator|&
name|netstore
argument_list|)
operator|!=
name|KEY_SUCCESS
condition|)
block|{
name|warnx
argument_list|(
literal|"could not set root's key and netname"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Decrypt yellow pages publickey entry to get secret key 	 */
name|passwd
operator|=
name|getpass
argument_list|(
literal|"root password:"
argument_list|)
expr_stmt|;
name|passwd2des
argument_list|(
name|passwd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|master
argument_list|)
expr_stmt|;
name|getnetname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getsecretkey
argument_list|(
name|name
argument_list|,
name|secret
argument_list|,
name|passwd
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"can't find %s's secret key"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|secret
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"password does not decrypt secret key for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|pk_setkey
argument_list|(
literal|0
argument_list|,
name|secret
argument_list|)
expr_stmt|;
comment|/* 	 * Store it for future use in $ROOTKEY, if possible 	 */
name|fd
operator|=
name|open
argument_list|(
name|ROOTKEY
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>
literal|0
condition|)
block|{
name|char
name|newline
init|=
literal|'\n'
decl_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|secret
argument_list|,
name|strlen
argument_list|(
name|secret
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|newline
argument_list|,
sizeof|sizeof
argument_list|(
name|newline
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Procedures to implement RPC service  */
end_comment

begin_function
name|char
modifier|*
name|strstatus
parameter_list|(
name|status
parameter_list|)
name|keystatus
name|status
decl_stmt|;
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|KEY_SUCCESS
case|:
return|return
operator|(
literal|"KEY_SUCCESS"
operator|)
return|;
case|case
name|KEY_NOSECRET
case|:
return|return
operator|(
literal|"KEY_NOSECRET"
operator|)
return|;
case|case
name|KEY_UNKNOWN
case|:
return|return
operator|(
literal|"KEY_UNKNOWN"
operator|)
return|;
case|case
name|KEY_SYSTEMERR
case|:
return|return
operator|(
literal|"KEY_SYSTEMERR"
operator|)
return|;
default|default:
return|return
operator|(
literal|"(bad result code)"
operator|)
return|;
block|}
block|}
end_function

begin_function
name|keystatus
modifier|*
name|key_set_1_svc_prog
parameter_list|(
name|uid
parameter_list|,
name|key
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
name|keybuf
name|key
decl_stmt|;
block|{
specifier|static
name|keystatus
name|status
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"set(%u, %.*s) = "
argument_list|,
name|uid
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|keybuf
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|pk_setkey
argument_list|(
name|uid
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|status
operator|)
return|;
block|}
end_function

begin_function
name|cryptkeyres
modifier|*
name|key_encrypt_pk_2_svc_prog
parameter_list|(
name|uid
parameter_list|,
name|arg
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
name|cryptkeyarg2
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|cryptkeyres
name|res
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"encrypt(%u, %s, %08x%08x) = "
argument_list|,
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|=
name|arg
operator|->
name|deskey
expr_stmt|;
name|res
operator|.
name|status
operator|=
name|pk_encrypt
argument_list|(
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
operator|&
operator|(
name|arg
operator|->
name|remotekey
operator|)
argument_list|,
operator|&
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|status
operator|==
name|KEY_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%08x%08x\n"
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|res
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|cryptkeyres
modifier|*
name|key_decrypt_pk_2_svc_prog
parameter_list|(
name|uid
parameter_list|,
name|arg
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
name|cryptkeyarg2
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|cryptkeyres
name|res
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"decrypt(%u, %s, %08x%08x) = "
argument_list|,
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|=
name|arg
operator|->
name|deskey
expr_stmt|;
name|res
operator|.
name|status
operator|=
name|pk_decrypt
argument_list|(
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
operator|&
operator|(
name|arg
operator|->
name|remotekey
operator|)
argument_list|,
operator|&
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|status
operator|==
name|KEY_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%08x%08x\n"
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|res
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|keystatus
modifier|*
name|key_net_put_2_svc_prog
parameter_list|(
name|uid
parameter_list|,
name|arg
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
name|key_netstarg
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|keystatus
name|status
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"net_put(%s, %.*s, %.*s) = "
argument_list|,
name|arg
operator|->
name|st_netname
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|arg
operator|->
name|st_pub_key
argument_list|)
argument_list|,
name|arg
operator|->
name|st_pub_key
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|arg
operator|->
name|st_priv_key
argument_list|)
argument_list|,
name|arg
operator|->
name|st_priv_key
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|status
operator|=
name|pk_netput
argument_list|(
name|uid
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|status
operator|)
return|;
block|}
end_function

begin_function
name|key_netstres
modifier|*
name|key_net_get_2_svc_prog
parameter_list|(
name|uid
parameter_list|,
name|arg
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|key_netstres
name|keynetname
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"net_get(%u) = "
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|keynetname
operator|.
name|status
operator|=
name|pk_netget
argument_list|(
name|uid
argument_list|,
operator|&
name|keynetname
operator|.
name|key_netstres_u
operator|.
name|knet
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
if|if
condition|(
name|keynetname
operator|.
name|status
operator|==
name|KEY_SUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<%s, %.*s, %.*s>\n"
argument_list|,
name|keynetname
operator|.
name|key_netstres_u
operator|.
name|knet
operator|.
name|st_netname
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|keynetname
operator|.
name|key_netstres_u
operator|.
name|knet
operator|.
name|st_pub_key
argument_list|)
argument_list|,
name|keynetname
operator|.
name|key_netstres_u
operator|.
name|knet
operator|.
name|st_pub_key
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|keynetname
operator|.
name|key_netstres_u
operator|.
name|knet
operator|.
name|st_priv_key
argument_list|)
argument_list|,
name|keynetname
operator|.
name|key_netstres_u
operator|.
name|knet
operator|.
name|st_priv_key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"NOT FOUND\n"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|keynetname
operator|)
return|;
block|}
end_function

begin_function
name|cryptkeyres
modifier|*
name|key_get_conv_2_svc_prog
parameter_list|(
name|uid
parameter_list|,
name|arg
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
name|keybuf
name|arg
decl_stmt|;
block|{
specifier|static
name|cryptkeyres
name|res
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"get_conv(%u, %.*s) = "
argument_list|,
name|uid
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|keybuf
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|res
operator|.
name|status
operator|=
name|pk_get_conv_key
argument_list|(
name|uid
argument_list|,
name|arg
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|status
operator|==
name|KEY_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%08x%08x\n"
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|res
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|cryptkeyres
modifier|*
name|key_encrypt_1_svc_prog
parameter_list|(
name|uid
parameter_list|,
name|arg
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
name|cryptkeyarg
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|cryptkeyres
name|res
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"encrypt(%u, %s, %08x%08x) = "
argument_list|,
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|=
name|arg
operator|->
name|deskey
expr_stmt|;
name|res
operator|.
name|status
operator|=
name|pk_encrypt
argument_list|(
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|status
operator|==
name|KEY_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%08x%08x\n"
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|res
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_function
name|cryptkeyres
modifier|*
name|key_decrypt_1_svc_prog
parameter_list|(
name|uid
parameter_list|,
name|arg
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
name|cryptkeyarg
modifier|*
name|arg
decl_stmt|;
block|{
specifier|static
name|cryptkeyres
name|res
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"decrypt(%u, %s, %08x%08x) = "
argument_list|,
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|arg
operator|->
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|=
name|arg
operator|->
name|deskey
expr_stmt|;
name|res
operator|.
name|status
operator|=
name|pk_decrypt
argument_list|(
name|uid
argument_list|,
name|arg
operator|->
name|remotename
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|status
operator|==
name|KEY_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%08x%08x\n"
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|high
argument_list|,
name|res
operator|.
name|cryptkeyres_u
operator|.
name|deskey
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|res
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|des_block
modifier|*
name|key_gen_1_svc_prog
parameter_list|(
name|v
parameter_list|,
name|s
parameter_list|)
name|void
modifier|*
name|v
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|timeval
name|time
decl_stmt|;
specifier|static
name|des_block
name|keygen
decl_stmt|;
specifier|static
name|des_block
name|key
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|time
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|keygen
operator|.
name|key
operator|.
name|high
operator|+=
operator|(
name|time
operator|.
name|tv_sec
operator|^
name|time
operator|.
name|tv_usec
operator|)
expr_stmt|;
name|keygen
operator|.
name|key
operator|.
name|low
operator|+=
operator|(
name|time
operator|.
name|tv_sec
operator|^
name|time
operator|.
name|tv_usec
operator|)
expr_stmt|;
name|ecb_crypt
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|masterkey
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|keygen
argument_list|,
sizeof|sizeof
argument_list|(
name|keygen
argument_list|)
argument_list|,
name|DES_ENCRYPT
operator||
name|DES_HW
argument_list|)
expr_stmt|;
name|key
operator|=
name|keygen
expr_stmt|;
name|des_setparity
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gen() = %08x%08x\n"
argument_list|,
name|key
operator|.
name|key
operator|.
name|high
argument_list|,
name|key
operator|.
name|key
operator|.
name|low
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|key
operator|)
return|;
block|}
end_function

begin_function
name|getcredres
modifier|*
name|key_getcred_1_svc_prog
parameter_list|(
name|uid
parameter_list|,
name|name
parameter_list|)
name|uid_t
name|uid
decl_stmt|;
name|netnamestr
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|getcredres
name|res
decl_stmt|;
specifier|static
name|u_int
name|gids
index|[
name|NGROUPS
index|]
decl_stmt|;
name|struct
name|unixcred
modifier|*
name|cred
decl_stmt|;
name|cred
operator|=
operator|&
name|res
operator|.
name|getcredres_u
operator|.
name|cred
expr_stmt|;
name|cred
operator|->
name|gids
operator|.
name|gids_val
operator|=
name|gids
expr_stmt|;
if|if
condition|(
operator|!
name|netname2user
argument_list|(
operator|*
name|name
argument_list|,
operator|(
name|uid_t
operator|*
operator|)
operator|&
name|cred
operator|->
name|uid
argument_list|,
operator|(
name|gid_t
operator|*
operator|)
operator|&
name|cred
operator|->
name|gid
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|cred
operator|->
name|gids
operator|.
name|gids_len
argument_list|,
operator|(
name|gid_t
operator|*
operator|)
name|gids
argument_list|)
condition|)
block|{
name|res
operator|.
name|status
operator|=
name|KEY_UNKNOWN
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|status
operator|=
name|KEY_SUCCESS
expr_stmt|;
block|}
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"getcred(%s) = "
argument_list|,
operator|*
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|status
operator|==
name|KEY_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uid=%d, gid=%d, grouplen=%d\n"
argument_list|,
name|cred
operator|->
name|uid
argument_list|,
name|cred
operator|->
name|gid
argument_list|,
name|cred
operator|->
name|gids
operator|.
name|gids_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|strstatus
argument_list|(
name|res
operator|.
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * RPC boilerplate  */
end_comment

begin_function
specifier|static
name|void
name|keyprogram
parameter_list|(
name|rqstp
parameter_list|,
name|transp
parameter_list|)
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
name|SVCXPRT
modifier|*
name|transp
decl_stmt|;
block|{
union|union
block|{
name|keybuf
name|key_set_1_arg
decl_stmt|;
name|cryptkeyarg
name|key_encrypt_1_arg
decl_stmt|;
name|cryptkeyarg
name|key_decrypt_1_arg
decl_stmt|;
name|netnamestr
name|key_getcred_1_arg
decl_stmt|;
name|cryptkeyarg
name|key_encrypt_2_arg
decl_stmt|;
name|cryptkeyarg
name|key_decrypt_2_arg
decl_stmt|;
name|netnamestr
name|key_getcred_2_arg
decl_stmt|;
name|cryptkeyarg2
name|key_encrypt_pk_2_arg
decl_stmt|;
name|cryptkeyarg2
name|key_decrypt_pk_2_arg
decl_stmt|;
name|key_netstarg
name|key_net_put_2_arg
decl_stmt|;
name|netobj
name|key_get_conv_2_arg
decl_stmt|;
block|}
name|argument
union|;
name|char
modifier|*
name|result
decl_stmt|;
name|xdrproc_t
name|xdr_argument
decl_stmt|,
name|xdr_result
decl_stmt|;
name|char
modifier|*
function_decl|(
modifier|*
name|local
function_decl|)
parameter_list|()
function_decl|;
name|uid_t
name|uid
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|check_auth
decl_stmt|;
switch|switch
condition|(
name|rqstp
operator|->
name|rq_proc
condition|)
block|{
case|case
name|NULLPROC
case|:
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_void
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
case|case
name|KEY_SET
case|:
name|xdr_argument
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_keybuf
expr_stmt|;
name|xdr_result
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_int
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_set_1_svc_prog
expr_stmt|;
name|check_auth
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_ENCRYPT
case|:
name|xdr_argument
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_cryptkeyarg
expr_stmt|;
name|xdr_result
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_cryptkeyres
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_encrypt_1_svc_prog
expr_stmt|;
name|check_auth
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_DECRYPT
case|:
name|xdr_argument
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_cryptkeyarg
expr_stmt|;
name|xdr_result
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_cryptkeyres
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_decrypt_1_svc_prog
expr_stmt|;
name|check_auth
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_GEN
case|:
name|xdr_argument
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_void
expr_stmt|;
name|xdr_result
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_des_block
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_gen_1_svc_prog
expr_stmt|;
name|check_auth
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_GETCRED
case|:
name|xdr_argument
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_netnamestr
expr_stmt|;
name|xdr_result
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_getcredres
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_getcred_1_svc_prog
expr_stmt|;
name|check_auth
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_ENCRYPT_PK
case|:
name|xdr_argument
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_cryptkeyarg2
expr_stmt|;
name|xdr_result
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_cryptkeyres
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_encrypt_pk_2_svc_prog
expr_stmt|;
name|check_auth
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_DECRYPT_PK
case|:
name|xdr_argument
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_cryptkeyarg2
expr_stmt|;
name|xdr_result
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_cryptkeyres
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_decrypt_pk_2_svc_prog
expr_stmt|;
name|check_auth
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_NET_PUT
case|:
name|xdr_argument
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_key_netstarg
expr_stmt|;
name|xdr_result
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_keystatus
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_net_put_2_svc_prog
expr_stmt|;
name|check_auth
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_NET_GET
case|:
name|xdr_argument
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_void
expr_stmt|;
name|xdr_result
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_key_netstres
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_net_get_2_svc_prog
expr_stmt|;
name|check_auth
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_GET_CONV
case|:
name|xdr_argument
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_keybuf
expr_stmt|;
name|xdr_result
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_cryptkeyres
expr_stmt|;
name|local
operator|=
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|()
operator|)
name|key_get_conv_2_svc_prog
expr_stmt|;
name|check_auth
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|svcerr_noproc
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|check_auth
condition|)
block|{
if|if
condition|(
name|root_auth
argument_list|(
name|transp
argument_list|,
name|rqstp
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not local privileged process\n"
argument_list|)
expr_stmt|;
block|}
name|svcerr_weakauth
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rqstp
operator|->
name|rq_cred
operator|.
name|oa_flavor
operator|!=
name|AUTH_SYS
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not unix authentication\n"
argument_list|)
expr_stmt|;
block|}
name|svcerr_weakauth
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|uid
operator|=
operator|(
operator|(
expr|struct
name|authsys_parms
operator|*
operator|)
name|rqstp
operator|->
name|rq_clntcred
operator|)
operator|->
name|aup_uid
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|argument
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|argument
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_getargs
argument_list|(
name|transp
argument_list|,
name|xdr_argument
argument_list|,
operator|&
name|argument
argument_list|)
condition|)
block|{
name|svcerr_decode
argument_list|(
name|transp
argument_list|)
expr_stmt|;
return|return;
block|}
name|result
operator|=
call|(
modifier|*
name|local
call|)
argument_list|(
name|uid
argument_list|,
operator|&
name|argument
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|transp
argument_list|,
name|xdr_result
argument_list|,
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to reply\n"
argument_list|)
expr_stmt|;
name|svcerr_systemerr
argument_list|(
name|transp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svc_freeargs
argument_list|(
name|transp
argument_list|,
name|xdr_argument
argument_list|,
operator|&
name|argument
argument_list|)
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to free arguments\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|root_auth
parameter_list|(
name|trans
parameter_list|,
name|rqstp
parameter_list|)
name|SVCXPRT
modifier|*
name|trans
decl_stmt|;
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
block|{
name|uid_t
name|uid
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|remote
decl_stmt|;
name|remote
operator|=
name|svc_getrpccaller
argument_list|(
name|trans
argument_list|)
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|remote
operator|->
name|sa_family
operator|!=
name|AF_UNIX
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"client didn't use AF_UNIX\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|__rpc_get_local_uid
argument_list|(
name|trans
argument_list|,
operator|&
name|uid
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"__rpc_get_local_uid failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"local_uid  %u\n"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|rqstp
operator|->
name|rq_cred
operator|.
name|oa_flavor
operator|==
name|AUTH_SYS
condition|)
block|{
if|if
condition|(
operator|(
call|(
name|uid_t
call|)
argument_list|(
operator|(
expr|struct
name|authunix_parms
operator|*
operator|)
name|rqstp
operator|->
name|rq_clntcred
argument_list|)
operator|->
name|aup_uid
operator|)
operator|==
name|uid
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"local_uid  %u mismatches auth %u\n"
argument_list|,
name|uid
argument_list|,
operator|(
call|(
name|uid_t
call|)
argument_list|(
operator|(
expr|struct
name|authunix_parms
operator|*
operator|)
name|rqstp
operator|->
name|rq_clntcred
argument_list|)
operator|->
name|aup_uid
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|debugging
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Not auth sys\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: keyserv [-n] [-D] [-d] [-v] [-p path]\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-d disables the use of default keys\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

