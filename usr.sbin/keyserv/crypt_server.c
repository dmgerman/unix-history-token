begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<rpc/des_crypt.h>
end_include

begin_include
include|#
directive|include
file|<rpc/des.h>
end_include

begin_include
include|#
directive|include
file|"crypt.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * The U.S. government stupidly believes that a) it can keep strong  * crypto code a secret and b) that doing so somehow protects national  * interests. It's wrong on both counts, but until it listens to reason  * we have to make certain compromises so it doesn't have an excuse to  * throw us in federal prison.  *  * Consequently, the core OS ships without DES support, and keyserv  * defaults to using ARCFOUR with only a 40 bit key, just like nutscrape.  * This breaks compatibility with Secure RPC on other systems, but it  * allows Secure RPC to work between FreeBSD systems that don't have the  * DES package installed without throwing security totally out the window.  *  * In order to avoid having to supply two versions of keyserv (one with  * DES and one without), we use dlopen() and friends to load libdes.so  * into our address space at runtime. We check for the presence of  * /usr/lib/libdes.so.3.0 at startup and load it if we find it. If we  * can't find it, or the __des_crypt symbol doesn't exist, we fall back  * to the ARCFOUR encryption code. The user can specify another path using  * the -p flag.  */
end_comment

begin_comment
comment|/* arcfour.h */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|arcfour_key
block|{
name|unsigned
name|char
name|state
index|[
literal|256
index|]
decl_stmt|;
name|unsigned
name|char
name|x
decl_stmt|;
name|unsigned
name|char
name|y
decl_stmt|;
block|}
name|arcfour_key
typedef|;
end_typedef

begin_function_decl
specifier|static
name|void
name|prepare_key
parameter_list|(
name|unsigned
name|char
modifier|*
name|key_data_ptr
parameter_list|,
name|int
name|key_data_len
parameter_list|,
name|arcfour_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arcfour
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer_ptr
parameter_list|,
name|int
name|buffer_len
parameter_list|,
name|arcfour_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap_byte
parameter_list|(
name|unsigned
name|char
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|prepare_key
parameter_list|(
name|unsigned
name|char
modifier|*
name|key_data_ptr
parameter_list|,
name|int
name|key_data_len
parameter_list|,
name|arcfour_key
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|char
name|index1
decl_stmt|;
name|unsigned
name|char
name|index2
decl_stmt|;
name|unsigned
name|char
modifier|*
name|state
decl_stmt|;
name|short
name|counter
decl_stmt|;
name|state
operator|=
operator|&
name|key
operator|->
name|state
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
literal|256
condition|;
name|counter
operator|++
control|)
name|state
index|[
name|counter
index|]
operator|=
name|counter
expr_stmt|;
name|key
operator|->
name|x
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|index1
operator|=
literal|0
expr_stmt|;
name|index2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
literal|256
condition|;
name|counter
operator|++
control|)
block|{
name|index2
operator|=
operator|(
name|key_data_ptr
index|[
name|index1
index|]
operator|+
name|state
index|[
name|counter
index|]
operator|+
name|index2
operator|)
operator|%
literal|256
expr_stmt|;
name|swap_byte
argument_list|(
operator|&
name|state
index|[
name|counter
index|]
argument_list|,
operator|&
name|state
index|[
name|index2
index|]
argument_list|)
expr_stmt|;
name|index1
operator|=
operator|(
name|index1
operator|+
literal|1
operator|)
operator|%
name|key_data_len
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arcfour
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer_ptr
parameter_list|,
name|int
name|buffer_len
parameter_list|,
name|arcfour_key
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|char
name|x
decl_stmt|;
name|unsigned
name|char
name|y
decl_stmt|;
name|unsigned
name|char
modifier|*
name|state
decl_stmt|;
name|unsigned
name|char
name|xorIndex
decl_stmt|;
name|short
name|counter
decl_stmt|;
name|x
operator|=
name|key
operator|->
name|x
expr_stmt|;
name|y
operator|=
name|key
operator|->
name|y
expr_stmt|;
name|state
operator|=
operator|&
name|key
operator|->
name|state
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|buffer_len
condition|;
name|counter
operator|++
control|)
block|{
name|x
operator|=
operator|(
name|x
operator|+
literal|1
operator|)
operator|%
literal|256
expr_stmt|;
name|y
operator|=
operator|(
name|state
index|[
name|x
index|]
operator|+
name|y
operator|)
operator|%
literal|256
expr_stmt|;
name|swap_byte
argument_list|(
operator|&
name|state
index|[
name|x
index|]
argument_list|,
operator|&
name|state
index|[
name|y
index|]
argument_list|)
expr_stmt|;
name|xorIndex
operator|=
operator|(
name|state
index|[
name|x
index|]
operator|+
name|state
index|[
name|y
index|]
operator|)
operator|%
literal|256
expr_stmt|;
name|buffer_ptr
index|[
name|counter
index|]
operator|^=
name|state
index|[
name|xorIndex
index|]
expr_stmt|;
block|}
name|key
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|key
operator|->
name|y
operator|=
name|y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swap_byte
parameter_list|(
name|unsigned
name|char
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
block|{
name|unsigned
name|char
name|swapByte
decl_stmt|;
name|swapByte
operator|=
operator|*
name|a
expr_stmt|;
operator|*
name|a
operator|=
operator|*
name|b
expr_stmt|;
operator|*
name|b
operator|=
name|swapByte
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dummy _des_crypt function that uses ARCFOUR with a 40 bit key */
end_comment

begin_function
name|int
name|_arcfour_crypt
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|desp
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|desparams
modifier|*
name|desp
decl_stmt|;
block|{
name|struct
name|arcfour_key
name|arcfourk
decl_stmt|;
comment|/* 	 * U.S. government anti-crypto weasels take 	 * note: although we are supplied with a 64 bit 	 * key, we're only passing 40 bits to the ARCFOUR 	 * encryption code. So there. 	 */
name|prepare_key
argument_list|(
name|desp
operator|->
name|des_key
argument_list|,
literal|5
argument_list|,
operator|&
name|arcfourk
argument_list|)
expr_stmt|;
name|arcfour
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|arcfourk
argument_list|)
expr_stmt|;
return|return
operator|(
name|DESERR_NOHWDEVICE
operator|)
return|;
block|}
end_function

begin_macro
name|int
argument_list|(
argument|*_my_crypt
argument_list|)
end_macro

begin_expr_stmt
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|desparams
operator|*
operator|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dlhandle
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_PATH_USRLIB
end_ifndef

begin_define
define|#
directive|define
name|_PATH_USRLIB
value|"/usr/lib"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LIBCRYPTO
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|OBJFORMAT_ELF
end_ifdef

begin_define
define|#
directive|define
name|LIBCRYPTO
value|"libcrypto.so.1"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LIBCRYPTO
value|"libcrypto.so.1."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OBJFORMAT_ELF */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|load_des
parameter_list|(
name|warn
parameter_list|,
name|libpath
parameter_list|)
name|int
name|warn
decl_stmt|;
name|char
modifier|*
name|libpath
decl_stmt|;
block|{
name|char
name|dlpath
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|libpath
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|OBJFORMAT_ELF
name|snprintf
argument_list|(
name|dlpath
argument_list|,
sizeof|sizeof
argument_list|(
name|dlpath
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|_PATH_USRLIB
argument_list|,
name|LIBCRYPTO
argument_list|)
expr_stmt|;
else|#
directive|else
name|len
operator|=
name|strlen
argument_list|(
name|LIBCRYPTO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dird
operator|=
name|opendir
argument_list|(
name|_PATH_USRLIB
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"opendir(/usr/lib) failed"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dirp
operator|=
name|readdir
argument_list|(
name|dird
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* must have a minor number */
if|if
condition|(
name|strlen
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|)
operator|<=
name|len
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
name|LIBCRYPTO
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
name|atoi
argument_list|(
operator|(
name|dirp
operator|->
name|d_name
operator|+
name|len
operator|+
literal|1
operator|)
argument_list|)
operator|>
name|minor
condition|)
block|{
name|minor
operator|=
name|atoi
argument_list|(
operator|(
name|dirp
operator|->
name|d_name
operator|+
name|len
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|dlpath
argument_list|,
sizeof|sizeof
argument_list|(
name|dlpath
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|_PATH_USRLIB
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|closedir
argument_list|(
name|dird
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJFORMAT_ELF */
block|}
else|else
name|snprintf
argument_list|(
name|dlpath
argument_list|,
sizeof|sizeof
argument_list|(
name|dlpath
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|libpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlpath
operator|!=
name|NULL
operator|&&
operator|(
name|dlhandle
operator|=
name|dlopen
argument_list|(
name|dlpath
argument_list|,
literal|0444
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
ifdef|#
directive|ifdef
name|OBJFORMAT_ELF
name|_my_crypt
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|dlsym
argument_list|(
name|dlhandle
argument_list|,
literal|"_des_crypt"
argument_list|)
expr_stmt|;
else|#
directive|else
name|_my_crypt
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|dlsym
argument_list|(
name|dlhandle
argument_list|,
literal|"__des_crypt"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OBJFORMAT_ELF */
if|if
condition|(
name|_my_crypt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dlhandle
operator|!=
name|NULL
condition|)
name|dlclose
argument_list|(
name|dlhandle
argument_list|)
expr_stmt|;
name|_my_crypt
operator|=
operator|&
name|_arcfour_crypt
expr_stmt|;
if|if
condition|(
name|warn
condition|)
block|{
name|printf
argument_list|(
literal|"DES support disabled -- using ARCFOUR instead.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Warning: ARCFOUR cipher is not compatible with "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"other Secure RPC implementations.\nInstall "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"the FreeBSD 'des' distribution to enable"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" DES encryption.\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|warn
condition|)
block|{
name|printf
argument_list|(
literal|"DES support enabled\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Using %s shared object.\n"
argument_list|,
name|dlpath
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|desresp
modifier|*
name|des_crypt_1_svc
parameter_list|(
name|desargs
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|desresp
name|result
decl_stmt|;
name|struct
name|desparams
name|dparm
decl_stmt|;
if|if
condition|(
name|argp
operator|->
name|desbuf
operator|.
name|desbuf_len
operator|>
name|DES_MAXDATA
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|DESERR_BADPARAM
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|argp
operator|->
name|des_key
argument_list|,
name|dparm
operator|.
name|des_key
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|argp
operator|->
name|des_ivec
argument_list|,
name|dparm
operator|.
name|des_ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|dparm
operator|.
name|des_mode
operator|=
name|argp
operator|->
name|des_mode
expr_stmt|;
name|dparm
operator|.
name|des_dir
operator|=
name|argp
operator|->
name|des_dir
expr_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_DES
name|dparm
operator|.
name|UDES
operator|.
name|UDES_buf
operator|=
name|argp
operator|->
name|desbuf
operator|.
name|desbuf_val
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX This compensates for a bug in the libdes Secure RPC 	 * compat interface. (Actually, there are a couple.) The 	 * des_ecb_encrypt() routine in libdes only encrypts 8 bytes 	 * (64 bits) at a time. However, the Sun Secure RPC ecb_crypt() 	 * routine is supposed to be able to handle buffers up to 8Kbytes. 	 * The rpc_enc module in libdes ignores this fact and just drops 	 * the length parameter on the floor, encrypting only the 	 * first 64 bits of whatever buffer you feed it. We deal with 	 * this here: if we're using DES encryption, and we're using 	 * ECB mode, then we make a pass over the entire buffer 	 * ourselves. Note: the rpc_enc module incorrectly transposes 	 * the mode flags, so when you ask for CBC mode, you're really 	 * getting ECB mode. 	 */
ifdef|#
directive|ifdef
name|BROKEN_DES
if|if
condition|(
name|_my_crypt
operator|!=
operator|&
name|_arcfour_crypt
operator|&&
name|argp
operator|->
name|des_mode
operator|==
name|CBC
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|_my_crypt
operator|!=
operator|&
name|_arcfour_crypt
operator|&&
name|argp
operator|->
name|des_mode
operator|==
name|ECB
condition|)
block|{
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|dptr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argp
operator|->
name|desbuf
operator|.
name|desbuf_len
operator|/
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|dptr
operator|=
name|argp
operator|->
name|desbuf
operator|.
name|desbuf_val
expr_stmt|;
name|dptr
operator|+=
operator|(
name|i
operator|*
literal|8
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_DES
name|dparm
operator|.
name|UDES
operator|.
name|UDES_buf
operator|=
name|dptr
expr_stmt|;
endif|#
directive|endif
name|result
operator|.
name|stat
operator|=
name|_my_crypt
argument_list|(
name|dptr
argument_list|,
literal|8
argument_list|,
operator|&
name|dparm
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|result
operator|.
name|stat
operator|=
name|_my_crypt
argument_list|(
name|argp
operator|->
name|desbuf
operator|.
name|desbuf_val
argument_list|,
name|argp
operator|->
name|desbuf
operator|.
name|desbuf_len
argument_list|,
operator|&
name|dparm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|DESERR_NONE
operator|||
name|result
operator|.
name|stat
operator|==
name|DESERR_NOHWDEVICE
condition|)
block|{
name|bcopy
argument_list|(
name|dparm
operator|.
name|des_ivec
argument_list|,
name|result
operator|.
name|des_ivec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|result
operator|.
name|desbuf
operator|.
name|desbuf_len
operator|=
name|argp
operator|->
name|desbuf
operator|.
name|desbuf_len
expr_stmt|;
name|result
operator|.
name|desbuf
operator|.
name|desbuf_val
operator|=
name|argp
operator|->
name|desbuf
operator|.
name|desbuf_val
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
end_function

end_unit

