begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * main.c - Point-to-Point Protocol main module  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: main.c,v 1.3 1995/04/29 13:55:34 ache Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SETSID
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_comment
comment|/*  * If REQ_SYSOPTIONS is defined to 1, pppd will not run unless  * /etc/ppp/options exists.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REQ_SYSOPTIONS
end_ifndef

begin_define
define|#
directive|define
name|REQ_SYSOPTIONS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SGTTY
end_ifdef

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|sun
end_ifndef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|"callout.h"
end_include

begin_include
include|#
directive|include
file|"ppp.h"
end_include

begin_include
include|#
directive|include
file|"magic.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"upap.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"pppd.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|(1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*TRUE*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*FALSE*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PIDPATH
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pidpath
init|=
name|PIDPATH
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filename in which pid will be stored */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pidpath
init|=
name|_PATH_PIDFILE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PIDFILE */
end_comment

begin_comment
comment|/* interface vars */
end_comment

begin_decl_stmt
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interface name */
end_comment

begin_decl_stmt
name|int
name|ifunit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interface unit number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of this program */
end_comment

begin_decl_stmt
name|char
modifier|*
name|username
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|hostname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our hostname */
end_comment

begin_decl_stmt
name|char
name|our_name
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|remote_name
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pidfilename
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pid_t
name|pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our pid */
end_comment

begin_decl_stmt
specifier|static
name|pid_t
name|pgrpid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Process Group ID */
end_comment

begin_decl_stmt
name|uid_t
name|uid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Our real user-id */
end_comment

begin_decl_stmt
name|gid_t
name|gid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|devname
index|[
name|MAXPATHLEN
index|]
init|=
literal|"/dev/tty"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device name */
end_comment

begin_decl_stmt
name|int
name|default_device
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use default device (stdin/out) */
end_comment

begin_decl_stmt
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device file descriptor */
end_comment

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Socket file descriptor */
end_comment

begin_decl_stmt
name|int
name|phase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where the link is at */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SGTTY
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|initsgttyb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial TTY sgttyb */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|termios
name|inittermios
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial TTY termios */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|initfdflags
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initial file descriptor flags */
end_comment

begin_decl_stmt
specifier|static
name|int
name|restore_term
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 => we've munged the terminal */
end_comment

begin_decl_stmt
name|u_char
name|outpacket_buf
index|[
name|MTU
operator|+
name|DLLHEADERLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for outgoing packet */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|inpacket_buf
index|[
name|MTU
operator|+
name|DLLHEADERLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for incoming packet */
end_comment

begin_decl_stmt
name|int
name|hungup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal has been hung up */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_children
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # child processes still running */
end_comment

begin_comment
comment|/* configured variables */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Debug flag */
end_comment

begin_decl_stmt
name|int
name|kdebugflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Kernel debugging flag */
end_comment

begin_decl_stmt
name|char
name|user
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* username for PAP */
end_comment

begin_decl_stmt
name|char
name|passwd
index|[
name|MAXSECRETLEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* password for PAP */
end_comment

begin_decl_stmt
name|char
modifier|*
name|connector
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "connect" command */
end_comment

begin_decl_stmt
name|char
modifier|*
name|disconnector
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "disconnect" command */
end_comment

begin_decl_stmt
name|int
name|inspeed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input/Output speed requested */
end_comment

begin_decl_stmt
name|int
name|baud_rate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bits/sec currently used */
end_comment

begin_decl_stmt
name|u_long
name|netmask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* netmask to use on ppp interface */
end_comment

begin_decl_stmt
name|int
name|crtscts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use h/w flow control */
end_comment

begin_decl_stmt
name|int
name|nodetach
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't fork */
end_comment

begin_decl_stmt
name|int
name|modem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use modem control lines */
end_comment

begin_decl_stmt
name|int
name|auth_required
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* require peer to authenticate */
end_comment

begin_decl_stmt
name|int
name|defaultroute
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* assign default route through interface */
end_comment

begin_decl_stmt
name|int
name|proxyarp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set entry in arp table */
end_comment

begin_decl_stmt
name|int
name|persist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* re-initiate on termination */
end_comment

begin_decl_stmt
name|int
name|answer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wait for incoming call */
end_comment

begin_decl_stmt
name|int
name|uselogin
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check PAP info against /etc/passwd */
end_comment

begin_decl_stmt
name|int
name|lockflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lock the serial device */
end_comment

begin_comment
comment|/* prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|hup
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|intr
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|term
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|alrm
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|io
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|chld
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|incdebug
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nodebug
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|establish_ppp
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|reap_kids
name|__ARGS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|cleanup
name|__ARGS
argument_list|(
operator|(
name|int
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|die
name|__ARGS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|novm
name|__ARGS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|log_packet
name|__ARGS
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|format_packet
name|__ARGS
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|int
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|char
operator|*
argument_list|,
operator|...
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pr_log
name|__ARGS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * PPP Data Link Layer "protocol" table.  * One entry per supported protocol.  */
end_comment

begin_struct
specifier|static
struct|struct
name|protent
block|{
name|u_short
name|protocol
decl_stmt|;
name|void
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|input
function_decl|)
parameter_list|()
function_decl|;
name|void
function_decl|(
modifier|*
name|protrej
function_decl|)
parameter_list|()
function_decl|;
name|int
function_decl|(
modifier|*
name|printpkt
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|prottbl
index|[]
init|=
block|{
block|{
name|LCP
block|,
name|lcp_init
block|,
name|lcp_input
block|,
name|lcp_protrej
block|,
name|lcp_printpkt
block|,
literal|"LCP"
block|}
block|,
block|{
name|IPCP
block|,
name|ipcp_init
block|,
name|ipcp_input
block|,
name|ipcp_protrej
block|,
name|ipcp_printpkt
block|,
literal|"IPCP"
block|}
block|,
block|{
name|UPAP
block|,
name|upap_init
block|,
name|upap_input
block|,
name|upap_protrej
block|,
name|upap_printpkt
block|,
literal|"PAP"
block|}
block|,
block|{
name|CHAP
block|,
name|ChapInit
block|,
name|ChapInput
block|,
name|ChapProtocolReject
block|,
name|ChapPrintPkt
block|,
literal|"CHAP"
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|N_PROTO
value|(sizeof(prottbl) / sizeof(prottbl[0]))
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|mask
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sigaction
name|sa
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
name|FILE
modifier|*
name|pidfile
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|p
operator|=
name|ttyname
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|strcpy
argument_list|(
name|devname
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|hostname
argument_list|,
name|MAXNAMELEN
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"couldn't get hostname"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hostname
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|gid
operator|=
name|getgid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ppp_available
argument_list|()
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sorry - PPP is not available on this system\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Initialize to the standard option set, then parse, in order,      * the system options file, the user's options file, and the command      * line arguments.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_PROTO
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|prottbl
index|[
name|i
index|]
operator|.
name|init
operator|)
operator|(
literal|0
operator|)
expr_stmt|;
name|progname
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|!
name|options_from_file
argument_list|(
name|_PATH_SYSOPTIONS
argument_list|,
name|REQ_SYSOPTIONS
argument_list|,
literal|0
argument_list|)
operator|||
operator|!
name|options_from_user
argument_list|()
operator|||
operator|!
name|parse_args
argument_list|(
name|argc
operator|-
literal|1
argument_list|,
name|argv
operator|+
literal|1
argument_list|)
operator|||
operator|!
name|options_for_tty
argument_list|()
condition|)
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|check_auth_options
argument_list|()
expr_stmt|;
name|setipdefault
argument_list|()
expr_stmt|;
comment|/*      * Initialize syslog system and magic number package.      */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|ultrix
argument_list|)
name|openlog
argument_list|(
literal|"pppd"
argument_list|,
name|LOG_PID
operator||
name|LOG_NDELAY
argument_list|,
name|LOG_PPP
argument_list|)
expr_stmt|;
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_INFO
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"pppd"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
define|#
directive|define
name|LOG_UPTO
parameter_list|(
name|x
parameter_list|)
value|(x)
define|#
directive|define
name|setlogmask
parameter_list|(
name|x
parameter_list|)
value|(x)
endif|#
directive|endif
if|if
condition|(
name|debug
condition|)
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
name|magic_init
argument_list|()
expr_stmt|;
name|username
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|username
operator|==
name|NULL
condition|)
block|{
name|pw
operator|=
name|getpwuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|!=
name|NULL
operator|&&
name|pw
operator|->
name|pw_name
operator|!=
name|NULL
condition|)
name|username
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
else|else
name|username
operator|=
literal|"(unknown)"
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"pppd %s.%d started by %s, uid %d"
argument_list|,
name|VERSION
argument_list|,
name|PATCHLEVEL
argument_list|,
name|username
argument_list|,
name|uid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SETSID
comment|/*      * Make sure we can set the serial device to be our controlling terminal.      */
if|if
condition|(
name|default_device
condition|)
block|{
comment|/* 	 * No device name was specified: 	 * we are in the device's session already. 	 */
if|if
condition|(
operator|(
name|pgrpid
operator|=
name|getpgrp
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getpgrp(): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	 * Not default device: make sure we're not a process group leader, 	 * then become session leader of a new session (so we can make 	 * our device its controlling terminal and thus get SIGHUPs). 	 */
if|if
condition|(
operator|!
name|nodetach
condition|)
block|{
comment|/* fork so we're not a process group leader */
if|if
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* parent is finished */
block|}
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork: %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* otherwise pid is 0 in child */
block|}
else|else
block|{
comment|/* 	     * try to put ourself into our parent's process group, 	     * so we're not a process group leader 	     */
if|if
condition|(
name|setpgrp
argument_list|(
name|pid
argument_list|,
name|getppid
argument_list|()
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"setpgrp: %m"
argument_list|)
expr_stmt|;
block|}
comment|/* create new session */
if|if
condition|(
operator|(
name|pgrpid
operator|=
name|setsid
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setsid(): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|lockflag
operator|&&
operator|!
name|default_device
condition|)
if|if
condition|(
name|lock
argument_list|(
name|devname
argument_list|)
operator|<
literal|0
condition|)
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Get an internet socket for doing socket ioctl's on. */
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket : %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Compute mask of all interesting signals and install signal handlers      * for each.  Only one signal handler may be active at a time.  Therefore,      * all other signals should be masked when any handler is executing.      */
name|sigemptyset
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STREAMS
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGPOLL
argument_list|)
expr_stmt|;
endif|#
directive|endif
define|#
directive|define
name|SIGNAL
parameter_list|(
name|s
parameter_list|,
name|handler
parameter_list|)
value|{ \ 	sa.sa_handler = handler; \ 	if (sigaction(s,&sa, NULL)< 0) { \ 	    syslog(LOG_ERR, "sigaction(%d): %m", s); \ 	    die(1); \ 	} \     }
name|sa
operator|.
name|sa_mask
operator|=
name|mask
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|SIGNAL
argument_list|(
name|SIGHUP
argument_list|,
name|hup
argument_list|)
expr_stmt|;
comment|/* Hangup */
name|SIGNAL
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
comment|/* Interrupt */
name|SIGNAL
argument_list|(
name|SIGTERM
argument_list|,
name|term
argument_list|)
expr_stmt|;
comment|/* Terminate */
name|SIGNAL
argument_list|(
name|SIGALRM
argument_list|,
name|alrm
argument_list|)
expr_stmt|;
comment|/* Timeout */
name|SIGNAL
argument_list|(
name|SIGIO
argument_list|,
name|io
argument_list|)
expr_stmt|;
comment|/* Input available */
name|SIGNAL
argument_list|(
name|SIGCHLD
argument_list|,
name|chld
argument_list|)
expr_stmt|;
comment|/* Death of child process */
ifdef|#
directive|ifdef
name|STREAMS
name|SIGNAL
argument_list|(
name|SIGPOLL
argument_list|,
name|io
argument_list|)
expr_stmt|;
comment|/* Input available */
endif|#
directive|endif
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|incdebug
argument_list|)
expr_stmt|;
comment|/* Increment debug flag */
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|nodebug
argument_list|)
expr_stmt|;
comment|/* Reset debug flag */
comment|/*      * Block SIGIOs and SIGPOLLs for now      */
name|sigemptyset
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STREAMS
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGPOLL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * Open the serial device and set it up to be the ppp interface.      */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|devname
argument_list|,
name|O_RDWR
comment|/*| O_NDELAY*/
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open(%s): %m"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|hungup
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSCTTY
comment|/* set device to be controlling tty */
if|if
condition|(
operator|!
name|default_device
operator|&&
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSCTTY
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSCTTY): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TIOCSCTTY */
comment|/* run connection script */
if|if
condition|(
name|connector
condition|)
block|{
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"Connecting with<%s>"
operator|,
name|connector
operator|)
argument_list|)
expr_stmt|;
comment|/* set line speed, flow control, etc.; set CLOCAL for now */
name|set_up_tty
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* drop dtr to hang up in case modem is off hook */
if|if
condition|(
operator|!
name|default_device
operator|&&
name|modem
condition|)
block|{
name|setdtr
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|setdtr
argument_list|(
name|fd
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|device_script
argument_list|(
name|connector
argument_list|,
name|fd
argument_list|,
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"could not set up connection"
argument_list|)
expr_stmt|;
name|setdtr
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Connected..."
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* give it time to set up its terminal */
block|}
comment|/* set line speed, flow control, etc.; clear CLOCAL if modem option */
name|set_up_tty
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set up the serial device as a ppp interface */
name|establish_ppp
argument_list|()
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Using interface ppp%d"
argument_list|,
name|ifunit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ifname
argument_list|,
literal|"ppp%d"
argument_list|,
name|ifunit
argument_list|)
expr_stmt|;
comment|/* write pid to file */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|pidfilename
argument_list|,
literal|"%s/%s.pid"
argument_list|,
name|pidpath
argument_list|,
name|ifname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pidfile
operator|=
name|fopen
argument_list|(
name|pidfilename
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|pidfile
argument_list|,
literal|"%d\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|pidfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unable to create pid file: %m"
argument_list|)
expr_stmt|;
name|pidfilename
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Set process group of device to our process group so we can get      * SIGIOs and SIGHUPs.      */
ifdef|#
directive|ifdef
name|SETSID
if|if
condition|(
name|default_device
condition|)
block|{
name|int
name|id
init|=
name|tcgetpgrp
argument_list|(
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|!=
name|pgrpid
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"warning: not in tty's process group"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tcsetpgrp
argument_list|(
name|fd
argument_list|,
name|pgrpid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tcsetpgrp(): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* set process group on tty so we get SIGIO's */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSPGRP
argument_list|,
operator|&
name|pgrpid
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSPGRP): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Record initial device flags, then set device to cause SIGIO      * signals to be generated.      */
if|if
condition|(
operator|(
name|initfdflags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_GETFL): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_linux_
comment|/* This is a kludge for Linux. FIXME !!! -- later. */
undef|#
directive|undef
name|FASYNC
define|#
directive|define
name|FASYNC
value|0
endif|#
directive|endif
if|if
condition|(
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|FNDELAY
operator||
name|FASYNC
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fcntl(F_SETFL, FNDELAY | FASYNC): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Block all signals, start opening the connection, and  wait for      * incoming signals (reply, timeout, etc.).      */
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Connect: %s<--> %s"
argument_list|,
name|ifname
argument_list|,
name|devname
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Block signals now */
name|lcp_lowerup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX Well, sort of... */
name|lcp_open
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Start protocol */
for|for
control|(
name|phase
operator|=
name|PHASE_ESTABLISH
init|;
name|phase
operator|!=
name|PHASE_DEAD
condition|;
control|)
name|sigpause
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for next signal */
comment|/*      * Run disconnector script, if requested      */
if|if
condition|(
name|disconnector
condition|)
block|{
if|if
condition|(
name|device_script
argument_list|(
name|disconnector
argument_list|,
name|fd
argument_list|,
name|fd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"disconnect script failed"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Disconnected..."
argument_list|)
expr_stmt|;
block|}
name|quit
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|B9600
operator|==
literal|9600
end_if

begin_comment
comment|/*  * XXX assume speed_t values numerically equal bits per second  * (so we can ask for any speed).  */
end_comment

begin_define
define|#
directive|define
name|translate_speed
parameter_list|(
name|bps
parameter_list|)
value|(bps)
end_define

begin_define
define|#
directive|define
name|baud_rate_of
parameter_list|(
name|speed
parameter_list|)
value|(speed)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * List of valid speeds.  */
end_comment

begin_struct
struct|struct
name|speed
block|{
name|int
name|speed_int
decl_stmt|,
name|speed_val
decl_stmt|;
block|}
name|speeds
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|B50
block|{
literal|50
block|,
name|B50
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B75
block|{
literal|75
block|,
name|B75
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B110
block|{
literal|110
block|,
name|B110
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B134
block|{
literal|134
block|,
name|B134
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B150
block|{
literal|150
block|,
name|B150
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B200
block|{
literal|200
block|,
name|B200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B300
block|{
literal|300
block|,
name|B300
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B600
block|{
literal|600
block|,
name|B600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B1200
block|{
literal|1200
block|,
name|B1200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B1800
block|{
literal|1800
block|,
name|B1800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B2000
block|{
literal|2000
block|,
name|B2000
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B2400
block|{
literal|2400
block|,
name|B2400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B3600
block|{
literal|3600
block|,
name|B3600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B4800
block|{
literal|4800
block|,
name|B4800
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B7200
block|{
literal|7200
block|,
name|B7200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B9600
block|{
literal|9600
block|,
name|B9600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B19200
block|{
literal|19200
block|,
name|B19200
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B38400
block|{
literal|38400
block|,
name|B38400
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTA
block|{
literal|19200
block|,
name|EXTA
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXTB
block|{
literal|38400
block|,
name|EXTB
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B57600
block|{
literal|57600
block|,
name|B57600
block|}
block|,
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B115200
block|{
literal|115200
block|,
name|B115200
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Translate from bits/second to a speed_t.  */
end_comment

begin_function
name|int
name|translate_speed
parameter_list|(
name|bps
parameter_list|)
name|int
name|bps
decl_stmt|;
block|{
name|struct
name|speed
modifier|*
name|speedp
decl_stmt|;
if|if
condition|(
name|bps
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|speedp
operator|=
name|speeds
init|;
name|speedp
operator|->
name|speed_int
condition|;
name|speedp
operator|++
control|)
if|if
condition|(
name|bps
operator|==
name|speedp
operator|->
name|speed_int
condition|)
return|return
name|speedp
operator|->
name|speed_val
return|;
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"speed %d not supported"
argument_list|,
name|bps
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Translate from a speed_t to bits/second.  */
end_comment

begin_function
name|int
name|baud_rate_of
parameter_list|(
name|speed
parameter_list|)
name|int
name|speed
decl_stmt|;
block|{
name|struct
name|speed
modifier|*
name|speedp
decl_stmt|;
if|if
condition|(
name|speed
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|speedp
operator|=
name|speeds
init|;
name|speedp
operator|->
name|speed_int
condition|;
name|speedp
operator|++
control|)
if|if
condition|(
name|speed
operator|==
name|speedp
operator|->
name|speed_val
condition|)
return|return
name|speedp
operator|->
name|speed_int
return|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * set_up_tty: Set up the serial port on `fd' for 8 bits, no parity,  * at the requested speed, etc.  If `local' is true, set CLOCAL  * regardless of whether the modem option was specified.  */
end_comment

begin_macro
name|set_up_tty
argument_list|(
argument|fd
argument_list|,
argument|local
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|,
name|local
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|SGTTY
name|int
name|speed
decl_stmt|,
name|x
decl_stmt|;
name|struct
name|termios
name|tios
decl_stmt|;
if|if
condition|(
name|tcgetattr
argument_list|(
name|fd
argument_list|,
operator|&
name|tios
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tcgetattr: %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|restore_term
condition|)
name|inittermios
operator|=
name|tios
expr_stmt|;
ifdef|#
directive|ifdef
name|CRTSCTS
name|tios
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|CSTOPB
operator||
name|PARENB
operator||
name|CLOCAL
operator||
name|CRTSCTS
operator|)
expr_stmt|;
if|if
condition|(
name|crtscts
operator|==
literal|1
condition|)
name|tios
operator|.
name|c_cflag
operator||=
name|CRTSCTS
expr_stmt|;
else|#
directive|else
name|tios
operator|.
name|c_cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|CSTOPB
operator||
name|PARENB
operator||
name|CLOCAL
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* CRTSCTS */
name|tios
operator|.
name|c_cflag
operator||=
name|CS8
operator||
name|CREAD
operator||
name|HUPCL
expr_stmt|;
if|if
condition|(
name|local
operator|||
operator|!
name|modem
condition|)
name|tios
operator|.
name|c_cflag
operator||=
name|CLOCAL
expr_stmt|;
name|tios
operator|.
name|c_iflag
operator|=
name|IGNBRK
operator||
name|IGNPAR
expr_stmt|;
name|tios
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|tios
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|tios
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|tios
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|crtscts
operator|==
literal|2
condition|)
block|{
name|tios
operator|.
name|c_iflag
operator||=
name|IXOFF
expr_stmt|;
name|tios
operator|.
name|c_cc
index|[
name|VSTOP
index|]
operator|=
literal|0x13
expr_stmt|;
comment|/* DC3 = XOFF = ^S */
name|tios
operator|.
name|c_cc
index|[
name|VSTART
index|]
operator|=
literal|0x11
expr_stmt|;
comment|/* DC1 = XON  = ^Q */
block|}
name|speed
operator|=
name|translate_speed
argument_list|(
name|inspeed
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
condition|)
block|{
name|cfsetospeed
argument_list|(
operator|&
name|tios
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|cfsetispeed
argument_list|(
operator|&
name|tios
argument_list|,
name|speed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|speed
operator|=
name|cfgetospeed
argument_list|(
operator|&
name|tios
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|tios
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tcsetattr: %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ultrix
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
operator|(
name|crtscts
operator|||
name|modem
operator|)
condition|?
name|TIOCMODEM
else|:
name|TIOCNMODEM
argument_list|,
operator|&
name|x
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"TIOC(N)MODEM: %m"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
operator|(
name|local
operator|||
operator|!
name|modem
operator|)
condition|?
name|TIOCNCAR
else|:
name|TIOCCAR
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"TIOC(N)CAR: %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* SGTTY */
name|int
name|speed
decl_stmt|;
name|struct
name|sgttyb
name|sgttyb
decl_stmt|;
comment|/*      * Put the tty in raw mode.      */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|sgttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCGETP): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|restore_term
condition|)
name|initsgttyb
operator|=
name|sgttyb
expr_stmt|;
name|sgttyb
operator|.
name|sg_flags
operator|=
name|RAW
operator||
name|ANYP
expr_stmt|;
name|speed
operator|=
name|translate_speed
argument_list|(
name|inspeed
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
condition|)
name|sgttyb
operator|.
name|sg_ispeed
operator|=
name|speed
expr_stmt|;
else|else
name|speed
operator|=
name|sgttyb
operator|.
name|sg_ispeed
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|sgttyb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TIOCSETP): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|baud_rate
operator|=
name|baud_rate_of
argument_list|(
name|speed
argument_list|)
expr_stmt|;
name|restore_term
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * setdtr - control the DTR line on the serial port.  * This is called from die(), so it shouldn't call die().  */
end_comment

begin_macro
name|setdtr
argument_list|(
argument|fd
argument_list|,
argument|on
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|,
name|on
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|modembits
init|=
name|TIOCM_DTR
decl_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
operator|(
name|on
condition|?
name|TIOCMBIS
else|:
name|TIOCMBIC
operator|)
argument_list|,
operator|&
name|modembits
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * quit - Clean up state and exit.  */
end_comment

begin_function
name|void
name|quit
parameter_list|()
block|{
name|die
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * die - like quit, except we can specify an exit status.  */
end_comment

begin_function
name|void
name|die
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|cleanup
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Exit."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cleanup - restore anything which needs to be restored before we exit  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|cleanup
parameter_list|(
name|status
parameter_list|,
name|arg
parameter_list|)
name|int
name|status
decl_stmt|;
name|caddr_t
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
comment|/* drop dtr to hang up */
if|if
condition|(
name|modem
condition|)
name|setdtr
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|initfdflags
operator|!=
operator|-
literal|1
operator|&&
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|initfdflags
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"fcntl(F_SETFL, fdflags): %m"
argument_list|)
expr_stmt|;
name|initfdflags
operator|=
operator|-
literal|1
expr_stmt|;
name|disestablish_ppp
argument_list|()
expr_stmt|;
if|if
condition|(
name|restore_term
condition|)
block|{
ifndef|#
directive|ifndef
name|SGTTY
if|if
condition|(
name|tcsetattr
argument_list|(
name|fd
argument_list|,
name|TCSAFLUSH
argument_list|,
operator|&
name|inittermios
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"tcsetattr: %m"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|initsgttyb
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"ioctl(TIOCSETP): %m"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pidfilename
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
name|unlink
argument_list|(
name|pidfilename
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unable to unlink pid file: %m"
argument_list|)
expr_stmt|;
name|pidfilename
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lockflag
operator|&&
operator|!
name|default_device
condition|)
name|unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|callout
modifier|*
name|callout
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Callout list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|schedtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time last timeout was set */
end_comment

begin_comment
comment|/*  * timeout - Schedule a timeout.  *  * Note that this timeout takes the number of seconds, NOT hz (as in  * the kernel).  */
end_comment

begin_decl_stmt
name|void
name|timeout
argument_list|(
name|func
argument_list|,
name|arg
argument_list|,
name|time
argument_list|)
name|void
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|itimerval
name|itv
decl_stmt|;
name|struct
name|callout
modifier|*
name|newp
decl_stmt|,
modifier|*
modifier|*
name|oldpp
decl_stmt|;
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"Timeout %x:%x in %d seconds."
operator|,
operator|(
name|int
operator|)
name|func
operator|,
operator|(
name|int
operator|)
name|arg
operator|,
name|time
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Allocate timeout.      */
if|if
condition|(
operator|(
name|newp
operator|=
operator|(
expr|struct
name|callout
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|callout
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Out of memory in timeout()!"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|newp
operator|->
name|c_arg
operator|=
name|arg
expr_stmt|;
name|newp
operator|->
name|c_func
operator|=
name|func
expr_stmt|;
comment|/*      * Find correct place to link it in and decrement its time by the      * amount of time used by preceding timeouts.      */
for|for
control|(
name|oldpp
operator|=
operator|&
name|callout
init|;
operator|*
name|oldpp
operator|&&
operator|(
operator|*
name|oldpp
operator|)
operator|->
name|c_time
operator|<=
name|time
condition|;
name|oldpp
operator|=
operator|&
operator|(
operator|*
name|oldpp
operator|)
operator|->
name|c_next
control|)
name|time
operator|-=
operator|(
operator|*
name|oldpp
operator|)
operator|->
name|c_time
expr_stmt|;
name|newp
operator|->
name|c_time
operator|=
name|time
expr_stmt|;
name|newp
operator|->
name|c_next
operator|=
operator|*
name|oldpp
expr_stmt|;
if|if
condition|(
operator|*
name|oldpp
condition|)
operator|(
operator|*
name|oldpp
operator|)
operator|->
name|c_time
operator|-=
name|time
expr_stmt|;
operator|*
name|oldpp
operator|=
name|newp
expr_stmt|;
comment|/*      * If this is now the first callout then we have to set a new      * itimer.      */
if|if
condition|(
name|callout
operator|==
name|newp
condition|)
block|{
name|itv
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|itv
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|callout
operator|->
name|c_time
expr_stmt|;
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"Setting itimer for %d seconds in timeout."
operator|,
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setitimer(ITIMER_REAL): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|schedtime
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday: %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * untimeout - Unschedule a timeout.  */
end_comment

begin_decl_stmt
name|void
name|untimeout
argument_list|(
name|func
argument_list|,
name|arg
argument_list|)
name|void
argument_list|(
operator|*
name|func
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|itimerval
name|itv
decl_stmt|;
name|struct
name|callout
modifier|*
modifier|*
name|copp
decl_stmt|,
modifier|*
name|freep
decl_stmt|;
name|int
name|reschedule
init|=
literal|0
decl_stmt|;
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"Untimeout %x:%x."
operator|,
operator|(
name|int
operator|)
name|func
operator|,
operator|(
name|int
operator|)
name|arg
operator|)
argument_list|)
expr_stmt|;
comment|/*      * If the first callout is unscheduled then we have to set a new      * itimer.      */
if|if
condition|(
name|callout
operator|&&
name|callout
operator|->
name|c_func
operator|==
name|func
operator|&&
name|callout
operator|->
name|c_arg
operator|==
name|arg
condition|)
name|reschedule
operator|=
literal|1
expr_stmt|;
comment|/*      * Find first matching timeout.  Add its time to the next timeouts      * time.      */
for|for
control|(
name|copp
operator|=
operator|&
name|callout
init|;
operator|*
name|copp
condition|;
name|copp
operator|=
operator|&
operator|(
operator|*
name|copp
operator|)
operator|->
name|c_next
control|)
if|if
condition|(
operator|(
operator|*
name|copp
operator|)
operator|->
name|c_func
operator|==
name|func
operator|&&
operator|(
operator|*
name|copp
operator|)
operator|->
name|c_arg
operator|==
name|arg
condition|)
block|{
name|freep
operator|=
operator|*
name|copp
expr_stmt|;
operator|*
name|copp
operator|=
name|freep
operator|->
name|c_next
expr_stmt|;
if|if
condition|(
operator|*
name|copp
condition|)
operator|(
operator|*
name|copp
operator|)
operator|->
name|c_time
operator|+=
name|freep
operator|->
name|c_time
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|freep
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reschedule
condition|)
block|{
name|itv
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|itv
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|callout
condition|?
name|callout
operator|->
name|c_time
else|:
literal|0
expr_stmt|;
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"Setting itimer for %d seconds in untimeout."
operator|,
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setitimer(ITIMER_REAL): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|schedtime
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday: %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * adjtimeout - Decrement the first timeout by the amount of time since  * it was scheduled.  */
end_comment

begin_function
name|void
name|adjtimeout
parameter_list|()
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|timediff
decl_stmt|;
if|if
condition|(
name|callout
operator|==
name|NULL
condition|)
return|return;
comment|/*      * Make sure that the clock hasn't been warped dramatically.      * Account for recently expired, but blocked timer by adding      * small fudge factor.      */
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday: %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|timediff
operator|=
name|tv
operator|.
name|tv_sec
operator|-
name|schedtime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|timediff
operator|<
literal|0
operator|||
name|timediff
operator|>
name|callout
operator|->
name|c_time
operator|+
literal|1
condition|)
return|return;
name|callout
operator|->
name|c_time
operator|-=
name|timediff
expr_stmt|;
comment|/* OK, Adjust time */
block|}
end_function

begin_comment
comment|/*  * hup - Catch SIGHUP signal.  *  * Indicates that the physical layer has been disconnected.  */
end_comment

begin_function
specifier|static
name|void
name|hup
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Hangup (SIGHUP)"
argument_list|)
expr_stmt|;
name|hungup
operator|=
literal|1
expr_stmt|;
comment|/* they hung up on us! */
name|persist
operator|=
literal|0
expr_stmt|;
comment|/* don't try to restart */
name|adjtimeout
argument_list|()
expr_stmt|;
comment|/* Adjust timeouts */
name|lcp_lowerdown
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset connection */
name|quit
argument_list|()
expr_stmt|;
comment|/* and die */
block|}
end_function

begin_comment
comment|/*  * term - Catch SIGTERM signal.  *  * Indicates that we should initiate a graceful disconnect and exit.  */
end_comment

begin_function
specifier|static
name|void
name|term
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Terminating link."
argument_list|)
expr_stmt|;
name|persist
operator|=
literal|0
expr_stmt|;
comment|/* don't try to restart */
name|adjtimeout
argument_list|()
expr_stmt|;
comment|/* Adjust timeouts */
name|lcp_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Close connection */
block|}
end_function

begin_comment
comment|/*  * intr - Catch SIGINT signal (DEL/^C).  *  * Indicates that we should initiate a graceful disconnect and exit.  */
end_comment

begin_function
specifier|static
name|void
name|intr
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Interrupt received: terminating link"
argument_list|)
expr_stmt|;
name|persist
operator|=
literal|0
expr_stmt|;
comment|/* don't try to restart */
name|adjtimeout
argument_list|()
expr_stmt|;
comment|/* Adjust timeouts */
name|lcp_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Close connection */
block|}
end_function

begin_comment
comment|/*  * alrm - Catch SIGALRM signal.  *  * Indicates a timeout.  */
end_comment

begin_function
specifier|static
name|void
name|alrm
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|struct
name|itimerval
name|itv
decl_stmt|;
name|struct
name|callout
modifier|*
name|freep
decl_stmt|,
modifier|*
name|list
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"Alarm"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout
operator|==
name|NULL
condition|)
return|return;
comment|/*      * Get the first scheduled timeout and any that were scheduled      * for the same time as a list, and remove them all from callout      * list.      */
name|list
operator|=
name|last
operator|=
name|callout
expr_stmt|;
while|while
condition|(
name|last
operator|->
name|c_next
operator|!=
name|NULL
operator|&&
name|last
operator|->
name|c_next
operator|->
name|c_time
operator|==
literal|0
condition|)
name|last
operator|=
name|last
operator|->
name|c_next
expr_stmt|;
name|callout
operator|=
name|last
operator|->
name|c_next
expr_stmt|;
name|last
operator|->
name|c_next
operator|=
name|NULL
expr_stmt|;
comment|/*      * Set a new itimer if there are more timeouts scheduled.      */
if|if
condition|(
name|callout
condition|)
block|{
name|itv
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|itv
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|callout
operator|->
name|c_time
expr_stmt|;
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"Setting itimer for %d seconds in alrm."
operator|,
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setitimer(ITIMER_REAL): %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|schedtime
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday: %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * Now call all the timeout routines scheduled for this time.      */
while|while
condition|(
name|list
condition|)
block|{
call|(
modifier|*
name|list
operator|->
name|c_func
call|)
argument_list|(
name|list
operator|->
name|c_arg
argument_list|)
expr_stmt|;
name|freep
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|list
operator|->
name|c_next
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|freep
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * chld - Catch SIGCHLD signal.  * Calls reap_kids to get status for any dead kids.  */
end_comment

begin_function
specifier|static
name|void
name|chld
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|reap_kids
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * io - Catch SIGIO signal.  *  * Indicates that incoming data is available.  */
end_comment

begin_function
specifier|static
name|void
name|io
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|u_short
name|protocol
decl_stmt|;
name|fd_set
name|fdset
decl_stmt|;
name|struct
name|timeval
name|notime
decl_stmt|;
name|int
name|ready
decl_stmt|;
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"IO signal received"
operator|)
argument_list|)
expr_stmt|;
name|adjtimeout
argument_list|()
expr_stmt|;
comment|/* Adjust timeouts */
comment|/* Yup, this is for real */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Read all available packets */
name|p
operator|=
name|inpacket_buf
expr_stmt|;
comment|/* point to beginning of packet buffer */
name|len
operator|=
name|read_packet
argument_list|(
name|inpacket_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"End of file on fd!"
operator|)
argument_list|)
expr_stmt|;
name|lcp_lowerdown
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|debug
comment|/*&& (debugflags& DBG_INPACKET)*/
condition|)
name|log_packet
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
literal|"rcvd "
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|DLLHEADERLEN
condition|)
block|{
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"io(): Received short packet."
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Skip address and control */
name|GETSHORT
argument_list|(
name|protocol
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|len
operator|-=
name|DLLHEADERLEN
expr_stmt|;
comment|/* 	 * Toss all non-LCP packets unless LCP is OPEN. 	 */
if|if
condition|(
name|protocol
operator|!=
name|LCP
operator|&&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|state
operator|!=
name|OPENED
condition|)
block|{
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"io(): Received non-LCP packet when LCP not open."
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Upcall the proper protocol input routine. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|prottbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|protent
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|prottbl
index|[
name|i
index|]
operator|.
name|protocol
operator|==
name|protocol
condition|)
block|{
operator|(
operator|*
name|prottbl
index|[
name|i
index|]
operator|.
name|input
operator|)
operator|(
literal|0
operator|,
name|p
operator|,
name|len
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|prottbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|protent
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"input: Unknown protocol (%x) received!"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|lcp_sprotrej
argument_list|(
literal|0
argument_list|,
name|p
operator|-
name|DLLHEADERLEN
argument_list|,
name|len
operator|+
name|DLLHEADERLEN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * demuxprotrej - Demultiplex a Protocol-Reject.  */
end_comment

begin_function
name|void
name|demuxprotrej
parameter_list|(
name|unit
parameter_list|,
name|protocol
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_short
name|protocol
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/*      * Upcall the proper Protocol-Reject routine.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|prottbl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|protent
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|prottbl
index|[
name|i
index|]
operator|.
name|protocol
operator|==
name|protocol
condition|)
block|{
operator|(
operator|*
name|prottbl
index|[
name|i
index|]
operator|.
name|protrej
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
return|return;
block|}
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"demuxprotrej: Unrecognized Protocol-Reject for protocol %d!"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * incdebug - Catch SIGUSR1 signal.  *  * Increment debug flag.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|incdebug
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Debug turned ON, Level %d"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_DEBUG
argument_list|)
argument_list|)
expr_stmt|;
name|debug
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * nodebug - Catch SIGUSR2 signal.  *  * Turn off debugging.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|nodebug
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
name|setlogmask
argument_list|(
name|LOG_UPTO
argument_list|(
name|LOG_WARNING
argument_list|)
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * device_script - run a program to connect or disconnect the  * serial device.  */
end_comment

begin_function
name|int
name|device_script
parameter_list|(
name|program
parameter_list|,
name|in
parameter_list|,
name|out
parameter_list|)
name|char
modifier|*
name|program
decl_stmt|;
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|mask
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fork: %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|initgroups
argument_list|(
name|username
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|setgid
argument_list|(
name|gid
argument_list|)
expr_stmt|;
name|setuid
argument_list|(
name|uid
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|in
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|out
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|execl
argument_list|(
literal|"/bin/sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|program
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"could not exec /bin/sh: %m"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|99
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
while|while
condition|(
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"waiting for (dis)connection process: %m"
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * run-program - execute a program with given arguments,  * but don't wait for it.  * If the program can't be executed, logs an error unless  * must_exist is 0 and the program file doesn't exist.  */
end_comment

begin_function
name|int
name|run_program
parameter_list|(
name|prog
parameter_list|,
name|args
parameter_list|,
name|must_exist
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|int
name|must_exist
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't fork to run %s: %m"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|execv
argument_list|(
name|prog
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_exist
operator|||
name|errno
operator|!=
name|ENOENT
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"can't execute %s: %m"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|MAINDEBUG
argument_list|(
operator|(
name|LOG_DEBUG
operator|,
literal|"Script %s started; pid = %d"
operator|,
name|prog
operator|,
name|pid
operator|)
argument_list|)
expr_stmt|;
operator|++
name|n_children
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * reap_kids - get status from any dead child processes,  * and log a message for abnormal terminations.  */
end_comment

begin_function
name|void
name|reap_kids
parameter_list|()
block|{
name|int
name|pid
decl_stmt|,
name|status
decl_stmt|;
if|if
condition|(
name|n_children
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|pid
operator|=
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ECHILD
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"waitpid: %m"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
block|{
operator|--
name|n_children
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"child process %d terminated with signal %d"
argument_list|,
name|pid
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * log_packet - format a packet and log it.  */
end_comment

begin_decl_stmt
name|char
name|line
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line to be logged accumulated here */
end_comment

begin_decl_stmt
name|char
modifier|*
name|linep
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|log_packet
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|,
name|prefix
parameter_list|)
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
name|strcpy
argument_list|(
name|line
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|linep
operator|=
name|line
operator|+
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|format_packet
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|pr_log
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|linep
operator|!=
name|line
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * format_packet - make a readable representation of a packet,  * calling `printer(arg, format, ...)' to output it.  */
end_comment

begin_function_decl
name|void
name|format_packet
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|,
name|printer
parameter_list|,
name|arg
parameter_list|)
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*printer
end_function_decl

begin_expr_stmt
unit|)
name|__ARGS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_short
name|proto
decl_stmt|;
name|u_char
name|x
decl_stmt|;
if|if
condition|(
name|len
operator|>=
name|DLLHEADERLEN
operator|&&
name|p
index|[
literal|0
index|]
operator|==
name|ALLSTATIONS
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|UI
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|GETSHORT
argument_list|(
name|proto
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|len
operator|-=
name|DLLHEADERLEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_PROTO
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|proto
operator|==
name|prottbl
index|[
name|i
index|]
operator|.
name|protocol
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|N_PROTO
condition|)
block|{
name|printer
argument_list|(
name|arg
argument_list|,
literal|"[%s"
argument_list|,
name|prottbl
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
operator|*
name|prottbl
index|[
name|i
index|]
operator|.
name|printpkt
operator|)
operator|(
name|p
operator|,
name|len
operator|,
name|printer
operator|,
name|arg
operator|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
else|else
block|{
name|printer
argument_list|(
name|arg
argument_list|,
literal|"[proto=0x%x]"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
block|{
name|GETCHAR
argument_list|(
name|x
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %.2x"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_function
name|void
name|pr_log
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|va_list
name|pvar
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|va_start
argument_list|(
name|pvar
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|pvar
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|pvar
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|linep
operator|+
name|n
operator|+
literal|1
operator|>
name|line
operator|+
sizeof|sizeof
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|linep
operator|=
name|line
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|linep
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|linep
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __STDC__ */
end_comment

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_function
name|void
name|pr_log
parameter_list|(
name|arg
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
function|va_dcl
block|{
name|int
name|n
decl_stmt|;
name|va_list
name|pvar
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|va_start
argument_list|(
name|pvar
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|pvar
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|pvar
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|linep
operator|+
name|n
operator|+
literal|1
operator|>
name|line
operator|+
sizeof|sizeof
argument_list|(
name|line
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|linep
operator|=
name|line
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|linep
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|linep
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * print_string - print a readable representation of a string using  * printer.  */
end_comment

begin_function_decl
name|void
name|print_string
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|,
name|printer
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*printer
end_function_decl

begin_expr_stmt
unit|)
name|__ARGS
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
block|{
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
literal|' '
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'~'
condition|)
name|printer
argument_list|(
name|arg
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|printer
argument_list|(
name|arg
argument_list|,
literal|"\\%.3o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|printer
argument_list|(
name|arg
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * novm - log an error message saying we ran out of memory, and die.  */
end_comment

begin_function
name|void
name|novm
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Virtual memory exhausted allocating %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

