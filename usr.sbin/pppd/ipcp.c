begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ipcp.c - PPP IP Control Protocol.  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ipcp.c,v 1.8 1994/05/26 06:37:34 paulus Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * TODO:  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|"pppd.h"
end_include

begin_include
include|#
directive|include
file|"ppp.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/* global vars */
end_comment

begin_decl_stmt
name|ipcp_options
name|ipcp_wantoptions
index|[
name|NPPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options that we want to request */
end_comment

begin_decl_stmt
name|ipcp_options
name|ipcp_gotoptions
index|[
name|NPPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options that peer ack'd */
end_comment

begin_decl_stmt
name|ipcp_options
name|ipcp_allowoptions
index|[
name|NPPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options we allow peer to request */
end_comment

begin_decl_stmt
name|ipcp_options
name|ipcp_hisoptions
index|[
name|NPPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options that we ack'd */
end_comment

begin_decl_stmt
specifier|extern
name|char
name|ifname
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|devname
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|baud_rate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local vars */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cis_received
index|[
name|NPPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # Conf-Reqs received */
end_comment

begin_comment
comment|/*  * Callbacks for fsm code.  (CI = Configuration Information)  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ipcp_resetci
name|__ARGS
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reset our CI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ipcp_cilen
name|__ARGS
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return length of our CI */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ipcp_addci
name|__ARGS
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add our CI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ipcp_ackci
name|__ARGS
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Peer ack'd our CI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ipcp_nakci
name|__ARGS
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Peer nak'd our CI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ipcp_rejci
name|__ARGS
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Peer rej'd our CI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ipcp_reqci
name|__ARGS
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Rcv CI */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ipcp_up
name|__ARGS
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We're UP */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ipcp_down
name|__ARGS
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We're DOWN */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ipcp_script
name|__ARGS
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Run an up/down script */
end_comment

begin_decl_stmt
name|fsm
name|ipcp_fsm
index|[
name|NPPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IPCP fsm structure */
end_comment

begin_decl_stmt
specifier|static
name|fsm_callbacks
name|ipcp_callbacks
init|=
block|{
comment|/* IPCP callback routines */
name|ipcp_resetci
block|,
comment|/* Reset our Configuration Information */
name|ipcp_cilen
block|,
comment|/* Length of our Configuration Information */
name|ipcp_addci
block|,
comment|/* Add our Configuration Information */
name|ipcp_ackci
block|,
comment|/* ACK our Configuration Information */
name|ipcp_nakci
block|,
comment|/* NAK our Configuration Information */
name|ipcp_rejci
block|,
comment|/* Reject our Configuration Information */
name|ipcp_reqci
block|,
comment|/* Request peer's Configuration Information */
name|ipcp_up
block|,
comment|/* Called when fsm reaches OPENED state */
name|ipcp_down
block|,
comment|/* Called when fsm leaves OPENED state */
name|NULL
block|,
comment|/* Called when we want the lower layer up */
name|NULL
block|,
comment|/* Called when we want the lower layer down */
name|NULL
block|,
comment|/* Called when Protocol-Reject received */
name|NULL
block|,
comment|/* Retransmission is necessary */
name|NULL
block|,
comment|/* Called to handle protocol-specific codes */
literal|"IPCP"
comment|/* String name of protocol */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Lengths of configuration options.  */
end_comment

begin_define
define|#
directive|define
name|CILEN_VOID
value|2
end_define

begin_define
define|#
directive|define
name|CILEN_COMPRESS
value|4
end_define

begin_comment
comment|/* min length for compression protocol opt. */
end_comment

begin_define
define|#
directive|define
name|CILEN_VJ
value|6
end_define

begin_comment
comment|/* length for RFC1332 Van-Jacobson opt. */
end_comment

begin_define
define|#
directive|define
name|CILEN_ADDR
value|6
end_define

begin_comment
comment|/* new-style single address option */
end_comment

begin_define
define|#
directive|define
name|CILEN_ADDRS
value|10
end_define

begin_comment
comment|/* old-style dual address option */
end_comment

begin_define
define|#
directive|define
name|CODENAME
parameter_list|(
name|x
parameter_list|)
value|((x) == CONFACK ? "ACK" : \ 			 (x) == CONFNAK ? "NAK" : "REJ")
end_define

begin_comment
comment|/*  * Make a string representation of a network IP address.  */
end_comment

begin_function
name|char
modifier|*
name|ip_ntoa
parameter_list|(
name|ipaddr
parameter_list|)
name|u_long
name|ipaddr
decl_stmt|;
block|{
specifier|static
name|char
name|b
index|[
literal|64
index|]
decl_stmt|;
name|ipaddr
operator|=
name|ntohl
argument_list|(
name|ipaddr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|ipaddr
operator|>>
literal|24
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|ipaddr
operator|>>
literal|16
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|ipaddr
operator|>>
literal|8
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|ipaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * ipcp_init - Initialize IPCP.  */
end_comment

begin_function
name|void
name|ipcp_init
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm
modifier|*
name|f
init|=
operator|&
name|ipcp_fsm
index|[
name|unit
index|]
decl_stmt|;
name|ipcp_options
modifier|*
name|wo
init|=
operator|&
name|ipcp_wantoptions
index|[
name|unit
index|]
decl_stmt|;
name|ipcp_options
modifier|*
name|ao
init|=
operator|&
name|ipcp_allowoptions
index|[
name|unit
index|]
decl_stmt|;
name|f
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|f
operator|->
name|protocol
operator|=
name|IPCP
expr_stmt|;
name|f
operator|->
name|callbacks
operator|=
operator|&
name|ipcp_callbacks
expr_stmt|;
name|fsm_init
argument_list|(
operator|&
name|ipcp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|wo
operator|->
name|neg_addr
operator|=
literal|1
expr_stmt|;
name|wo
operator|->
name|old_addrs
operator|=
literal|0
expr_stmt|;
name|wo
operator|->
name|ouraddr
operator|=
literal|0
expr_stmt|;
name|wo
operator|->
name|hisaddr
operator|=
literal|0
expr_stmt|;
name|wo
operator|->
name|neg_vj
operator|=
literal|1
expr_stmt|;
name|wo
operator|->
name|old_vj
operator|=
literal|0
expr_stmt|;
name|wo
operator|->
name|vj_protocol
operator|=
name|IPCP_VJ_COMP
expr_stmt|;
name|wo
operator|->
name|maxslotindex
operator|=
name|MAX_STATES
operator|-
literal|1
expr_stmt|;
comment|/* really max index */
name|wo
operator|->
name|cflag
operator|=
literal|1
expr_stmt|;
comment|/* max slots and slot-id compression are currently hardwired in */
comment|/* ppp_if.c to 16 and 1, this needs to be changed (among other */
comment|/* things) gmc */
name|ao
operator|->
name|neg_addr
operator|=
literal|1
expr_stmt|;
name|ao
operator|->
name|neg_vj
operator|=
literal|1
expr_stmt|;
name|ao
operator|->
name|maxslotindex
operator|=
name|MAX_STATES
operator|-
literal|1
expr_stmt|;
name|ao
operator|->
name|cflag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_open - IPCP is allowed to come up.  */
end_comment

begin_function
name|void
name|ipcp_open
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm_open
argument_list|(
operator|&
name|ipcp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_close - Take IPCP down.  */
end_comment

begin_function
name|void
name|ipcp_close
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm_close
argument_list|(
operator|&
name|ipcp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_lowerup - The lower layer is up.  */
end_comment

begin_function
name|void
name|ipcp_lowerup
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm_lowerup
argument_list|(
operator|&
name|ipcp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_lowerdown - The lower layer is down.  */
end_comment

begin_function
name|void
name|ipcp_lowerdown
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm_lowerdown
argument_list|(
operator|&
name|ipcp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_input - Input IPCP packet.  */
end_comment

begin_function
name|void
name|ipcp_input
parameter_list|(
name|unit
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|fsm_input
argument_list|(
operator|&
name|ipcp_fsm
index|[
name|unit
index|]
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_protrej - A Protocol-Reject was received for IPCP.  *  * Pretend the lower layer went down, so we shut up.  */
end_comment

begin_function
name|void
name|ipcp_protrej
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm_lowerdown
argument_list|(
operator|&
name|ipcp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_resetci - Reset our CI.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_resetci
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|ipcp_options
modifier|*
name|wo
init|=
operator|&
name|ipcp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|wo
operator|->
name|req_addr
operator|=
name|wo
operator|->
name|neg_addr
operator|&&
name|ipcp_allowoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|neg_addr
expr_stmt|;
if|if
condition|(
name|wo
operator|->
name|ouraddr
operator|==
literal|0
condition|)
name|wo
operator|->
name|accept_local
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wo
operator|->
name|hisaddr
operator|==
literal|0
condition|)
name|wo
operator|->
name|accept_remote
operator|=
literal|1
expr_stmt|;
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
operator|=
operator|*
name|wo
expr_stmt|;
name|cis_received
index|[
name|f
operator|->
name|unit
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_cilen - Return length of our CI.  */
end_comment

begin_function
specifier|static
name|int
name|ipcp_cilen
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|ipcp_options
modifier|*
name|go
init|=
operator|&
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
define|#
directive|define
name|LENCIVJ
parameter_list|(
name|neg
parameter_list|,
name|old
parameter_list|)
value|(neg ? (old? CILEN_COMPRESS : CILEN_VJ) : 0)
define|#
directive|define
name|LENCIADDR
parameter_list|(
name|neg
parameter_list|,
name|old
parameter_list|)
value|(neg ? (old? CILEN_ADDRS : CILEN_ADDR) : 0)
return|return
operator|(
name|LENCIADDR
argument_list|(
name|go
operator|->
name|neg_addr
argument_list|,
name|go
operator|->
name|old_addrs
argument_list|)
operator|+
name|LENCIVJ
argument_list|(
name|go
operator|->
name|neg_vj
argument_list|,
name|go
operator|->
name|old_vj
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ipcp_addci - Add our desired CIs to a packet.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_addci
parameter_list|(
name|f
parameter_list|,
name|ucp
parameter_list|,
name|lenp
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|ucp
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
block|{
name|ipcp_options
modifier|*
name|wo
init|=
operator|&
name|ipcp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipcp_options
modifier|*
name|go
init|=
operator|&
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipcp_options
modifier|*
name|ho
init|=
operator|&
name|ipcp_hisoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|int
name|len
init|=
operator|*
name|lenp
decl_stmt|;
define|#
directive|define
name|ADDCIVJ
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|,
name|old
parameter_list|,
name|maxslotindex
parameter_list|,
name|cflag
parameter_list|)
define|\
value|if (neg) { \ 	int vjlen = old? CILEN_COMPRESS : CILEN_VJ; \ 	if (len>= vjlen) { \ 	    PUTCHAR(opt, ucp); \ 	    PUTCHAR(vjlen, ucp); \ 	    PUTSHORT(val, ucp); \ 	    if (!old) { \ 		PUTCHAR(maxslotindex, ucp); \ 		PUTCHAR(cflag, ucp); \ 	    } \ 	    len -= vjlen; \ 	} else \ 	    neg = 0; \     }
define|#
directive|define
name|ADDCIADDR
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|old
parameter_list|,
name|val1
parameter_list|,
name|val2
parameter_list|)
define|\
value|if (neg) { \ 	int addrlen = (old? CILEN_ADDRS: CILEN_ADDR); \ 	if (len>= addrlen) { \ 	    u_long l; \ 	    PUTCHAR(opt, ucp); \ 	    PUTCHAR(addrlen, ucp); \ 	    l = ntohl(val1); \ 	    PUTLONG(l, ucp); \ 	    if (old) { \ 		l = ntohl(val2); \ 		PUTLONG(l, ucp); \ 	    } \ 	    len -= addrlen; \ 	} else \ 	    neg = 0; \     }
comment|/*      * First see if we want to change our options to the old      * forms because we have received old forms from the peer.      */
if|if
condition|(
name|wo
operator|->
name|neg_addr
operator|&&
operator|!
name|go
operator|->
name|neg_addr
operator|&&
operator|!
name|go
operator|->
name|old_addrs
condition|)
block|{
comment|/* use the old style of address negotiation */
name|go
operator|->
name|neg_addr
operator|=
literal|1
expr_stmt|;
name|go
operator|->
name|old_addrs
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|wo
operator|->
name|neg_vj
operator|&&
operator|!
name|go
operator|->
name|neg_vj
operator|&&
operator|!
name|go
operator|->
name|old_vj
condition|)
block|{
comment|/* try an older style of VJ negotiation */
if|if
condition|(
name|cis_received
index|[
name|f
operator|->
name|unit
index|]
operator|==
literal|0
condition|)
block|{
comment|/* keep trying the new style until we see some CI from the peer */
name|go
operator|->
name|neg_vj
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* use the old style only if the peer did */
if|if
condition|(
name|ho
operator|->
name|neg_vj
operator|&&
name|ho
operator|->
name|old_vj
condition|)
block|{
name|go
operator|->
name|neg_vj
operator|=
literal|1
expr_stmt|;
name|go
operator|->
name|old_vj
operator|=
literal|1
expr_stmt|;
name|go
operator|->
name|vj_protocol
operator|=
name|ho
operator|->
name|vj_protocol
expr_stmt|;
block|}
block|}
block|}
name|ADDCIADDR
argument_list|(
operator|(
name|go
operator|->
name|old_addrs
condition|?
name|CI_ADDRS
else|:
name|CI_ADDR
operator|)
argument_list|,
name|go
operator|->
name|neg_addr
argument_list|,
name|go
operator|->
name|old_addrs
argument_list|,
name|go
operator|->
name|ouraddr
argument_list|,
name|go
operator|->
name|hisaddr
argument_list|)
expr_stmt|;
name|ADDCIVJ
argument_list|(
name|CI_COMPRESSTYPE
argument_list|,
name|go
operator|->
name|neg_vj
argument_list|,
name|go
operator|->
name|vj_protocol
argument_list|,
name|go
operator|->
name|old_vj
argument_list|,
name|go
operator|->
name|maxslotindex
argument_list|,
name|go
operator|->
name|cflag
argument_list|)
expr_stmt|;
operator|*
name|lenp
operator|-=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_ackci - Ack our CIs.  *  * Returns:  *	0 - Ack was bad.  *	1 - Ack was good.  */
end_comment

begin_function
specifier|static
name|int
name|ipcp_ackci
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|ipcp_options
modifier|*
name|go
init|=
operator|&
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_short
name|cilen
decl_stmt|,
name|citype
decl_stmt|,
name|cishort
decl_stmt|;
name|u_long
name|cilong
decl_stmt|;
name|u_char
name|cimaxslotindex
decl_stmt|,
name|cicflag
decl_stmt|;
comment|/*      * CIs must be in exactly the same order that we sent...      * Check packet length and CI length at each step.      * If we find any deviations, then this packet is bad.      */
define|#
directive|define
name|ACKCIVJ
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|,
name|old
parameter_list|,
name|maxslotindex
parameter_list|,
name|cflag
parameter_list|)
define|\
value|if (neg) { \ 	int vjlen = old? CILEN_COMPRESS : CILEN_VJ; \ 	if ((len -= vjlen)< 0) \ 	    goto bad; \ 	GETCHAR(citype, p); \ 	GETCHAR(cilen, p); \ 	if (cilen != vjlen || \ 	    citype != opt)  \ 	    goto bad; \ 	GETSHORT(cishort, p); \ 	if (cishort != val) \ 	    goto bad; \ 	if (!old) { \ 	    GETCHAR(cimaxslotindex, p); \ 	    if (cimaxslotindex != maxslotindex) \ 		goto bad; \ 	    GETCHAR(cicflag, p); \ 	    if (cicflag != cflag) \ 		goto bad; \ 	} \     }
define|#
directive|define
name|ACKCIADDR
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|old
parameter_list|,
name|val1
parameter_list|,
name|val2
parameter_list|)
define|\
value|if (neg) { \ 	int addrlen = (old? CILEN_ADDRS: CILEN_ADDR); \ 	u_long l; \ 	if ((len -= addrlen)< 0) \ 	    goto bad; \ 	GETCHAR(citype, p); \ 	GETCHAR(cilen, p); \ 	if (cilen != addrlen || \ 	    citype != opt) \ 	    goto bad; \ 	GETLONG(l, p); \ 	cilong = htonl(l); \ 	if (val1 != cilong) \ 	    goto bad; \ 	if (old) { \ 	    GETLONG(l, p); \ 	    cilong = htonl(l); \ 	    if (val2 != cilong) \ 		goto bad; \ 	} \     }
name|ACKCIADDR
argument_list|(
operator|(
name|go
operator|->
name|old_addrs
condition|?
name|CI_ADDRS
else|:
name|CI_ADDR
operator|)
argument_list|,
name|go
operator|->
name|neg_addr
argument_list|,
name|go
operator|->
name|old_addrs
argument_list|,
name|go
operator|->
name|ouraddr
argument_list|,
name|go
operator|->
name|hisaddr
argument_list|)
expr_stmt|;
name|ACKCIVJ
argument_list|(
name|CI_COMPRESSTYPE
argument_list|,
name|go
operator|->
name|neg_vj
argument_list|,
name|go
operator|->
name|vj_protocol
argument_list|,
name|go
operator|->
name|old_vj
argument_list|,
name|go
operator|->
name|maxslotindex
argument_list|,
name|go
operator|->
name|cflag
argument_list|)
expr_stmt|;
comment|/*      * If there are any remaining CIs, then this packet is bad.      */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
return|return
operator|(
literal|1
operator|)
return|;
name|bad
label|:
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ipcp_ackci: received bad Ack!"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ipcp_nakci - Peer has sent a NAK for some of our CIs.  * This should not modify any state if the Nak is bad  * or if IPCP is in the OPENED state.  *  * Returns:  *	0 - Nak was bad.  *	1 - Nak was good.  */
end_comment

begin_function
specifier|static
name|int
name|ipcp_nakci
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|ipcp_options
modifier|*
name|go
init|=
operator|&
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
name|cimaxslotindex
decl_stmt|,
name|cicflag
decl_stmt|;
name|u_char
name|citype
decl_stmt|,
name|cilen
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|u_short
name|cishort
decl_stmt|;
name|u_long
name|ciaddr1
decl_stmt|,
name|ciaddr2
decl_stmt|,
name|l
decl_stmt|;
name|ipcp_options
name|no
decl_stmt|;
comment|/* options we've seen Naks for */
name|ipcp_options
name|try
decl_stmt|;
comment|/* options to request next time */
name|BZERO
argument_list|(
operator|&
name|no
argument_list|,
sizeof|sizeof
argument_list|(
name|no
argument_list|)
argument_list|)
expr_stmt|;
name|try
operator|=
operator|*
name|go
expr_stmt|;
comment|/*      * Any Nak'd CIs must be in exactly the same order that we sent.      * Check packet length and CI length at each step.      * If we find any deviations, then this packet is bad.      */
define|#
directive|define
name|NAKCIADDR
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|old
parameter_list|,
name|code
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= (cilen = (old? CILEN_ADDRS: CILEN_ADDR))&& \ 	p[1] == cilen&& \ 	p[0] == opt) { \ 	len -= cilen; \ 	INCPTR(2, p); \ 	GETLONG(l, p); \ 	ciaddr1 = htonl(l); \ 	if (old) { \ 	    GETLONG(l, p); \ 	    ciaddr2 = htonl(l); \ 	    no.old_addrs = 1; \ 	} else \ 	    ciaddr2 = 0; \ 	no.neg = 1; \ 	code \     }
define|#
directive|define
name|NAKCIVJ
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|code
parameter_list|)
define|\
value|if (go->neg&& \ 	((cilen = p[1]) == CILEN_COMPRESS || cilen == CILEN_VJ)&& \ 	len>= cilen&& \ 	p[0] == opt) { \ 	len -= cilen; \ 	INCPTR(2, p); \ 	GETSHORT(cishort, p); \ 	no.neg = 1; \         code \     }
comment|/*      * Accept the peer's idea of {our,his} address, if different      * from our idea, only if the accept_{local,remote} flag is set.      */
name|NAKCIADDR
argument_list|(
argument|CI_ADDR
argument_list|,
argument|neg_addr
argument_list|,
argument|go->old_addrs
argument_list|,
argument|if (go->accept_local&& ciaddr1) {
comment|/* Do we know our address? */
argument|try.ouraddr = ciaddr1; 		  IPCPDEBUG((LOG_INFO,
literal|"local IP address %s"
argument|, 			     ip_ntoa(ciaddr1))); 	      } 	      if (go->accept_remote&& ciaddr2) {
comment|/* Does he know his? */
argument|try.hisaddr = ciaddr2; 		  IPCPDEBUG((LOG_INFO,
literal|"remote IP address %s"
argument|, 			     ip_ntoa(ciaddr2))); 	      }
argument_list|)
empty_stmt|;
comment|/*      * Accept the peer's value of maxslotindex provided that it      * is less than what we asked for.  Turn off slot-ID compression      * if the peer wants.  Send old-style compress-type option if      * the peer wants.      */
name|NAKCIVJ
argument_list|(
argument|CI_COMPRESSTYPE
argument_list|,
argument|neg_vj
argument_list|,
argument|if (cilen == CILEN_VJ) { 		GETCHAR(cimaxslotindex, p); 		GETCHAR(cicflag, p); 		if (cishort == IPCP_VJ_COMP) { 		    try.old_vj =
literal|0
argument|; 		    if (cimaxslotindex< go->maxslotindex) 			try.maxslotindex = cimaxslotindex; 		    if (!cicflag) 			try.cflag =
literal|0
argument|; 		} else { 		    try.neg_vj =
literal|0
argument|; 		} 	    } else { 		if (cishort == IPCP_VJ_COMP || cishort == IPCP_VJ_COMP_OLD) { 		    try.old_vj =
literal|1
argument|; 		    try.vj_protocol = cishort; 		} else { 		    try.neg_vj =
literal|0
argument|; 		} 	    }
argument_list|)
empty_stmt|;
comment|/*      * There may be remaining CIs, if the peer is requesting negotiation      * on an option that we didn't include in our request packet.      * If they want to negotiate about IP addresses, we comply.      * If they want us to ask for compression, we refuse.      */
while|while
condition|(
name|len
operator|>
name|CILEN_VOID
condition|)
block|{
name|GETCHAR
argument_list|(
name|citype
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|cilen
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|-=
name|cilen
operator|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
name|next
operator|=
name|p
operator|+
name|cilen
operator|-
literal|2
expr_stmt|;
switch|switch
condition|(
name|citype
condition|)
block|{
case|case
name|CI_COMPRESSTYPE
case|:
if|if
condition|(
name|go
operator|->
name|neg_vj
operator|||
name|no
operator|.
name|neg_vj
operator|||
operator|(
name|cilen
operator|!=
name|CILEN_VJ
operator|&&
name|cilen
operator|!=
name|CILEN_COMPRESS
operator|)
condition|)
goto|goto
name|bad
goto|;
name|no
operator|.
name|neg_vj
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CI_ADDRS
case|:
if|if
condition|(
name|go
operator|->
name|neg_addr
operator|&&
name|go
operator|->
name|old_addrs
operator|||
name|no
operator|.
name|old_addrs
operator|||
name|cilen
operator|!=
name|CILEN_ADDRS
condition|)
goto|goto
name|bad
goto|;
name|try
operator|.
name|neg_addr
operator|=
literal|1
expr_stmt|;
name|try
operator|.
name|old_addrs
operator|=
literal|1
expr_stmt|;
name|GETLONG
argument_list|(
name|l
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ciaddr1
operator|=
name|htonl
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ciaddr1
operator|&&
name|go
operator|->
name|accept_local
condition|)
name|try
operator|.
name|ouraddr
operator|=
name|ciaddr1
expr_stmt|;
name|GETLONG
argument_list|(
name|l
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ciaddr2
operator|=
name|htonl
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ciaddr2
operator|&&
name|go
operator|->
name|accept_remote
condition|)
name|try
operator|.
name|hisaddr
operator|=
name|ciaddr2
expr_stmt|;
name|no
operator|.
name|old_addrs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CI_ADDR
case|:
if|if
condition|(
name|go
operator|->
name|neg_addr
operator|||
name|no
operator|.
name|neg_addr
operator|||
name|cilen
operator|!=
name|CILEN_ADDR
condition|)
goto|goto
name|bad
goto|;
name|try
operator|.
name|neg_addr
operator|=
literal|1
expr_stmt|;
name|try
operator|.
name|old_addrs
operator|=
literal|0
expr_stmt|;
name|GETLONG
argument_list|(
name|l
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ciaddr1
operator|=
name|htonl
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ciaddr1
operator|&&
name|go
operator|->
name|accept_local
condition|)
name|try
operator|.
name|ouraddr
operator|=
name|ciaddr1
expr_stmt|;
name|no
operator|.
name|neg_addr
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
goto|goto
name|bad
goto|;
block|}
name|p
operator|=
name|next
expr_stmt|;
block|}
comment|/* If there is still anything left, this packet is bad. */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/*      * OK, the Nak is good.  Now we can update state.      */
if|if
condition|(
name|f
operator|->
name|state
operator|!=
name|OPENED
condition|)
operator|*
name|go
operator|=
name|try
expr_stmt|;
return|return
literal|1
return|;
name|bad
label|:
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ipcp_nakci: received bad Nak!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ipcp_rejci - Reject some of our CIs.  */
end_comment

begin_function
specifier|static
name|int
name|ipcp_rejci
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|ipcp_options
modifier|*
name|go
init|=
operator|&
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
name|cimaxslotindex
decl_stmt|,
name|ciflag
decl_stmt|,
name|cilen
decl_stmt|;
name|u_short
name|cishort
decl_stmt|;
name|u_long
name|cilong
decl_stmt|;
name|ipcp_options
name|try
decl_stmt|;
comment|/* options to request next time */
name|try
operator|=
operator|*
name|go
expr_stmt|;
comment|/*      * Any Rejected CIs must be in exactly the same order that we sent.      * Check packet length and CI length at each step.      * If we find any deviations, then this packet is bad.      */
define|#
directive|define
name|REJCIADDR
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|old
parameter_list|,
name|val1
parameter_list|,
name|val2
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= (cilen = old? CILEN_ADDRS: CILEN_ADDR)&& \ 	p[1] == cilen&& \ 	p[0] == opt) { \ 	u_long l; \ 	len -= cilen; \ 	INCPTR(2, p); \ 	GETLONG(l, p); \ 	cilong = htonl(l); \
comment|/* Check rejected value. */
value|\ 	if (cilong != val1) \ 	    goto bad; \ 	if (old) { \ 	    GETLONG(l, p); \ 	    cilong = htonl(l); \
comment|/* Check rejected value. */
value|\ 	    if (cilong != val2) \ 		goto bad; \ 	} \ 	try.neg = 0; \     }
define|#
directive|define
name|REJCIVJ
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|,
name|old
parameter_list|,
name|maxslot
parameter_list|,
name|cflag
parameter_list|)
define|\
value|if (go->neg&& \ 	p[1] == (old? CILEN_COMPRESS : CILEN_VJ)&& \ 	len>= p[1]&& \ 	p[0] == opt) { \ 	len -= p[1]; \ 	INCPTR(2, p); \ 	GETSHORT(cishort, p); \
comment|/* Check rejected value. */
value|\ 	if (cishort != val) \ 	    goto bad; \ 	if (!old) { \ 	   GETCHAR(cimaxslotindex, p); \ 	   if (cimaxslotindex != maxslot) \ 	     goto bad; \ 	   GETCHAR(ciflag, p); \ 	   if (ciflag != cflag) \ 	     goto bad; \         } \ 	try.neg = 0; \      }
name|REJCIADDR
argument_list|(
operator|(
name|go
operator|->
name|old_addrs
condition|?
name|CI_ADDRS
else|:
name|CI_ADDR
operator|)
argument_list|,
name|neg_addr
argument_list|,
name|go
operator|->
name|old_addrs
argument_list|,
name|go
operator|->
name|ouraddr
argument_list|,
name|go
operator|->
name|hisaddr
argument_list|)
expr_stmt|;
name|REJCIVJ
argument_list|(
name|CI_COMPRESSTYPE
argument_list|,
name|neg_vj
argument_list|,
name|go
operator|->
name|vj_protocol
argument_list|,
name|go
operator|->
name|old_vj
argument_list|,
name|go
operator|->
name|maxslotindex
argument_list|,
name|go
operator|->
name|cflag
argument_list|)
expr_stmt|;
comment|/*      * If there are any remaining CIs, then this packet is bad.      */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/*      * Now we can update state.      */
if|if
condition|(
name|f
operator|->
name|state
operator|!=
name|OPENED
condition|)
operator|*
name|go
operator|=
name|try
expr_stmt|;
return|return
literal|1
return|;
name|bad
label|:
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ipcp_rejci: received bad Reject!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ipcp_reqci - Check the peer's requested CIs and send appropriate response.  *  * Returns: CONFACK, CONFNAK or CONFREJ and input packet modified  * appropriately.  If reject_if_disagree is non-zero, doesn't return  * CONFNAK; returns CONFREJ if it can't return CONFACK.  */
end_comment

begin_function
specifier|static
name|int
name|ipcp_reqci
parameter_list|(
name|f
parameter_list|,
name|inp
parameter_list|,
name|len
parameter_list|,
name|reject_if_disagree
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
comment|/* Requested CIs */
name|int
modifier|*
name|len
decl_stmt|;
comment|/* Length of requested CIs */
name|int
name|reject_if_disagree
decl_stmt|;
block|{
name|ipcp_options
modifier|*
name|wo
init|=
operator|&
name|ipcp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipcp_options
modifier|*
name|ho
init|=
operator|&
name|ipcp_hisoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipcp_options
modifier|*
name|ao
init|=
operator|&
name|ipcp_allowoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipcp_options
modifier|*
name|go
init|=
operator|&
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
modifier|*
name|cip
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* Pointer to current and next CIs */
name|u_short
name|cilen
decl_stmt|,
name|citype
decl_stmt|;
comment|/* Parsed len, type */
name|u_short
name|cishort
decl_stmt|;
comment|/* Parsed short value */
name|u_long
name|tl
decl_stmt|,
name|ciaddr1
decl_stmt|,
name|ciaddr2
decl_stmt|;
comment|/* Parsed address values */
name|int
name|rc
init|=
name|CONFACK
decl_stmt|;
comment|/* Final packet return code */
name|int
name|orc
decl_stmt|;
comment|/* Individual option return code */
name|u_char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to next char to parse */
name|u_char
modifier|*
name|ucp
init|=
name|inp
decl_stmt|;
comment|/* Pointer to current output char */
name|int
name|l
init|=
operator|*
name|len
decl_stmt|;
comment|/* Length left */
name|u_char
name|maxslotindex
decl_stmt|,
name|cflag
decl_stmt|;
comment|/*      * Reset all his options.      */
name|BZERO
argument_list|(
name|ho
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ho
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Process all his options.      */
name|next
operator|=
name|inp
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
name|orc
operator|=
name|CONFACK
expr_stmt|;
comment|/* Assume success */
name|cip
operator|=
name|p
operator|=
name|next
expr_stmt|;
comment|/* Remember begining of CI */
if|if
condition|(
name|l
operator|<
literal|2
operator|||
comment|/* Not enough data for CI header or */
name|p
index|[
literal|1
index|]
operator|<
literal|2
operator|||
comment|/*  CI length too small or */
name|p
index|[
literal|1
index|]
operator|>
name|l
condition|)
block|{
comment|/*  CI length too big? */
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ipcp_reqci: bad CI length!"
operator|)
argument_list|)
expr_stmt|;
name|orc
operator|=
name|CONFREJ
expr_stmt|;
comment|/* Reject bad CI */
name|cilen
operator|=
name|l
expr_stmt|;
comment|/* Reject till end of packet */
name|l
operator|=
literal|0
expr_stmt|;
comment|/* Don't loop again */
goto|goto
name|endswitch
goto|;
block|}
name|GETCHAR
argument_list|(
name|citype
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Parse CI type */
name|GETCHAR
argument_list|(
name|cilen
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Parse CI length */
name|l
operator|-=
name|cilen
expr_stmt|;
comment|/* Adjust remaining length */
name|next
operator|+=
name|cilen
expr_stmt|;
comment|/* Step to next CI */
switch|switch
condition|(
name|citype
condition|)
block|{
comment|/* Check CI type */
case|case
name|CI_ADDRS
case|:
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ipcp: received ADDRS "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_addr
operator|||
name|cilen
operator|!=
name|CILEN_ADDRS
condition|)
block|{
comment|/* Check CI length */
name|orc
operator|=
name|CONFREJ
expr_stmt|;
comment|/* Reject CI */
break|break;
block|}
comment|/* 	     * If he has no address, or if we both have his address but 	     * disagree about it, then NAK it with our idea. 	     * In particular, if we don't know his address, but he does, 	     * then accept it. 	     */
name|GETLONG
argument_list|(
name|tl
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Parse source address (his) */
name|ciaddr1
operator|=
name|htonl
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"(%s:"
operator|,
name|ip_ntoa
argument_list|(
name|ciaddr1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ciaddr1
operator|!=
name|wo
operator|->
name|hisaddr
operator|&&
operator|(
name|ciaddr1
operator|==
literal|0
operator|||
operator|!
name|wo
operator|->
name|accept_remote
operator|)
condition|)
block|{
name|orc
operator|=
name|CONFNAK
expr_stmt|;
if|if
condition|(
operator|!
name|reject_if_disagree
condition|)
block|{
name|DECPTR
argument_list|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|tl
operator|=
name|ntohl
argument_list|(
name|wo
operator|->
name|hisaddr
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|tl
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	     * If he doesn't know our address, or if we both have our address 	     * but disagree about it, then NAK it with our idea. 	     */
name|GETLONG
argument_list|(
name|tl
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Parse desination address (ours) */
name|ciaddr2
operator|=
name|htonl
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"%s)"
operator|,
name|ip_ntoa
argument_list|(
name|ciaddr2
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ciaddr2
operator|!=
name|wo
operator|->
name|ouraddr
condition|)
block|{
if|if
condition|(
name|ciaddr2
operator|==
literal|0
operator|||
operator|!
name|wo
operator|->
name|accept_local
condition|)
block|{
name|orc
operator|=
name|CONFNAK
expr_stmt|;
if|if
condition|(
operator|!
name|reject_if_disagree
condition|)
block|{
name|DECPTR
argument_list|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|tl
operator|=
name|ntohl
argument_list|(
name|wo
operator|->
name|ouraddr
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|tl
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|go
operator|->
name|ouraddr
operator|=
name|ciaddr2
expr_stmt|;
comment|/* accept peer's idea */
block|}
block|}
name|ho
operator|->
name|neg_addr
operator|=
literal|1
expr_stmt|;
name|ho
operator|->
name|old_addrs
operator|=
literal|1
expr_stmt|;
name|ho
operator|->
name|hisaddr
operator|=
name|ciaddr1
expr_stmt|;
name|ho
operator|->
name|ouraddr
operator|=
name|ciaddr2
expr_stmt|;
break|break;
case|case
name|CI_ADDR
case|:
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ipcp: received ADDR "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_addr
operator|||
name|cilen
operator|!=
name|CILEN_ADDR
condition|)
block|{
comment|/* Check CI length */
name|orc
operator|=
name|CONFREJ
expr_stmt|;
comment|/* Reject CI */
break|break;
block|}
comment|/* 	     * If he has no address, or if we both have his address but 	     * disagree about it, then NAK it with our idea. 	     * In particular, if we don't know his address, but he does, 	     * then accept it. 	     */
name|GETLONG
argument_list|(
name|tl
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Parse source address (his) */
name|ciaddr1
operator|=
name|htonl
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"(%s)"
operator|,
name|ip_ntoa
argument_list|(
name|ciaddr1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ciaddr1
operator|!=
name|wo
operator|->
name|hisaddr
operator|&&
operator|(
name|ciaddr1
operator|==
literal|0
operator|||
operator|!
name|wo
operator|->
name|accept_remote
operator|)
condition|)
block|{
name|orc
operator|=
name|CONFNAK
expr_stmt|;
if|if
condition|(
operator|!
name|reject_if_disagree
condition|)
block|{
name|DECPTR
argument_list|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|tl
operator|=
name|ntohl
argument_list|(
name|wo
operator|->
name|hisaddr
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|tl
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|ho
operator|->
name|neg_addr
operator|=
literal|1
expr_stmt|;
name|ho
operator|->
name|hisaddr
operator|=
name|ciaddr1
expr_stmt|;
break|break;
case|case
name|CI_COMPRESSTYPE
case|:
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ipcp: received COMPRESSTYPE "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_vj
operator|||
operator|(
name|cilen
operator|!=
name|CILEN_VJ
operator|&&
name|cilen
operator|!=
name|CILEN_COMPRESS
operator|)
condition|)
block|{
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"(%d)"
operator|,
name|cishort
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cishort
operator|==
name|IPCP_VJ_COMP
operator|||
operator|(
name|cishort
operator|==
name|IPCP_VJ_COMP_OLD
operator|&&
name|cilen
operator|==
name|CILEN_COMPRESS
operator|)
operator|)
condition|)
block|{
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|ho
operator|->
name|neg_vj
operator|=
literal|1
expr_stmt|;
name|ho
operator|->
name|vj_protocol
operator|=
name|cishort
expr_stmt|;
if|if
condition|(
name|cilen
operator|==
name|CILEN_VJ
condition|)
block|{
name|GETCHAR
argument_list|(
name|maxslotindex
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxslotindex
operator|>
name|ao
operator|->
name|maxslotindex
condition|)
block|{
name|orc
operator|=
name|CONFNAK
expr_stmt|;
if|if
condition|(
operator|!
name|reject_if_disagree
condition|)
block|{
name|DECPTR
argument_list|(
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|ao
operator|->
name|maxslotindex
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|GETCHAR
argument_list|(
name|cflag
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|&&
operator|!
name|ao
operator|->
name|cflag
condition|)
block|{
name|orc
operator|=
name|CONFNAK
expr_stmt|;
if|if
condition|(
operator|!
name|reject_if_disagree
condition|)
block|{
name|DECPTR
argument_list|(
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|wo
operator|->
name|cflag
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|ho
operator|->
name|maxslotindex
operator|=
name|maxslotindex
expr_stmt|;
name|ho
operator|->
name|cflag
operator|=
name|wo
operator|->
name|cflag
expr_stmt|;
block|}
else|else
block|{
name|ho
operator|->
name|old_vj
operator|=
literal|1
expr_stmt|;
name|ho
operator|->
name|maxslotindex
operator|=
name|MAX_STATES
operator|-
literal|1
expr_stmt|;
name|ho
operator|->
name|cflag
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|endswitch
label|:
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|" (%s)\n"
operator|,
name|CODENAME
argument_list|(
name|orc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|orc
operator|==
name|CONFACK
operator|&&
comment|/* Good CI */
name|rc
operator|!=
name|CONFACK
condition|)
comment|/*  but prior CI wasnt? */
continue|continue;
comment|/* Don't send this one */
if|if
condition|(
name|orc
operator|==
name|CONFNAK
condition|)
block|{
comment|/* Nak this CI? */
if|if
condition|(
name|reject_if_disagree
condition|)
comment|/* Getting fed up with sending NAKs? */
name|orc
operator|=
name|CONFREJ
expr_stmt|;
comment|/* Get tough if so */
else|else
block|{
if|if
condition|(
name|rc
operator|==
name|CONFREJ
condition|)
comment|/* Rejecting prior CI? */
continue|continue;
comment|/* Don't send this one */
if|if
condition|(
name|rc
operator|==
name|CONFACK
condition|)
block|{
comment|/* Ack'd all prior CIs? */
name|rc
operator|=
name|CONFNAK
expr_stmt|;
comment|/* Not anymore... */
name|ucp
operator|=
name|inp
expr_stmt|;
comment|/* Backup */
block|}
block|}
block|}
if|if
condition|(
name|orc
operator|==
name|CONFREJ
operator|&&
comment|/* Reject this CI */
name|rc
operator|!=
name|CONFREJ
condition|)
block|{
comment|/*  but no prior ones? */
name|rc
operator|=
name|CONFREJ
expr_stmt|;
name|ucp
operator|=
name|inp
expr_stmt|;
comment|/* Backup */
block|}
comment|/* Need to move CI? */
if|if
condition|(
name|ucp
operator|!=
name|cip
condition|)
name|BCOPY
argument_list|(
name|cip
argument_list|,
name|ucp
argument_list|,
name|cilen
argument_list|)
expr_stmt|;
comment|/* Move it */
comment|/* Update output pointer */
name|INCPTR
argument_list|(
name|cilen
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we aren't rejecting this packet, and we want to negotiate      * their address, and they didn't send their address, then we      * send a NAK with a CI_ADDR option appended.  We assume the      * input buffer is long enough that we can append the extra      * option safely.      */
if|if
condition|(
name|rc
operator|!=
name|CONFREJ
operator|&&
operator|!
name|ho
operator|->
name|neg_addr
operator|&&
name|wo
operator|->
name|req_addr
operator|&&
operator|!
name|reject_if_disagree
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|CONFACK
condition|)
block|{
name|rc
operator|=
name|CONFNAK
expr_stmt|;
name|ucp
operator|=
name|inp
expr_stmt|;
comment|/* reset pointer */
name|wo
operator|->
name|req_addr
operator|=
literal|0
expr_stmt|;
comment|/* don't ask again */
block|}
name|PUTCHAR
argument_list|(
name|CI_ADDR
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CILEN_ADDR
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
name|tl
operator|=
name|ntohl
argument_list|(
name|wo
operator|->
name|hisaddr
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|tl
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
block|}
operator|*
name|len
operator|=
name|ucp
operator|-
name|inp
expr_stmt|;
comment|/* Compute output length */
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ipcp: returning Configure-%s"
operator|,
name|CODENAME
argument_list|(
name|rc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Return final code */
block|}
end_function

begin_comment
comment|/*  * ipcp_up - IPCP has come UP.  *  * Configure the IP network interface appropriately and bring it up.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_up
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|u_long
name|mask
decl_stmt|;
name|ipcp_options
modifier|*
name|ho
init|=
operator|&
name|ipcp_hisoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipcp_options
modifier|*
name|go
init|=
operator|&
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ipcp: up"
operator|)
argument_list|)
expr_stmt|;
name|go
operator|->
name|default_route
operator|=
literal|0
expr_stmt|;
name|go
operator|->
name|proxy_arp
operator|=
literal|0
expr_stmt|;
comment|/*      * We must have a non-zero IP address for both ends of the link.      */
if|if
condition|(
operator|!
name|ho
operator|->
name|neg_addr
condition|)
name|ho
operator|->
name|hisaddr
operator|=
name|ipcp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|hisaddr
expr_stmt|;
if|if
condition|(
name|ho
operator|->
name|hisaddr
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not determine remote IP address"
argument_list|)
expr_stmt|;
name|ipcp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|go
operator|->
name|ouraddr
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not determine local IP address"
argument_list|)
expr_stmt|;
name|ipcp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Check that the peer is allowed to use the IP address it wants.      */
if|if
condition|(
operator|!
name|auth_ip_addr
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|ho
operator|->
name|hisaddr
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Peer is not authorized to use remote address %s"
argument_list|,
name|ip_ntoa
argument_list|(
name|ho
operator|->
name|hisaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ipcp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"local  IP address %s"
argument_list|,
name|ip_ntoa
argument_list|(
name|go
operator|->
name|ouraddr
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"remote IP address %s"
argument_list|,
name|ip_ntoa
argument_list|(
name|ho
operator|->
name|hisaddr
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Set IP addresses and (if specified) netmask.      */
name|mask
operator|=
name|GetMask
argument_list|(
name|go
operator|->
name|ouraddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sifaddr
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|go
operator|->
name|ouraddr
argument_list|,
name|ho
operator|->
name|hisaddr
argument_list|,
name|mask
argument_list|)
condition|)
block|{
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_WARNING
operator|,
literal|"sifaddr failed"
operator|)
argument_list|)
expr_stmt|;
name|ipcp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* set tcp compression */
name|sifvjcomp
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|ho
operator|->
name|neg_vj
argument_list|,
name|ho
operator|->
name|cflag
argument_list|,
name|ho
operator|->
name|maxslotindex
argument_list|)
expr_stmt|;
comment|/* bring the interface up for IP */
if|if
condition|(
operator|!
name|sifup
argument_list|(
name|f
operator|->
name|unit
argument_list|)
condition|)
block|{
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_WARNING
operator|,
literal|"sifup failed"
operator|)
argument_list|)
expr_stmt|;
name|ipcp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* assign a default route through the interface if required */
if|if
condition|(
name|ipcp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|default_route
condition|)
if|if
condition|(
name|sifdefaultroute
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|ho
operator|->
name|hisaddr
argument_list|)
condition|)
name|go
operator|->
name|default_route
operator|=
literal|1
expr_stmt|;
comment|/* Make a proxy ARP entry if requested. */
if|if
condition|(
name|ipcp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|proxy_arp
condition|)
if|if
condition|(
name|sifproxyarp
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|ho
operator|->
name|hisaddr
argument_list|)
condition|)
name|go
operator|->
name|proxy_arp
operator|=
literal|1
expr_stmt|;
comment|/*      * Execute the ip-up script, like this:      *	/etc/ppp/ip-up interface tty speed local-IP remote-IP      */
name|ipcp_script
argument_list|(
name|f
argument_list|,
name|_PATH_IPUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_down - IPCP has gone DOWN.  *  * Take the IP network interface down, clear its addresses  * and delete routes through it.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_down
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|u_long
name|ouraddr
decl_stmt|,
name|hisaddr
decl_stmt|;
name|IPCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ipcp: down"
operator|)
argument_list|)
expr_stmt|;
name|ouraddr
operator|=
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|ouraddr
expr_stmt|;
name|hisaddr
operator|=
name|ipcp_hisoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|hisaddr
expr_stmt|;
if|if
condition|(
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|proxy_arp
condition|)
name|cifproxyarp
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|hisaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|default_route
condition|)
name|cifdefaultroute
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|hisaddr
argument_list|)
expr_stmt|;
name|sifdown
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
name|cifaddr
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|ouraddr
argument_list|,
name|hisaddr
argument_list|)
expr_stmt|;
comment|/* Execute the ip-down script */
name|ipcp_script
argument_list|(
name|f
argument_list|,
name|_PATH_IPDOWN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_script - Execute a script with arguments  * interface-name tty-name speed local-IP remote-IP.  */
end_comment

begin_function
specifier|static
name|void
name|ipcp_script
parameter_list|(
name|f
parameter_list|,
name|script
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|script
decl_stmt|;
block|{
name|char
name|strspeed
index|[
literal|32
index|]
decl_stmt|,
name|strlocal
index|[
literal|32
index|]
decl_stmt|,
name|strremote
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|8
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|strspeed
argument_list|,
literal|"%d"
argument_list|,
name|baud_rate
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|strlocal
argument_list|,
name|ip_ntoa
argument_list|(
name|ipcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|ouraddr
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|strremote
argument_list|,
name|ip_ntoa
argument_list|(
name|ipcp_hisoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|hisaddr
argument_list|)
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|script
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|ifname
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|devname
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|=
name|strspeed
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|=
name|strlocal
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|=
name|strremote
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
name|run_program
argument_list|(
name|script
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipcp_printpkt - print the contents of an IPCP packet.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ipcp_codenames
index|[]
init|=
block|{
literal|"ConfReq"
block|,
literal|"ConfAck"
block|,
literal|"ConfNak"
block|,
literal|"ConfRej"
block|,
literal|"TermReq"
block|,
literal|"TermAck"
block|,
literal|"CodeRej"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipcp_printpkt
argument_list|(
name|p
argument_list|,
name|plen
argument_list|,
name|printer
argument_list|,
name|arg
argument_list|)
name|u_char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|plen
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|printer
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|code
decl_stmt|,
name|id
decl_stmt|,
name|len
decl_stmt|,
name|olen
decl_stmt|;
name|u_char
modifier|*
name|pstart
decl_stmt|,
modifier|*
name|optend
decl_stmt|;
name|u_short
name|cishort
decl_stmt|;
name|u_long
name|cilong
decl_stmt|;
if|if
condition|(
name|plen
operator|<
name|HEADERLEN
condition|)
return|return
literal|0
return|;
name|pstart
operator|=
name|p
expr_stmt|;
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|id
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|len
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|HEADERLEN
operator|||
name|len
operator|>
name|plen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|>=
literal|1
operator|&&
name|code
operator|<=
sizeof|sizeof
argument_list|(
name|ipcp_codenames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %s"
argument_list|,
name|ipcp_codenames
index|[
name|code
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|printer
argument_list|(
name|arg
argument_list|,
literal|" code=0x%x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" id=0x%x"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|len
operator|-=
name|HEADERLEN
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONFREQ
case|:
case|case
name|CONFACK
case|:
case|case
name|CONFNAK
case|:
case|case
name|CONFREJ
case|:
comment|/* print option list */
while|while
condition|(
name|len
operator|>=
literal|2
condition|)
block|{
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|olen
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|olen
operator|<
literal|2
operator|||
name|olen
operator|>
name|len
condition|)
block|{
break|break;
block|}
name|printer
argument_list|(
name|arg
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|len
operator|-=
name|olen
expr_stmt|;
name|optend
operator|=
name|p
operator|+
name|olen
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CI_ADDRS
case|:
if|if
condition|(
name|olen
operator|==
name|CILEN_ADDRS
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|GETLONG
argument_list|(
name|cilong
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"addrs %s"
argument_list|,
name|ip_ntoa
argument_list|(
name|htonl
argument_list|(
name|cilong
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|cilong
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %s"
argument_list|,
name|ip_ntoa
argument_list|(
name|htonl
argument_list|(
name|cilong
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CI_COMPRESSTYPE
case|:
if|if
condition|(
name|olen
operator|>=
name|CILEN_COMPRESS
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"compress "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cishort
condition|)
block|{
case|case
name|IPCP_VJ_COMP
case|:
name|printer
argument_list|(
name|arg
argument_list|,
literal|"VJ"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPCP_VJ_COMP_OLD
case|:
name|printer
argument_list|(
name|arg
argument_list|,
literal|"old-VJ"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printer
argument_list|(
name|arg
argument_list|,
literal|"0x%x"
argument_list|,
name|cishort
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CI_ADDR
case|:
if|if
condition|(
name|olen
operator|==
name|CILEN_ADDR
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|GETLONG
argument_list|(
name|cilong
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"addr %s"
argument_list|,
name|ip_ntoa
argument_list|(
name|htonl
argument_list|(
name|cilong
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
while|while
condition|(
name|p
operator|<
name|optend
condition|)
block|{
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %.2x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
name|printer
argument_list|(
name|arg
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* print the rest of the bytes in the packet */
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
block|{
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %.2x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
return|return
name|p
operator|-
name|pstart
return|;
block|}
end_block

end_unit

