begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * lcp.c - PPP Link Control Protocol.  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * TODO:  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|"pppd.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"magic.h"
end_include

begin_comment
comment|/* global vars */
end_comment

begin_decl_stmt
name|fsm
name|lcp_fsm
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LCP fsm structure (global)*/
end_comment

begin_decl_stmt
name|lcp_options
name|lcp_wantoptions
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options that we want to request */
end_comment

begin_decl_stmt
name|lcp_options
name|lcp_gotoptions
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options that peer ack'd */
end_comment

begin_decl_stmt
name|lcp_options
name|lcp_allowoptions
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options we allow peer to request */
end_comment

begin_decl_stmt
name|lcp_options
name|lcp_hisoptions
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options that we ack'd */
end_comment

begin_decl_stmt
name|u_int32_t
name|xmit_accm
index|[
name|NUM_PPP
index|]
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* extended transmit ACCM */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|lcp_echos_pending
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of outstanding echo msgs */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|lcp_echo_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ID number of next echo frame */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|lcp_echo_timer_running
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if a timer is running */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|nak_buffer
index|[
name|PPP_MRU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where we construct a nak packet */
end_comment

begin_comment
comment|/*  * Callbacks for fsm code.  (CI = Configuration Information)  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|lcp_resetci
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reset our CI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lcp_cilen
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return length of our CI */
end_comment

begin_decl_stmt
specifier|static
name|void
name|lcp_addci
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add our CI to pkt */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lcp_ackci
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Peer ack'd our CI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lcp_nakci
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Peer nak'd our CI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lcp_rejci
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Peer rej'd our CI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lcp_reqci
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Rcv peer CI */
end_comment

begin_decl_stmt
specifier|static
name|void
name|lcp_up
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We're UP */
end_comment

begin_decl_stmt
specifier|static
name|void
name|lcp_down
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We're DOWN */
end_comment

begin_decl_stmt
specifier|static
name|void
name|lcp_starting
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We need lower layer up */
end_comment

begin_decl_stmt
specifier|static
name|void
name|lcp_finished
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We need lower layer down */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lcp_extcode
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lcp_rprotrej
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * routines to send LCP echos to peer  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|lcp_echo_lowerup
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lcp_echo_lowerdown
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|LcpEchoTimeout
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lcp_received_echo_reply
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|,
name|int
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|LcpSendEchoRequest
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|LcpLinkFailure
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|LcpEchoCheck
name|__P
argument_list|(
operator|(
name|fsm
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fsm_callbacks
name|lcp_callbacks
init|=
block|{
comment|/* LCP callback routines */
name|lcp_resetci
block|,
comment|/* Reset our Configuration Information */
name|lcp_cilen
block|,
comment|/* Length of our Configuration Information */
name|lcp_addci
block|,
comment|/* Add our Configuration Information */
name|lcp_ackci
block|,
comment|/* ACK our Configuration Information */
name|lcp_nakci
block|,
comment|/* NAK our Configuration Information */
name|lcp_rejci
block|,
comment|/* Reject our Configuration Information */
name|lcp_reqci
block|,
comment|/* Request peer's Configuration Information */
name|lcp_up
block|,
comment|/* Called when fsm reaches OPENED state */
name|lcp_down
block|,
comment|/* Called when fsm leaves OPENED state */
name|lcp_starting
block|,
comment|/* Called when we want the lower layer up */
name|lcp_finished
block|,
comment|/* Called when we want the lower layer down */
name|NULL
block|,
comment|/* Called when Protocol-Reject received */
name|NULL
block|,
comment|/* Retransmission is necessary */
name|lcp_extcode
block|,
comment|/* Called to handle LCP-specific codes */
literal|"LCP"
comment|/* String name of protocol */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Protocol entry points.  * Some of these are called directly.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|lcp_init
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lcp_input
name|__P
argument_list|(
operator|(
name|int
operator|,
name|u_char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lcp_protrej
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lcp_printpkt
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|,
name|int
operator|,
name|void
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|protent
name|lcp_protent
init|=
block|{
name|PPP_LCP
block|,
name|lcp_init
block|,
name|lcp_input
block|,
name|lcp_protrej
block|,
name|lcp_lowerup
block|,
name|lcp_lowerdown
block|,
name|lcp_open
block|,
name|lcp_close
block|,
name|lcp_printpkt
block|,
name|NULL
block|,
literal|1
block|,
literal|"LCP"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lcp_loopbackfail
init|=
name|DEFLOOPBACKFAIL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Length of each type of configuration option (in octets)  */
end_comment

begin_define
define|#
directive|define
name|CILEN_VOID
value|2
end_define

begin_define
define|#
directive|define
name|CILEN_CHAR
value|3
end_define

begin_define
define|#
directive|define
name|CILEN_SHORT
value|4
end_define

begin_comment
comment|/* CILEN_VOID + sizeof(short) */
end_comment

begin_define
define|#
directive|define
name|CILEN_CHAP
value|5
end_define

begin_comment
comment|/* CILEN_VOID + sizeof(short) + 1 */
end_comment

begin_define
define|#
directive|define
name|CILEN_LONG
value|6
end_define

begin_comment
comment|/* CILEN_VOID + sizeof(long) */
end_comment

begin_define
define|#
directive|define
name|CILEN_LQR
value|8
end_define

begin_comment
comment|/* CILEN_VOID + sizeof(short) + sizeof(long) */
end_comment

begin_define
define|#
directive|define
name|CILEN_CBCP
value|3
end_define

begin_define
define|#
directive|define
name|CODENAME
parameter_list|(
name|x
parameter_list|)
value|((x) == CONFACK ? "ACK" : \ 			 (x) == CONFNAK ? "NAK" : "REJ")
end_define

begin_comment
comment|/*  * lcp_init - Initialize LCP.  */
end_comment

begin_function
specifier|static
name|void
name|lcp_init
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm
modifier|*
name|f
init|=
operator|&
name|lcp_fsm
index|[
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|wo
init|=
operator|&
name|lcp_wantoptions
index|[
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|ao
init|=
operator|&
name|lcp_allowoptions
index|[
name|unit
index|]
decl_stmt|;
name|f
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|f
operator|->
name|protocol
operator|=
name|PPP_LCP
expr_stmt|;
name|f
operator|->
name|callbacks
operator|=
operator|&
name|lcp_callbacks
expr_stmt|;
name|fsm_init
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|wo
operator|->
name|passive
operator|=
literal|0
expr_stmt|;
name|wo
operator|->
name|silent
operator|=
literal|0
expr_stmt|;
name|wo
operator|->
name|restart
operator|=
literal|0
expr_stmt|;
comment|/* Set to 1 in kernels or multi-line 					   implementations */
name|wo
operator|->
name|neg_mru
operator|=
literal|1
expr_stmt|;
name|wo
operator|->
name|mru
operator|=
name|DEFMRU
expr_stmt|;
name|wo
operator|->
name|neg_asyncmap
operator|=
literal|0
expr_stmt|;
name|wo
operator|->
name|asyncmap
operator|=
literal|0
expr_stmt|;
name|wo
operator|->
name|neg_chap
operator|=
literal|0
expr_stmt|;
comment|/* Set to 1 on server */
name|wo
operator|->
name|neg_upap
operator|=
literal|0
expr_stmt|;
comment|/* Set to 1 on server */
name|wo
operator|->
name|chap_mdtype
operator|=
name|CHAP_DIGEST_MD5
expr_stmt|;
name|wo
operator|->
name|neg_magicnumber
operator|=
literal|1
expr_stmt|;
name|wo
operator|->
name|neg_pcompression
operator|=
literal|1
expr_stmt|;
name|wo
operator|->
name|neg_accompression
operator|=
literal|1
expr_stmt|;
name|wo
operator|->
name|neg_lqr
operator|=
literal|0
expr_stmt|;
comment|/* no LQR implementation yet */
name|wo
operator|->
name|neg_cbcp
operator|=
literal|0
expr_stmt|;
name|ao
operator|->
name|neg_mru
operator|=
literal|1
expr_stmt|;
name|ao
operator|->
name|mru
operator|=
name|MAXMRU
expr_stmt|;
name|ao
operator|->
name|neg_asyncmap
operator|=
literal|1
expr_stmt|;
name|ao
operator|->
name|asyncmap
operator|=
literal|0
expr_stmt|;
name|ao
operator|->
name|neg_chap
operator|=
literal|1
expr_stmt|;
name|ao
operator|->
name|chap_mdtype
operator|=
name|CHAP_DIGEST_MD5
expr_stmt|;
name|ao
operator|->
name|neg_upap
operator|=
literal|1
expr_stmt|;
name|ao
operator|->
name|neg_magicnumber
operator|=
literal|1
expr_stmt|;
name|ao
operator|->
name|neg_pcompression
operator|=
literal|1
expr_stmt|;
name|ao
operator|->
name|neg_accompression
operator|=
literal|1
expr_stmt|;
name|ao
operator|->
name|neg_lqr
operator|=
literal|0
expr_stmt|;
comment|/* no LQR implementation yet */
ifdef|#
directive|ifdef
name|CBCP_SUPPORT
name|ao
operator|->
name|neg_cbcp
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|ao
operator|->
name|neg_cbcp
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|xmit_accm
index|[
name|unit
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xmit_accm
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|xmit_accm
index|[
name|unit
index|]
index|[
literal|3
index|]
operator|=
literal|0x60000000
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_open - LCP is allowed to come up.  */
end_comment

begin_function
name|void
name|lcp_open
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm
modifier|*
name|f
init|=
operator|&
name|lcp_fsm
index|[
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|wo
init|=
operator|&
name|lcp_wantoptions
index|[
name|unit
index|]
decl_stmt|;
name|f
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wo
operator|->
name|passive
condition|)
name|f
operator|->
name|flags
operator||=
name|OPT_PASSIVE
expr_stmt|;
if|if
condition|(
name|wo
operator|->
name|silent
condition|)
name|f
operator|->
name|flags
operator||=
name|OPT_SILENT
expr_stmt|;
name|fsm_open
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_close - Take LCP down.  */
end_comment

begin_function
name|void
name|lcp_close
parameter_list|(
name|unit
parameter_list|,
name|reason
parameter_list|)
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|;
block|{
name|fsm
modifier|*
name|f
init|=
operator|&
name|lcp_fsm
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|phase
operator|!=
name|PHASE_DEAD
condition|)
name|phase
operator|=
name|PHASE_TERMINATE
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|state
operator|==
name|STOPPED
operator|&&
name|f
operator|->
name|flags
operator|&
operator|(
name|OPT_PASSIVE
operator||
name|OPT_SILENT
operator|)
condition|)
block|{
comment|/* 	 * This action is not strictly according to the FSM in RFC1548, 	 * but it does mean that the program terminates if you do a 	 * lcp_close() in passive/silent mode when a connection hasn't 	 * been established. 	 */
name|f
operator|->
name|state
operator|=
name|CLOSED
expr_stmt|;
name|lcp_finished
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
else|else
name|fsm_close
argument_list|(
operator|&
name|lcp_fsm
index|[
name|unit
index|]
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_lowerup - The lower layer is up.  */
end_comment

begin_function
name|void
name|lcp_lowerup
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|lcp_options
modifier|*
name|wo
init|=
operator|&
name|lcp_wantoptions
index|[
name|unit
index|]
decl_stmt|;
comment|/*      * Don't use A/C or protocol compression on transmission,      * but accept A/C and protocol compressed packets      * if we are going to ask for A/C and protocol compression.      */
name|ppp_set_xaccm
argument_list|(
name|unit
argument_list|,
name|xmit_accm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|ppp_send_config
argument_list|(
name|unit
argument_list|,
name|PPP_MRU
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ppp_recv_config
argument_list|(
name|unit
argument_list|,
name|PPP_MRU
argument_list|,
literal|0xffffffff
argument_list|,
name|wo
operator|->
name|neg_pcompression
argument_list|,
name|wo
operator|->
name|neg_accompression
argument_list|)
expr_stmt|;
name|peer_mru
index|[
name|unit
index|]
operator|=
name|PPP_MRU
expr_stmt|;
name|lcp_allowoptions
index|[
name|unit
index|]
operator|.
name|asyncmap
operator|=
name|xmit_accm
index|[
name|unit
index|]
index|[
literal|0
index|]
expr_stmt|;
name|fsm_lowerup
argument_list|(
operator|&
name|lcp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_lowerdown - The lower layer is down.  */
end_comment

begin_function
name|void
name|lcp_lowerdown
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm_lowerdown
argument_list|(
operator|&
name|lcp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_input - Input LCP packet.  */
end_comment

begin_function
specifier|static
name|void
name|lcp_input
parameter_list|(
name|unit
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|fsm
modifier|*
name|f
init|=
operator|&
name|lcp_fsm
index|[
name|unit
index|]
decl_stmt|;
name|fsm_input
argument_list|(
name|f
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_extcode - Handle a LCP-specific code.  */
end_comment

begin_function
specifier|static
name|int
name|lcp_extcode
parameter_list|(
name|f
parameter_list|,
name|code
parameter_list|,
name|id
parameter_list|,
name|inp
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|int
name|code
decl_stmt|,
name|id
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|u_char
modifier|*
name|magp
decl_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PROTREJ
case|:
name|lcp_rprotrej
argument_list|(
name|f
argument_list|,
name|inp
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECHOREQ
case|:
if|if
condition|(
name|f
operator|->
name|state
operator|!=
name|OPENED
condition|)
break|break;
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp: Echo-Request, Rcvd id %d"
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
name|magp
operator|=
name|inp
expr_stmt|;
name|PUTLONG
argument_list|(
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|magicnumber
argument_list|,
name|magp
argument_list|)
expr_stmt|;
name|fsm_sdata
argument_list|(
name|f
argument_list|,
name|ECHOREP
argument_list|,
name|id
argument_list|,
name|inp
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|ECHOREP
case|:
name|lcp_received_echo_reply
argument_list|(
name|f
argument_list|,
name|id
argument_list|,
name|inp
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|DISCREQ
case|:
break|break;
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * lcp_rprotrej - Receive an Protocol-Reject.  *  * Figure out which protocol is rejected and inform it.  */
end_comment

begin_function
specifier|static
name|void
name|lcp_rprotrej
parameter_list|(
name|f
parameter_list|,
name|inp
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|protent
modifier|*
name|protp
decl_stmt|;
name|u_short
name|prot
decl_stmt|;
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_rprotrej."
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
block|{
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_rprotrej: Rcvd short Protocol-Reject packet!"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|GETSHORT
argument_list|(
name|prot
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_rprotrej: Rcvd Protocol-Reject packet for %x!"
operator|,
name|prot
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Protocol-Reject packets received in any state other than the LCP      * OPENED state SHOULD be silently discarded.      */
if|if
condition|(
name|f
operator|->
name|state
operator|!=
name|OPENED
condition|)
block|{
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"Protocol-Reject discarded: LCP in state %d"
operator|,
name|f
operator|->
name|state
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Upcall the proper Protocol-Reject routine.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|protp
operator|=
name|protocols
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|protp
operator|->
name|protocol
operator|==
name|prot
operator|&&
name|protp
operator|->
name|enabled_flag
condition|)
block|{
call|(
modifier|*
name|protp
operator|->
name|protrej
call|)
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Protocol-Reject for unsupported protocol 0x%x"
argument_list|,
name|prot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_protrej - A Protocol-Reject was received.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|lcp_protrej
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
comment|/*      * Can't reject LCP!      */
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_WARNING
operator|,
literal|"lcp_protrej: Received Protocol-Reject for LCP!"
operator|)
argument_list|)
expr_stmt|;
name|fsm_protreject
argument_list|(
operator|&
name|lcp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_sprotrej - Send a Protocol-Reject for some protocol.  */
end_comment

begin_function
name|void
name|lcp_sprotrej
parameter_list|(
name|unit
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
comment|/*      * Send back the protocol and the information field of the      * rejected packet.  We only get here if LCP is in the OPENED state.      */
name|p
operator|+=
literal|2
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
name|fsm_sdata
argument_list|(
operator|&
name|lcp_fsm
index|[
name|unit
index|]
argument_list|,
name|PROTREJ
argument_list|,
operator|++
name|lcp_fsm
index|[
name|unit
index|]
operator|.
name|id
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_resetci - Reset our CI.  */
end_comment

begin_function
specifier|static
name|void
name|lcp_resetci
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|lcp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|magicnumber
operator|=
name|magic
argument_list|()
expr_stmt|;
name|lcp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|numloops
operator|=
literal|0
expr_stmt|;
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
operator|=
name|lcp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
expr_stmt|;
name|peer_mru
index|[
name|f
operator|->
name|unit
index|]
operator|=
name|PPP_MRU
expr_stmt|;
name|auth_reset
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_cilen - Return length of our CI.  */
end_comment

begin_function
specifier|static
name|int
name|lcp_cilen
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
define|#
directive|define
name|LENCIVOID
parameter_list|(
name|neg
parameter_list|)
value|((neg) ? CILEN_VOID : 0)
define|#
directive|define
name|LENCICHAP
parameter_list|(
name|neg
parameter_list|)
value|((neg) ? CILEN_CHAP : 0)
define|#
directive|define
name|LENCISHORT
parameter_list|(
name|neg
parameter_list|)
value|((neg) ? CILEN_SHORT : 0)
define|#
directive|define
name|LENCILONG
parameter_list|(
name|neg
parameter_list|)
value|((neg) ? CILEN_LONG : 0)
define|#
directive|define
name|LENCILQR
parameter_list|(
name|neg
parameter_list|)
value|((neg) ? CILEN_LQR: 0)
define|#
directive|define
name|LENCICBCP
parameter_list|(
name|neg
parameter_list|)
value|((neg) ? CILEN_CBCP: 0)
comment|/*      * NB: we only ask for one of CHAP and UPAP, even if we will      * accept either.      */
return|return
operator|(
name|LENCISHORT
argument_list|(
name|go
operator|->
name|neg_mru
operator|&&
name|go
operator|->
name|mru
operator|!=
name|DEFMRU
argument_list|)
operator|+
name|LENCILONG
argument_list|(
name|go
operator|->
name|neg_asyncmap
operator|&&
name|go
operator|->
name|asyncmap
operator|!=
literal|0xFFFFFFFF
argument_list|)
operator|+
name|LENCICHAP
argument_list|(
name|go
operator|->
name|neg_chap
argument_list|)
operator|+
name|LENCISHORT
argument_list|(
operator|!
name|go
operator|->
name|neg_chap
operator|&&
name|go
operator|->
name|neg_upap
argument_list|)
operator|+
name|LENCILQR
argument_list|(
name|go
operator|->
name|neg_lqr
argument_list|)
operator|+
name|LENCICBCP
argument_list|(
name|go
operator|->
name|neg_cbcp
argument_list|)
operator|+
name|LENCILONG
argument_list|(
name|go
operator|->
name|neg_magicnumber
argument_list|)
operator|+
name|LENCIVOID
argument_list|(
name|go
operator|->
name|neg_pcompression
argument_list|)
operator|+
name|LENCIVOID
argument_list|(
name|go
operator|->
name|neg_accompression
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lcp_addci - Add our desired CIs to a packet.  */
end_comment

begin_function
specifier|static
name|void
name|lcp_addci
parameter_list|(
name|f
parameter_list|,
name|ucp
parameter_list|,
name|lenp
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|ucp
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
block|{
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
modifier|*
name|start_ucp
init|=
name|ucp
decl_stmt|;
define|#
directive|define
name|ADDCIVOID
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|)
define|\
value|if (neg) { \ 	PUTCHAR(opt, ucp); \ 	PUTCHAR(CILEN_VOID, ucp); \     }
define|#
directive|define
name|ADDCISHORT
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (neg) { \ 	PUTCHAR(opt, ucp); \ 	PUTCHAR(CILEN_SHORT, ucp); \ 	PUTSHORT(val, ucp); \     }
define|#
directive|define
name|ADDCICHAP
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|,
name|digest
parameter_list|)
define|\
value|if (neg) { \ 	PUTCHAR(opt, ucp); \ 	PUTCHAR(CILEN_CHAP, ucp); \ 	PUTSHORT(val, ucp); \ 	PUTCHAR(digest, ucp); \     }
define|#
directive|define
name|ADDCILONG
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (neg) { \ 	PUTCHAR(opt, ucp); \ 	PUTCHAR(CILEN_LONG, ucp); \ 	PUTLONG(val, ucp); \     }
define|#
directive|define
name|ADDCILQR
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (neg) { \ 	PUTCHAR(opt, ucp); \ 	PUTCHAR(CILEN_LQR, ucp); \ 	PUTSHORT(PPP_LQR, ucp); \ 	PUTLONG(val, ucp); \     }
define|#
directive|define
name|ADDCICHAR
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (neg) { \ 	PUTCHAR(opt, ucp); \ 	PUTCHAR(CILEN_CHAR, ucp); \ 	PUTCHAR(val, ucp); \     }
name|ADDCISHORT
argument_list|(
name|CI_MRU
argument_list|,
name|go
operator|->
name|neg_mru
operator|&&
name|go
operator|->
name|mru
operator|!=
name|DEFMRU
argument_list|,
name|go
operator|->
name|mru
argument_list|)
expr_stmt|;
name|ADDCILONG
argument_list|(
name|CI_ASYNCMAP
argument_list|,
name|go
operator|->
name|neg_asyncmap
operator|&&
name|go
operator|->
name|asyncmap
operator|!=
literal|0xFFFFFFFF
argument_list|,
name|go
operator|->
name|asyncmap
argument_list|)
expr_stmt|;
name|ADDCICHAP
argument_list|(
name|CI_AUTHTYPE
argument_list|,
name|go
operator|->
name|neg_chap
argument_list|,
name|PPP_CHAP
argument_list|,
name|go
operator|->
name|chap_mdtype
argument_list|)
expr_stmt|;
name|ADDCISHORT
argument_list|(
name|CI_AUTHTYPE
argument_list|,
operator|!
name|go
operator|->
name|neg_chap
operator|&&
name|go
operator|->
name|neg_upap
argument_list|,
name|PPP_PAP
argument_list|)
expr_stmt|;
name|ADDCILQR
argument_list|(
name|CI_QUALITY
argument_list|,
name|go
operator|->
name|neg_lqr
argument_list|,
name|go
operator|->
name|lqr_period
argument_list|)
expr_stmt|;
name|ADDCICHAR
argument_list|(
name|CI_CALLBACK
argument_list|,
name|go
operator|->
name|neg_cbcp
argument_list|,
name|CBCP_OPT
argument_list|)
expr_stmt|;
name|ADDCILONG
argument_list|(
name|CI_MAGICNUMBER
argument_list|,
name|go
operator|->
name|neg_magicnumber
argument_list|,
name|go
operator|->
name|magicnumber
argument_list|)
expr_stmt|;
name|ADDCIVOID
argument_list|(
name|CI_PCOMPRESSION
argument_list|,
name|go
operator|->
name|neg_pcompression
argument_list|)
expr_stmt|;
name|ADDCIVOID
argument_list|(
name|CI_ACCOMPRESSION
argument_list|,
name|go
operator|->
name|neg_accompression
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucp
operator|-
name|start_ucp
operator|!=
operator|*
name|lenp
condition|)
block|{
comment|/* this should never happen, because peer_mtu should be 1500 */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Bug in lcp_addci: wrong length"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * lcp_ackci - Ack our CIs.  * This should not modify any state if the Ack is bad.  *  * Returns:  *	0 - Ack was bad.  *	1 - Ack was good.  */
end_comment

begin_function
specifier|static
name|int
name|lcp_ackci
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
name|cilen
decl_stmt|,
name|citype
decl_stmt|,
name|cichar
decl_stmt|;
name|u_short
name|cishort
decl_stmt|;
name|u_int32_t
name|cilong
decl_stmt|;
comment|/*      * CIs must be in exactly the same order that we sent.      * Check packet length and CI length at each step.      * If we find any deviations, then this packet is bad.      */
define|#
directive|define
name|ACKCIVOID
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|)
define|\
value|if (neg) { \ 	if ((len -= CILEN_VOID)< 0) \ 	    goto bad; \ 	GETCHAR(citype, p); \ 	GETCHAR(cilen, p); \ 	if (cilen != CILEN_VOID || \ 	    citype != opt) \ 	    goto bad; \     }
define|#
directive|define
name|ACKCISHORT
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (neg) { \ 	if ((len -= CILEN_SHORT)< 0) \ 	    goto bad; \ 	GETCHAR(citype, p); \ 	GETCHAR(cilen, p); \ 	if (cilen != CILEN_SHORT || \ 	    citype != opt) \ 	    goto bad; \ 	GETSHORT(cishort, p); \ 	if (cishort != val) \ 	    goto bad; \     }
define|#
directive|define
name|ACKCICHAR
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (neg) { \ 	if ((len -= CILEN_CHAR)< 0) \ 	    goto bad; \ 	GETCHAR(citype, p); \ 	GETCHAR(cilen, p); \ 	if (cilen != CILEN_CHAR || \ 	    citype != opt) \ 	    goto bad; \ 	GETCHAR(cichar, p); \ 	if (cichar != val) \ 	    goto bad; \     }
define|#
directive|define
name|ACKCICHAP
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|,
name|digest
parameter_list|)
define|\
value|if (neg) { \ 	if ((len -= CILEN_CHAP)< 0) \ 	    goto bad; \ 	GETCHAR(citype, p); \ 	GETCHAR(cilen, p); \ 	if (cilen != CILEN_CHAP || \ 	    citype != opt) \ 	    goto bad; \ 	GETSHORT(cishort, p); \ 	if (cishort != val) \ 	    goto bad; \ 	GETCHAR(cichar, p); \ 	if (cichar != digest) \ 	  goto bad; \     }
define|#
directive|define
name|ACKCILONG
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (neg) { \ 	if ((len -= CILEN_LONG)< 0) \ 	    goto bad; \ 	GETCHAR(citype, p); \ 	GETCHAR(cilen, p); \ 	if (cilen != CILEN_LONG || \ 	    citype != opt) \ 	    goto bad; \ 	GETLONG(cilong, p); \ 	if (cilong != val) \ 	    goto bad; \     }
define|#
directive|define
name|ACKCILQR
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (neg) { \ 	if ((len -= CILEN_LQR)< 0) \ 	    goto bad; \ 	GETCHAR(citype, p); \ 	GETCHAR(cilen, p); \ 	if (cilen != CILEN_LQR || \ 	    citype != opt) \ 	    goto bad; \ 	GETSHORT(cishort, p); \ 	if (cishort != PPP_LQR) \ 	    goto bad; \ 	GETLONG(cilong, p); \ 	if (cilong != val) \ 	  goto bad; \     }
name|ACKCISHORT
argument_list|(
name|CI_MRU
argument_list|,
name|go
operator|->
name|neg_mru
operator|&&
name|go
operator|->
name|mru
operator|!=
name|DEFMRU
argument_list|,
name|go
operator|->
name|mru
argument_list|)
expr_stmt|;
name|ACKCILONG
argument_list|(
name|CI_ASYNCMAP
argument_list|,
name|go
operator|->
name|neg_asyncmap
operator|&&
name|go
operator|->
name|asyncmap
operator|!=
literal|0xFFFFFFFF
argument_list|,
name|go
operator|->
name|asyncmap
argument_list|)
expr_stmt|;
name|ACKCICHAP
argument_list|(
name|CI_AUTHTYPE
argument_list|,
name|go
operator|->
name|neg_chap
argument_list|,
name|PPP_CHAP
argument_list|,
name|go
operator|->
name|chap_mdtype
argument_list|)
expr_stmt|;
name|ACKCISHORT
argument_list|(
name|CI_AUTHTYPE
argument_list|,
operator|!
name|go
operator|->
name|neg_chap
operator|&&
name|go
operator|->
name|neg_upap
argument_list|,
name|PPP_PAP
argument_list|)
expr_stmt|;
name|ACKCILQR
argument_list|(
name|CI_QUALITY
argument_list|,
name|go
operator|->
name|neg_lqr
argument_list|,
name|go
operator|->
name|lqr_period
argument_list|)
expr_stmt|;
name|ACKCICHAR
argument_list|(
name|CI_CALLBACK
argument_list|,
name|go
operator|->
name|neg_cbcp
argument_list|,
name|CBCP_OPT
argument_list|)
expr_stmt|;
name|ACKCILONG
argument_list|(
name|CI_MAGICNUMBER
argument_list|,
name|go
operator|->
name|neg_magicnumber
argument_list|,
name|go
operator|->
name|magicnumber
argument_list|)
expr_stmt|;
name|ACKCIVOID
argument_list|(
name|CI_PCOMPRESSION
argument_list|,
name|go
operator|->
name|neg_pcompression
argument_list|)
expr_stmt|;
name|ACKCIVOID
argument_list|(
name|CI_ACCOMPRESSION
argument_list|,
name|go
operator|->
name|neg_accompression
argument_list|)
expr_stmt|;
comment|/*      * If there are any remaining CIs, then this packet is bad.      */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
return|return
operator|(
literal|1
operator|)
return|;
name|bad
label|:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_WARNING
operator|,
literal|"lcp_acki: received bad Ack!"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lcp_nakci - Peer has sent a NAK for some of our CIs.  * This should not modify any state if the Nak is bad  * or if LCP is in the OPENED state.  *  * Returns:  *	0 - Nak was bad.  *	1 - Nak was good.  */
end_comment

begin_function
specifier|static
name|int
name|lcp_nakci
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|wo
init|=
operator|&
name|lcp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
name|citype
decl_stmt|,
name|cichar
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|u_short
name|cishort
decl_stmt|;
name|u_int32_t
name|cilong
decl_stmt|;
name|lcp_options
name|no
decl_stmt|;
comment|/* options we've seen Naks for */
name|lcp_options
name|try
decl_stmt|;
comment|/* options to request next time */
name|int
name|looped_back
init|=
literal|0
decl_stmt|;
name|int
name|cilen
decl_stmt|;
name|BZERO
argument_list|(
operator|&
name|no
argument_list|,
sizeof|sizeof
argument_list|(
name|no
argument_list|)
argument_list|)
expr_stmt|;
name|try
operator|=
operator|*
name|go
expr_stmt|;
comment|/*      * Any Nak'd CIs must be in exactly the same order that we sent.      * Check packet length and CI length at each step.      * If we find any deviations, then this packet is bad.      */
define|#
directive|define
name|NAKCIVOID
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|code
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_VOID&& \ 	p[1] == CILEN_VOID&& \ 	p[0] == opt) { \ 	len -= CILEN_VOID; \ 	INCPTR(CILEN_VOID, p); \ 	no.neg = 1; \ 	code \     }
define|#
directive|define
name|NAKCICHAP
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|code
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_CHAP&& \ 	p[1] == CILEN_CHAP&& \ 	p[0] == opt) { \ 	len -= CILEN_CHAP; \ 	INCPTR(2, p); \ 	GETSHORT(cishort, p); \ 	GETCHAR(cichar, p); \ 	no.neg = 1; \ 	code \     }
define|#
directive|define
name|NAKCICHAR
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|code
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_CHAR&& \ 	p[1] == CILEN_CHAR&& \ 	p[0] == opt) { \ 	len -= CILEN_CHAR; \ 	INCPTR(2, p); \ 	GETCHAR(cichar, p); \ 	no.neg = 1; \ 	code \     }
define|#
directive|define
name|NAKCISHORT
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|code
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_SHORT&& \ 	p[1] == CILEN_SHORT&& \ 	p[0] == opt) { \ 	len -= CILEN_SHORT; \ 	INCPTR(2, p); \ 	GETSHORT(cishort, p); \ 	no.neg = 1; \ 	code \     }
define|#
directive|define
name|NAKCILONG
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|code
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_LONG&& \ 	p[1] == CILEN_LONG&& \ 	p[0] == opt) { \ 	len -= CILEN_LONG; \ 	INCPTR(2, p); \ 	GETLONG(cilong, p); \ 	no.neg = 1; \ 	code \     }
define|#
directive|define
name|NAKCILQR
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|code
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_LQR&& \ 	p[1] == CILEN_LQR&& \ 	p[0] == opt) { \ 	len -= CILEN_LQR; \ 	INCPTR(2, p); \ 	GETSHORT(cishort, p); \ 	GETLONG(cilong, p); \ 	no.neg = 1; \ 	code \     }
comment|/*      * We don't care if they want to send us smaller packets than      * we want.  Therefore, accept any MRU less than what we asked for,      * but then ignore the new value when setting the MRU in the kernel.      * If they send us a bigger MRU than what we asked, accept it, up to      * the limit of the default MRU we'd get if we didn't negotiate.      */
if|if
condition|(
name|go
operator|->
name|neg_mru
operator|&&
name|go
operator|->
name|mru
operator|!=
name|DEFMRU
condition|)
block|{
name|NAKCISHORT
argument_list|(
argument|CI_MRU
argument_list|,
argument|neg_mru
argument_list|,
argument|if (cishort<= wo->mru || cishort<= DEFMRU) 		       try.mru = cishort;
argument_list|)
empty_stmt|;
block|}
comment|/*      * Add any characters they want to our (receive-side) asyncmap.      */
if|if
condition|(
name|go
operator|->
name|neg_asyncmap
operator|&&
name|go
operator|->
name|asyncmap
operator|!=
literal|0xFFFFFFFF
condition|)
block|{
name|NAKCILONG
argument_list|(
argument|CI_ASYNCMAP
argument_list|,
argument|neg_asyncmap
argument_list|,
argument|try.asyncmap = go->asyncmap | cilong;
argument_list|)
empty_stmt|;
block|}
comment|/*      * If they've nak'd our authentication-protocol, check whether      * they are proposing a different protocol, or a different      * hash algorithm for CHAP.      */
if|if
condition|(
operator|(
name|go
operator|->
name|neg_chap
operator|||
name|go
operator|->
name|neg_upap
operator|)
operator|&&
name|len
operator|>=
name|CILEN_SHORT
operator|&&
name|p
index|[
literal|0
index|]
operator|==
name|CI_AUTHTYPE
operator|&&
name|p
index|[
literal|1
index|]
operator|>=
name|CILEN_SHORT
operator|&&
name|p
index|[
literal|1
index|]
operator|<=
name|len
condition|)
block|{
name|cilen
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|len
operator|-=
name|cilen
expr_stmt|;
name|no
operator|.
name|neg_chap
operator|=
name|go
operator|->
name|neg_chap
expr_stmt|;
name|no
operator|.
name|neg_upap
operator|=
name|go
operator|->
name|neg_upap
expr_stmt|;
name|INCPTR
argument_list|(
literal|2
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cishort
operator|==
name|PPP_PAP
operator|&&
name|cilen
operator|==
name|CILEN_SHORT
condition|)
block|{
comment|/* 	     * If we were asking for CHAP, they obviously don't want to do it. 	     * If we weren't asking for CHAP, then we were asking for PAP, 	     * in which case this Nak is bad. 	     */
if|if
condition|(
operator|!
name|go
operator|->
name|neg_chap
condition|)
goto|goto
name|bad
goto|;
name|try
operator|.
name|neg_chap
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cishort
operator|==
name|PPP_CHAP
operator|&&
name|cilen
operator|==
name|CILEN_CHAP
condition|)
block|{
name|GETCHAR
argument_list|(
name|cichar
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|go
operator|->
name|neg_chap
condition|)
block|{
comment|/* 		 * We were asking for CHAP/MD5; they must want a different 		 * algorithm.  If they can't do MD5, we'll have to stop 		 * asking for CHAP. 		 */
if|if
condition|(
name|cichar
operator|!=
name|go
operator|->
name|chap_mdtype
condition|)
name|try
operator|.
name|neg_chap
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Stop asking for PAP if we were asking for it. 		 */
name|try
operator|.
name|neg_upap
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 	     * We don't recognize what they're suggesting. 	     * Stop asking for what we were asking for. 	     */
if|if
condition|(
name|go
operator|->
name|neg_chap
condition|)
name|try
operator|.
name|neg_chap
operator|=
literal|0
expr_stmt|;
else|else
name|try
operator|.
name|neg_upap
operator|=
literal|0
expr_stmt|;
name|p
operator|+=
name|cilen
operator|-
name|CILEN_SHORT
expr_stmt|;
block|}
block|}
comment|/*      * If they can't cope with our link quality protocol, we'll have      * to stop asking for LQR.  We haven't got any other protocol.      * If they Nak the reporting period, take their value XXX ?      */
name|NAKCILQR
argument_list|(
argument|CI_QUALITY
argument_list|,
argument|neg_lqr
argument_list|,
argument|if (cishort != PPP_LQR) 		 try.neg_lqr =
literal|0
argument|; 	     else 		 try.lqr_period = cilong;
argument_list|)
empty_stmt|;
comment|/*      * Only implementing CBCP...not the rest of the callback options      */
name|NAKCICHAR
argument_list|(
argument|CI_CALLBACK
argument_list|,
argument|neg_cbcp
argument_list|,
argument|try.neg_cbcp =
literal|0
argument|;
argument_list|)
empty_stmt|;
comment|/*      * Check for a looped-back line.      */
name|NAKCILONG
argument_list|(
argument|CI_MAGICNUMBER
argument_list|,
argument|neg_magicnumber
argument_list|,
argument|try.magicnumber = magic(); 	      looped_back =
literal|1
argument|;
argument_list|)
empty_stmt|;
comment|/*      * Peer shouldn't send Nak for protocol compression or      * address/control compression requests; they should send      * a Reject instead.  If they send a Nak, treat it as a Reject.      */
name|NAKCIVOID
argument_list|(
argument|CI_PCOMPRESSION
argument_list|,
argument|neg_pcompression
argument_list|,
argument|try.neg_pcompression =
literal|0
argument|;
argument_list|)
empty_stmt|;
name|NAKCIVOID
argument_list|(
argument|CI_ACCOMPRESSION
argument_list|,
argument|neg_accompression
argument_list|,
argument|try.neg_accompression =
literal|0
argument|;
argument_list|)
empty_stmt|;
comment|/*      * There may be remaining CIs, if the peer is requesting negotiation      * on an option that we didn't include in our request packet.      * If we see an option that we requested, or one we've already seen      * in this packet, then this packet is bad.      * If we wanted to respond by starting to negotiate on the requested      * option(s), we could, but we don't, because except for the      * authentication type and quality protocol, if we are not negotiating      * an option, it is because we were told not to.      * For the authentication type, the Nak from the peer means      * `let me authenticate myself with you' which is a bit pointless.      * For the quality protocol, the Nak means `ask me to send you quality      * reports', but if we didn't ask for them, we don't want them.      * An option we don't recognize represents the peer asking to      * negotiate some option we don't support, so ignore it.      */
while|while
condition|(
name|len
operator|>
name|CILEN_VOID
condition|)
block|{
name|GETCHAR
argument_list|(
name|citype
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|cilen
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cilen
operator|<
name|CILEN_VOID
operator|||
operator|(
name|len
operator|-=
name|cilen
operator|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
name|next
operator|=
name|p
operator|+
name|cilen
operator|-
literal|2
expr_stmt|;
switch|switch
condition|(
name|citype
condition|)
block|{
case|case
name|CI_MRU
case|:
if|if
condition|(
operator|(
name|go
operator|->
name|neg_mru
operator|&&
name|go
operator|->
name|mru
operator|!=
name|DEFMRU
operator|)
operator|||
name|no
operator|.
name|neg_mru
operator|||
name|cilen
operator|!=
name|CILEN_SHORT
condition|)
goto|goto
name|bad
goto|;
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cishort
operator|<
name|DEFMRU
condition|)
name|try
operator|.
name|mru
operator|=
name|cishort
expr_stmt|;
break|break;
case|case
name|CI_ASYNCMAP
case|:
if|if
condition|(
operator|(
name|go
operator|->
name|neg_asyncmap
operator|&&
name|go
operator|->
name|asyncmap
operator|!=
literal|0xFFFFFFFF
operator|)
operator|||
name|no
operator|.
name|neg_asyncmap
operator|||
name|cilen
operator|!=
name|CILEN_LONG
condition|)
goto|goto
name|bad
goto|;
break|break;
case|case
name|CI_AUTHTYPE
case|:
if|if
condition|(
name|go
operator|->
name|neg_chap
operator|||
name|no
operator|.
name|neg_chap
operator|||
name|go
operator|->
name|neg_upap
operator|||
name|no
operator|.
name|neg_upap
condition|)
goto|goto
name|bad
goto|;
break|break;
case|case
name|CI_MAGICNUMBER
case|:
if|if
condition|(
name|go
operator|->
name|neg_magicnumber
operator|||
name|no
operator|.
name|neg_magicnumber
operator|||
name|cilen
operator|!=
name|CILEN_LONG
condition|)
goto|goto
name|bad
goto|;
break|break;
case|case
name|CI_PCOMPRESSION
case|:
if|if
condition|(
name|go
operator|->
name|neg_pcompression
operator|||
name|no
operator|.
name|neg_pcompression
operator|||
name|cilen
operator|!=
name|CILEN_VOID
condition|)
goto|goto
name|bad
goto|;
break|break;
case|case
name|CI_ACCOMPRESSION
case|:
if|if
condition|(
name|go
operator|->
name|neg_accompression
operator|||
name|no
operator|.
name|neg_accompression
operator|||
name|cilen
operator|!=
name|CILEN_VOID
condition|)
goto|goto
name|bad
goto|;
break|break;
case|case
name|CI_QUALITY
case|:
if|if
condition|(
name|go
operator|->
name|neg_lqr
operator|||
name|no
operator|.
name|neg_lqr
operator|||
name|cilen
operator|!=
name|CILEN_LQR
condition|)
goto|goto
name|bad
goto|;
break|break;
block|}
name|p
operator|=
name|next
expr_stmt|;
block|}
comment|/* If there is still anything left, this packet is bad. */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/*      * OK, the Nak is good.  Now we can update state.      */
if|if
condition|(
name|f
operator|->
name|state
operator|!=
name|OPENED
condition|)
block|{
if|if
condition|(
name|looped_back
condition|)
block|{
if|if
condition|(
operator|++
name|try
operator|.
name|numloops
operator|>=
name|lcp_loopbackfail
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Serial line is looped back."
argument_list|)
expr_stmt|;
name|lcp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|,
literal|"Loopback detected"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|try
operator|.
name|numloops
operator|=
literal|0
expr_stmt|;
operator|*
name|go
operator|=
name|try
expr_stmt|;
block|}
return|return
literal|1
return|;
name|bad
label|:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_WARNING
operator|,
literal|"lcp_nakci: received bad Nak!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * lcp_rejci - Peer has Rejected some of our CIs.  * This should not modify any state if the Reject is bad  * or if LCP is in the OPENED state.  *  * Returns:  *	0 - Reject was bad.  *	1 - Reject was good.  */
end_comment

begin_function
specifier|static
name|int
name|lcp_rejci
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
name|cichar
decl_stmt|;
name|u_short
name|cishort
decl_stmt|;
name|u_int32_t
name|cilong
decl_stmt|;
name|lcp_options
name|try
decl_stmt|;
comment|/* options to request next time */
name|try
operator|=
operator|*
name|go
expr_stmt|;
comment|/*      * Any Rejected CIs must be in exactly the same order that we sent.      * Check packet length and CI length at each step.      * If we find any deviations, then this packet is bad.      */
define|#
directive|define
name|REJCIVOID
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_VOID&& \ 	p[1] == CILEN_VOID&& \ 	p[0] == opt) { \ 	len -= CILEN_VOID; \ 	INCPTR(CILEN_VOID, p); \ 	try.neg = 0; \ 	LCPDEBUG((LOG_INFO, "lcp_rejci rejected void opt %d", opt)); \     }
define|#
directive|define
name|REJCISHORT
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_SHORT&& \ 	p[1] == CILEN_SHORT&& \ 	p[0] == opt) { \ 	len -= CILEN_SHORT; \ 	INCPTR(2, p); \ 	GETSHORT(cishort, p); \
comment|/* Check rejected value. */
value|\ 	if (cishort != val) \ 	    goto bad; \ 	try.neg = 0; \ 	LCPDEBUG((LOG_INFO,"lcp_rejci rejected short opt %d", opt)); \     }
define|#
directive|define
name|REJCICHAP
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|,
name|digest
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_CHAP&& \ 	p[1] == CILEN_CHAP&& \ 	p[0] == opt) { \ 	len -= CILEN_CHAP; \ 	INCPTR(2, p); \ 	GETSHORT(cishort, p); \ 	GETCHAR(cichar, p); \
comment|/* Check rejected value. */
value|\ 	if (cishort != val || cichar != digest) \ 	    goto bad; \ 	try.neg = 0; \ 	try.neg_upap = 0; \ 	LCPDEBUG((LOG_INFO,"lcp_rejci rejected chap opt %d", opt)); \     }
define|#
directive|define
name|REJCILONG
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_LONG&& \ 	p[1] == CILEN_LONG&& \ 	p[0] == opt) { \ 	len -= CILEN_LONG; \ 	INCPTR(2, p); \ 	GETLONG(cilong, p); \
comment|/* Check rejected value. */
value|\ 	if (cilong != val) \ 	    goto bad; \ 	try.neg = 0; \ 	LCPDEBUG((LOG_INFO,"lcp_rejci rejected long opt %d", opt)); \     }
define|#
directive|define
name|REJCILQR
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_LQR&& \ 	p[1] == CILEN_LQR&& \ 	p[0] == opt) { \ 	len -= CILEN_LQR; \ 	INCPTR(2, p); \ 	GETSHORT(cishort, p); \ 	GETLONG(cilong, p); \
comment|/* Check rejected value. */
value|\ 	if (cishort != PPP_LQR || cilong != val) \ 	    goto bad; \ 	try.neg = 0; \ 	LCPDEBUG((LOG_INFO,"lcp_rejci rejected LQR opt %d", opt)); \     }
define|#
directive|define
name|REJCICBCP
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= CILEN_CBCP&& \ 	p[1] == CILEN_CBCP&& \ 	p[0] == opt) { \ 	len -= CILEN_CBCP; \ 	INCPTR(2, p); \ 	GETCHAR(cichar, p); \
comment|/* Check rejected value. */
value|\ 	if (cichar != val) \ 	    goto bad; \ 	try.neg = 0; \ 	LCPDEBUG((LOG_INFO,"lcp_rejci rejected Callback opt %d", opt)); \     }
name|REJCISHORT
argument_list|(
name|CI_MRU
argument_list|,
name|neg_mru
argument_list|,
name|go
operator|->
name|mru
argument_list|)
expr_stmt|;
name|REJCILONG
argument_list|(
name|CI_ASYNCMAP
argument_list|,
name|neg_asyncmap
argument_list|,
name|go
operator|->
name|asyncmap
argument_list|)
expr_stmt|;
name|REJCICHAP
argument_list|(
name|CI_AUTHTYPE
argument_list|,
name|neg_chap
argument_list|,
name|PPP_CHAP
argument_list|,
name|go
operator|->
name|chap_mdtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|go
operator|->
name|neg_chap
condition|)
block|{
name|REJCISHORT
argument_list|(
name|CI_AUTHTYPE
argument_list|,
name|neg_upap
argument_list|,
name|PPP_PAP
argument_list|)
expr_stmt|;
block|}
name|REJCILQR
argument_list|(
name|CI_QUALITY
argument_list|,
name|neg_lqr
argument_list|,
name|go
operator|->
name|lqr_period
argument_list|)
expr_stmt|;
name|REJCICBCP
argument_list|(
name|CI_CALLBACK
argument_list|,
name|neg_cbcp
argument_list|,
name|CBCP_OPT
argument_list|)
expr_stmt|;
name|REJCILONG
argument_list|(
name|CI_MAGICNUMBER
argument_list|,
name|neg_magicnumber
argument_list|,
name|go
operator|->
name|magicnumber
argument_list|)
expr_stmt|;
name|REJCIVOID
argument_list|(
name|CI_PCOMPRESSION
argument_list|,
name|neg_pcompression
argument_list|)
expr_stmt|;
name|REJCIVOID
argument_list|(
name|CI_ACCOMPRESSION
argument_list|,
name|neg_accompression
argument_list|)
expr_stmt|;
comment|/*      * If there are any remaining CIs, then this packet is bad.      */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/*      * Now we can update state.      */
if|if
condition|(
name|f
operator|->
name|state
operator|!=
name|OPENED
condition|)
operator|*
name|go
operator|=
name|try
expr_stmt|;
return|return
literal|1
return|;
name|bad
label|:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_WARNING
operator|,
literal|"lcp_rejci: received bad Reject!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * lcp_reqci - Check the peer's requested CIs and send appropriate response.  *  * Returns: CONFACK, CONFNAK or CONFREJ and input packet modified  * appropriately.  If reject_if_disagree is non-zero, doesn't return  * CONFNAK; returns CONFREJ if it can't return CONFACK.  */
end_comment

begin_function
specifier|static
name|int
name|lcp_reqci
parameter_list|(
name|f
parameter_list|,
name|inp
parameter_list|,
name|lenp
parameter_list|,
name|reject_if_disagree
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
comment|/* Requested CIs */
name|int
modifier|*
name|lenp
decl_stmt|;
comment|/* Length of requested CIs */
name|int
name|reject_if_disagree
decl_stmt|;
block|{
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|ho
init|=
operator|&
name|lcp_hisoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|ao
init|=
operator|&
name|lcp_allowoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
modifier|*
name|cip
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* Pointer to current and next CIs */
name|int
name|cilen
decl_stmt|,
name|citype
decl_stmt|,
name|cichar
decl_stmt|;
comment|/* Parsed len, type, char value */
name|u_short
name|cishort
decl_stmt|;
comment|/* Parsed short value */
name|u_int32_t
name|cilong
decl_stmt|;
comment|/* Parse long value */
name|int
name|rc
init|=
name|CONFACK
decl_stmt|;
comment|/* Final packet return code */
name|int
name|orc
decl_stmt|;
comment|/* Individual option return code */
name|u_char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to next char to parse */
name|u_char
modifier|*
name|rejp
decl_stmt|;
comment|/* Pointer to next char in reject frame */
name|u_char
modifier|*
name|nakp
decl_stmt|;
comment|/* Pointer to next char in Nak frame */
name|int
name|l
init|=
operator|*
name|lenp
decl_stmt|;
comment|/* Length left */
comment|/*      * Reset all his options.      */
name|BZERO
argument_list|(
name|ho
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ho
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Process all his options.      */
name|next
operator|=
name|inp
expr_stmt|;
name|nakp
operator|=
name|nak_buffer
expr_stmt|;
name|rejp
operator|=
name|inp
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
name|orc
operator|=
name|CONFACK
expr_stmt|;
comment|/* Assume success */
name|cip
operator|=
name|p
operator|=
name|next
expr_stmt|;
comment|/* Remember begining of CI */
if|if
condition|(
name|l
operator|<
literal|2
operator|||
comment|/* Not enough data for CI header or */
name|p
index|[
literal|1
index|]
operator|<
literal|2
operator|||
comment|/*  CI length too small or */
name|p
index|[
literal|1
index|]
operator|>
name|l
condition|)
block|{
comment|/*  CI length too big? */
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_WARNING
operator|,
literal|"lcp_reqci: bad CI length!"
operator|)
argument_list|)
expr_stmt|;
name|orc
operator|=
name|CONFREJ
expr_stmt|;
comment|/* Reject bad CI */
name|cilen
operator|=
name|l
expr_stmt|;
comment|/* Reject till end of packet */
name|l
operator|=
literal|0
expr_stmt|;
comment|/* Don't loop again */
name|citype
operator|=
literal|0
expr_stmt|;
goto|goto
name|endswitch
goto|;
block|}
name|GETCHAR
argument_list|(
name|citype
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Parse CI type */
name|GETCHAR
argument_list|(
name|cilen
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Parse CI length */
name|l
operator|-=
name|cilen
expr_stmt|;
comment|/* Adjust remaining length */
name|next
operator|+=
name|cilen
expr_stmt|;
comment|/* Step to next CI */
switch|switch
condition|(
name|citype
condition|)
block|{
comment|/* Check CI type */
case|case
name|CI_MRU
case|:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_reqci: rcvd MRU"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_mru
operator|||
comment|/* Allow option? */
name|cilen
operator|!=
name|CILEN_SHORT
condition|)
block|{
comment|/* Check CI length */
name|orc
operator|=
name|CONFREJ
expr_stmt|;
comment|/* Reject CI */
break|break;
block|}
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Parse MRU */
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"(%d)"
operator|,
name|cishort
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * He must be able to receive at least our minimum. 	     * No need to check a maximum.  If he sends a large number, 	     * we'll just ignore it. 	     */
if|if
condition|(
name|cishort
operator|<
name|MINMRU
condition|)
block|{
name|orc
operator|=
name|CONFNAK
expr_stmt|;
comment|/* Nak CI */
name|PUTCHAR
argument_list|(
name|CI_MRU
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CILEN_SHORT
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|MINMRU
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
comment|/* Give him a hint */
break|break;
block|}
name|ho
operator|->
name|neg_mru
operator|=
literal|1
expr_stmt|;
comment|/* Remember he sent MRU */
name|ho
operator|->
name|mru
operator|=
name|cishort
expr_stmt|;
comment|/* And remember value */
break|break;
case|case
name|CI_ASYNCMAP
case|:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_reqci: rcvd ASYNCMAP"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_asyncmap
operator|||
name|cilen
operator|!=
name|CILEN_LONG
condition|)
block|{
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|GETLONG
argument_list|(
name|cilong
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"(%x)"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|cilong
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * Asyncmap must have set at least the bits 	     * which are set in lcp_allowoptions[unit].asyncmap. 	     */
if|if
condition|(
operator|(
name|ao
operator|->
name|asyncmap
operator|&
operator|~
name|cilong
operator|)
operator|!=
literal|0
condition|)
block|{
name|orc
operator|=
name|CONFNAK
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CI_ASYNCMAP
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CILEN_LONG
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|ao
operator|->
name|asyncmap
operator||
name|cilong
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
break|break;
block|}
name|ho
operator|->
name|neg_asyncmap
operator|=
literal|1
expr_stmt|;
name|ho
operator|->
name|asyncmap
operator|=
name|cilong
expr_stmt|;
break|break;
case|case
name|CI_AUTHTYPE
case|:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_reqci: rcvd AUTHTYPE"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cilen
operator|<
name|CILEN_SHORT
operator|||
operator|!
operator|(
name|ao
operator|->
name|neg_upap
operator|||
name|ao
operator|->
name|neg_chap
operator|)
condition|)
block|{
comment|/* 		 * Reject the option if we're not willing to authenticate. 		 */
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"(%x)"
operator|,
name|cishort
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * Authtype must be UPAP or CHAP. 	     * 	     * Note: if both ao->neg_upap and ao->neg_chap are set, 	     * and the peer sends a Configure-Request with two 	     * authenticate-protocol requests, one for CHAP and one 	     * for UPAP, then we will reject the second request. 	     * Whether we end up doing CHAP or UPAP depends then on 	     * the ordering of the CIs in the peer's Configure-Request. 	     */
if|if
condition|(
name|cishort
operator|==
name|PPP_PAP
condition|)
block|{
if|if
condition|(
name|ho
operator|->
name|neg_chap
operator|||
comment|/* we've already accepted CHAP */
name|cilen
operator|!=
name|CILEN_SHORT
condition|)
block|{
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_WARNING
operator|,
literal|"lcp_reqci: rcvd AUTHTYPE PAP, rejecting..."
operator|)
argument_list|)
expr_stmt|;
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_upap
condition|)
block|{
comment|/* we don't want to do PAP */
name|orc
operator|=
name|CONFNAK
expr_stmt|;
comment|/* NAK it and suggest CHAP */
name|PUTCHAR
argument_list|(
name|CI_AUTHTYPE
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CILEN_CHAP
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|PPP_CHAP
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|ao
operator|->
name|chap_mdtype
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
break|break;
block|}
name|ho
operator|->
name|neg_upap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cishort
operator|==
name|PPP_CHAP
condition|)
block|{
if|if
condition|(
name|ho
operator|->
name|neg_upap
operator|||
comment|/* we've already accepted PAP */
name|cilen
operator|!=
name|CILEN_CHAP
condition|)
block|{
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_reqci: rcvd AUTHTYPE CHAP, rejecting..."
operator|)
argument_list|)
expr_stmt|;
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_chap
condition|)
block|{
comment|/* we don't want to do CHAP */
name|orc
operator|=
name|CONFNAK
expr_stmt|;
comment|/* NAK it and suggest PAP */
name|PUTCHAR
argument_list|(
name|CI_AUTHTYPE
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CILEN_SHORT
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|PPP_PAP
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
break|break;
block|}
name|GETCHAR
argument_list|(
name|cichar
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* get digest type*/
if|if
condition|(
name|cichar
operator|!=
name|CHAP_DIGEST_MD5
ifdef|#
directive|ifdef
name|CHAPMS
operator|&&
name|cichar
operator|!=
name|CHAP_MICROSOFT
endif|#
directive|endif
condition|)
block|{
name|orc
operator|=
name|CONFNAK
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CI_AUTHTYPE
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CILEN_CHAP
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|PPP_CHAP
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|ao
operator|->
name|chap_mdtype
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
break|break;
block|}
name|ho
operator|->
name|chap_mdtype
operator|=
name|cichar
expr_stmt|;
comment|/* save md type */
name|ho
operator|->
name|neg_chap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 	     * We don't recognize the protocol they're asking for. 	     * Nak it with something we're willing to do. 	     * (At this point we know ao->neg_upap || ao->neg_chap.) 	     */
name|orc
operator|=
name|CONFNAK
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CI_AUTHTYPE
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ao
operator|->
name|neg_chap
condition|)
block|{
name|PUTCHAR
argument_list|(
name|CILEN_CHAP
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|PPP_CHAP
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|ao
operator|->
name|chap_mdtype
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PUTCHAR
argument_list|(
name|CILEN_SHORT
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|PPP_PAP
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CI_QUALITY
case|:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_reqci: rcvd QUALITY"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_lqr
operator|||
name|cilen
operator|!=
name|CILEN_LQR
condition|)
block|{
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|cilong
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"(%x %x)"
operator|,
name|cishort
operator|,
operator|(
name|unsigned
name|int
operator|)
name|cilong
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * Check the protocol and the reporting period. 	     * XXX When should we Nak this, and what with? 	     */
if|if
condition|(
name|cishort
operator|!=
name|PPP_LQR
condition|)
block|{
name|orc
operator|=
name|CONFNAK
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CI_QUALITY
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CILEN_LQR
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|PPP_LQR
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|ao
operator|->
name|lqr_period
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|CI_MAGICNUMBER
case|:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_reqci: rcvd MAGICNUMBER"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ao
operator|->
name|neg_magicnumber
operator|||
name|go
operator|->
name|neg_magicnumber
operator|)
operator|||
name|cilen
operator|!=
name|CILEN_LONG
condition|)
block|{
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|GETLONG
argument_list|(
name|cilong
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"(%x)"
operator|,
operator|(
name|unsigned
name|int
operator|)
name|cilong
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * He must have a different magic number. 	     */
if|if
condition|(
name|go
operator|->
name|neg_magicnumber
operator|&&
name|cilong
operator|==
name|go
operator|->
name|magicnumber
condition|)
block|{
name|cilong
operator|=
name|magic
argument_list|()
expr_stmt|;
comment|/* Don't put magic() inside macro! */
name|orc
operator|=
name|CONFNAK
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CI_MAGICNUMBER
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CILEN_LONG
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|cilong
argument_list|,
name|nakp
argument_list|)
expr_stmt|;
break|break;
block|}
name|ho
operator|->
name|neg_magicnumber
operator|=
literal|1
expr_stmt|;
name|ho
operator|->
name|magicnumber
operator|=
name|cilong
expr_stmt|;
break|break;
case|case
name|CI_PCOMPRESSION
case|:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_reqci: rcvd PCOMPRESSION"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_pcompression
operator|||
name|cilen
operator|!=
name|CILEN_VOID
condition|)
block|{
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|ho
operator|->
name|neg_pcompression
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CI_ACCOMPRESSION
case|:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_reqci: rcvd ACCOMPRESSION"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_accompression
operator|||
name|cilen
operator|!=
name|CILEN_VOID
condition|)
block|{
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|ho
operator|->
name|neg_accompression
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_reqci: rcvd unknown option %d"
operator|,
name|citype
operator|)
argument_list|)
expr_stmt|;
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|endswitch
label|:
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|" (%s)"
operator|,
name|CODENAME
argument_list|(
name|orc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|orc
operator|==
name|CONFACK
operator|&&
comment|/* Good CI */
name|rc
operator|!=
name|CONFACK
condition|)
comment|/*  but prior CI wasnt? */
continue|continue;
comment|/* Don't send this one */
if|if
condition|(
name|orc
operator|==
name|CONFNAK
condition|)
block|{
comment|/* Nak this CI? */
if|if
condition|(
name|reject_if_disagree
comment|/* Getting fed up with sending NAKs? */
operator|&&
name|citype
operator|!=
name|CI_MAGICNUMBER
condition|)
block|{
name|orc
operator|=
name|CONFREJ
expr_stmt|;
comment|/* Get tough if so */
block|}
else|else
block|{
if|if
condition|(
name|rc
operator|==
name|CONFREJ
condition|)
comment|/* Rejecting prior CI? */
continue|continue;
comment|/* Don't send this one */
name|rc
operator|=
name|CONFNAK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|orc
operator|==
name|CONFREJ
condition|)
block|{
comment|/* Reject this CI */
name|rc
operator|=
name|CONFREJ
expr_stmt|;
if|if
condition|(
name|cip
operator|!=
name|rejp
condition|)
comment|/* Need to move rejected CI? */
name|BCOPY
argument_list|(
name|cip
argument_list|,
name|rejp
argument_list|,
name|cilen
argument_list|)
expr_stmt|;
comment|/* Move it */
name|INCPTR
argument_list|(
name|cilen
argument_list|,
name|rejp
argument_list|)
expr_stmt|;
comment|/* Update output pointer */
block|}
block|}
comment|/*      * If we wanted to send additional NAKs (for unsent CIs), the      * code would go here.  The extra NAKs would go at *nakp.      * At present there are no cases where we want to ask the      * peer to negotiate an option.      */
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|CONFACK
case|:
operator|*
name|lenp
operator|=
name|next
operator|-
name|inp
expr_stmt|;
break|break;
case|case
name|CONFNAK
case|:
comment|/* 	 * Copy the Nak'd options from the nak_buffer to the caller's buffer. 	 */
operator|*
name|lenp
operator|=
name|nakp
operator|-
name|nak_buffer
expr_stmt|;
name|BCOPY
argument_list|(
name|nak_buffer
argument_list|,
name|inp
argument_list|,
operator|*
name|lenp
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONFREJ
case|:
operator|*
name|lenp
operator|=
name|rejp
operator|-
name|inp
expr_stmt|;
break|break;
block|}
name|LCPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"lcp_reqci: returning CONF%s."
operator|,
name|CODENAME
argument_list|(
name|rc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Return final code */
block|}
end_function

begin_comment
comment|/*  * lcp_up - LCP has come UP.  */
end_comment

begin_function
specifier|static
name|void
name|lcp_up
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|lcp_options
modifier|*
name|wo
init|=
operator|&
name|lcp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|ho
init|=
operator|&
name|lcp_hisoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|ao
init|=
operator|&
name|lcp_allowoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|go
operator|->
name|neg_magicnumber
condition|)
name|go
operator|->
name|magicnumber
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ho
operator|->
name|neg_magicnumber
condition|)
name|ho
operator|->
name|magicnumber
operator|=
literal|0
expr_stmt|;
comment|/*      * Set our MTU to the smaller of the MTU we wanted and      * the MRU our peer wanted.  If we negotiated an MRU,      * set our MRU to the larger of value we wanted and      * the value we got in the negotiation.      */
name|ppp_send_config
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|MIN
argument_list|(
name|ao
operator|->
name|mru
argument_list|,
operator|(
name|ho
operator|->
name|neg_mru
condition|?
name|ho
operator|->
name|mru
else|:
name|PPP_MRU
operator|)
argument_list|)
argument_list|,
operator|(
name|ho
operator|->
name|neg_asyncmap
condition|?
name|ho
operator|->
name|asyncmap
else|:
literal|0xffffffff
operator|)
argument_list|,
name|ho
operator|->
name|neg_pcompression
argument_list|,
name|ho
operator|->
name|neg_accompression
argument_list|)
expr_stmt|;
name|ppp_recv_config
argument_list|(
name|f
operator|->
name|unit
argument_list|,
operator|(
name|go
operator|->
name|neg_mru
condition|?
name|MAX
argument_list|(
name|wo
operator|->
name|mru
argument_list|,
name|go
operator|->
name|mru
argument_list|)
else|:
name|PPP_MRU
operator|)
argument_list|,
operator|(
name|go
operator|->
name|neg_asyncmap
condition|?
name|go
operator|->
name|asyncmap
else|:
literal|0xffffffff
operator|)
argument_list|,
name|go
operator|->
name|neg_pcompression
argument_list|,
name|go
operator|->
name|neg_accompression
argument_list|)
expr_stmt|;
if|if
condition|(
name|ho
operator|->
name|neg_mru
condition|)
name|peer_mru
index|[
name|f
operator|->
name|unit
index|]
operator|=
name|ho
operator|->
name|mru
expr_stmt|;
name|lcp_echo_lowerup
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* Enable echo messages */
name|link_established
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_down - LCP has gone DOWN.  *  * Alert other protocols.  */
end_comment

begin_function
specifier|static
name|void
name|lcp_down
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|lcp_echo_lowerdown
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
name|link_down
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ppp_send_config
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|PPP_MRU
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ppp_recv_config
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|PPP_MRU
argument_list|,
operator|(
name|go
operator|->
name|neg_asyncmap
condition|?
name|go
operator|->
name|asyncmap
else|:
literal|0xffffffff
operator|)
argument_list|,
name|go
operator|->
name|neg_pcompression
argument_list|,
name|go
operator|->
name|neg_accompression
argument_list|)
expr_stmt|;
name|peer_mru
index|[
name|f
operator|->
name|unit
index|]
operator|=
name|PPP_MRU
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_starting - LCP needs the lower layer up.  */
end_comment

begin_function
specifier|static
name|void
name|lcp_starting
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|link_required
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_finished - LCP has finished with the lower layer.  */
end_comment

begin_function
specifier|static
name|void
name|lcp_finished
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|link_terminated
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_printpkt - print the contents of an LCP packet.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lcp_codenames
index|[]
init|=
block|{
literal|"ConfReq"
block|,
literal|"ConfAck"
block|,
literal|"ConfNak"
block|,
literal|"ConfRej"
block|,
literal|"TermReq"
block|,
literal|"TermAck"
block|,
literal|"CodeRej"
block|,
literal|"ProtRej"
block|,
literal|"EchoReq"
block|,
literal|"EchoRep"
block|,
literal|"DiscReq"
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|lcp_printpkt
parameter_list|(
name|p
parameter_list|,
name|plen
parameter_list|,
name|printer
parameter_list|,
name|arg
parameter_list|)
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|plen
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*printer
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|code
decl_stmt|,
name|id
decl_stmt|,
name|len
decl_stmt|,
name|olen
decl_stmt|;
name|u_char
modifier|*
name|pstart
decl_stmt|,
modifier|*
name|optend
decl_stmt|;
name|u_short
name|cishort
decl_stmt|;
name|u_int32_t
name|cilong
decl_stmt|;
if|if
condition|(
name|plen
operator|<
name|HEADERLEN
condition|)
return|return
literal|0
return|;
name|pstart
operator|=
name|p
expr_stmt|;
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|id
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|len
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|HEADERLEN
operator|||
name|len
operator|>
name|plen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|>=
literal|1
operator|&&
name|code
operator|<=
sizeof|sizeof
argument_list|(
name|lcp_codenames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %s"
argument_list|,
name|lcp_codenames
index|[
name|code
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|printer
argument_list|(
name|arg
argument_list|,
literal|" code=0x%x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" id=0x%x"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|len
operator|-=
name|HEADERLEN
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONFREQ
case|:
case|case
name|CONFACK
case|:
case|case
name|CONFNAK
case|:
case|case
name|CONFREJ
case|:
comment|/* print option list */
while|while
condition|(
name|len
operator|>=
literal|2
condition|)
block|{
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|olen
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|olen
operator|<
literal|2
operator|||
name|olen
operator|>
name|len
condition|)
block|{
break|break;
block|}
name|printer
argument_list|(
name|arg
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|len
operator|-=
name|olen
expr_stmt|;
name|optend
operator|=
name|p
operator|+
name|olen
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CI_MRU
case|:
if|if
condition|(
name|olen
operator|==
name|CILEN_SHORT
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"mru %d"
argument_list|,
name|cishort
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CI_ASYNCMAP
case|:
if|if
condition|(
name|olen
operator|==
name|CILEN_LONG
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|GETLONG
argument_list|(
name|cilong
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"asyncmap 0x%x"
argument_list|,
name|cilong
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CI_AUTHTYPE
case|:
if|if
condition|(
name|olen
operator|>=
name|CILEN_SHORT
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"auth "
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cishort
condition|)
block|{
case|case
name|PPP_PAP
case|:
name|printer
argument_list|(
name|arg
argument_list|,
literal|"pap"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPP_CHAP
case|:
name|printer
argument_list|(
name|arg
argument_list|,
literal|"chap"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printer
argument_list|(
name|arg
argument_list|,
literal|"0x%x"
argument_list|,
name|cishort
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CI_QUALITY
case|:
if|if
condition|(
name|olen
operator|>=
name|CILEN_SHORT
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"quality "
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cishort
condition|)
block|{
case|case
name|PPP_LQR
case|:
name|printer
argument_list|(
name|arg
argument_list|,
literal|"lqr"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printer
argument_list|(
name|arg
argument_list|,
literal|"0x%x"
argument_list|,
name|cishort
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CI_CALLBACK
case|:
if|if
condition|(
name|olen
operator|>=
name|CILEN_CHAR
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"callback "
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cishort
condition|)
block|{
case|case
name|CBCP_OPT
case|:
name|printer
argument_list|(
name|arg
argument_list|,
literal|"CBCP"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printer
argument_list|(
name|arg
argument_list|,
literal|"0x%x"
argument_list|,
name|cishort
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CI_MAGICNUMBER
case|:
if|if
condition|(
name|olen
operator|==
name|CILEN_LONG
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|GETLONG
argument_list|(
name|cilong
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"magic 0x%x"
argument_list|,
name|cilong
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CI_PCOMPRESSION
case|:
if|if
condition|(
name|olen
operator|==
name|CILEN_VOID
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"pcomp"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CI_ACCOMPRESSION
case|:
if|if
condition|(
name|olen
operator|==
name|CILEN_VOID
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"accomp"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
while|while
condition|(
name|p
operator|<
name|optend
condition|)
block|{
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %.2x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
name|printer
argument_list|(
name|arg
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TERMACK
case|:
case|case
name|TERMREQ
case|:
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
operator|*
name|p
operator|>=
literal|' '
operator|&&
operator|*
name|p
operator|<
literal|0x7f
condition|)
block|{
name|printer
argument_list|(
name|arg
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|printer
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|ECHOREQ
case|:
case|case
name|ECHOREP
case|:
case|case
name|DISCREQ
case|:
if|if
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|GETLONG
argument_list|(
name|cilong
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" magic=0x%x"
argument_list|,
name|cilong
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
break|break;
block|}
comment|/* print the rest of the bytes in the packet */
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
block|{
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %.2x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
return|return
name|p
operator|-
name|pstart
return|;
block|}
end_block

begin_comment
comment|/*  * Time to shut down the link because there is nothing out there.  */
end_comment

begin_function
specifier|static
name|void
name|LcpLinkFailure
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
if|if
condition|(
name|f
operator|->
name|state
operator|==
name|OPENED
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"No response to %d echo-requests"
argument_list|,
name|lcp_echos_pending
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Serial link appears to be disconnected."
argument_list|)
expr_stmt|;
name|lcp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|,
literal|"Peer not responding"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Timer expired for the LCP echo requests from this process.  */
end_comment

begin_function
specifier|static
name|void
name|LcpEchoCheck
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|LcpSendEchoRequest
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/*      * Start the timer for the next interval.      */
name|assert
argument_list|(
name|lcp_echo_timer_running
operator|==
literal|0
argument_list|)
expr_stmt|;
name|TIMEOUT
argument_list|(
name|LcpEchoTimeout
argument_list|,
name|f
argument_list|,
name|lcp_echo_interval
argument_list|)
expr_stmt|;
name|lcp_echo_timer_running
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * LcpEchoTimeout - Timer expired on the LCP echo  */
end_comment

begin_function
specifier|static
name|void
name|LcpEchoTimeout
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|lcp_echo_timer_running
operator|!=
literal|0
condition|)
block|{
name|lcp_echo_timer_running
operator|=
literal|0
expr_stmt|;
name|LcpEchoCheck
argument_list|(
operator|(
name|fsm
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * LcpEchoReply - LCP has received a reply to the echo  */
end_comment

begin_function
specifier|static
name|void
name|lcp_received_echo_reply
parameter_list|(
name|f
parameter_list|,
name|id
parameter_list|,
name|inp
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|int
name|id
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|u_int32_t
name|magic
decl_stmt|;
comment|/* Check the magic number - don't count replies from ourselves. */
if|if
condition|(
name|len
operator|<
literal|4
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"lcp: received short Echo-Reply, length %d"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
name|GETLONG
argument_list|(
name|magic
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|neg_magicnumber
operator|&&
name|magic
operator|==
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|magicnumber
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"appear to have received our own echo-reply!"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Reset the number of outstanding echo frames */
name|lcp_echos_pending
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * LcpSendEchoRequest - Send an echo request frame to the peer  */
end_comment

begin_function
specifier|static
name|void
name|LcpSendEchoRequest
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|u_int32_t
name|lcp_magic
decl_stmt|;
name|u_char
name|pkt
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|pktp
decl_stmt|;
comment|/*      * Detect the failure of the peer at this point.      */
if|if
condition|(
name|lcp_echo_fails
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|lcp_echos_pending
operator|>=
name|lcp_echo_fails
condition|)
block|{
name|LcpLinkFailure
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|lcp_echos_pending
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*      * Make and send the echo request frame.      */
if|if
condition|(
name|f
operator|->
name|state
operator|==
name|OPENED
condition|)
block|{
name|lcp_magic
operator|=
name|lcp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|magicnumber
expr_stmt|;
name|pktp
operator|=
name|pkt
expr_stmt|;
name|PUTLONG
argument_list|(
name|lcp_magic
argument_list|,
name|pktp
argument_list|)
expr_stmt|;
name|fsm_sdata
argument_list|(
name|f
argument_list|,
name|ECHOREQ
argument_list|,
name|lcp_echo_number
operator|++
operator|&
literal|0xFF
argument_list|,
name|pkt
argument_list|,
name|pktp
operator|-
name|pkt
argument_list|)
expr_stmt|;
operator|++
name|lcp_echos_pending
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * lcp_echo_lowerup - Start the timer for the LCP frame  */
end_comment

begin_function
specifier|static
name|void
name|lcp_echo_lowerup
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm
modifier|*
name|f
init|=
operator|&
name|lcp_fsm
index|[
name|unit
index|]
decl_stmt|;
comment|/* Clear the parameters for generating echo frames */
name|lcp_echos_pending
operator|=
literal|0
expr_stmt|;
name|lcp_echo_number
operator|=
literal|0
expr_stmt|;
name|lcp_echo_timer_running
operator|=
literal|0
expr_stmt|;
comment|/* If a timeout interval is specified then start the timer */
if|if
condition|(
name|lcp_echo_interval
operator|!=
literal|0
condition|)
name|LcpEchoCheck
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * lcp_echo_lowerdown - Stop the timer for the LCP frame  */
end_comment

begin_function
specifier|static
name|void
name|lcp_echo_lowerdown
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm
modifier|*
name|f
init|=
operator|&
name|lcp_fsm
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|lcp_echo_timer_running
operator|!=
literal|0
condition|)
block|{
name|UNTIMEOUT
argument_list|(
name|LcpEchoTimeout
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|lcp_echo_timer_running
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

