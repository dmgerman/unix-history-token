begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*     ipv6cp.c - PPP IPV6 Control Protocol.     Copyright (C) 1999  Tommi Komulainen<Tommi.Komulainen@iki.fi>      Redistribution and use in source and binary forms are permitted     provided that the above copyright notice and this paragraph are     duplicated in all such forms.  The name of the author may not be     used to endorse or promote products derived from this software     without specific prior written permission.     THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR     IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED     WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE. */
end_comment

begin_comment
comment|/*  Original version, based on RFC2023 :      Copyright (c) 1995, 1996, 1997 Francis.Dupont@inria.fr, INRIA Rocquencourt,     Alain.Durand@imag.fr, IMAG,     Jean-Luc.Richier@imag.fr, IMAG-LSR.      Copyright (c) 1998, 1999 Francis.Dupont@inria.fr, GIE DYADE,     Alain.Durand@imag.fr, IMAG,     Jean-Luc.Richier@imag.fr, IMAG-LSR.      Ce travail a été fait au sein du GIE DYADE (Groupement d'Intérêt     Économique ayant pour membres BULL S.A. et l'INRIA).      Ce logiciel informatique est disponible aux conditions     usuelles dans la recherche, c'est-à-dire qu'il peut     être utilisé, copié, modifié, distribué à l'unique     condition que ce texte soit conservé afin que     l'origine de ce logiciel soit reconnue.      Le nom de l'Institut National de Recherche en Informatique     et en Automatique (INRIA), de l'IMAG, ou d'une personne morale     ou physique ayant participé à l'élaboration de ce logiciel ne peut     être utilisé sans son accord préalable explicite.      Ce logiciel est fourni tel quel sans aucune garantie,     support ou responsabilité d'aucune sorte.     Ce logiciel est dérivé de sources d'origine     "University of California at Berkeley" et     "Digital Equipment Corporation" couvertes par des copyrights.      L'Institut d'Informatique et de Mathématiques Appliquées de Grenoble (IMAG)     est une fédération d'unités mixtes de recherche du CNRS, de l'Institut National     Polytechnique de Grenoble et de l'Université Joseph Fourier regroupant     sept laboratoires dont le laboratoire Logiciels, Systèmes, Réseaux (LSR).      This work has been done in the context of GIE DYADE (joint R& D venture     between BULL S.A. and INRIA).      This software is available with usual "research" terms     with the aim of retain credits of the software.      Permission to use, copy, modify and distribute this software for any     purpose and without fee is hereby granted, provided that the above     copyright notice and this permission notice appear in all copies,     and the name of INRIA, IMAG, or any contributor not be used in advertising     or publicity pertaining to this material without the prior explicit     permission. The software is provided "as is" without any     warranties, support or liabilities of any kind.     This software is derived from source code from     "University of California at Berkeley" and     "Digital Equipment Corporation" protected by copyrights.      Grenoble's Institute of Computer Science and Applied Mathematics (IMAG)     is a federation of seven research units funded by the CNRS, National     Polytechnic Institute of Grenoble and University Joseph Fourier.     The research unit in Software, Systems, Networks (LSR) is member of IMAG. */
end_comment

begin_comment
comment|/*  * Derived from :  *  *  * ipcp.c - PPP IP Control Protocol.  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * $Id: ipv6cp.c,v 1.7 1999/10/08 01:08:18 masputra Exp $   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_define
define|#
directive|define
name|RCSID
value|"$Id: ipv6cp.c,v 1.7 1999/10/08 01:08:18 masputra Exp $"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * TODO:   *  * Proxy Neighbour Discovery.  *  * Better defines for selecting the ordering of  *   interface up / set address. (currently checks for __linux__,  *   since SVR4&& (SNI || __USLC__) didn't work properly)  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|"pppd.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"ipv6cp.h"
end_include

begin_include
include|#
directive|include
file|"magic.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|s6_addr32
value|__u6_addr.__u6_addr32
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|RCSID
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
name|RCSID
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* global vars */
end_comment

begin_decl_stmt
name|ipv6cp_options
name|ipv6cp_wantoptions
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options that we want to request */
end_comment

begin_decl_stmt
name|ipv6cp_options
name|ipv6cp_gotoptions
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options that peer ack'd */
end_comment

begin_decl_stmt
name|ipv6cp_options
name|ipv6cp_allowoptions
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options we allow peer to request */
end_comment

begin_decl_stmt
name|ipv6cp_options
name|ipv6cp_hisoptions
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Options that we ack'd */
end_comment

begin_decl_stmt
name|int
name|no_ifaceid_neg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local vars */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ipv6cp_is_up
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Callbacks for fsm code.  (CI = Configuration Information)  */
end_comment

begin_function_decl
specifier|static
name|void
name|ipv6cp_resetci
parameter_list|(
name|fsm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Reset our CI */
end_comment

begin_function_decl
specifier|static
name|int
name|ipv6cp_cilen
parameter_list|(
name|fsm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Return length of our CI */
end_comment

begin_function_decl
specifier|static
name|void
name|ipv6cp_addci
parameter_list|(
name|fsm
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Add our CI */
end_comment

begin_function_decl
specifier|static
name|int
name|ipv6cp_ackci
parameter_list|(
name|fsm
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Peer ack'd our CI */
end_comment

begin_function_decl
specifier|static
name|int
name|ipv6cp_nakci
parameter_list|(
name|fsm
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Peer nak'd our CI */
end_comment

begin_function_decl
specifier|static
name|int
name|ipv6cp_rejci
parameter_list|(
name|fsm
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Peer rej'd our CI */
end_comment

begin_function_decl
specifier|static
name|int
name|ipv6cp_reqci
parameter_list|(
name|fsm
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Rcv CI */
end_comment

begin_function_decl
specifier|static
name|void
name|ipv6cp_up
parameter_list|(
name|fsm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We're UP */
end_comment

begin_function_decl
specifier|static
name|void
name|ipv6cp_down
parameter_list|(
name|fsm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* We're DOWN */
end_comment

begin_function_decl
specifier|static
name|void
name|ipv6cp_finished
parameter_list|(
name|fsm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Don't need lower layer */
end_comment

begin_decl_stmt
name|fsm
name|ipv6cp_fsm
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IPV6CP fsm structure */
end_comment

begin_decl_stmt
specifier|static
name|fsm_callbacks
name|ipv6cp_callbacks
init|=
block|{
comment|/* IPV6CP callback routines */
name|ipv6cp_resetci
block|,
comment|/* Reset our Configuration Information */
name|ipv6cp_cilen
block|,
comment|/* Length of our Configuration Information */
name|ipv6cp_addci
block|,
comment|/* Add our Configuration Information */
name|ipv6cp_ackci
block|,
comment|/* ACK our Configuration Information */
name|ipv6cp_nakci
block|,
comment|/* NAK our Configuration Information */
name|ipv6cp_rejci
block|,
comment|/* Reject our Configuration Information */
name|ipv6cp_reqci
block|,
comment|/* Request peer's Configuration Information */
name|ipv6cp_up
block|,
comment|/* Called when fsm reaches OPENED state */
name|ipv6cp_down
block|,
comment|/* Called when fsm leaves OPENED state */
name|NULL
block|,
comment|/* Called when we want the lower layer up */
name|ipv6cp_finished
block|,
comment|/* Called when we want the lower layer down */
name|NULL
block|,
comment|/* Called when Protocol-Reject received */
name|NULL
block|,
comment|/* Retransmission is necessary */
name|NULL
block|,
comment|/* Called to handle protocol-specific codes */
literal|"IPV6CP"
comment|/* String name of protocol */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Protocol entry points from main code.  */
end_comment

begin_function_decl
specifier|static
name|void
name|ipv6cp_init
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_open
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_close
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_lowerup
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_lowerdown
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_input
parameter_list|(
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_protrej
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipv6cp_printpkt
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6_check_options
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipv6_demand_conf
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ipv6_active_pkt
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|protent
name|ipv6cp_protent
init|=
block|{
name|PPP_IPV6CP
block|,
name|ipv6cp_init
block|,
name|ipv6cp_input
block|,
name|ipv6cp_protrej
block|,
name|ipv6cp_lowerup
block|,
name|ipv6cp_lowerdown
block|,
name|ipv6cp_open
block|,
name|ipv6cp_close
block|,
name|ipv6cp_printpkt
block|,
name|NULL
block|,
literal|0
block|,
literal|"IPV6CP"
block|,
name|ipv6_check_options
block|,
name|ipv6_demand_conf
block|,
name|ipv6_active_pkt
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ipv6cp_clear_addrs
parameter_list|(
name|int
parameter_list|,
name|eui64_t
parameter_list|,
name|eui64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipv6cp_script
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Lengths of configuration options.  */
end_comment

begin_define
define|#
directive|define
name|CILEN_VOID
value|2
end_define

begin_define
define|#
directive|define
name|CILEN_COMPRESS
value|4
end_define

begin_comment
comment|/* length for RFC2023 compress opt. */
end_comment

begin_define
define|#
directive|define
name|CILEN_IFACEID
value|10
end_define

begin_comment
comment|/* RFC2472, interface identifier    */
end_comment

begin_define
define|#
directive|define
name|CODENAME
parameter_list|(
name|x
parameter_list|)
value|((x) == CONFACK ? "ACK" : \ 			 (x) == CONFNAK ? "NAK" : "REJ")
end_define

begin_comment
comment|/*  * This state variable is used to ensure that we don't  * run an ipcp-up/down script while one is already running.  */
end_comment

begin_enum
specifier|static
enum|enum
name|script_state
block|{
name|s_down
block|,
name|s_up
block|, }
name|ipv6cp_script_state
enum|;
end_enum

begin_comment
comment|/*  * setifaceid - set the interface identifiers manually  */
end_comment

begin_function
name|int
name|setifaceid
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|comma
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
name|ipv6cp_options
modifier|*
name|wo
init|=
operator|&
name|ipv6cp_wantoptions
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|in6_addr
name|addr
decl_stmt|;
define|#
directive|define
name|VALIDID
parameter_list|(
name|a
parameter_list|)
value|( (((a).s6_addr32[0] == 0)&& ((a).s6_addr32[1] == 0))&& \ 			(((a).s6_addr32[2] != 0) || ((a).s6_addr32[3] != 0)) )
name|arg
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|(
name|comma
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|comma
operator|=
name|arg
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/*       * If comma first character, then no local identifier      */
if|if
condition|(
name|comma
operator|!=
name|arg
condition|)
block|{
operator|*
name|comma
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|arg
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|VALIDID
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|option_error
argument_list|(
literal|"Illegal interface identifier (local): %s"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|eui64_copy
argument_list|(
name|addr
operator|.
name|s6_addr32
index|[
literal|2
index|]
argument_list|,
name|wo
operator|->
name|ourid
argument_list|)
expr_stmt|;
name|wo
operator|->
name|opt_local
operator|=
literal|1
expr_stmt|;
operator|*
name|comma
operator|=
literal|','
expr_stmt|;
block|}
comment|/*      * If comma last character, the no remote identifier      */
if|if
condition|(
operator|*
name|comma
operator|!=
literal|0
operator|&&
operator|*
operator|++
name|comma
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|comma
argument_list|,
operator|&
name|addr
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|VALIDID
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|option_error
argument_list|(
literal|"Illegal interface identifier (remote): %s"
argument_list|,
name|comma
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|eui64_copy
argument_list|(
name|addr
operator|.
name|s6_addr32
index|[
literal|2
index|]
argument_list|,
name|wo
operator|->
name|hisid
argument_list|)
expr_stmt|;
name|wo
operator|->
name|opt_remote
operator|=
literal|1
expr_stmt|;
block|}
name|ipv6cp_protent
operator|.
name|enabled_flag
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Make a string representation of a network address.  */
end_comment

begin_function
name|char
modifier|*
name|llv6_ntoa
parameter_list|(
name|ifaceid
parameter_list|)
name|eui64_t
name|ifaceid
decl_stmt|;
block|{
specifier|static
name|char
name|b
index|[
literal|64
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|b
argument_list|,
literal|"fe80::%s"
argument_list|,
name|eui64_ntoa
argument_list|(
name|ifaceid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_init - Initialize IPV6CP.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_init
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm
modifier|*
name|f
init|=
operator|&
name|ipv6cp_fsm
index|[
name|unit
index|]
decl_stmt|;
name|ipv6cp_options
modifier|*
name|wo
init|=
operator|&
name|ipv6cp_wantoptions
index|[
name|unit
index|]
decl_stmt|;
name|ipv6cp_options
modifier|*
name|ao
init|=
operator|&
name|ipv6cp_allowoptions
index|[
name|unit
index|]
decl_stmt|;
name|f
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|f
operator|->
name|protocol
operator|=
name|PPP_IPV6CP
expr_stmt|;
name|f
operator|->
name|callbacks
operator|=
operator|&
name|ipv6cp_callbacks
expr_stmt|;
name|fsm_init
argument_list|(
operator|&
name|ipv6cp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|wo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ao
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ao
argument_list|)
argument_list|)
expr_stmt|;
name|wo
operator|->
name|accept_local
operator|=
literal|1
expr_stmt|;
name|wo
operator|->
name|neg_ifaceid
operator|=
literal|1
expr_stmt|;
name|ao
operator|->
name|neg_ifaceid
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|IPV6CP_COMP
name|wo
operator|->
name|neg_vj
operator|=
literal|1
expr_stmt|;
name|ao
operator|->
name|neg_vj
operator|=
literal|1
expr_stmt|;
name|wo
operator|->
name|vj_protocol
operator|=
name|IPV6CP_COMP
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * ipv6cp_open - IPV6CP is allowed to come up.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_open
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm_open
argument_list|(
operator|&
name|ipv6cp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_close - Take IPV6CP down.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_close
parameter_list|(
name|unit
parameter_list|,
name|reason
parameter_list|)
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|reason
decl_stmt|;
block|{
name|fsm_close
argument_list|(
operator|&
name|ipv6cp_fsm
index|[
name|unit
index|]
argument_list|,
name|reason
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_lowerup - The lower layer is up.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_lowerup
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm_lowerup
argument_list|(
operator|&
name|ipv6cp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_lowerdown - The lower layer is down.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_lowerdown
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm_lowerdown
argument_list|(
operator|&
name|ipv6cp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_input - Input IPV6CP packet.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_input
parameter_list|(
name|unit
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|fsm_input
argument_list|(
operator|&
name|ipv6cp_fsm
index|[
name|unit
index|]
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_protrej - A Protocol-Reject was received for IPV6CP.  *  * Pretend the lower layer went down, so we shut up.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_protrej
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|fsm_lowerdown
argument_list|(
operator|&
name|ipv6cp_fsm
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_resetci - Reset our CI.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_resetci
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|ipv6cp_options
modifier|*
name|wo
init|=
operator|&
name|ipv6cp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipv6cp_options
modifier|*
name|go
init|=
operator|&
name|ipv6cp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|wo
operator|->
name|req_ifaceid
operator|=
name|wo
operator|->
name|neg_ifaceid
operator|&&
name|ipv6cp_allowoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|neg_ifaceid
expr_stmt|;
if|if
condition|(
operator|!
name|wo
operator|->
name|opt_local
condition|)
block|{
name|eui64_magic_nz
argument_list|(
name|wo
operator|->
name|ourid
argument_list|)
expr_stmt|;
block|}
operator|*
name|go
operator|=
operator|*
name|wo
expr_stmt|;
name|eui64_zero
argument_list|(
name|go
operator|->
name|hisid
argument_list|)
expr_stmt|;
comment|/* last proposed interface identifier */
block|}
end_function

begin_comment
comment|/*  * ipv6cp_cilen - Return length of our CI.  */
end_comment

begin_function
specifier|static
name|int
name|ipv6cp_cilen
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|ipv6cp_options
modifier|*
name|go
init|=
operator|&
name|ipv6cp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
define|#
directive|define
name|LENCIVJ
parameter_list|(
name|neg
parameter_list|)
value|(neg ? CILEN_COMPRESS : 0)
define|#
directive|define
name|LENCIIFACEID
parameter_list|(
name|neg
parameter_list|)
value|(neg ? CILEN_IFACEID : 0)
return|return
operator|(
name|LENCIIFACEID
argument_list|(
name|go
operator|->
name|neg_ifaceid
argument_list|)
operator|+
name|LENCIVJ
argument_list|(
name|go
operator|->
name|neg_vj
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_addci - Add our desired CIs to a packet.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_addci
parameter_list|(
name|f
parameter_list|,
name|ucp
parameter_list|,
name|lenp
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|ucp
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
block|{
name|ipv6cp_options
modifier|*
name|go
init|=
operator|&
name|ipv6cp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|int
name|len
init|=
operator|*
name|lenp
decl_stmt|;
define|#
directive|define
name|ADDCIVJ
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (neg) { \ 	int vjlen = CILEN_COMPRESS; \ 	if (len>= vjlen) { \ 	    PUTCHAR(opt, ucp); \ 	    PUTCHAR(vjlen, ucp); \ 	    PUTSHORT(val, ucp); \ 	    len -= vjlen; \ 	} else \ 	    neg = 0; \     }
define|#
directive|define
name|ADDCIIFACEID
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val1
parameter_list|)
define|\
value|if (neg) { \ 	int idlen = CILEN_IFACEID; \ 	if (len>= idlen) { \ 	    PUTCHAR(opt, ucp); \ 	    PUTCHAR(idlen, ucp); \ 	    eui64_put(val1, ucp); \ 	    len -= idlen; \ 	} else \ 	    neg = 0; \     }
name|ADDCIIFACEID
argument_list|(
name|CI_IFACEID
argument_list|,
name|go
operator|->
name|neg_ifaceid
argument_list|,
name|go
operator|->
name|ourid
argument_list|)
expr_stmt|;
name|ADDCIVJ
argument_list|(
name|CI_COMPRESSTYPE
argument_list|,
name|go
operator|->
name|neg_vj
argument_list|,
name|go
operator|->
name|vj_protocol
argument_list|)
expr_stmt|;
operator|*
name|lenp
operator|-=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_ackci - Ack our CIs.  *  * Returns:  *	0 - Ack was bad.  *	1 - Ack was good.  */
end_comment

begin_function
specifier|static
name|int
name|ipv6cp_ackci
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|ipv6cp_options
modifier|*
name|go
init|=
operator|&
name|ipv6cp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_short
name|cilen
decl_stmt|,
name|citype
decl_stmt|,
name|cishort
decl_stmt|;
name|eui64_t
name|ifaceid
decl_stmt|;
comment|/*      * CIs must be in exactly the same order that we sent...      * Check packet length and CI length at each step.      * If we find any deviations, then this packet is bad.      */
define|#
directive|define
name|ACKCIVJ
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (neg) { \ 	int vjlen = CILEN_COMPRESS; \ 	if ((len -= vjlen)< 0) \ 	    goto bad; \ 	GETCHAR(citype, p); \ 	GETCHAR(cilen, p); \ 	if (cilen != vjlen || \ 	    citype != opt)  \ 	    goto bad; \ 	GETSHORT(cishort, p); \ 	if (cishort != val) \ 	    goto bad; \     }
define|#
directive|define
name|ACKCIIFACEID
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val1
parameter_list|)
define|\
value|if (neg) { \ 	int idlen = CILEN_IFACEID; \ 	if ((len -= idlen)< 0) \ 	    goto bad; \ 	GETCHAR(citype, p); \ 	GETCHAR(cilen, p); \ 	if (cilen != idlen || \ 	    citype != opt) \ 	    goto bad; \ 	eui64_get(ifaceid, p); \ 	if (! eui64_equals(val1, ifaceid)) \ 	    goto bad; \     }
name|ACKCIIFACEID
argument_list|(
name|CI_IFACEID
argument_list|,
name|go
operator|->
name|neg_ifaceid
argument_list|,
name|go
operator|->
name|ourid
argument_list|)
expr_stmt|;
name|ACKCIVJ
argument_list|(
name|CI_COMPRESSTYPE
argument_list|,
name|go
operator|->
name|neg_vj
argument_list|,
name|go
operator|->
name|vj_protocol
argument_list|)
expr_stmt|;
comment|/*      * If there are any remaining CIs, then this packet is bad.      */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
return|return
operator|(
literal|1
operator|)
return|;
name|bad
label|:
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|"ipv6cp_ackci: received bad Ack!"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_nakci - Peer has sent a NAK for some of our CIs.  * This should not modify any state if the Nak is bad  * or if IPV6CP is in the OPENED state.  *  * Returns:  *	0 - Nak was bad.  *	1 - Nak was good.  */
end_comment

begin_function
specifier|static
name|int
name|ipv6cp_nakci
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|ipv6cp_options
modifier|*
name|go
init|=
operator|&
name|ipv6cp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
name|citype
decl_stmt|,
name|cilen
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|u_short
name|cishort
decl_stmt|;
name|eui64_t
name|ifaceid
decl_stmt|;
name|ipv6cp_options
name|no
decl_stmt|;
comment|/* options we've seen Naks for */
name|ipv6cp_options
name|try
decl_stmt|;
comment|/* options to request next time */
name|BZERO
argument_list|(
operator|&
name|no
argument_list|,
sizeof|sizeof
argument_list|(
name|no
argument_list|)
argument_list|)
expr_stmt|;
name|try
operator|=
operator|*
name|go
expr_stmt|;
comment|/*      * Any Nak'd CIs must be in exactly the same order that we sent.      * Check packet length and CI length at each step.      * If we find any deviations, then this packet is bad.      */
define|#
directive|define
name|NAKCIIFACEID
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|code
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= (cilen = CILEN_IFACEID)&& \ 	p[1] == cilen&& \ 	p[0] == opt) { \ 	len -= cilen; \ 	INCPTR(2, p); \ 	eui64_get(ifaceid, p); \ 	no.neg = 1; \ 	code \     }
define|#
directive|define
name|NAKCIVJ
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|code
parameter_list|)
define|\
value|if (go->neg&& \ 	((cilen = p[1]) == CILEN_COMPRESS)&& \ 	len>= cilen&& \ 	p[0] == opt) { \ 	len -= cilen; \ 	INCPTR(2, p); \ 	GETSHORT(cishort, p); \ 	no.neg = 1; \         code \     }
comment|/*      * Accept the peer's idea of {our,his} interface identifier, if different      * from our idea, only if the accept_{local,remote} flag is set.      */
name|NAKCIIFACEID
argument_list|(
argument|CI_IFACEID
argument_list|,
argument|neg_ifaceid
argument_list|,
argument|if (go->accept_local) { 		  while (eui64_iszero(ifaceid) ||  			 eui64_equals(ifaceid, go->hisid))
comment|/* bad luck */
argument|eui64_magic(ifaceid); 		  try.ourid = ifaceid; 		  IPV6CPDEBUG((
literal|"local LL address %s"
argument|, llv6_ntoa(ifaceid))); 	      }
argument_list|)
empty_stmt|;
ifdef|#
directive|ifdef
name|IPV6CP_COMP
name|NAKCIVJ
argument_list|(
argument|CI_COMPRESSTYPE
argument_list|,
argument|neg_vj
argument_list|,
argument|{ 		if (cishort == IPV6CP_COMP) { 		    try.vj_protocol = cishort; 		} else { 		    try.neg_vj =
literal|0
argument|; 		} 	    }
argument_list|)
empty_stmt|;
else|#
directive|else
name|NAKCIVJ
argument_list|(
argument|CI_COMPRESSTYPE
argument_list|,
argument|neg_vj
argument_list|,
argument|{ 		try.neg_vj =
literal|0
argument|; 	    }
argument_list|)
empty_stmt|;
endif|#
directive|endif
comment|/*      * There may be remaining CIs, if the peer is requesting negotiation      * on an option that we didn't include in our request packet.      * If they want to negotiate about interface identifier, we comply.      * If they want us to ask for compression, we refuse.      */
while|while
condition|(
name|len
operator|>
name|CILEN_VOID
condition|)
block|{
name|GETCHAR
argument_list|(
name|citype
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|cilen
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|-=
name|cilen
operator|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
name|next
operator|=
name|p
operator|+
name|cilen
operator|-
literal|2
expr_stmt|;
switch|switch
condition|(
name|citype
condition|)
block|{
case|case
name|CI_COMPRESSTYPE
case|:
if|if
condition|(
name|go
operator|->
name|neg_vj
operator|||
name|no
operator|.
name|neg_vj
operator|||
operator|(
name|cilen
operator|!=
name|CILEN_COMPRESS
operator|)
condition|)
goto|goto
name|bad
goto|;
name|no
operator|.
name|neg_vj
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CI_IFACEID
case|:
if|if
condition|(
name|go
operator|->
name|neg_ifaceid
operator|||
name|no
operator|.
name|neg_ifaceid
operator|||
name|cilen
operator|!=
name|CILEN_IFACEID
condition|)
goto|goto
name|bad
goto|;
name|try
operator|.
name|neg_ifaceid
operator|=
literal|1
expr_stmt|;
name|eui64_get
argument_list|(
name|ifaceid
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|go
operator|->
name|accept_local
condition|)
block|{
while|while
condition|(
name|eui64_iszero
argument_list|(
name|ifaceid
argument_list|)
operator|||
name|eui64_equals
argument_list|(
name|ifaceid
argument_list|,
name|go
operator|->
name|hisid
argument_list|)
condition|)
comment|/* bad luck */
name|eui64_magic
argument_list|(
name|ifaceid
argument_list|)
expr_stmt|;
name|try
operator|.
name|ourid
operator|=
name|ifaceid
expr_stmt|;
block|}
name|no
operator|.
name|neg_ifaceid
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|next
expr_stmt|;
block|}
comment|/* If there is still anything left, this packet is bad. */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/*      * OK, the Nak is good.  Now we can update state.      */
if|if
condition|(
name|f
operator|->
name|state
operator|!=
name|OPENED
condition|)
operator|*
name|go
operator|=
name|try
expr_stmt|;
return|return
literal|1
return|;
name|bad
label|:
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|"ipv6cp_nakci: received bad Nak!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_rejci - Reject some of our CIs.  */
end_comment

begin_function
specifier|static
name|int
name|ipv6cp_rejci
parameter_list|(
name|f
parameter_list|,
name|p
parameter_list|,
name|len
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|ipv6cp_options
modifier|*
name|go
init|=
operator|&
name|ipv6cp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
name|cilen
decl_stmt|;
name|u_short
name|cishort
decl_stmt|;
name|eui64_t
name|ifaceid
decl_stmt|;
name|ipv6cp_options
name|try
decl_stmt|;
comment|/* options to request next time */
name|try
operator|=
operator|*
name|go
expr_stmt|;
comment|/*      * Any Rejected CIs must be in exactly the same order that we sent.      * Check packet length and CI length at each step.      * If we find any deviations, then this packet is bad.      */
define|#
directive|define
name|REJCIIFACEID
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val1
parameter_list|)
define|\
value|if (go->neg&& \ 	len>= (cilen = CILEN_IFACEID)&& \ 	p[1] == cilen&& \ 	p[0] == opt) { \ 	len -= cilen; \ 	INCPTR(2, p); \ 	eui64_get(ifaceid, p); \
comment|/* Check rejected value. */
value|\ 	if (! eui64_equals(ifaceid, val1)) \ 	    goto bad; \ 	try.neg = 0; \     }
define|#
directive|define
name|REJCIVJ
parameter_list|(
name|opt
parameter_list|,
name|neg
parameter_list|,
name|val
parameter_list|)
define|\
value|if (go->neg&& \ 	p[1] == CILEN_COMPRESS&& \ 	len>= p[1]&& \ 	p[0] == opt) { \ 	len -= p[1]; \ 	INCPTR(2, p); \ 	GETSHORT(cishort, p); \
comment|/* Check rejected value. */
value|\ 	if (cishort != val) \ 	    goto bad; \ 	try.neg = 0; \      }
name|REJCIIFACEID
argument_list|(
name|CI_IFACEID
argument_list|,
name|neg_ifaceid
argument_list|,
name|go
operator|->
name|ourid
argument_list|)
expr_stmt|;
name|REJCIVJ
argument_list|(
name|CI_COMPRESSTYPE
argument_list|,
name|neg_vj
argument_list|,
name|go
operator|->
name|vj_protocol
argument_list|)
expr_stmt|;
comment|/*      * If there are any remaining CIs, then this packet is bad.      */
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/*      * Now we can update state.      */
if|if
condition|(
name|f
operator|->
name|state
operator|!=
name|OPENED
condition|)
operator|*
name|go
operator|=
name|try
expr_stmt|;
return|return
literal|1
return|;
name|bad
label|:
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|"ipv6cp_rejci: received bad Reject!"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_reqci - Check the peer's requested CIs and send appropriate response.  *  * Returns: CONFACK, CONFNAK or CONFREJ and input packet modified  * appropriately.  If reject_if_disagree is non-zero, doesn't return  * CONFNAK; returns CONFREJ if it can't return CONFACK.  */
end_comment

begin_function
specifier|static
name|int
name|ipv6cp_reqci
parameter_list|(
name|f
parameter_list|,
name|inp
parameter_list|,
name|len
parameter_list|,
name|reject_if_disagree
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
comment|/* Requested CIs */
name|int
modifier|*
name|len
decl_stmt|;
comment|/* Length of requested CIs */
name|int
name|reject_if_disagree
decl_stmt|;
block|{
name|ipv6cp_options
modifier|*
name|wo
init|=
operator|&
name|ipv6cp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipv6cp_options
modifier|*
name|ho
init|=
operator|&
name|ipv6cp_hisoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipv6cp_options
modifier|*
name|ao
init|=
operator|&
name|ipv6cp_allowoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipv6cp_options
modifier|*
name|go
init|=
operator|&
name|ipv6cp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|u_char
modifier|*
name|cip
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* Pointer to current and next CIs */
name|u_short
name|cilen
decl_stmt|,
name|citype
decl_stmt|;
comment|/* Parsed len, type */
name|u_short
name|cishort
decl_stmt|;
comment|/* Parsed short value */
name|eui64_t
name|ifaceid
decl_stmt|;
comment|/* Parsed interface identifier */
name|int
name|rc
init|=
name|CONFACK
decl_stmt|;
comment|/* Final packet return code */
name|int
name|orc
decl_stmt|;
comment|/* Individual option return code */
name|u_char
modifier|*
name|p
decl_stmt|;
comment|/* Pointer to next char to parse */
name|u_char
modifier|*
name|ucp
init|=
name|inp
decl_stmt|;
comment|/* Pointer to current output char */
name|int
name|l
init|=
operator|*
name|len
decl_stmt|;
comment|/* Length left */
comment|/*      * Reset all his options.      */
name|BZERO
argument_list|(
name|ho
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ho
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Process all his options.      */
name|next
operator|=
name|inp
expr_stmt|;
while|while
condition|(
name|l
condition|)
block|{
name|orc
operator|=
name|CONFACK
expr_stmt|;
comment|/* Assume success */
name|cip
operator|=
name|p
operator|=
name|next
expr_stmt|;
comment|/* Remember begining of CI */
if|if
condition|(
name|l
operator|<
literal|2
operator|||
comment|/* Not enough data for CI header or */
name|p
index|[
literal|1
index|]
operator|<
literal|2
operator|||
comment|/*  CI length too small or */
name|p
index|[
literal|1
index|]
operator|>
name|l
condition|)
block|{
comment|/*  CI length too big? */
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|"ipv6cp_reqci: bad CI length!"
operator|)
argument_list|)
expr_stmt|;
name|orc
operator|=
name|CONFREJ
expr_stmt|;
comment|/* Reject bad CI */
name|cilen
operator|=
name|l
expr_stmt|;
comment|/* Reject till end of packet */
name|l
operator|=
literal|0
expr_stmt|;
comment|/* Don't loop again */
goto|goto
name|endswitch
goto|;
block|}
name|GETCHAR
argument_list|(
name|citype
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Parse CI type */
name|GETCHAR
argument_list|(
name|cilen
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Parse CI length */
name|l
operator|-=
name|cilen
expr_stmt|;
comment|/* Adjust remaining length */
name|next
operator|+=
name|cilen
expr_stmt|;
comment|/* Step to next CI */
switch|switch
condition|(
name|citype
condition|)
block|{
comment|/* Check CI type */
case|case
name|CI_IFACEID
case|:
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|"ipv6cp: received interface identifier "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_ifaceid
operator|||
name|cilen
operator|!=
name|CILEN_IFACEID
condition|)
block|{
comment|/* Check CI length */
name|orc
operator|=
name|CONFREJ
expr_stmt|;
comment|/* Reject CI */
break|break;
block|}
comment|/* 	     * If he has no interface identifier, or if we both have same  	     * identifier then NAK it with new idea. 	     * In particular, if we don't know his identifier, but he does, 	     * then accept it. 	     */
name|eui64_get
argument_list|(
name|ifaceid
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|"(%s)"
operator|,
name|llv6_ntoa
argument_list|(
name|ifaceid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eui64_iszero
argument_list|(
name|ifaceid
argument_list|)
operator|&&
name|eui64_iszero
argument_list|(
name|go
operator|->
name|ourid
argument_list|)
condition|)
block|{
name|orc
operator|=
name|CONFREJ
expr_stmt|;
comment|/* Reject CI */
break|break;
block|}
if|if
condition|(
operator|!
name|eui64_iszero
argument_list|(
name|wo
operator|->
name|hisid
argument_list|)
operator|&&
operator|!
name|eui64_equals
argument_list|(
name|ifaceid
argument_list|,
name|wo
operator|->
name|hisid
argument_list|)
operator|&&
name|eui64_iszero
argument_list|(
name|go
operator|->
name|hisid
argument_list|)
condition|)
block|{
name|orc
operator|=
name|CONFNAK
expr_stmt|;
name|ifaceid
operator|=
name|wo
operator|->
name|hisid
expr_stmt|;
name|go
operator|->
name|hisid
operator|=
name|ifaceid
expr_stmt|;
name|DECPTR
argument_list|(
sizeof|sizeof
argument_list|(
name|ifaceid
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|eui64_put
argument_list|(
name|ifaceid
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eui64_iszero
argument_list|(
name|ifaceid
argument_list|)
operator|||
name|eui64_equals
argument_list|(
name|ifaceid
argument_list|,
name|go
operator|->
name|ourid
argument_list|)
condition|)
block|{
name|orc
operator|=
name|CONFNAK
expr_stmt|;
if|if
condition|(
name|eui64_iszero
argument_list|(
name|go
operator|->
name|hisid
argument_list|)
condition|)
comment|/* first time, try option */
name|ifaceid
operator|=
name|wo
operator|->
name|hisid
expr_stmt|;
while|while
condition|(
name|eui64_iszero
argument_list|(
name|ifaceid
argument_list|)
operator|||
name|eui64_equals
argument_list|(
name|ifaceid
argument_list|,
name|go
operator|->
name|ourid
argument_list|)
condition|)
comment|/* bad luck */
name|eui64_magic
argument_list|(
name|ifaceid
argument_list|)
expr_stmt|;
name|go
operator|->
name|hisid
operator|=
name|ifaceid
expr_stmt|;
name|DECPTR
argument_list|(
sizeof|sizeof
argument_list|(
name|ifaceid
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|eui64_put
argument_list|(
name|ifaceid
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|ho
operator|->
name|neg_ifaceid
operator|=
literal|1
expr_stmt|;
name|ho
operator|->
name|hisid
operator|=
name|ifaceid
expr_stmt|;
break|break;
case|case
name|CI_COMPRESSTYPE
case|:
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|"ipv6cp: received COMPRESSTYPE "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ao
operator|->
name|neg_vj
operator|||
operator|(
name|cilen
operator|!=
name|CILEN_COMPRESS
operator|)
condition|)
block|{
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|"(%d)"
operator|,
name|cishort
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPV6CP_COMP
if|if
condition|(
operator|!
operator|(
name|cishort
operator|==
name|IPV6CP_COMP
operator|)
condition|)
block|{
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
endif|#
directive|endif
name|ho
operator|->
name|neg_vj
operator|=
literal|1
expr_stmt|;
name|ho
operator|->
name|vj_protocol
operator|=
name|cishort
expr_stmt|;
break|break;
default|default:
name|orc
operator|=
name|CONFREJ
expr_stmt|;
break|break;
block|}
name|endswitch
label|:
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|" (%s)\n"
operator|,
name|CODENAME
argument_list|(
name|orc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|orc
operator|==
name|CONFACK
operator|&&
comment|/* Good CI */
name|rc
operator|!=
name|CONFACK
condition|)
comment|/*  but prior CI wasnt? */
continue|continue;
comment|/* Don't send this one */
if|if
condition|(
name|orc
operator|==
name|CONFNAK
condition|)
block|{
comment|/* Nak this CI? */
if|if
condition|(
name|reject_if_disagree
condition|)
comment|/* Getting fed up with sending NAKs? */
name|orc
operator|=
name|CONFREJ
expr_stmt|;
comment|/* Get tough if so */
else|else
block|{
if|if
condition|(
name|rc
operator|==
name|CONFREJ
condition|)
comment|/* Rejecting prior CI? */
continue|continue;
comment|/* Don't send this one */
if|if
condition|(
name|rc
operator|==
name|CONFACK
condition|)
block|{
comment|/* Ack'd all prior CIs? */
name|rc
operator|=
name|CONFNAK
expr_stmt|;
comment|/* Not anymore... */
name|ucp
operator|=
name|inp
expr_stmt|;
comment|/* Backup */
block|}
block|}
block|}
if|if
condition|(
name|orc
operator|==
name|CONFREJ
operator|&&
comment|/* Reject this CI */
name|rc
operator|!=
name|CONFREJ
condition|)
block|{
comment|/*  but no prior ones? */
name|rc
operator|=
name|CONFREJ
expr_stmt|;
name|ucp
operator|=
name|inp
expr_stmt|;
comment|/* Backup */
block|}
comment|/* Need to move CI? */
if|if
condition|(
name|ucp
operator|!=
name|cip
condition|)
name|BCOPY
argument_list|(
name|cip
argument_list|,
name|ucp
argument_list|,
name|cilen
argument_list|)
expr_stmt|;
comment|/* Move it */
comment|/* Update output pointer */
name|INCPTR
argument_list|(
name|cilen
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
block|}
comment|/*      * If we aren't rejecting this packet, and we want to negotiate      * their identifier and they didn't send their identifier, then we      * send a NAK with a CI_IFACEID option appended.  We assume the      * input buffer is long enough that we can append the extra      * option safely.      */
if|if
condition|(
name|rc
operator|!=
name|CONFREJ
operator|&&
operator|!
name|ho
operator|->
name|neg_ifaceid
operator|&&
name|wo
operator|->
name|req_ifaceid
operator|&&
operator|!
name|reject_if_disagree
condition|)
block|{
if|if
condition|(
name|rc
operator|==
name|CONFACK
condition|)
block|{
name|rc
operator|=
name|CONFNAK
expr_stmt|;
name|ucp
operator|=
name|inp
expr_stmt|;
comment|/* reset pointer */
name|wo
operator|->
name|req_ifaceid
operator|=
literal|0
expr_stmt|;
comment|/* don't ask again */
block|}
name|PUTCHAR
argument_list|(
name|CI_IFACEID
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CILEN_IFACEID
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
name|eui64_put
argument_list|(
name|wo
operator|->
name|hisid
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
block|}
operator|*
name|len
operator|=
name|ucp
operator|-
name|inp
expr_stmt|;
comment|/* Compute output length */
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|"ipv6cp: returning Configure-%s"
operator|,
name|CODENAME
argument_list|(
name|rc
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
comment|/* Return final code */
block|}
end_function

begin_comment
comment|/*  * ipv6_check_options - check that any IP-related options are OK,  * and assign appropriate defaults.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6_check_options
parameter_list|()
block|{
name|ipv6cp_options
modifier|*
name|wo
init|=
operator|&
name|ipv6cp_wantoptions
index|[
literal|0
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SOL2
argument_list|)
comment|/*      * Persistent link-local id is only used when user has not explicitly      * configure/hard-code the id      */
if|if
condition|(
operator|(
name|wo
operator|->
name|use_persistent
operator|)
operator|&&
operator|(
operator|!
name|wo
operator|->
name|opt_local
operator|)
operator|&&
operator|(
operator|!
name|wo
operator|->
name|opt_remote
operator|)
condition|)
block|{
comment|/*  	 * On systems where there are no Ethernet interfaces used, there 	 * may be other ways to obtain a persistent id. Right now, it 	 * will fall back to using magic [see eui64_magic] below when 	 * an EUI-48 from MAC address can't be obtained. Other possibilities 	 * include obtaining EEPROM serial numbers, or some other unique 	 * yet persistent number. On Sparc platforms, this is possible, 	 * but too bad there's no standards yet for x86 machines. 	 */
if|if
condition|(
name|ether_to_eui64
argument_list|(
operator|&
name|wo
operator|->
name|ourid
argument_list|)
condition|)
block|{
name|wo
operator|->
name|opt_local
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|wo
operator|->
name|opt_local
condition|)
block|{
comment|/* init interface identifier */
if|if
condition|(
name|wo
operator|->
name|use_ip
operator|&&
name|eui64_iszero
argument_list|(
name|wo
operator|->
name|ourid
argument_list|)
condition|)
block|{
name|eui64_setlo32
argument_list|(
name|wo
operator|->
name|ourid
argument_list|,
name|ntohl
argument_list|(
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|ouraddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eui64_iszero
argument_list|(
name|wo
operator|->
name|ourid
argument_list|)
condition|)
name|wo
operator|->
name|opt_local
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|eui64_iszero
argument_list|(
name|wo
operator|->
name|ourid
argument_list|)
condition|)
name|eui64_magic
argument_list|(
name|wo
operator|->
name|ourid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|wo
operator|->
name|opt_remote
condition|)
block|{
if|if
condition|(
name|wo
operator|->
name|use_ip
operator|&&
name|eui64_iszero
argument_list|(
name|wo
operator|->
name|hisid
argument_list|)
condition|)
block|{
name|eui64_setlo32
argument_list|(
name|wo
operator|->
name|hisid
argument_list|,
name|ntohl
argument_list|(
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|hisaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eui64_iszero
argument_list|(
name|wo
operator|->
name|hisid
argument_list|)
condition|)
name|wo
operator|->
name|opt_remote
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|demand
operator|&&
operator|(
name|eui64_iszero
argument_list|(
name|wo
operator|->
name|ourid
argument_list|)
operator|||
name|eui64_iszero
argument_list|(
name|wo
operator|->
name|hisid
argument_list|)
operator|)
condition|)
block|{
name|option_error
argument_list|(
literal|"local/remote LL address required for demand-dialling\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ipv6_demand_conf - configure the interface as though  * IPV6CP were up, for use with dial-on-demand.  */
end_comment

begin_function
specifier|static
name|int
name|ipv6_demand_conf
parameter_list|(
name|u
parameter_list|)
name|int
name|u
decl_stmt|;
block|{
name|ipv6cp_options
modifier|*
name|wo
init|=
operator|&
name|ipv6cp_wantoptions
index|[
name|u
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|||
name|defined
argument_list|(
name|SOL2
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SVR4
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|SNI
argument_list|)
operator|||
name|defined
argument_list|(
name|__USLC__
argument_list|)
operator|)
operator|)
if|#
directive|if
name|defined
argument_list|(
name|SOL2
argument_list|)
if|if
condition|(
operator|!
name|sif6up
argument_list|(
name|u
argument_list|)
condition|)
return|return
literal|0
return|;
else|#
directive|else
if|if
condition|(
operator|!
name|sifup
argument_list|(
name|u
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* defined(SOL2) */
endif|#
directive|endif
if|if
condition|(
operator|!
name|sif6addr
argument_list|(
name|u
argument_list|,
name|wo
operator|->
name|ourid
argument_list|,
name|wo
operator|->
name|hisid
argument_list|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|SVR4
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|SNI
argument_list|)
operator|||
name|defined
argument_list|(
name|__USLC__
argument_list|)
operator|)
operator|)
if|if
condition|(
operator|!
name|sifup
argument_list|(
name|u
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|sifnpmode
argument_list|(
name|u
argument_list|,
name|PPP_IPV6
argument_list|,
name|NPMODE_QUEUE
argument_list|)
condition|)
return|return
literal|0
return|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ipv6_demand_conf"
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"local  LL address %s"
argument_list|,
name|llv6_ntoa
argument_list|(
name|wo
operator|->
name|ourid
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"remote LL address %s"
argument_list|,
name|llv6_ntoa
argument_list|(
name|wo
operator|->
name|hisid
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_up - IPV6CP has come UP.  *  * Configure the IPv6 network interface appropriately and bring it up.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_up
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|ipv6cp_options
modifier|*
name|ho
init|=
operator|&
name|ipv6cp_hisoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipv6cp_options
modifier|*
name|go
init|=
operator|&
name|ipv6cp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|ipv6cp_options
modifier|*
name|wo
init|=
operator|&
name|ipv6cp_wantoptions
index|[
name|f
operator|->
name|unit
index|]
decl_stmt|;
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|"ipv6cp: up"
operator|)
argument_list|)
expr_stmt|;
comment|/*      * We must have a non-zero LL address for both ends of the link.      */
if|if
condition|(
operator|!
name|ho
operator|->
name|neg_ifaceid
condition|)
name|ho
operator|->
name|hisid
operator|=
name|wo
operator|->
name|hisid
expr_stmt|;
if|if
condition|(
operator|!
name|no_ifaceid_neg
condition|)
block|{
if|if
condition|(
name|eui64_iszero
argument_list|(
name|ho
operator|->
name|hisid
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not determine remote LL address"
argument_list|)
expr_stmt|;
name|ipv6cp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|,
literal|"Could not determine remote LL address"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eui64_iszero
argument_list|(
name|go
operator|->
name|ourid
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Could not determine local LL address"
argument_list|)
expr_stmt|;
name|ipv6cp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|,
literal|"Could not determine local LL address"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|eui64_equals
argument_list|(
name|go
operator|->
name|ourid
argument_list|,
name|ho
operator|->
name|hisid
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"local and remote LL addresses are equal"
argument_list|)
expr_stmt|;
name|ipv6cp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|,
literal|"local and remote LL addresses are equal"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|script_setenv
argument_list|(
literal|"LLLOCAL"
argument_list|,
name|llv6_ntoa
argument_list|(
name|go
operator|->
name|ourid
argument_list|)
argument_list|)
expr_stmt|;
name|script_setenv
argument_list|(
literal|"LLREMOTE"
argument_list|,
name|llv6_ntoa
argument_list|(
name|ho
operator|->
name|hisid
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPV6CP_COMP
comment|/* set tcp compression */
name|sif6comp
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|ho
operator|->
name|neg_vj
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * If we are doing dial-on-demand, the interface is already      * configured, so we put out any saved-up packets, then set the      * interface to pass IPv6 packets.      */
if|if
condition|(
name|demand
condition|)
block|{
if|if
condition|(
operator|!
name|eui64_equals
argument_list|(
name|go
operator|->
name|ourid
argument_list|,
name|wo
operator|->
name|ourid
argument_list|)
operator|||
operator|!
name|eui64_equals
argument_list|(
name|ho
operator|->
name|hisid
argument_list|,
name|wo
operator|->
name|hisid
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|eui64_equals
argument_list|(
name|go
operator|->
name|ourid
argument_list|,
name|wo
operator|->
name|ourid
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Local LL address changed to %s"
argument_list|,
name|llv6_ntoa
argument_list|(
name|go
operator|->
name|ourid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eui64_equals
argument_list|(
name|ho
operator|->
name|hisid
argument_list|,
name|wo
operator|->
name|hisid
argument_list|)
condition|)
name|warn
argument_list|(
literal|"Remote LL address changed to %s"
argument_list|,
name|llv6_ntoa
argument_list|(
name|ho
operator|->
name|hisid
argument_list|)
argument_list|)
expr_stmt|;
name|ipv6cp_clear_addrs
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|go
operator|->
name|ourid
argument_list|,
name|ho
operator|->
name|hisid
argument_list|)
expr_stmt|;
comment|/* Set the interface to the new addresses */
if|if
condition|(
operator|!
name|sif6addr
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|go
operator|->
name|ourid
argument_list|,
name|ho
operator|->
name|hisid
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|warn
argument_list|(
literal|"sif6addr failed"
argument_list|)
expr_stmt|;
name|ipv6cp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|,
literal|"Interface configuration failed"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|demand_rexmit
argument_list|(
name|PPP_IPV6
argument_list|)
expr_stmt|;
name|sifnpmode
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|PPP_IPV6
argument_list|,
name|NPMODE_PASS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Set LL addresses 	 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SOL2
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|SVR4
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|SNI
argument_list|)
operator|||
name|defined
argument_list|(
name|__USLC__
argument_list|)
operator|)
operator|)
if|if
condition|(
operator|!
name|sif6addr
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|go
operator|->
name|ourid
argument_list|,
name|ho
operator|->
name|hisid
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|warn
argument_list|(
literal|"sif6addr failed"
argument_list|)
expr_stmt|;
name|ipv6cp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|,
literal|"Interface configuration failed"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* bring the interface up for IPv6 */
if|#
directive|if
name|defined
argument_list|(
name|SOL2
argument_list|)
if|if
condition|(
operator|!
name|sif6up
argument_list|(
name|f
operator|->
name|unit
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|warn
argument_list|(
literal|"sifup failed (IPV6)"
argument_list|)
expr_stmt|;
name|ipv6cp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|,
literal|"Interface configuration failed"
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|sifup
argument_list|(
name|f
operator|->
name|unit
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|warn
argument_list|(
literal|"sifup failed (IPV6)"
argument_list|)
expr_stmt|;
name|ipv6cp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|,
literal|"Interface configuration failed"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* defined(SOL2) */
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|||
name|defined
argument_list|(
name|SOL2
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SVR4
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|SNI
argument_list|)
operator|||
name|defined
argument_list|(
name|__USLC__
argument_list|)
operator|)
operator|)
if|if
condition|(
operator|!
name|sif6addr
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|go
operator|->
name|ourid
argument_list|,
name|ho
operator|->
name|hisid
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|warn
argument_list|(
literal|"sif6addr failed"
argument_list|)
expr_stmt|;
name|ipv6cp_close
argument_list|(
name|f
operator|->
name|unit
argument_list|,
literal|"Interface configuration failed"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|sifnpmode
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|PPP_IPV6
argument_list|,
name|NPMODE_PASS
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"local  LL address %s"
argument_list|,
name|llv6_ntoa
argument_list|(
name|go
operator|->
name|ourid
argument_list|)
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"remote LL address %s"
argument_list|,
name|llv6_ntoa
argument_list|(
name|ho
operator|->
name|hisid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|np_up
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|PPP_IPV6
argument_list|)
expr_stmt|;
name|ipv6cp_is_up
operator|=
literal|1
expr_stmt|;
comment|/*      * Execute the ipv6-up script, like this:      *	/etc/ppp/ipv6-up interface tty speed local-LL remote-LL      */
if|if
condition|(
name|ipv6cp_script_state
operator|==
name|s_down
condition|)
block|{
name|ipv6cp_script_state
operator|=
name|s_up
expr_stmt|;
name|ipv6cp_script
argument_list|(
name|_PATH_IPV6UP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ipv6cp_down - IPV6CP has gone DOWN.  *  * Take the IPv6 network interface down, clear its addresses  * and delete routes through it.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_down
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|IPV6CPDEBUG
argument_list|(
operator|(
literal|"ipv6cp: down"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipv6cp_is_up
condition|)
block|{
name|ipv6cp_is_up
operator|=
literal|0
expr_stmt|;
name|np_down
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|PPP_IPV6
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPV6CP_COMP
name|sif6comp
argument_list|(
name|f
operator|->
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * If we are doing dial-on-demand, set the interface      * to queue up outgoing packets (for now).      */
if|if
condition|(
name|demand
condition|)
block|{
name|sifnpmode
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|PPP_IPV6
argument_list|,
name|NPMODE_QUEUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sifnpmode
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|PPP_IPV6
argument_list|,
name|NPMODE_DROP
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
operator|!
operator|(
name|defined
argument_list|(
name|SVR4
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|SNI
argument_list|)
operator|||
name|defined
argument_list|(
name|__USLC
argument_list|)
operator|)
operator|)
if|#
directive|if
name|defined
argument_list|(
name|SOL2
argument_list|)
name|sif6down
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
name|sifdown
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(SOL2) */
endif|#
directive|endif
name|ipv6cp_clear_addrs
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|ipv6cp_gotoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|ourid
argument_list|,
name|ipv6cp_hisoptions
index|[
name|f
operator|->
name|unit
index|]
operator|.
name|hisid
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SVR4
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|SNI
argument_list|)
operator|||
name|defined
argument_list|(
name|__USLC
argument_list|)
operator|)
operator|)
name|sifdown
argument_list|(
name|f
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Execute the ipv6-down script */
if|if
condition|(
name|ipv6cp_script_state
operator|==
name|s_up
condition|)
block|{
name|ipv6cp_script_state
operator|=
name|s_down
expr_stmt|;
name|ipv6cp_script
argument_list|(
name|_PATH_IPV6DOWN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ipv6cp_clear_addrs() - clear the interface addresses, routes,  * proxy neighbour discovery entries, etc.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_clear_addrs
parameter_list|(
name|unit
parameter_list|,
name|ourid
parameter_list|,
name|hisid
parameter_list|)
name|int
name|unit
decl_stmt|;
name|eui64_t
name|ourid
decl_stmt|;
name|eui64_t
name|hisid
decl_stmt|;
block|{
name|cif6addr
argument_list|(
name|unit
argument_list|,
name|ourid
argument_list|,
name|hisid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_finished - possibly shut down the lower layers.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_finished
parameter_list|(
name|f
parameter_list|)
name|fsm
modifier|*
name|f
decl_stmt|;
block|{
name|np_finished
argument_list|(
name|f
operator|->
name|unit
argument_list|,
name|PPP_IPV6
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_script - Execute a script with arguments  * interface-name tty-name speed local-LL remote-LL.  */
end_comment

begin_function
specifier|static
name|void
name|ipv6cp_script
parameter_list|(
name|script
parameter_list|)
name|char
modifier|*
name|script
decl_stmt|;
block|{
name|char
name|strspeed
index|[
literal|32
index|]
decl_stmt|,
name|strlocal
index|[
literal|32
index|]
decl_stmt|,
name|strremote
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|8
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|strspeed
argument_list|,
literal|"%d"
argument_list|,
name|baud_rate
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|strlocal
argument_list|,
name|llv6_ntoa
argument_list|(
name|ipv6cp_gotoptions
index|[
literal|0
index|]
operator|.
name|ourid
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|strremote
argument_list|,
name|llv6_ntoa
argument_list|(
name|ipv6cp_hisoptions
index|[
literal|0
index|]
operator|.
name|hisid
argument_list|)
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|script
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|ifname
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|devnam
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|=
name|strspeed
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|=
name|strlocal
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|=
name|strremote
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|=
name|ipparam
expr_stmt|;
name|argv
index|[
literal|7
index|]
operator|=
name|NULL
expr_stmt|;
name|run_program
argument_list|(
name|script
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ipv6cp_printpkt - print the contents of an IPV6CP packet.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ipv6cp_codenames
index|[]
init|=
block|{
literal|"ConfReq"
block|,
literal|"ConfAck"
block|,
literal|"ConfNak"
block|,
literal|"ConfRej"
block|,
literal|"TermReq"
block|,
literal|"TermAck"
block|,
literal|"CodeRej"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipv6cp_printpkt
argument_list|(
name|p
argument_list|,
name|plen
argument_list|,
name|printer
argument_list|,
name|arg
argument_list|)
name|u_char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|plen
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|printer
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|code
decl_stmt|,
name|id
decl_stmt|,
name|len
decl_stmt|,
name|olen
decl_stmt|;
name|u_char
modifier|*
name|pstart
decl_stmt|,
modifier|*
name|optend
decl_stmt|;
name|u_short
name|cishort
decl_stmt|;
name|eui64_t
name|ifaceid
decl_stmt|;
if|if
condition|(
name|plen
operator|<
name|HEADERLEN
condition|)
return|return
literal|0
return|;
name|pstart
operator|=
name|p
expr_stmt|;
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|id
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|len
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|HEADERLEN
operator|||
name|len
operator|>
name|plen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|>=
literal|1
operator|&&
name|code
operator|<=
sizeof|sizeof
argument_list|(
name|ipv6cp_codenames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %s"
argument_list|,
name|ipv6cp_codenames
index|[
name|code
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|printer
argument_list|(
name|arg
argument_list|,
literal|" code=0x%x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" id=0x%x"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|len
operator|-=
name|HEADERLEN
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CONFREQ
case|:
case|case
name|CONFACK
case|:
case|case
name|CONFNAK
case|:
case|case
name|CONFREJ
case|:
comment|/* print option list */
while|while
condition|(
name|len
operator|>=
literal|2
condition|)
block|{
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|olen
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|olen
operator|<
literal|2
operator|||
name|olen
operator|>
name|len
condition|)
block|{
break|break;
block|}
name|printer
argument_list|(
name|arg
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|len
operator|-=
name|olen
expr_stmt|;
name|optend
operator|=
name|p
operator|+
name|olen
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CI_COMPRESSTYPE
case|:
if|if
condition|(
name|olen
operator|>=
name|CILEN_COMPRESS
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|GETSHORT
argument_list|(
name|cishort
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"compress "
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"0x%x"
argument_list|,
name|cishort
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CI_IFACEID
case|:
if|if
condition|(
name|olen
operator|==
name|CILEN_IFACEID
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|eui64_get
argument_list|(
name|ifaceid
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"addr %s"
argument_list|,
name|llv6_ntoa
argument_list|(
name|ifaceid
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
while|while
condition|(
name|p
operator|<
name|optend
condition|)
block|{
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %.2x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
name|printer
argument_list|(
name|arg
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TERMACK
case|:
case|case
name|TERMREQ
case|:
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
operator|*
name|p
operator|>=
literal|' '
operator|&&
operator|*
name|p
operator|<
literal|0x7f
condition|)
block|{
name|printer
argument_list|(
name|arg
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
name|p
argument_list|,
name|len
argument_list|,
name|printer
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
comment|/* print the rest of the bytes in the packet */
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
block|{
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %.2x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
return|return
name|p
operator|-
name|pstart
return|;
block|}
end_block

begin_comment
comment|/*  * ipv6_active_pkt - see if this IP packet is worth bringing the link up for.  * We don't bring the link up for IP fragments or for TCP FIN packets  * with no data.  */
end_comment

begin_define
define|#
directive|define
name|IP6_HDRLEN
value|40
end_define

begin_comment
comment|/* bytes */
end_comment

begin_define
define|#
directive|define
name|IP6_NHDR_FRAG
value|44
end_define

begin_comment
comment|/* fragment IPv6 header */
end_comment

begin_define
define|#
directive|define
name|IPPROTO_TCP
value|6
end_define

begin_define
define|#
directive|define
name|TCP_HDRLEN
value|20
end_define

begin_define
define|#
directive|define
name|TH_FIN
value|0x01
end_define

begin_comment
comment|/*  * We use these macros because the IP header may be at an odd address,  * and some compilers might use word loads to get th_off or ip_hl.  */
end_comment

begin_define
define|#
directive|define
name|get_ip6nh
parameter_list|(
name|x
parameter_list|)
value|(((unsigned char *)(x))[6])
end_define

begin_define
define|#
directive|define
name|get_tcpoff
parameter_list|(
name|x
parameter_list|)
value|(((unsigned char *)(x))[12]>> 4)
end_define

begin_define
define|#
directive|define
name|get_tcpflags
parameter_list|(
name|x
parameter_list|)
value|(((unsigned char *)(x))[13])
end_define

begin_function
specifier|static
name|int
name|ipv6_active_pkt
parameter_list|(
name|pkt
parameter_list|,
name|len
parameter_list|)
name|u_char
modifier|*
name|pkt
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|u_char
modifier|*
name|tcp
decl_stmt|;
name|len
operator|-=
name|PPP_HDRLEN
expr_stmt|;
name|pkt
operator|+=
name|PPP_HDRLEN
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|IP6_HDRLEN
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_ip6nh
argument_list|(
name|pkt
argument_list|)
operator|==
name|IP6_NHDR_FRAG
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|get_ip6nh
argument_list|(
name|pkt
argument_list|)
operator|!=
name|IPPROTO_TCP
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|len
operator|<
name|IP6_HDRLEN
operator|+
name|TCP_HDRLEN
condition|)
return|return
literal|0
return|;
name|tcp
operator|=
name|pkt
operator|+
name|IP6_HDRLEN
expr_stmt|;
if|if
condition|(
operator|(
name|get_tcpflags
argument_list|(
name|tcp
argument_list|)
operator|&
name|TH_FIN
operator|)
operator|!=
literal|0
operator|&&
name|len
operator|==
name|IP6_HDRLEN
operator|+
name|get_tcpoff
argument_list|(
name|tcp
argument_list|)
operator|*
literal|4
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

end_unit

