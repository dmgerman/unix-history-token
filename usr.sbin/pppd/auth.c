begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * auth.c - PPP authentication and phase control.  *  * Copyright (c) 1993 The Australian National University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the Australian National University.  The name of the University  * may not be used to endorse or promote products derived from this  * software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_PATH_LASTLOG
argument_list|)
operator|&&
name|defined
argument_list|(
name|_linux_
argument_list|)
end_if

begin_include
include|#
directive|include
file|<lastlog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PAM
end_ifdef

begin_include
include|#
directive|include
file|<security/pam_appl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SHADOW
end_ifdef

begin_include
include|#
directive|include
file|<shadow.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PW_PPP
end_ifndef

begin_define
define|#
directive|define
name|PW_PPP
value|PW_LOGIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pppd.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"upap.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CBCP_SUPPORT
end_ifdef

begin_include
include|#
directive|include
file|"cbcp.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/* Used for storing a sequence of words.  Usually malloced. */
end_comment

begin_struct
struct|struct
name|wordlist
block|{
name|struct
name|wordlist
modifier|*
name|next
decl_stmt|;
name|char
name|word
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Bits in scan_authfile return value */
end_comment

begin_define
define|#
directive|define
name|NONWILD_SERVER
value|1
end_define

begin_define
define|#
directive|define
name|NONWILD_CLIENT
value|2
end_define

begin_define
define|#
directive|define
name|ISWILD
parameter_list|(
name|word
parameter_list|)
value|(word[0] == '*'&& word[1] == 0)
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_comment
comment|/* The name by which the peer authenticated itself to us. */
end_comment

begin_decl_stmt
name|char
name|peer_authname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Records which authentication operations haven't completed yet. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|auth_pending
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if we have successfully called plogin() */
end_comment

begin_decl_stmt
specifier|static
name|int
name|logged_in
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if not wild or blank */
end_comment

begin_decl_stmt
specifier|static
name|int
name|non_wildclient
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if we have run the /etc/ppp/auth-up script. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|did_authup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of addresses which the peer may use. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|wordlist
modifier|*
name|addresses
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of network protocols which we have opened. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_np_open
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of network protocols which have come up. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_np_up
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if we got the contents of passwd[] from the pap-secrets file. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|passwd_from_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bits in auth_pending[] */
end_comment

begin_define
define|#
directive|define
name|PAP_WITHPEER
value|1
end_define

begin_define
define|#
directive|define
name|PAP_PEER
value|2
end_define

begin_define
define|#
directive|define
name|CHAP_WITHPEER
value|4
end_define

begin_define
define|#
directive|define
name|CHAP_PEER
value|8
end_define

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|crypt
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for procedures local to this file. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|network_phase
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_idle
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|connect_time_expired
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|plogin
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|plogout
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|null_login
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_pap_passwd
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_pap_secret
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_chap_secret
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip_addr_check
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|,
expr|struct
name|wordlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scan_authfile
name|__P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|u_int32_t
operator|,
name|char
operator|*
operator|,
expr|struct
name|wordlist
operator|*
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_wordlist
name|__P
argument_list|(
operator|(
expr|struct
name|wordlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|auth_set_ip_addr
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|auth_script
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_allowed_addrs
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|wordlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * An Open on LCP has requested a change from Dead to Establish phase.  * Do what's necessary to bring the physical layer up.  */
end_comment

begin_function
name|void
name|link_required
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*  * LCP has terminated the link; go to the Dead phase and take the  * physical layer down.  */
end_comment

begin_function
name|void
name|link_terminated
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|extern
name|time_t
name|etime
decl_stmt|,
name|stime
decl_stmt|;
specifier|extern
name|int
name|minutes
decl_stmt|;
if|if
condition|(
name|phase
operator|==
name|PHASE_DEAD
condition|)
return|return;
if|if
condition|(
name|logged_in
condition|)
name|plogout
argument_list|()
expr_stmt|;
name|phase
operator|=
name|PHASE_DEAD
expr_stmt|;
name|etime
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|minutes
operator|=
operator|(
name|etime
operator|-
name|stime
operator|)
operator|/
literal|60
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Connection terminated, connected for %d minutes\n"
argument_list|,
name|minutes
operator|>
literal|1
condition|?
name|minutes
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * LCP has gone down; it will either die or try to re-establish.  */
end_comment

begin_function
name|void
name|link_down
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|protent
modifier|*
name|protp
decl_stmt|;
if|if
condition|(
name|did_authup
condition|)
block|{
name|auth_script
argument_list|(
name|_PATH_AUTHDOWN
argument_list|)
expr_stmt|;
name|did_authup
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|protp
operator|=
name|protocols
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|protp
operator|->
name|enabled_flag
condition|)
continue|continue;
if|if
condition|(
name|protp
operator|->
name|protocol
operator|!=
name|PPP_LCP
operator|&&
name|protp
operator|->
name|lowerdown
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|protp
operator|->
name|lowerdown
call|)
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|protp
operator|->
name|protocol
operator|<
literal|0xC000
operator|&&
name|protp
operator|->
name|close
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|protp
operator|->
name|close
call|)
argument_list|(
name|unit
argument_list|,
literal|"LCP down"
argument_list|)
expr_stmt|;
block|}
name|num_np_open
operator|=
literal|0
expr_stmt|;
name|num_np_up
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|phase
operator|!=
name|PHASE_DEAD
condition|)
name|phase
operator|=
name|PHASE_TERMINATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The link is established.  * Proceed to the Dead, Authenticate or Network phase as appropriate.  */
end_comment

begin_function
name|void
name|link_established
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|auth
decl_stmt|;
name|lcp_options
modifier|*
name|wo
init|=
operator|&
name|lcp_wantoptions
index|[
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|ho
init|=
operator|&
name|lcp_hisoptions
index|[
name|unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|protent
modifier|*
name|protp
decl_stmt|;
comment|/*      * Tell higher-level protocols that LCP is up.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|protp
operator|=
name|protocols
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|protp
operator|->
name|protocol
operator|!=
name|PPP_LCP
operator|&&
name|protp
operator|->
name|enabled_flag
operator|&&
name|protp
operator|->
name|lowerup
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|protp
operator|->
name|lowerup
call|)
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_required
operator|&&
operator|!
operator|(
name|go
operator|->
name|neg_chap
operator|||
name|go
operator|->
name|neg_upap
operator|)
condition|)
block|{
comment|/* 	 * We wanted the peer to authenticate itself, and it refused: 	 * treat it as though it authenticated with PAP using a username 	 * of "" and a password of "".  If that's not OK, boot it out. 	 */
if|if
condition|(
operator|!
name|wo
operator|->
name|neg_upap
operator|||
operator|!
name|null_login
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"peer refused to authenticate"
argument_list|)
expr_stmt|;
name|lcp_close
argument_list|(
name|unit
argument_list|,
literal|"peer refused to authenticate"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|phase
operator|=
name|PHASE_AUTHENTICATE
expr_stmt|;
name|auth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|go
operator|->
name|neg_chap
condition|)
block|{
name|ChapAuthPeer
argument_list|(
name|unit
argument_list|,
name|our_name
argument_list|,
name|go
operator|->
name|chap_mdtype
argument_list|)
expr_stmt|;
name|auth
operator||=
name|CHAP_PEER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|go
operator|->
name|neg_upap
condition|)
block|{
name|upap_authpeer
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|auth
operator||=
name|PAP_PEER
expr_stmt|;
block|}
if|if
condition|(
name|ho
operator|->
name|neg_chap
condition|)
block|{
name|ChapAuthWithPeer
argument_list|(
name|unit
argument_list|,
name|user
argument_list|,
name|ho
operator|->
name|chap_mdtype
argument_list|)
expr_stmt|;
name|auth
operator||=
name|CHAP_WITHPEER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ho
operator|->
name|neg_upap
condition|)
block|{
if|if
condition|(
name|passwd
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|passwd_from_file
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|get_pap_passwd
argument_list|(
name|passwd
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No secret found for PAP login"
argument_list|)
expr_stmt|;
block|}
name|upap_authwithpeer
argument_list|(
name|unit
argument_list|,
name|user
argument_list|,
name|passwd
argument_list|)
expr_stmt|;
name|auth
operator||=
name|PAP_WITHPEER
expr_stmt|;
block|}
name|auth_pending
index|[
name|unit
index|]
operator|=
name|auth
expr_stmt|;
if|if
condition|(
operator|!
name|auth
condition|)
name|network_phase
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Proceed to the network phase.  */
end_comment

begin_function
specifier|static
name|void
name|network_phase
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|protent
modifier|*
name|protp
decl_stmt|;
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|unit
index|]
decl_stmt|;
comment|/*      * If the peer had to authenticate, run the auth-up script now.      */
if|if
condition|(
operator|(
name|go
operator|->
name|neg_chap
operator|||
name|go
operator|->
name|neg_upap
operator|)
operator|&&
operator|!
name|did_authup
condition|)
block|{
name|auth_script
argument_list|(
name|_PATH_AUTHUP
argument_list|)
expr_stmt|;
name|did_authup
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CBCP_SUPPORT
comment|/*      * If we negotiated callback, do it now.      */
if|if
condition|(
name|go
operator|->
name|neg_cbcp
condition|)
block|{
name|phase
operator|=
name|PHASE_CALLBACK
expr_stmt|;
call|(
modifier|*
name|cbcp_protent
operator|.
name|open
call|)
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|phase
operator|=
name|PHASE_NETWORK
expr_stmt|;
if|#
directive|if
literal|0
block|if (!demand) 	set_filters(&pass_filter,&active_filter);
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|protp
operator|=
name|protocols
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|protp
operator|->
name|protocol
operator|<
literal|0xC000
operator|&&
name|protp
operator|->
name|enabled_flag
operator|&&
name|protp
operator|->
name|open
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|protp
operator|->
name|open
call|)
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|protp
operator|->
name|protocol
operator|!=
name|PPP_CCP
condition|)
operator|++
name|num_np_open
expr_stmt|;
block|}
if|if
condition|(
name|num_np_open
operator|==
literal|0
condition|)
comment|/* nothing to do */
name|lcp_close
argument_list|(
literal|0
argument_list|,
literal|"No network protocols running"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The peer has failed to authenticate himself using `protocol'.  */
end_comment

begin_function
name|void
name|auth_peer_fail
parameter_list|(
name|unit
parameter_list|,
name|protocol
parameter_list|)
name|int
name|unit
decl_stmt|,
name|protocol
decl_stmt|;
block|{
comment|/*      * Authentication failure: take the link down      */
name|lcp_close
argument_list|(
name|unit
argument_list|,
literal|"Authentication failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The peer has been successfully authenticated using `protocol'.  */
end_comment

begin_function
name|void
name|auth_peer_success
parameter_list|(
name|unit
parameter_list|,
name|protocol
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|)
name|int
name|unit
decl_stmt|,
name|protocol
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
block|{
name|int
name|bit
decl_stmt|;
switch|switch
condition|(
name|protocol
condition|)
block|{
case|case
name|PPP_CHAP
case|:
name|bit
operator|=
name|CHAP_PEER
expr_stmt|;
break|break;
case|case
name|PPP_PAP
case|:
name|bit
operator|=
name|PAP_PEER
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"auth_peer_success: unknown protocol %x"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Save the authenticated name of the peer for later.      */
if|if
condition|(
name|namelen
operator|>
sizeof|sizeof
argument_list|(
name|peer_authname
argument_list|)
operator|-
literal|1
condition|)
name|namelen
operator|=
sizeof|sizeof
argument_list|(
name|peer_authname
argument_list|)
operator|-
literal|1
expr_stmt|;
name|BCOPY
argument_list|(
name|name
argument_list|,
name|peer_authname
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|peer_authname
index|[
name|namelen
index|]
operator|=
literal|0
expr_stmt|;
comment|/*      * If we have overridden addresses based on auth info      * then set that information now before continuing.      */
name|auth_set_ip_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|script_setenv
argument_list|(
literal|"PEERNAME"
argument_list|,
name|peer_authname
argument_list|)
expr_stmt|;
comment|/*      * If there is no more authentication still to be done,      * proceed to the network (or callback) phase.      */
if|if
condition|(
operator|(
name|auth_pending
index|[
name|unit
index|]
operator|&=
operator|~
name|bit
operator|)
operator|==
literal|0
condition|)
name|network_phase
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have failed to authenticate ourselves to the peer using `protocol'.  */
end_comment

begin_function
name|void
name|auth_withpeer_fail
parameter_list|(
name|unit
parameter_list|,
name|protocol
parameter_list|)
name|int
name|unit
decl_stmt|,
name|protocol
decl_stmt|;
block|{
if|if
condition|(
name|passwd_from_file
condition|)
name|BZERO
argument_list|(
name|passwd
argument_list|,
name|MAXSECRETLEN
argument_list|)
expr_stmt|;
comment|/*      * We've failed to authenticate ourselves to our peer.      * He'll probably take the link down, and there's not much      * we can do except wait for that.      */
block|}
end_function

begin_comment
comment|/*  * We have successfully authenticated ourselves with the peer using `protocol'.  */
end_comment

begin_function
name|void
name|auth_withpeer_success
parameter_list|(
name|unit
parameter_list|,
name|protocol
parameter_list|)
name|int
name|unit
decl_stmt|,
name|protocol
decl_stmt|;
block|{
name|int
name|bit
decl_stmt|;
switch|switch
condition|(
name|protocol
condition|)
block|{
case|case
name|PPP_CHAP
case|:
name|bit
operator|=
name|CHAP_WITHPEER
expr_stmt|;
break|break;
case|case
name|PPP_PAP
case|:
if|if
condition|(
name|passwd_from_file
condition|)
name|BZERO
argument_list|(
name|passwd
argument_list|,
name|MAXSECRETLEN
argument_list|)
expr_stmt|;
name|bit
operator|=
name|PAP_WITHPEER
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"auth_peer_success: unknown protocol %x"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * If we have overridden addresses based on auth info      * then set that information now before continuing.      */
name|auth_set_ip_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/*      * If there is no more authentication still being done,      * proceed to the network (or callback) phase.      */
if|if
condition|(
operator|(
name|auth_pending
index|[
name|unit
index|]
operator|&=
operator|~
name|bit
operator|)
operator|==
literal|0
condition|)
name|network_phase
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * np_up - a network protocol has come up.  */
end_comment

begin_function
name|void
name|np_up
parameter_list|(
name|unit
parameter_list|,
name|proto
parameter_list|)
name|int
name|unit
decl_stmt|,
name|proto
decl_stmt|;
block|{
if|if
condition|(
name|num_np_up
operator|==
literal|0
condition|)
block|{
comment|/* 	 * At this point we consider that the link has come up successfully. 	 */
name|need_holdoff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|idle_time_limit
operator|>
literal|0
condition|)
name|TIMEOUT
argument_list|(
name|check_idle
argument_list|,
name|NULL
argument_list|,
name|idle_time_limit
argument_list|)
expr_stmt|;
comment|/* 	 * Set a timeout to close the connection once the maximum 	 * connect time has expired. 	 */
if|if
condition|(
name|maxconnect
operator|>
literal|0
condition|)
name|TIMEOUT
argument_list|(
name|connect_time_expired
argument_list|,
literal|0
argument_list|,
name|maxconnect
argument_list|)
expr_stmt|;
comment|/* 	 * Detach now, if the updetach option was given. 	 */
if|if
condition|(
name|nodetach
operator|==
operator|-
literal|1
condition|)
name|detach
argument_list|()
expr_stmt|;
block|}
operator|++
name|num_np_up
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * np_down - a network protocol has gone down.  */
end_comment

begin_function
name|void
name|np_down
parameter_list|(
name|unit
parameter_list|,
name|proto
parameter_list|)
name|int
name|unit
decl_stmt|,
name|proto
decl_stmt|;
block|{
if|if
condition|(
operator|--
name|num_np_up
operator|==
literal|0
operator|&&
name|idle_time_limit
operator|>
literal|0
condition|)
block|{
name|UNTIMEOUT
argument_list|(
name|check_idle
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * np_finished - a network protocol has finished using the link.  */
end_comment

begin_function
name|void
name|np_finished
parameter_list|(
name|unit
parameter_list|,
name|proto
parameter_list|)
name|int
name|unit
decl_stmt|,
name|proto
decl_stmt|;
block|{
if|if
condition|(
operator|--
name|num_np_open
operator|<=
literal|0
condition|)
block|{
comment|/* no further use for the link: shut up shop. */
name|lcp_close
argument_list|(
literal|0
argument_list|,
literal|"No network protocols running"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * check_idle - check whether the link has been idle for long  * enough that we can shut it down.  */
end_comment

begin_function
specifier|static
name|void
name|check_idle
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ppp_idle
name|idle
decl_stmt|;
name|time_t
name|itime
decl_stmt|;
if|if
condition|(
operator|!
name|get_idle_time
argument_list|(
literal|0
argument_list|,
operator|&
name|idle
argument_list|)
condition|)
return|return;
name|itime
operator|=
name|MIN
argument_list|(
name|idle
operator|.
name|xmit_idle
argument_list|,
name|idle
operator|.
name|recv_idle
argument_list|)
expr_stmt|;
if|if
condition|(
name|itime
operator|>=
name|idle_time_limit
condition|)
block|{
comment|/* link is idle: shut it down. */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Terminating connection due to lack of activity."
argument_list|)
expr_stmt|;
name|lcp_close
argument_list|(
literal|0
argument_list|,
literal|"Link inactive"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TIMEOUT
argument_list|(
name|check_idle
argument_list|,
name|NULL
argument_list|,
name|idle_time_limit
operator|-
name|itime
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * connect_time_expired - log a message and close the connection.  */
end_comment

begin_function
specifier|static
name|void
name|connect_time_expired
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Connect time expired"
argument_list|)
expr_stmt|;
name|lcp_close
argument_list|(
literal|0
argument_list|,
literal|"Connect time expired"
argument_list|)
expr_stmt|;
comment|/* Close connection */
block|}
end_function

begin_comment
comment|/*  * auth_check_options - called to check authentication options.  */
end_comment

begin_function
name|void
name|auth_check_options
parameter_list|()
block|{
name|lcp_options
modifier|*
name|wo
init|=
operator|&
name|lcp_wantoptions
index|[
literal|0
index|]
decl_stmt|;
name|int
name|can_auth
decl_stmt|;
name|ipcp_options
modifier|*
name|ipwo
init|=
operator|&
name|ipcp_wantoptions
index|[
literal|0
index|]
decl_stmt|;
name|u_int32_t
name|remote
decl_stmt|;
comment|/* Default our_name to hostname, and user to our_name */
if|if
condition|(
name|our_name
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|usehostname
condition|)
name|strcpy
argument_list|(
name|our_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|user
argument_list|,
name|our_name
argument_list|)
expr_stmt|;
comment|/* If authentication is required, ask peer for CHAP or PAP. */
if|if
condition|(
name|auth_required
operator|&&
operator|!
name|wo
operator|->
name|neg_chap
operator|&&
operator|!
name|wo
operator|->
name|neg_upap
condition|)
block|{
name|wo
operator|->
name|neg_chap
operator|=
literal|1
expr_stmt|;
name|wo
operator|->
name|neg_upap
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * Check whether we have appropriate secrets to use      * to authenticate the peer.      */
name|can_auth
operator|=
name|wo
operator|->
name|neg_upap
operator|&&
operator|(
name|uselogin
operator|||
name|have_pap_secret
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|can_auth
operator|&&
name|wo
operator|->
name|neg_chap
condition|)
block|{
name|remote
operator|=
name|ipwo
operator|->
name|accept_remote
condition|?
literal|0
else|:
name|ipwo
operator|->
name|hisaddr
expr_stmt|;
name|can_auth
operator|=
name|have_chap_secret
argument_list|(
name|remote_name
argument_list|,
name|our_name
argument_list|,
name|remote
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auth_required
operator|&&
operator|!
name|can_auth
condition|)
block|{
name|option_error
argument_list|(
literal|"peer authentication required but no suitable secret(s) found\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|option_error
argument_list|(
literal|"for authenticating any peer to us (%s)\n"
argument_list|,
name|our_name
argument_list|)
expr_stmt|;
else|else
name|option_error
argument_list|(
literal|"for authenticating peer %s to us (%s)\n"
argument_list|,
name|remote_name
argument_list|,
name|our_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*      * Check whether the user tried to override certain values      * set by root.      */
if|if
condition|(
operator|!
name|auth_required
operator|&&
name|auth_req_info
operator|.
name|priv
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|default_device
operator|&&
name|devnam_info
operator|.
name|priv
operator|==
literal|0
condition|)
block|{
name|option_error
argument_list|(
literal|"can't override device name when noauth option used"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|connector
operator|!=
name|NULL
operator|&&
name|connector_info
operator|.
name|priv
operator|==
literal|0
operator|)
operator|||
operator|(
name|disconnector
operator|!=
name|NULL
operator|&&
name|disconnector_info
operator|.
name|priv
operator|==
literal|0
operator|)
operator|||
operator|(
name|welcomer
operator|!=
name|NULL
operator|&&
name|welcomer_info
operator|.
name|priv
operator|==
literal|0
operator|)
condition|)
block|{
name|option_error
argument_list|(
literal|"can't override connect, disconnect or welcome"
argument_list|)
expr_stmt|;
name|option_error
argument_list|(
literal|"option values when noauth option used"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * auth_reset - called when LCP is starting negotiations to recheck  * authentication options, i.e. whether we have appropriate secrets  * to use for authenticating ourselves and/or the peer.  */
end_comment

begin_function
name|void
name|auth_reset
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|ao
init|=
operator|&
name|lcp_allowoptions
index|[
literal|0
index|]
decl_stmt|;
name|ipcp_options
modifier|*
name|ipwo
init|=
operator|&
name|ipcp_wantoptions
index|[
literal|0
index|]
decl_stmt|;
name|u_int32_t
name|remote
decl_stmt|;
name|ao
operator|->
name|neg_upap
operator|=
operator|!
name|refuse_pap
operator|&&
operator|(
name|passwd
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|get_pap_passwd
argument_list|(
name|NULL
argument_list|)
operator|)
expr_stmt|;
name|ao
operator|->
name|neg_chap
operator|=
operator|!
name|refuse_chap
operator|&&
name|have_chap_secret
argument_list|(
name|user
argument_list|,
name|remote_name
argument_list|,
operator|(
name|u_int32_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|go
operator|->
name|neg_upap
operator|&&
operator|!
name|uselogin
operator|&&
operator|!
name|have_pap_secret
argument_list|()
condition|)
name|go
operator|->
name|neg_upap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|go
operator|->
name|neg_chap
condition|)
block|{
name|remote
operator|=
name|ipwo
operator|->
name|accept_remote
condition|?
literal|0
else|:
name|ipwo
operator|->
name|hisaddr
expr_stmt|;
if|if
condition|(
operator|!
name|have_chap_secret
argument_list|(
name|remote_name
argument_list|,
name|our_name
argument_list|,
name|remote
argument_list|)
condition|)
name|go
operator|->
name|neg_chap
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * check_passwd - Check the user name and passwd against the PAP secrets  * file.  If requested, also check against the system password database,  * and login the user if OK.  *  * returns:  *	UPAP_AUTHNAK: Authentication failed.  *	UPAP_AUTHACK: Authentication succeeded.  * In either case, msg points to an appropriate message.  */
end_comment

begin_function
name|int
name|check_passwd
parameter_list|(
name|unit
parameter_list|,
name|auser
parameter_list|,
name|userlen
parameter_list|,
name|apasswd
parameter_list|,
name|passwdlen
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|auser
decl_stmt|;
name|int
name|userlen
decl_stmt|;
name|char
modifier|*
name|apasswd
decl_stmt|;
name|int
name|passwdlen
decl_stmt|;
name|char
modifier|*
modifier|*
name|msg
decl_stmt|;
name|int
modifier|*
name|msglen
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
name|u_int32_t
name|remote
decl_stmt|;
name|ipcp_options
modifier|*
name|ipwo
init|=
operator|&
name|ipcp_wantoptions
index|[
name|unit
index|]
decl_stmt|;
name|char
name|passwd
index|[
literal|256
index|]
decl_stmt|,
name|user
index|[
literal|256
index|]
decl_stmt|;
name|char
name|secret
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
specifier|static
name|int
name|attempts
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/*      * Make copies of apasswd and auser, then null-terminate them.      */
name|len
operator|=
name|MIN
argument_list|(
name|passwdlen
argument_list|,
sizeof|sizeof
argument_list|(
name|passwd
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|apasswd
argument_list|,
name|passwd
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|passwd
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|userlen
argument_list|,
sizeof|sizeof
argument_list|(
name|user
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|auser
argument_list|,
name|user
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|user
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/*      * Open the file of pap secrets and scan for a suitable secret      * for authenticating this user.      */
name|filename
operator|=
name|_PATH_UPAPFILE
expr_stmt|;
name|addrs
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|UPAP_AUTHACK
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't open PAP password file %s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ret
operator|=
name|UPAP_AUTHNAK
expr_stmt|;
block|}
else|else
block|{
name|check_access
argument_list|(
name|f
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|remote
operator|=
name|ipwo
operator|->
name|accept_remote
condition|?
literal|0
else|:
name|ipwo
operator|->
name|hisaddr
expr_stmt|;
if|if
condition|(
name|scan_authfile
argument_list|(
name|f
argument_list|,
name|user
argument_list|,
name|our_name
argument_list|,
name|remote
argument_list|,
name|secret
argument_list|,
operator|&
name|addrs
argument_list|,
name|filename
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"no PAP secret found for %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|secret
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* password given in pap-secrets - must match */
if|if
condition|(
operator|(
name|cryptpap
operator|||
name|strcmp
argument_list|(
name|passwd
argument_list|,
name|secret
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|passwd
argument_list|,
name|secret
argument_list|)
argument_list|,
name|secret
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|UPAP_AUTHNAK
expr_stmt|;
name|warn
argument_list|(
literal|"PAP authentication failure for %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uselogin
operator|&&
name|ret
operator|==
name|UPAP_AUTHACK
condition|)
block|{
name|ret
operator|=
name|plogin
argument_list|(
name|user
argument_list|,
name|passwd
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|UPAP_AUTHNAK
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"PAP login failure for %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|UPAP_AUTHNAK
condition|)
block|{
if|if
condition|(
operator|*
name|msg
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
operator|*
name|msg
operator|=
literal|"Login incorrect"
expr_stmt|;
operator|*
name|msglen
operator|=
name|strlen
argument_list|(
operator|*
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * Frustrate passwd stealer programs. 	 * Allow 10 tries, but start backing off after 3 (stolen from login). 	 * On 10'th, drop the connection. 	 */
if|if
condition|(
name|attempts
operator|++
operator|>=
literal|10
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%d LOGIN FAILURES ON %s, %s"
argument_list|,
name|attempts
argument_list|,
name|devnam
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|attempts
operator|>
literal|3
condition|)
name|sleep
argument_list|(
call|(
name|u_int
call|)
argument_list|(
name|attempts
operator|-
literal|3
argument_list|)
operator|*
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrs
operator|!=
name|NULL
condition|)
name|free_wordlist
argument_list|(
name|addrs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attempts
operator|=
literal|0
expr_stmt|;
comment|/* Reset count */
if|if
condition|(
operator|*
name|msg
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
operator|*
name|msg
operator|=
literal|"Login ok"
expr_stmt|;
operator|*
name|msglen
operator|=
name|strlen
argument_list|(
operator|*
name|msg
argument_list|)
expr_stmt|;
name|set_allowed_addrs
argument_list|(
name|unit
argument_list|,
name|addrs
argument_list|)
expr_stmt|;
block|}
name|BZERO
argument_list|(
name|passwd
argument_list|,
sizeof|sizeof
argument_list|(
name|passwd
argument_list|)
argument_list|)
expr_stmt|;
name|BZERO
argument_list|(
name|secret
argument_list|,
sizeof|sizeof
argument_list|(
name|secret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Check if an "entry" is in the file "fname" - used by ppplogin.  * Taken from libexec/ftpd/ftpd.c  * Returns: 0 if not found, 1 if found, 2 if file can't be opened for reading.  */
end_comment

begin_function
specifier|static
name|int
name|checkfile
parameter_list|(
name|fname
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
literal|2
operator|)
return|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is needed for PAM.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PAM
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|PAM_username
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|PAM_password
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PAM_ESTABLISH_CRED
end_ifdef

begin_comment
comment|/* new PAM defines :(^ */
end_comment

begin_define
define|#
directive|define
name|MY_PAM_STRERROR
parameter_list|(
name|err_code
parameter_list|)
value|(char *) pam_strerror(pamh,err_code)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MY_PAM_STRERROR
parameter_list|(
name|err_code
parameter_list|)
value|(char *) pam_strerror(err_code)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|pam_conv
parameter_list|(
name|int
name|num_msg
parameter_list|,
specifier|const
name|struct
name|pam_message
modifier|*
modifier|*
name|msg
parameter_list|,
name|struct
name|pam_response
modifier|*
modifier|*
name|resp
parameter_list|,
name|void
modifier|*
name|appdata_ptr
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|,
name|replies
init|=
literal|0
decl_stmt|;
name|struct
name|pam_response
modifier|*
name|reply
init|=
name|NULL
decl_stmt|;
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|num_msg
condition|;
name|count
operator|++
control|)
block|{
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pam_response
argument_list|)
expr_stmt|;
name|reply
operator|=
name|realloc
argument_list|(
name|reply
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* ANSI: is malloc() if reply==NULL */
if|if
condition|(
operator|!
name|reply
condition|)
return|return
name|PAM_CONV_ERR
return|;
switch|switch
condition|(
name|msg
index|[
name|count
index|]
operator|->
name|msg_style
condition|)
block|{
case|case
name|PAM_PROMPT_ECHO_ON
case|:
name|reply
index|[
name|replies
index|]
operator|.
name|resp_retcode
operator|=
name|PAM_SUCCESS
expr_stmt|;
name|reply
index|[
name|replies
operator|++
index|]
operator|.
name|resp
operator|=
name|strdup
argument_list|(
name|PAM_username
argument_list|)
expr_stmt|;
comment|/* never NULL */
break|break;
case|case
name|PAM_PROMPT_ECHO_OFF
case|:
name|reply
index|[
name|replies
index|]
operator|.
name|resp_retcode
operator|=
name|PAM_SUCCESS
expr_stmt|;
name|reply
index|[
name|replies
operator|++
index|]
operator|.
name|resp
operator|=
name|strdup
argument_list|(
name|PAM_password
argument_list|)
expr_stmt|;
comment|/* never NULL */
break|break;
case|case
name|PAM_TEXT_INFO
case|:
name|reply
index|[
name|replies
index|]
operator|.
name|resp_retcode
operator|=
name|PAM_SUCCESS
expr_stmt|;
name|reply
index|[
name|replies
operator|++
index|]
operator|.
name|resp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|PAM_ERROR_MSG
case|:
default|default:
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|PAM_CONV_ERR
return|;
block|}
block|}
if|if
condition|(
name|resp
condition|)
operator|*
name|resp
operator|=
name|reply
expr_stmt|;
else|else
name|free
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|PAM_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * plogin - Check the user name and password against the system  * password database, and login the user if OK.  *  * returns:  *	UPAP_AUTHNAK: Login failed.  *	UPAP_AUTHACK: Login succeeded.  * In either case, msg points to an appropriate message.  *  * UPAP_AUTHACK should only be returned *after* wtmp and utmp are updated.  */
end_comment

begin_function
specifier|static
name|int
name|plogin
parameter_list|(
name|user
parameter_list|,
name|passwd
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|passwd
decl_stmt|;
name|char
modifier|*
modifier|*
name|msg
decl_stmt|;
name|int
modifier|*
name|msglen
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|USE_PAM
name|struct
name|pam_conv
name|pam_conversation
decl_stmt|;
name|pam_handle_t
modifier|*
name|pamh
decl_stmt|;
name|int
name|pam_error
decl_stmt|;
comment|/*  * Fill the pam_conversion structure  */
name|memset
argument_list|(
operator|&
name|pam_conversation
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pam_conv
argument_list|)
argument_list|)
expr_stmt|;
name|pam_conversation
operator|.
name|conv
operator|=
operator|&
name|pam_conv
expr_stmt|;
name|pam_error
operator|=
name|pam_start
argument_list|(
literal|"ppp"
argument_list|,
name|user
argument_list|,
operator|&
name|pam_conversation
argument_list|,
operator|&
name|pamh
argument_list|)
expr_stmt|;
if|if
condition|(
name|pam_error
operator|!=
name|PAM_SUCCESS
condition|)
block|{
operator|*
name|msg
operator|=
name|MY_PAM_STRERROR
argument_list|(
name|pam_error
argument_list|)
expr_stmt|;
return|return
name|UPAP_AUTHNAK
return|;
block|}
comment|/*  * Define the fields for the credintial validation  */
operator|(
name|void
operator|)
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_TTY
argument_list|,
name|devnam
argument_list|)
expr_stmt|;
name|PAM_username
operator|=
name|user
expr_stmt|;
name|PAM_password
operator|=
name|passwd
expr_stmt|;
comment|/*  * Validate the user  */
name|pam_error
operator|=
name|pam_authenticate
argument_list|(
name|pamh
argument_list|,
name|PAM_SILENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pam_error
operator|==
name|PAM_SUCCESS
condition|)
block|{
name|pam_error
operator|=
name|pam_acct_mgmt
argument_list|(
name|pamh
argument_list|,
name|PAM_SILENT
argument_list|)
expr_stmt|;
comment|/* start a session for this user. Session closed when link ends. */
if|if
condition|(
name|pam_error
operator|==
name|PAM_SUCCESS
condition|)
operator|(
name|void
operator|)
name|pam_open_session
argument_list|(
name|pamh
argument_list|,
name|PAM_SILENT
argument_list|)
expr_stmt|;
block|}
operator|*
name|msg
operator|=
name|MY_PAM_STRERROR
argument_list|(
name|pam_error
argument_list|)
expr_stmt|;
name|PAM_username
operator|=
name|PAM_password
operator|=
literal|""
expr_stmt|;
comment|/*  * Clean up the mess  */
operator|(
name|void
operator|)
name|pam_end
argument_list|(
name|pamh
argument_list|,
name|pam_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|pam_error
operator|!=
name|PAM_SUCCESS
condition|)
return|return
name|UPAP_AUTHNAK
return|;
comment|/*  * Use the non-PAM methods directly  */
else|#
directive|else
comment|/* #ifdef USE_PAM */
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|utmp
name|utmp
decl_stmt|;
name|struct
name|timeval
name|tp
decl_stmt|;
name|char
modifier|*
name|tty
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_SHADOW
name|struct
name|spwd
modifier|*
name|spwd
decl_stmt|;
name|struct
name|spwd
modifier|*
name|getspnam
parameter_list|()
function_decl|;
endif|#
directive|endif
name|pw
operator|=
name|getpwnam
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
comment|/*  * Check that the user is not listed in /etc/ppp/ppp.deny  * and that the user's shell is listed in /etc/ppp/ppp.shells  * if /etc/ppp/ppp.shells exists.  */
if|if
condition|(
name|checkfile
argument_list|(
name|_PATH_PPPDENY
argument_list|,
name|user
argument_list|)
operator|==
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"upap user %s: login denied in %s"
argument_list|,
name|user
argument_list|,
name|_PATH_PPPDENY
argument_list|)
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
if|if
condition|(
name|checkfile
argument_list|(
name|_PATH_PPPSHELLS
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"upap user %s: shell %s not in %s"
argument_list|,
name|user
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|,
name|_PATH_PPPSHELLS
argument_list|)
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAS_SHADOW
name|spwd
operator|=
name|getspnam
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|endspent
argument_list|()
expr_stmt|;
if|if
condition|(
name|spwd
condition|)
block|{
comment|/* check the age of the password entry */
name|long
name|now
init|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|/
literal|86400L
decl_stmt|;
if|if
condition|(
operator|(
name|spwd
operator|->
name|sp_expire
operator|>
literal|0
operator|&&
name|now
operator|>=
name|spwd
operator|->
name|sp_expire
operator|)
operator|||
operator|(
operator|(
name|spwd
operator|->
name|sp_max
operator|>=
literal|0
operator|&&
name|spwd
operator|->
name|sp_max
operator|<
literal|10000
operator|)
operator|&&
name|spwd
operator|->
name|sp_lstchg
operator|>=
literal|0
operator|&&
name|now
operator|>=
name|spwd
operator|->
name|sp_lstchg
operator|+
name|spwd
operator|->
name|sp_max
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Password for %s has expired"
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
name|pw
operator|->
name|pw_passwd
operator|=
name|spwd
operator|->
name|sp_pwdp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * If no passwd, don't let them login.      */
if|if
condition|(
name|pw
operator|->
name|pw_passwd
operator|==
name|NULL
operator|||
operator|*
name|pw
operator|->
name|pw_passwd
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|passwd
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
if|if
condition|(
name|pw
operator|->
name|pw_expire
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|.
name|tv_sec
operator|>=
name|pw
operator|->
name|pw_expire
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"pap user %s account expired"
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
block|}
comment|/* These functions are not enabled for PAM. The reason for this is that */
comment|/* there is not necessarily a "passwd" entry for this user. That is     */
comment|/* real purpose of 'PAM' -- to virtualize the account data from the     */
comment|/* application. If you want to do the same thing, write the entry in    */
comment|/* the 'session' hook.                                                  */
comment|/* Log in wtmp and utmp using login() */
name|tty
operator|=
name|devnam
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tty
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
name|_PATH_DEV
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|tty
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|logout
argument_list|(
name|tty
argument_list|)
condition|)
comment|/* Already entered (by login?) */
name|logwtmp
argument_list|(
name|tty
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_PATH_LASTLOG
argument_list|)
block|{
name|struct
name|lastlog
name|ll
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|_PATH_LASTLOG
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|pw
operator|->
name|pw_uid
operator|*
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|ll
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|)
expr_stmt|;
name|ll
operator|.
name|ll_time
operator|=
name|_time_to_time32
argument_list|(
name|time
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|,
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
operator|.
name|ll_line
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ll
argument_list|,
sizeof|sizeof
argument_list|(
name|ll
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|utmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
name|utmp
operator|.
name|ut_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|,
name|user
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|,
literal|":PPP"
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_line
argument_list|,
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|login
argument_list|(
operator|&
name|utmp
argument_list|)
expr_stmt|;
comment|/* This logs us in wtmp too */
endif|#
directive|endif
comment|/* #ifdef USE_PAM */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"user %s logged in"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|logged_in
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHACK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * plogout - Logout the user.  */
end_comment

begin_function
specifier|static
name|void
name|plogout
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|USE_PAM
name|struct
name|pam_conv
name|pam_conversation
decl_stmt|;
name|pam_handle_t
modifier|*
name|pamh
decl_stmt|;
name|int
name|pam_error
decl_stmt|;
comment|/*  * Fill the pam_conversion structure. The PAM specification states that the  * session must be able to be closed by a totally different handle from which  * it was created. Hold the PAM group to their own specification!  */
name|memset
argument_list|(
operator|&
name|pam_conversation
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pam_conv
argument_list|)
argument_list|)
expr_stmt|;
name|pam_conversation
operator|.
name|conv
operator|=
operator|&
name|pam_conv
expr_stmt|;
name|pam_error
operator|=
name|pam_start
argument_list|(
literal|"ppp"
argument_list|,
name|user
argument_list|,
operator|&
name|pam_conversation
argument_list|,
operator|&
name|pamh
argument_list|)
expr_stmt|;
if|if
condition|(
name|pam_error
operator|==
name|PAM_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|pam_set_item
argument_list|(
name|pamh
argument_list|,
name|PAM_TTY
argument_list|,
name|devnam
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pam_close_session
argument_list|(
name|pamh
argument_list|,
name|PAM_SILENT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pam_end
argument_list|(
name|pamh
argument_list|,
name|PAM_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|char
modifier|*
name|tty
decl_stmt|;
name|tty
operator|=
name|devnam
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tty
argument_list|,
name|_PATH_DEV
argument_list|,
sizeof|sizeof
name|_PATH_DEV
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|tty
operator|+=
literal|5
expr_stmt|;
name|logwtmp
argument_list|(
name|tty
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Wipe out wtmp logout entry */
name|logout
argument_list|(
name|tty
argument_list|)
expr_stmt|;
comment|/* Wipe out utmp */
endif|#
directive|endif
name|logged_in
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * null_login - Check if a username of "" and a password of "" are  * acceptable, and iff so, set the list of acceptable IP addresses  * and return 1.  */
end_comment

begin_function
specifier|static
name|int
name|null_login
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
name|char
name|secret
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
comment|/*      * Open the file of pap secrets and scan for a suitable secret.      * We don't accept a wildcard client.      */
name|filename
operator|=
name|_PATH_UPAPFILE
expr_stmt|;
name|addrs
operator|=
name|NULL
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|check_access
argument_list|(
name|f
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|i
operator|=
name|scan_authfile
argument_list|(
name|f
argument_list|,
literal|""
argument_list|,
name|our_name
argument_list|,
operator|(
name|u_int32_t
operator|)
literal|0
argument_list|,
name|secret
argument_list|,
operator|&
name|addrs
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i
operator|>=
literal|0
operator|&&
operator|(
name|i
operator|&
name|NONWILD_CLIENT
operator|)
operator|!=
literal|0
operator|&&
name|secret
index|[
literal|0
index|]
operator|==
literal|0
expr_stmt|;
name|BZERO
argument_list|(
name|secret
argument_list|,
sizeof|sizeof
argument_list|(
name|secret
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|set_allowed_addrs
argument_list|(
name|unit
argument_list|,
name|addrs
argument_list|)
expr_stmt|;
else|else
name|free_wordlist
argument_list|(
name|addrs
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * get_pap_passwd - get a password for authenticating ourselves with  * our peer using PAP.  Returns 1 on success, 0 if no suitable password  * could be found.  */
end_comment

begin_function
specifier|static
name|int
name|get_pap_passwd
parameter_list|(
name|passwd
parameter_list|)
name|char
modifier|*
name|passwd
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
name|char
name|secret
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
name|filename
operator|=
name|_PATH_UPAPFILE
expr_stmt|;
name|addrs
operator|=
name|NULL
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|check_access
argument_list|(
name|f
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ret
operator|=
name|scan_authfile
argument_list|(
name|f
argument_list|,
name|user
argument_list|,
name|remote_name
index|[
literal|0
index|]
condition|?
name|remote_name
else|:
name|NULL
argument_list|,
operator|(
name|u_int32_t
operator|)
literal|0
argument_list|,
name|secret
argument_list|,
name|NULL
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|passwd
operator|!=
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|passwd
argument_list|,
name|secret
argument_list|,
name|MAXSECRETLEN
argument_list|)
expr_stmt|;
name|passwd
index|[
name|MAXSECRETLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|BZERO
argument_list|(
name|secret
argument_list|,
sizeof|sizeof
argument_list|(
name|secret
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * have_pap_secret - check whether we have a PAP file with any  * secrets that we could possibly use for authenticating the peer.  */
end_comment

begin_function
specifier|static
name|int
name|have_pap_secret
parameter_list|()
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|ipcp_options
modifier|*
name|ipwo
init|=
operator|&
name|ipcp_wantoptions
index|[
literal|0
index|]
decl_stmt|;
name|u_int32_t
name|remote
decl_stmt|;
name|filename
operator|=
name|_PATH_UPAPFILE
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|remote
operator|=
name|ipwo
operator|->
name|accept_remote
condition|?
literal|0
else|:
name|ipwo
operator|->
name|hisaddr
expr_stmt|;
name|ret
operator|=
name|scan_authfile
argument_list|(
name|f
argument_list|,
name|NULL
argument_list|,
name|our_name
argument_list|,
name|remote
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * have_chap_secret - check whether we have a CHAP file with a  * secret that we could possibly use for authenticating `client'  * on `server'.  Either can be the null string, meaning we don't  * know the identity yet.  */
end_comment

begin_function
specifier|static
name|int
name|have_chap_secret
parameter_list|(
name|client
parameter_list|,
name|server
parameter_list|,
name|remote
parameter_list|)
name|char
modifier|*
name|client
decl_stmt|;
name|char
modifier|*
name|server
decl_stmt|;
name|u_int32_t
name|remote
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|filename
operator|=
name|_PATH_CHAPFILE
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|client
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|client
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|server
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|server
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|scan_authfile
argument_list|(
name|f
argument_list|,
name|client
argument_list|,
name|server
argument_list|,
name|remote
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * get_secret - open the CHAP secret file and return the secret  * for authenticating the given client on the given server.  * (We could be either client or server).  */
end_comment

begin_function
name|int
name|get_secret
parameter_list|(
name|unit
parameter_list|,
name|client
parameter_list|,
name|server
parameter_list|,
name|secret
parameter_list|,
name|secret_len
parameter_list|,
name|save_addrs
parameter_list|)
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|client
decl_stmt|;
name|char
modifier|*
name|server
decl_stmt|;
name|char
modifier|*
name|secret
decl_stmt|;
name|int
modifier|*
name|secret_len
decl_stmt|;
name|int
name|save_addrs
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
name|char
name|secbuf
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
name|filename
operator|=
name|_PATH_CHAPFILE
expr_stmt|;
name|addrs
operator|=
name|NULL
expr_stmt|;
name|secbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't open chap secret file %s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|check_access
argument_list|(
name|f
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ret
operator|=
name|scan_authfile
argument_list|(
name|f
argument_list|,
name|client
argument_list|,
name|server
argument_list|,
operator|(
name|u_int32_t
operator|)
literal|0
argument_list|,
name|secbuf
argument_list|,
operator|&
name|addrs
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|save_addrs
condition|)
name|set_allowed_addrs
argument_list|(
name|unit
argument_list|,
name|addrs
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|secbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MAXSECRETLEN
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Secret for %s on %s is too long"
argument_list|,
name|client
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|len
operator|=
name|MAXSECRETLEN
expr_stmt|;
block|}
name|BCOPY
argument_list|(
name|secbuf
argument_list|,
name|secret
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|BZERO
argument_list|(
name|secbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|secbuf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|secret_len
operator|=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * set_allowed_addrs() - set the list of allowed addresses.  */
end_comment

begin_function
specifier|static
name|void
name|set_allowed_addrs
parameter_list|(
name|unit
parameter_list|,
name|addrs
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
block|{
if|if
condition|(
name|addresses
index|[
name|unit
index|]
operator|!=
name|NULL
condition|)
name|free_wordlist
argument_list|(
name|addresses
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|addresses
index|[
name|unit
index|]
operator|=
name|addrs
expr_stmt|;
comment|/*      * If there's only one authorized address we might as well      * ask our peer for that one right away      */
if|if
condition|(
name|addrs
operator|!=
name|NULL
operator|&&
name|addrs
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|addrs
operator|->
name|word
decl_stmt|;
name|struct
name|ipcp_options
modifier|*
name|wo
init|=
operator|&
name|ipcp_wantoptions
index|[
name|unit
index|]
decl_stmt|;
name|u_int32_t
name|a
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'!'
operator|&&
operator|*
name|p
operator|!=
literal|'-'
operator|&&
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
operator|&&
name|hp
operator|->
name|h_addrtype
operator|==
name|AF_INET
condition|)
name|a
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|hp
operator|->
name|h_addr
expr_stmt|;
else|else
name|a
operator|=
name|inet_addr
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|!=
operator|(
name|u_int32_t
operator|)
operator|-
literal|1
condition|)
name|wo
operator|->
name|hisaddr
operator|=
name|a
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|auth_set_ip_addr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
if|if
condition|(
name|non_wildclient
operator|&&
operator|(
name|addrs
operator|=
name|addresses
index|[
name|unit
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|addrs
operator|!=
name|NULL
condition|;
name|addrs
operator|=
name|addrs
operator|->
name|next
control|)
block|{
comment|/* Look for address overrides, and set them if we have any */
if|if
condition|(
name|strchr
argument_list|(
name|addrs
operator|->
name|word
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|setipaddr
argument_list|(
name|addrs
operator|->
name|word
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * auth_ip_addr - check whether the peer is authorized to use  * a given IP address.  Returns 1 if authorized, 0 otherwise.  */
end_comment

begin_function
name|int
name|auth_ip_addr
parameter_list|(
name|unit
parameter_list|,
name|addr
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
block|{
return|return
name|ip_addr_check
argument_list|(
name|addr
argument_list|,
name|addresses
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ip_addr_check
parameter_list|(
name|addr
parameter_list|,
name|addrs
parameter_list|)
name|u_int32_t
name|addr
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|u_int32_t
name|a
decl_stmt|,
name|mask
decl_stmt|,
name|ah
decl_stmt|;
name|int
name|accept
decl_stmt|;
name|char
modifier|*
name|ptr_word
decl_stmt|,
modifier|*
name|ptr_mask
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|netent
modifier|*
name|np
decl_stmt|;
comment|/* don't allow loopback or multicast address */
if|if
condition|(
name|bad_ip_adrs
argument_list|(
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addrs
operator|==
name|NULL
condition|)
return|return
operator|!
name|auth_required
return|;
comment|/* no addresses authorized */
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|addrs
operator|!=
name|NULL
condition|;
name|addrs
operator|=
name|addrs
operator|->
name|next
control|)
block|{
name|y
operator|++
expr_stmt|;
comment|/* "-" means no addresses authorized, "*" means any address allowed */
name|ptr_word
operator|=
name|addrs
operator|->
name|word
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ptr_word
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|ptr_word
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* 	 * A colon in the string means that we wish to force a specific 	 * local:remote address, but we ignore these for now. 	 */
if|if
condition|(
name|strchr
argument_list|(
name|addrs
operator|->
name|word
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
name|x
operator|++
expr_stmt|;
else|else
block|{
name|accept
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|ptr_word
operator|==
literal|'!'
condition|)
block|{
name|accept
operator|=
literal|0
expr_stmt|;
operator|++
name|ptr_word
expr_stmt|;
block|}
name|mask
operator|=
operator|~
operator|(
name|u_int32_t
operator|)
literal|0
expr_stmt|;
name|ptr_mask
operator|=
name|strchr
argument_list|(
name|ptr_word
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_mask
operator|!=
name|NULL
condition|)
block|{
name|int
name|bit_count
decl_stmt|;
name|bit_count
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|ptr_mask
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit_count
operator|<=
literal|0
operator|||
name|bit_count
operator|>
literal|32
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"invalid address length %s in auth. address list"
argument_list|,
name|ptr_mask
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|ptr_mask
operator|=
literal|'\0'
expr_stmt|;
name|mask
operator|<<=
literal|32
operator|-
name|bit_count
expr_stmt|;
block|}
name|hp
operator|=
name|gethostbyname
argument_list|(
name|ptr_word
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
operator|&&
name|hp
operator|->
name|h_addrtype
operator|==
name|AF_INET
condition|)
block|{
name|a
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|hp
operator|->
name|h_addr
expr_stmt|;
block|}
else|else
block|{
name|np
operator|=
name|getnetbyname
argument_list|(
name|ptr_word
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
operator|&&
name|np
operator|->
name|n_addrtype
operator|==
name|AF_INET
condition|)
block|{
name|a
operator|=
name|htonl
argument_list|(
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|np
operator|->
name|n_net
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr_mask
operator|==
name|NULL
condition|)
block|{
comment|/* calculate appropriate mask for net */
name|ah
operator|=
name|ntohl
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_CLASSA
argument_list|(
name|ah
argument_list|)
condition|)
name|mask
operator|=
name|IN_CLASSA_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSB
argument_list|(
name|ah
argument_list|)
condition|)
name|mask
operator|=
name|IN_CLASSB_NET
expr_stmt|;
elseif|else
if|if
condition|(
name|IN_CLASSC
argument_list|(
name|ah
argument_list|)
condition|)
name|mask
operator|=
name|IN_CLASSC_NET
expr_stmt|;
block|}
block|}
else|else
block|{
name|a
operator|=
name|inet_addr
argument_list|(
name|ptr_word
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ptr_mask
operator|!=
name|NULL
condition|)
operator|*
name|ptr_mask
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|a
operator|==
operator|(
name|u_int32_t
operator|)
operator|-
literal|1L
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unknown host %s in auth. address list"
argument_list|,
name|addrs
operator|->
name|word
argument_list|)
expr_stmt|;
elseif|else
comment|/* Here a and addr are in network byte order, 	       and mask is in host order. */
if|if
condition|(
operator|(
operator|(
name|addr
operator|^
name|a
operator|)
operator|&
name|htonl
argument_list|(
name|mask
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
name|accept
return|;
block|}
comment|/* else */
block|}
return|return
name|x
operator|==
name|y
return|;
comment|/* not in list => can't have it */
block|}
end_function

begin_comment
comment|/*  * bad_ip_adrs - return 1 if the IP address is one we don't want  * to use, such as an address in the loopback net or a multicast address.  * addr is in network byte order.  */
end_comment

begin_function
name|int
name|bad_ip_adrs
parameter_list|(
name|addr
parameter_list|)
name|u_int32_t
name|addr
decl_stmt|;
block|{
name|addr
operator|=
name|ntohl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|>>
name|IN_CLASSA_NSHIFT
operator|)
operator|==
name|IN_LOOPBACKNET
operator|||
name|IN_MULTICAST
argument_list|(
name|addr
argument_list|)
operator|||
name|IN_BADCLASS
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * check_access - complain if a secret file has too-liberal permissions.  */
end_comment

begin_function
name|void
name|check_access
parameter_list|(
name|f
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"cannot stat secret file %s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
operator|(
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Warning - secret file %s has world and/or group access"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * scan_authfile - Scan an authorization file for a secret suitable  * for authenticating `client' on `server'.  The return value is -1  * if no secret is found, otherwise>= 0.  The return value has  * NONWILD_CLIENT set if the secret didn't have "*" for the client, and  * NONWILD_SERVER set if the secret didn't have "*" for the server.  * Any following words on the line (i.e. address authorization  * info) are placed in a wordlist and returned in *addrs.    */
end_comment

begin_function
specifier|static
name|int
name|scan_authfile
parameter_list|(
name|f
parameter_list|,
name|client
parameter_list|,
name|server
parameter_list|,
name|ipaddr
parameter_list|,
name|secret
parameter_list|,
name|addrs
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|client
decl_stmt|;
name|char
modifier|*
name|server
decl_stmt|;
name|u_int32_t
name|ipaddr
decl_stmt|;
name|char
modifier|*
name|secret
decl_stmt|;
name|struct
name|wordlist
modifier|*
modifier|*
name|addrs
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|newline
decl_stmt|,
name|xxx
decl_stmt|;
name|int
name|got_flag
decl_stmt|,
name|best_flag
decl_stmt|;
name|FILE
modifier|*
name|sf
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|ap
decl_stmt|,
modifier|*
name|addr_list
decl_stmt|,
modifier|*
name|alist
decl_stmt|,
modifier|*
name|alast
decl_stmt|;
name|char
name|word
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
name|char
name|atfile
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
name|char
name|lsecret
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
if|if
condition|(
name|addrs
operator|!=
name|NULL
condition|)
operator|*
name|addrs
operator|=
name|NULL
expr_stmt|;
name|addr_list
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|f
argument_list|,
name|word
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* file is empty??? */
name|newline
operator|=
literal|1
expr_stmt|;
name|best_flag
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * Skip until we find a word at the start of a line. 	 */
while|while
condition|(
operator|!
name|newline
operator|&&
name|getword
argument_list|(
name|f
argument_list|,
name|word
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|newline
condition|)
break|break;
comment|/* got to end of file */
comment|/* 	 * Got a client - check if it's a match or a wildcard. 	 */
name|got_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|client
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|word
argument_list|,
name|client
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|ISWILD
argument_list|(
name|word
argument_list|)
condition|)
block|{
name|newline
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|ISWILD
argument_list|(
name|word
argument_list|)
condition|)
name|got_flag
operator|=
name|NONWILD_CLIENT
expr_stmt|;
comment|/* 	 * Now get a server and check if it matches. 	 */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|f
argument_list|,
name|word
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
break|break;
if|if
condition|(
name|newline
condition|)
continue|continue;
if|if
condition|(
name|server
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|word
argument_list|,
name|server
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|ISWILD
argument_list|(
name|word
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ISWILD
argument_list|(
name|word
argument_list|)
condition|)
name|got_flag
operator||=
name|NONWILD_SERVER
expr_stmt|;
comment|/* 	 * Got some sort of a match - see if it's better than what 	 * we have already. 	 */
if|if
condition|(
name|got_flag
operator|<=
name|best_flag
condition|)
continue|continue;
comment|/* 	 * Get the secret. 	 */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|f
argument_list|,
name|word
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
break|break;
if|if
condition|(
name|newline
condition|)
continue|continue;
comment|/* 	 * Special syntax: @filename means read secret from file. 	 */
if|if
condition|(
name|word
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|strcpy
argument_list|(
name|atfile
argument_list|,
name|word
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sf
operator|=
name|fopen
argument_list|(
name|atfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"can't open indirect secret file %s"
argument_list|,
name|atfile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|check_access
argument_list|(
name|sf
argument_list|,
name|atfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|sf
argument_list|,
name|word
argument_list|,
operator|&
name|xxx
argument_list|,
name|atfile
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"no secret in indirect secret file %s"
argument_list|,
name|atfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|sf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fclose
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secret
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|lsecret
argument_list|,
name|word
argument_list|)
expr_stmt|;
comment|/* 	 * Now read address authorization info and make a wordlist. 	 */
name|alist
operator|=
name|alast
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|getword
argument_list|(
name|f
argument_list|,
name|word
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
operator|||
name|newline
condition|)
break|break;
name|ap
operator|=
operator|(
expr|struct
name|wordlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wordlist
argument_list|)
operator|+
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
name|novm
argument_list|(
literal|"authorized addresses"
argument_list|)
expr_stmt|;
name|ap
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|ap
operator|->
name|word
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|alist
operator|==
name|NULL
condition|)
name|alist
operator|=
name|ap
expr_stmt|;
else|else
name|alast
operator|->
name|next
operator|=
name|ap
expr_stmt|;
name|alast
operator|=
name|ap
expr_stmt|;
block|}
comment|/* 	 * Check if the given IP address is allowed by the wordlist. 	 */
if|if
condition|(
name|ipaddr
operator|!=
literal|0
operator|&&
operator|!
name|ip_addr_check
argument_list|(
name|ipaddr
argument_list|,
name|alist
argument_list|)
condition|)
block|{
name|free_wordlist
argument_list|(
name|alist
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 	 * This is the best so far; remember it. 	 */
name|best_flag
operator|=
name|got_flag
expr_stmt|;
if|if
condition|(
name|addr_list
condition|)
name|free_wordlist
argument_list|(
name|addr_list
argument_list|)
expr_stmt|;
name|addr_list
operator|=
name|alist
expr_stmt|;
if|if
condition|(
name|secret
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|secret
argument_list|,
name|lsecret
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newline
condition|)
break|break;
block|}
if|if
condition|(
name|addrs
operator|!=
name|NULL
condition|)
operator|*
name|addrs
operator|=
name|addr_list
expr_stmt|;
elseif|else
if|if
condition|(
name|addr_list
operator|!=
name|NULL
condition|)
name|free_wordlist
argument_list|(
name|addr_list
argument_list|)
expr_stmt|;
name|non_wildclient
operator|=
operator|(
name|best_flag
operator|&
name|NONWILD_CLIENT
operator|)
operator|&&
name|client
operator|!=
name|NULL
operator|&&
operator|*
name|client
operator|!=
literal|'\0'
expr_stmt|;
return|return
name|best_flag
return|;
block|}
end_function

begin_comment
comment|/*  * free_wordlist - release memory allocated for a wordlist.  */
end_comment

begin_function
specifier|static
name|void
name|free_wordlist
parameter_list|(
name|wp
parameter_list|)
name|struct
name|wordlist
modifier|*
name|wp
decl_stmt|;
block|{
name|struct
name|wordlist
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|wp
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|wp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|wp
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * auth_script - execute a script with arguments  * interface-name peer-name real-user tty speed  */
end_comment

begin_function
specifier|static
name|void
name|auth_script
parameter_list|(
name|script
parameter_list|)
name|char
modifier|*
name|script
decl_stmt|;
block|{
name|char
name|strspeed
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|char
name|struid
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|user_name
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|7
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|pw
operator|->
name|pw_name
operator|!=
name|NULL
condition|)
name|user_name
operator|=
name|pw
operator|->
name|pw_name
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|struid
argument_list|,
literal|"%d"
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|user_name
operator|=
name|struid
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|strspeed
argument_list|,
literal|"%d"
argument_list|,
name|baud_rate
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|script
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|ifname
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|peer_authname
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|=
name|user_name
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|=
name|devnam
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|=
name|strspeed
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
name|run_program
argument_list|(
name|script
argument_list|,
name|argv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

