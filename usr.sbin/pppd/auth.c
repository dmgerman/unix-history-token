begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * auth.c - PPP authentication and phase control.  *  * Copyright (c) 1993 The Australian National University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the Australian National University.  The name of the University  * may not be used to endorse or promote products derived from this  * software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: auth.c,v 1.15 1997/04/16 02:07:06 danny Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_SHADOW
end_ifdef

begin_include
include|#
directive|include
file|<shadow.h>
end_include

begin_include
include|#
directive|include
file|<shadow/pwauth.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PW_PPP
end_ifndef

begin_define
define|#
directive|define
name|PW_PPP
value|PW_LOGIN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pppd.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"upap.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"ccp.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sun
argument_list|)
operator|&&
name|defined
argument_list|(
name|sparc
argument_list|)
end_if

begin_include
include|#
directive|include
file|<alloca.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*sparc*/
end_comment

begin_comment
comment|/* Used for storing a sequence of words.  Usually malloced. */
end_comment

begin_struct
struct|struct
name|wordlist
block|{
name|struct
name|wordlist
modifier|*
name|next
decl_stmt|;
name|char
name|word
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Bits in scan_authfile return value */
end_comment

begin_define
define|#
directive|define
name|NONWILD_SERVER
value|1
end_define

begin_define
define|#
directive|define
name|NONWILD_CLIENT
value|2
end_define

begin_define
define|#
directive|define
name|ISWILD
parameter_list|(
name|word
parameter_list|)
value|(word[0] == '*'&& word[1] == 0)
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_comment
comment|/* Records which authentication operations haven't completed yet. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|auth_pending
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|logged_in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|non_wildclient
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not wild nor blank */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|wordlist
modifier|*
name|addresses
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bits in auth_pending[] */
end_comment

begin_define
define|#
directive|define
name|UPAP_WITHPEER
value|1
end_define

begin_define
define|#
directive|define
name|UPAP_PEER
value|2
end_define

begin_define
define|#
directive|define
name|CHAP_WITHPEER
value|4
end_define

begin_define
define|#
directive|define
name|CHAP_PEER
value|8
end_define

begin_comment
comment|/* Prototypes */
end_comment

begin_decl_stmt
name|void
name|check_access
name|__P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|network_phase
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ppplogin
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppplogout
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|null_login
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_upap_passwd
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_upap_secret
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_chap_secret
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scan_authfile
name|__P
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|wordlist
operator|*
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_wordlist
name|__P
argument_list|(
operator|(
expr|struct
name|wordlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|auth_set_ip_addr
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * An Open on LCP has requested a change from Dead to Establish phase.  * Do what's necessary to bring the physical layer up.  */
end_comment

begin_function
name|void
name|link_required
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/*  * LCP has terminated the link; go to the Dead phase and take the  * physical layer down.  */
end_comment

begin_function
name|void
name|link_terminated
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|extern
name|time_t
name|etime
decl_stmt|,
name|stime
decl_stmt|;
specifier|extern
name|int
name|minutes
decl_stmt|;
if|if
condition|(
name|phase
operator|==
name|PHASE_DEAD
condition|)
return|return;
if|if
condition|(
name|logged_in
condition|)
name|ppplogout
argument_list|()
expr_stmt|;
name|phase
operator|=
name|PHASE_DEAD
expr_stmt|;
name|etime
operator|=
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|minutes
operator|=
operator|(
name|etime
operator|-
name|stime
operator|)
operator|/
literal|60
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"Connection terminated, connected for %d minutes\n"
argument_list|,
name|minutes
operator|>
literal|1
condition|?
name|minutes
else|:
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * LCP has gone down; it will either die or try to re-establish.  */
end_comment

begin_function
name|void
name|link_down
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|ipcp_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ccp_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|phase
operator|=
name|PHASE_TERMINATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The link is established.  * Proceed to the Dead, Authenticate or Network phase as appropriate.  */
end_comment

begin_function
name|void
name|link_established
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|auth
decl_stmt|;
name|lcp_options
modifier|*
name|wo
init|=
operator|&
name|lcp_wantoptions
index|[
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|go
init|=
operator|&
name|lcp_gotoptions
index|[
name|unit
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|ho
init|=
operator|&
name|lcp_hisoptions
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|auth_required
operator|&&
operator|!
operator|(
name|go
operator|->
name|neg_chap
operator|||
name|go
operator|->
name|neg_upap
operator|)
condition|)
block|{
comment|/* 	 * We wanted the peer to authenticate itself, and it refused: 	 * treat it as though it authenticated with PAP using a username 	 * of "" and a password of "".  If that's not OK, boot it out. 	 */
if|if
condition|(
operator|!
name|wo
operator|->
name|neg_upap
operator|||
operator|!
name|null_login
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"peer refused to authenticate"
argument_list|)
expr_stmt|;
name|lcp_close
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|phase
operator|=
name|PHASE_TERMINATE
expr_stmt|;
return|return;
block|}
block|}
name|phase
operator|=
name|PHASE_AUTHENTICATE
expr_stmt|;
name|auth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|go
operator|->
name|neg_chap
condition|)
block|{
name|ChapAuthPeer
argument_list|(
name|unit
argument_list|,
name|our_name
argument_list|,
name|go
operator|->
name|chap_mdtype
argument_list|)
expr_stmt|;
name|auth
operator||=
name|CHAP_PEER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|go
operator|->
name|neg_upap
condition|)
block|{
name|upap_authpeer
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|auth
operator||=
name|UPAP_PEER
expr_stmt|;
block|}
if|if
condition|(
name|ho
operator|->
name|neg_chap
condition|)
block|{
name|ChapAuthWithPeer
argument_list|(
name|unit
argument_list|,
name|our_name
argument_list|,
name|ho
operator|->
name|chap_mdtype
argument_list|)
expr_stmt|;
name|auth
operator||=
name|CHAP_WITHPEER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ho
operator|->
name|neg_upap
condition|)
block|{
name|upap_authwithpeer
argument_list|(
name|unit
argument_list|,
name|user
argument_list|,
name|passwd
argument_list|)
expr_stmt|;
name|auth
operator||=
name|UPAP_WITHPEER
expr_stmt|;
block|}
name|auth_pending
index|[
name|unit
index|]
operator|=
name|auth
expr_stmt|;
if|if
condition|(
operator|!
name|auth
condition|)
name|network_phase
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Proceed to the network phase.  */
end_comment

begin_function
specifier|static
name|void
name|network_phase
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|phase
operator|=
name|PHASE_NETWORK
expr_stmt|;
name|ipcp_open
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ccp_open
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The peer has failed to authenticate himself using `protocol'.  */
end_comment

begin_function
name|void
name|auth_peer_fail
parameter_list|(
name|unit
parameter_list|,
name|protocol
parameter_list|)
name|int
name|unit
decl_stmt|,
name|protocol
decl_stmt|;
block|{
comment|/*      * Authentication failure: take the link down      */
name|lcp_close
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|phase
operator|=
name|PHASE_TERMINATE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The peer has been successfully authenticated using `protocol'.  */
end_comment

begin_function
name|void
name|auth_peer_success
parameter_list|(
name|unit
parameter_list|,
name|protocol
parameter_list|)
name|int
name|unit
decl_stmt|,
name|protocol
decl_stmt|;
block|{
name|int
name|bit
decl_stmt|;
switch|switch
condition|(
name|protocol
condition|)
block|{
case|case
name|PPP_CHAP
case|:
name|bit
operator|=
name|CHAP_PEER
expr_stmt|;
break|break;
case|case
name|PPP_PAP
case|:
name|bit
operator|=
name|UPAP_PEER
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"auth_peer_success: unknown protocol %x"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * If we have overridden addresses based on auth info      * then set that information now before continuing      */
name|auth_set_ip_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/*      * If there is no more authentication still to be done,      * proceed to the network phase.      */
if|if
condition|(
operator|(
name|auth_pending
index|[
name|unit
index|]
operator|&=
operator|~
name|bit
operator|)
operator|==
literal|0
condition|)
block|{
name|phase
operator|=
name|PHASE_NETWORK
expr_stmt|;
name|ipcp_open
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ccp_open
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * We have failed to authenticate ourselves to the peer using `protocol'.  */
end_comment

begin_function
name|void
name|auth_withpeer_fail
parameter_list|(
name|unit
parameter_list|,
name|protocol
parameter_list|)
name|int
name|unit
decl_stmt|,
name|protocol
decl_stmt|;
block|{
comment|/*      * We've failed to authenticate ourselves to our peer.      * He'll probably take the link down, and there's not much      * we can do except wait for that.      */
block|}
end_function

begin_comment
comment|/*  * We have successfully authenticated ourselves with the peer using `protocol'.  */
end_comment

begin_function
name|void
name|auth_withpeer_success
parameter_list|(
name|unit
parameter_list|,
name|protocol
parameter_list|)
name|int
name|unit
decl_stmt|,
name|protocol
decl_stmt|;
block|{
name|int
name|bit
decl_stmt|;
switch|switch
condition|(
name|protocol
condition|)
block|{
case|case
name|PPP_CHAP
case|:
name|bit
operator|=
name|CHAP_WITHPEER
expr_stmt|;
break|break;
case|case
name|PPP_PAP
case|:
name|bit
operator|=
name|UPAP_WITHPEER
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"auth_peer_success: unknown protocol %x"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * If we have overridden addresses based on auth info      * then set that information now before continuing      */
name|auth_set_ip_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/*      * If there is no more authentication still being done,      * proceed to the network phase.      */
if|if
condition|(
operator|(
name|auth_pending
index|[
name|unit
index|]
operator|&=
operator|~
name|bit
operator|)
operator|==
literal|0
condition|)
name|network_phase
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * check_auth_options - called to check authentication options.  */
end_comment

begin_function
name|void
name|check_auth_options
parameter_list|()
block|{
name|lcp_options
modifier|*
name|wo
init|=
operator|&
name|lcp_wantoptions
index|[
literal|0
index|]
decl_stmt|;
name|lcp_options
modifier|*
name|ao
init|=
operator|&
name|lcp_allowoptions
index|[
literal|0
index|]
decl_stmt|;
comment|/* Default our_name to hostname, and user to our_name */
if|if
condition|(
name|our_name
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|usehostname
condition|)
name|strcpy
argument_list|(
name|our_name
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|user
argument_list|,
name|our_name
argument_list|)
expr_stmt|;
comment|/* If authentication is required, ask peer for CHAP or PAP. */
if|if
condition|(
name|auth_required
operator|&&
operator|!
name|wo
operator|->
name|neg_chap
operator|&&
operator|!
name|wo
operator|->
name|neg_upap
condition|)
block|{
name|wo
operator|->
name|neg_chap
operator|=
literal|1
expr_stmt|;
name|wo
operator|->
name|neg_upap
operator|=
literal|1
expr_stmt|;
block|}
comment|/*      * Check whether we have appropriate secrets to use      * to authenticate ourselves and/or the peer.      */
if|if
condition|(
name|ao
operator|->
name|neg_upap
operator|&&
name|passwd
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|!
name|get_upap_passwd
argument_list|()
condition|)
name|ao
operator|->
name|neg_upap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wo
operator|->
name|neg_upap
operator|&&
operator|!
name|uselogin
operator|&&
operator|!
name|have_upap_secret
argument_list|()
condition|)
name|wo
operator|->
name|neg_upap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ao
operator|->
name|neg_chap
operator|&&
operator|!
name|have_chap_secret
argument_list|(
name|our_name
argument_list|,
name|remote_name
argument_list|)
condition|)
name|ao
operator|->
name|neg_chap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wo
operator|->
name|neg_chap
operator|&&
operator|!
name|have_chap_secret
argument_list|(
name|remote_name
argument_list|,
name|our_name
argument_list|)
condition|)
name|wo
operator|->
name|neg_chap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|auth_required
operator|&&
operator|!
name|wo
operator|->
name|neg_chap
operator|&&
operator|!
name|wo
operator|->
name|neg_upap
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ pppd: peer authentication required but no authentication files accessible\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * check_passwd - Check the user name and passwd against the PAP secrets  * file.  If requested, also check against the system password database,  * and login the user if OK.  *  * returns:  *	UPAP_AUTHNAK: Authentication failed.  *	UPAP_AUTHACK: Authentication succeeded.  * In either case, msg points to an appropriate message.  */
end_comment

begin_function
name|int
name|check_passwd
parameter_list|(
name|unit
parameter_list|,
name|auser
parameter_list|,
name|userlen
parameter_list|,
name|apasswd
parameter_list|,
name|passwdlen
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|auser
decl_stmt|;
name|int
name|userlen
decl_stmt|;
name|char
modifier|*
name|apasswd
decl_stmt|;
name|int
name|passwdlen
decl_stmt|;
name|char
modifier|*
modifier|*
name|msg
decl_stmt|;
name|int
modifier|*
name|msglen
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
name|char
name|passwd
index|[
literal|256
index|]
decl_stmt|,
name|user
index|[
literal|256
index|]
decl_stmt|;
name|char
name|secret
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
specifier|static
name|int
name|attempts
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/*      * Make copies of apasswd and auser, then null-terminate them.      */
name|len
operator|=
name|MIN
argument_list|(
name|passwdlen
argument_list|,
sizeof|sizeof
argument_list|(
name|passwd
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|apasswd
argument_list|,
name|passwd
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|passwd
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|userlen
argument_list|,
sizeof|sizeof
argument_list|(
name|user
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|auser
argument_list|,
name|user
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|user
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * Open the file of upap secrets and scan for a suitable secret      * for authenticating this user.      */
name|filename
operator|=
name|_PATH_UPAPFILE
expr_stmt|;
name|addrs
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|UPAP_AUTHACK
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|uselogin
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't open upap password file %s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ret
operator|=
name|UPAP_AUTHNAK
expr_stmt|;
block|}
block|}
else|else
block|{
name|check_access
argument_list|(
name|f
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan_authfile
argument_list|(
name|f
argument_list|,
name|user
argument_list|,
name|our_name
argument_list|,
name|secret
argument_list|,
operator|&
name|addrs
argument_list|,
name|filename
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|secret
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
operator|(
name|cryptpap
operator|||
name|strcmp
argument_list|(
name|passwd
argument_list|,
name|secret
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|crypt
argument_list|(
name|passwd
argument_list|,
name|secret
argument_list|)
argument_list|,
name|secret
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"upap authentication failure for %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|ret
operator|=
name|UPAP_AUTHNAK
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uselogin
operator|&&
name|ret
operator|==
name|UPAP_AUTHACK
condition|)
block|{
name|ret
operator|=
name|ppplogin
argument_list|(
name|user
argument_list|,
name|passwd
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|UPAP_AUTHNAK
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"upap login failure for %s"
argument_list|,
name|user
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ret
operator|==
name|UPAP_AUTHNAK
condition|)
block|{
operator|*
name|msg
operator|=
literal|"Login incorrect"
expr_stmt|;
operator|*
name|msglen
operator|=
name|strlen
argument_list|(
operator|*
name|msg
argument_list|)
expr_stmt|;
comment|/* 	 * Frustrate passwd stealer programs. 	 * Allow 10 tries, but start backing off after 3 (stolen from login). 	 * On 10'th, drop the connection. 	 */
if|if
condition|(
name|attempts
operator|++
operator|>=
literal|10
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%d LOGIN FAILURES ON %s, %s"
argument_list|,
name|attempts
argument_list|,
name|devnam
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|quit
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|attempts
operator|>
literal|3
condition|)
name|sleep
argument_list|(
call|(
name|u_int
call|)
argument_list|(
name|attempts
operator|-
literal|3
argument_list|)
operator|*
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrs
operator|!=
name|NULL
condition|)
name|free_wordlist
argument_list|(
name|addrs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attempts
operator|=
literal|0
expr_stmt|;
comment|/* Reset count */
operator|*
name|msg
operator|=
literal|"Login ok"
expr_stmt|;
operator|*
name|msglen
operator|=
name|strlen
argument_list|(
operator|*
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|addresses
index|[
name|unit
index|]
operator|!=
name|NULL
condition|)
name|free_wordlist
argument_list|(
name|addresses
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|addresses
index|[
name|unit
index|]
operator|=
name|addrs
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Check if an "entry" is in the file "fname" - used by ppplogin.  * Taken from libexec/ftpd/ftpd.c  * Returns: 0 if not found, 1 if found, 2 if file can't be opened for reading.  */
end_comment

begin_function
specifier|static
name|int
name|checkfile
parameter_list|(
name|fname
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|FILE
modifier|*
name|fd
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|fopen
argument_list|(
name|fname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|line
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
literal|2
operator|)
return|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppplogin - Check the user name and password against the system  * password database, and login the user if OK.  *  * returns:  *	UPAP_AUTHNAK: Login failed.  *	UPAP_AUTHACK: Login succeeded.  * In either case, msg points to an appropriate message.  *  * UPAP_AUTHACK should only be returned *after* wtmp and utmp are updated.  */
end_comment

begin_function
specifier|static
name|int
name|ppplogin
parameter_list|(
name|user
parameter_list|,
name|passwd
parameter_list|,
name|msg
parameter_list|,
name|msglen
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|;
name|char
modifier|*
name|passwd
decl_stmt|;
name|char
modifier|*
modifier|*
name|msg
decl_stmt|;
name|int
modifier|*
name|msglen
decl_stmt|;
block|{
name|struct
name|utmp
name|utmp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|struct
name|timeval
name|tp
decl_stmt|;
name|char
modifier|*
name|epasswd
decl_stmt|;
name|char
modifier|*
name|tty
decl_stmt|;
ifdef|#
directive|ifdef
name|HAS_SHADOW
name|struct
name|spwd
modifier|*
name|spwd
decl_stmt|;
name|struct
name|spwd
modifier|*
name|getspnam
parameter_list|()
function_decl|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|pw
operator|=
name|getpwnam
argument_list|(
name|user
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
comment|/*  * Check that the user is not listed in /etc/ppp/ppp.deny  * and that the user's shell is listed in /etc/ppp/ppp.shells  * if /etc/ppp/ppp.shells exists.  */
if|if
condition|(
name|checkfile
argument_list|(
name|_PATH_PPPDENY
argument_list|,
name|user
argument_list|)
operator|==
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"upap user %s: login denied in %s"
argument_list|,
name|user
argument_list|,
name|_PATH_PPPDENY
argument_list|)
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
if|if
condition|(
name|checkfile
argument_list|(
name|_PATH_PPPSHELLS
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|)
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"upap user %s: shell %s not in %s"
argument_list|,
name|user
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|,
name|_PATH_PPPSHELLS
argument_list|)
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HAS_SHADOW
if|if
condition|(
operator|(
name|spwd
operator|=
name|getspnam
argument_list|(
name|user
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pw
operator|->
name|pw_passwd
operator|=
literal|""
expr_stmt|;
block|}
else|else
block|{
name|pw
operator|->
name|pw_passwd
operator|=
name|spwd
operator|->
name|sp_pwdp
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * If there is a password, check it.      */
if|if
condition|(
name|pw
operator|->
name|pw_passwd
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
ifdef|#
directive|ifdef
name|HAS_SHADOW
if|if
condition|(
operator|(
name|pw
operator|->
name|pw_passwd
operator|&&
name|pw
operator|->
name|pw_passwd
index|[
literal|0
index|]
operator|==
literal|'@'
operator|&&
name|pw_auth
argument_list|(
name|pw
operator|->
name|pw_passwd
operator|+
literal|1
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|PW_PPP
argument_list|,
name|NULL
argument_list|)
operator|)
operator|||
operator|!
name|valid
argument_list|(
name|passwd
argument_list|,
name|pw
argument_list|)
condition|)
block|{
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
else|#
directive|else
name|epasswd
operator|=
name|crypt
argument_list|(
name|passwd
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|epasswd
argument_list|,
name|pw
operator|->
name|pw_passwd
argument_list|)
condition|)
block|{
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pw
operator|->
name|pw_expire
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tp
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|.
name|tv_sec
operator|>=
name|pw
operator|->
name|pw_expire
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"pap user %s account expired"
argument_list|,
name|user
argument_list|)
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHNAK
operator|)
return|;
block|}
block|}
block|}
comment|/* if password */
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"user %s logged in"
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|/* Log in wtmp and utmp using login() */
name|tty
operator|=
name|devnam
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tty
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|tty
operator|+=
literal|5
expr_stmt|;
name|logged_in
operator|=
name|TRUE
expr_stmt|;
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|utmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|utmp
operator|.
name|ut_time
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|,
name|user
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|,
literal|":PPP"
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_host
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|utmp
operator|.
name|ut_line
argument_list|,
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
name|utmp
operator|.
name|ut_line
argument_list|)
argument_list|)
expr_stmt|;
name|login
argument_list|(
operator|&
name|utmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|UPAP_AUTHACK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppplogout - Logout the user.  */
end_comment

begin_function
specifier|static
name|void
name|ppplogout
parameter_list|()
block|{
name|char
modifier|*
name|tty
decl_stmt|;
name|tty
operator|=
name|devnam
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|tty
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|tty
operator|+=
literal|5
expr_stmt|;
name|logwtmp
argument_list|(
name|tty
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Wipe out wtmp logout entry */
name|logged_in
operator|=
name|FALSE
expr_stmt|;
name|logout
argument_list|(
name|tty
argument_list|)
expr_stmt|;
comment|/* Wipe out utmp */
block|}
end_function

begin_comment
comment|/*  * null_login - Check if a username of "" and a password of "" are  * acceptable, and iff so, set the list of acceptable IP addresses  * and return 1.  */
end_comment

begin_function
specifier|static
name|int
name|null_login
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
name|char
name|secret
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
comment|/*      * Open the file of upap secrets and scan for a suitable secret.      * We don't accept a wildcard client.      */
name|filename
operator|=
name|_PATH_UPAPFILE
expr_stmt|;
name|addrs
operator|=
name|NULL
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|check_access
argument_list|(
name|f
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|i
operator|=
name|scan_authfile
argument_list|(
name|f
argument_list|,
literal|""
argument_list|,
name|our_name
argument_list|,
name|secret
argument_list|,
operator|&
name|addrs
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i
operator|>=
literal|0
operator|&&
operator|(
name|i
operator|&
name|NONWILD_CLIENT
operator|)
operator|!=
literal|0
operator|&&
name|secret
index|[
literal|0
index|]
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|addresses
index|[
name|unit
index|]
operator|!=
name|NULL
condition|)
name|free_wordlist
argument_list|(
name|addresses
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|addresses
index|[
name|unit
index|]
operator|=
name|addrs
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * get_upap_passwd - get a password for authenticating ourselves with  * our peer using PAP.  Returns 1 on success, 0 if no suitable password  * could be found.  */
end_comment

begin_function
specifier|static
name|int
name|get_upap_passwd
parameter_list|()
block|{
name|char
modifier|*
name|filename
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
name|char
name|secret
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
name|filename
operator|=
name|_PATH_UPAPFILE
expr_stmt|;
name|addrs
operator|=
name|NULL
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|check_access
argument_list|(
name|f
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|scan_authfile
argument_list|(
name|f
argument_list|,
name|user
argument_list|,
name|remote_name
argument_list|,
name|secret
argument_list|,
name|NULL
argument_list|,
name|filename
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|strncpy
argument_list|(
name|passwd
argument_list|,
name|secret
argument_list|,
name|MAXSECRETLEN
argument_list|)
expr_stmt|;
name|passwd
index|[
name|MAXSECRETLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * have_upap_secret - check whether we have a PAP file with any  * secrets that we could possibly use for authenticating the peer.  */
end_comment

begin_function
specifier|static
name|int
name|have_upap_secret
parameter_list|()
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|filename
operator|=
name|_PATH_UPAPFILE
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|scan_authfile
argument_list|(
name|f
argument_list|,
name|NULL
argument_list|,
name|our_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * have_chap_secret - check whether we have a CHAP file with a  * secret that we could possibly use for authenticating `client'  * on `server'.  Either can be the null string, meaning we don't  * know the identity yet.  */
end_comment

begin_function
specifier|static
name|int
name|have_chap_secret
parameter_list|(
name|client
parameter_list|,
name|server
parameter_list|)
name|char
modifier|*
name|client
decl_stmt|;
name|char
modifier|*
name|server
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|filename
operator|=
name|_PATH_CHAPFILE
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|client
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|client
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|server
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|server
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|scan_authfile
argument_list|(
name|f
argument_list|,
name|client
argument_list|,
name|server
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * get_secret - open the CHAP secret file and return the secret  * for authenticating the given client on the given server.  * (We could be either client or server).  */
end_comment

begin_function
name|int
name|get_secret
parameter_list|(
name|unit
parameter_list|,
name|client
parameter_list|,
name|server
parameter_list|,
name|secret
parameter_list|,
name|secret_len
parameter_list|,
name|save_addrs
parameter_list|)
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|client
decl_stmt|;
name|char
modifier|*
name|server
decl_stmt|;
name|char
modifier|*
name|secret
decl_stmt|;
name|int
modifier|*
name|secret_len
decl_stmt|;
name|int
name|save_addrs
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
name|char
name|secbuf
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
name|filename
operator|=
name|_PATH_CHAPFILE
expr_stmt|;
name|addrs
operator|=
name|NULL
expr_stmt|;
name|secbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Can't open chap secret file %s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|check_access
argument_list|(
name|f
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|ret
operator|=
name|scan_authfile
argument_list|(
name|f
argument_list|,
name|client
argument_list|,
name|server
argument_list|,
name|secbuf
argument_list|,
operator|&
name|addrs
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|save_addrs
condition|)
block|{
if|if
condition|(
name|addresses
index|[
name|unit
index|]
operator|!=
name|NULL
condition|)
name|free_wordlist
argument_list|(
name|addresses
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|addresses
index|[
name|unit
index|]
operator|=
name|addrs
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|secbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MAXSECRETLEN
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Secret for %s on %s is too long"
argument_list|,
name|client
argument_list|,
name|server
argument_list|)
expr_stmt|;
name|len
operator|=
name|MAXSECRETLEN
expr_stmt|;
block|}
name|BCOPY
argument_list|(
name|secbuf
argument_list|,
name|secret
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|secret_len
operator|=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|auth_set_ip_addr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
if|if
condition|(
name|non_wildclient
operator|&&
operator|(
name|addrs
operator|=
name|addresses
index|[
name|unit
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|addrs
operator|!=
name|NULL
condition|;
name|addrs
operator|=
name|addrs
operator|->
name|next
control|)
block|{
comment|/* 	     * Look for address overrides, and set them if we have any 	     */
if|if
condition|(
name|strchr
argument_list|(
name|addrs
operator|->
name|word
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|setipaddr
argument_list|(
name|addrs
operator|->
name|word
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * auth_ip_addr - check whether the peer is authorized to use  * a given IP address.  Returns 1 if authorized, 0 otherwise.  */
end_comment

begin_function
name|int
name|auth_ip_addr
parameter_list|(
name|unit
parameter_list|,
name|addr
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|;
block|{
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|u_int32_t
name|a
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|addrs
decl_stmt|;
comment|/* don't allow loopback or multicast address */
if|if
condition|(
name|bad_ip_adrs
argument_list|(
name|addr
argument_list|)
condition|)
return|return
literal|0
return|;
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|addrs
operator|=
name|addresses
index|[
name|unit
index|]
init|;
name|addrs
operator|!=
name|NULL
condition|;
name|addrs
operator|=
name|addrs
operator|->
name|next
operator|,
name|y
operator|++
control|)
block|{
comment|/* "-" means no addresses authorized */
if|if
condition|(
name|strcmp
argument_list|(
name|addrs
operator|->
name|word
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* 	 * A colon in the string means that we wish to force a specific 	 * local:remote address, but we ignore these for now 	 */
if|if
condition|(
name|strchr
argument_list|(
name|addrs
operator|->
name|word
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
condition|)
name|x
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|a
operator|=
name|inet_addr
argument_list|(
name|addrs
operator|->
name|word
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|addrs
operator|->
name|word
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"unknown host %s in auth. address list"
argument_list|,
name|addrs
operator|->
name|word
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|a
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|hp
operator|->
name|h_addr
expr_stmt|;
block|}
if|if
condition|(
name|addr
operator|==
name|a
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
name|x
operator|==
name|y
return|;
comment|/* not in list => can't have it */
block|}
end_function

begin_comment
comment|/*  * bad_ip_adrs - return 1 if the IP address is one we don't want  * to use, such as an address in the loopback net or a multicast address.  * addr is in network byte order.  */
end_comment

begin_function
name|int
name|bad_ip_adrs
parameter_list|(
name|addr
parameter_list|)
name|u_int32_t
name|addr
decl_stmt|;
block|{
name|addr
operator|=
name|ntohl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|>>
name|IN_CLASSA_NSHIFT
operator|)
operator|==
name|IN_LOOPBACKNET
operator|||
name|IN_MULTICAST
argument_list|(
name|addr
argument_list|)
operator|||
name|IN_BADCLASS
argument_list|(
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * check_access - complain if a secret file has too-liberal permissions.  */
end_comment

begin_function
name|void
name|check_access
parameter_list|(
name|f
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"cannot stat secret file %s: %m"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sbuf
operator|.
name|st_mode
operator|&
operator|(
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Warning - secret file %s has world and/or group access"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * scan_authfile - Scan an authorization file for a secret suitable  * for authenticating `client' on `server'.  The return value is -1  * if no secret is found, otherwise>= 0.  The return value has  * NONWILD_CLIENT set if the secret didn't have "*" for the client, and  * NONWILD_SERVER set if the secret didn't have "*" for the server.  * Any following words on the line (i.e. address authorization  * info) are placed in a wordlist and returned in *addrs.    */
end_comment

begin_function
specifier|static
name|int
name|scan_authfile
parameter_list|(
name|f
parameter_list|,
name|client
parameter_list|,
name|server
parameter_list|,
name|secret
parameter_list|,
name|addrs
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|client
decl_stmt|;
name|char
modifier|*
name|server
decl_stmt|;
name|char
modifier|*
name|secret
decl_stmt|;
name|struct
name|wordlist
modifier|*
modifier|*
name|addrs
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|newline
decl_stmt|,
name|xxx
decl_stmt|;
name|int
name|got_flag
decl_stmt|,
name|best_flag
decl_stmt|;
name|FILE
modifier|*
name|sf
decl_stmt|;
name|struct
name|wordlist
modifier|*
name|ap
decl_stmt|,
modifier|*
name|addr_list
decl_stmt|,
modifier|*
name|addr_last
decl_stmt|;
name|char
name|word
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
name|char
name|atfile
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
if|if
condition|(
name|addrs
operator|!=
name|NULL
condition|)
operator|*
name|addrs
operator|=
name|NULL
expr_stmt|;
name|addr_list
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|f
argument_list|,
name|word
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* file is empty??? */
name|newline
operator|=
literal|1
expr_stmt|;
name|best_flag
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * Skip until we find a word at the start of a line. 	 */
while|while
condition|(
operator|!
name|newline
operator|&&
name|getword
argument_list|(
name|f
argument_list|,
name|word
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|newline
condition|)
break|break;
comment|/* got to end of file */
comment|/* 	 * Got a client - check if it's a match or a wildcard. 	 */
name|got_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|client
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|word
argument_list|,
name|client
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|ISWILD
argument_list|(
name|word
argument_list|)
condition|)
block|{
name|newline
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|ISWILD
argument_list|(
name|word
argument_list|)
condition|)
name|got_flag
operator|=
name|NONWILD_CLIENT
expr_stmt|;
comment|/* 	 * Now get a server and check if it matches. 	 */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|f
argument_list|,
name|word
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
break|break;
if|if
condition|(
name|newline
condition|)
continue|continue;
if|if
condition|(
name|server
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|word
argument_list|,
name|server
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|ISWILD
argument_list|(
name|word
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ISWILD
argument_list|(
name|word
argument_list|)
condition|)
name|got_flag
operator||=
name|NONWILD_SERVER
expr_stmt|;
comment|/* 	 * Got some sort of a match - see if it's better than what 	 * we have already. 	 */
if|if
condition|(
name|got_flag
operator|<=
name|best_flag
condition|)
continue|continue;
comment|/* 	 * Get the secret. 	 */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|f
argument_list|,
name|word
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
break|break;
if|if
condition|(
name|newline
condition|)
continue|continue;
comment|/* 	 * Special syntax: @filename means read secret from file. 	 */
if|if
condition|(
name|word
index|[
literal|0
index|]
operator|==
literal|'@'
condition|)
block|{
name|strcpy
argument_list|(
name|atfile
argument_list|,
name|word
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sf
operator|=
name|fopen
argument_list|(
name|atfile
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"can't open indirect secret file %s"
argument_list|,
name|atfile
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|check_access
argument_list|(
name|sf
argument_list|,
name|atfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|sf
argument_list|,
name|word
argument_list|,
operator|&
name|xxx
argument_list|,
name|atfile
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"no secret in indirect secret file %s"
argument_list|,
name|atfile
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|sf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|fclose
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|secret
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|secret
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|best_flag
operator|=
name|got_flag
expr_stmt|;
comment|/* 	 * Now read address authorization info and make a wordlist. 	 */
if|if
condition|(
name|addr_list
condition|)
name|free_wordlist
argument_list|(
name|addr_list
argument_list|)
expr_stmt|;
name|addr_list
operator|=
name|addr_last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|getword
argument_list|(
name|f
argument_list|,
name|word
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
operator|||
name|newline
condition|)
break|break;
name|ap
operator|=
operator|(
expr|struct
name|wordlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wordlist
argument_list|)
operator|+
name|strlen
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
name|novm
argument_list|(
literal|"authorized addresses"
argument_list|)
expr_stmt|;
name|ap
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|ap
operator|->
name|word
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_list
operator|==
name|NULL
condition|)
name|addr_list
operator|=
name|ap
expr_stmt|;
else|else
name|addr_last
operator|->
name|next
operator|=
name|ap
expr_stmt|;
name|addr_last
operator|=
name|ap
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newline
condition|)
break|break;
block|}
if|if
condition|(
name|addrs
operator|!=
name|NULL
condition|)
operator|*
name|addrs
operator|=
name|addr_list
expr_stmt|;
elseif|else
if|if
condition|(
name|addr_list
operator|!=
name|NULL
condition|)
name|free_wordlist
argument_list|(
name|addr_list
argument_list|)
expr_stmt|;
name|non_wildclient
operator|=
operator|(
name|best_flag
operator|&
name|NONWILD_CLIENT
operator|)
operator|&&
name|client
operator|&&
operator|*
name|client
operator|!=
literal|'\0'
expr_stmt|;
return|return
name|best_flag
return|;
block|}
end_function

begin_comment
comment|/*  * free_wordlist - release memory allocated for a wordlist.  */
end_comment

begin_function
specifier|static
name|void
name|free_wordlist
parameter_list|(
name|wp
parameter_list|)
name|struct
name|wordlist
modifier|*
name|wp
decl_stmt|;
block|{
name|struct
name|wordlist
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|wp
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|wp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|wp
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

end_unit

