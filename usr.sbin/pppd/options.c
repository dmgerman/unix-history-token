begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * options.c - handles option processing for PPP.  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_define
define|#
directive|define
name|devnam
value|STDLIB_devnam
end_define

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_undef
undef|#
directive|undef
name|devnam
end_undef

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|"ppp.h"
end_include

begin_include
include|#
directive|include
file|"pppd.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"patchlevel.h"
end_include

begin_include
include|#
directive|include
file|"fsm.h"
end_include

begin_include
include|#
directive|include
file|"lcp.h"
end_include

begin_include
include|#
directive|include
file|"ipcp.h"
end_include

begin_include
include|#
directive|include
file|"upap.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ultrix
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|strdup
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GIDSET_TYPE
end_ifndef

begin_define
define|#
directive|define
name|GIDSET_TYPE
value|gid_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|setdebug
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setkdebug
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setpassive
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setsilent
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noopt
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnovj
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnovjccomp
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setvjslots
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reqpap
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nopap
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setupapfile
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nochap
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reqchap
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setspeed
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noaccomp
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noasyncmap
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|noipaddr
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nomagicnumber
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setasyncmap
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setescape
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setmru
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setmtu
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nomru
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nopcomp
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setconnector
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdisconnector
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdomain
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnetmask
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setcrtscts
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setxonxoff
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnodetach
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setmodem
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlocal
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlock
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setname
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setuser
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setremote
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setauth
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readfile
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdefaultroute
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setproxyarp
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setpersist
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdologin
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setusehostname
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setnoipdflt
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlcptimeout
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlcpterm
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlcpconf
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlcpfails
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcptimeout
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcpterm
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcpconf
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcpfails
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setpaptimeout
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setpapreqs
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setchaptimeout
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setchapchal
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setchapintv
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcpaccl
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setipcpaccr
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlcpechointv
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setlcpechofails
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|number_option
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|long
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readable
name|__P
argument_list|(
operator|(
name|int
name|fd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdns1
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setdns2
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Option variables  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|kdebugflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|modem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lockflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|crtscts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nodetach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|connector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|disconnector
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|inspeed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|devnam
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|default_device
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|netmask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|dns1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|dns2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|user
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|passwd
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|auth_required
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|proxyarp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|persist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|uselogin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|lcp_echo_interval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_long
name|lcp_echo_fails
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|our_name
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|remote_name
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|usehostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|disable_defaultip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Valid arguments.  */
end_comment

begin_struct
specifier|static
struct|struct
name|cmd
block|{
name|char
modifier|*
name|cmd_name
decl_stmt|;
name|int
name|num_args
decl_stmt|;
name|int
function_decl|(
modifier|*
name|cmd_func
function_decl|)
parameter_list|()
function_decl|;
block|}
name|cmds
index|[]
init|=
block|{
block|{
literal|"-all"
block|,
literal|0
block|,
name|noopt
block|}
block|,
comment|/* Don't request/allow any options */
block|{
literal|"-ac"
block|,
literal|0
block|,
name|noaccomp
block|}
block|,
comment|/* Disable Address/Control compress */
block|{
literal|"-am"
block|,
literal|0
block|,
name|noasyncmap
block|}
block|,
comment|/* Disable asyncmap negotiation */
block|{
literal|"-as"
block|,
literal|1
block|,
name|setasyncmap
block|}
block|,
comment|/* set the desired async map */
block|{
literal|"-d"
block|,
literal|0
block|,
name|setdebug
block|}
block|,
comment|/* Increase debugging level */
block|{
literal|"-detach"
block|,
literal|0
block|,
name|setnodetach
block|}
block|,
comment|/* don't fork */
block|{
literal|"-ip"
block|,
literal|0
block|,
name|noipaddr
block|}
block|,
comment|/* Disable IP address negotiation */
block|{
literal|"-mn"
block|,
literal|0
block|,
name|nomagicnumber
block|}
block|,
comment|/* Disable magic number negotiation */
block|{
literal|"-mru"
block|,
literal|0
block|,
name|nomru
block|}
block|,
comment|/* Disable mru negotiation */
block|{
literal|"-p"
block|,
literal|0
block|,
name|setpassive
block|}
block|,
comment|/* Set passive mode */
block|{
literal|"-pc"
block|,
literal|0
block|,
name|nopcomp
block|}
block|,
comment|/* Disable protocol field compress */
block|{
literal|"+ua"
block|,
literal|1
block|,
name|setupapfile
block|}
block|,
comment|/* Get PAP user and password from file */
block|{
literal|"+pap"
block|,
literal|0
block|,
name|reqpap
block|}
block|,
comment|/* Require PAP auth from peer */
block|{
literal|"-pap"
block|,
literal|0
block|,
name|nopap
block|}
block|,
comment|/* Don't allow PPP_PAP authentication with peer */
block|{
literal|"+chap"
block|,
literal|0
block|,
name|reqchap
block|}
block|,
comment|/* Require CHAP authentication from peer */
block|{
literal|"-chap"
block|,
literal|0
block|,
name|nochap
block|}
block|,
comment|/* Don't allow CHAP authentication with peer */
block|{
literal|"-vj"
block|,
literal|0
block|,
name|setnovj
block|}
block|,
comment|/* disable VJ compression */
block|{
literal|"-vjccomp"
block|,
literal|0
block|,
name|setnovjccomp
block|}
block|,
comment|/* disable VJ connection-ID compression */
block|{
literal|"vj-max-slots"
block|,
literal|1
block|,
name|setvjslots
block|}
block|,
comment|/* Set maximum VJ header slots */
block|{
literal|"asyncmap"
block|,
literal|1
block|,
name|setasyncmap
block|}
block|,
comment|/* set the desired async map */
block|{
literal|"escape"
block|,
literal|1
block|,
name|setescape
block|}
block|,
comment|/* set chars to escape on transmission */
block|{
literal|"connect"
block|,
literal|1
block|,
name|setconnector
block|}
block|,
comment|/* A program to set up a connection */
block|{
literal|"disconnect"
block|,
literal|1
block|,
name|setdisconnector
block|}
block|,
comment|/* program to disconnect serial dev. */
block|{
literal|"crtscts"
block|,
literal|0
block|,
name|setcrtscts
block|}
block|,
comment|/* set h/w flow control */
block|{
literal|"xonxoff"
block|,
literal|0
block|,
name|setxonxoff
block|}
block|,
comment|/* set s/w flow control */
block|{
literal|"-crtscts"
block|,
literal|0
block|,
name|setxonxoff
block|}
block|,
comment|/* another name for xonxoff */
block|{
literal|"debug"
block|,
literal|0
block|,
name|setdebug
block|}
block|,
comment|/* Increase debugging level */
block|{
literal|"kdebug"
block|,
literal|1
block|,
name|setkdebug
block|}
block|,
comment|/* Enable kernel-level debugging */
block|{
literal|"domain"
block|,
literal|1
block|,
name|setdomain
block|}
block|,
comment|/* Add given domain name to hostname*/
block|{
literal|"mru"
block|,
literal|1
block|,
name|setmru
block|}
block|,
comment|/* Set MRU value for negotiation */
block|{
literal|"mtu"
block|,
literal|1
block|,
name|setmtu
block|}
block|,
comment|/* Set our MTU */
block|{
literal|"netmask"
block|,
literal|1
block|,
name|setnetmask
block|}
block|,
comment|/* set netmask */
block|{
literal|"dns1"
block|,
literal|1
block|,
name|setdns1
block|}
block|,
comment|/* set Primary Domain Name Server */
block|{
literal|"dns2"
block|,
literal|1
block|,
name|setdns2
block|}
block|,
comment|/* set Secondary Domain Name Server */
block|{
literal|"passive"
block|,
literal|0
block|,
name|setpassive
block|}
block|,
comment|/* Set passive mode */
block|{
literal|"silent"
block|,
literal|0
block|,
name|setsilent
block|}
block|,
comment|/* Set silent mode */
block|{
literal|"modem"
block|,
literal|0
block|,
name|setmodem
block|}
block|,
comment|/* Use modem control lines */
block|{
literal|"local"
block|,
literal|0
block|,
name|setlocal
block|}
block|,
comment|/* Don't use modem control lines */
block|{
literal|"lock"
block|,
literal|0
block|,
name|setlock
block|}
block|,
comment|/* Lock serial device (with lock file) */
block|{
literal|"name"
block|,
literal|1
block|,
name|setname
block|}
block|,
comment|/* Set local name for authentication */
block|{
literal|"user"
block|,
literal|1
block|,
name|setuser
block|}
block|,
comment|/* Set username for PAP auth with peer */
block|{
literal|"usehostname"
block|,
literal|0
block|,
name|setusehostname
block|}
block|,
comment|/* Must use hostname for auth. */
block|{
literal|"remotename"
block|,
literal|1
block|,
name|setremote
block|}
block|,
comment|/* Set remote name for authentication */
block|{
literal|"auth"
block|,
literal|0
block|,
name|setauth
block|}
block|,
comment|/* Require authentication from peer */
block|{
literal|"file"
block|,
literal|1
block|,
name|readfile
block|}
block|,
comment|/* Take options from a file */
block|{
literal|"defaultroute"
block|,
literal|0
block|,
name|setdefaultroute
block|}
block|,
comment|/* Add default route */
block|{
literal|"proxyarp"
block|,
literal|0
block|,
name|setproxyarp
block|}
block|,
comment|/* Add proxy ARP entry */
block|{
literal|"persist"
block|,
literal|0
block|,
name|setpersist
block|}
block|,
comment|/* Keep on reopening connection after close */
block|{
literal|"login"
block|,
literal|0
block|,
name|setdologin
block|}
block|,
comment|/* Use system password database for PPP_PAP */
block|{
literal|"noipdefault"
block|,
literal|0
block|,
name|setnoipdflt
block|}
block|,
comment|/* Don't use name for default IP adrs */
block|{
literal|"lcp-echo-failure"
block|,
literal|1
block|,
name|setlcpechofails
block|}
block|,
comment|/* consecutive echo failures */
block|{
literal|"lcp-echo-interval"
block|,
literal|1
block|,
name|setlcpechointv
block|}
block|,
comment|/* time for lcp echo events */
block|{
literal|"lcp-restart"
block|,
literal|1
block|,
name|setlcptimeout
block|}
block|,
comment|/* Set timeout for LCP */
block|{
literal|"lcp-max-terminate"
block|,
literal|1
block|,
name|setlcpterm
block|}
block|,
comment|/* Set max #xmits for term-reqs */
block|{
literal|"lcp-max-configure"
block|,
literal|1
block|,
name|setlcpconf
block|}
block|,
comment|/* Set max #xmits for conf-reqs */
block|{
literal|"lcp-max-failure"
block|,
literal|1
block|,
name|setlcpfails
block|}
block|,
comment|/* Set max #conf-naks for LCP */
block|{
literal|"ipcp-restart"
block|,
literal|1
block|,
name|setipcptimeout
block|}
block|,
comment|/* Set timeout for PPP_IPCP */
block|{
literal|"ipcp-max-terminate"
block|,
literal|1
block|,
name|setipcpterm
block|}
block|,
comment|/* Set max #xmits for term-reqs */
block|{
literal|"ipcp-max-configure"
block|,
literal|1
block|,
name|setipcpconf
block|}
block|,
comment|/* Set max #xmits for conf-reqs */
block|{
literal|"ipcp-max-failure"
block|,
literal|1
block|,
name|setipcpfails
block|}
block|,
comment|/* Set max #conf-naks for PPP_IPCP */
block|{
literal|"pap-restart"
block|,
literal|1
block|,
name|setpaptimeout
block|}
block|,
comment|/* Set timeout for PPP_PAP */
block|{
literal|"pap-max-authreq"
block|,
literal|1
block|,
name|setpapreqs
block|}
block|,
comment|/* Set max #xmits for auth-reqs */
block|{
literal|"chap-restart"
block|,
literal|1
block|,
name|setchaptimeout
block|}
block|,
comment|/* Set timeout for CHAP */
block|{
literal|"chap-max-challenge"
block|,
literal|1
block|,
name|setchapchal
block|}
block|,
comment|/* Set max #xmits for challenge */
block|{
literal|"chap-interval"
block|,
literal|1
block|,
name|setchapintv
block|}
block|,
comment|/* Set interval for rechallenge */
block|{
literal|"ipcp-accept-local"
block|,
literal|0
block|,
name|setipcpaccl
block|}
block|,
comment|/* Accept peer's address for us */
block|{
literal|"ipcp-accept-remote"
block|,
literal|0
block|,
name|setipcpaccr
block|}
block|,
comment|/* Accept peer's address for it */
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|IMPLEMENTATION
end_ifndef

begin_define
define|#
directive|define
name|IMPLEMENTATION
value|""
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|usage_string
init|=
literal|"\ pppd version %s patch level %d%s\n\ Usage: %s [ arguments ], where arguments are:\n\<device>	Communicate over the named device\n\<speed>		Set the baud rate to<speed>\n\<loc>:<rem>	Set the local and/or remote interface IP\n\ 			addresses.  Either one may be omitted.\n\ 	asyncmap<n>	Set the desired async map to hex<n>\n\ 	auth		Require authentication from peer\n\         connect<p>     Invoke shell command<p> to set up the serial line\n\ 	crtscts		Use hardware RTS/CTS flow control\n\ 	defaultroute	Add default route through interface\n\ 	file<f>	Take options from file<f>\n\ 	modem		Use modem control lines\n\ 	mru<n>		Set MRU value to<n> for negotiation\n\ 	netmask<n>	Set interface netmask to<n>\n\ See pppd(8) for more options.\n\ "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * parse_args - parse a string of arguments, from the command  * line or from a file.  */
end_comment

begin_function
name|int
name|parse_args
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
name|int
name|ret
decl_stmt|;
while|while
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
name|arg
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
operator|--
name|argc
expr_stmt|;
comment|/* 	 * First see if it's a command. 	 */
for|for
control|(
name|cmdp
operator|=
name|cmds
init|;
name|cmdp
operator|->
name|cmd_name
condition|;
name|cmdp
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
name|cmdp
operator|->
name|cmd_name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cmdp
operator|->
name|cmd_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|argc
operator|<
name|cmdp
operator|->
name|num_args
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too few parameters for command %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|cmdp
operator|->
name|cmd_func
call|)
argument_list|(
name|argv
argument_list|)
condition|)
return|return
literal|0
return|;
name|argc
operator|-=
name|cmdp
operator|->
name|num_args
expr_stmt|;
name|argv
operator|+=
name|cmdp
operator|->
name|num_args
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * Maybe a tty name, speed or IP address? 	     */
if|if
condition|(
operator|(
name|ret
operator|=
name|setdevnam
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ret
operator|=
name|setspeed
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ret
operator|=
name|setipaddr
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: unrecognized command\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
comment|/* error */
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * usage - print out a message telling how to use the program.  */
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|usage_string
argument_list|,
name|VERSION
argument_list|,
name|PATCHLEVEL
argument_list|,
name|IMPLEMENTATION
argument_list|,
name|progname
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * options_from_file - Read a string of options from a file,  * and interpret them.  */
end_comment

begin_function
name|int
name|options_from_file
parameter_list|(
name|filename
parameter_list|,
name|must_exist
parameter_list|,
name|check_prot
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|must_exist
decl_stmt|;
name|int
name|check_prot
decl_stmt|;
block|{
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|newline
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|cmd
modifier|*
name|cmdp
decl_stmt|;
name|char
modifier|*
name|argv
index|[
name|MAXARGS
index|]
decl_stmt|;
name|char
name|args
index|[
name|MAXARGS
index|]
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
name|char
name|cmd
index|[
name|MAXWORDLEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|must_exist
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|1
return|;
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|check_prot
operator|&&
operator|!
name|readable
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: access denied\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|getword
argument_list|(
name|f
argument_list|,
name|cmd
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
block|{
comment|/* 	 * First see if it's a command. 	 */
for|for
control|(
name|cmdp
operator|=
name|cmds
init|;
name|cmdp
operator|->
name|cmd_name
condition|;
name|cmdp
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cmd
argument_list|,
name|cmdp
operator|->
name|cmd_name
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cmdp
operator|->
name|cmd_name
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmdp
operator|->
name|num_args
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|getword
argument_list|(
name|f
argument_list|,
name|args
index|[
name|i
index|]
argument_list|,
operator|&
name|newline
argument_list|,
name|filename
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In file %s: too few parameters for command %s\n"
argument_list|,
name|filename
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|argv
index|[
name|i
index|]
operator|=
name|args
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
call|(
modifier|*
name|cmdp
operator|->
name|cmd_func
call|)
argument_list|(
name|argv
argument_list|)
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* 	     * Maybe a tty name, speed or IP address? 	     */
if|if
condition|(
operator|(
name|ret
operator|=
name|setdevnam
argument_list|(
name|cmd
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ret
operator|=
name|setspeed
argument_list|(
name|cmd
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ret
operator|=
name|setipaddr
argument_list|(
name|cmd
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"In file %s: unrecognized command %s\n"
argument_list|,
name|filename
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
comment|/* error */
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * options_from_user - See if the use has a ~/.ppprc file,  * and if so, interpret options from it.  */
end_comment

begin_function
name|int
name|options_from_user
parameter_list|()
block|{
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|file
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
operator|||
operator|(
name|user
operator|=
name|pw
operator|->
name|pw_dir
operator|)
operator|==
name|NULL
operator|||
name|user
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|file
operator|=
name|_PATH_USEROPT
expr_stmt|;
name|path
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|user
argument_list|)
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|novm
argument_list|(
literal|"init file name"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ret
operator|=
name|options_from_file
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * options_for_tty - See if an options file exists for the serial  * device, and if so, interpret options from it.  */
end_comment

begin_function
name|int
name|options_for_tty
parameter_list|()
block|{
name|char
modifier|*
name|dev
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev
operator|=
name|strrchr
argument_list|(
name|devnam
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
name|dev
operator|=
name|devnam
expr_stmt|;
else|else
operator|++
name|dev
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|dev
argument_list|,
literal|"tty"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* don't look for /etc/ppp/options.tty */
name|path
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|_PATH_TTYOPT
argument_list|)
operator|+
name|strlen
argument_list|(
name|dev
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|novm
argument_list|(
literal|"tty init file name"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|_PATH_TTYOPT
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|ret
operator|=
name|options_from_file
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * readable - check if a file is readable by the real user.  */
end_comment

begin_function
specifier|static
name|int
name|readable
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
name|uid_t
name|uid
decl_stmt|;
name|int
name|ngroups
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|GIDSET_TYPE
name|groups
index|[
name|NGROUPS_MAX
index|]
decl_stmt|;
name|uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sbuf
operator|.
name|st_uid
operator|==
name|uid
condition|)
return|return
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IRUSR
return|;
if|if
condition|(
name|sbuf
operator|.
name|st_gid
operator|==
name|getgid
argument_list|()
condition|)
return|return
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IRGRP
return|;
name|ngroups
operator|=
name|getgroups
argument_list|(
name|NGROUPS_MAX
argument_list|,
name|groups
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngroups
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|sbuf
operator|.
name|st_gid
operator|==
name|groups
index|[
name|i
index|]
condition|)
return|return
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IRGRP
return|;
return|return
name|sbuf
operator|.
name|st_mode
operator|&
name|S_IROTH
return|;
block|}
end_function

begin_comment
comment|/*  * Read a word from a file.  * Words are delimited by white-space or by quotes (").  * Quotes, white-space and \ may be escaped with \.  * \<newline> is ignored.  */
end_comment

begin_function
name|int
name|getword
parameter_list|(
name|f
parameter_list|,
name|word
parameter_list|,
name|newlinep
parameter_list|,
name|filename
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
name|int
modifier|*
name|newlinep
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|len
decl_stmt|,
name|escape
decl_stmt|;
name|int
name|quoted
decl_stmt|;
operator|*
name|newlinep
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|escape
operator|=
literal|0
expr_stmt|;
name|quoted
operator|=
literal|0
expr_stmt|;
comment|/*      * First skip white-space and comments      */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* 	     * \<newline> is ignored; \ followed by anything else 	     * starts a word. 	     */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
literal|'\n'
condition|)
continue|continue;
name|word
index|[
name|len
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|escape
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|*
name|newlinep
operator|=
literal|1
expr_stmt|;
comment|/* next word starts a line */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
block|{
comment|/* comment - ignore until EOF or \n */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
operator|*
name|newlinep
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
comment|/*      * End of file or error - fail      */
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * Is this character escaped by \ ? 	 */
if|if
condition|(
name|escape
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
operator|--
name|len
expr_stmt|;
comment|/* ignore \<newline> */
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|word
index|[
name|len
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
comment|/* put special char in word */
else|else
block|{
if|if
condition|(
name|len
operator|<
name|MAXWORDLEN
operator|-
literal|1
condition|)
name|word
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|len
expr_stmt|;
block|}
name|escape
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
name|quoted
operator|=
operator|!
name|quoted
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|quoted
operator|&&
operator|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|'#'
operator|)
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|<
name|MAXWORDLEN
operator|-
literal|1
condition|)
name|word
index|[
name|len
index|]
operator|=
name|c
expr_stmt|;
operator|++
name|len
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|escape
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|EOF
condition|)
break|break;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|die
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>=
name|MAXWORDLEN
condition|)
block|{
name|word
index|[
name|MAXWORDLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: warning: word in file %s too long (%.20s...)\n"
argument_list|,
name|progname
argument_list|,
name|filename
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
else|else
name|word
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * number_option - parse a numeric parameter for an option  */
end_comment

begin_function
specifier|static
name|int
name|number_option
parameter_list|(
name|str
parameter_list|,
name|valp
parameter_list|,
name|base
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|long
modifier|*
name|valp
decl_stmt|;
name|int
name|base
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
operator|*
name|valp
operator|=
name|strtol
argument_list|(
name|str
argument_list|,
operator|&
name|ptr
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|str
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid number: %s\n"
argument_list|,
name|progname
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * int_option - like number_option, but valp is int *,  * the base is assumed to be 0, and *valp is not changed  * if there is an error.  */
end_comment

begin_function
specifier|static
name|int
name|int_option
parameter_list|(
name|str
parameter_list|,
name|valp
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|valp
decl_stmt|;
block|{
name|long
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|number_option
argument_list|(
name|str
argument_list|,
operator|&
name|v
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|valp
operator|=
operator|(
name|int
operator|)
name|v
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * The following procedures execute commands.  */
end_comment

begin_comment
comment|/*  * readfile - take commands from a file.  */
end_comment

begin_function
specifier|static
name|int
name|readfile
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|options_from_file
argument_list|(
operator|*
name|argv
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * setdebug - Set debug (command line argument).  */
end_comment

begin_function
specifier|static
name|int
name|setdebug
parameter_list|()
block|{
name|debug
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setkdebug - Set kernel debugging level.  */
end_comment

begin_function
specifier|static
name|int
name|setkdebug
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|kdebugflag
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * noopt - Disable all options.  */
end_comment

begin_function
specifier|static
name|int
name|noopt
parameter_list|()
block|{
name|BZERO
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|lcp_wantoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lcp_options
argument_list|)
argument_list|)
expr_stmt|;
name|BZERO
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|lcp_allowoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lcp_options
argument_list|)
argument_list|)
expr_stmt|;
name|BZERO
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ipcp_wantoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipcp_options
argument_list|)
argument_list|)
expr_stmt|;
name|BZERO
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ipcp_allowoptions
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipcp_options
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noaccomp - Disable Address/Control field compression negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|noaccomp
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_accompression
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_accompression
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noasyncmap - Disable async map negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|noasyncmap
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_asyncmap
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_asyncmap
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * noipaddr - Disable IP address negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|noipaddr
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_addr
operator|=
literal|0
expr_stmt|;
name|ipcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_addr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nomagicnumber - Disable magic number negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|nomagicnumber
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_magicnumber
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_magicnumber
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nomru - Disable mru negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|nomru
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_mru
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_mru
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setmru - Set MRU for negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|setmru
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|long
name|mru
decl_stmt|;
if|if
condition|(
operator|!
name|number_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|mru
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|mru
operator|=
name|mru
expr_stmt|;
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_mru
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setmru - Set the largest MTU we'll use.  */
end_comment

begin_function
specifier|static
name|int
name|setmtu
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|long
name|mtu
decl_stmt|;
if|if
condition|(
operator|!
name|number_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|mtu
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mtu
operator|<
name|MINMRU
operator|||
name|mtu
operator|>
name|MAXMRU
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mtu option value of %d is too %s\n"
argument_list|,
name|mtu
argument_list|,
operator|(
name|mtu
operator|<
name|MINMRU
condition|?
literal|"small"
else|:
literal|"large"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|mru
operator|=
name|mtu
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nopcomp - Disable Protocol field compression negotiation.  */
end_comment

begin_function
specifier|static
name|int
name|nopcomp
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_pcompression
operator|=
literal|0
expr_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_pcompression
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setpassive - Set passive mode (don't give up if we time out sending  * LCP configure-requests).  */
end_comment

begin_function
specifier|static
name|int
name|setpassive
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|passive
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setsilent - Set silent mode (don't start sending LCP configure-requests  * until we get one from the peer).  */
end_comment

begin_function
specifier|static
name|int
name|setsilent
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|silent
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * nopap - Disable PAP authentication with peer.  */
end_comment

begin_function
specifier|static
name|int
name|nopap
parameter_list|()
block|{
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * reqpap - Require PAP authentication from peer.  */
end_comment

begin_function
specifier|static
name|int
name|reqpap
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|=
literal|1
expr_stmt|;
name|auth_required
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setupapfile - specifies PPP_PAP info for authenticating with peer.  */
end_comment

begin_function
specifier|static
name|int
name|setupapfile
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|ufile
decl_stmt|;
name|int
name|l
decl_stmt|;
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_upap
operator|=
literal|1
expr_stmt|;
comment|/* open user info file */
if|if
condition|(
operator|(
name|ufile
operator|=
name|fopen
argument_list|(
operator|*
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to open user login data file %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|readable
argument_list|(
name|fileno
argument_list|(
name|ufile
argument_list|)
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: access denied\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|check_access
argument_list|(
name|ufile
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
comment|/* get username */
if|if
condition|(
name|fgets
argument_list|(
name|user
argument_list|,
name|MAXNAMELEN
operator|-
literal|1
argument_list|,
name|ufile
argument_list|)
operator|==
name|NULL
operator|||
name|fgets
argument_list|(
name|passwd
argument_list|,
name|MAXSECRETLEN
operator|-
literal|1
argument_list|,
name|ufile
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unable to read user login data file %s.\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fclose
argument_list|(
name|ufile
argument_list|)
expr_stmt|;
comment|/* get rid of newlines */
name|l
operator|=
name|strlen
argument_list|(
name|user
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
operator|&&
name|user
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|user
index|[
name|l
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
operator|&&
name|passwd
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|passwd
index|[
name|l
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nochap - Disable CHAP authentication with peer.  */
end_comment

begin_function
specifier|static
name|int
name|nochap
parameter_list|()
block|{
name|lcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_chap
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * reqchap - Require CHAP authentication from peer.  */
end_comment

begin_function
specifier|static
name|int
name|reqchap
parameter_list|()
block|{
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_chap
operator|=
literal|1
expr_stmt|;
name|auth_required
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setnovj - disable vj compression  */
end_comment

begin_function
specifier|static
name|int
name|setnovj
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_vj
operator|=
literal|0
expr_stmt|;
name|ipcp_allowoptions
index|[
literal|0
index|]
operator|.
name|neg_vj
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setnovjccomp - disable VJ connection-ID compression  */
end_comment

begin_function
specifier|static
name|int
name|setnovjccomp
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|cflag
operator|=
literal|0
expr_stmt|;
name|ipcp_allowoptions
index|[
literal|0
index|]
operator|.
name|cflag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setvjslots - set maximum number of connection slots for VJ compression  */
end_comment

begin_function
specifier|static
name|int
name|setvjslots
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|value
decl_stmt|;
if|if
condition|(
operator|!
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|value
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|value
operator|<
literal|2
operator|||
name|value
operator|>
literal|16
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pppd: vj-max-slots value must be between 2 and 16\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|maxslotindex
operator|=
name|ipcp_allowoptions
index|[
literal|0
index|]
operator|.
name|maxslotindex
operator|=
name|value
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * setconnector - Set a program to connect to a serial line  */
end_comment

begin_function
specifier|static
name|int
name|setconnector
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|connector
operator|=
name|strdup
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|connector
operator|==
name|NULL
condition|)
name|novm
argument_list|(
literal|"connector string"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setdisconnector - Set a program to disconnect from the serial line  */
end_comment

begin_function
specifier|static
name|int
name|setdisconnector
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|disconnector
operator|=
name|strdup
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|disconnector
operator|==
name|NULL
condition|)
name|novm
argument_list|(
literal|"disconnector string"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setdomain - Set domain name to append to hostname  */
end_comment

begin_function
specifier|static
name|int
name|setdomain
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|strncat
argument_list|(
name|hostname
argument_list|,
operator|*
name|argv
argument_list|,
name|MAXNAMELEN
operator|-
name|strlen
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
name|hostname
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setasyncmap - add bits to asyncmap (what we request peer to escape).  */
end_comment

begin_function
specifier|static
name|int
name|setasyncmap
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|long
name|asyncmap
decl_stmt|;
if|if
condition|(
operator|!
name|number_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|asyncmap
argument_list|,
literal|16
argument_list|)
condition|)
return|return
literal|0
return|;
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|asyncmap
operator||=
name|asyncmap
expr_stmt|;
name|lcp_wantoptions
index|[
literal|0
index|]
operator|.
name|neg_asyncmap
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setescape - add chars to the set we escape on transmission.  */
end_comment

begin_function
specifier|static
name|int
name|setescape
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|ret
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|p
operator|=
operator|*
name|argv
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|n
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|endp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|endp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: invalid hex number: %s\n"
argument_list|,
name|progname
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
name|endp
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
literal|0x20
operator|<=
name|n
operator|&&
name|n
operator|<=
literal|0x3F
operator|||
name|n
operator|==
literal|0x5E
operator|||
name|n
operator|>
literal|0xFF
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't escape character 0x%x\n"
argument_list|,
name|progname
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|xmit_accm
index|[
literal|0
index|]
index|[
name|n
operator|>>
literal|5
index|]
operator||=
literal|1
operator|<<
operator|(
name|n
operator|&
literal|0x1F
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|' '
condition|)
operator|++
name|p
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * setspeed - Set the speed.  */
end_comment

begin_function
specifier|static
name|int
name|setspeed
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|spd
decl_stmt|;
name|spd
operator|=
name|strtol
argument_list|(
name|arg
argument_list|,
operator|&
name|ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|arg
operator|||
operator|*
name|ptr
operator|!=
literal|0
operator|||
name|spd
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|inspeed
operator|=
name|spd
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * setdevnam - Set the device name.  */
end_comment

begin_function
name|int
name|setdevnam
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|char
modifier|*
name|tty
decl_stmt|,
modifier|*
name|ttyname
argument_list|()
decl_stmt|;
name|char
name|dev
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
literal|"/dev/"
argument_list|,
name|cp
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|dev
argument_list|,
literal|"/dev/"
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|dev
argument_list|,
name|cp
argument_list|,
name|MAXPATHLEN
operator|-
literal|5
argument_list|)
expr_stmt|;
name|dev
index|[
name|MAXPATHLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|dev
expr_stmt|;
block|}
comment|/*      * Check if there is a device by this name.      */
if|if
condition|(
name|stat
argument_list|(
name|cp
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
return|return
literal|0
return|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|devnam
argument_list|,
name|cp
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|devnam
index|[
name|MAXPATHLEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|default_device
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * setipaddr - Set the IP address  */
end_comment

begin_function
name|int
name|setipaddr
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|colon
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|;
name|u_long
name|local
decl_stmt|,
name|remote
decl_stmt|;
name|ipcp_options
modifier|*
name|wo
init|=
operator|&
name|ipcp_wantoptions
index|[
literal|0
index|]
decl_stmt|;
comment|/*      * IP address pair separated by ":".      */
if|if
condition|(
operator|(
name|colon
operator|=
name|index
argument_list|(
name|arg
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/*      * If colon first character, then no local addr.      */
if|if
condition|(
name|colon
operator|!=
name|arg
condition|)
block|{
operator|*
name|colon
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|local
operator|=
name|inet_addr
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|arg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown host: %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|local
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|hp
operator|->
name|h_addr
expr_stmt|;
if|if
condition|(
name|our_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|our_name
argument_list|,
name|arg
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|our_name
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bad_ip_adrs
argument_list|(
name|local
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad local IP address %s\n"
argument_list|,
name|ip_ntoa
argument_list|(
name|local
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|local
operator|!=
literal|0
condition|)
name|wo
operator|->
name|ouraddr
operator|=
name|local
expr_stmt|;
operator|*
name|colon
operator|=
literal|':'
expr_stmt|;
block|}
comment|/*      * If colon last character, then no remote addr.      */
if|if
condition|(
operator|*
operator|++
name|colon
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|(
name|remote
operator|=
name|inet_addr
argument_list|(
name|colon
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|colon
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown host: %s\n"
argument_list|,
name|colon
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|remote
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|hp
operator|->
name|h_addr
expr_stmt|;
if|if
condition|(
name|remote_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|remote_name
argument_list|,
name|colon
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|remote_name
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bad_ip_adrs
argument_list|(
name|remote
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad remote IP address %s\n"
argument_list|,
name|ip_ntoa
argument_list|(
name|remote
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|remote
operator|!=
literal|0
condition|)
name|wo
operator|->
name|hisaddr
operator|=
name|remote
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * setnoipdflt - disable setipdefault()  */
end_comment

begin_function
specifier|static
name|int
name|setnoipdflt
parameter_list|()
block|{
name|disable_defaultip
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * setipcpaccl - accept peer's idea of our address  */
end_comment

begin_function
specifier|static
name|int
name|setipcpaccl
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|accept_local
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * setipcpaccr - accept peer's idea of its address  */
end_comment

begin_function
specifier|static
name|int
name|setipcpaccr
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|accept_remote
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * setipdefault - default our local IP address based on our hostname.  */
end_comment

begin_function
name|void
name|setipdefault
parameter_list|()
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|u_long
name|local
decl_stmt|;
name|ipcp_options
modifier|*
name|wo
init|=
operator|&
name|ipcp_wantoptions
index|[
literal|0
index|]
decl_stmt|;
comment|/*      * If local IP address already given, don't bother.      */
if|if
condition|(
name|wo
operator|->
name|ouraddr
operator|!=
literal|0
operator|||
name|disable_defaultip
condition|)
return|return;
comment|/*      * Look up our hostname (possibly with domain name appended)      * and take the first IP address as our local IP address.      * If there isn't an IP address for our hostname, too bad.      */
name|wo
operator|->
name|accept_local
operator|=
literal|1
expr_stmt|;
comment|/* don't insist on this default value */
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|hostname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|local
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|hp
operator|->
name|h_addr
expr_stmt|;
if|if
condition|(
name|local
operator|!=
literal|0
operator|&&
operator|!
name|bad_ip_adrs
argument_list|(
name|local
argument_list|)
condition|)
name|wo
operator|->
name|ouraddr
operator|=
name|local
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setnetmask - set the netmask to be used on the interface.  */
end_comment

begin_function
specifier|static
name|int
name|setnetmask
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|in_addr
name|mask
decl_stmt|;
if|if
condition|(
operator|(
name|inet_aton
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|mask
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|netmask
operator|&
operator|~
name|mask
operator|.
name|s_addr
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid netmask %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|netmask
operator|=
name|mask
operator|.
name|s_addr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setdns1 - set the primary dns.  */
end_comment

begin_function
specifier|static
name|int
name|setdns1
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|in_addr
name|mask
decl_stmt|;
if|if
condition|(
operator|(
name|inet_aton
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|mask
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid dns1 %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dns1
operator|=
name|mask
operator|.
name|s_addr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setdns2 - set the secondary dns.  */
end_comment

begin_function
specifier|static
name|int
name|setdns2
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|in_addr
name|mask
decl_stmt|;
if|if
condition|(
operator|(
name|inet_aton
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|mask
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid dns2 %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dns2
operator|=
name|mask
operator|.
name|s_addr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return user specified netmask. A value of zero means no netmask has  * been set.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|u_long
name|GetMask
parameter_list|(
name|addr
parameter_list|)
name|u_long
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|netmask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setcrtscts
parameter_list|()
block|{
name|crtscts
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setxonxoff
parameter_list|()
block|{
name|crtscts
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setnodetach
parameter_list|()
block|{
name|nodetach
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setmodem
parameter_list|()
block|{
name|modem
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setlocal
parameter_list|()
block|{
name|modem
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setlock
parameter_list|()
block|{
name|lockflag
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setusehostname
parameter_list|()
block|{
name|usehostname
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setname
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
if|if
condition|(
name|our_name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|our_name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|our_name
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setuser
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|strncpy
argument_list|(
name|user
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|user
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setremote
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|strncpy
argument_list|(
name|remote_name
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|remote_name
index|[
name|MAXNAMELEN
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setauth
parameter_list|()
block|{
name|auth_required
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setdefaultroute
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|default_route
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setproxyarp
parameter_list|()
block|{
name|ipcp_wantoptions
index|[
literal|0
index|]
operator|.
name|proxy_arp
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setpersist
parameter_list|()
block|{
name|persist
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setdologin
parameter_list|()
block|{
name|uselogin
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Functions to set the echo interval for modem-less monitors  */
end_comment

begin_function
specifier|static
name|int
name|setlcpechointv
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_echo_interval
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setlcpechofails
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_echo_fails
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Functions to set timeouts, max transmits, etc.  */
end_comment

begin_function
specifier|static
name|int
name|setlcptimeout
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|timeouttime
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setlcpterm
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|maxtermtransmits
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setlcpconf
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|maxconfreqtransmits
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setlcpfails
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|maxnakloops
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setipcptimeout
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ipcp_fsm
index|[
literal|0
index|]
operator|.
name|timeouttime
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setipcpterm
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ipcp_fsm
index|[
literal|0
index|]
operator|.
name|maxtermtransmits
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setipcpconf
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ipcp_fsm
index|[
literal|0
index|]
operator|.
name|maxconfreqtransmits
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setipcpfails
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|lcp_fsm
index|[
literal|0
index|]
operator|.
name|maxnakloops
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setpaptimeout
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|upap
index|[
literal|0
index|]
operator|.
name|us_timeouttime
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setpapreqs
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|upap
index|[
literal|0
index|]
operator|.
name|us_maxtransmits
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setchaptimeout
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|chap
index|[
literal|0
index|]
operator|.
name|timeouttime
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setchapchal
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|chap
index|[
literal|0
index|]
operator|.
name|max_transmits
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setchapintv
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
return|return
name|int_option
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|chap
index|[
literal|0
index|]
operator|.
name|chal_interval
argument_list|)
return|;
block|}
end_function

end_unit

