begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * chap.c - Challenge Handshake Authentication Protocol.  *  * Copyright (c) 1993 The Australian National University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the Australian National University.  The name of the University  * may not be used to endorse or promote products derived from this  * software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Copyright (c) 1991 Gregory M. Christy.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Gregory M. Christy.  The name of the author may not be used to  * endorse or promote products derived from this software without  * specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * TODO:  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<md5.h>
end_include

begin_include
include|#
directive|include
file|"pppd.h"
end_include

begin_include
include|#
directive|include
file|"chap.h"
end_include

begin_include
include|#
directive|include
file|"md5.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CHAPMS
end_ifdef

begin_include
include|#
directive|include
file|"chap_ms.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Protocol entry points.  */
end_comment

begin_function_decl
specifier|static
name|void
name|ChapInit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapLowerUp
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapLowerDown
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapInput
parameter_list|(
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapProtocolReject
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ChapPrintPkt
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|protent
name|chap_protent
init|=
block|{
name|PPP_CHAP
block|,
name|ChapInit
block|,
name|ChapInput
block|,
name|ChapProtocolReject
block|,
name|ChapLowerUp
block|,
name|ChapLowerDown
block|,
name|NULL
block|,
name|NULL
block|,
name|ChapPrintPkt
block|,
name|NULL
block|,
literal|1
block|,
literal|"CHAP"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|chap_state
name|chap
index|[
name|NUM_PPP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CHAP state; one for each unit */
end_comment

begin_function_decl
specifier|static
name|void
name|ChapChallengeTimeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapResponseTimeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapReceiveChallenge
parameter_list|(
name|chap_state
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapRechallenge
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapReceiveResponse
parameter_list|(
name|chap_state
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapReceiveSuccess
parameter_list|(
name|chap_state
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapReceiveFailure
parameter_list|(
name|chap_state
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapSendStatus
parameter_list|(
name|chap_state
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapSendChallenge
parameter_list|(
name|chap_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapSendResponse
parameter_list|(
name|chap_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ChapGenChallenge
parameter_list|(
name|chap_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|double
name|drand48
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|srand48
parameter_list|(
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ChapInit - Initialize a CHAP unit.  */
end_comment

begin_function
specifier|static
name|void
name|ChapInit
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
name|BZERO
argument_list|(
name|cstate
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cstate
argument_list|)
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_INITIAL
expr_stmt|;
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_INITIAL
expr_stmt|;
name|cstate
operator|->
name|timeouttime
operator|=
name|CHAP_DEFTIMEOUT
expr_stmt|;
name|cstate
operator|->
name|max_transmits
operator|=
name|CHAP_DEFTRANSMITS
expr_stmt|;
comment|/* random number generator is initialized in magic_init */
block|}
end_function

begin_comment
comment|/*  * ChapAuthWithPeer - Authenticate us with our peer (start client).  *  */
end_comment

begin_function
name|void
name|ChapAuthWithPeer
parameter_list|(
name|unit
parameter_list|,
name|our_name
parameter_list|,
name|digest
parameter_list|)
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|our_name
decl_stmt|;
name|int
name|digest
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
name|cstate
operator|->
name|resp_name
operator|=
name|our_name
expr_stmt|;
name|cstate
operator|->
name|resp_type
operator|=
name|digest
expr_stmt|;
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_INITIAL
operator|||
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_PENDING
condition|)
block|{
comment|/* lower layer isn't up - wait until later */
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_PENDING
expr_stmt|;
return|return;
block|}
comment|/*      * We get here as a result of LCP coming up.      * So even if CHAP was open before, we will       * have to re-authenticate ourselves.      */
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_LISTEN
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapAuthPeer - Authenticate our peer (start server).  */
end_comment

begin_function
name|void
name|ChapAuthPeer
parameter_list|(
name|unit
parameter_list|,
name|our_name
parameter_list|,
name|digest
parameter_list|)
name|int
name|unit
decl_stmt|;
name|char
modifier|*
name|our_name
decl_stmt|;
name|int
name|digest
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
name|cstate
operator|->
name|chal_name
operator|=
name|our_name
expr_stmt|;
name|cstate
operator|->
name|chal_type
operator|=
name|digest
expr_stmt|;
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_INITIAL
operator|||
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_PENDING
condition|)
block|{
comment|/* lower layer isn't up - wait until later */
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_PENDING
expr_stmt|;
return|return;
block|}
name|ChapGenChallenge
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
name|ChapSendChallenge
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
comment|/* crank it up dude! */
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_INITIAL_CHAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapChallengeTimeout - Timeout expired on sending challenge.  */
end_comment

begin_function
specifier|static
name|void
name|ChapChallengeTimeout
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|(
name|chap_state
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* if we aren't sending challenges, don't worry.  then again we */
comment|/* probably shouldn't be here either */
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|!=
name|CHAPSS_INITIAL_CHAL
operator|&&
name|cstate
operator|->
name|serverstate
operator|!=
name|CHAPSS_RECHALLENGE
condition|)
return|return;
if|if
condition|(
name|cstate
operator|->
name|chal_transmits
operator|>=
name|cstate
operator|->
name|max_transmits
condition|)
block|{
comment|/* give up on peer */
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"Peer failed to respond to CHAP challenge"
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_BADAUTH
expr_stmt|;
name|auth_peer_fail
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|PPP_CHAP
argument_list|)
expr_stmt|;
return|return;
block|}
name|ChapSendChallenge
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
comment|/* Re-send challenge */
block|}
end_function

begin_comment
comment|/*  * ChapResponseTimeout - Timeout expired on sending response.  */
end_comment

begin_function
specifier|static
name|void
name|ChapResponseTimeout
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|(
name|chap_state
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* if we aren't sending a response, don't worry. */
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|!=
name|CHAPCS_RESPONSE
condition|)
return|return;
name|ChapSendResponse
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
comment|/* re-send response */
block|}
end_function

begin_comment
comment|/*  * ChapRechallenge - Time to challenge the peer again.  */
end_comment

begin_function
specifier|static
name|void
name|ChapRechallenge
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|(
name|chap_state
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* if we aren't sending a response, don't worry. */
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|!=
name|CHAPSS_OPEN
condition|)
return|return;
name|ChapGenChallenge
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
name|ChapSendChallenge
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_RECHALLENGE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapLowerUp - The lower layer is up.  *  * Start up if we have pending requests.  */
end_comment

begin_function
specifier|static
name|void
name|ChapLowerUp
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_INITIAL
condition|)
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_CLOSED
expr_stmt|;
elseif|else
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_PENDING
condition|)
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_LISTEN
expr_stmt|;
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_INITIAL
condition|)
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_CLOSED
expr_stmt|;
elseif|else
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_PENDING
condition|)
block|{
name|ChapGenChallenge
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
name|ChapSendChallenge
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_INITIAL_CHAL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ChapLowerDown - The lower layer is down.  *  * Cancel all timeouts.  */
end_comment

begin_function
specifier|static
name|void
name|ChapLowerDown
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
comment|/* Timeout(s) pending?  Cancel if so. */
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_INITIAL_CHAL
operator|||
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_RECHALLENGE
condition|)
name|UNTIMEOUT
argument_list|(
name|ChapChallengeTimeout
argument_list|,
name|cstate
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_OPEN
operator|&&
name|cstate
operator|->
name|chal_interval
operator|!=
literal|0
condition|)
name|UNTIMEOUT
argument_list|(
name|ChapRechallenge
argument_list|,
name|cstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_RESPONSE
condition|)
name|UNTIMEOUT
argument_list|(
name|ChapResponseTimeout
argument_list|,
name|cstate
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_INITIAL
expr_stmt|;
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_INITIAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapProtocolReject - Peer doesn't grok CHAP.  */
end_comment

begin_function
specifier|static
name|void
name|ChapProtocolReject
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|!=
name|CHAPSS_INITIAL
operator|&&
name|cstate
operator|->
name|serverstate
operator|!=
name|CHAPSS_CLOSED
condition|)
name|auth_peer_fail
argument_list|(
name|unit
argument_list|,
name|PPP_CHAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|!=
name|CHAPCS_INITIAL
operator|&&
name|cstate
operator|->
name|clientstate
operator|!=
name|CHAPCS_CLOSED
condition|)
name|auth_withpeer_fail
argument_list|(
name|unit
argument_list|,
name|PPP_CHAP
argument_list|)
expr_stmt|;
name|ChapLowerDown
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* shutdown chap */
block|}
end_function

begin_comment
comment|/*  * ChapInput - Input CHAP packet.  */
end_comment

begin_function
specifier|static
name|void
name|ChapInput
parameter_list|(
name|unit
parameter_list|,
name|inpacket
parameter_list|,
name|packet_len
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_char
modifier|*
name|inpacket
decl_stmt|;
name|int
name|packet_len
decl_stmt|;
block|{
name|chap_state
modifier|*
name|cstate
init|=
operator|&
name|chap
index|[
name|unit
index|]
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|u_char
name|code
decl_stmt|,
name|id
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/*      * Parse header (code, id and length).      * If packet too short, drop it.      */
name|inp
operator|=
name|inpacket
expr_stmt|;
if|if
condition|(
name|packet_len
operator|<
name|CHAP_HEADERLEN
condition|)
block|{
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapInput: rcvd short header."
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|id
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|len
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|CHAP_HEADERLEN
condition|)
block|{
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapInput: rcvd illegal length."
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|>
name|packet_len
condition|)
block|{
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapInput: rcvd short packet."
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|-=
name|CHAP_HEADERLEN
expr_stmt|;
comment|/*      * Action depends on code (as in fact it usually does :-).      */
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CHAP_CHALLENGE
case|:
name|ChapReceiveChallenge
argument_list|(
name|cstate
argument_list|,
name|inp
argument_list|,
name|id
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAP_RESPONSE
case|:
name|ChapReceiveResponse
argument_list|(
name|cstate
argument_list|,
name|inp
argument_list|,
name|id
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAP_FAILURE
case|:
name|ChapReceiveFailure
argument_list|(
name|cstate
argument_list|,
name|inp
argument_list|,
name|id
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAP_SUCCESS
case|:
name|ChapReceiveSuccess
argument_list|(
name|cstate
argument_list|,
name|inp
argument_list|,
name|id
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Need code reject? */
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Unknown CHAP code (%d) received."
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * ChapReceiveChallenge - Receive Challenge and send Response.  */
end_comment

begin_function
specifier|static
name|void
name|ChapReceiveChallenge
parameter_list|(
name|cstate
parameter_list|,
name|inp
parameter_list|,
name|id
parameter_list|,
name|len
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|rchallenge_len
decl_stmt|;
name|u_char
modifier|*
name|rchallenge
decl_stmt|;
name|int
name|secret_len
decl_stmt|;
name|char
name|secret
index|[
name|MAXSECRETLEN
index|]
decl_stmt|;
name|char
name|rhostname
index|[
literal|256
index|]
decl_stmt|;
name|MD5_CTX
name|mdContext
decl_stmt|;
name|u_char
name|hash
index|[
name|MD5_SIGNATURE_SIZE
index|]
decl_stmt|;
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveChallenge: Rcvd id %d."
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_CLOSED
operator|||
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_PENDING
condition|)
block|{
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveChallenge: in state %d"
operator|,
name|cstate
operator|->
name|clientstate
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveChallenge: rcvd short packet."
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|GETCHAR
argument_list|(
name|rchallenge_len
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
name|rchallenge_len
expr_stmt|;
comment|/* now name field length */
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveChallenge: rcvd short packet."
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|rchallenge
operator|=
name|inp
expr_stmt|;
name|INCPTR
argument_list|(
name|rchallenge_len
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|rhostname
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|rhostname
argument_list|)
operator|-
literal|1
expr_stmt|;
name|BCOPY
argument_list|(
name|inp
argument_list|,
name|rhostname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rhostname
index|[
name|len
index|]
operator|=
literal|'\000'
expr_stmt|;
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveChallenge: received name field '%s'"
operator|,
name|rhostname
operator|)
argument_list|)
expr_stmt|;
comment|/* Microsoft doesn't send their name back in the PPP packet */
if|if
condition|(
name|remote_name
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
operator|(
name|explicit_remote
operator|||
name|rhostname
index|[
literal|0
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|strncpy
argument_list|(
name|rhostname
argument_list|,
name|remote_name
argument_list|,
sizeof|sizeof
argument_list|(
name|rhostname
argument_list|)
argument_list|)
expr_stmt|;
name|rhostname
index|[
sizeof|sizeof
argument_list|(
name|rhostname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveChallenge: using '%s' as remote name"
operator|,
name|rhostname
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* get secret for authenticating ourselves with the specified host */
if|if
condition|(
operator|!
name|get_secret
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|cstate
operator|->
name|resp_name
argument_list|,
name|rhostname
argument_list|,
name|secret
argument_list|,
operator|&
name|secret_len
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|secret_len
operator|=
literal|0
expr_stmt|;
comment|/* assume null secret if can't find one */
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"No CHAP secret found for authenticating us to %s"
argument_list|,
name|rhostname
argument_list|)
expr_stmt|;
block|}
comment|/* cancel response send timeout if necessary */
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_RESPONSE
condition|)
name|UNTIMEOUT
argument_list|(
name|ChapResponseTimeout
argument_list|,
name|cstate
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|resp_id
operator|=
name|id
expr_stmt|;
name|cstate
operator|->
name|resp_transmits
operator|=
literal|0
expr_stmt|;
comment|/*  generate MD based on negotiated type */
switch|switch
condition|(
name|cstate
operator|->
name|resp_type
condition|)
block|{
case|case
name|CHAP_DIGEST_MD5
case|:
name|MD5Init
argument_list|(
operator|&
name|mdContext
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
operator|&
name|cstate
operator|->
name|resp_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
name|secret
argument_list|,
name|secret_len
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
name|rchallenge
argument_list|,
name|rchallenge_len
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|hash
argument_list|,
operator|&
name|mdContext
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|hash
argument_list|,
name|cstate
operator|->
name|response
argument_list|,
name|MD5_SIGNATURE_SIZE
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|resp_length
operator|=
name|MD5_SIGNATURE_SIZE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|CHAPMS
case|case
name|CHAP_MICROSOFT
case|:
name|ChapMS
argument_list|(
name|cstate
argument_list|,
name|rchallenge
argument_list|,
name|rchallenge_len
argument_list|,
name|secret
argument_list|,
name|secret_len
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"unknown digest type %d"
operator|,
name|cstate
operator|->
name|resp_type
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|BZERO
argument_list|(
name|secret
argument_list|,
sizeof|sizeof
argument_list|(
name|secret
argument_list|)
argument_list|)
expr_stmt|;
name|ChapSendResponse
argument_list|(
name|cstate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapReceiveResponse - Receive and process response.  */
end_comment

begin_function
specifier|static
name|void
name|ChapReceiveResponse
parameter_list|(
name|cstate
parameter_list|,
name|inp
parameter_list|,
name|id
parameter_list|,
name|len
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|u_char
modifier|*
name|remmd
decl_stmt|,
name|remmd_len
decl_stmt|;
name|int
name|secret_len
decl_stmt|,
name|old_state
decl_stmt|;
name|int
name|code
decl_stmt|;
name|char
name|rhostname
index|[
literal|256
index|]
decl_stmt|;
name|MD5_CTX
name|mdContext
decl_stmt|;
name|char
name|secret
index|[
name|MAXSECRETLEN
index|]
decl_stmt|;
name|u_char
name|hash
index|[
name|MD5_SIGNATURE_SIZE
index|]
decl_stmt|;
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveResponse: Rcvd id %d."
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_CLOSED
operator|||
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_PENDING
condition|)
block|{
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveResponse: in state %d"
operator|,
name|cstate
operator|->
name|serverstate
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|id
operator|!=
name|cstate
operator|->
name|chal_id
condition|)
return|return;
comment|/* doesn't match ID of last challenge */
comment|/*      * If we have received a duplicate or bogus Response,      * we have to send the same answer (Success/Failure)      * as we did for the first Response we saw.      */
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_OPEN
condition|)
block|{
name|ChapSendStatus
argument_list|(
name|cstate
argument_list|,
name|CHAP_SUCCESS
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cstate
operator|->
name|serverstate
operator|==
name|CHAPSS_BADAUTH
condition|)
block|{
name|ChapSendStatus
argument_list|(
name|cstate
argument_list|,
name|CHAP_FAILURE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|<
literal|2
condition|)
block|{
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveResponse: rcvd short packet."
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|GETCHAR
argument_list|(
name|remmd_len
argument_list|,
name|inp
argument_list|)
expr_stmt|;
comment|/* get length of MD */
name|remmd
operator|=
name|inp
expr_stmt|;
comment|/* get pointer to MD */
name|INCPTR
argument_list|(
name|remmd_len
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
name|remmd_len
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveResponse: rcvd short packet."
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNTIMEOUT
argument_list|(
name|ChapChallengeTimeout
argument_list|,
name|cstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|rhostname
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|rhostname
argument_list|)
operator|-
literal|1
expr_stmt|;
name|BCOPY
argument_list|(
name|inp
argument_list|,
name|rhostname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|rhostname
index|[
name|len
index|]
operator|=
literal|'\000'
expr_stmt|;
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveResponse: received name field: %s"
operator|,
name|rhostname
operator|)
argument_list|)
expr_stmt|;
comment|/*      * Get secret for authenticating them with us,      * do the hash ourselves, and compare the result.      */
name|code
operator|=
name|CHAP_FAILURE
expr_stmt|;
if|if
condition|(
operator|!
name|get_secret
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|rhostname
argument_list|,
name|cstate
operator|->
name|chal_name
argument_list|,
name|secret
argument_list|,
operator|&
name|secret_len
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"No CHAP secret found for authenticating %s"
argument_list|,
name|rhostname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  generate MD based on negotiated type */
switch|switch
condition|(
name|cstate
operator|->
name|chal_type
condition|)
block|{
case|case
name|CHAP_DIGEST_MD5
case|:
comment|/* only MD5 is defined for now */
if|if
condition|(
name|remmd_len
operator|!=
name|MD5_SIGNATURE_SIZE
condition|)
break|break;
comment|/* it's not even the right length */
name|MD5Init
argument_list|(
operator|&
name|mdContext
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
operator|&
name|cstate
operator|->
name|chal_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
name|secret
argument_list|,
name|secret_len
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|mdContext
argument_list|,
name|cstate
operator|->
name|challenge
argument_list|,
name|cstate
operator|->
name|chal_len
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|hash
argument_list|,
operator|&
name|mdContext
argument_list|)
expr_stmt|;
comment|/* compare local and remote MDs and send the appropriate status */
if|if
condition|(
name|memcmp
argument_list|(
name|hash
argument_list|,
name|remmd
argument_list|,
name|MD5_SIGNATURE_SIZE
argument_list|)
operator|==
literal|0
condition|)
name|code
operator|=
name|CHAP_SUCCESS
expr_stmt|;
comment|/* they are the same! */
break|break;
default|default:
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"unknown digest type %d"
operator|,
name|cstate
operator|->
name|chal_type
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|BZERO
argument_list|(
name|secret
argument_list|,
sizeof|sizeof
argument_list|(
name|secret
argument_list|)
argument_list|)
expr_stmt|;
name|ChapSendStatus
argument_list|(
name|cstate
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|CHAP_SUCCESS
condition|)
block|{
name|old_state
operator|=
name|cstate
operator|->
name|serverstate
expr_stmt|;
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_OPEN
expr_stmt|;
if|if
condition|(
name|old_state
operator|==
name|CHAPSS_INITIAL_CHAL
condition|)
block|{
name|auth_peer_success
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|PPP_CHAP
argument_list|,
name|rhostname
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cstate
operator|->
name|chal_interval
operator|!=
literal|0
condition|)
name|TIMEOUT
argument_list|(
name|ChapRechallenge
argument_list|,
name|cstate
argument_list|,
name|cstate
operator|->
name|chal_interval
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"CHAP peer authentication succeeded for %s"
argument_list|,
name|rhostname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"CHAP peer authentication failed for remote host %s"
argument_list|,
name|rhostname
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|serverstate
operator|=
name|CHAPSS_BADAUTH
expr_stmt|;
name|auth_peer_fail
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|PPP_CHAP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ChapReceiveSuccess - Receive Success  */
end_comment

begin_function
specifier|static
name|void
name|ChapReceiveSuccess
parameter_list|(
name|cstate
parameter_list|,
name|inp
parameter_list|,
name|id
parameter_list|,
name|len
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|u_char
name|id
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveSuccess: Rcvd id %d."
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|==
name|CHAPCS_OPEN
condition|)
comment|/* presumably an answer to a duplicate response */
return|return;
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|!=
name|CHAPCS_RESPONSE
condition|)
block|{
comment|/* don't know what this is */
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveSuccess: in state %d\n"
operator|,
name|cstate
operator|->
name|clientstate
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNTIMEOUT
argument_list|(
name|ChapResponseTimeout
argument_list|,
name|cstate
argument_list|)
expr_stmt|;
comment|/*      * Print message.      */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|PRINTMSG
argument_list|(
name|inp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_OPEN
expr_stmt|;
name|auth_withpeer_success
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|PPP_CHAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapReceiveFailure - Receive failure.  */
end_comment

begin_function
specifier|static
name|void
name|ChapReceiveFailure
parameter_list|(
name|cstate
parameter_list|,
name|inp
parameter_list|,
name|id
parameter_list|,
name|len
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
name|u_char
modifier|*
name|inp
decl_stmt|;
name|u_char
name|id
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveFailure: Rcvd id %d."
operator|,
name|id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstate
operator|->
name|clientstate
operator|!=
name|CHAPCS_RESPONSE
condition|)
block|{
comment|/* don't know what this is */
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapReceiveFailure: in state %d\n"
operator|,
name|cstate
operator|->
name|clientstate
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNTIMEOUT
argument_list|(
name|ChapResponseTimeout
argument_list|,
name|cstate
argument_list|)
expr_stmt|;
comment|/*      * Print message.      */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|PRINTMSG
argument_list|(
name|inp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"CHAP authentication failed"
argument_list|)
expr_stmt|;
name|auth_withpeer_fail
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|PPP_CHAP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapSendChallenge - Send an Authenticate challenge.  */
end_comment

begin_function
specifier|static
name|void
name|ChapSendChallenge
parameter_list|(
name|cstate
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
block|{
name|u_char
modifier|*
name|outp
decl_stmt|;
name|int
name|chal_len
decl_stmt|,
name|name_len
decl_stmt|;
name|int
name|outlen
decl_stmt|;
name|chal_len
operator|=
name|cstate
operator|->
name|chal_len
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|cstate
operator|->
name|chal_name
argument_list|)
expr_stmt|;
name|outlen
operator|=
name|CHAP_HEADERLEN
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
name|chal_len
operator|+
name|name_len
expr_stmt|;
name|outp
operator|=
name|outpacket_buf
expr_stmt|;
name|MAKEHEADER
argument_list|(
name|outp
argument_list|,
name|PPP_CHAP
argument_list|)
expr_stmt|;
comment|/* paste in a CHAP header */
name|PUTCHAR
argument_list|(
name|CHAP_CHALLENGE
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|cstate
operator|->
name|chal_id
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|outlen
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|chal_len
argument_list|,
name|outp
argument_list|)
expr_stmt|;
comment|/* put length of challenge */
name|BCOPY
argument_list|(
name|cstate
operator|->
name|challenge
argument_list|,
name|outp
argument_list|,
name|chal_len
argument_list|)
expr_stmt|;
name|INCPTR
argument_list|(
name|chal_len
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|cstate
operator|->
name|chal_name
argument_list|,
name|outp
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
comment|/* append hostname */
name|output
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|outpacket_buf
argument_list|,
name|outlen
operator|+
name|PPP_HDRLEN
argument_list|)
expr_stmt|;
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapSendChallenge: Sent id %d."
operator|,
name|cstate
operator|->
name|chal_id
operator|)
argument_list|)
expr_stmt|;
name|TIMEOUT
argument_list|(
name|ChapChallengeTimeout
argument_list|,
name|cstate
argument_list|,
name|cstate
operator|->
name|timeouttime
argument_list|)
expr_stmt|;
operator|++
name|cstate
operator|->
name|chal_transmits
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapSendStatus - Send a status response (ack or nak).  */
end_comment

begin_function
specifier|static
name|void
name|ChapSendStatus
parameter_list|(
name|cstate
parameter_list|,
name|code
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
name|int
name|code
decl_stmt|;
block|{
name|u_char
modifier|*
name|outp
decl_stmt|;
name|int
name|outlen
decl_stmt|,
name|msglen
decl_stmt|;
name|char
name|msg
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|CHAP_SUCCESS
condition|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Welcome to %s."
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"I don't like you.  Go 'way."
argument_list|)
expr_stmt|;
name|msglen
operator|=
name|strlen
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|outlen
operator|=
name|CHAP_HEADERLEN
operator|+
name|msglen
expr_stmt|;
name|outp
operator|=
name|outpacket_buf
expr_stmt|;
name|MAKEHEADER
argument_list|(
name|outp
argument_list|,
name|PPP_CHAP
argument_list|)
expr_stmt|;
comment|/* paste in a header */
name|PUTCHAR
argument_list|(
name|code
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|cstate
operator|->
name|chal_id
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|outlen
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|msg
argument_list|,
name|outp
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|output
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|outpacket_buf
argument_list|,
name|outlen
operator|+
name|PPP_HDRLEN
argument_list|)
expr_stmt|;
name|CHAPDEBUG
argument_list|(
operator|(
name|LOG_INFO
operator|,
literal|"ChapSendStatus: Sent code %d, id %d."
operator|,
name|code
operator|,
name|cstate
operator|->
name|chal_id
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapGenChallenge is used to generate a pseudo-random challenge string of  * a pseudo-random length between min_len and max_len.  The challenge  * string and its length are stored in *cstate, and various other fields of  * *cstate are initialized.  */
end_comment

begin_function
specifier|static
name|void
name|ChapGenChallenge
parameter_list|(
name|cstate
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
block|{
name|int
name|chal_len
decl_stmt|;
name|u_char
modifier|*
name|ptr
init|=
name|cstate
operator|->
name|challenge
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* pick a random challenge length between MIN_CHALLENGE_LENGTH and         MAX_CHALLENGE_LENGTH */
name|chal_len
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|drand48
argument_list|()
operator|*
operator|(
name|MAX_CHALLENGE_LENGTH
operator|-
name|MIN_CHALLENGE_LENGTH
operator|)
operator|)
operator|+
name|MIN_CHALLENGE_LENGTH
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|chal_len
operator|=
name|chal_len
expr_stmt|;
name|cstate
operator|->
name|chal_id
operator|=
operator|++
name|cstate
operator|->
name|id
expr_stmt|;
name|cstate
operator|->
name|chal_transmits
operator|=
literal|0
expr_stmt|;
comment|/* generate a random string */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chal_len
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
call|(
name|char
call|)
argument_list|(
name|drand48
argument_list|()
operator|*
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapSendResponse - send a response packet with values as specified  * in *cstate.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|ChapSendResponse
parameter_list|(
name|cstate
parameter_list|)
name|chap_state
modifier|*
name|cstate
decl_stmt|;
block|{
name|u_char
modifier|*
name|outp
decl_stmt|;
name|int
name|outlen
decl_stmt|,
name|md_len
decl_stmt|,
name|name_len
decl_stmt|;
name|md_len
operator|=
name|cstate
operator|->
name|resp_length
expr_stmt|;
name|name_len
operator|=
name|strlen
argument_list|(
name|cstate
operator|->
name|resp_name
argument_list|)
expr_stmt|;
name|outlen
operator|=
name|CHAP_HEADERLEN
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
operator|+
name|md_len
operator|+
name|name_len
expr_stmt|;
name|outp
operator|=
name|outpacket_buf
expr_stmt|;
name|MAKEHEADER
argument_list|(
name|outp
argument_list|,
name|PPP_CHAP
argument_list|)
expr_stmt|;
name|PUTCHAR
argument_list|(
name|CHAP_RESPONSE
argument_list|,
name|outp
argument_list|)
expr_stmt|;
comment|/* we are a response */
name|PUTCHAR
argument_list|(
name|cstate
operator|->
name|resp_id
argument_list|,
name|outp
argument_list|)
expr_stmt|;
comment|/* copy id from challenge packet */
name|PUTSHORT
argument_list|(
name|outlen
argument_list|,
name|outp
argument_list|)
expr_stmt|;
comment|/* packet length */
name|PUTCHAR
argument_list|(
name|md_len
argument_list|,
name|outp
argument_list|)
expr_stmt|;
comment|/* length of MD */
name|BCOPY
argument_list|(
name|cstate
operator|->
name|response
argument_list|,
name|outp
argument_list|,
name|md_len
argument_list|)
expr_stmt|;
comment|/* copy MD to buffer */
name|INCPTR
argument_list|(
name|md_len
argument_list|,
name|outp
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|cstate
operator|->
name|resp_name
argument_list|,
name|outp
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
comment|/* append our name */
comment|/* send the packet */
name|output
argument_list|(
name|cstate
operator|->
name|unit
argument_list|,
name|outpacket_buf
argument_list|,
name|outlen
operator|+
name|PPP_HDRLEN
argument_list|)
expr_stmt|;
name|cstate
operator|->
name|clientstate
operator|=
name|CHAPCS_RESPONSE
expr_stmt|;
name|TIMEOUT
argument_list|(
name|ChapResponseTimeout
argument_list|,
name|cstate
argument_list|,
name|cstate
operator|->
name|timeouttime
argument_list|)
expr_stmt|;
operator|++
name|cstate
operator|->
name|resp_transmits
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ChapPrintPkt - print the contents of a CHAP packet.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ChapCodenames
index|[]
init|=
block|{
literal|"Challenge"
block|,
literal|"Response"
block|,
literal|"Success"
block|,
literal|"Failure"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ChapPrintPkt
argument_list|(
name|p
argument_list|,
name|plen
argument_list|,
name|printer
argument_list|,
name|arg
argument_list|)
name|u_char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|plen
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|printer
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|code
decl_stmt|,
name|id
decl_stmt|,
name|len
decl_stmt|;
name|int
name|clen
decl_stmt|,
name|nlen
decl_stmt|;
name|u_char
name|x
decl_stmt|;
if|if
condition|(
name|plen
operator|<
name|CHAP_HEADERLEN
condition|)
return|return
literal|0
return|;
name|GETCHAR
argument_list|(
name|code
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETCHAR
argument_list|(
name|id
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|len
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|CHAP_HEADERLEN
operator|||
name|len
operator|>
name|plen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|>=
literal|1
operator|&&
name|code
operator|<=
sizeof|sizeof
argument_list|(
name|ChapCodenames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %s"
argument_list|,
name|ChapCodenames
index|[
name|code
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|printer
argument_list|(
name|arg
argument_list|,
literal|" code=0x%x"
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" id=0x%x"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|len
operator|-=
name|CHAP_HEADERLEN
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CHAP_CHALLENGE
case|:
case|case
name|CHAP_RESPONSE
case|:
if|if
condition|(
name|len
operator|<
literal|1
condition|)
break|break;
name|clen
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|clen
operator|+
literal|1
condition|)
break|break;
operator|++
name|p
expr_stmt|;
name|nlen
operator|=
name|len
operator|-
name|clen
operator|-
literal|1
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|clen
operator|>
literal|0
condition|;
operator|--
name|clen
control|)
block|{
name|GETCHAR
argument_list|(
name|x
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|"%.2x"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
name|printer
argument_list|(
name|arg
argument_list|,
literal|">, name = "
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|nlen
argument_list|,
name|printer
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|CHAP_FAILURE
case|:
case|case
name|CHAP_SUCCESS
case|:
name|printer
argument_list|(
name|arg
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|print_string
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
name|len
argument_list|,
name|printer
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
for|for
control|(
name|clen
operator|=
name|len
init|;
name|clen
operator|>
literal|0
condition|;
operator|--
name|clen
control|)
block|{
name|GETCHAR
argument_list|(
name|x
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|printer
argument_list|(
name|arg
argument_list|,
literal|" %.2x"
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|len
operator|+
name|CHAP_HEADERLEN
return|;
block|}
end_block

end_unit

