begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: cd9660_eltorito.c,v 1.17 2011/06/23 02:35:56 enami Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2005 Daniel Watt, Walter Deignan, Ryan Gabrys, Alan  * Perez-Rathke and Ram Vedam.  All rights reserved.  *  * This code was written by Daniel Watt, Walter Deignan, Ryan Gabrys,  * Alan Perez-Rathke and Ram Vedam.  *  * Redistribution and use in source and binary forms, with or  * without modification, are permitted provided that the following  * conditions are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above  *    copyright notice, this list of conditions and the following  *    disclaimer in the documentation and/or other materials provided  *    with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY DANIEL WATT, WALTER DEIGNAN, RYAN  * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL DANIEL WATT, WALTER DEIGNAN, RYAN  * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE,DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"cd9660.h"
end_include

begin_include
include|#
directive|include
file|"cd9660_eltorito.h"
end_include

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|ELTORITO_DPRINTF
parameter_list|(
name|__x
parameter_list|)
value|printf __x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ELTORITO_DPRINTF
parameter_list|(
name|__x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|boot_catalog_entry
modifier|*
name|cd9660_init_boot_catalog_entry
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|boot_catalog_entry
modifier|*
name|cd9660_boot_setup_validation_entry
parameter_list|(
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|boot_catalog_entry
modifier|*
name|cd9660_boot_setup_default_entry
parameter_list|(
name|struct
name|cd9660_boot_image
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|boot_catalog_entry
modifier|*
name|cd9660_boot_setup_section_head
parameter_list|(
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|boot_catalog_entry
modifier|*
name|cd9660_boot_setup_validation_entry
parameter_list|(
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static u_char cd9660_boot_get_system_type(struct cd9660_boot_image *);
endif|#
directive|endif
end_endif

begin_function
name|int
name|cd9660_add_boot_disk
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
specifier|const
name|char
modifier|*
name|boot_info
parameter_list|)
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode_msg
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|char
modifier|*
name|sysname
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|struct
name|cd9660_boot_image
modifier|*
name|new_image
decl_stmt|,
modifier|*
name|tmp_image
decl_stmt|;
name|assert
argument_list|(
name|boot_info
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|boot_info
operator|==
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"Error: Boot disk information must be in the "
literal|"format 'system;filename'"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* First decode the boot information */
name|temp
operator|=
name|estrdup
argument_list|(
name|boot_info
argument_list|)
expr_stmt|;
name|sysname
operator|=
name|temp
expr_stmt|;
name|filename
operator|=
name|strchr
argument_list|(
name|sysname
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"supply boot disk information in the format "
literal|"'system;filename'"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|filename
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Found bootdisk with system %s, and filename %s\n"
argument_list|,
name|sysname
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|new_image
operator|=
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_image
argument_list|)
argument_list|)
expr_stmt|;
name|new_image
operator|->
name|loadSegment
operator|=
literal|0
expr_stmt|;
comment|/* default for now */
comment|/* Decode System */
if|if
condition|(
name|strcmp
argument_list|(
name|sysname
argument_list|,
literal|"i386"
argument_list|)
operator|==
literal|0
condition|)
name|new_image
operator|->
name|system
operator|=
name|ET_SYS_X86
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sysname
argument_list|,
literal|"powerpc"
argument_list|)
operator|==
literal|0
condition|)
name|new_image
operator|->
name|system
operator|=
name|ET_SYS_PPC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sysname
argument_list|,
literal|"macppc"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|sysname
argument_list|,
literal|"mac68k"
argument_list|)
operator|==
literal|0
condition|)
name|new_image
operator|->
name|system
operator|=
name|ET_SYS_MAC
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"boot disk system must be "
literal|"i386, powerpc, macppc, or mac68k"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_image
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|new_image
operator|->
name|filename
operator|=
name|estrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
comment|/* Get information about the file */
if|if
condition|(
name|lstat
argument_list|(
name|new_image
operator|->
name|filename
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s: lstat(\"%s\")"
argument_list|,
name|__func__
argument_list|,
name|new_image
operator|->
name|filename
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|stbuf
operator|.
name|st_size
condition|)
block|{
case|case
literal|1440
operator|*
literal|1024
case|:
name|new_image
operator|->
name|targetMode
operator|=
name|ET_MEDIA_144FDD
expr_stmt|;
name|mode_msg
operator|=
literal|"Assigned boot image to 1.44 emulation mode"
expr_stmt|;
break|break;
case|case
literal|1200
operator|*
literal|1024
case|:
name|new_image
operator|->
name|targetMode
operator|=
name|ET_MEDIA_12FDD
expr_stmt|;
name|mode_msg
operator|=
literal|"Assigned boot image to 1.2 emulation mode"
expr_stmt|;
break|break;
case|case
literal|2880
operator|*
literal|1024
case|:
name|new_image
operator|->
name|targetMode
operator|=
name|ET_MEDIA_288FDD
expr_stmt|;
name|mode_msg
operator|=
literal|"Assigned boot image to 2.88 emulation mode"
expr_stmt|;
break|break;
default|default:
name|new_image
operator|->
name|targetMode
operator|=
name|ET_MEDIA_NOEM
expr_stmt|;
name|mode_msg
operator|=
literal|"Assigned boot image to no emulation mode"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|mode_msg
argument_list|)
expr_stmt|;
name|new_image
operator|->
name|size
operator|=
name|stbuf
operator|.
name|st_size
expr_stmt|;
name|new_image
operator|->
name|num_sectors
operator|=
name|howmany
argument_list|(
name|new_image
operator|->
name|size
argument_list|,
name|diskStructure
operator|->
name|sectorSize
argument_list|)
operator|*
name|howmany
argument_list|(
name|diskStructure
operator|->
name|sectorSize
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"New image has size %d, uses %d 512-byte sectors\n"
argument_list|,
name|new_image
operator|->
name|size
argument_list|,
name|new_image
operator|->
name|num_sectors
argument_list|)
expr_stmt|;
block|}
name|new_image
operator|->
name|sector
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Bootable by default */
name|new_image
operator|->
name|bootable
operator|=
name|ET_BOOTABLE
expr_stmt|;
comment|/* Add boot disk */
comment|/* Group images for the same platform together. */
name|TAILQ_FOREACH
argument_list|(
argument|tmp_image
argument_list|,
argument|&diskStructure->boot_images
argument_list|,
argument|image_list
argument_list|)
block|{
if|if
condition|(
name|tmp_image
operator|->
name|system
operator|!=
name|new_image
operator|->
name|system
condition|)
break|break;
block|}
if|if
condition|(
name|tmp_image
operator|==
name|NULL
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|diskStructure
operator|->
name|boot_images
argument_list|,
name|new_image
argument_list|,
name|image_list
argument_list|)
expr_stmt|;
block|}
else|else
name|TAILQ_INSERT_BEFORE
argument_list|(
name|tmp_image
argument_list|,
name|new_image
argument_list|,
name|image_list
argument_list|)
expr_stmt|;
name|new_image
operator|->
name|serialno
operator|=
name|diskStructure
operator|->
name|image_serialno
operator|++
expr_stmt|;
comment|/* TODO : Need to do anything about the boot image in the tree? */
name|diskStructure
operator|->
name|is_bootable
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|cd9660_eltorito_add_boot_option
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
specifier|const
name|char
modifier|*
name|option_string
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|eptr
decl_stmt|;
name|struct
name|cd9660_boot_image
modifier|*
name|image
decl_stmt|;
name|assert
argument_list|(
name|option_string
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Find the last image added */
name|TAILQ_FOREACH
argument_list|(
argument|image
argument_list|,
argument|&diskStructure->boot_images
argument_list|,
argument|image_list
argument_list|)
block|{
if|if
condition|(
name|image
operator|->
name|serialno
operator|+
literal|1
operator|==
name|diskStructure
operator|->
name|image_serialno
condition|)
break|break;
block|}
if|if
condition|(
name|image
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Attempted to add boot option, "
literal|"but no boot images have been specified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|option_string
argument_list|,
literal|"no-emul-boot"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image
operator|->
name|targetMode
operator|=
name|ET_MEDIA_NOEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|option_string
argument_list|,
literal|"no-boot"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image
operator|->
name|bootable
operator|=
name|ET_NOT_BOOTABLE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|option_string
argument_list|,
literal|"hard-disk-boot"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image
operator|->
name|targetMode
operator|=
name|ET_MEDIA_HDD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|option_string
argument_list|,
literal|"boot-load-segment"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|image
operator|->
name|loadSegment
operator|=
name|strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|eptr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|==
name|value
operator|||
operator|*
name|eptr
operator|!=
literal|'\0'
operator|||
name|errno
operator|!=
name|ERANGE
condition|)
block|{
name|warn
argument_list|(
literal|"%s: strtoul"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|boot_catalog_entry
modifier|*
name|cd9660_init_boot_catalog_entry
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|boot_catalog_entry
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|boot_catalog_entry
modifier|*
name|cd9660_boot_setup_validation_entry
parameter_list|(
name|char
name|sys
parameter_list|)
block|{
name|struct
name|boot_catalog_entry
modifier|*
name|entry
decl_stmt|;
name|boot_catalog_validation_entry
modifier|*
name|ve
decl_stmt|;
name|int16_t
name|checksum
decl_stmt|;
name|unsigned
name|char
modifier|*
name|csptr
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|entry
operator|=
name|cd9660_init_boot_catalog_entry
argument_list|()
expr_stmt|;
name|ve
operator|=
operator|&
name|entry
operator|->
name|entry_data
operator|.
name|VE
expr_stmt|;
name|ve
operator|->
name|header_id
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|ve
operator|->
name|platform_id
index|[
literal|0
index|]
operator|=
name|sys
expr_stmt|;
name|ve
operator|->
name|key
index|[
literal|0
index|]
operator|=
literal|0x55
expr_stmt|;
name|ve
operator|->
name|key
index|[
literal|1
index|]
operator|=
literal|0xAA
expr_stmt|;
comment|/* Calculate checksum */
name|checksum
operator|=
literal|0
expr_stmt|;
name|cd9660_721
argument_list|(
literal|0
argument_list|,
name|ve
operator|->
name|checksum
argument_list|)
expr_stmt|;
name|csptr
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ve
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ve
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|checksum
operator|+=
operator|(
name|int16_t
operator|)
name|csptr
index|[
name|i
index|]
expr_stmt|;
name|checksum
operator|+=
literal|256
operator|*
operator|(
name|int16_t
operator|)
name|csptr
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|checksum
operator|=
operator|-
name|checksum
expr_stmt|;
name|cd9660_721
argument_list|(
name|checksum
argument_list|,
name|ve
operator|->
name|checksum
argument_list|)
expr_stmt|;
name|ELTORITO_DPRINTF
argument_list|(
operator|(
literal|"%s: header_id %d, platform_id %d, key[0] %d, key[1] %d, "
literal|"checksum %04x\n"
operator|,
name|__func__
operator|,
name|ve
operator|->
name|header_id
index|[
literal|0
index|]
operator|,
name|ve
operator|->
name|platform_id
index|[
literal|0
index|]
operator|,
name|ve
operator|->
name|key
index|[
literal|0
index|]
operator|,
name|ve
operator|->
name|key
index|[
literal|1
index|]
operator|,
name|checksum
operator|)
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|boot_catalog_entry
modifier|*
name|cd9660_boot_setup_default_entry
parameter_list|(
name|struct
name|cd9660_boot_image
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|boot_catalog_entry
modifier|*
name|default_entry
decl_stmt|;
name|boot_catalog_initial_entry
modifier|*
name|ie
decl_stmt|;
name|default_entry
operator|=
name|cd9660_init_boot_catalog_entry
argument_list|()
expr_stmt|;
if|if
condition|(
name|default_entry
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|ie
operator|=
operator|&
name|default_entry
operator|->
name|entry_data
operator|.
name|IE
expr_stmt|;
name|ie
operator|->
name|boot_indicator
index|[
literal|0
index|]
operator|=
name|disk
operator|->
name|bootable
expr_stmt|;
name|ie
operator|->
name|media_type
index|[
literal|0
index|]
operator|=
name|disk
operator|->
name|targetMode
expr_stmt|;
name|cd9660_721
argument_list|(
name|disk
operator|->
name|loadSegment
argument_list|,
name|ie
operator|->
name|load_segment
argument_list|)
expr_stmt|;
name|ie
operator|->
name|system_type
index|[
literal|0
index|]
operator|=
name|disk
operator|->
name|system
expr_stmt|;
name|cd9660_721
argument_list|(
name|disk
operator|->
name|num_sectors
argument_list|,
name|ie
operator|->
name|sector_count
argument_list|)
expr_stmt|;
name|cd9660_731
argument_list|(
name|disk
operator|->
name|sector
argument_list|,
name|ie
operator|->
name|load_rba
argument_list|)
expr_stmt|;
name|ELTORITO_DPRINTF
argument_list|(
operator|(
literal|"%s: boot indicator %d, media type %d, "
literal|"load segment %04x, system type %d, sector count %d, "
literal|"load rba %d\n"
operator|,
name|__func__
operator|,
name|ie
operator|->
name|boot_indicator
index|[
literal|0
index|]
operator|,
name|ie
operator|->
name|media_type
index|[
literal|0
index|]
operator|,
name|disk
operator|->
name|loadSegment
operator|,
name|ie
operator|->
name|system_type
index|[
literal|0
index|]
operator|,
name|disk
operator|->
name|num_sectors
operator|,
name|disk
operator|->
name|sector
operator|)
argument_list|)
expr_stmt|;
return|return
name|default_entry
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|boot_catalog_entry
modifier|*
name|cd9660_boot_setup_section_head
parameter_list|(
name|char
name|platform
parameter_list|)
block|{
name|struct
name|boot_catalog_entry
modifier|*
name|entry
decl_stmt|;
name|boot_catalog_section_header
modifier|*
name|sh
decl_stmt|;
name|entry
operator|=
name|cd9660_init_boot_catalog_entry
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sh
operator|=
operator|&
name|entry
operator|->
name|entry_data
operator|.
name|SH
expr_stmt|;
comment|/* More by default. The last one will manually be set to 0x91 */
name|sh
operator|->
name|header_indicator
index|[
literal|0
index|]
operator|=
name|ET_SECTION_HEADER_MORE
expr_stmt|;
name|sh
operator|->
name|platform_id
index|[
literal|0
index|]
operator|=
name|platform
expr_stmt|;
name|sh
operator|->
name|num_section_entries
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|boot_catalog_entry
modifier|*
name|cd9660_boot_setup_section_entry
parameter_list|(
name|struct
name|cd9660_boot_image
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|boot_catalog_entry
modifier|*
name|entry
decl_stmt|;
name|boot_catalog_section_entry
modifier|*
name|se
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|cd9660_init_boot_catalog_entry
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|se
operator|=
operator|&
name|entry
operator|->
name|entry_data
operator|.
name|SE
expr_stmt|;
name|se
operator|->
name|boot_indicator
index|[
literal|0
index|]
operator|=
name|ET_BOOTABLE
expr_stmt|;
name|se
operator|->
name|media_type
index|[
literal|0
index|]
operator|=
name|disk
operator|->
name|targetMode
expr_stmt|;
name|cd9660_721
argument_list|(
name|disk
operator|->
name|loadSegment
argument_list|,
name|se
operator|->
name|load_segment
argument_list|)
expr_stmt|;
name|cd9660_721
argument_list|(
name|disk
operator|->
name|num_sectors
argument_list|,
name|se
operator|->
name|sector_count
argument_list|)
expr_stmt|;
name|cd9660_731
argument_list|(
name|disk
operator|->
name|sector
argument_list|,
name|se
operator|->
name|load_rba
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static u_char cd9660_boot_get_system_type(struct cd9660_boot_image *disk) {
comment|/* 		For hard drive booting, we need to examine the MBR to figure 		out what the partition type is 	*/
end_comment

begin_endif
unit|return 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set up the BVD, Boot catalog, and the boot entries, but do no writing  */
end_comment

begin_function
name|int
name|cd9660_setup_boot
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|int
name|first_sector
parameter_list|)
block|{
name|int
name|sector
decl_stmt|;
name|int
name|used_sectors
decl_stmt|;
name|int
name|num_entries
init|=
literal|0
decl_stmt|;
name|int
name|catalog_sectors
decl_stmt|;
name|struct
name|boot_catalog_entry
modifier|*
name|x86_head
decl_stmt|,
modifier|*
name|mac_head
decl_stmt|,
modifier|*
name|ppc_head
decl_stmt|,
modifier|*
name|valid_entry
decl_stmt|,
modifier|*
name|default_entry
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
modifier|*
name|head
decl_stmt|,
modifier|*
modifier|*
name|headp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|cd9660_boot_image
modifier|*
name|tmp_disk
decl_stmt|;
name|headp
operator|=
name|NULL
expr_stmt|;
name|x86_head
operator|=
name|mac_head
operator|=
name|ppc_head
operator|=
name|NULL
expr_stmt|;
comment|/* If there are no boot disks, don't bother building boot information */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|diskStructure
operator|->
name|boot_images
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Point to catalog: For now assume it consumes one sector */
name|ELTORITO_DPRINTF
argument_list|(
operator|(
literal|"Boot catalog will go in sector %d\n"
operator|,
name|first_sector
operator|)
argument_list|)
expr_stmt|;
name|diskStructure
operator|->
name|boot_catalog_sector
operator|=
name|first_sector
expr_stmt|;
name|cd9660_bothendian_dword
argument_list|(
name|first_sector
argument_list|,
name|diskStructure
operator|->
name|boot_descriptor
operator|->
name|boot_catalog_pointer
argument_list|)
expr_stmt|;
comment|/* Step 1: Generate boot catalog */
comment|/* Step 1a: Validation entry */
name|valid_entry
operator|=
name|cd9660_boot_setup_validation_entry
argument_list|(
name|ET_SYS_X86
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid_entry
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * Count how many boot images there are, 	 * and how many sectors they consume. 	 */
name|num_entries
operator|=
literal|1
expr_stmt|;
name|used_sectors
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tmp_disk
argument_list|,
argument|&diskStructure->boot_images
argument_list|,
argument|image_list
argument_list|)
block|{
name|used_sectors
operator|+=
name|tmp_disk
operator|->
name|num_sectors
expr_stmt|;
comment|/* One default entry per image */
name|num_entries
operator|++
expr_stmt|;
block|}
name|catalog_sectors
operator|=
name|howmany
argument_list|(
name|num_entries
operator|*
literal|0x20
argument_list|,
name|diskStructure
operator|->
name|sectorSize
argument_list|)
expr_stmt|;
name|used_sectors
operator|+=
name|catalog_sectors
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: there will be %i entries consuming %i sectors. "
literal|"Catalog is %i sectors\n"
argument_list|,
name|__func__
argument_list|,
name|num_entries
argument_list|,
name|used_sectors
argument_list|,
name|catalog_sectors
argument_list|)
expr_stmt|;
block|}
comment|/* Populate sector numbers */
name|sector
operator|=
name|first_sector
operator|+
name|catalog_sectors
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tmp_disk
argument_list|,
argument|&diskStructure->boot_images
argument_list|,
argument|image_list
argument_list|)
block|{
name|tmp_disk
operator|->
name|sector
operator|=
name|sector
expr_stmt|;
name|sector
operator|+=
name|tmp_disk
operator|->
name|num_sectors
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|diskStructure
operator|->
name|boot_entries
argument_list|,
name|valid_entry
argument_list|,
name|ll_struct
argument_list|)
expr_stmt|;
comment|/* Step 1b: Initial/default entry */
comment|/* TODO : PARAM */
name|tmp_disk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|diskStructure
operator|->
name|boot_images
argument_list|)
expr_stmt|;
name|default_entry
operator|=
name|cd9660_boot_setup_default_entry
argument_list|(
name|tmp_disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|default_entry
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Error: memory allocation failed in cd9660_setup_boot"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|LIST_INSERT_AFTER
argument_list|(
name|valid_entry
argument_list|,
name|default_entry
argument_list|,
name|ll_struct
argument_list|)
expr_stmt|;
comment|/* Todo: multiple default entries? */
name|tmp_disk
operator|=
name|TAILQ_NEXT
argument_list|(
name|tmp_disk
argument_list|,
name|image_list
argument_list|)
expr_stmt|;
name|temp
operator|=
name|default_entry
expr_stmt|;
comment|/* If multiple boot images are given : */
while|while
condition|(
name|tmp_disk
operator|!=
name|NULL
condition|)
block|{
comment|/* Step 2: Section header */
switch|switch
condition|(
name|tmp_disk
operator|->
name|system
condition|)
block|{
case|case
name|ET_SYS_X86
case|:
name|headp
operator|=
operator|&
name|x86_head
expr_stmt|;
break|break;
case|case
name|ET_SYS_PPC
case|:
name|headp
operator|=
operator|&
name|ppc_head
expr_stmt|;
break|break;
case|case
name|ET_SYS_MAC
case|:
name|headp
operator|=
operator|&
name|mac_head
expr_stmt|;
break|break;
default|default:
name|warnx
argument_list|(
literal|"%s: internal error: unknown system type"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|*
name|headp
operator|==
name|NULL
condition|)
block|{
name|head
operator|=
name|cd9660_boot_setup_section_head
argument_list|(
name|tmp_disk
operator|->
name|system
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Error: memory allocation failed in "
literal|"cd9660_setup_boot"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|LIST_INSERT_AFTER
argument_list|(
name|default_entry
argument_list|,
name|head
argument_list|,
name|ll_struct
argument_list|)
expr_stmt|;
operator|*
name|headp
operator|=
name|head
expr_stmt|;
block|}
else|else
name|head
operator|=
operator|*
name|headp
expr_stmt|;
name|head
operator|->
name|entry_data
operator|.
name|SH
operator|.
name|num_section_entries
index|[
literal|0
index|]
operator|++
expr_stmt|;
comment|/* Step 2a: Section entry and extensions */
name|temp
operator|=
name|cd9660_boot_setup_section_entry
argument_list|(
name|tmp_disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: cd9660_boot_setup_section_entry"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
operator|(
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|head
argument_list|,
name|ll_struct
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|next
operator|->
name|entry_type
operator|==
name|ET_ENTRY_SE
condition|)
name|head
operator|=
name|next
expr_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|head
argument_list|,
name|temp
argument_list|,
name|ll_struct
argument_list|)
expr_stmt|;
name|tmp_disk
operator|=
name|TAILQ_NEXT
argument_list|(
name|tmp_disk
argument_list|,
name|image_list
argument_list|)
expr_stmt|;
block|}
comment|/* TODO: Remaining boot disks when implemented */
return|return
name|first_sector
operator|+
name|used_sectors
return|;
block|}
end_function

begin_function
name|int
name|cd9660_setup_boot_volume_descriptor
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|volume_descriptor
modifier|*
name|bvd
parameter_list|)
block|{
name|boot_volume_descriptor
modifier|*
name|bvdData
init|=
operator|(
name|boot_volume_descriptor
operator|*
operator|)
name|bvd
operator|->
name|volumeDescriptorData
decl_stmt|;
name|bvdData
operator|->
name|boot_record_indicator
index|[
literal|0
index|]
operator|=
name|ISO_VOLUME_DESCRIPTOR_BOOT
expr_stmt|;
name|memcpy
argument_list|(
name|bvdData
operator|->
name|identifier
argument_list|,
name|ISO_VOLUME_DESCRIPTOR_STANDARD_ID
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|bvdData
operator|->
name|version
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|bvdData
operator|->
name|boot_system_identifier
argument_list|,
name|ET_ID
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bvdData
operator|->
name|identifier
argument_list|,
name|ISO_VOLUME_DESCRIPTOR_STANDARD_ID
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|diskStructure
operator|->
name|boot_descriptor
operator|=
operator|(
name|boot_volume_descriptor
operator|*
operator|)
name|bvd
operator|->
name|volumeDescriptorData
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cd9660_write_mbr_partition_entry
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|int
name|idx
parameter_list|,
name|off_t
name|sector_start
parameter_list|,
name|off_t
name|nsectors
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|uint8_t
name|val
decl_stmt|;
name|uint32_t
name|lba
decl_stmt|;
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|idx
argument_list|)
operator|*
literal|16
operator|+
literal|0x1be
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0x80
expr_stmt|;
comment|/* Bootable */
name|fwrite
argument_list|(
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0xff
expr_stmt|;
comment|/* CHS begin */
name|fwrite
argument_list|(
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|val
operator|=
name|type
expr_stmt|;
comment|/* Part type */
name|fwrite
argument_list|(
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|val
operator|=
literal|0xff
expr_stmt|;
comment|/* CHS end */
name|fwrite
argument_list|(
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* LBA extent */
name|lba
operator|=
name|htole32
argument_list|(
name|sector_start
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|lba
argument_list|,
sizeof|sizeof
argument_list|(
name|lba
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|lba
operator|=
name|htole32
argument_list|(
name|nsectors
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|lba
argument_list|,
sizeof|sizeof
argument_list|(
name|lba
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cd9660_write_apm_partition_entry
parameter_list|(
name|FILE
modifier|*
name|fd
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
name|total_partitions
parameter_list|,
name|off_t
name|sector_start
parameter_list|,
name|off_t
name|nsectors
parameter_list|,
name|off_t
name|sector_size
parameter_list|,
specifier|const
name|char
modifier|*
name|part_name
parameter_list|,
specifier|const
name|char
modifier|*
name|part_type
parameter_list|)
block|{
name|uint32_t
name|apm32
decl_stmt|,
name|part_status
decl_stmt|;
name|uint16_t
name|apm16
decl_stmt|;
comment|/* See Apple Tech Note 1189 for the details about the pmPartStatus 	 * flags. 	 * Below the flags which are default: 	 * - IsValid     0x01 	 * - IsAllocated 0x02 	 * - IsReadable  0x10 	 * - IsWritable  0x20 	 */
name|part_status
operator|=
literal|0x01
operator||
literal|0x02
operator||
literal|0x10
operator||
literal|0x20
expr_stmt|;
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|idx
operator|+
literal|1
argument_list|)
operator|*
name|sector_size
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
comment|/* Signature */
name|apm16
operator|=
name|htobe16
argument_list|(
literal|0x504d
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm16
argument_list|,
sizeof|sizeof
argument_list|(
name|apm16
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|apm16
operator|=
literal|0
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm16
argument_list|,
sizeof|sizeof
argument_list|(
name|apm16
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* Total number of partitions */
name|apm32
operator|=
name|htobe32
argument_list|(
name|total_partitions
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm32
argument_list|,
sizeof|sizeof
argument_list|(
name|apm32
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* Bounds */
name|apm32
operator|=
name|htobe32
argument_list|(
name|sector_start
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm32
argument_list|,
sizeof|sizeof
argument_list|(
name|apm32
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|apm32
operator|=
name|htobe32
argument_list|(
name|nsectors
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm32
argument_list|,
sizeof|sizeof
argument_list|(
name|apm32
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|part_name
argument_list|,
name|strlen
argument_list|(
name|part_name
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|32
operator|-
name|strlen
argument_list|(
name|part_name
argument_list|)
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|part_type
argument_list|,
name|strlen
argument_list|(
name|part_type
argument_list|)
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|32
operator|-
name|strlen
argument_list|(
name|part_type
argument_list|)
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|apm32
operator|=
literal|0
expr_stmt|;
comment|/* pmLgDataStart */
name|fwrite
argument_list|(
operator|&
name|apm32
argument_list|,
sizeof|sizeof
argument_list|(
name|apm32
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* pmDataCnt */
name|apm32
operator|=
name|htobe32
argument_list|(
name|nsectors
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm32
argument_list|,
sizeof|sizeof
argument_list|(
name|apm32
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* pmPartStatus */
name|apm32
operator|=
name|htobe32
argument_list|(
name|part_status
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm32
argument_list|,
sizeof|sizeof
argument_list|(
name|apm32
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cd9660_write_boot
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|FILE
modifier|*
name|fd
parameter_list|)
block|{
name|struct
name|boot_catalog_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|cd9660_boot_image
modifier|*
name|t
decl_stmt|;
name|int
name|apm_partitions
init|=
literal|0
decl_stmt|;
name|int
name|mbr_partitions
init|=
literal|0
decl_stmt|;
comment|/* write boot catalog */
if|if
condition|(
name|fseeko
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|diskStructure
operator|->
name|boot_catalog_sector
operator|*
name|diskStructure
operator|->
name|sectorSize
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fseeko"
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Writing boot catalog to sector %"
name|PRId64
literal|"\n"
argument_list|,
name|diskStructure
operator|->
name|boot_catalog_sector
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|e
argument_list|,
argument|&diskStructure->boot_entries
argument_list|,
argument|ll_struct
argument_list|)
block|{
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Writing catalog entry of type %d\n"
argument_list|,
name|e
operator|->
name|entry_type
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * It doesn't matter which one gets written 		 * since they are the same size 		 */
name|fwrite
argument_list|(
operator|&
operator|(
name|e
operator|->
name|entry_data
operator|.
name|VE
operator|)
argument_list|,
literal|1
argument_list|,
literal|32
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Finished writing boot catalog\n"
argument_list|)
expr_stmt|;
comment|/* copy boot images */
name|TAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&diskStructure->boot_images
argument_list|,
argument|image_list
argument_list|)
block|{
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Writing boot image from %s to sectors %d\n"
argument_list|,
name|t
operator|->
name|filename
argument_list|,
name|t
operator|->
name|sector
argument_list|)
expr_stmt|;
block|}
name|cd9660_copy_file
argument_list|(
name|diskStructure
argument_list|,
name|fd
argument_list|,
name|t
operator|->
name|sector
argument_list|,
name|t
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|system
operator|==
name|ET_SYS_MAC
condition|)
name|apm_partitions
operator|++
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|system
operator|==
name|ET_SYS_PPC
condition|)
name|mbr_partitions
operator|++
expr_stmt|;
block|}
comment|/* some systems need partition tables as well */
if|if
condition|(
name|mbr_partitions
operator|>
literal|0
operator|||
name|diskStructure
operator|->
name|chrp_boot
condition|)
block|{
name|uint16_t
name|sig
decl_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|0x1fe
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|sig
operator|=
name|htole16
argument_list|(
literal|0xaa55
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|mbr_partitions
operator|=
literal|0
expr_stmt|;
comment|/* Write ISO9660 descriptor, enclosing the whole disk */
if|if
condition|(
name|diskStructure
operator|->
name|chrp_boot
condition|)
name|cd9660_write_mbr_partition_entry
argument_list|(
name|fd
argument_list|,
name|mbr_partitions
operator|++
argument_list|,
literal|0
argument_list|,
name|diskStructure
operator|->
name|totalSectors
operator|*
operator|(
name|diskStructure
operator|->
name|sectorSize
operator|/
literal|512
operator|)
argument_list|,
literal|0x96
argument_list|)
expr_stmt|;
comment|/* Write all partition entries */
name|TAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&diskStructure->boot_images
argument_list|,
argument|image_list
argument_list|)
block|{
if|if
condition|(
name|t
operator|->
name|system
operator|!=
name|ET_SYS_PPC
condition|)
continue|continue;
name|cd9660_write_mbr_partition_entry
argument_list|(
name|fd
argument_list|,
name|mbr_partitions
operator|++
argument_list|,
name|t
operator|->
name|sector
operator|*
operator|(
name|diskStructure
operator|->
name|sectorSize
operator|/
literal|512
operator|)
argument_list|,
name|t
operator|->
name|num_sectors
operator|*
operator|(
name|diskStructure
operator|->
name|sectorSize
operator|/
literal|512
operator|)
argument_list|,
literal|0x41
comment|/* PReP Boot */
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|apm_partitions
operator|>
literal|0
condition|)
block|{
comment|/* Write DDR and global APM info */
name|uint32_t
name|apm32
decl_stmt|;
name|uint16_t
name|apm16
decl_stmt|;
name|int
name|total_parts
decl_stmt|;
name|fseek
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|apm16
operator|=
name|htobe16
argument_list|(
literal|0x4552
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm16
argument_list|,
sizeof|sizeof
argument_list|(
name|apm16
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* Device block size */
name|apm16
operator|=
name|htobe16
argument_list|(
literal|512
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm16
argument_list|,
sizeof|sizeof
argument_list|(
name|apm16
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* Device block count */
name|apm32
operator|=
name|htobe32
argument_list|(
name|diskStructure
operator|->
name|totalSectors
operator|*
operator|(
name|diskStructure
operator|->
name|sectorSize
operator|/
literal|512
operator|)
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm32
argument_list|,
sizeof|sizeof
argument_list|(
name|apm32
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* Device type/id */
name|apm16
operator|=
name|htobe16
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm16
argument_list|,
sizeof|sizeof
argument_list|(
name|apm16
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
operator|&
name|apm16
argument_list|,
sizeof|sizeof
argument_list|(
name|apm16
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* Count total needed entries */
name|total_parts
operator|=
literal|2
operator|+
name|apm_partitions
expr_stmt|;
comment|/* Self + ISO9660 */
comment|/* Write self-descriptor */
name|cd9660_write_apm_partition_entry
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|,
name|total_parts
argument_list|,
literal|1
argument_list|,
name|total_parts
argument_list|,
literal|512
argument_list|,
literal|"Apple"
argument_list|,
literal|"Apple_partition_map"
argument_list|)
expr_stmt|;
comment|/* Write all partition entries */
name|apm_partitions
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|t
argument_list|,
argument|&diskStructure->boot_images
argument_list|,
argument|image_list
argument_list|)
block|{
if|if
condition|(
name|t
operator|->
name|system
operator|!=
name|ET_SYS_MAC
condition|)
continue|continue;
name|cd9660_write_apm_partition_entry
argument_list|(
name|fd
argument_list|,
literal|1
operator|+
name|apm_partitions
operator|++
argument_list|,
name|total_parts
argument_list|,
name|t
operator|->
name|sector
operator|*
operator|(
name|diskStructure
operator|->
name|sectorSize
operator|/
literal|512
operator|)
argument_list|,
name|t
operator|->
name|num_sectors
operator|*
operator|(
name|diskStructure
operator|->
name|sectorSize
operator|/
literal|512
operator|)
argument_list|,
literal|512
argument_list|,
literal|"CD Boot"
argument_list|,
literal|"Apple_Bootstrap"
argument_list|)
expr_stmt|;
block|}
comment|/* Write ISO9660 descriptor, enclosing the whole disk */
name|cd9660_write_apm_partition_entry
argument_list|(
name|fd
argument_list|,
literal|2
operator|+
name|apm_partitions
argument_list|,
name|total_parts
argument_list|,
literal|0
argument_list|,
name|diskStructure
operator|->
name|totalSectors
operator|*
operator|(
name|diskStructure
operator|->
name|sectorSize
operator|/
literal|512
operator|)
argument_list|,
literal|512
argument_list|,
literal|"ISO9660"
argument_list|,
literal|"CD_ROM_Mode_1"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

