begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: cd9660.c,v 1.32 2011/08/23 17:09:11 christos Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2005 Daniel Watt, Walter Deignan, Ryan Gabrys, Alan  * Perez-Rathke and Ram Vedam.  All rights reserved.  *  * This code was written by Daniel Watt, Walter Deignan, Ryan Gabrys,  * Alan Perez-Rathke and Ram Vedam.  *  * Redistribution and use in source and binary forms, with or  * without modification, are permitted provided that the following  * conditions are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above  *    copyright notice, this list of conditions and the following  *    disclaimer in the documentation and/or other materials provided  *    with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY DANIEL WATT, WALTER DEIGNAN, RYAN  * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL DANIEL WATT, WALTER DEIGNAN, RYAN  * GABRYS, ALAN PEREZ-RATHKE AND RAM VEDAM BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE,DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Wasabi Systems, Inc.  * All rights reserved.  *  * Written by Luke Mewburn for Wasabi Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed for the NetBSD Project by  *      Wasabi Systems, Inc.  * 4. The name of Wasabi Systems, Inc. may not be used to endorse  *    or promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_include
include|#
directive|include
file|"makefs.h"
end_include

begin_include
include|#
directive|include
file|"cd9660.h"
end_include

begin_include
include|#
directive|include
file|"cd9660/iso9660_rrip.h"
end_include

begin_include
include|#
directive|include
file|"cd9660/cd9660_archimedes.h"
end_include

begin_function_decl
specifier|static
name|void
name|cd9660_finalize_PVD
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cd9660node
modifier|*
name|cd9660_allocate_cd9660node
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd9660_set_defaults
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_arguments_set_string
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd9660_populate_iso_dir_record
parameter_list|(
name|struct
name|_iso_directory_record_cd9660
modifier|*
parameter_list|,
name|u_char
parameter_list|,
name|u_char
parameter_list|,
name|u_char
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd9660_setup_root_node
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_setup_volume_descriptors
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int cd9660_fill_extended_attribute_record(cd9660node *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|cd9660_sort_nodes
parameter_list|(
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_translate_node_common
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_translate_node
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
name|fsnode
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_compare_filename
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd9660_sorted_child_insert
parameter_list|(
name|cd9660node
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_handle_collisions
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cd9660node
modifier|*
name|cd9660_rename_filename
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd9660_copy_filenames
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd9660_sorting_nodes
parameter_list|(
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_count_collisions
parameter_list|(
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cd9660node
modifier|*
name|cd9660_rrip_move_directory
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_add_dot_records
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd9660_convert_structure
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
name|fsnode
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd9660_free_structure
parameter_list|(
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_generate_path_table
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_level1_convert_filename
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_level2_convert_filename
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int cd9660_joliet_convert_filename(iso9660_disk *, const char *, char *,     int);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|cd9660_convert_filename
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd9660_populate_dot_records
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|cd9660_compute_offsets
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int cd9660_copy_stat_info(cd9660node *, cd9660node *, int);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|cd9660node
modifier|*
name|cd9660_create_virtual_entry
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cd9660node
modifier|*
name|cd9660_create_file
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cd9660node
modifier|*
name|cd9660_create_directory
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|,
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|cd9660node
modifier|*
name|cd9660_create_special_directory
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
name|u_char
parameter_list|,
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cd9660_add_generic_bootimage
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Allocate and initialize a cd9660node  * @returns struct cd9660node * Pointer to new node, or NULL on error  */
end_comment

begin_function
specifier|static
name|cd9660node
modifier|*
name|cd9660_allocate_cd9660node
parameter_list|(
name|void
parameter_list|)
block|{
name|cd9660node
modifier|*
name|temp
init|=
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|temp
argument_list|)
argument_list|)
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|temp
operator|->
name|cn_children
argument_list|)
expr_stmt|;
name|temp
operator|->
name|parent
operator|=
name|temp
operator|->
name|dot_record
operator|=
name|temp
operator|->
name|dot_dot_record
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|ptnext
operator|=
name|temp
operator|->
name|ptprev
operator|=
name|temp
operator|->
name|ptlast
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|isoDirRecord
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|isoExtAttributes
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|rr_real_parent
operator|=
name|temp
operator|->
name|rr_relocated
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|su_tail_data
operator|=
name|NULL
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/** * Set default values for cd9660 extension to makefs */
end_comment

begin_function
specifier|static
name|void
name|cd9660_set_defaults
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|)
block|{
comment|/*Fix the sector size for now, though the spec allows for other sizes*/
name|diskStructure
operator|->
name|sectorSize
operator|=
literal|2048
expr_stmt|;
comment|/* Set up defaults in our own structure */
name|diskStructure
operator|->
name|verbose_level
operator|=
literal|0
expr_stmt|;
name|diskStructure
operator|->
name|keep_bad_images
operator|=
literal|0
expr_stmt|;
name|diskStructure
operator|->
name|follow_sym_links
operator|=
literal|0
expr_stmt|;
name|diskStructure
operator|->
name|isoLevel
operator|=
literal|2
expr_stmt|;
name|diskStructure
operator|->
name|rock_ridge_enabled
operator|=
literal|0
expr_stmt|;
name|diskStructure
operator|->
name|rock_ridge_renamed_dir_name
operator|=
literal|0
expr_stmt|;
name|diskStructure
operator|->
name|rock_ridge_move_count
operator|=
literal|0
expr_stmt|;
name|diskStructure
operator|->
name|rr_moved_dir
operator|=
literal|0
expr_stmt|;
name|diskStructure
operator|->
name|archimedes_enabled
operator|=
literal|0
expr_stmt|;
name|diskStructure
operator|->
name|chrp_boot
operator|=
literal|0
expr_stmt|;
name|diskStructure
operator|->
name|include_padding_areas
operator|=
literal|1
expr_stmt|;
comment|/* Spec breaking functionality */
name|diskStructure
operator|->
name|allow_deep_trees
operator|=
name|diskStructure
operator|->
name|allow_start_dot
operator|=
name|diskStructure
operator|->
name|allow_max_name
operator|=
name|diskStructure
operator|->
name|allow_illegal_chars
operator|=
name|diskStructure
operator|->
name|allow_lowercase
operator|=
name|diskStructure
operator|->
name|allow_multidot
operator|=
name|diskStructure
operator|->
name|omit_trailing_period
operator|=
literal|0
expr_stmt|;
comment|/* Make sure the PVD is clear */
name|memset
argument_list|(
operator|&
name|diskStructure
operator|->
name|primaryDescriptor
argument_list|,
literal|0
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|publisher_id
argument_list|,
literal|0x20
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|preparer_id
argument_list|,
literal|0x20
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|application_id
argument_list|,
literal|0x20
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|copyright_file_id
argument_list|,
literal|0x20
argument_list|,
literal|37
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|abstract_file_id
argument_list|,
literal|0x20
argument_list|,
literal|37
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|bibliographic_file_id
argument_list|,
literal|0x20
argument_list|,
literal|37
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|system_id
argument_list|,
literal|"FreeBSD"
argument_list|)
expr_stmt|;
comment|/* Boot support: Initially disabled */
name|diskStructure
operator|->
name|has_generic_bootimage
operator|=
literal|0
expr_stmt|;
name|diskStructure
operator|->
name|generic_bootimage
operator|=
name|NULL
expr_stmt|;
name|diskStructure
operator|->
name|boot_image_directory
operator|=
literal|0
expr_stmt|;
comment|/*memset(diskStructure->boot_descriptor, 0, 2048);*/
name|diskStructure
operator|->
name|is_bootable
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|diskStructure
operator|->
name|boot_images
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|diskStructure
operator|->
name|boot_entries
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cd9660_prep_opts
parameter_list|(
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|iso9660_disk
modifier|*
name|diskStructure
init|=
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|diskStructure
argument_list|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|OPT_STR
parameter_list|(
name|letter
parameter_list|,
name|name
parameter_list|,
name|desc
parameter_list|)
define|\
value|{ letter, name, NULL, OPT_STRBUF, 0, 0, desc }
define|#
directive|define
name|OPT_NUM
parameter_list|(
name|letter
parameter_list|,
name|name
parameter_list|,
name|field
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|,
name|desc
parameter_list|)
define|\
value|{ letter, name,&diskStructure->field, \ 	  sizeof(diskStructure->field) == 8 ? OPT_INT64 : \ 	  (sizeof(diskStructure->field) == 4 ? OPT_INT32 : \ 	  (sizeof(diskStructure->field) == 2 ? OPT_INT16 : OPT_INT8)), \ 	  min, max, desc }
define|#
directive|define
name|OPT_BOOL
parameter_list|(
name|letter
parameter_list|,
name|name
parameter_list|,
name|field
parameter_list|,
name|desc
parameter_list|)
define|\
value|OPT_NUM(letter, name, field, 0, 1, desc)
specifier|const
name|option_t
name|cd9660_options
index|[]
init|=
block|{
name|OPT_NUM
argument_list|(
literal|'l'
argument_list|,
literal|"isolevel"
argument_list|,
name|isoLevel
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|"ISO Level"
argument_list|)
block|,
name|OPT_NUM
argument_list|(
literal|'v'
argument_list|,
literal|"verbose"
argument_list|,
name|verbose_level
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|"Turns on verbose output"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'h'
argument_list|,
literal|"help"
argument_list|,
name|displayHelp
argument_list|,
literal|"Show help message"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'S'
argument_list|,
literal|"follow-symlinks"
argument_list|,
name|follow_sym_links
argument_list|,
literal|"Resolve symlinks in pathnames"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'R'
argument_list|,
literal|"rockridge"
argument_list|,
name|rock_ridge_enabled
argument_list|,
literal|"Enable Rock-Ridge extensions"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'C'
argument_list|,
literal|"chrp-boot"
argument_list|,
name|chrp_boot
argument_list|,
literal|"Enable CHRP boot"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'K'
argument_list|,
literal|"keep-bad-images"
argument_list|,
name|keep_bad_images
argument_list|,
literal|"Keep bad images"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'D'
argument_list|,
literal|"allow-deep-trees"
argument_list|,
name|allow_deep_trees
argument_list|,
literal|"Allow trees more than 8 levels"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'a'
argument_list|,
literal|"allow-max-name"
argument_list|,
name|allow_max_name
argument_list|,
literal|"Allow 37 char filenames (unimplemented)"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'i'
argument_list|,
literal|"allow-illegal-chars"
argument_list|,
name|allow_illegal_chars
argument_list|,
literal|"Allow illegal characters in filenames"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'m'
argument_list|,
literal|"allow-multidot"
argument_list|,
name|allow_multidot
argument_list|,
literal|"Allow multiple periods in filenames"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'o'
argument_list|,
literal|"omit-trailing-period"
argument_list|,
name|omit_trailing_period
argument_list|,
literal|"Omit trailing periods in filenames"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'\0'
argument_list|,
literal|"allow-lowercase"
argument_list|,
name|allow_lowercase
argument_list|,
literal|"Allow lowercase characters in filenames"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'\0'
argument_list|,
literal|"archimedes"
argument_list|,
name|archimedes_enabled
argument_list|,
literal|"Enable Archimedes structure"
argument_list|)
block|,
name|OPT_BOOL
argument_list|(
literal|'\0'
argument_list|,
literal|"no-trailing-padding"
argument_list|,
name|include_padding_areas
argument_list|,
literal|"Include padding areas"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'A'
argument_list|,
literal|"applicationid"
argument_list|,
literal|"Application Identifier"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'P'
argument_list|,
literal|"publisher"
argument_list|,
literal|"Publisher Identifier"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'p'
argument_list|,
literal|"preparer"
argument_list|,
literal|"Preparer Identifier"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'L'
argument_list|,
literal|"label"
argument_list|,
literal|"Disk Label"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'V'
argument_list|,
literal|"volumeid"
argument_list|,
literal|"Volume Set Identifier"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'B'
argument_list|,
literal|"bootimage"
argument_list|,
literal|"Boot image parameter"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'G'
argument_list|,
literal|"generic-bootimage"
argument_list|,
literal|"Generic boot image param"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'\0'
argument_list|,
literal|"bootimagedir"
argument_list|,
literal|"Boot image directory"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'\0'
argument_list|,
literal|"no-emul-boot"
argument_list|,
literal|"No boot emulation"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'\0'
argument_list|,
literal|"no-boot"
argument_list|,
literal|"No boot support"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'\0'
argument_list|,
literal|"hard-disk-boot"
argument_list|,
literal|"Boot from hard disk"
argument_list|)
block|,
name|OPT_STR
argument_list|(
literal|'\0'
argument_list|,
literal|"boot-load-segment"
argument_list|,
literal|"Boot load segment"
argument_list|)
block|,
block|{
operator|.
name|name
operator|=
name|NULL
block|}
block|}
decl_stmt|;
name|fsopts
operator|->
name|fs_specific
operator|=
name|diskStructure
expr_stmt|;
name|fsopts
operator|->
name|fs_options
operator|=
name|copy_opts
argument_list|(
name|cd9660_options
argument_list|)
expr_stmt|;
name|cd9660_set_defaults
argument_list|(
name|diskStructure
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cd9660_cleanup_opts
parameter_list|(
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|free
argument_list|(
name|fsopts
operator|->
name|fs_specific
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fsopts
operator|->
name|fs_options
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cd9660_arguments_set_string
parameter_list|(
specifier|const
name|char
modifier|*
name|val
parameter_list|,
specifier|const
name|char
modifier|*
name|fieldtitle
parameter_list|,
name|int
name|length
parameter_list|,
name|char
name|testmode
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|test
decl_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
name|warnx
argument_list|(
literal|"error: The %s requires a string argument"
argument_list|,
name|fieldtitle
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
name|val
argument_list|)
operator|)
operator|<=
name|length
condition|)
block|{
if|if
condition|(
name|testmode
operator|==
literal|'d'
condition|)
name|test
operator|=
name|cd9660_valid_d_chars
argument_list|(
name|val
argument_list|)
expr_stmt|;
else|else
name|test
operator|=
name|cd9660_valid_a_chars
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
condition|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|test
operator|==
literal|2
condition|)
name|cd9660_uppercase_characters
argument_list|(
name|dest
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|warnx
argument_list|(
literal|"error: The %s must be composed of "
literal|"%c-characters"
argument_list|,
name|fieldtitle
argument_list|,
name|testmode
argument_list|)
expr_stmt|;
block|}
else|else
name|warnx
argument_list|(
literal|"error: The %s must be at most 32 characters long"
argument_list|,
name|fieldtitle
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Command-line parsing function  */
end_comment

begin_function
name|int
name|cd9660_parse_opts
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|int
name|rv
decl_stmt|,
name|i
decl_stmt|;
name|iso9660_disk
modifier|*
name|diskStructure
init|=
name|fsopts
operator|->
name|fs_specific
decl_stmt|;
name|option_t
modifier|*
name|cd9660_options
init|=
name|fsopts
operator|->
name|fs_options
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|desc
decl_stmt|;
name|assert
argument_list|(
name|option
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_PARSE_OPTS
condition|)
name|printf
argument_list|(
literal|"%s: got `%s'\n"
argument_list|,
name|__func__
argument_list|,
name|option
argument_list|)
expr_stmt|;
name|i
operator|=
name|set_option
argument_list|(
name|cd9660_options
argument_list|,
name|option
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cd9660_options
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
name|abort
argument_list|()
expr_stmt|;
name|name
operator|=
name|cd9660_options
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
name|desc
operator|=
name|cd9660_options
index|[
name|i
index|]
operator|.
name|desc
expr_stmt|;
switch|switch
condition|(
name|cd9660_options
index|[
name|i
index|]
operator|.
name|letter
condition|)
block|{
case|case
literal|'h'
case|:
case|case
literal|'S'
case|:
name|rv
operator|=
literal|0
expr_stmt|;
comment|/* this is not handled yet */
break|break;
case|case
literal|'L'
case|:
name|rv
operator|=
name|cd9660_arguments_set_string
argument_list|(
name|buf
argument_list|,
name|desc
argument_list|,
literal|32
argument_list|,
literal|'d'
argument_list|,
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|volume_id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|rv
operator|=
name|cd9660_arguments_set_string
argument_list|(
name|buf
argument_list|,
name|desc
argument_list|,
literal|128
argument_list|,
literal|'a'
argument_list|,
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|application_id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|rv
operator|=
name|cd9660_arguments_set_string
argument_list|(
name|buf
argument_list|,
name|desc
argument_list|,
literal|128
argument_list|,
literal|'a'
argument_list|,
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|publisher_id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|rv
operator|=
name|cd9660_arguments_set_string
argument_list|(
name|buf
argument_list|,
name|desc
argument_list|,
literal|128
argument_list|,
literal|'a'
argument_list|,
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|preparer_id
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|rv
operator|=
name|cd9660_arguments_set_string
argument_list|(
name|buf
argument_list|,
name|desc
argument_list|,
literal|128
argument_list|,
literal|'a'
argument_list|,
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|volume_set_id
argument_list|)
expr_stmt|;
break|break;
comment|/* Boot options */
case|case
literal|'B'
case|:
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"The Boot Image parameter requires a valid boot"
literal|"information string"
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|rv
operator|=
name|cd9660_add_boot_disk
argument_list|(
name|diskStructure
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"The Generic Boot Image parameter requires a"
literal|" valid boot information string"
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|rv
operator|=
name|cd9660_add_generic_bootimage
argument_list|(
name|diskStructure
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"bootimagedir"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * XXXfvdl this is unused. 			 */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"The Boot Image Directory parameter"
literal|" requires a directory name"
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|diskStructure
operator|->
name|boot_image_directory
operator|=
name|emalloc
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* BIG TODO: Add the max length function here */
name|rv
operator|=
name|cd9660_arguments_set_string
argument_list|(
name|buf
argument_list|,
name|desc
argument_list|,
literal|12
argument_list|,
literal|'d'
argument_list|,
name|diskStructure
operator|->
name|boot_image_directory
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"no-emul-boot"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"no-boot"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"hard-disk-boot"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* RRIP */
name|cd9660_eltorito_add_boot_option
argument_list|(
name|diskStructure
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"boot-load-segment"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"Option `%s' doesn't contain a value"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cd9660_eltorito_add_boot_option
argument_list|(
name|diskStructure
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|rv
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * Main function for cd9660_makefs  * Builds the ISO image file  * @param const char *image The image filename to create  * @param const char *dir The directory that is being read  * @param struct fsnode *root The root node of the filesystem tree  * @param struct fsinfo_t *fsopts Any options  */
end_comment

begin_function
name|void
name|cd9660_makefs
parameter_list|(
specifier|const
name|char
modifier|*
name|image
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
name|fsnode
modifier|*
name|root
parameter_list|,
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|int64_t
name|startoffset
decl_stmt|;
name|int
name|numDirectories
decl_stmt|;
name|uint64_t
name|pathTableSectors
decl_stmt|;
name|int64_t
name|firstAvailableSector
decl_stmt|;
name|int64_t
name|totalSpace
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cd9660node
modifier|*
name|real_root
decl_stmt|;
name|iso9660_disk
modifier|*
name|diskStructure
init|=
name|fsopts
operator|->
name|fs_specific
decl_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: ISO level is %i\n"
argument_list|,
name|__func__
argument_list|,
name|diskStructure
operator|->
name|isoLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|isoLevel
operator|<
literal|2
operator|&&
name|diskStructure
operator|->
name|allow_multidot
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"allow-multidot requires iso level of 2"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|image
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dir
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|root
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|displayHelp
condition|)
block|{
comment|/* 		 * Display help here - probably want to put it in 		 * a separate function 		 */
return|return;
block|}
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: image %s directory %s root %p\n"
argument_list|,
name|__func__
argument_list|,
name|image
argument_list|,
name|dir
argument_list|,
name|root
argument_list|)
expr_stmt|;
comment|/* Set up some constants. Later, these will be defined with options */
comment|/* Counter needed for path tables */
name|numDirectories
operator|=
literal|0
expr_stmt|;
comment|/* Convert tree to our own format */
comment|/* Actually, we now need to add the REAL root node, at level 0 */
name|real_root
operator|=
name|cd9660_allocate_cd9660node
argument_list|()
expr_stmt|;
name|real_root
operator|->
name|isoDirRecord
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|real_root
operator|->
name|isoDirRecord
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Leave filename blank for root */
name|memset
argument_list|(
name|real_root
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|ISO_FILENAME_MAXLENGTH_WITH_PADDING
argument_list|)
expr_stmt|;
name|real_root
operator|->
name|level
operator|=
literal|0
expr_stmt|;
name|diskStructure
operator|->
name|rootNode
operator|=
name|real_root
expr_stmt|;
name|real_root
operator|->
name|type
operator|=
name|CD9660_TYPE_DIR
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|real_root
operator|->
name|node
operator|=
name|root
expr_stmt|;
name|cd9660_convert_structure
argument_list|(
name|diskStructure
argument_list|,
name|root
argument_list|,
name|real_root
argument_list|,
literal|1
argument_list|,
operator|&
name|numDirectories
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|real_root
operator|->
name|cn_children
argument_list|)
condition|)
block|{
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s: converted directory is empty. "
literal|"Tree conversion failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s: tree conversion failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: tree converted\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* Add the dot and dot dot records */
name|cd9660_add_dot_records
argument_list|(
name|diskStructure
argument_list|,
name|real_root
argument_list|)
expr_stmt|;
name|cd9660_setup_root_node
argument_list|(
name|diskStructure
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: done converting tree\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* non-SUSP extensions */
if|if
condition|(
name|diskStructure
operator|->
name|archimedes_enabled
condition|)
name|archimedes_convert_tree
argument_list|(
name|diskStructure
operator|->
name|rootNode
argument_list|)
expr_stmt|;
comment|/* Rock ridge / SUSP init pass */
if|if
condition|(
name|diskStructure
operator|->
name|rock_ridge_enabled
condition|)
block|{
name|cd9660_susp_initialize
argument_list|(
name|diskStructure
argument_list|,
name|diskStructure
operator|->
name|rootNode
argument_list|,
name|diskStructure
operator|->
name|rootNode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Build path table structure */
name|diskStructure
operator|->
name|pathTableLength
operator|=
name|cd9660_generate_path_table
argument_list|(
name|diskStructure
argument_list|)
expr_stmt|;
name|pathTableSectors
operator|=
name|CD9660_BLOCKS
argument_list|(
name|diskStructure
operator|->
name|sectorSize
argument_list|,
name|diskStructure
operator|->
name|pathTableLength
argument_list|)
expr_stmt|;
name|firstAvailableSector
operator|=
name|cd9660_setup_volume_descriptors
argument_list|(
name|diskStructure
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|is_bootable
condition|)
block|{
name|firstAvailableSector
operator|=
name|cd9660_setup_boot
argument_list|(
name|diskStructure
argument_list|,
name|firstAvailableSector
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstAvailableSector
operator|<
literal|0
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"setup_boot failed"
argument_list|)
expr_stmt|;
block|}
comment|/* LE first, then BE */
name|diskStructure
operator|->
name|primaryLittleEndianTableSector
operator|=
name|firstAvailableSector
expr_stmt|;
name|diskStructure
operator|->
name|primaryBigEndianTableSector
operator|=
name|diskStructure
operator|->
name|primaryLittleEndianTableSector
operator|+
name|pathTableSectors
expr_stmt|;
comment|/* Set the secondary ones to -1, not going to use them for now */
name|diskStructure
operator|->
name|secondaryBigEndianTableSector
operator|=
operator|-
literal|1
expr_stmt|;
name|diskStructure
operator|->
name|secondaryLittleEndianTableSector
operator|=
operator|-
literal|1
expr_stmt|;
name|diskStructure
operator|->
name|dataFirstSector
operator|=
name|diskStructure
operator|->
name|primaryBigEndianTableSector
operator|+
name|pathTableSectors
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Path table conversion complete. "
literal|"Each table is %i bytes, or %"
name|PRIu64
literal|" sectors.\n"
argument_list|,
name|__func__
argument_list|,
name|diskStructure
operator|->
name|pathTableLength
argument_list|,
name|pathTableSectors
argument_list|)
expr_stmt|;
name|startoffset
operator|=
name|diskStructure
operator|->
name|sectorSize
operator|*
name|diskStructure
operator|->
name|dataFirstSector
expr_stmt|;
name|totalSpace
operator|=
name|cd9660_compute_offsets
argument_list|(
name|diskStructure
argument_list|,
name|real_root
argument_list|,
name|startoffset
argument_list|)
expr_stmt|;
name|diskStructure
operator|->
name|totalSectors
operator|=
name|diskStructure
operator|->
name|dataFirstSector
operator|+
name|CD9660_BLOCKS
argument_list|(
name|diskStructure
operator|->
name|sectorSize
argument_list|,
name|totalSpace
argument_list|)
expr_stmt|;
comment|/* Disabled until pass 1 is done */
if|if
condition|(
name|diskStructure
operator|->
name|rock_ridge_enabled
condition|)
block|{
name|diskStructure
operator|->
name|susp_continuation_area_start_sector
operator|=
name|diskStructure
operator|->
name|totalSectors
expr_stmt|;
name|diskStructure
operator|->
name|totalSectors
operator|+=
name|CD9660_BLOCKS
argument_list|(
name|diskStructure
operator|->
name|sectorSize
argument_list|,
name|diskStructure
operator|->
name|susp_continuation_area_size
argument_list|)
expr_stmt|;
name|cd9660_susp_finalize
argument_list|(
name|diskStructure
argument_list|,
name|diskStructure
operator|->
name|rootNode
argument_list|)
expr_stmt|;
block|}
name|cd9660_finalize_PVD
argument_list|(
name|diskStructure
argument_list|)
expr_stmt|;
comment|/* Add padding sectors, just for testing purposes right now */
comment|/* diskStructure->totalSectors+=150; */
comment|/* Debugging output */
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Sectors 0-15 reserved\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Primary path tables starts in sector %"
name|PRId64
literal|"\n"
argument_list|,
name|__func__
argument_list|,
name|diskStructure
operator|->
name|primaryLittleEndianTableSector
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: File data starts in sector %"
name|PRId64
literal|"\n"
argument_list|,
name|__func__
argument_list|,
name|diskStructure
operator|->
name|dataFirstSector
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Total sectors: %"
name|PRId64
literal|"\n"
argument_list|,
name|__func__
argument_list|,
name|diskStructure
operator|->
name|totalSectors
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add padding sectors at the end 	 * TODO: Clean this up and separate padding 	 */
if|if
condition|(
name|diskStructure
operator|->
name|include_padding_areas
condition|)
name|diskStructure
operator|->
name|totalSectors
operator|+=
literal|150
expr_stmt|;
name|cd9660_write_image
argument_list|(
name|diskStructure
argument_list|,
name|image
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|1
condition|)
block|{
name|debug_print_volume_descriptor_information
argument_list|(
name|diskStructure
argument_list|)
expr_stmt|;
name|debug_print_tree
argument_list|(
name|diskStructure
argument_list|,
name|real_root
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|debug_print_path_tree
argument_list|(
name|real_root
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up data structures */
name|cd9660_free_structure
argument_list|(
name|real_root
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: done\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generic function pointer - implement later */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|cd9660node_func
function_decl|)
parameter_list|(
name|cd9660node
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function
specifier|static
name|void
name|cd9660_finalize_PVD
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|)
block|{
name|time_t
name|tstamp
init|=
name|stampst
operator|.
name|st_ino
condition|?
name|stampst
operator|.
name|st_mtime
else|:
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
comment|/* root should be a fixed size of 34 bytes since it has no name */
name|memcpy
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|root_directory_record
argument_list|,
name|diskStructure
operator|->
name|rootNode
operator|->
name|dot_record
operator|->
name|isoDirRecord
argument_list|,
literal|34
argument_list|)
expr_stmt|;
comment|/* In RRIP, this might be longer than 34 */
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|root_directory_record
index|[
literal|0
index|]
operator|=
literal|34
expr_stmt|;
comment|/* Set up all the important numbers in the PVD */
name|cd9660_bothendian_dword
argument_list|(
name|diskStructure
operator|->
name|totalSectors
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|volume_space_size
argument_list|)
expr_stmt|;
name|cd9660_bothendian_word
argument_list|(
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|volume_set_size
argument_list|)
expr_stmt|;
name|cd9660_bothendian_word
argument_list|(
literal|1
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|volume_sequence_number
argument_list|)
expr_stmt|;
name|cd9660_bothendian_word
argument_list|(
name|diskStructure
operator|->
name|sectorSize
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|logical_block_size
argument_list|)
expr_stmt|;
name|cd9660_bothendian_dword
argument_list|(
name|diskStructure
operator|->
name|pathTableLength
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|path_table_size
argument_list|)
expr_stmt|;
name|cd9660_731
argument_list|(
name|diskStructure
operator|->
name|primaryLittleEndianTableSector
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|type_l_path_table
argument_list|)
expr_stmt|;
name|cd9660_732
argument_list|(
name|diskStructure
operator|->
name|primaryBigEndianTableSector
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|type_m_path_table
argument_list|)
expr_stmt|;
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|file_structure_version
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Pad all strings with spaces instead of nulls */
name|cd9660_pad_string_spaces
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|volume_id
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|cd9660_pad_string_spaces
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|system_id
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|cd9660_pad_string_spaces
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|volume_set_id
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|cd9660_pad_string_spaces
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|publisher_id
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|cd9660_pad_string_spaces
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|preparer_id
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|cd9660_pad_string_spaces
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|application_id
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|cd9660_pad_string_spaces
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|copyright_file_id
argument_list|,
literal|37
argument_list|)
expr_stmt|;
name|cd9660_pad_string_spaces
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|abstract_file_id
argument_list|,
literal|37
argument_list|)
expr_stmt|;
name|cd9660_pad_string_spaces
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|bibliographic_file_id
argument_list|,
literal|37
argument_list|)
expr_stmt|;
comment|/* Setup dates */
name|cd9660_time_8426
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|creation_date
argument_list|,
name|tstamp
argument_list|)
expr_stmt|;
name|cd9660_time_8426
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|modification_date
argument_list|,
name|tstamp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|cd9660_set_date(diskStructure->primaryDescriptor.expiration_date, 	    tstamp);
endif|#
directive|endif
name|memset
argument_list|(
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|expiration_date
argument_list|,
literal|'0'
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|expiration_date
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|cd9660_time_8426
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|diskStructure
operator|->
name|primaryDescriptor
operator|.
name|effective_date
argument_list|,
name|tstamp
argument_list|)
expr_stmt|;
comment|/* make this sane */
name|cd9660_time_915
argument_list|(
name|diskStructure
operator|->
name|rootNode
operator|->
name|dot_record
operator|->
name|isoDirRecord
operator|->
name|date
argument_list|,
name|tstamp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd9660_populate_iso_dir_record
parameter_list|(
name|struct
name|_iso_directory_record_cd9660
modifier|*
name|record
parameter_list|,
name|u_char
name|ext_attr_length
parameter_list|,
name|u_char
name|flags
parameter_list|,
name|u_char
name|name_len
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|record
operator|->
name|ext_attr_length
index|[
literal|0
index|]
operator|=
name|ext_attr_length
expr_stmt|;
name|record
operator|->
name|flags
index|[
literal|0
index|]
operator|=
name|ISO_FLAG_CLEAR
operator||
name|flags
expr_stmt|;
name|record
operator|->
name|file_unit_size
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|record
operator|->
name|interleave
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|cd9660_bothendian_word
argument_list|(
literal|1
argument_list|,
name|record
operator|->
name|volume_sequence_number
argument_list|)
expr_stmt|;
name|record
operator|->
name|name_len
index|[
literal|0
index|]
operator|=
name|name_len
expr_stmt|;
name|memset
argument_list|(
name|record
operator|->
name|name
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|record
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|record
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|record
operator|->
name|length
index|[
literal|0
index|]
operator|=
literal|33
operator|+
name|name_len
expr_stmt|;
comment|/* Todo : better rounding */
name|record
operator|->
name|length
index|[
literal|0
index|]
operator|+=
operator|(
name|record
operator|->
name|length
index|[
literal|0
index|]
operator|&
literal|1
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd9660_setup_root_node
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|)
block|{
name|cd9660_populate_iso_dir_record
argument_list|(
name|diskStructure
operator|->
name|rootNode
operator|->
name|isoDirRecord
argument_list|,
literal|0
argument_list|,
name|ISO_FLAG_DIRECTORY
argument_list|,
literal|1
argument_list|,
literal|"\0"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********** SUPPORT FUNCTIONS ***********/
end_comment

begin_function
specifier|static
name|int
name|cd9660_setup_volume_descriptors
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|)
block|{
comment|/* Boot volume descriptor should come second */
name|int
name|sector
init|=
literal|16
decl_stmt|;
comment|/* For now, a fixed 2 : PVD and terminator */
name|volume_descriptor
modifier|*
name|temp
decl_stmt|,
modifier|*
name|t
decl_stmt|;
comment|/* Set up the PVD */
name|temp
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|volumeDescriptorData
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|diskStructure
operator|->
name|primaryDescriptor
expr_stmt|;
name|temp
operator|->
name|volumeDescriptorData
index|[
literal|0
index|]
operator|=
name|ISO_VOLUME_DESCRIPTOR_PVD
expr_stmt|;
name|temp
operator|->
name|volumeDescriptorData
index|[
literal|6
index|]
operator|=
literal|1
expr_stmt|;
name|temp
operator|->
name|sector
operator|=
name|sector
expr_stmt|;
name|memcpy
argument_list|(
name|temp
operator|->
name|volumeDescriptorData
operator|+
literal|1
argument_list|,
name|ISO_VOLUME_DESCRIPTOR_STANDARD_ID
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|diskStructure
operator|->
name|firstVolumeDescriptor
operator|=
name|temp
expr_stmt|;
name|sector
operator|++
expr_stmt|;
comment|/* Set up boot support if enabled. BVD must reside in sector 17 */
if|if
condition|(
name|diskStructure
operator|->
name|is_bootable
condition|)
block|{
name|t
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|volumeDescriptorData
operator|=
name|ecalloc
argument_list|(
literal|1
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|t
expr_stmt|;
name|temp
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|sector
operator|=
literal|17
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Setting up boot volume descriptor\n"
argument_list|)
expr_stmt|;
name|cd9660_setup_boot_volume_descriptor
argument_list|(
name|diskStructure
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|sector
operator|++
expr_stmt|;
block|}
comment|/* Set up the terminator */
name|t
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|volumeDescriptorData
operator|=
name|ecalloc
argument_list|(
literal|1
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|t
expr_stmt|;
name|t
operator|->
name|volumeDescriptorData
index|[
literal|0
index|]
operator|=
name|ISO_VOLUME_DESCRIPTOR_TERMINATOR
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|volumeDescriptorData
index|[
literal|6
index|]
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|sector
operator|=
name|sector
expr_stmt|;
name|memcpy
argument_list|(
name|t
operator|->
name|volumeDescriptorData
operator|+
literal|1
argument_list|,
name|ISO_VOLUME_DESCRIPTOR_STANDARD_ID
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|sector
operator|++
expr_stmt|;
return|return
name|sector
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Populate EAR at some point. Not required, but is used by NetBSD's  * cd9660 support  */
end_comment

begin_endif
unit|static int cd9660_fill_extended_attribute_record(cd9660node *node) { 	node->isoExtAttributes = emalloc(sizeof(*node->isoExtAttributes)); 	return 1; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|cd9660_translate_node_common
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|cd9660node
modifier|*
name|newnode
parameter_list|)
block|{
name|time_t
name|tstamp
init|=
name|stampst
operator|.
name|st_ino
condition|?
name|stampst
operator|.
name|st_mtime
else|:
name|time
argument_list|(
name|NULL
argument_list|)
decl_stmt|;
name|u_char
name|flag
decl_stmt|;
name|char
name|temp
index|[
name|ISO_FILENAME_MAXLENGTH_WITH_PADDING
index|]
decl_stmt|;
comment|/* Now populate the isoDirRecord structure */
name|memset
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|,
name|ISO_FILENAME_MAXLENGTH_WITH_PADDING
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cd9660_convert_filename
argument_list|(
name|diskStructure
argument_list|,
name|newnode
operator|->
name|node
operator|->
name|name
argument_list|,
name|temp
argument_list|,
operator|!
operator|(
name|S_ISDIR
argument_list|(
name|newnode
operator|->
name|node
operator|->
name|type
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|flag
operator|=
name|ISO_FLAG_CLEAR
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|newnode
operator|->
name|node
operator|->
name|type
argument_list|)
condition|)
name|flag
operator||=
name|ISO_FLAG_DIRECTORY
expr_stmt|;
name|cd9660_populate_iso_dir_record
argument_list|(
name|newnode
operator|->
name|isoDirRecord
argument_list|,
literal|0
argument_list|,
name|flag
argument_list|,
name|strlen
argument_list|(
name|temp
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Set the various dates */
comment|/* If we want to use the current date and time */
name|cd9660_time_915
argument_list|(
name|newnode
operator|->
name|isoDirRecord
operator|->
name|date
argument_list|,
name|tstamp
argument_list|)
expr_stmt|;
name|cd9660_bothendian_dword
argument_list|(
name|newnode
operator|->
name|fileDataLength
argument_list|,
name|newnode
operator|->
name|isoDirRecord
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* If the file is a link, we want to set the size to 0 */
if|if
condition|(
name|S_ISLNK
argument_list|(
name|newnode
operator|->
name|node
operator|->
name|type
argument_list|)
condition|)
name|newnode
operator|->
name|fileDataLength
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Translate fsnode to cd9660node  * Translate filenames and other metadata, including dates, sizes,  * permissions, etc  * @param struct fsnode * The node generated by makefs  * @param struct cd9660node * The intermediate node to be written to  * @returns int 0 on failure, 1 on success  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_translate_node
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|fsnode
modifier|*
name|node
parameter_list|,
name|cd9660node
modifier|*
name|newnode
parameter_list|)
block|{
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: NULL node passed, returning\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|newnode
operator|->
name|isoDirRecord
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newnode
operator|->
name|isoDirRecord
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the node pointer */
name|newnode
operator|->
name|node
operator|=
name|node
expr_stmt|;
comment|/* Set the size */
if|if
condition|(
operator|!
operator|(
name|S_ISDIR
argument_list|(
name|node
operator|->
name|type
argument_list|)
operator|)
condition|)
name|newnode
operator|->
name|fileDataLength
operator|=
name|node
operator|->
name|inode
operator|->
name|st
operator|.
name|st_size
expr_stmt|;
if|if
condition|(
name|cd9660_translate_node_common
argument_list|(
name|diskStructure
argument_list|,
name|newnode
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Finally, overwrite some of the values that are set by default */
name|cd9660_time_915
argument_list|(
name|newnode
operator|->
name|isoDirRecord
operator|->
name|date
argument_list|,
name|stampst
operator|.
name|st_ino
condition|?
name|stampst
operator|.
name|st_mtime
else|:
name|node
operator|->
name|inode
operator|->
name|st
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Compares two ISO filenames  * @param const char * The first file name  * @param const char * The second file name  * @returns : -1 if first is less than second, 0 if they are the same, 1 if  * 	the second is greater than the first  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_compare_filename
parameter_list|(
specifier|const
name|char
modifier|*
name|first
parameter_list|,
specifier|const
name|char
modifier|*
name|second
parameter_list|)
block|{
comment|/* 	 * This can be made more optimal once it has been tested 	 * (the extra character, for example, is for testing) 	 */
name|int
name|p1
init|=
literal|0
decl_stmt|;
name|int
name|p2
init|=
literal|0
decl_stmt|;
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
comment|/* First, on the filename */
while|while
condition|(
name|p1
operator|<
name|ISO_FILENAME_MAXLENGTH_BEFORE_VERSION
operator|-
literal|1
operator|&&
name|p2
operator|<
name|ISO_FILENAME_MAXLENGTH_BEFORE_VERSION
operator|-
literal|1
condition|)
block|{
name|c1
operator|=
name|first
index|[
name|p1
index|]
expr_stmt|;
name|c2
operator|=
name|second
index|[
name|p2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|'.'
operator|&&
name|c2
operator|==
literal|'.'
condition|)
break|break;
elseif|else
if|if
condition|(
name|c1
operator|==
literal|'.'
condition|)
block|{
name|p2
operator|++
expr_stmt|;
name|c1
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|'.'
condition|)
block|{
name|p1
operator|++
expr_stmt|;
name|c2
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
name|p1
operator|++
expr_stmt|;
name|p2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|<
name|c2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|c1
operator|>
name|c2
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|first
index|[
name|p1
index|]
operator|==
literal|'.'
operator|&&
name|second
index|[
name|p2
index|]
operator|==
literal|'.'
condition|)
block|{
name|p1
operator|++
expr_stmt|;
name|p2
operator|++
expr_stmt|;
while|while
condition|(
name|p1
operator|<
name|ISO_FILENAME_MAXLENGTH_BEFORE_VERSION
operator|-
literal|1
operator|&&
name|p2
operator|<
name|ISO_FILENAME_MAXLENGTH_BEFORE_VERSION
operator|-
literal|1
condition|)
block|{
name|c1
operator|=
name|first
index|[
name|p1
index|]
expr_stmt|;
name|c2
operator|=
name|second
index|[
name|p2
index|]
expr_stmt|;
if|if
condition|(
name|c1
operator|==
literal|';'
operator|&&
name|c2
operator|==
literal|';'
condition|)
break|break;
elseif|else
if|if
condition|(
name|c1
operator|==
literal|';'
condition|)
block|{
name|p2
operator|++
expr_stmt|;
name|c1
operator|=
literal|' '
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c2
operator|==
literal|';'
condition|)
block|{
name|p1
operator|++
expr_stmt|;
name|c2
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
name|p1
operator|++
expr_stmt|;
name|p2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c1
operator|<
name|c2
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|c1
operator|>
name|c2
condition|)
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a node into list with ISO sorting rules  * @param cd9660node * The head node of the list  * @param cd9660node * The node to be inserted  */
end_comment

begin_function
specifier|static
name|void
name|cd9660_sorted_child_insert
parameter_list|(
name|cd9660node
modifier|*
name|parent
parameter_list|,
name|cd9660node
modifier|*
name|cn_new
parameter_list|)
block|{
name|int
name|compare
decl_stmt|;
name|cd9660node
modifier|*
name|cn
decl_stmt|;
name|struct
name|cd9660_children_head
modifier|*
name|head
init|=
operator|&
name|parent
operator|->
name|cn_children
decl_stmt|;
comment|/* TODO: Optimize? */
name|cn_new
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
comment|/* 	 * first will either be 0, the . or the .. 	 * if . or .., this means no other entry may be written before first 	 * if 0, the new node may be inserted at the head 	 */
name|TAILQ_FOREACH
argument_list|(
argument|cn
argument_list|,
argument|head
argument_list|,
argument|cn_next_child
argument_list|)
block|{
comment|/* 		 * Dont insert a node twice - 		 * that would cause an infinite loop 		 */
if|if
condition|(
name|cn_new
operator|==
name|cn
condition|)
return|return;
name|compare
operator|=
name|cd9660_compare_filename
argument_list|(
name|cn_new
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|,
name|cn
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|==
literal|0
condition|)
name|compare
operator|=
name|cd9660_compare_filename
argument_list|(
name|cn_new
operator|->
name|node
operator|->
name|name
argument_list|,
name|cn
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare
operator|<
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|cn
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|cn_new
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_BEFORE
argument_list|(
name|cn
argument_list|,
name|cn_new
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called After cd9660_sorted_child_insert  * handles file collisions by suffixing each filname with ~n  * where n represents the files respective place in the ordering  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_handle_collisions
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|cd9660node
modifier|*
name|colliding
parameter_list|,
name|int
name|past
parameter_list|)
block|{
name|cd9660node
modifier|*
name|iter
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|int
name|delete_chars
init|=
literal|0
decl_stmt|;
name|int
name|temp_past
init|=
name|past
decl_stmt|;
name|int
name|temp_skip
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|cd9660node
modifier|*
name|end_of_range
decl_stmt|;
for|for
control|(
name|iter
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|colliding
operator|->
name|cn_children
argument_list|)
init|;
name|iter
operator|!=
name|NULL
operator|&&
operator|(
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|iter
argument_list|,
name|cn_next_child
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|iter
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|,
name|next
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|iter
operator|=
name|TAILQ_NEXT
argument_list|(
name|iter
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|flag
operator|=
literal|1
expr_stmt|;
name|temp_skip
operator|=
name|skip
operator|=
name|cd9660_count_collisions
argument_list|(
name|iter
argument_list|)
expr_stmt|;
name|end_of_range
operator|=
name|iter
expr_stmt|;
while|while
condition|(
name|temp_skip
operator|>
literal|0
condition|)
block|{
name|temp_skip
operator|--
expr_stmt|;
name|end_of_range
operator|=
name|TAILQ_NEXT
argument_list|(
name|end_of_range
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
block|}
name|temp_past
operator|=
name|past
expr_stmt|;
while|while
condition|(
name|temp_past
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|end_of_range
argument_list|,
name|cn_next_child
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|end_of_range
operator|=
name|next
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|prev
operator|=
name|TAILQ_PREV
argument_list|(
name|iter
argument_list|,
name|cd9660_children_head
argument_list|,
name|cn_next_child
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|iter
operator|=
name|prev
expr_stmt|;
else|else
name|delete_chars
operator|++
expr_stmt|;
name|temp_past
operator|--
expr_stmt|;
block|}
name|skip
operator|+=
name|past
expr_stmt|;
name|iter
operator|=
name|cd9660_rename_filename
argument_list|(
name|diskStructure
argument_list|,
name|iter
argument_list|,
name|skip
argument_list|,
name|delete_chars
argument_list|)
expr_stmt|;
block|}
return|return
name|flag
return|;
block|}
end_function

begin_function
specifier|static
name|cd9660node
modifier|*
name|cd9660_rename_filename
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|cd9660node
modifier|*
name|iter
parameter_list|,
name|int
name|num
parameter_list|,
name|int
name|delete_chars
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|numbts
decl_stmt|,
name|digit
decl_stmt|,
name|digits
decl_stmt|,
name|temp
decl_stmt|,
name|powers
decl_stmt|,
name|count
decl_stmt|;
name|char
modifier|*
name|naming
decl_stmt|;
name|int
name|maxlength
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Rename_filename called\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|1
operator|<=
name|diskStructure
operator|->
name|isoLevel
operator|&&
name|diskStructure
operator|->
name|isoLevel
operator|<=
literal|2
argument_list|)
expr_stmt|;
comment|/* TODO : A LOT of chanes regarding 8.3 filenames */
if|if
condition|(
name|diskStructure
operator|->
name|isoLevel
operator|==
literal|1
condition|)
name|maxlength
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|diskStructure
operator|->
name|isoLevel
operator|==
literal|2
condition|)
name|maxlength
operator|=
literal|31
expr_stmt|;
else|else
name|maxlength
operator|=
name|ISO_FILENAME_MAXLENGTH_BEFORE_VERSION
expr_stmt|;
name|tmp
operator|=
name|emalloc
argument_list|(
name|ISO_FILENAME_MAXLENGTH_WITH_PADDING
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|num
operator|&&
name|iter
condition|)
block|{
name|powers
operator|=
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|digits
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
call|(
name|int
call|)
argument_list|(
name|i
operator|/
name|powers
argument_list|)
operator|)
operator|>=
literal|10
condition|)
block|{
name|digits
operator|++
expr_stmt|;
name|powers
operator|=
name|powers
operator|*
literal|10
expr_stmt|;
block|}
name|naming
operator|=
name|iter
operator|->
name|o_name
expr_stmt|;
comment|/* 		while ((*naming != '.')&& (*naming != ';')) { 			naming++; 			count++; 		} 		*/
while|while
condition|(
name|count
operator|<
name|maxlength
condition|)
block|{
if|if
condition|(
operator|*
name|naming
operator|==
literal|';'
condition|)
break|break;
name|naming
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|count
operator|+
name|digits
operator|)
operator|<
name|maxlength
condition|)
name|numbts
operator|=
name|count
expr_stmt|;
else|else
name|numbts
operator|=
name|maxlength
operator|-
operator|(
name|digits
operator|)
expr_stmt|;
name|numbts
operator|-=
name|delete_chars
expr_stmt|;
comment|/* 8.3 rules - keep the extension, add before the dot */
comment|/* 		 * This code makes a bunch of assumptions. 		 * See if you can spot them all :) 		 */
if|#
directive|if
literal|0
block|if (diskStructure->isoLevel == 1) { 			numbts = 8 - digits - delete_chars; 			if (dot< 0) {  			} else { 				if (dot< 8) { 					memmove(&tmp[numbts],&tmp[dot],4); 				} 			} 		}
endif|#
directive|endif
comment|/* (copying just the filename before the '.' */
name|memcpy
argument_list|(
name|tmp
argument_list|,
operator|(
name|iter
operator|->
name|o_name
operator|)
argument_list|,
name|numbts
argument_list|)
expr_stmt|;
comment|/* adding the appropriate number following the name */
name|temp
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|digits
operator|>
literal|0
condition|)
block|{
name|digit
operator|=
call|(
name|int
call|)
argument_list|(
name|temp
operator|/
name|powers
argument_list|)
expr_stmt|;
name|temp
operator|=
name|temp
operator|-
name|digit
operator|*
name|powers
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|tmp
index|[
name|numbts
index|]
argument_list|,
literal|"%d"
argument_list|,
name|digit
argument_list|)
expr_stmt|;
name|digits
operator|--
expr_stmt|;
name|numbts
operator|++
expr_stmt|;
name|powers
operator|=
name|powers
operator|/
literal|10
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|naming
operator|!=
literal|';'
operator|)
operator|&&
operator|(
name|numbts
operator|<
name|maxlength
operator|)
condition|)
block|{
name|tmp
index|[
name|numbts
index|]
operator|=
operator|(
operator|*
name|naming
operator|)
expr_stmt|;
name|naming
operator|++
expr_stmt|;
name|numbts
operator|++
expr_stmt|;
block|}
name|tmp
index|[
name|numbts
index|]
operator|=
literal|';'
expr_stmt|;
name|tmp
index|[
name|numbts
operator|+
literal|1
index|]
operator|=
literal|'1'
expr_stmt|;
name|tmp
index|[
name|numbts
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 		 * now tmp has exactly the identifier 		 * we want so we'll copy it back to record 		 */
name|memcpy
argument_list|(
operator|(
name|iter
operator|->
name|isoDirRecord
operator|->
name|name
operator|)
argument_list|,
name|tmp
argument_list|,
name|numbts
operator|+
literal|3
argument_list|)
expr_stmt|;
name|iter
operator|=
name|TAILQ_NEXT
argument_list|(
name|iter
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|iter
return|;
block|}
end_function

begin_comment
comment|/* Todo: Figure out why these functions are nec. */
end_comment

begin_function
specifier|static
name|void
name|cd9660_copy_filenames
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|cd9660node
modifier|*
name|node
parameter_list|)
block|{
name|cd9660node
modifier|*
name|cn
decl_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|node
operator|->
name|cn_children
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|node
operator|->
name|cn_children
argument_list|)
operator|->
name|isoDirRecord
operator|==
name|NULL
condition|)
block|{
name|debug_print_tree
argument_list|(
name|diskStructure
argument_list|,
name|diskStructure
operator|->
name|rootNode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|cn
argument_list|,
argument|&node->cn_children
argument_list|,
argument|cn_next_child
argument_list|)
block|{
name|cd9660_copy_filenames
argument_list|(
name|diskStructure
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cn
operator|->
name|o_name
argument_list|,
name|cn
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|,
name|ISO_FILENAME_MAXLENGTH_WITH_PADDING
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cd9660_sorting_nodes
parameter_list|(
name|cd9660node
modifier|*
name|node
parameter_list|)
block|{
name|cd9660node
modifier|*
name|cn
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cn
argument_list|,
argument|&node->cn_children
argument_list|,
argument|cn_next_child
argument_list|)
name|cd9660_sorting_nodes
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|cd9660_sort_nodes
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX Bubble sort. */
end_comment

begin_function
specifier|static
name|void
name|cd9660_sort_nodes
parameter_list|(
name|cd9660node
modifier|*
name|node
parameter_list|)
block|{
name|cd9660node
modifier|*
name|cn
decl_stmt|,
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|TAILQ_FOREACH
argument_list|(
argument|cn
argument_list|,
argument|&node->cn_children
argument_list|,
argument|cn_next_child
argument_list|)
block|{
if|if
condition|(
operator|(
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|cn
argument_list|,
name|cn_next_child
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|next
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|,
name|cn
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|)
operator|>=
literal|0
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|node
operator|->
name|cn_children
argument_list|,
name|next
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|cn
argument_list|,
name|next
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|cn
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|cd9660_count_collisions
parameter_list|(
name|cd9660node
modifier|*
name|copy
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|cd9660node
modifier|*
name|iter
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|iter
operator|=
name|copy
init|;
operator|(
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|iter
argument_list|,
name|cn_next_child
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|iter
operator|=
name|next
control|)
block|{
if|if
condition|(
name|cd9660_compare_filename
argument_list|(
name|iter
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|,
name|next
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|count
operator|++
expr_stmt|;
else|else
return|return
name|count
return|;
block|}
if|#
directive|if
literal|0
block|if ((next = TAILQ_NEXT(iter, cn_next_child)) != NULL) { 		printf("%s: count is %i\n", __func__, count); 		compare = cd9660_compare_filename(iter->isoDirRecord->name, 			next->isoDirRecord->name); 		if (compare == 0) { 			count++; 			return cd9660_recurse_on_collision(next, count); 		} else 			return count; 	}
endif|#
directive|endif
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|cd9660node
modifier|*
name|cd9660_rrip_move_directory
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|cd9660node
modifier|*
name|dir
parameter_list|)
block|{
name|char
name|newname
index|[
literal|9
index|]
decl_stmt|;
name|cd9660node
modifier|*
name|tfile
decl_stmt|;
comment|/* 	 * This function needs to: 	 * 1) Create an empty virtual file in place of the old directory 	 * 2) Point the virtual file to the new directory 	 * 3) Point the relocated directory to its old parent 	 * 4) Move the directory specified by dir into rr_moved_dir, 	 * and rename it to "diskStructure->rock_ridge_move_count" (as a string) 	 */
comment|/* First see if the moved directory even exists */
if|if
condition|(
name|diskStructure
operator|->
name|rr_moved_dir
operator|==
name|NULL
condition|)
block|{
name|diskStructure
operator|->
name|rr_moved_dir
operator|=
name|cd9660_create_directory
argument_list|(
name|diskStructure
argument_list|,
name|ISO_RRIP_DEFAULT_MOVE_DIR_NAME
argument_list|,
name|diskStructure
operator|->
name|rootNode
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|rr_moved_dir
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|cd9660_time_915
argument_list|(
name|diskStructure
operator|->
name|rr_moved_dir
operator|->
name|isoDirRecord
operator|->
name|date
argument_list|,
name|stampst
operator|.
name|st_ino
condition|?
name|stampst
operator|.
name|st_mtime
else|:
name|start_time
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
block|}
comment|/* Create a file with the same ORIGINAL name */
name|tfile
operator|=
name|cd9660_create_file
argument_list|(
name|diskStructure
argument_list|,
name|dir
operator|->
name|node
operator|->
name|name
argument_list|,
name|dir
operator|->
name|parent
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfile
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|diskStructure
operator|->
name|rock_ridge_move_count
operator|++
expr_stmt|;
name|snprintf
argument_list|(
name|newname
argument_list|,
sizeof|sizeof
argument_list|(
name|newname
argument_list|)
argument_list|,
literal|"%08i"
argument_list|,
name|diskStructure
operator|->
name|rock_ridge_move_count
argument_list|)
expr_stmt|;
comment|/* Point to old parent */
name|dir
operator|->
name|rr_real_parent
operator|=
name|dir
operator|->
name|parent
expr_stmt|;
comment|/* Place the placeholder file */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|dir
operator|->
name|rr_real_parent
operator|->
name|cn_children
argument_list|)
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|dir
operator|->
name|rr_real_parent
operator|->
name|cn_children
argument_list|,
name|tfile
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cd9660_sorted_child_insert
argument_list|(
name|dir
operator|->
name|rr_real_parent
argument_list|,
name|tfile
argument_list|)
expr_stmt|;
block|}
comment|/* Point to new parent */
name|dir
operator|->
name|parent
operator|=
name|diskStructure
operator|->
name|rr_moved_dir
expr_stmt|;
comment|/* Point the file to the moved directory */
name|tfile
operator|->
name|rr_relocated
operator|=
name|dir
expr_stmt|;
comment|/* Actually move the directory */
name|cd9660_sorted_child_insert
argument_list|(
name|diskStructure
operator|->
name|rr_moved_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* TODO: Inherit permissions / ownership (basically the entire inode) */
comment|/* Set the new name */
name|memset
argument_list|(
name|dir
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|,
literal|0
argument_list|,
name|ISO_FILENAME_MAXLENGTH_WITH_PADDING
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dir
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|,
name|newname
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|dir
operator|->
name|isoDirRecord
operator|->
name|length
index|[
literal|0
index|]
operator|=
literal|34
operator|+
literal|8
expr_stmt|;
name|dir
operator|->
name|isoDirRecord
operator|->
name|name_len
index|[
literal|0
index|]
operator|=
literal|8
expr_stmt|;
return|return
name|dir
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cd9660_add_dot_records
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|cd9660node
modifier|*
name|root
parameter_list|)
block|{
name|struct
name|cd9660_children_head
modifier|*
name|head
init|=
operator|&
name|root
operator|->
name|cn_children
decl_stmt|;
name|cd9660node
modifier|*
name|cn
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cn
argument_list|,
argument|head
argument_list|,
argument|cn_next_child
argument_list|)
block|{
if|if
condition|(
operator|(
name|cn
operator|->
name|type
operator|&
name|CD9660_TYPE_DIR
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Recursion first */
name|cd9660_add_dot_records
argument_list|(
name|diskStructure
argument_list|,
name|cn
argument_list|)
expr_stmt|;
block|}
name|cd9660_create_special_directory
argument_list|(
name|diskStructure
argument_list|,
name|CD9660_TYPE_DOT
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|cd9660_create_special_directory
argument_list|(
name|diskStructure
argument_list|,
name|CD9660_TYPE_DOTDOT
argument_list|,
name|root
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Convert node to cd9660 structure  * This function is designed to be called recursively on the root node of  * the filesystem  * Lots of recursion going on here, want to make sure it is efficient  * @param struct fsnode * The root node to be converted  * @param struct cd9660* The parent node (should not be NULL)  * @param int Current directory depth  * @param int* Running count of the number of directories that are being created  */
end_comment

begin_function
specifier|static
name|void
name|cd9660_convert_structure
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|fsnode
modifier|*
name|root
parameter_list|,
name|cd9660node
modifier|*
name|parent_node
parameter_list|,
name|int
name|level
parameter_list|,
name|int
modifier|*
name|numDirectories
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|fsnode
modifier|*
name|iterator
init|=
name|root
decl_stmt|;
name|cd9660node
modifier|*
name|this_node
decl_stmt|;
name|int
name|working_level
decl_stmt|;
name|int
name|add
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
comment|/* 	 * Newer, more efficient method, reduces recursion depth 	 */
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: root is null"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Test for an empty directory - makefs still gives us the . record */
if|if
condition|(
operator|(
name|S_ISDIR
argument_list|(
name|root
operator|->
name|type
argument_list|)
operator|)
operator|&&
operator|(
name|root
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|root
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|root
operator|=
name|root
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
return|return;
block|}
if|if
condition|(
operator|(
name|this_node
operator|=
name|cd9660_allocate_cd9660node
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|CD9660_MEM_ALLOC_ERROR
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * To reduce the number of recursive calls, we will iterate over 	 * the next pointers to the right. 	 */
while|while
condition|(
name|iterator
operator|!=
name|NULL
condition|)
block|{
name|add
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Increment the directory count if this is a directory 		 * Ignore "." entries. We will generate them later 		 */
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|iterator
operator|->
name|type
argument_list|)
operator|||
name|strcmp
argument_list|(
name|iterator
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Translate the node, including its filename */
name|this_node
operator|->
name|parent
operator|=
name|parent_node
expr_stmt|;
name|cd9660_translate_node
argument_list|(
name|diskStructure
argument_list|,
name|iterator
argument_list|,
name|this_node
argument_list|)
expr_stmt|;
name|this_node
operator|->
name|level
operator|=
name|level
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|iterator
operator|->
name|type
argument_list|)
condition|)
block|{
operator|(
operator|*
name|numDirectories
operator|)
operator|++
expr_stmt|;
name|this_node
operator|->
name|type
operator|=
name|CD9660_TYPE_DIR
expr_stmt|;
name|working_level
operator|=
name|level
operator|+
literal|1
expr_stmt|;
comment|/* 				 * If at level 8, directory would be at 8 				 * and have children at 9 which is not 				 * allowed as per ISO spec 				 */
if|if
condition|(
name|level
operator|==
literal|8
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|diskStructure
operator|->
name|allow_deep_trees
operator|)
operator|&&
operator|(
operator|!
name|diskStructure
operator|->
name|rock_ridge_enabled
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"error: found entry "
literal|"with depth greater "
literal|"than 8."
argument_list|)
expr_stmt|;
operator|(
operator|*
name|error
operator|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|diskStructure
operator|->
name|rock_ridge_enabled
condition|)
block|{
name|working_level
operator|=
literal|3
expr_stmt|;
comment|/* 						 * Moved directory is actually 						 * at level 2. 						 */
name|this_node
operator|->
name|level
operator|=
name|working_level
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cd9660_rrip_move_directory
argument_list|(
name|diskStructure
argument_list|,
name|this_node
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Failure in "
literal|"cd9660_rrip_"
literal|"move_directory"
argument_list|)
expr_stmt|;
operator|(
operator|*
name|error
operator|)
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|add
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Do the recursive call on the children */
if|if
condition|(
name|iterator
operator|->
name|child
operator|!=
name|NULL
condition|)
block|{
name|cd9660_convert_structure
argument_list|(
name|diskStructure
argument_list|,
name|iterator
operator|->
name|child
argument_list|,
name|this_node
argument_list|,
name|working_level
argument_list|,
name|numDirectories
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|error
operator|)
operator|==
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: Error on recursive "
literal|"call"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
comment|/* Only directories should have children */
name|assert
argument_list|(
name|iterator
operator|->
name|child
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|this_node
operator|->
name|type
operator|=
name|CD9660_TYPE_FILE
expr_stmt|;
block|}
comment|/* 			 * Finally, do a sorted insert 			 */
if|if
condition|(
name|add
condition|)
block|{
name|cd9660_sorted_child_insert
argument_list|(
name|parent_node
argument_list|,
name|this_node
argument_list|)
expr_stmt|;
block|}
comment|/*Allocate new temp_node */
if|if
condition|(
name|iterator
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|this_node
operator|=
name|cd9660_allocate_cd9660node
argument_list|()
expr_stmt|;
if|if
condition|(
name|this_node
operator|==
name|NULL
condition|)
name|CD9660_MEM_ALLOC_ERROR
argument_list|(
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
name|iterator
operator|=
name|iterator
operator|->
name|next
expr_stmt|;
block|}
comment|/* cd9660_handle_collisions(first_node); */
comment|/* TODO: need cleanup */
name|cd9660_copy_filenames
argument_list|(
name|diskStructure
argument_list|,
name|parent_node
argument_list|)
expr_stmt|;
do|do
block|{
name|flag
operator|=
name|cd9660_handle_collisions
argument_list|(
name|diskStructure
argument_list|,
name|parent_node
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
name|cd9660_sorting_nodes
argument_list|(
name|parent_node
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|flag
operator|==
literal|1
operator|)
operator|&&
operator|(
name|counter
operator|<
literal|100
operator|)
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Clean up the cd9660node tree  * This is designed to be called recursively on the root node  * @param struct cd9660node *root The node to free  * @returns void  */
end_comment

begin_function
specifier|static
name|void
name|cd9660_free_structure
parameter_list|(
name|cd9660node
modifier|*
name|root
parameter_list|)
block|{
name|cd9660node
modifier|*
name|cn
decl_stmt|;
while|while
condition|(
operator|(
name|cn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|root
operator|->
name|cn_children
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|root
operator|->
name|cn_children
argument_list|,
name|cn
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
name|cd9660_free_structure
argument_list|(
name|cn
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|root
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Be a little more memory conservative:  * instead of having the TAILQ_ENTRY as part of the cd9660node,  * just create a temporary structure  */
end_comment

begin_struct
specifier|static
struct|struct
name|ptq_entry
block|{
name|TAILQ_ENTRY
argument_list|(
argument|ptq_entry
argument_list|)
name|ptq
expr_stmt|;
name|cd9660node
modifier|*
name|node
decl_stmt|;
block|}
modifier|*
name|n
struct|;
end_struct

begin_define
define|#
directive|define
name|PTQUEUE_NEW
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|,
name|r
parameter_list|,
name|t
parameter_list|)
value|{\ 	n = emalloc(sizeof(struct s));	\ 	n->node = t;\ }
end_define

begin_comment
comment|/*  * Generate the path tables  * The specific implementation of this function is left as an exercise to the  * programmer. It could be done recursively. Make sure you read how the path  * table has to be laid out, it has levels.  * @param struct iso9660_disk *disk The disk image  * @returns int The number of built path tables (between 1 and 4), 0 on failure  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_generate_path_table
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|)
block|{
name|cd9660node
modifier|*
name|cn
decl_stmt|,
modifier|*
name|dirNode
init|=
name|diskStructure
operator|->
name|rootNode
decl_stmt|;
name|cd9660node
modifier|*
name|last
init|=
name|dirNode
decl_stmt|;
name|int
name|pathTableSize
init|=
literal|0
decl_stmt|;
comment|/* computed as we go */
name|int
name|counter
init|=
literal|1
decl_stmt|;
comment|/* root gets a count of 0 */
name|TAILQ_HEAD
argument_list|(
argument|cd9660_pt_head
argument_list|,
argument|ptq_entry
argument_list|)
name|pt_head
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pt_head
argument_list|)
expr_stmt|;
name|PTQUEUE_NEW
argument_list|(
name|n
argument_list|,
name|ptq_entry
argument_list|,
operator|-
literal|1
argument_list|,
name|diskStructure
operator|->
name|rootNode
argument_list|)
expr_stmt|;
comment|/* Push the root node */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pt_head
argument_list|,
name|n
argument_list|,
name|ptq
argument_list|)
expr_stmt|;
comment|/* Breadth-first traversal of file structure */
while|while
condition|(
name|pt_head
operator|.
name|tqh_first
operator|!=
literal|0
condition|)
block|{
name|n
operator|=
name|pt_head
operator|.
name|tqh_first
expr_stmt|;
name|dirNode
operator|=
name|n
operator|->
name|node
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pt_head
argument_list|,
name|pt_head
operator|.
name|tqh_first
argument_list|,
name|ptq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Update the size */
name|pathTableSize
operator|+=
name|ISO_PATHTABLE_ENTRY_BASESIZE
operator|+
name|dirNode
operator|->
name|isoDirRecord
operator|->
name|name_len
index|[
literal|0
index|]
operator|+
operator|(
name|dirNode
operator|->
name|isoDirRecord
operator|->
name|name_len
index|[
literal|0
index|]
operator|%
literal|2
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
comment|/* includes the padding bit */
name|dirNode
operator|->
name|ptnumber
operator|=
name|counter
expr_stmt|;
if|if
condition|(
name|dirNode
operator|!=
name|last
condition|)
block|{
name|last
operator|->
name|ptnext
operator|=
name|dirNode
expr_stmt|;
name|dirNode
operator|->
name|ptprev
operator|=
name|last
expr_stmt|;
block|}
name|last
operator|=
name|dirNode
expr_stmt|;
comment|/* Push children onto queue */
name|TAILQ_FOREACH
argument_list|(
argument|cn
argument_list|,
argument|&dirNode->cn_children
argument_list|,
argument|cn_next_child
argument_list|)
block|{
comment|/* 			 * Dont add the DOT and DOTDOT types to the path 			 * table. 			 */
if|if
condition|(
operator|(
name|cn
operator|->
name|type
operator|!=
name|CD9660_TYPE_DOT
operator|)
operator|&&
operator|(
name|cn
operator|->
name|type
operator|!=
name|CD9660_TYPE_DOTDOT
operator|)
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|cn
operator|->
name|node
operator|->
name|type
argument_list|)
condition|)
block|{
name|PTQUEUE_NEW
argument_list|(
name|n
argument_list|,
name|ptq_entry
argument_list|,
operator|-
literal|1
argument_list|,
name|cn
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pt_head
argument_list|,
name|n
argument_list|,
name|ptq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|counter
operator|++
expr_stmt|;
block|}
return|return
name|pathTableSize
return|;
block|}
end_function

begin_function
name|void
name|cd9660_compute_full_filename
parameter_list|(
name|cd9660node
modifier|*
name|node
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|CD9660MAXPATH
operator|+
literal|1
expr_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|node
operator|->
name|node
operator|->
name|root
argument_list|,
name|node
operator|->
name|node
operator|->
name|path
argument_list|,
name|node
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|CD9660MAXPATH
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Pathname too long."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NEW filename conversion method */
end_comment

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|cd9660_filename_conversion_functor
function_decl|)
parameter_list|(
name|iso9660_disk
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * TODO: These two functions are almost identical.  * Some code cleanup is possible here  *  * XXX bounds checking!  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_level1_convert_filename
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
specifier|const
name|char
modifier|*
name|oldname
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|int
name|is_file
parameter_list|)
block|{
comment|/* 	 * ISO 9660 : 10.1 	 * File Name shall not contain more than 8 d or d1 characters 	 * File Name Extension shall not contain more than 3 d or d1 characters 	 * Directory Identifier shall not contain more than 8 d or d1 characters 	 */
name|int
name|namelen
init|=
literal|0
decl_stmt|;
name|int
name|extlen
init|=
literal|0
decl_stmt|;
name|int
name|found_ext
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|oldname
operator|!=
literal|'\0'
operator|&&
name|extlen
operator|<
literal|3
condition|)
block|{
comment|/* Handle period first, as it is special */
if|if
condition|(
operator|*
name|oldname
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|found_ext
condition|)
block|{
operator|*
name|newname
operator|++
operator|=
literal|'_'
expr_stmt|;
name|extlen
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|newname
operator|++
operator|=
literal|'.'
expr_stmt|;
name|found_ext
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* cut RISC OS file type off ISO name */
if|if
condition|(
name|diskStructure
operator|->
name|archimedes_enabled
operator|&&
operator|*
name|oldname
operator|==
literal|','
operator|&&
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|==
literal|4
condition|)
break|break;
comment|/* Enforce 12.3 / 8 */
if|if
condition|(
name|namelen
operator|==
literal|8
operator|&&
operator|!
name|found_ext
condition|)
break|break;
if|if
condition|(
name|islower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|oldname
argument_list|)
condition|)
operator|*
name|newname
operator|++
operator|=
name|toupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|oldname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|oldname
argument_list|)
operator|||
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|oldname
argument_list|)
condition|)
operator|*
name|newname
operator|++
operator|=
operator|*
name|oldname
expr_stmt|;
else|else
operator|*
name|newname
operator|++
operator|=
literal|'_'
expr_stmt|;
if|if
condition|(
name|found_ext
condition|)
name|extlen
operator|++
expr_stmt|;
else|else
name|namelen
operator|++
expr_stmt|;
block|}
name|oldname
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|is_file
condition|)
block|{
if|if
condition|(
operator|!
name|found_ext
operator|&&
operator|!
name|diskStructure
operator|->
name|omit_trailing_period
condition|)
operator|*
name|newname
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* Add version */
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|";%i"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|namelen
operator|+
name|extlen
operator|+
name|found_ext
return|;
block|}
end_function

begin_comment
comment|/* XXX bounds checking! */
end_comment

begin_function
specifier|static
name|int
name|cd9660_level2_convert_filename
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
specifier|const
name|char
modifier|*
name|oldname
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|int
name|is_file
parameter_list|)
block|{
comment|/* 	 * ISO 9660 : 7.5.1 	 * File name : 0+ d or d1 characters 	 * separator 1 (.) 	 * File name extension : 0+ d or d1 characters 	 * separator 2 (;) 	 * File version number (5 characters, 1-32767) 	 * 1<= Sum of File name and File name extension<= 30 	 */
name|int
name|namelen
init|=
literal|0
decl_stmt|;
name|int
name|extlen
init|=
literal|0
decl_stmt|;
name|int
name|found_ext
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|oldname
operator|!=
literal|'\0'
operator|&&
name|namelen
operator|+
name|extlen
operator|<
literal|30
condition|)
block|{
comment|/* Handle period first, as it is special */
if|if
condition|(
operator|*
name|oldname
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|found_ext
condition|)
block|{
if|if
condition|(
name|diskStructure
operator|->
name|allow_multidot
condition|)
block|{
operator|*
name|newname
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|newname
operator|++
operator|=
literal|'_'
expr_stmt|;
block|}
name|extlen
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|newname
operator|++
operator|=
literal|'.'
expr_stmt|;
name|found_ext
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* cut RISC OS file type off ISO name */
if|if
condition|(
name|diskStructure
operator|->
name|archimedes_enabled
operator|&&
operator|*
name|oldname
operator|==
literal|','
operator|&&
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|==
literal|4
condition|)
break|break;
if|if
condition|(
name|islower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|oldname
argument_list|)
condition|)
operator|*
name|newname
operator|++
operator|=
name|toupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|oldname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|oldname
argument_list|)
operator|||
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|oldname
argument_list|)
condition|)
operator|*
name|newname
operator|++
operator|=
operator|*
name|oldname
expr_stmt|;
elseif|else
if|if
condition|(
name|diskStructure
operator|->
name|allow_multidot
operator|&&
operator|*
name|oldname
operator|==
literal|'.'
condition|)
block|{
operator|*
name|newname
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|newname
operator|++
operator|=
literal|'_'
expr_stmt|;
block|}
if|if
condition|(
name|found_ext
condition|)
name|extlen
operator|++
expr_stmt|;
else|else
name|namelen
operator|++
expr_stmt|;
block|}
name|oldname
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|is_file
condition|)
block|{
if|if
condition|(
operator|!
name|found_ext
operator|&&
operator|!
name|diskStructure
operator|->
name|omit_trailing_period
condition|)
operator|*
name|newname
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* Add version */
name|sprintf
argument_list|(
name|newname
argument_list|,
literal|";%i"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|namelen
operator|+
name|extlen
operator|+
name|found_ext
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int cd9660_joliet_convert_filename(iso9660_disk *diskStructure, const char *oldname,     char *newname, int is_file) {
comment|/* TODO: implement later, move to cd9660_joliet.c ?? */
end_comment

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Convert a file name to ISO compliant file name  * @param char * oldname The original filename  * @param char ** newname The new file name, in the appropriate character  *                        set and of appropriate length  * @param int 1 if file, 0 if directory  * @returns int The length of the new string  */
end_comment

begin_function
specifier|static
name|int
name|cd9660_convert_filename
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
specifier|const
name|char
modifier|*
name|oldname
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|int
name|is_file
parameter_list|)
block|{
name|assert
argument_list|(
literal|1
operator|<=
name|diskStructure
operator|->
name|isoLevel
operator|&&
name|diskStructure
operator|->
name|isoLevel
operator|<=
literal|2
argument_list|)
expr_stmt|;
comment|/* NEW */
name|cd9660_filename_conversion_functor
name|conversion_function
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|isoLevel
operator|==
literal|1
condition|)
name|conversion_function
operator|=
operator|&
name|cd9660_level1_convert_filename
expr_stmt|;
elseif|else
if|if
condition|(
name|diskStructure
operator|->
name|isoLevel
operator|==
literal|2
condition|)
name|conversion_function
operator|=
operator|&
name|cd9660_level2_convert_filename
expr_stmt|;
return|return
call|(
modifier|*
name|conversion_function
call|)
argument_list|(
name|diskStructure
argument_list|,
name|oldname
argument_list|,
name|newname
argument_list|,
name|is_file
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|cd9660_compute_record_size
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|cd9660node
modifier|*
name|node
parameter_list|)
block|{
name|int
name|size
init|=
name|node
operator|->
name|isoDirRecord
operator|->
name|length
index|[
literal|0
index|]
decl_stmt|;
if|if
condition|(
name|diskStructure
operator|->
name|rock_ridge_enabled
condition|)
name|size
operator|+=
name|node
operator|->
name|susp_entry_size
expr_stmt|;
name|size
operator|+=
name|node
operator|->
name|su_tail_size
expr_stmt|;
name|size
operator|+=
name|size
operator|&
literal|1
expr_stmt|;
comment|/* Ensure length of record is even. */
name|assert
argument_list|(
name|size
operator|<=
literal|254
argument_list|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cd9660_populate_dot_records
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|cd9660node
modifier|*
name|node
parameter_list|)
block|{
name|node
operator|->
name|dot_record
operator|->
name|fileDataSector
operator|=
name|node
operator|->
name|fileDataSector
expr_stmt|;
name|memcpy
argument_list|(
name|node
operator|->
name|dot_record
operator|->
name|isoDirRecord
argument_list|,
name|node
operator|->
name|isoDirRecord
argument_list|,
literal|34
argument_list|)
expr_stmt|;
name|node
operator|->
name|dot_record
operator|->
name|isoDirRecord
operator|->
name|name_len
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|dot_record
operator|->
name|isoDirRecord
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|dot_record
operator|->
name|isoDirRecord
operator|->
name|name
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|dot_record
operator|->
name|isoDirRecord
operator|->
name|length
index|[
literal|0
index|]
operator|=
literal|34
expr_stmt|;
name|node
operator|->
name|dot_record
operator|->
name|fileRecordSize
operator|=
name|cd9660_compute_record_size
argument_list|(
name|diskStructure
argument_list|,
name|node
operator|->
name|dot_record
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|diskStructure
operator|->
name|rootNode
condition|)
block|{
name|node
operator|->
name|dot_dot_record
operator|->
name|fileDataSector
operator|=
name|node
operator|->
name|fileDataSector
expr_stmt|;
name|memcpy
argument_list|(
name|node
operator|->
name|dot_dot_record
operator|->
name|isoDirRecord
argument_list|,
name|node
operator|->
name|isoDirRecord
argument_list|,
literal|34
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node
operator|->
name|dot_dot_record
operator|->
name|fileDataSector
operator|=
name|node
operator|->
name|parent
operator|->
name|fileDataSector
expr_stmt|;
name|memcpy
argument_list|(
name|node
operator|->
name|dot_dot_record
operator|->
name|isoDirRecord
argument_list|,
name|node
operator|->
name|parent
operator|->
name|isoDirRecord
argument_list|,
literal|34
argument_list|)
expr_stmt|;
block|}
name|node
operator|->
name|dot_dot_record
operator|->
name|isoDirRecord
operator|->
name|name_len
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|dot_dot_record
operator|->
name|isoDirRecord
operator|->
name|name
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
name|node
operator|->
name|dot_dot_record
operator|->
name|isoDirRecord
operator|->
name|name
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|dot_dot_record
operator|->
name|isoDirRecord
operator|->
name|length
index|[
literal|0
index|]
operator|=
literal|34
expr_stmt|;
name|node
operator|->
name|dot_dot_record
operator|->
name|fileRecordSize
operator|=
name|cd9660_compute_record_size
argument_list|(
name|diskStructure
argument_list|,
name|node
operator|->
name|dot_dot_record
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * @param struct cd9660node *node The node  * @param int The offset (in bytes) - SHOULD align to the beginning of a sector  * @returns int The total size of files and directory entries (should be  *              a multiple of sector size) */
end_comment

begin_function
specifier|static
name|int64_t
name|cd9660_compute_offsets
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|cd9660node
modifier|*
name|node
parameter_list|,
name|int64_t
name|startOffset
parameter_list|)
block|{
comment|/* 	 * This function needs to compute the size of directory records and 	 * runs, file lengths, and set the appropriate variables both in 	 * cd9660node and isoDirEntry 	 */
name|int64_t
name|used_bytes
init|=
literal|0
decl_stmt|;
name|int64_t
name|current_sector_usage
init|=
literal|0
decl_stmt|;
name|cd9660node
modifier|*
name|child
decl_stmt|;
name|fsinode
modifier|*
name|inode
decl_stmt|;
name|int64_t
name|r
decl_stmt|;
name|assert
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE : There needs to be some special case detection for 	 * the "real root" node, since for it, node->node is undefined 	 */
name|node
operator|->
name|fileDataSector
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|&
name|CD9660_TYPE_DIR
condition|)
block|{
name|node
operator|->
name|fileRecordSize
operator|=
name|cd9660_compute_record_size
argument_list|(
name|diskStructure
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/*Set what sector this directory starts in*/
name|node
operator|->
name|fileDataSector
operator|=
name|CD9660_BLOCKS
argument_list|(
name|diskStructure
operator|->
name|sectorSize
argument_list|,
name|startOffset
argument_list|)
expr_stmt|;
name|cd9660_bothendian_dword
argument_list|(
name|node
operator|->
name|fileDataSector
argument_list|,
name|node
operator|->
name|isoDirRecord
operator|->
name|extent
argument_list|)
expr_stmt|;
comment|/* 		 * First loop over children, need to know the size of 		 * their directory records 		 */
name|node
operator|->
name|fileSectorsUsed
operator|=
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|child
argument_list|,
argument|&node->cn_children
argument_list|,
argument|cn_next_child
argument_list|)
block|{
name|node
operator|->
name|fileDataLength
operator|+=
name|cd9660_compute_record_size
argument_list|(
name|diskStructure
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cd9660_compute_record_size
argument_list|(
name|diskStructure
argument_list|,
name|child
argument_list|)
operator|+
name|current_sector_usage
operator|)
operator|>=
name|diskStructure
operator|->
name|sectorSize
condition|)
block|{
name|current_sector_usage
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|fileSectorsUsed
operator|++
expr_stmt|;
block|}
name|current_sector_usage
operator|+=
name|cd9660_compute_record_size
argument_list|(
name|diskStructure
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
name|cd9660_bothendian_dword
argument_list|(
name|node
operator|->
name|fileSectorsUsed
operator|*
name|diskStructure
operator|->
name|sectorSize
argument_list|,
name|node
operator|->
name|isoDirRecord
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* 		 * This should point to the sector after the directory 		 * record (or, the first byte in that sector) 		 */
name|used_bytes
operator|+=
name|node
operator|->
name|fileSectorsUsed
operator|*
name|diskStructure
operator|->
name|sectorSize
expr_stmt|;
for|for
control|(
name|child
operator|=
name|TAILQ_NEXT
argument_list|(
name|node
operator|->
name|dot_dot_record
argument_list|,
name|cn_next_child
argument_list|)
init|;
name|child
operator|!=
name|NULL
condition|;
name|child
operator|=
name|TAILQ_NEXT
argument_list|(
name|child
argument_list|,
name|cn_next_child
argument_list|)
control|)
block|{
comment|/* Directories need recursive call */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|child
operator|->
name|node
operator|->
name|type
argument_list|)
condition|)
block|{
name|r
operator|=
name|cd9660_compute_offsets
argument_list|(
name|diskStructure
argument_list|,
name|child
argument_list|,
name|used_bytes
operator|+
name|startOffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
operator|-
literal|1
condition|)
name|used_bytes
operator|+=
name|r
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Explicitly set the . and .. records */
name|cd9660_populate_dot_records
argument_list|(
name|diskStructure
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Finally, do another iteration to write the file data*/
for|for
control|(
name|child
operator|=
name|TAILQ_NEXT
argument_list|(
name|node
operator|->
name|dot_dot_record
argument_list|,
name|cn_next_child
argument_list|)
init|;
name|child
operator|!=
name|NULL
condition|;
name|child
operator|=
name|TAILQ_NEXT
argument_list|(
name|child
argument_list|,
name|cn_next_child
argument_list|)
control|)
block|{
comment|/* Files need extent set */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|child
operator|->
name|node
operator|->
name|type
argument_list|)
condition|)
continue|continue;
name|child
operator|->
name|fileRecordSize
operator|=
name|cd9660_compute_record_size
argument_list|(
name|diskStructure
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|child
operator|->
name|fileSectorsUsed
operator|=
name|CD9660_BLOCKS
argument_list|(
name|diskStructure
operator|->
name|sectorSize
argument_list|,
name|child
operator|->
name|fileDataLength
argument_list|)
expr_stmt|;
name|inode
operator|=
name|child
operator|->
name|node
operator|->
name|inode
expr_stmt|;
if|if
condition|(
operator|(
name|inode
operator|->
name|flags
operator|&
name|FI_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|inode
operator|->
name|ino
operator|=
name|CD9660_BLOCKS
argument_list|(
name|diskStructure
operator|->
name|sectorSize
argument_list|,
name|used_bytes
operator|+
name|startOffset
argument_list|)
expr_stmt|;
name|inode
operator|->
name|flags
operator||=
name|FI_ALLOCATED
expr_stmt|;
name|used_bytes
operator|+=
name|child
operator|->
name|fileSectorsUsed
operator|*
name|diskStructure
operator|->
name|sectorSize
expr_stmt|;
block|}
else|else
block|{
name|INODE_WARNX
argument_list|(
operator|(
literal|"%s: already allocated inode %d "
literal|"data sectors at %"
name|PRIu32
operator|,
name|__func__
operator|,
operator|(
name|int
operator|)
name|inode
operator|->
name|st
operator|.
name|st_ino
operator|,
name|inode
operator|->
name|ino
operator|)
argument_list|)
expr_stmt|;
block|}
name|child
operator|->
name|fileDataSector
operator|=
name|inode
operator|->
name|ino
expr_stmt|;
name|cd9660_bothendian_dword
argument_list|(
name|child
operator|->
name|fileDataSector
argument_list|,
name|child
operator|->
name|isoDirRecord
operator|->
name|extent
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|used_bytes
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Might get rid of this func */
end_comment

begin_comment
unit|static int cd9660_copy_stat_info(cd9660node *from, cd9660node *to, int file) { 	to->node->inode->st.st_dev = 0; 	to->node->inode->st.st_ino = 0; 	to->node->inode->st.st_size = 0; 	to->node->inode->st.st_blksize = from->node->inode->st.st_blksize; 	to->node->inode->st.st_atime = from->node->inode->st.st_atime; 	to->node->inode->st.st_mtime = from->node->inode->st.st_mtime; 	to->node->inode->st.st_ctime = from->node->inode->st.st_ctime; 	to->node->inode->st.st_uid = from->node->inode->st.st_uid; 	to->node->inode->st.st_gid = from->node->inode->st.st_gid; 	to->node->inode->st.st_mode = from->node->inode->st.st_mode;
comment|/* Clear out type */
end_comment

begin_endif
unit|to->node->inode->st.st_mode = to->node->inode->st.st_mode& ~(S_IFMT); 	if (file) 		to->node->inode->st.st_mode |= S_IFREG; 	else 		to->node->inode->st.st_mode |= S_IFDIR; 	return 1; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|cd9660node
modifier|*
name|cd9660_create_virtual_entry
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|cd9660node
modifier|*
name|parent
parameter_list|,
name|int
name|file
parameter_list|,
name|int
name|insert
parameter_list|)
block|{
name|cd9660node
modifier|*
name|temp
decl_stmt|;
name|fsnode
modifier|*
name|tfsnode
decl_stmt|;
name|assert
argument_list|(
name|parent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|temp
operator|=
name|cd9660_allocate_cd9660node
argument_list|()
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|tfsnode
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tfsnode
argument_list|)
argument_list|)
expr_stmt|;
name|tfsnode
operator|->
name|name
operator|=
name|estrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|temp
operator|->
name|isoDirRecord
operator|=
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|temp
operator|->
name|isoDirRecord
argument_list|)
argument_list|)
expr_stmt|;
name|cd9660_convert_filename
argument_list|(
name|diskStructure
argument_list|,
name|tfsnode
operator|->
name|name
argument_list|,
name|temp
operator|->
name|isoDirRecord
operator|->
name|name
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|temp
operator|->
name|node
operator|=
name|tfsnode
expr_stmt|;
name|temp
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|insert
condition|)
block|{
if|if
condition|(
name|temp
operator|->
name|parent
operator|!=
name|NULL
condition|)
block|{
name|temp
operator|->
name|level
operator|=
name|temp
operator|->
name|parent
operator|->
name|level
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|temp
operator|->
name|parent
operator|->
name|cn_children
argument_list|)
condition|)
name|cd9660_sorted_child_insert
argument_list|(
name|temp
operator|->
name|parent
argument_list|,
name|temp
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|temp
operator|->
name|parent
operator|->
name|cn_children
argument_list|,
name|temp
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|parent
operator|->
name|node
operator|!=
name|NULL
condition|)
block|{
name|tfsnode
operator|->
name|type
operator|=
name|parent
operator|->
name|node
operator|->
name|type
expr_stmt|;
block|}
comment|/* Clear out file type bits */
name|tfsnode
operator|->
name|type
operator|&=
operator|~
operator|(
name|S_IFMT
operator|)
expr_stmt|;
if|if
condition|(
name|file
condition|)
name|tfsnode
operator|->
name|type
operator||=
name|S_IFREG
expr_stmt|;
else|else
name|tfsnode
operator|->
name|type
operator||=
name|S_IFDIR
expr_stmt|;
comment|/* Indicate that there is no spec entry (inode) */
name|tfsnode
operator|->
name|flags
operator|&=
operator|~
operator|(
name|FSNODE_F_HASSPEC
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|cd9660_copy_stat_info(parent, temp, file);
endif|#
directive|endif
return|return
name|temp
return|;
block|}
end_function

begin_function
specifier|static
name|cd9660node
modifier|*
name|cd9660_create_file
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|cd9660node
modifier|*
name|parent
parameter_list|,
name|cd9660node
modifier|*
name|me
parameter_list|)
block|{
name|cd9660node
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|cd9660_create_virtual_entry
argument_list|(
name|diskStructure
argument_list|,
name|name
argument_list|,
name|parent
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|temp
operator|->
name|fileDataLength
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|CD9660_TYPE_FILE
operator||
name|CD9660_TYPE_VIRTUAL
expr_stmt|;
name|temp
operator|->
name|node
operator|->
name|inode
operator|=
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|temp
operator|->
name|node
operator|->
name|inode
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|temp
operator|->
name|node
operator|->
name|inode
operator|=
operator|*
name|me
operator|->
name|node
operator|->
name|inode
expr_stmt|;
if|if
condition|(
name|cd9660_translate_node_common
argument_list|(
name|diskStructure
argument_list|,
name|temp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new directory which does not exist on disk  * @param const char * name The name to assign to the directory  * @param const char * parent Pointer to the parent directory  * @returns cd9660node * Pointer to the new directory  */
end_comment

begin_function
specifier|static
name|cd9660node
modifier|*
name|cd9660_create_directory
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|cd9660node
modifier|*
name|parent
parameter_list|,
name|cd9660node
modifier|*
name|me
parameter_list|)
block|{
name|cd9660node
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|cd9660_create_virtual_entry
argument_list|(
name|diskStructure
argument_list|,
name|name
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|temp
operator|->
name|node
operator|->
name|type
operator||=
name|S_IFDIR
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|CD9660_TYPE_DIR
operator||
name|CD9660_TYPE_VIRTUAL
expr_stmt|;
name|temp
operator|->
name|node
operator|->
name|inode
operator|=
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|temp
operator|->
name|node
operator|->
name|inode
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|temp
operator|->
name|node
operator|->
name|inode
operator|=
operator|*
name|me
operator|->
name|node
operator|->
name|inode
expr_stmt|;
if|if
condition|(
name|cd9660_translate_node_common
argument_list|(
name|diskStructure
argument_list|,
name|temp
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|temp
return|;
block|}
end_function

begin_function
specifier|static
name|cd9660node
modifier|*
name|cd9660_create_special_directory
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
name|u_char
name|type
parameter_list|,
name|cd9660node
modifier|*
name|parent
parameter_list|)
block|{
name|cd9660node
modifier|*
name|temp
decl_stmt|,
modifier|*
name|first
decl_stmt|;
name|char
name|na
index|[
literal|2
index|]
decl_stmt|;
name|assert
argument_list|(
name|parent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CD9660_TYPE_DOT
condition|)
name|na
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|CD9660_TYPE_DOTDOT
condition|)
name|na
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
name|na
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|=
name|cd9660_create_virtual_entry
argument_list|(
name|diskStructure
argument_list|,
name|na
argument_list|,
name|parent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|temp
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|temp
operator|->
name|isoDirRecord
operator|->
name|length
index|[
literal|0
index|]
operator|=
literal|34
expr_stmt|;
comment|/* Dot record is always first */
if|if
condition|(
name|type
operator|==
name|CD9660_TYPE_DOT
condition|)
block|{
name|parent
operator|->
name|dot_record
operator|=
name|temp
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|parent
operator|->
name|cn_children
argument_list|,
name|temp
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
comment|/* DotDot should be second */
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|CD9660_TYPE_DOTDOT
condition|)
block|{
name|parent
operator|->
name|dot_dot_record
operator|=
name|temp
expr_stmt|;
comment|/*                  * If the first child is the dot record, insert                  * this second.  Otherwise, insert it at the head. 		 */
if|if
condition|(
operator|(
name|first
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|parent
operator|->
name|cn_children
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|first
operator|->
name|type
operator|&
name|CD9660_TYPE_DOT
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|parent
operator|->
name|cn_children
argument_list|,
name|temp
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|parent
operator|->
name|cn_children
argument_list|,
name|first
argument_list|,
name|temp
argument_list|,
name|cn_next_child
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|temp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cd9660_add_generic_bootimage
parameter_list|(
name|iso9660_disk
modifier|*
name|diskStructure
parameter_list|,
specifier|const
name|char
modifier|*
name|bootimage
parameter_list|)
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
name|assert
argument_list|(
name|bootimage
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bootimage
operator|==
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"Error: Boot image must be a filename"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|diskStructure
operator|->
name|generic_bootimage
operator|=
name|estrdup
argument_list|(
name|bootimage
argument_list|)
expr_stmt|;
comment|/* Get information about the file */
if|if
condition|(
name|lstat
argument_list|(
name|diskStructure
operator|->
name|generic_bootimage
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"%s: lstat(\"%s\")"
argument_list|,
name|__func__
argument_list|,
name|diskStructure
operator|->
name|generic_bootimage
argument_list|)
expr_stmt|;
if|if
condition|(
name|stbuf
operator|.
name|st_size
operator|>
literal|32768
condition|)
block|{
name|warnx
argument_list|(
literal|"Error: Boot image must be no greater than 32768 bytes"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|diskStructure
operator|->
name|verbose_level
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Generic boot image image has size %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|stbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
name|diskStructure
operator|->
name|has_generic_bootimage
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

