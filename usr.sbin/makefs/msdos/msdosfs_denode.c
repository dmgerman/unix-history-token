begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: msdosfs_denode.c,v 1.7 2015/03/29 05:52:59 agc Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 1994, 1995, 1997 Wolfgang Solfrank.  * Copyright (C) 1994, 1995, 1997 TooLs GmbH.  * All rights reserved.  * Original code by Paul Popelka (paulp@uts.amdahl.com) (see below).  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by TooLs GmbH.  * 4. The name of TooLs GmbH may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Written by Paul Popelka (paulp@uts.amdahl.com)  *  * You can do anything you want with this software, just don't say you wrote  * it, and don't remove this notice.  *  * This software is provided "as is".  *  * The author supplies this software to be publicly redistributed on the  * understanding that the author is not responsible for the correct  * functioning of this software in any circumstances and is not liable for  * any damages caused by this software.  *  * October 1992  */
end_comment

begin_if
if|#
directive|if
name|HAVE_NBTOOL_CONFIG_H
end_if

begin_include
include|#
directive|include
file|"nbtool_config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<ffs/buf.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/bpb.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/msdosfsmount.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/direntry.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/denode.h>
end_include

begin_include
include|#
directive|include
file|<fs/msdosfs/fat.h>
end_include

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_comment
comment|/*  * If deget() succeeds it returns with the gotten denode locked().  *  * pmp	     - address of msdosfsmount structure of the filesystem containing  *	       the denode of interest.  The pm_dev field and the address of  *	       the msdosfsmount structure are used.  * dirclust  - which cluster bp contains, if dirclust is 0 (root directory)  *	       diroffset is relative to the beginning of the root directory,  *	       otherwise it is cluster relative.  * diroffset - offset past begin of cluster of denode we want  * depp	     - returns the address of the gotten denode.  */
end_comment

begin_function
name|int
name|deget
parameter_list|(
name|struct
name|msdosfsmount
modifier|*
name|pmp
parameter_list|,
name|u_long
name|dirclust
parameter_list|,
name|u_long
name|diroffset
parameter_list|,
name|struct
name|denode
modifier|*
modifier|*
name|depp
parameter_list|)
comment|/* pmp:	 so we know the maj/min number */
comment|/* dirclust:		 cluster this dir entry came from */
comment|/* diroffset:		 index of entry within the cluster */
comment|/* depp:		 returns the addr of the gotten denode */
block|{
name|int
name|error
decl_stmt|;
name|struct
name|direntry
modifier|*
name|direntptr
decl_stmt|;
name|struct
name|denode
modifier|*
name|ldep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"deget(pmp %p, dirclust %lu, diroffset %lx, depp %p)\n"
argument_list|,
name|pmp
argument_list|,
name|dirclust
argument_list|,
name|diroffset
argument_list|,
name|depp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * On FAT32 filesystems, root is a (more or less) normal 	 * directory 	 */
if|if
condition|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
operator|&&
name|dirclust
operator|==
name|MSDOSFSROOT
condition|)
name|dirclust
operator|=
name|pmp
operator|->
name|pm_rootdirblk
expr_stmt|;
name|ldep
operator|=
name|ecalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ldep
argument_list|)
argument_list|)
expr_stmt|;
name|ldep
operator|->
name|de_vnode
operator|=
name|NULL
expr_stmt|;
name|ldep
operator|->
name|de_flag
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_devvp
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_lockf
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_dev
operator|=
name|pmp
operator|->
name|pm_dev
expr_stmt|;
name|ldep
operator|->
name|de_dirclust
operator|=
name|dirclust
expr_stmt|;
name|ldep
operator|->
name|de_diroffset
operator|=
name|diroffset
expr_stmt|;
name|ldep
operator|->
name|de_pmp
operator|=
name|pmp
expr_stmt|;
name|ldep
operator|->
name|de_devvp
operator|=
name|pmp
operator|->
name|pm_devvp
expr_stmt|;
name|ldep
operator|->
name|de_refcnt
operator|=
literal|1
expr_stmt|;
name|fc_purge
argument_list|(
name|ldep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the directory entry into the denode area of the vnode. 	 */
if|if
condition|(
operator|(
name|dirclust
operator|==
name|MSDOSFSROOT
operator|||
operator|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
operator|&&
name|dirclust
operator|==
name|pmp
operator|->
name|pm_rootdirblk
operator|)
operator|)
operator|&&
name|diroffset
operator|==
name|MSDOSFSROOT_OFS
condition|)
block|{
comment|/* 		 * Directory entry for the root directory. There isn't one, 		 * so we manufacture one. We should probably rummage 		 * through the root directory and find a label entry (if it 		 * exists), and then use the time and date from that entry 		 * as the time and date for the root denode. 		 */
name|ldep
operator|->
name|de_vnode
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|ldep
operator|->
name|de_Attributes
operator|=
name|ATTR_DIRECTORY
expr_stmt|;
if|if
condition|(
name|FAT32
argument_list|(
name|pmp
argument_list|)
condition|)
name|ldep
operator|->
name|de_StartCluster
operator|=
name|pmp
operator|->
name|pm_rootdirblk
expr_stmt|;
comment|/* de_FileSize will be filled in further down */
else|else
block|{
name|ldep
operator|->
name|de_StartCluster
operator|=
name|MSDOSFSROOT
expr_stmt|;
name|ldep
operator|->
name|de_FileSize
operator|=
name|pmp
operator|->
name|pm_rootdirsize
operator|*
name|pmp
operator|->
name|pm_BytesPerSec
expr_stmt|;
block|}
comment|/* 		 * fill in time and date so that dos2unixtime() doesn't 		 * spit up when called from msdosfs_getattr() with root 		 * denode 		 */
name|ldep
operator|->
name|de_CHun
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_CTime
operator|=
literal|0x0000
expr_stmt|;
comment|/* 00:00:00	 */
name|ldep
operator|->
name|de_CDate
operator|=
operator|(
literal|0
operator|<<
name|DD_YEAR_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|DD_MONTH_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|DD_DAY_SHIFT
operator|)
expr_stmt|;
comment|/* Jan 1, 1980	 */
name|ldep
operator|->
name|de_ADate
operator|=
name|ldep
operator|->
name|de_CDate
expr_stmt|;
name|ldep
operator|->
name|de_MTime
operator|=
name|ldep
operator|->
name|de_CTime
expr_stmt|;
name|ldep
operator|->
name|de_MDate
operator|=
name|ldep
operator|->
name|de_CDate
expr_stmt|;
comment|/* leave the other fields as garbage */
block|}
else|else
block|{
name|error
operator|=
name|readep
argument_list|(
name|pmp
argument_list|,
name|dirclust
argument_list|,
name|diroffset
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|direntptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ldep
operator|->
name|de_devvp
operator|=
name|NULL
expr_stmt|;
name|ldep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|=
name|SLOT_DELETED
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|DE_INTERNALIZE
argument_list|(
name|ldep
argument_list|,
name|direntptr
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in a few fields of the vnode and finish filling in the 	 * denode.  Then return the address of the found denode. 	 */
if|if
condition|(
name|ldep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
comment|/* 		 * Since DOS directory entries that describe directories 		 * have 0 in the filesize field, we take this opportunity 		 * to find out the length of the directory and plug it into 		 * the denode structure. 		 */
name|u_long
name|size
decl_stmt|;
if|if
condition|(
name|ldep
operator|->
name|de_StartCluster
operator|!=
name|MSDOSFSROOT
condition|)
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|ldep
argument_list|,
name|CLUST_END
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|E2BIG
condition|)
block|{
name|ldep
operator|->
name|de_FileSize
operator|=
name|de_cn2off
argument_list|(
name|pmp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"deget(): pcbmap returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|depp
operator|=
name|ldep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Truncate the file described by dep to the length specified by length.  */
end_comment

begin_function
name|int
name|detrunc
parameter_list|(
name|struct
name|denode
modifier|*
name|dep
parameter_list|,
name|u_long
name|length
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|kauth_cred
modifier|*
name|cred
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|allerror
init|=
literal|0
decl_stmt|;
name|u_long
name|eofentry
decl_stmt|;
name|u_long
name|chaintofree
init|=
literal|0
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|,
name|lastblock
decl_stmt|;
name|int
name|boff
decl_stmt|;
name|int
name|isadir
init|=
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): file %s, length %lu, flags %x\n"
argument_list|,
name|dep
operator|->
name|de_Name
argument_list|,
name|length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Disallow attempts to truncate the root directory since it is of 	 * fixed size.  That's just the way dos filesystems are.  We use 	 * the VROOT bit in the vnode because checking for the directory 	 * bit and a startcluster of 0 in the denode is not adequate to 	 * recognize the root directory at this point in a file or 	 * directory's life. 	 */
if|if
condition|(
name|dep
operator|->
name|de_vnode
operator|!=
name|NULL
operator|&&
operator|!
name|FAT32
argument_list|(
name|pmp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"detrunc(): can't truncate root directory, clust %ld, offset %ld\n"
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|,
name|dep
operator|->
name|de_diroffset
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|dep
operator|->
name|de_FileSize
operator|<
name|length
condition|)
return|return
operator|(
name|deextend
argument_list|(
name|dep
argument_list|,
name|length
argument_list|,
name|cred
argument_list|)
operator|)
return|;
name|lastblock
operator|=
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|length
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If the desired length is 0 then remember the starting cluster of 	 * the file and set the StartCluster field in the directory entry 	 * to 0.  If the desired length is not zero, then get the number of 	 * the last cluster in the shortened file.  Then get the number of 	 * the first cluster in the part of the file that is to be freed. 	 * Then set the next cluster pointer in the last cluster of the 	 * file to CLUST_EOFE. 	 */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|chaintofree
operator|=
name|dep
operator|->
name|de_StartCluster
expr_stmt|;
name|dep
operator|->
name|de_StartCluster
operator|=
literal|0
expr_stmt|;
name|eofentry
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|lastblock
argument_list|,
literal|0
argument_list|,
operator|&
name|eofentry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): pcbmap fails %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * If the new length is not a multiple of the cluster size then we 	 * must zero the tail end of the new last cluster in case it 	 * becomes part of the file again because of a seek. 	 */
if|if
condition|(
operator|(
name|boff
operator|=
name|length
operator|&
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|isadir
condition|)
block|{
name|bn
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|de_bn2kb
argument_list|(
name|pmp
argument_list|,
name|bn
argument_list|)
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|B_MODIFY
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): bread fails %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
name|boff
argument_list|,
literal|0
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|boff
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IO_SYNC
condition|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Write out the updated directory entry.  Even if the update fails 	 * we free the trailing clusters. 	 */
name|dep
operator|->
name|de_FileSize
operator|=
name|length
expr_stmt|;
if|if
condition|(
operator|!
name|isadir
condition|)
name|dep
operator|->
name|de_flag
operator||=
name|DE_UPDATE
operator||
name|DE_MODIFIED
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): allerror %d, eofentry %lu\n"
argument_list|,
name|allerror
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If we need to break the cluster chain for the file then do it 	 * now. 	 */
if|if
condition|(
name|eofentry
operator|!=
operator|(
name|u_long
operator|)
operator|~
literal|0
condition|)
block|{
name|error
operator|=
name|fatentry
argument_list|(
name|FAT_GET_AND_SET
argument_list|,
name|pmp
argument_list|,
name|eofentry
argument_list|,
operator|&
name|chaintofree
argument_list|,
name|CLUST_EOFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): fatentry errors %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Now free the clusters removed from the file because of the 	 * truncation. 	 */
if|if
condition|(
name|chaintofree
operator|!=
literal|0
operator|&&
operator|!
name|MSDOSFSEOF
argument_list|(
name|chaintofree
argument_list|,
name|pmp
operator|->
name|pm_fatmask
argument_list|)
condition|)
name|freeclusterchain
argument_list|(
name|pmp
argument_list|,
name|chaintofree
argument_list|)
expr_stmt|;
return|return
operator|(
name|allerror
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extend the file described by dep to length specified by length.  */
end_comment

begin_function
name|int
name|deextend
parameter_list|(
name|struct
name|denode
modifier|*
name|dep
parameter_list|,
name|u_long
name|length
parameter_list|,
name|struct
name|kauth_cred
modifier|*
name|cred
parameter_list|)
block|{
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|u_long
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * The root of a DOS filesystem cannot be extended. 	 */
if|if
condition|(
name|dep
operator|->
name|de_vnode
operator|!=
name|NULL
operator|&&
operator|!
name|FAT32
argument_list|(
name|pmp
argument_list|)
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * Directories cannot be extended. 	 */
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
return|return
name|EISDIR
return|;
if|if
condition|(
name|length
operator|<=
name|dep
operator|->
name|de_FileSize
condition|)
return|return
name|E2BIG
return|;
comment|/* 	 * Compute the number of clusters to allocate. 	 */
name|count
operator|=
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|length
argument_list|)
operator|-
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>
name|pmp
operator|->
name|pm_freeclustercount
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|error
operator|=
name|extendfile
argument_list|(
name|dep
argument_list|,
name|count
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DE_CLEAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* truncate the added clusters away again */
operator|(
name|void
operator|)
name|detrunc
argument_list|(
name|dep
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Zero extend file range; ubc_zerorange() uses ubc_alloc() and a 	 * memset(); we set the write size so ubc won't read in file data that 	 * is zero'd later. 	 */
name|dep
operator|->
name|de_FileSize
operator|=
name|length
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_UPDATE
operator||
name|DE_MODIFIED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

