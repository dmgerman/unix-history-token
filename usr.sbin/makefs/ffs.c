begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: ffs.c,v 1.44 2009/04/28 22:49:26 joerg Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2001 Wasabi Systems, Inc.  * All rights reserved.  *  * Written by Luke Mewburn for Wasabi Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed for the NetBSD Project by  *      Wasabi Systems, Inc.  * 4. The name of Wasabi Systems, Inc. may not be used to endorse  *    or promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ffs_alloc.c	8.19 (Berkeley) 7/13/95  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"makefs.h"
end_include

begin_include
include|#
directive|include
file|"ffs.h"
end_include

begin_if
if|#
directive|if
name|HAVE_STRUCT_STATVFS_F_IOSIZE
operator|&&
name|HAVE_FSTATVFS
end_if

begin_include
include|#
directive|include
file|<sys/statvfs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|"ffs/ufs_bswap.h"
end_include

begin_include
include|#
directive|include
file|"ffs/ufs_inode.h"
end_include

begin_include
include|#
directive|include
file|"ffs/newfs_extern.h"
end_include

begin_include
include|#
directive|include
file|"ffs/ffs_extern.h"
end_include

begin_undef
undef|#
directive|undef
name|DIP
end_undef

begin_define
define|#
directive|define
name|DIP
parameter_list|(
name|dp
parameter_list|,
name|field
parameter_list|)
define|\
value|((ffs_opts->version == 1) ? \ 	(dp)->ffs1_din.di_##field : (dp)->ffs2_din.di_##field)
end_define

begin_comment
comment|/*  * Various file system defaults (cribbed from newfs(8)).  */
end_comment

begin_define
define|#
directive|define
name|DFL_FRAGSIZE
value|1024
end_define

begin_comment
comment|/* fragment size */
end_comment

begin_define
define|#
directive|define
name|DFL_BLKSIZE
value|8192
end_define

begin_comment
comment|/* block size */
end_comment

begin_define
define|#
directive|define
name|DFL_SECSIZE
value|512
end_define

begin_comment
comment|/* sector size */
end_comment

begin_define
define|#
directive|define
name|DFL_CYLSPERGROUP
value|65536
end_define

begin_comment
comment|/* cylinders per group */
end_comment

begin_define
define|#
directive|define
name|DFL_FRAGSPERINODE
value|4
end_define

begin_comment
comment|/* fragments per inode */
end_comment

begin_define
define|#
directive|define
name|DFL_ROTDELAY
value|0
end_define

begin_comment
comment|/* rotational delay */
end_comment

begin_define
define|#
directive|define
name|DFL_NRPOS
value|1
end_define

begin_comment
comment|/* rotational positions */
end_comment

begin_define
define|#
directive|define
name|DFL_RPM
value|3600
end_define

begin_comment
comment|/* rpm of disk */
end_comment

begin_define
define|#
directive|define
name|DFL_NSECTORS
value|64
end_define

begin_comment
comment|/* # of sectors */
end_comment

begin_define
define|#
directive|define
name|DFL_NTRACKS
value|16
end_define

begin_comment
comment|/* # of tracks */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_char
modifier|*
name|buf
decl_stmt|;
comment|/* buf for directory */
name|doff_t
name|size
decl_stmt|;
comment|/* full size of buf */
name|doff_t
name|cur
decl_stmt|;
comment|/* offset of current entry */
block|}
name|dirbuf_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|ffs_create_image
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|fsinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffs_dump_fsinfo
parameter_list|(
name|fsinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffs_dump_dirbuf
parameter_list|(
name|dirbuf_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffs_make_dirbuf
parameter_list|(
name|dirbuf_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|fsnode
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ffs_populate_dir
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|fsnode
modifier|*
parameter_list|,
name|fsinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffs_size_dir
parameter_list|(
name|fsnode
modifier|*
parameter_list|,
name|fsinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffs_validate
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|fsnode
modifier|*
parameter_list|,
name|fsinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffs_write_file
parameter_list|(
name|union
name|dinode
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|fsinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ffs_write_inode
parameter_list|(
name|union
name|dinode
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
specifier|const
name|fsinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ffs_build_dinode1
parameter_list|(
name|struct
name|ufs1_dinode
modifier|*
parameter_list|,
name|dirbuf_t
modifier|*
parameter_list|,
name|fsnode
modifier|*
parameter_list|,
name|fsnode
modifier|*
parameter_list|,
name|fsinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ffs_build_dinode2
parameter_list|(
name|struct
name|ufs2_dinode
modifier|*
parameter_list|,
name|dirbuf_t
modifier|*
parameter_list|,
name|fsnode
modifier|*
parameter_list|,
name|fsnode
modifier|*
parameter_list|,
name|fsinfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|sectorsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX: for buf.c::getblk() */
end_comment

begin_comment
comment|/* publicly visible functions */
end_comment

begin_function
name|void
name|ffs_prep_opts
parameter_list|(
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|ffs_opt_t
modifier|*
name|ffs_opts
decl_stmt|;
if|if
condition|(
operator|(
name|ffs_opts
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|ffs_opt_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Allocating memory for ffs_options"
argument_list|)
expr_stmt|;
name|fsopts
operator|->
name|fs_specific
operator|=
name|ffs_opts
expr_stmt|;
name|ffs_opts
operator|->
name|bsize
operator|=
operator|-
literal|1
expr_stmt|;
name|ffs_opts
operator|->
name|fsize
operator|=
operator|-
literal|1
expr_stmt|;
name|ffs_opts
operator|->
name|cpg
operator|=
operator|-
literal|1
expr_stmt|;
name|ffs_opts
operator|->
name|density
operator|=
operator|-
literal|1
expr_stmt|;
name|ffs_opts
operator|->
name|minfree
operator|=
operator|-
literal|1
expr_stmt|;
name|ffs_opts
operator|->
name|optimization
operator|=
operator|-
literal|1
expr_stmt|;
name|ffs_opts
operator|->
name|maxcontig
operator|=
operator|-
literal|1
expr_stmt|;
name|ffs_opts
operator|->
name|maxbpg
operator|=
operator|-
literal|1
expr_stmt|;
name|ffs_opts
operator|->
name|avgfilesize
operator|=
operator|-
literal|1
expr_stmt|;
name|ffs_opts
operator|->
name|avgfpdir
operator|=
operator|-
literal|1
expr_stmt|;
name|ffs_opts
operator|->
name|version
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ffs_cleanup_opts
parameter_list|(
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
if|if
condition|(
name|fsopts
operator|->
name|fs_specific
condition|)
name|free
argument_list|(
name|fsopts
operator|->
name|fs_specific
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ffs_parse_opts
parameter_list|(
specifier|const
name|char
modifier|*
name|option
parameter_list|,
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|ffs_opt_t
modifier|*
name|ffs_opts
init|=
name|fsopts
operator|->
name|fs_specific
decl_stmt|;
name|option_t
name|ffs_options
index|[]
init|=
block|{
block|{
literal|"bsize"
block|,
operator|&
name|ffs_opts
operator|->
name|bsize
block|,
literal|1
block|,
name|INT_MAX
block|,
literal|"block size"
block|}
block|,
block|{
literal|"fsize"
block|,
operator|&
name|ffs_opts
operator|->
name|fsize
block|,
literal|1
block|,
name|INT_MAX
block|,
literal|"fragment size"
block|}
block|,
block|{
literal|"density"
block|,
operator|&
name|ffs_opts
operator|->
name|density
block|,
literal|1
block|,
name|INT_MAX
block|,
literal|"bytes per inode"
block|}
block|,
block|{
literal|"minfree"
block|,
operator|&
name|ffs_opts
operator|->
name|minfree
block|,
literal|0
block|,
literal|99
block|,
literal|"minfree"
block|}
block|,
block|{
literal|"maxbpg"
block|,
operator|&
name|ffs_opts
operator|->
name|maxbpg
block|,
literal|1
block|,
name|INT_MAX
block|,
literal|"max blocks per file in a cg"
block|}
block|,
block|{
literal|"avgfilesize"
block|,
operator|&
name|ffs_opts
operator|->
name|avgfilesize
block|,
literal|1
block|,
name|INT_MAX
block|,
literal|"expected average file size"
block|}
block|,
block|{
literal|"avgfpdir"
block|,
operator|&
name|ffs_opts
operator|->
name|avgfpdir
block|,
literal|1
block|,
name|INT_MAX
block|,
literal|"expected # of files per directory"
block|}
block|,
block|{
literal|"extent"
block|,
operator|&
name|ffs_opts
operator|->
name|maxbsize
block|,
literal|1
block|,
name|INT_MAX
block|,
literal|"maximum # extent size"
block|}
block|,
block|{
literal|"maxbpcg"
block|,
operator|&
name|ffs_opts
operator|->
name|maxblkspercg
block|,
literal|1
block|,
name|INT_MAX
block|,
literal|"max # of blocks per group"
block|}
block|,
block|{
literal|"version"
block|,
operator|&
name|ffs_opts
operator|->
name|version
block|,
literal|1
block|,
literal|2
block|,
literal|"UFS version"
block|}
block|,
block|{
operator|.
name|name
operator|=
name|NULL
block|}
block|}
decl_stmt|;
name|char
modifier|*
name|var
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|assert
argument_list|(
name|option
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fsopts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffs_opts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_PARSE_OPTS
condition|)
name|printf
argument_list|(
literal|"ffs_parse_opts: got `%s'\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|var
operator|=
name|strdup
argument_list|(
name|option
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Allocating memory for copy of option string"
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|strchr
argument_list|(
name|var
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"Option `%s' doesn't contain a value"
argument_list|,
name|var
argument_list|)
expr_stmt|;
goto|goto
name|leave_ffs_parse_opts
goto|;
block|}
operator|*
name|val
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"optimization"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"time"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ffs_opts
operator|->
name|optimization
operator|=
name|FS_OPTTIME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"space"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ffs_opts
operator|->
name|optimization
operator|=
name|FS_OPTSPACE
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Invalid optimization `%s'"
argument_list|,
name|val
argument_list|)
expr_stmt|;
goto|goto
name|leave_ffs_parse_opts
goto|;
block|}
name|rv
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|var
argument_list|,
literal|"label"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strlcpy
argument_list|(
name|ffs_opts
operator|->
name|label
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|ffs_opts
operator|->
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|rv
operator|=
name|set_option
argument_list|(
name|ffs_options
argument_list|,
name|var
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|leave_ffs_parse_opts
label|:
if|if
condition|(
name|var
condition|)
name|free
argument_list|(
name|var
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ffs_makefs
parameter_list|(
specifier|const
name|char
modifier|*
name|image
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
name|fsnode
modifier|*
name|root
parameter_list|,
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|struct
name|fs
modifier|*
name|superblock
decl_stmt|;
name|struct
name|timeval
name|start
decl_stmt|;
name|assert
argument_list|(
name|image
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dir
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|root
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fsopts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_MAKEFS
condition|)
name|printf
argument_list|(
literal|"ffs_makefs: image %s directory %s root %p\n"
argument_list|,
name|image
argument_list|,
name|dir
argument_list|,
name|root
argument_list|)
expr_stmt|;
comment|/* validate tree and options */
name|TIMER_START
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|ffs_validate
argument_list|(
name|dir
argument_list|,
name|root
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
name|TIMER_RESULTS
argument_list|(
name|start
argument_list|,
literal|"ffs_validate"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Calculated size of `%s': %lld bytes, %lld inodes\n"
argument_list|,
name|image
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|size
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|inodes
argument_list|)
expr_stmt|;
comment|/* create image */
name|TIMER_START
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffs_create_image
argument_list|(
name|image
argument_list|,
name|fsopts
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Image file `%s' not created."
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|TIMER_RESULTS
argument_list|(
name|start
argument_list|,
literal|"ffs_create_image"
argument_list|)
expr_stmt|;
name|fsopts
operator|->
name|curinode
operator|=
name|ROOTINO
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_MAKEFS
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* populate image */
name|printf
argument_list|(
literal|"Populating `%s'\n"
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|TIMER_START
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffs_populate_dir
argument_list|(
name|dir
argument_list|,
name|root
argument_list|,
name|fsopts
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Image file `%s' not populated."
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|TIMER_RESULTS
argument_list|(
name|start
argument_list|,
literal|"ffs_populate_dir"
argument_list|)
expr_stmt|;
comment|/* ensure no outstanding buffers remain */
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_MAKEFS
condition|)
name|bcleanup
argument_list|()
expr_stmt|;
comment|/* update various superblock parameters */
name|superblock
operator|=
name|fsopts
operator|->
name|superblock
expr_stmt|;
name|superblock
operator|->
name|fs_fmod
operator|=
literal|0
expr_stmt|;
name|superblock
operator|->
name|fs_old_cstotal
operator|.
name|cs_ndir
operator|=
name|superblock
operator|->
name|fs_cstotal
operator|.
name|cs_ndir
expr_stmt|;
name|superblock
operator|->
name|fs_old_cstotal
operator|.
name|cs_nbfree
operator|=
name|superblock
operator|->
name|fs_cstotal
operator|.
name|cs_nbfree
expr_stmt|;
name|superblock
operator|->
name|fs_old_cstotal
operator|.
name|cs_nifree
operator|=
name|superblock
operator|->
name|fs_cstotal
operator|.
name|cs_nifree
expr_stmt|;
name|superblock
operator|->
name|fs_old_cstotal
operator|.
name|cs_nffree
operator|=
name|superblock
operator|->
name|fs_cstotal
operator|.
name|cs_nffree
expr_stmt|;
comment|/* write out superblock; image is now complete */
name|ffs_write_superblock
argument_list|(
name|fsopts
operator|->
name|superblock
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|fsopts
operator|->
name|fd
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Closing `%s'"
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|fsopts
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"Image `%s' complete\n"
argument_list|,
name|image
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of public functions */
end_comment

begin_function
specifier|static
name|void
name|ffs_validate
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
name|fsnode
modifier|*
name|root
parameter_list|,
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|int32_t
name|ncg
init|=
literal|1
decl_stmt|;
if|#
directive|if
name|notyet
name|int32_t
name|spc
decl_stmt|,
name|nspf
decl_stmt|,
name|ncyl
decl_stmt|,
name|fssize
decl_stmt|;
endif|#
directive|endif
name|ffs_opt_t
modifier|*
name|ffs_opts
init|=
name|fsopts
operator|->
name|fs_specific
decl_stmt|;
name|assert
argument_list|(
name|dir
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|root
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fsopts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffs_opts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_VALIDATE
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_validate: before defaults set:\n"
argument_list|)
expr_stmt|;
name|ffs_dump_fsinfo
argument_list|(
name|fsopts
argument_list|)
expr_stmt|;
block|}
comment|/* set FFS defaults */
if|if
condition|(
name|fsopts
operator|->
name|sectorsize
operator|==
operator|-
literal|1
condition|)
name|fsopts
operator|->
name|sectorsize
operator|=
name|DFL_SECSIZE
expr_stmt|;
if|if
condition|(
name|ffs_opts
operator|->
name|fsize
operator|==
operator|-
literal|1
condition|)
name|ffs_opts
operator|->
name|fsize
operator|=
name|MAX
argument_list|(
name|DFL_FRAGSIZE
argument_list|,
name|fsopts
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffs_opts
operator|->
name|bsize
operator|==
operator|-
literal|1
condition|)
name|ffs_opts
operator|->
name|bsize
operator|=
name|MIN
argument_list|(
name|DFL_BLKSIZE
argument_list|,
literal|8
operator|*
name|ffs_opts
operator|->
name|fsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffs_opts
operator|->
name|cpg
operator|==
operator|-
literal|1
condition|)
name|ffs_opts
operator|->
name|cpg
operator|=
name|DFL_CYLSPERGROUP
expr_stmt|;
else|else
name|ffs_opts
operator|->
name|cpgflg
operator|=
literal|1
expr_stmt|;
comment|/* fsopts->density is set below */
if|if
condition|(
name|ffs_opts
operator|->
name|nsectors
operator|==
operator|-
literal|1
condition|)
name|ffs_opts
operator|->
name|nsectors
operator|=
name|DFL_NSECTORS
expr_stmt|;
if|if
condition|(
name|ffs_opts
operator|->
name|minfree
operator|==
operator|-
literal|1
condition|)
name|ffs_opts
operator|->
name|minfree
operator|=
name|MINFREE
expr_stmt|;
if|if
condition|(
name|ffs_opts
operator|->
name|optimization
operator|==
operator|-
literal|1
condition|)
name|ffs_opts
operator|->
name|optimization
operator|=
name|DEFAULTOPT
expr_stmt|;
if|if
condition|(
name|ffs_opts
operator|->
name|maxcontig
operator|==
operator|-
literal|1
condition|)
name|ffs_opts
operator|->
name|maxcontig
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|MIN
argument_list|(
name|MAXPHYS
argument_list|,
name|FFS_MAXBSIZE
argument_list|)
operator|/
name|ffs_opts
operator|->
name|bsize
argument_list|)
expr_stmt|;
comment|/* XXX ondisk32 */
if|if
condition|(
name|ffs_opts
operator|->
name|maxbpg
operator|==
operator|-
literal|1
condition|)
name|ffs_opts
operator|->
name|maxbpg
operator|=
name|ffs_opts
operator|->
name|bsize
operator|/
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffs_opts
operator|->
name|avgfilesize
operator|==
operator|-
literal|1
condition|)
name|ffs_opts
operator|->
name|avgfilesize
operator|=
name|AVFILESIZ
expr_stmt|;
if|if
condition|(
name|ffs_opts
operator|->
name|avgfpdir
operator|==
operator|-
literal|1
condition|)
name|ffs_opts
operator|->
name|avgfpdir
operator|=
name|AFPDIR
expr_stmt|;
if|if
condition|(
name|fsopts
operator|->
name|maxsize
operator|>
literal|0
operator|&&
name|roundup
argument_list|(
name|fsopts
operator|->
name|minsize
argument_list|,
name|ffs_opts
operator|->
name|bsize
argument_list|)
operator|>
name|fsopts
operator|->
name|maxsize
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"`%s' minsize of %lld rounded up to ffs bsize of %d "
literal|"exceeds maxsize %lld.  Lower bsize, or round the minimum "
literal|"and maximum sizes to bsize."
argument_list|,
name|dir
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|minsize
argument_list|,
name|ffs_opts
operator|->
name|bsize
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|maxsize
argument_list|)
expr_stmt|;
comment|/* calculate size of tree */
name|ffs_size_dir
argument_list|(
name|root
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
name|fsopts
operator|->
name|inodes
operator|+=
name|ROOTINO
expr_stmt|;
comment|/* include first two inodes */
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_VALIDATE
condition|)
name|printf
argument_list|(
literal|"ffs_validate: size of tree: %lld bytes, %lld inodes\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|size
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|inodes
argument_list|)
expr_stmt|;
comment|/* add requested slop */
name|fsopts
operator|->
name|size
operator|+=
name|fsopts
operator|->
name|freeblocks
expr_stmt|;
name|fsopts
operator|->
name|inodes
operator|+=
name|fsopts
operator|->
name|freefiles
expr_stmt|;
if|if
condition|(
name|fsopts
operator|->
name|freefilepc
operator|>
literal|0
condition|)
name|fsopts
operator|->
name|inodes
operator|=
name|fsopts
operator|->
name|inodes
operator|*
operator|(
literal|100
operator|+
name|fsopts
operator|->
name|freefilepc
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|fsopts
operator|->
name|freeblockpc
operator|>
literal|0
condition|)
name|fsopts
operator|->
name|size
operator|=
name|fsopts
operator|->
name|size
operator|*
operator|(
literal|100
operator|+
name|fsopts
operator|->
name|freeblockpc
operator|)
operator|/
literal|100
expr_stmt|;
comment|/* add space needed for superblocks */
comment|/* 	 * The old SBOFF (SBLOCK_UFS1) is used here because makefs is 	 * typically used for small filesystems where space matters. 	 * XXX make this an option. 	 */
name|fsopts
operator|->
name|size
operator|+=
operator|(
name|SBLOCK_UFS1
operator|+
name|SBLOCKSIZE
operator|)
operator|*
name|ncg
expr_stmt|;
comment|/* add space needed to store inodes, x3 for blockmaps, etc */
if|if
condition|(
name|ffs_opts
operator|->
name|version
operator|==
literal|1
condition|)
name|fsopts
operator|->
name|size
operator|+=
name|ncg
operator|*
name|DINODE1_SIZE
operator|*
name|roundup
argument_list|(
name|fsopts
operator|->
name|inodes
operator|/
name|ncg
argument_list|,
name|ffs_opts
operator|->
name|bsize
operator|/
name|DINODE1_SIZE
argument_list|)
expr_stmt|;
else|else
name|fsopts
operator|->
name|size
operator|+=
name|ncg
operator|*
name|DINODE2_SIZE
operator|*
name|roundup
argument_list|(
name|fsopts
operator|->
name|inodes
operator|/
name|ncg
argument_list|,
name|ffs_opts
operator|->
name|bsize
operator|/
name|DINODE2_SIZE
argument_list|)
expr_stmt|;
comment|/* add minfree */
if|if
condition|(
name|ffs_opts
operator|->
name|minfree
operator|>
literal|0
condition|)
name|fsopts
operator|->
name|size
operator|=
name|fsopts
operator|->
name|size
operator|*
operator|(
literal|100
operator|+
name|ffs_opts
operator|->
name|minfree
operator|)
operator|/
literal|100
expr_stmt|;
comment|/* 	 * XXX	any other fs slop to add, such as csum's, bitmaps, etc ?? 	 */
if|if
condition|(
name|fsopts
operator|->
name|size
operator|<
name|fsopts
operator|->
name|minsize
condition|)
comment|/* ensure meets minimum size */
name|fsopts
operator|->
name|size
operator|=
name|fsopts
operator|->
name|minsize
expr_stmt|;
comment|/* round up to the next block */
name|fsopts
operator|->
name|size
operator|=
name|roundup
argument_list|(
name|fsopts
operator|->
name|size
argument_list|,
name|ffs_opts
operator|->
name|bsize
argument_list|)
expr_stmt|;
comment|/* round up to requested block size, if any */
if|if
condition|(
name|fsopts
operator|->
name|roundup
operator|>
literal|0
condition|)
name|fsopts
operator|->
name|size
operator|=
name|roundup
argument_list|(
name|fsopts
operator|->
name|size
argument_list|,
name|fsopts
operator|->
name|roundup
argument_list|)
expr_stmt|;
comment|/* calculate density if necessary */
if|if
condition|(
name|ffs_opts
operator|->
name|density
operator|==
operator|-
literal|1
condition|)
name|ffs_opts
operator|->
name|density
operator|=
name|fsopts
operator|->
name|size
operator|/
name|fsopts
operator|->
name|inodes
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_VALIDATE
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_validate: after defaults set:\n"
argument_list|)
expr_stmt|;
name|ffs_dump_fsinfo
argument_list|(
name|fsopts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ffs_validate: dir %s; %lld bytes, %lld inodes\n"
argument_list|,
name|dir
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|size
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|inodes
argument_list|)
expr_stmt|;
block|}
name|sectorsize
operator|=
name|fsopts
operator|->
name|sectorsize
expr_stmt|;
comment|/* XXX - see earlier */
comment|/* now check calculated sizes vs requested sizes */
if|if
condition|(
name|fsopts
operator|->
name|maxsize
operator|>
literal|0
operator|&&
name|fsopts
operator|->
name|size
operator|>
name|fsopts
operator|->
name|maxsize
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"`%s' size of %lld is larger than the maxsize of %lld."
argument_list|,
name|dir
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|size
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|maxsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ffs_dump_fsinfo
parameter_list|(
name|fsinfo_t
modifier|*
name|f
parameter_list|)
block|{
name|ffs_opt_t
modifier|*
name|fs
init|=
name|f
operator|->
name|fs_specific
decl_stmt|;
name|printf
argument_list|(
literal|"fsopts at %p\n"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tsize %lld, inodes %lld, curinode %u\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|f
operator|->
name|size
argument_list|,
operator|(
name|long
name|long
operator|)
name|f
operator|->
name|inodes
argument_list|,
name|f
operator|->
name|curinode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tminsize %lld, maxsize %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|f
operator|->
name|minsize
argument_list|,
operator|(
name|long
name|long
operator|)
name|f
operator|->
name|maxsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tfree files %lld, freefile %% %d\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|f
operator|->
name|freefiles
argument_list|,
name|f
operator|->
name|freefilepc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tfree blocks %lld, freeblock %% %d\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|f
operator|->
name|freeblocks
argument_list|,
name|f
operator|->
name|freeblockpc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tneedswap %d, sectorsize %d\n"
argument_list|,
name|f
operator|->
name|needswap
argument_list|,
name|f
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tbsize %d, fsize %d, cpg %d, density %d\n"
argument_list|,
name|fs
operator|->
name|bsize
argument_list|,
name|fs
operator|->
name|fsize
argument_list|,
name|fs
operator|->
name|cpg
argument_list|,
name|fs
operator|->
name|density
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnsectors %d, rpm %d, minfree %d\n"
argument_list|,
name|fs
operator|->
name|nsectors
argument_list|,
name|fs
operator|->
name|rpm
argument_list|,
name|fs
operator|->
name|minfree
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tmaxcontig %d, maxbpg %d\n"
argument_list|,
name|fs
operator|->
name|maxcontig
argument_list|,
name|fs
operator|->
name|maxbpg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\toptimization %s\n"
argument_list|,
name|fs
operator|->
name|optimization
operator|==
name|FS_OPTSPACE
condition|?
literal|"space"
else|:
literal|"time"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffs_create_image
parameter_list|(
specifier|const
name|char
modifier|*
name|image
parameter_list|,
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
if|#
directive|if
name|HAVE_STRUCT_STATVFS_F_IOSIZE
operator|&&
name|HAVE_FSTATVFS
name|struct
name|statvfs
name|sfs
decl_stmt|;
endif|#
directive|endif
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bufsize
decl_stmt|;
name|off_t
name|bufrem
decl_stmt|;
name|assert
argument_list|(
name|image
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fsopts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* create image */
if|if
condition|(
operator|(
name|fsopts
operator|->
name|fd
operator|=
name|open
argument_list|(
name|image
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0666
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Can't open `%s' for writing"
argument_list|,
name|image
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* zero image */
if|#
directive|if
name|HAVE_STRUCT_STATVFS_F_IOSIZE
operator|&&
name|HAVE_FSTATVFS
if|if
condition|(
name|fstatvfs
argument_list|(
name|fsopts
operator|->
name|fd
argument_list|,
operator|&
name|sfs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
endif|#
directive|endif
name|bufsize
operator|=
literal|8192
expr_stmt|;
if|#
directive|if
name|HAVE_STRUCT_STATVFS_F_IOSIZE
operator|&&
name|HAVE_FSTATVFS
name|warn
argument_list|(
literal|"can't fstatvfs `%s', using default %d byte chunk"
argument_list|,
name|image
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
else|else
name|bufsize
operator|=
name|sfs
operator|.
name|f_iosize
expr_stmt|;
endif|#
directive|endif
name|bufrem
operator|=
name|fsopts
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|fsopts
operator|->
name|sparse
condition|)
block|{
if|if
condition|(
name|ftruncate
argument_list|(
name|fsopts
operator|->
name|fd
argument_list|,
name|bufrem
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"sparse option disabled.\n"
argument_list|)
expr_stmt|;
name|fsopts
operator|->
name|sparse
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fsopts
operator|->
name|sparse
condition|)
block|{
comment|/* File truncated at bufrem. Remaining is 0 */
name|bufrem
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_CREATE_IMAGE
condition|)
name|printf
argument_list|(
literal|"zero-ing image `%s', %lld sectors, "
literal|"using %d byte chunks\n"
argument_list|,
name|image
argument_list|,
operator|(
name|long
name|long
operator|)
name|bufrem
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|bufsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"Can't create buffer for sector"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
while|while
condition|(
name|bufrem
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|write
argument_list|(
name|fsopts
operator|->
name|fd
argument_list|,
name|buf
argument_list|,
name|MIN
argument_list|(
name|bufsize
argument_list|,
name|bufrem
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"zeroing image, %lld bytes to go"
argument_list|,
operator|(
name|long
name|long
operator|)
name|bufrem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bufrem
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* make the file system */
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_CREATE_IMAGE
condition|)
name|printf
argument_list|(
literal|"calling mkfs(\"%s\", ...)\n"
argument_list|,
name|image
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ffs_mkfs
argument_list|(
name|image
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
name|fsopts
operator|->
name|superblock
operator|=
operator|(
name|void
operator|*
operator|)
name|fs
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_CREATE_IMAGE
condition|)
block|{
name|time_t
name|t
decl_stmt|;
name|t
operator|=
call|(
name|time_t
call|)
argument_list|(
operator|(
expr|struct
name|fs
operator|*
operator|)
name|fsopts
operator|->
name|superblock
argument_list|)
operator|->
name|fs_time
expr_stmt|;
name|printf
argument_list|(
literal|"mkfs returned %p; fs_time %s"
argument_list|,
name|fsopts
operator|->
name|superblock
argument_list|,
name|ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fs totals: nbfree %lld, nffree %lld, nifree %lld, ndir %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nbfree
argument_list|,
operator|(
name|long
name|long
operator|)
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nffree
argument_list|,
operator|(
name|long
name|long
operator|)
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nifree
argument_list|,
operator|(
name|long
name|long
operator|)
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_ndir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nifree
operator|+
name|ROOTINO
operator|<
name|fsopts
operator|->
name|inodes
condition|)
block|{
name|warnx
argument_list|(
literal|"Image file `%s' has %lld free inodes; %lld are required."
argument_list|,
name|image
argument_list|,
call|(
name|long
name|long
call|)
argument_list|(
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nifree
operator|+
name|ROOTINO
argument_list|)
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|inodes
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|fsopts
operator|->
name|fd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffs_size_dir
parameter_list|(
name|fsnode
modifier|*
name|root
parameter_list|,
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|struct
name|direct
name|tmpdir
decl_stmt|;
name|fsnode
modifier|*
name|node
decl_stmt|;
name|int
name|curdirsize
decl_stmt|,
name|this
decl_stmt|;
name|ffs_opt_t
modifier|*
name|ffs_opts
init|=
name|fsopts
operator|->
name|fs_specific
decl_stmt|;
comment|/* node may be NULL (empty directory) */
name|assert
argument_list|(
name|fsopts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffs_opts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_SIZE_DIR
condition|)
name|printf
argument_list|(
literal|"ffs_size_dir: entry: bytes %lld inodes %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|size
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|inodes
argument_list|)
expr_stmt|;
define|#
directive|define
name|ADDDIRENT
parameter_list|(
name|e
parameter_list|)
value|do {						\ 	tmpdir.d_namlen = strlen((e));					\ 	this = DIRSIZ_SWAP(0,&tmpdir, 0);					\ 	if (debug& DEBUG_FS_SIZE_DIR_ADD_DIRENT)			\ 		printf("ADDDIRENT: was: %s (%d) this %d cur %d\n",	\ 		    e, tmpdir.d_namlen, this, curdirsize);		\ 	if (this + curdirsize> roundup(curdirsize, DIRBLKSIZ))		\ 		curdirsize = roundup(curdirsize, DIRBLKSIZ);		\ 	curdirsize += this;						\ 	if (debug& DEBUG_FS_SIZE_DIR_ADD_DIRENT)			\ 		printf("ADDDIRENT: now: %s (%d) this %d cur %d\n",	\ 		    e, tmpdir.d_namlen, this, curdirsize);		\ } while (0);
comment|/* 	 * XXX	this needs to take into account extra space consumed 	 *	by indirect blocks, etc. 	 */
define|#
directive|define
name|ADDSIZE
parameter_list|(
name|x
parameter_list|)
value|do {							\ 	fsopts->size += roundup((x), ffs_opts->fsize);			\ } while (0);
name|curdirsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|node
operator|=
name|root
init|;
name|node
operator|!=
name|NULL
condition|;
name|node
operator|=
name|node
operator|->
name|next
control|)
block|{
name|ADDDIRENT
argument_list|(
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|root
condition|)
block|{
comment|/* we're at "." */
name|assert
argument_list|(
name|strcmp
argument_list|(
name|node
operator|->
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ADDDIRENT
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|node
operator|->
name|inode
operator|->
name|flags
operator|&
name|FI_SIZED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* don't count duplicate names */
name|node
operator|->
name|inode
operator|->
name|flags
operator||=
name|FI_SIZED
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_SIZE_DIR_NODE
condition|)
name|printf
argument_list|(
literal|"ffs_size_dir: `%s' size %lld\n"
argument_list|,
name|node
operator|->
name|name
argument_list|,
operator|(
name|long
name|long
operator|)
name|node
operator|->
name|inode
operator|->
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|fsopts
operator|->
name|inodes
operator|++
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|S_IFREG
condition|)
name|ADDSIZE
argument_list|(
name|node
operator|->
name|inode
operator|->
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|S_IFLNK
condition|)
block|{
name|int
name|slen
decl_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|node
operator|->
name|symlink
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|slen
operator|>=
operator|(
name|ffs_opts
operator|->
name|version
operator|==
literal|1
condition|?
name|MAXSYMLINKLEN_UFS1
else|:
name|MAXSYMLINKLEN_UFS2
operator|)
condition|)
name|ADDSIZE
argument_list|(
name|slen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|node
operator|->
name|type
operator|==
name|S_IFDIR
condition|)
name|ffs_size_dir
argument_list|(
name|node
operator|->
name|child
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
block|}
name|ADDSIZE
argument_list|(
name|curdirsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_SIZE_DIR
condition|)
name|printf
argument_list|(
literal|"ffs_size_dir: exit: size %lld inodes %lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|size
argument_list|,
operator|(
name|long
name|long
operator|)
name|fsopts
operator|->
name|inodes
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ffs_build_dinode1
parameter_list|(
name|struct
name|ufs1_dinode
modifier|*
name|dinp
parameter_list|,
name|dirbuf_t
modifier|*
name|dbufp
parameter_list|,
name|fsnode
modifier|*
name|cur
parameter_list|,
name|fsnode
modifier|*
name|root
parameter_list|,
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|int
name|slen
decl_stmt|;
name|void
modifier|*
name|membuf
decl_stmt|;
name|memset
argument_list|(
name|dinp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dinp
argument_list|)
argument_list|)
expr_stmt|;
name|dinp
operator|->
name|di_mode
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_mode
expr_stmt|;
name|dinp
operator|->
name|di_nlink
operator|=
name|cur
operator|->
name|inode
operator|->
name|nlink
expr_stmt|;
name|dinp
operator|->
name|di_size
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_size
expr_stmt|;
name|dinp
operator|->
name|di_atime
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_atime
expr_stmt|;
name|dinp
operator|->
name|di_mtime
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_mtime
expr_stmt|;
name|dinp
operator|->
name|di_ctime
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_ctime
expr_stmt|;
if|#
directive|if
name|HAVE_STRUCT_STAT_ST_MTIMENSEC
name|dinp
operator|->
name|di_atimensec
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_atimensec
expr_stmt|;
name|dinp
operator|->
name|di_mtimensec
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_mtimensec
expr_stmt|;
name|dinp
operator|->
name|di_ctimensec
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_ctimensec
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_STRUCT_STAT_ST_FLAGS
name|dinp
operator|->
name|di_flags
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_flags
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_STRUCT_STAT_ST_GEN
name|dinp
operator|->
name|di_gen
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_gen
expr_stmt|;
endif|#
directive|endif
name|dinp
operator|->
name|di_uid
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_uid
expr_stmt|;
name|dinp
operator|->
name|di_gid
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_gid
expr_stmt|;
comment|/* not set: di_db, di_ib, di_blocks, di_spare */
name|membuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|root
condition|)
block|{
comment|/* "."; write dirbuf */
name|membuf
operator|=
name|dbufp
operator|->
name|buf
expr_stmt|;
name|dinp
operator|->
name|di_size
operator|=
name|dbufp
operator|->
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|cur
operator|->
name|type
argument_list|)
operator|||
name|S_ISCHR
argument_list|(
name|cur
operator|->
name|type
argument_list|)
condition|)
block|{
name|dinp
operator|->
name|di_size
operator|=
literal|0
expr_stmt|;
comment|/* a device */
name|dinp
operator|->
name|di_rdev
operator|=
name|ufs_rw32
argument_list|(
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_rdev
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|cur
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* symlink */
name|slen
operator|=
name|strlen
argument_list|(
name|cur
operator|->
name|symlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|<
name|MAXSYMLINKLEN_UFS1
condition|)
block|{
comment|/* short link */
name|memcpy
argument_list|(
name|dinp
operator|->
name|di_db
argument_list|,
name|cur
operator|->
name|symlink
argument_list|,
name|slen
argument_list|)
expr_stmt|;
block|}
else|else
name|membuf
operator|=
name|cur
operator|->
name|symlink
expr_stmt|;
name|dinp
operator|->
name|di_size
operator|=
name|slen
expr_stmt|;
block|}
return|return
name|membuf
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ffs_build_dinode2
parameter_list|(
name|struct
name|ufs2_dinode
modifier|*
name|dinp
parameter_list|,
name|dirbuf_t
modifier|*
name|dbufp
parameter_list|,
name|fsnode
modifier|*
name|cur
parameter_list|,
name|fsnode
modifier|*
name|root
parameter_list|,
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|int
name|slen
decl_stmt|;
name|void
modifier|*
name|membuf
decl_stmt|;
name|memset
argument_list|(
name|dinp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dinp
argument_list|)
argument_list|)
expr_stmt|;
name|dinp
operator|->
name|di_mode
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_mode
expr_stmt|;
name|dinp
operator|->
name|di_nlink
operator|=
name|cur
operator|->
name|inode
operator|->
name|nlink
expr_stmt|;
name|dinp
operator|->
name|di_size
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_size
expr_stmt|;
name|dinp
operator|->
name|di_atime
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_atime
expr_stmt|;
name|dinp
operator|->
name|di_mtime
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_mtime
expr_stmt|;
name|dinp
operator|->
name|di_ctime
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_ctime
expr_stmt|;
if|#
directive|if
name|HAVE_STRUCT_STAT_ST_MTIMENSEC
name|dinp
operator|->
name|di_atimensec
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_atimensec
expr_stmt|;
name|dinp
operator|->
name|di_mtimensec
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_mtimensec
expr_stmt|;
name|dinp
operator|->
name|di_ctimensec
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_ctimensec
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_STRUCT_STAT_ST_FLAGS
name|dinp
operator|->
name|di_flags
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_flags
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_STRUCT_STAT_ST_GEN
name|dinp
operator|->
name|di_gen
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_gen
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|HAVE_STRUCT_STAT_BIRTHTIME
name|dinp
operator|->
name|di_birthtime
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_birthtime
expr_stmt|;
name|dinp
operator|->
name|di_birthnsec
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_birthtimensec
expr_stmt|;
endif|#
directive|endif
name|dinp
operator|->
name|di_uid
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_uid
expr_stmt|;
name|dinp
operator|->
name|di_gid
operator|=
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_gid
expr_stmt|;
comment|/* not set: di_db, di_ib, di_blocks, di_spare */
name|membuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|root
condition|)
block|{
comment|/* "."; write dirbuf */
name|membuf
operator|=
name|dbufp
operator|->
name|buf
expr_stmt|;
name|dinp
operator|->
name|di_size
operator|=
name|dbufp
operator|->
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISBLK
argument_list|(
name|cur
operator|->
name|type
argument_list|)
operator|||
name|S_ISCHR
argument_list|(
name|cur
operator|->
name|type
argument_list|)
condition|)
block|{
name|dinp
operator|->
name|di_size
operator|=
literal|0
expr_stmt|;
comment|/* a device */
name|dinp
operator|->
name|di_rdev
operator|=
name|ufs_rw64
argument_list|(
name|cur
operator|->
name|inode
operator|->
name|st
operator|.
name|st_rdev
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISLNK
argument_list|(
name|cur
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* symlink */
name|slen
operator|=
name|strlen
argument_list|(
name|cur
operator|->
name|symlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|<
name|MAXSYMLINKLEN_UFS2
condition|)
block|{
comment|/* short link */
name|memcpy
argument_list|(
name|dinp
operator|->
name|di_db
argument_list|,
name|cur
operator|->
name|symlink
argument_list|,
name|slen
argument_list|)
expr_stmt|;
block|}
else|else
name|membuf
operator|=
name|cur
operator|->
name|symlink
expr_stmt|;
name|dinp
operator|->
name|di_size
operator|=
name|slen
expr_stmt|;
block|}
return|return
name|membuf
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ffs_populate_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
name|fsnode
modifier|*
name|root
parameter_list|,
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|fsnode
modifier|*
name|cur
decl_stmt|;
name|dirbuf_t
name|dirbuf
decl_stmt|;
name|union
name|dinode
name|din
decl_stmt|;
name|void
modifier|*
name|membuf
decl_stmt|;
name|char
name|path
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|ffs_opt_t
modifier|*
name|ffs_opts
init|=
name|fsopts
operator|->
name|fs_specific
decl_stmt|;
name|assert
argument_list|(
name|dir
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|root
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fsopts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffs_opts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|dirbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_POPULATE
condition|)
name|printf
argument_list|(
literal|"ffs_populate_dir: PASS 1  dir %s node %p\n"
argument_list|,
name|dir
argument_list|,
name|root
argument_list|)
expr_stmt|;
comment|/* 		 * pass 1: allocate inode numbers, build directory `file' 		 */
for|for
control|(
name|cur
operator|=
name|root
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|cur
operator|->
name|inode
operator|->
name|flags
operator|&
name|FI_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|cur
operator|->
name|inode
operator|->
name|flags
operator||=
name|FI_ALLOCATED
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|root
operator|&&
name|cur
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|cur
operator|->
name|inode
operator|->
name|ino
operator|=
name|cur
operator|->
name|parent
operator|->
name|inode
operator|->
name|ino
expr_stmt|;
else|else
block|{
name|cur
operator|->
name|inode
operator|->
name|ino
operator|=
name|fsopts
operator|->
name|curinode
expr_stmt|;
name|fsopts
operator|->
name|curinode
operator|++
expr_stmt|;
block|}
block|}
name|ffs_make_dirbuf
argument_list|(
operator|&
name|dirbuf
argument_list|,
name|cur
operator|->
name|name
argument_list|,
name|cur
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|root
condition|)
block|{
comment|/* we're at "."; add ".." */
name|ffs_make_dirbuf
argument_list|(
operator|&
name|dirbuf
argument_list|,
literal|".."
argument_list|,
name|cur
operator|->
name|parent
operator|==
name|NULL
condition|?
name|cur
else|:
name|cur
operator|->
name|parent
operator|->
name|first
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
expr_stmt|;
name|root
operator|->
name|inode
operator|->
name|nlink
operator|++
expr_stmt|;
comment|/* count my parent's link */
block|}
elseif|else
if|if
condition|(
name|cur
operator|->
name|child
operator|!=
name|NULL
condition|)
name|root
operator|->
name|inode
operator|->
name|nlink
operator|++
expr_stmt|;
comment|/* count my child's link */
comment|/* 		 * XXX	possibly write file and long symlinks here, 		 *	ensuring that blocks get written before inodes? 		 *	otoh, this isn't a real filesystem, so who 		 *	cares about ordering? :-) 		 */
block|}
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_POPULATE_DIRBUF
condition|)
name|ffs_dump_dirbuf
argument_list|(
operator|&
name|dirbuf
argument_list|,
name|dir
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
expr_stmt|;
comment|/* 		 * pass 2: write out dirbuf, then non-directories at this level 		 */
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_POPULATE
condition|)
name|printf
argument_list|(
literal|"ffs_populate_dir: PASS 2  dir %s\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|root
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|inode
operator|->
name|flags
operator|&
name|FI_WRITTEN
condition|)
continue|continue;
comment|/* skip hard-linked entries */
name|cur
operator|->
name|inode
operator|->
name|flags
operator||=
name|FI_WRITTEN
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|contents
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s/%s"
argument_list|,
name|cur
operator|->
name|root
argument_list|,
name|cur
operator|->
name|path
argument_list|,
name|cur
operator|->
name|name
argument_list|)
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|path
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Pathname too long."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|->
name|child
operator|!=
name|NULL
condition|)
continue|continue;
comment|/* child creates own inode */
comment|/* build on-disk inode */
if|if
condition|(
name|ffs_opts
operator|->
name|version
operator|==
literal|1
condition|)
name|membuf
operator|=
name|ffs_build_dinode1
argument_list|(
operator|&
name|din
operator|.
name|ffs1_din
argument_list|,
operator|&
name|dirbuf
argument_list|,
name|cur
argument_list|,
name|root
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
else|else
name|membuf
operator|=
name|ffs_build_dinode2
argument_list|(
operator|&
name|din
operator|.
name|ffs2_din
argument_list|,
operator|&
name|dirbuf
argument_list|,
name|cur
argument_list|,
name|root
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_POPULATE_NODE
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_populate_dir: writing ino %d, %s"
argument_list|,
name|cur
operator|->
name|inode
operator|->
name|ino
argument_list|,
name|inode_type
argument_list|(
name|cur
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|inode
operator|->
name|nlink
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|", nlink %d"
argument_list|,
name|cur
operator|->
name|inode
operator|->
name|nlink
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|membuf
operator|!=
name|NULL
condition|)
block|{
name|ffs_write_file
argument_list|(
operator|&
name|din
argument_list|,
name|cur
operator|->
name|inode
operator|->
name|ino
argument_list|,
name|membuf
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISREG
argument_list|(
name|cur
operator|->
name|type
argument_list|)
condition|)
block|{
name|ffs_write_file
argument_list|(
operator|&
name|din
argument_list|,
name|cur
operator|->
name|inode
operator|->
name|ino
argument_list|,
operator|(
name|cur
operator|->
name|contents
operator|)
condition|?
name|cur
operator|->
name|contents
else|:
name|path
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
operator|!
name|S_ISDIR
argument_list|(
name|cur
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ffs_write_inode
argument_list|(
operator|&
name|din
argument_list|,
name|cur
operator|->
name|inode
operator|->
name|ino
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * pass 3: write out sub-directories 		 */
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_POPULATE
condition|)
name|printf
argument_list|(
literal|"ffs_populate_dir: PASS 3  dir %s\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|root
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|child
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|dir
argument_list|,
name|cur
operator|->
name|name
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|path
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Pathname too long."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ffs_populate_dir
argument_list|(
name|path
argument_list|,
name|cur
operator|->
name|child
argument_list|,
name|fsopts
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_POPULATE
condition|)
name|printf
argument_list|(
literal|"ffs_populate_dir: DONE dir %s\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* cleanup */
if|if
condition|(
name|dirbuf
operator|.
name|buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dirbuf
operator|.
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffs_write_file
parameter_list|(
name|union
name|dinode
modifier|*
name|din
parameter_list|,
name|uint32_t
name|ino
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|int
name|isfile
decl_stmt|,
name|ffd
decl_stmt|;
name|char
modifier|*
name|fbuf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|off_t
name|bufleft
decl_stmt|,
name|chunk
decl_stmt|,
name|offset
decl_stmt|;
name|ssize_t
name|nread
decl_stmt|;
name|struct
name|inode
name|in
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ffs_opt_t
modifier|*
name|ffs_opts
init|=
name|fsopts
operator|->
name|fs_specific
decl_stmt|;
name|assert
argument_list|(
name|din
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fsopts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffs_opts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|isfile
operator|=
name|S_ISREG
argument_list|(
name|DIP
argument_list|(
name|din
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
name|fbuf
operator|=
name|NULL
expr_stmt|;
name|ffd
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
name|in
operator|.
name|i_fs
operator|=
operator|(
expr|struct
name|fs
operator|*
operator|)
name|fsopts
operator|->
name|superblock
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_WRITE_FILE
condition|)
block|{
name|printf
argument_list|(
literal|"ffs_write_file: ino %u, din %p, isfile %d, %s, size %lld"
argument_list|,
name|ino
argument_list|,
name|din
argument_list|,
name|isfile
argument_list|,
name|inode_type
argument_list|(
name|DIP
argument_list|(
name|din
argument_list|,
name|mode
argument_list|)
operator|&
name|S_IFMT
argument_list|)
argument_list|,
operator|(
name|long
name|long
operator|)
name|DIP
argument_list|(
name|din
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isfile
condition|)
name|printf
argument_list|(
literal|", file '%s'\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", buffer %p\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|in
operator|.
name|i_number
operator|=
name|ino
expr_stmt|;
name|in
operator|.
name|i_size
operator|=
name|DIP
argument_list|(
name|din
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffs_opts
operator|->
name|version
operator|==
literal|1
condition|)
name|memcpy
argument_list|(
operator|&
name|in
operator|.
name|i_din
operator|.
name|ffs1_din
argument_list|,
operator|&
name|din
operator|->
name|ffs1_din
argument_list|,
sizeof|sizeof
argument_list|(
name|in
operator|.
name|i_din
operator|.
name|ffs1_din
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
operator|&
name|in
operator|.
name|i_din
operator|.
name|ffs2_din
argument_list|,
operator|&
name|din
operator|->
name|ffs2_din
argument_list|,
sizeof|sizeof
argument_list|(
name|in
operator|.
name|i_din
operator|.
name|ffs2_din
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|.
name|i_fd
operator|=
name|fsopts
operator|->
name|fd
expr_stmt|;
if|if
condition|(
name|DIP
argument_list|(
name|din
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|write_inode_and_leave
goto|;
comment|/* mmm, cheating */
if|if
condition|(
name|isfile
condition|)
block|{
if|if
condition|(
operator|(
name|fbuf
operator|=
name|malloc
argument_list|(
name|ffs_opts
operator|->
name|bsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Allocating memory for write buffer"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ffd
operator|=
name|open
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|O_RDONLY
argument_list|,
literal|0444
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Can't open `%s' for reading"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|leave_ffs_write_file
goto|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|buf
expr_stmt|;
block|}
name|chunk
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bufleft
operator|=
name|DIP
argument_list|(
name|din
argument_list|,
name|size
argument_list|)
init|;
name|bufleft
operator|>
literal|0
condition|;
name|bufleft
operator|-=
name|chunk
control|)
block|{
name|chunk
operator|=
name|MIN
argument_list|(
name|bufleft
argument_list|,
name|ffs_opts
operator|->
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
operator|(
name|nread
operator|=
name|read
argument_list|(
name|ffd
argument_list|,
name|fbuf
argument_list|,
name|chunk
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Reading `%s', %lld bytes to go"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|long
name|long
operator|)
name|bufleft
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nread
operator|!=
name|chunk
condition|)
name|errx
argument_list|(
name|EXIT_FAILURE
argument_list|,
literal|"Reading `%s', %lld bytes to go, "
literal|"read %zd bytes, expected %ju bytes, does "
literal|"metalog size= attribute mismatch source size?"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|(
name|long
name|long
operator|)
name|bufleft
argument_list|,
name|nread
argument_list|,
operator|(
name|uintmax_t
operator|)
name|chunk
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|fbuf
expr_stmt|;
name|offset
operator|=
name|DIP
argument_list|(
name|din
argument_list|,
name|size
argument_list|)
operator|-
name|bufleft
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_WRITE_FILE_BLOCK
condition|)
name|printf
argument_list|(
literal|"ffs_write_file: write %p offset %lld size %lld left %lld\n"
argument_list|,
name|p
argument_list|,
operator|(
name|long
name|long
operator|)
name|offset
argument_list|,
operator|(
name|long
name|long
operator|)
name|chunk
argument_list|,
operator|(
name|long
name|long
operator|)
name|bufleft
argument_list|)
expr_stmt|;
comment|/* 	 * XXX	if holey support is desired, do the check here 	 * 	 * XXX	might need to write out last bit in fragroundup 	 *	sized chunk. however, ffs_balloc() handles this for us 	 */
name|errno
operator|=
name|ffs_balloc
argument_list|(
operator|&
name|in
argument_list|,
name|offset
argument_list|,
name|chunk
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|bad_ffs_write_file
label|:
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Writing inode %d (%s), bytes %lld + %lld"
argument_list|,
name|ino
argument_list|,
name|isfile
condition|?
operator|(
name|char
operator|*
operator|)
name|buf
else|:
name|inode_type
argument_list|(
name|DIP
argument_list|(
name|din
argument_list|,
name|mode
argument_list|)
operator|&
name|S_IFMT
argument_list|)
argument_list|,
operator|(
name|long
name|long
operator|)
name|offset
argument_list|,
operator|(
name|long
name|long
operator|)
name|chunk
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|p
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|errno
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
goto|goto
name|bad_ffs_write_file
goto|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isfile
condition|)
name|p
operator|+=
name|chunk
expr_stmt|;
block|}
name|write_inode_and_leave
label|:
name|ffs_write_inode
argument_list|(
operator|&
name|in
operator|.
name|i_din
argument_list|,
name|in
operator|.
name|i_number
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
name|leave_ffs_write_file
label|:
if|if
condition|(
name|fbuf
condition|)
name|free
argument_list|(
name|fbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|ffd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ffs_dump_dirbuf
parameter_list|(
name|dirbuf_t
modifier|*
name|dbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
name|int
name|needswap
parameter_list|)
block|{
name|doff_t
name|i
decl_stmt|;
name|struct
name|direct
modifier|*
name|de
decl_stmt|;
name|uint16_t
name|reclen
decl_stmt|;
name|assert
argument_list|(
name|dbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|dir
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ffs_dump_dirbuf: dir %s size %d cur %d\n"
argument_list|,
name|dir
argument_list|,
name|dbuf
operator|->
name|size
argument_list|,
name|dbuf
operator|->
name|cur
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbuf
operator|->
name|size
condition|;
control|)
block|{
name|de
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|dbuf
operator|->
name|buf
operator|+
name|i
operator|)
expr_stmt|;
name|reclen
operator|=
name|ufs_rw16
argument_list|(
name|de
operator|->
name|d_reclen
argument_list|,
name|needswap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" inode %4d %7s offset %4d reclen %3d namlen %3d name %s\n"
argument_list|,
name|ufs_rw32
argument_list|(
name|de
operator|->
name|d_ino
argument_list|,
name|needswap
argument_list|)
argument_list|,
name|inode_type
argument_list|(
name|DTTOIF
argument_list|(
name|de
operator|->
name|d_type
argument_list|)
argument_list|)
argument_list|,
name|i
argument_list|,
name|reclen
argument_list|,
name|de
operator|->
name|d_namlen
argument_list|,
name|de
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|i
operator|+=
name|reclen
expr_stmt|;
name|assert
argument_list|(
name|reclen
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ffs_make_dirbuf
parameter_list|(
name|dirbuf_t
modifier|*
name|dbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|fsnode
modifier|*
name|node
parameter_list|,
name|int
name|needswap
parameter_list|)
block|{
name|struct
name|direct
name|de
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|uint16_t
name|llen
decl_stmt|,
name|reclen
decl_stmt|;
name|u_char
modifier|*
name|newbuf
decl_stmt|;
name|assert
argument_list|(
name|dbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* create direct entry */
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|de
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|de
argument_list|)
argument_list|)
expr_stmt|;
name|de
operator|.
name|d_ino
operator|=
name|ufs_rw32
argument_list|(
name|node
operator|->
name|inode
operator|->
name|ino
argument_list|,
name|needswap
argument_list|)
expr_stmt|;
name|de
operator|.
name|d_type
operator|=
name|IFTODT
argument_list|(
name|node
operator|->
name|type
argument_list|)
expr_stmt|;
name|de
operator|.
name|d_namlen
operator|=
operator|(
name|uint8_t
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|de
operator|.
name|d_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|reclen
operator|=
name|DIRSIZ_SWAP
argument_list|(
literal|0
argument_list|,
operator|&
name|de
argument_list|,
name|needswap
argument_list|)
expr_stmt|;
name|de
operator|.
name|d_reclen
operator|=
name|ufs_rw16
argument_list|(
name|reclen
argument_list|,
name|needswap
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|dbuf
operator|->
name|buf
operator|+
name|dbuf
operator|->
name|cur
operator|)
expr_stmt|;
name|llen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|llen
operator|=
name|DIRSIZ_SWAP
argument_list|(
literal|0
argument_list|,
name|dp
argument_list|,
name|needswap
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_MAKE_DIRBUF
condition|)
name|printf
argument_list|(
literal|"ffs_make_dirbuf: dbuf siz %d cur %d lastlen %d\n"
literal|"  ino %d type %d reclen %d namlen %d name %.30s\n"
argument_list|,
name|dbuf
operator|->
name|size
argument_list|,
name|dbuf
operator|->
name|cur
argument_list|,
name|llen
argument_list|,
name|ufs_rw32
argument_list|(
name|de
operator|.
name|d_ino
argument_list|,
name|needswap
argument_list|)
argument_list|,
name|de
operator|.
name|d_type
argument_list|,
name|reclen
argument_list|,
name|de
operator|.
name|d_namlen
argument_list|,
name|de
operator|.
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|+
name|dbuf
operator|->
name|cur
operator|+
name|llen
operator|>
name|roundup
argument_list|(
name|dbuf
operator|->
name|size
argument_list|,
name|DIRBLKSIZ
argument_list|)
condition|)
block|{
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_MAKE_DIRBUF
condition|)
name|printf
argument_list|(
literal|"ffs_make_dirbuf: growing buf to %d\n"
argument_list|,
name|dbuf
operator|->
name|size
operator|+
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newbuf
operator|=
name|realloc
argument_list|(
name|dbuf
operator|->
name|buf
argument_list|,
name|dbuf
operator|->
name|size
operator|+
name|DIRBLKSIZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Allocating memory for directory buffer"
argument_list|)
expr_stmt|;
name|dbuf
operator|->
name|buf
operator|=
name|newbuf
expr_stmt|;
name|dbuf
operator|->
name|size
operator|+=
name|DIRBLKSIZ
expr_stmt|;
name|memset
argument_list|(
name|dbuf
operator|->
name|buf
operator|+
name|dbuf
operator|->
name|size
operator|-
name|DIRBLKSIZ
argument_list|,
literal|0
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
name|dbuf
operator|->
name|cur
operator|=
name|dbuf
operator|->
name|size
operator|-
name|DIRBLKSIZ
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
condition|)
block|{
comment|/* shrink end of previous */
name|dp
operator|->
name|d_reclen
operator|=
name|ufs_rw16
argument_list|(
name|llen
argument_list|,
name|needswap
argument_list|)
expr_stmt|;
name|dbuf
operator|->
name|cur
operator|+=
name|llen
expr_stmt|;
block|}
name|dp
operator|=
operator|(
expr|struct
name|direct
operator|*
operator|)
operator|(
name|dbuf
operator|->
name|buf
operator|+
name|dbuf
operator|->
name|cur
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|dp
argument_list|,
operator|&
name|de
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|ufs_rw16
argument_list|(
name|dbuf
operator|->
name|size
operator|-
name|dbuf
operator|->
name|cur
argument_list|,
name|needswap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cribbed from sys/ufs/ffs/ffs_alloc.c  */
end_comment

begin_function
specifier|static
name|void
name|ffs_write_inode
parameter_list|(
name|union
name|dinode
modifier|*
name|dp
parameter_list|,
name|uint32_t
name|ino
parameter_list|,
specifier|const
name|fsinfo_t
modifier|*
name|fsopts
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|ufs1_dinode
modifier|*
name|dp1
decl_stmt|;
name|struct
name|ufs2_dinode
modifier|*
name|dp2
decl_stmt|,
modifier|*
name|dip
decl_stmt|;
name|struct
name|cg
modifier|*
name|cgp
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|int
name|cg
decl_stmt|,
name|cgino
decl_stmt|,
name|i
decl_stmt|;
name|daddr_t
name|d
decl_stmt|;
name|char
name|sbbuf
index|[
name|FFS_MAXBSIZE
index|]
decl_stmt|;
name|int32_t
name|initediblk
decl_stmt|;
name|ffs_opt_t
modifier|*
name|ffs_opts
init|=
name|fsopts
operator|->
name|fs_specific
decl_stmt|;
name|assert
argument_list|(
name|dp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ino
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|fsopts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ffs_opts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fs
operator|=
operator|(
expr|struct
name|fs
operator|*
operator|)
name|fsopts
operator|->
name|superblock
expr_stmt|;
name|cg
operator|=
name|ino_to_cg
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|cgino
operator|=
name|ino
operator|%
name|fs
operator|->
name|fs_ipg
expr_stmt|;
if|if
condition|(
name|debug
operator|&
name|DEBUG_FS_WRITE_INODE
condition|)
name|printf
argument_list|(
literal|"ffs_write_inode: din %p ino %u cg %d cgino %d\n"
argument_list|,
name|dp
argument_list|,
name|ino
argument_list|,
name|cg
argument_list|,
name|cgino
argument_list|)
expr_stmt|;
name|ffs_rdfs
argument_list|(
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_cgsize
argument_list|,
operator|&
name|sbbuf
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
name|cgp
operator|=
operator|(
expr|struct
name|cg
operator|*
operator|)
name|sbbuf
expr_stmt|;
if|if
condition|(
operator|!
name|cg_chkmagic_swap
argument_list|(
name|cgp
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"ffs_write_inode: cg %d: bad magic number"
argument_list|,
name|cg
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|isclr
argument_list|(
name|cg_inosused_swap
argument_list|(
name|cgp
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
argument_list|,
name|cgino
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"ffs_write_inode: cg %d: can't alloc inode block"
argument_list|,
name|cg
argument_list|)
expr_stmt|;
name|dp1
operator|=
operator|(
expr|struct
name|ufs1_dinode
operator|*
operator|)
name|buf
expr_stmt|;
name|dp2
operator|=
operator|(
expr|struct
name|ufs2_dinode
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nifree
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"ffs_write_inode: fs out of inodes for ino %u"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|.
name|cs_nifree
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"ffs_write_inode: cg %d out of inodes for ino %u"
argument_list|,
name|cg
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|cg_inosused_swap
argument_list|(
name|cgp
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
argument_list|,
name|cgino
argument_list|)
expr_stmt|;
name|ufs_add32
argument_list|(
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_nifree
argument_list|,
operator|-
literal|1
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_nifree
operator|--
expr_stmt|;
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|.
name|cs_nifree
operator|--
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|DIP
argument_list|(
name|dp
argument_list|,
name|mode
argument_list|)
argument_list|)
condition|)
block|{
name|ufs_add32
argument_list|(
name|cgp
operator|->
name|cg_cs
operator|.
name|cs_ndir
argument_list|,
literal|1
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_cstotal
operator|.
name|cs_ndir
operator|++
expr_stmt|;
name|fs
operator|->
name|fs_cs
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
operator|.
name|cs_ndir
operator|++
expr_stmt|;
block|}
comment|/* 	 * Initialize inode blocks on the fly for UFS2. 	 */
name|initediblk
operator|=
name|ufs_rw32
argument_list|(
name|cgp
operator|->
name|cg_initediblk
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffs_opts
operator|->
name|version
operator|==
literal|2
operator|&&
name|cgino
operator|+
name|INOPB
argument_list|(
name|fs
argument_list|)
operator|>
name|initediblk
operator|&&
name|initediblk
operator|<
name|ufs_rw32
argument_list|(
name|cgp
operator|->
name|cg_niblk
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|)
expr_stmt|;
name|dip
operator|=
operator|(
expr|struct
name|ufs2_dinode
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* Seeding affects reproducible builds. */
name|srandom
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|INOPB
argument_list|(
name|fs
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|dip
operator|->
name|di_gen
operator|=
name|random
argument_list|()
expr_stmt|;
name|dip
operator|++
expr_stmt|;
block|}
name|ffs_wtfs
argument_list|(
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|cg
operator|*
name|fs
operator|->
name|fs_ipg
operator|+
name|initediblk
argument_list|)
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|buf
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
name|initediblk
operator|+=
name|INOPB
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|cgp
operator|->
name|cg_initediblk
operator|=
name|ufs_rw32
argument_list|(
name|initediblk
argument_list|,
name|fsopts
operator|->
name|needswap
argument_list|)
expr_stmt|;
block|}
name|ffs_wtfs
argument_list|(
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|cgtod
argument_list|(
name|fs
argument_list|,
name|cg
argument_list|)
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|fs_cgsize
argument_list|,
operator|&
name|sbbuf
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
comment|/* now write inode */
name|d
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
argument_list|)
expr_stmt|;
name|ffs_rdfs
argument_list|(
name|d
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|buf
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsopts
operator|->
name|needswap
condition|)
block|{
if|if
condition|(
name|ffs_opts
operator|->
name|version
operator|==
literal|1
condition|)
name|ffs_dinode1_swap
argument_list|(
operator|&
name|dp
operator|->
name|ffs1_din
argument_list|,
operator|&
name|dp1
index|[
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
index|]
argument_list|)
expr_stmt|;
else|else
name|ffs_dinode2_swap
argument_list|(
operator|&
name|dp
operator|->
name|ffs2_din
argument_list|,
operator|&
name|dp2
index|[
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ffs_opts
operator|->
name|version
operator|==
literal|1
condition|)
name|dp1
index|[
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
index|]
operator|=
name|dp
operator|->
name|ffs1_din
expr_stmt|;
else|else
name|dp2
index|[
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|ino
argument_list|)
index|]
operator|=
name|dp
operator|->
name|ffs2_din
expr_stmt|;
block|}
name|ffs_wtfs
argument_list|(
name|d
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
name|buf
argument_list|,
name|fsopts
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|panic
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vwarnx
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

