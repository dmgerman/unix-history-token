begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997-2007 Kenneth D. Merry  * Copyright (c) 2013, 2014, 2015 Spectra Logic Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions, and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    substantially similar to the "NO WARRANTY" disclaimer below  *    ("Disclaimer") and any redistribution must be conditioned upon  *    including a substantially similar Disclaimer requirement for further  *    binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT  * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGES.  *  * Authors: Ken Merry           (Spectra Logic Corporation)  */
end_comment

begin_comment
comment|/*  * This is eventually intended to be:  * - A basic data transfer/copy utility  * - A simple benchmark utility  * - An example of how to use the asynchronous pass(4) driver interface.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus_dma.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<semaphore.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<bsdxml.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_debug.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_da.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pass.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/smp_all.h>
end_include

begin_include
include|#
directive|include
file|<camlib.h>
end_include

begin_include
include|#
directive|include
file|<mtlib.h>
end_include

begin_include
include|#
directive|include
file|<zlib.h>
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAMDD_CMD_NONE
init|=
literal|0x00000000
block|,
name|CAMDD_CMD_HELP
init|=
literal|0x00000001
block|,
name|CAMDD_CMD_WRITE
init|=
literal|0x00000002
block|,
name|CAMDD_CMD_READ
init|=
literal|0x00000003
block|}
name|camdd_cmdmask
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAMDD_ARG_NONE
init|=
literal|0x00000000
block|,
name|CAMDD_ARG_VERBOSE
init|=
literal|0x00000001
block|,
name|CAMDD_ARG_DEVICE
init|=
literal|0x00000002
block|,
name|CAMDD_ARG_BUS
init|=
literal|0x00000004
block|,
name|CAMDD_ARG_TARGET
init|=
literal|0x00000008
block|,
name|CAMDD_ARG_LUN
init|=
literal|0x00000010
block|,
name|CAMDD_ARG_UNIT
init|=
literal|0x00000020
block|,
name|CAMDD_ARG_TIMEOUT
init|=
literal|0x00000040
block|,
name|CAMDD_ARG_ERR_RECOVER
init|=
literal|0x00000080
block|,
name|CAMDD_ARG_RETRIES
init|=
literal|0x00000100
block|}
name|camdd_argmask
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAMDD_DEV_NONE
init|=
literal|0x00
block|,
name|CAMDD_DEV_PASS
init|=
literal|0x01
block|,
name|CAMDD_DEV_FILE
init|=
literal|0x02
block|}
name|camdd_dev_type
typedef|;
end_typedef

begin_struct
struct|struct
name|camdd_io_opts
block|{
name|camdd_dev_type
name|dev_type
decl_stmt|;
name|char
modifier|*
name|dev_name
decl_stmt|;
name|uint64_t
name|blocksize
decl_stmt|;
name|uint64_t
name|queue_depth
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|int
name|min_cmd_size
decl_stmt|;
name|int
name|write_dev
decl_stmt|;
name|uint64_t
name|debug
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAMDD_BUF_NONE
block|,
name|CAMDD_BUF_DATA
block|,
name|CAMDD_BUF_INDIRECT
block|}
name|camdd_buf_type
typedef|;
end_typedef

begin_struct
struct|struct
name|camdd_buf_indirect
block|{
comment|/* 	 * Pointer to the source buffer. 	 */
name|struct
name|camdd_buf
modifier|*
name|src_buf
decl_stmt|;
comment|/* 	 * Offset into the source buffer, in bytes. 	 */
name|uint64_t
name|offset
decl_stmt|;
comment|/* 	 * Pointer to the starting point in the source buffer. 	 */
name|uint8_t
modifier|*
name|start_ptr
decl_stmt|;
comment|/* 	 * Length of this chunk in bytes. 	 */
name|size_t
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|camdd_buf_data
block|{
comment|/* 	 * Buffer allocated when we allocate this camdd_buf.  This should 	 * be the size of the blocksize for this device. 	 */
name|uint8_t
modifier|*
name|buf
decl_stmt|;
comment|/* 	 * The amount of backing store allocated in buf.  Generally this 	 * will be the blocksize of the device. 	 */
name|uint32_t
name|alloc_len
decl_stmt|;
comment|/* 	 * The amount of data that was put into the buffer (on reads) or 	 * the amount of data we have put onto the src_list so far (on 	 * writes). 	 */
name|uint32_t
name|fill_len
decl_stmt|;
comment|/* 	 * The amount of data that was not transferred. 	 */
name|uint32_t
name|resid
decl_stmt|;
comment|/* 	 * Starting byte offset on the reader. 	 */
name|uint64_t
name|src_start_offset
decl_stmt|;
comment|/* 	 * CCB used for pass(4) device targets. 	 */
name|union
name|ccb
name|ccb
decl_stmt|;
comment|/* 	 * Number of scatter/gather segments. 	 */
name|int
name|sg_count
decl_stmt|;
comment|/* 	 * Set if we had to tack on an extra buffer to round the transfer 	 * up to a sector size. 	 */
name|int
name|extra_buf
decl_stmt|;
comment|/* 	 * Scatter/gather list used generally when we're the writer for a 	 * pass(4) device.  	 */
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
comment|/* 	 * Scatter/gather list used generally when we're the writer for a 	 * file or block device; 	 */
name|struct
name|iovec
modifier|*
name|iovec
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|camdd_buf_types
block|{
name|struct
name|camdd_buf_indirect
name|indirect
decl_stmt|;
name|struct
name|camdd_buf_data
name|data
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAMDD_STATUS_NONE
block|,
name|CAMDD_STATUS_OK
block|,
name|CAMDD_STATUS_SHORT_IO
block|,
name|CAMDD_STATUS_EOF
block|,
name|CAMDD_STATUS_ERROR
block|}
name|camdd_buf_status
typedef|;
end_typedef

begin_struct
struct|struct
name|camdd_buf
block|{
name|camdd_buf_type
name|buf_type
decl_stmt|;
name|union
name|camdd_buf_types
name|buf_type_spec
decl_stmt|;
name|camdd_buf_status
name|status
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* 	 * A reference count of how many indirect buffers point to this 	 * buffer. 	 */
name|int
name|refcount
decl_stmt|;
comment|/* 	 * A link back to our parent device. 	 */
name|struct
name|camdd_dev
modifier|*
name|dev
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|camdd_buf
argument_list|)
name|links
expr_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|camdd_buf
argument_list|)
name|work_links
expr_stmt|;
comment|/* 	 * A count of the buffers on the src_list. 	 */
name|int
name|src_count
decl_stmt|;
comment|/* 	 * List of buffers from our partner thread that are the components 	 * of this buffer for the I/O.  Uses src_links. 	 */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|camdd_buf
argument_list|)
name|src_list
expr_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|camdd_buf
argument_list|)
name|src_links
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NUM_DEV_TYPES
value|2
end_define

begin_struct
struct|struct
name|camdd_dev_pass
block|{
name|int
name|scsi_dev_type
decl_stmt|;
name|struct
name|cam_device
modifier|*
name|dev
decl_stmt|;
name|uint64_t
name|max_sector
decl_stmt|;
name|uint32_t
name|block_len
decl_stmt|;
name|uint32_t
name|cpi_maxio
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAMDD_FILE_NONE
block|,
name|CAMDD_FILE_REG
block|,
name|CAMDD_FILE_STD
block|,
name|CAMDD_FILE_PIPE
block|,
name|CAMDD_FILE_DISK
block|,
name|CAMDD_FILE_TAPE
block|,
name|CAMDD_FILE_TTY
block|,
name|CAMDD_FILE_MEM
block|}
name|camdd_file_type
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAMDD_FF_NONE
init|=
literal|0x00
block|,
name|CAMDD_FF_CAN_SEEK
init|=
literal|0x01
block|}
name|camdd_file_flags
typedef|;
end_typedef

begin_struct
struct|struct
name|camdd_dev_file
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|char
name|filename
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|camdd_file_type
name|file_type
decl_stmt|;
name|camdd_file_flags
name|file_flags
decl_stmt|;
name|uint8_t
modifier|*
name|tmp_buf
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|camdd_dev_block
block|{
name|int
name|fd
decl_stmt|;
name|uint64_t
name|size_bytes
decl_stmt|;
name|uint32_t
name|block_len
decl_stmt|;
block|}
struct|;
end_struct

begin_union
union|union
name|camdd_dev_spec
block|{
name|struct
name|camdd_dev_pass
name|pass
decl_stmt|;
name|struct
name|camdd_dev_file
name|file
decl_stmt|;
name|struct
name|camdd_dev_block
name|block
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAMDD_DEV_FLAG_NONE
init|=
literal|0x00
block|,
name|CAMDD_DEV_FLAG_EOF
init|=
literal|0x01
block|,
name|CAMDD_DEV_FLAG_PEER_EOF
init|=
literal|0x02
block|,
name|CAMDD_DEV_FLAG_ACTIVE
init|=
literal|0x04
block|,
name|CAMDD_DEV_FLAG_EOF_SENT
init|=
literal|0x08
block|,
name|CAMDD_DEV_FLAG_EOF_QUEUED
init|=
literal|0x10
block|}
name|camdd_dev_flags
typedef|;
end_typedef

begin_struct
struct|struct
name|camdd_dev
block|{
name|camdd_dev_type
name|dev_type
decl_stmt|;
name|union
name|camdd_dev_spec
name|dev_spec
decl_stmt|;
name|camdd_dev_flags
name|flags
decl_stmt|;
name|char
name|device_name
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|uint32_t
name|blocksize
decl_stmt|;
name|uint32_t
name|sector_size
decl_stmt|;
name|uint64_t
name|max_sector
decl_stmt|;
name|uint64_t
name|sector_io_limit
decl_stmt|;
name|int
name|min_cmd_size
decl_stmt|;
name|int
name|write_dev
decl_stmt|;
name|int
name|retry_count
decl_stmt|;
name|int
name|io_timeout
decl_stmt|;
name|int
name|debug
decl_stmt|;
name|uint64_t
name|start_offset_bytes
decl_stmt|;
name|uint64_t
name|next_io_pos_bytes
decl_stmt|;
name|uint64_t
name|next_peer_pos_bytes
decl_stmt|;
name|uint64_t
name|next_completion_pos_bytes
decl_stmt|;
name|uint64_t
name|peer_bytes_queued
decl_stmt|;
name|uint64_t
name|bytes_transferred
decl_stmt|;
name|uint32_t
name|target_queue_depth
decl_stmt|;
name|uint32_t
name|cur_active_io
decl_stmt|;
name|uint8_t
modifier|*
name|extra_buf
decl_stmt|;
name|uint32_t
name|extra_buf_len
decl_stmt|;
name|struct
name|camdd_dev
modifier|*
name|peer_dev
decl_stmt|;
name|pthread_mutex_t
name|mutex
decl_stmt|;
name|pthread_cond_t
name|cond
decl_stmt|;
name|int
name|kq
decl_stmt|;
name|int
function_decl|(
modifier|*
name|run
function_decl|)
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|fetch
function_decl|)
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
comment|/* 	 * Buffers that are available for I/O.  Uses links. 	 */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|camdd_buf
argument_list|)
name|free_queue
expr_stmt|;
comment|/* 	 * Free indirect buffers.  These are used for breaking a large 	 * buffer into multiple pieces. 	 */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|camdd_buf
argument_list|)
name|free_indirect_queue
expr_stmt|;
comment|/* 	 * Buffers that have been queued to the kernel.  Uses links. 	 */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|camdd_buf
argument_list|)
name|active_queue
expr_stmt|;
comment|/* 	 * Will generally contain one of our buffers that is waiting for enough 	 * I/O from our partner thread to be able to execute.  This will 	 * generally happen when our per-I/O-size is larger than the 	 * partner thread's per-I/O-size.  Uses links. 	 */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|camdd_buf
argument_list|)
name|pending_queue
expr_stmt|;
comment|/* 	 * Number of buffers on the pending queue 	 */
name|int
name|num_pending_queue
decl_stmt|;
comment|/* 	 * Buffers that are filled and ready to execute.  This is used when 	 * our partner (reader) thread sends us blocks that are larger than 	 * our blocksize, and so we have to split them into multiple pieces. 	 */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|camdd_buf
argument_list|)
name|run_queue
expr_stmt|;
comment|/* 	 * Number of buffers on the run queue. 	 */
name|int
name|num_run_queue
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|camdd_buf
argument_list|)
name|reorder_queue
expr_stmt|;
name|int
name|num_reorder_queue
decl_stmt|;
comment|/* 	 * Buffers that have been queued to us by our partner thread 	 * (generally the reader thread) to be written out.  Uses 	 * work_links. 	 */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|camdd_buf
argument_list|)
name|work_queue
expr_stmt|;
comment|/* 	 * Buffers that have been completed by our partner thread.  Uses 	 * work_links. 	 */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|camdd_buf
argument_list|)
name|peer_done_queue
expr_stmt|;
comment|/* 	 * Number of buffers on the peer done queue. 	 */
name|uint32_t
name|num_peer_done_queue
decl_stmt|;
comment|/* 	 * A list of buffers that we have queued to our peer thread.  Uses 	 * links. 	 */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|camdd_buf
argument_list|)
name|peer_work_queue
expr_stmt|;
comment|/* 	 * Number of buffers on the peer work queue. 	 */
name|uint32_t
name|num_peer_work_queue
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|sem_t
name|camdd_sem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sig_atomic_t
name|need_exit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sig_atomic_t
name|error_exit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sig_atomic_t
name|need_status
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a< b) ? a : b
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * XXX KDM private copy of timespecsub().  This is normally defined in  * sys/time.h, but is only enabled in the kernel.  If that definition is  * enabled in userland, it breaks the build of libnetbsd.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|timespecsub
end_ifndef

begin_define
define|#
directive|define
name|timespecsub
parameter_list|(
name|vvp
parameter_list|,
name|uvp
parameter_list|)
define|\
value|do {								\ 		(vvp)->tv_sec -= (uvp)->tv_sec;				\ 		(vvp)->tv_nsec -= (uvp)->tv_nsec;			\ 		if ((vvp)->tv_nsec< 0) {				\ 			(vvp)->tv_sec--;				\ 			(vvp)->tv_nsec += 1000000000;			\ 		}							\ 	} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Generically useful offsets into the peripheral private area */
end_comment

begin_define
define|#
directive|define
name|ppriv_ptr0
value|periph_priv.entries[0].ptr
end_define

begin_define
define|#
directive|define
name|ppriv_ptr1
value|periph_priv.entries[1].ptr
end_define

begin_define
define|#
directive|define
name|ppriv_field0
value|periph_priv.entries[0].field
end_define

begin_define
define|#
directive|define
name|ppriv_field1
value|periph_priv.entries[1].field
end_define

begin_define
define|#
directive|define
name|ccb_buf
value|ppriv_ptr0
end_define

begin_define
define|#
directive|define
name|CAMDD_FILE_DEFAULT_BLOCK
value|524288
end_define

begin_define
define|#
directive|define
name|CAMDD_FILE_DEFAULT_DEPTH
value|1
end_define

begin_define
define|#
directive|define
name|CAMDD_PASS_MAX_BLOCK
value|1048576
end_define

begin_define
define|#
directive|define
name|CAMDD_PASS_DEFAULT_DEPTH
value|6
end_define

begin_define
define|#
directive|define
name|CAMDD_PASS_RW_TIMEOUT
value|60 * 1000
end_define

begin_function_decl
specifier|static
name|int
name|parse_btl
parameter_list|(
name|char
modifier|*
name|tstr
parameter_list|,
name|int
modifier|*
name|bus
parameter_list|,
name|int
modifier|*
name|target
parameter_list|,
name|int
modifier|*
name|lun
parameter_list|,
name|camdd_argmask
modifier|*
name|arglst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|camdd_free_dev
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|camdd_dev
modifier|*
name|camdd_alloc_dev
parameter_list|(
name|camdd_dev_type
name|dev_type
parameter_list|,
name|struct
name|kevent
modifier|*
name|new_ke
parameter_list|,
name|int
name|num_ke
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|camdd_buf
modifier|*
name|camdd_alloc_buf
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|camdd_buf_type
name|buf_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|camdd_release_buf
parameter_list|(
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|camdd_buf
modifier|*
name|camdd_get_buf
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|camdd_buf_type
name|buf_type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|camdd_buf_sg_create
parameter_list|(
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|,
name|int
name|iovec
parameter_list|,
name|uint32_t
name|sector_size
parameter_list|,
name|uint32_t
modifier|*
name|num_sectors_used
parameter_list|,
name|int
modifier|*
name|double_buf_needed
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint32_t
name|camdd_buf_get_len
parameter_list|(
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|camdd_buf_add_child
parameter_list|(
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|,
name|struct
name|camdd_buf
modifier|*
name|child_buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|camdd_probe_tape
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|uint64_t
modifier|*
name|max_iosize
parameter_list|,
name|uint64_t
modifier|*
name|max_blk
parameter_list|,
name|uint64_t
modifier|*
name|min_blk
parameter_list|,
name|uint64_t
modifier|*
name|blk_gran
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|camdd_dev
modifier|*
name|camdd_probe_file
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|camdd_io_opts
modifier|*
name|io_opts
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|camdd_dev
modifier|*
name|camdd_probe_pass
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|,
name|struct
name|camdd_io_opts
modifier|*
name|io_opts
parameter_list|,
name|camdd_argmask
name|arglist
parameter_list|,
name|int
name|probe_retry_count
parameter_list|,
name|int
name|probe_timeout
parameter_list|,
name|int
name|io_retry_count
parameter_list|,
name|int
name|io_timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|camdd_file_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|camdd_buf_status
name|camdd_ccb_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|camdd_queue_peer_buf
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|camdd_complete_peer_buf
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|camdd_buf
modifier|*
name|peer_buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|camdd_peer_done
parameter_list|(
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|camdd_complete_buf
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|error_count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|camdd_pass_fetch
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|camdd_file_run
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|camdd_pass_run
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|camdd_get_next_lba_len
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|uint64_t
modifier|*
name|lba
parameter_list|,
name|ssize_t
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|camdd_queue
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|camdd_buf
modifier|*
name|read_buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|camdd_get_depth
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|uint32_t
modifier|*
name|our_depth
parameter_list|,
name|uint32_t
modifier|*
name|peer_depth
parameter_list|,
name|uint32_t
modifier|*
name|our_bytes
parameter_list|,
name|uint32_t
modifier|*
name|peer_bytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|camdd_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|camdd_sig_handler
parameter_list|(
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|camdd_print_status
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|camdd_dev
parameter_list|,
name|struct
name|camdd_dev
modifier|*
name|other_dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|start_time
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|camdd_rw
parameter_list|(
name|struct
name|camdd_io_opts
modifier|*
name|io_opts
parameter_list|,
name|int
name|num_io_opts
parameter_list|,
name|uint64_t
name|max_io
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|camdd_parse_io_opts
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|is_write
parameter_list|,
name|struct
name|camdd_io_opts
modifier|*
name|io_opts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Parse out a bus, or a bus, target and lun in the following  * format:  * bus  * bus:target  * bus:target:lun  *  * Returns the number of parsed components, or 0.  */
end_comment

begin_function
specifier|static
name|int
name|parse_btl
parameter_list|(
name|char
modifier|*
name|tstr
parameter_list|,
name|int
modifier|*
name|bus
parameter_list|,
name|int
modifier|*
name|target
parameter_list|,
name|int
modifier|*
name|lun
parameter_list|,
name|camdd_argmask
modifier|*
name|arglst
parameter_list|)
block|{
name|char
modifier|*
name|tmpstr
decl_stmt|;
name|int
name|convs
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tstr
argument_list|)
operator|&&
operator|(
operator|*
name|tstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tstr
operator|++
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|tstr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|bus
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|arglst
operator||=
name|CAMDD_ARG_BUS
expr_stmt|;
name|convs
operator|++
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|target
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|arglst
operator||=
name|CAMDD_ARG_TARGET
expr_stmt|;
name|convs
operator|++
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|*
name|lun
operator|=
name|strtol
argument_list|(
name|tmpstr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|arglst
operator||=
name|CAMDD_ARG_LUN
expr_stmt|;
name|convs
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|convs
return|;
block|}
end_function

begin_comment
comment|/*  * XXX KDM clean up and free all of the buffers on the queue!  */
end_comment

begin_function
name|void
name|camdd_free_dev
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|dev
operator|->
name|dev_type
condition|)
block|{
case|case
name|CAMDD_DEV_FILE
case|:
block|{
name|struct
name|camdd_dev_file
modifier|*
name|file_dev
init|=
operator|&
name|dev
operator|->
name|dev_spec
operator|.
name|file
decl_stmt|;
if|if
condition|(
name|file_dev
operator|->
name|fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|file_dev
operator|->
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file_dev
operator|->
name|tmp_buf
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CAMDD_DEV_PASS
case|:
block|{
name|struct
name|camdd_dev_pass
modifier|*
name|pass_dev
init|=
operator|&
name|dev
operator|->
name|dev_spec
operator|.
name|pass
decl_stmt|;
if|if
condition|(
name|pass_dev
operator|->
name|dev
operator|!=
name|NULL
condition|)
name|cam_close_device
argument_list|(
name|pass_dev
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
name|free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|camdd_dev
modifier|*
name|camdd_alloc_dev
parameter_list|(
name|camdd_dev_type
name|dev_type
parameter_list|,
name|struct
name|kevent
modifier|*
name|new_ke
parameter_list|,
name|int
name|num_ke
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|camdd_dev
modifier|*
name|dev
init|=
name|NULL
decl_stmt|;
name|struct
name|kevent
modifier|*
name|ke
decl_stmt|;
name|size_t
name|ke_size
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to malloc %zu bytes"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bzero
argument_list|(
name|dev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|dev_type
operator|=
name|dev_type
expr_stmt|;
name|dev
operator|->
name|io_timeout
operator|=
name|timeout
expr_stmt|;
name|dev
operator|->
name|retry_count
operator|=
name|retry_count
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|dev
operator|->
name|free_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|dev
operator|->
name|free_indirect_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|dev
operator|->
name|active_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|dev
operator|->
name|pending_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|dev
operator|->
name|reorder_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|dev
operator|->
name|work_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|dev
operator|->
name|peer_done_queue
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|dev
operator|->
name|peer_work_queue
argument_list|)
expr_stmt|;
name|retval
operator|=
name|pthread_mutex_init
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warnc
argument_list|(
name|retval
argument_list|,
literal|"%s: failed to initialize mutex"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|retval
operator|=
name|pthread_cond_init
argument_list|(
operator|&
name|dev
operator|->
name|cond
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warnc
argument_list|(
name|retval
argument_list|,
literal|"%s: failed to initialize condition variable"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|dev
operator|->
name|kq
operator|=
name|kqueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|kq
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"%s: Unable to create kqueue"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|ke_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
operator|*
operator|(
name|num_ke
operator|+
literal|4
operator|)
expr_stmt|;
name|ke
operator|=
name|malloc
argument_list|(
name|ke_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to malloc %zu bytes"
argument_list|,
name|__func__
argument_list|,
name|ke_size
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bzero
argument_list|(
name|ke
argument_list|,
name|ke_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_ke
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|new_ke
argument_list|,
name|ke
argument_list|,
name|num_ke
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|ke
index|[
name|num_ke
operator|++
index|]
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|dev
operator|->
name|work_queue
argument_list|,
name|EVFILT_USER
argument_list|,
name|EV_ADD
operator||
name|EV_ENABLE
operator||
name|EV_CLEAR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|ke
index|[
name|num_ke
operator|++
index|]
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|dev
operator|->
name|peer_done_queue
argument_list|,
name|EVFILT_USER
argument_list|,
name|EV_ADD
operator||
name|EV_ENABLE
operator||
name|EV_CLEAR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|ke
index|[
name|num_ke
operator|++
index|]
argument_list|,
name|SIGINFO
argument_list|,
name|EVFILT_SIGNAL
argument_list|,
name|EV_ADD
operator||
name|EV_ENABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|EV_SET
argument_list|(
operator|&
name|ke
index|[
name|num_ke
operator|++
index|]
argument_list|,
name|SIGINT
argument_list|,
name|EVFILT_SIGNAL
argument_list|,
name|EV_ADD
operator||
name|EV_ENABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
name|kevent
argument_list|(
name|dev
operator|->
name|kq
argument_list|,
name|ke
argument_list|,
name|num_ke
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"%s: Unable to register kevents"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
return|return
operator|(
name|dev
operator|)
return|;
name|bailout
label|:
name|free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|camdd_buf
modifier|*
name|camdd_alloc_buf
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|camdd_buf_type
name|buf_type
parameter_list|)
block|{
name|struct
name|camdd_buf
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|uint8_t
modifier|*
name|data_ptr
init|=
name|NULL
decl_stmt|;
comment|/* 	 * We only need to allocate data space for data buffers. 	 */
switch|switch
condition|(
name|buf_type
condition|)
block|{
case|case
name|CAMDD_BUF_DATA
case|:
name|data_ptr
operator|=
name|malloc
argument_list|(
name|dev
operator|->
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_ptr
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"unable to allocate %u bytes"
argument_list|,
name|dev
operator|->
name|blocksize
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
break|break;
default|default:
break|break;
block|}
name|buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"unable to allocate %zu bytes"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|buf_type
operator|=
name|buf_type
expr_stmt|;
name|buf
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
switch|switch
condition|(
name|buf_type
condition|)
block|{
case|case
name|CAMDD_BUF_DATA
case|:
block|{
name|struct
name|camdd_buf_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
name|data
operator|->
name|alloc_len
operator|=
name|dev
operator|->
name|blocksize
expr_stmt|;
name|data
operator|->
name|buf
operator|=
name|data_ptr
expr_stmt|;
break|break;
block|}
case|case
name|CAMDD_BUF_INDIRECT
case|:
break|break;
default|default:
break|break;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|buf
operator|->
name|src_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
name|bailout_error
label|:
name|free
argument_list|(
name|data_ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|camdd_release_buf
parameter_list|(
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|camdd_dev
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|buf
operator|->
name|dev
expr_stmt|;
switch|switch
condition|(
name|buf
operator|->
name|buf_type
condition|)
block|{
case|case
name|CAMDD_BUF_DATA
case|:
block|{
name|struct
name|camdd_buf_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|segs
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|extra_buf
operator|!=
literal|0
condition|)
block|{
name|void
modifier|*
name|extra_buf
decl_stmt|;
name|extra_buf
operator|=
operator|(
name|void
operator|*
operator|)
name|data
operator|->
name|segs
index|[
name|data
operator|->
name|sg_count
operator|-
literal|1
index|]
operator|.
name|ds_addr
expr_stmt|;
name|free
argument_list|(
name|extra_buf
argument_list|)
expr_stmt|;
name|data
operator|->
name|extra_buf
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|data
operator|->
name|segs
argument_list|)
expr_stmt|;
name|data
operator|->
name|segs
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|sg_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|iovec
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|extra_buf
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|data
operator|->
name|iovec
index|[
name|data
operator|->
name|sg_count
operator|-
literal|1
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
name|data
operator|->
name|extra_buf
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|data
operator|->
name|iovec
argument_list|)
expr_stmt|;
name|data
operator|->
name|iovec
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|sg_count
operator|=
literal|0
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|free_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CAMDD_BUF_INDIRECT
case|:
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|free_indirect_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s: Invalid buffer type %d for released buffer"
argument_list|,
name|__func__
argument_list|,
name|buf
operator|->
name|buf_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|struct
name|camdd_buf
modifier|*
name|camdd_get_buf
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|camdd_buf_type
name|buf_type
parameter_list|)
block|{
name|struct
name|camdd_buf
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|buf_type
condition|)
block|{
case|case
name|CAMDD_BUF_DATA
case|:
name|buf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|free_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|struct
name|camdd_buf_data
modifier|*
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|data_ptr
decl_stmt|;
name|uint32_t
name|alloc_len
decl_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|free_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
name|data_ptr
operator|=
name|data
operator|->
name|buf
expr_stmt|;
name|alloc_len
operator|=
name|data
operator|->
name|alloc_len
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|->
name|buf
operator|=
name|data_ptr
expr_stmt|;
name|data
operator|->
name|alloc_len
operator|=
name|alloc_len
expr_stmt|;
block|}
break|break;
case|case
name|CAMDD_BUF_INDIRECT
case|:
name|buf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|free_indirect_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|free_indirect_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|warnx
argument_list|(
literal|"Unknown buffer type %d requested"
argument_list|,
name|buf_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|camdd_alloc_buf
argument_list|(
name|dev
argument_list|,
name|buf_type
argument_list|)
operator|)
return|;
else|else
block|{
name|STAILQ_INIT
argument_list|(
operator|&
name|buf
operator|->
name|src_list
argument_list|)
expr_stmt|;
name|buf
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|buf
operator|->
name|buf_type
operator|=
name|buf_type
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|camdd_buf_sg_create
parameter_list|(
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|,
name|int
name|iovec
parameter_list|,
name|uint32_t
name|sector_size
parameter_list|,
name|uint32_t
modifier|*
name|num_sectors_used
parameter_list|,
name|int
modifier|*
name|double_buf_needed
parameter_list|)
block|{
name|struct
name|camdd_buf
modifier|*
name|tmp_buf
decl_stmt|;
name|struct
name|camdd_buf_data
modifier|*
name|data
decl_stmt|;
name|uint8_t
modifier|*
name|extra_buf
init|=
name|NULL
decl_stmt|;
name|size_t
name|extra_buf_len
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
name|data
operator|->
name|sg_count
operator|=
name|buf
operator|->
name|src_count
expr_stmt|;
comment|/* 	 * Compose a scatter/gather list from all of the buffers in the list. 	 * If the length of the buffer isn't a multiple of the sector size, 	 * we'll have to add an extra buffer.  This should only happen 	 * at the end of a transfer. 	 */
if|if
condition|(
operator|(
name|data
operator|->
name|fill_len
operator|%
name|sector_size
operator|)
operator|!=
literal|0
condition|)
block|{
name|extra_buf_len
operator|=
name|sector_size
operator|-
operator|(
name|data
operator|->
name|fill_len
operator|%
name|sector_size
operator|)
expr_stmt|;
name|extra_buf
operator|=
name|calloc
argument_list|(
name|extra_buf_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra_buf
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zu bytes for extra "
literal|"buffer space"
argument_list|,
name|__func__
argument_list|,
name|extra_buf_len
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|data
operator|->
name|extra_buf
operator|=
literal|1
expr_stmt|;
name|data
operator|->
name|sg_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|iovec
operator|==
literal|0
condition|)
block|{
name|data
operator|->
name|segs
operator|=
name|calloc
argument_list|(
name|data
operator|->
name|sg_count
argument_list|,
sizeof|sizeof
argument_list|(
name|bus_dma_segment_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|segs
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zu bytes for S/G list"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
name|bus_dma_segment_t
argument_list|)
operator|*
name|data
operator|->
name|sg_count
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
else|else
block|{
name|data
operator|->
name|iovec
operator|=
name|calloc
argument_list|(
name|data
operator|->
name|sg_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iovec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|iovec
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s: unable to allocate %zu bytes for S/G list"
argument_list|,
name|__func__
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iovec
argument_list|)
operator|*
name|data
operator|->
name|sg_count
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmp_buf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|buf
operator|->
name|src_list
argument_list|)
init|;
name|i
operator|<
name|buf
operator|->
name|src_count
operator|&&
name|tmp_buf
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|tmp_buf
operator|=
name|STAILQ_NEXT
argument_list|(
name|tmp_buf
argument_list|,
name|src_links
argument_list|)
control|)
block|{
if|if
condition|(
name|tmp_buf
operator|->
name|buf_type
operator|==
name|CAMDD_BUF_DATA
condition|)
block|{
name|struct
name|camdd_buf_data
modifier|*
name|tmp_data
decl_stmt|;
name|tmp_data
operator|=
operator|&
name|tmp_buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
if|if
condition|(
name|iovec
operator|==
literal|0
condition|)
block|{
name|data
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|tmp_data
operator|->
name|buf
expr_stmt|;
name|data
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|=
name|tmp_data
operator|->
name|fill_len
operator|-
name|tmp_data
operator|->
name|resid
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|iovec
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|tmp_data
operator|->
name|buf
expr_stmt|;
name|data
operator|->
name|iovec
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|tmp_data
operator|->
name|fill_len
operator|-
name|tmp_data
operator|->
name|resid
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|tmp_data
operator|->
name|fill_len
operator|-
name|tmp_data
operator|->
name|resid
operator|)
operator|%
name|sector_size
operator|)
operator|!=
literal|0
condition|)
operator|*
name|double_buf_needed
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|struct
name|camdd_buf_indirect
modifier|*
name|tmp_ind
decl_stmt|;
name|tmp_ind
operator|=
operator|&
name|tmp_buf
operator|->
name|buf_type_spec
operator|.
name|indirect
expr_stmt|;
if|if
condition|(
name|iovec
operator|==
literal|0
condition|)
block|{
name|data
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|tmp_ind
operator|->
name|start_ptr
expr_stmt|;
name|data
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|=
name|tmp_ind
operator|->
name|len
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|iovec
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|tmp_ind
operator|->
name|start_ptr
expr_stmt|;
name|data
operator|->
name|iovec
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|tmp_ind
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tmp_ind
operator|->
name|len
operator|%
name|sector_size
operator|)
operator|!=
literal|0
condition|)
operator|*
name|double_buf_needed
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|extra_buf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|iovec
operator|==
literal|0
condition|)
block|{
name|data
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|=
operator|(
name|bus_addr_t
operator|)
name|extra_buf
expr_stmt|;
name|data
operator|->
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|=
name|extra_buf_len
expr_stmt|;
block|}
else|else
block|{
name|data
operator|->
name|iovec
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|extra_buf
expr_stmt|;
name|data
operator|->
name|iovec
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|extra_buf_len
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tmp_buf
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|i
operator|!=
name|data
operator|->
name|sg_count
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"buffer source count does not match "
literal|"number of buffers in list!"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bailout
label|:
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
operator|*
name|num_sectors_used
operator|=
operator|(
name|data
operator|->
name|fill_len
operator|+
name|extra_buf_len
operator|)
operator|/
name|sector_size
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|camdd_buf_get_len
parameter_list|(
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|)
block|{
name|uint32_t
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|buf
operator|->
name|buf_type
operator|!=
name|CAMDD_BUF_DATA
condition|)
block|{
name|struct
name|camdd_buf_indirect
modifier|*
name|indirect
decl_stmt|;
name|indirect
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|indirect
expr_stmt|;
name|len
operator|=
name|indirect
operator|->
name|len
expr_stmt|;
block|}
else|else
block|{
name|struct
name|camdd_buf_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
name|len
operator|=
name|data
operator|->
name|fill_len
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
name|void
name|camdd_buf_add_child
parameter_list|(
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|,
name|struct
name|camdd_buf
modifier|*
name|child_buf
parameter_list|)
block|{
name|struct
name|camdd_buf_data
modifier|*
name|data
decl_stmt|;
name|assert
argument_list|(
name|buf
operator|->
name|buf_type
operator|==
name|CAMDD_BUF_DATA
argument_list|)
expr_stmt|;
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|buf
operator|->
name|src_list
argument_list|,
name|child_buf
argument_list|,
name|src_links
argument_list|)
expr_stmt|;
name|buf
operator|->
name|src_count
operator|++
expr_stmt|;
name|data
operator|->
name|fill_len
operator|+=
name|camdd_buf_get_len
argument_list|(
name|child_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
block|{
name|CAMDD_TS_MAX_BLK
block|,
name|CAMDD_TS_MIN_BLK
block|,
name|CAMDD_TS_BLK_GRAN
block|,
name|CAMDD_TS_EFF_IOSIZE
block|}
name|camdd_status_item_index
typedef|;
end_typedef

begin_struct
specifier|static
struct|struct
name|camdd_status_items
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|mt_status_entry
modifier|*
name|entry
decl_stmt|;
block|}
name|req_status_items
index|[]
init|=
block|{
block|{
literal|"max_blk"
block|,
name|NULL
block|}
block|,
block|{
literal|"min_blk"
block|,
name|NULL
block|}
block|,
block|{
literal|"blk_gran"
block|,
name|NULL
block|}
block|,
block|{
literal|"max_effective_iosize"
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
name|int
name|camdd_probe_tape
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|uint64_t
modifier|*
name|max_iosize
parameter_list|,
name|uint64_t
modifier|*
name|max_blk
parameter_list|,
name|uint64_t
modifier|*
name|min_blk
parameter_list|,
name|uint64_t
modifier|*
name|blk_gran
parameter_list|)
block|{
name|struct
name|mt_status_data
name|status_data
decl_stmt|;
name|char
modifier|*
name|xml_str
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|retval
operator|=
name|mt_get_xml_str
argument_list|(
name|fd
argument_list|,
name|MTIOCEXTGET
argument_list|,
operator|&
name|xml_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Couldn't get XML string from %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|retval
operator|=
name|mt_get_status
argument_list|(
name|xml_str
argument_list|,
operator|&
name|status_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|XML_STATUS_OK
condition|)
block|{
name|warn
argument_list|(
literal|"couldn't get status for %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
else|else
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status_data
operator|.
name|error
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|status_data
operator|.
name|error_str
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|req_status_items
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|req_status_items
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|req_status_items
index|[
name|i
index|]
operator|.
name|entry
operator|=
name|mt_status_entry_find
argument_list|(
operator|&
name|status_data
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|req_status_items
index|[
name|i
index|]
operator|.
name|entry
operator|==
name|NULL
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Cannot find status entry %s"
argument_list|,
name|req_status_items
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|max_iosize
operator|=
name|req_status_items
index|[
name|CAMDD_TS_EFF_IOSIZE
index|]
operator|.
name|entry
operator|->
name|value_unsigned
expr_stmt|;
operator|*
name|max_blk
operator|=
name|req_status_items
index|[
name|CAMDD_TS_MAX_BLK
index|]
operator|.
name|entry
operator|->
name|value_unsigned
expr_stmt|;
operator|*
name|min_blk
operator|=
name|req_status_items
index|[
name|CAMDD_TS_MIN_BLK
index|]
operator|.
name|entry
operator|->
name|value_unsigned
expr_stmt|;
operator|*
name|blk_gran
operator|=
name|req_status_items
index|[
name|CAMDD_TS_BLK_GRAN
index|]
operator|.
name|entry
operator|->
name|value_unsigned
expr_stmt|;
name|bailout
label|:
name|free
argument_list|(
name|xml_str
argument_list|)
expr_stmt|;
name|mt_status_free
argument_list|(
operator|&
name|status_data
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|camdd_dev
modifier|*
name|camdd_probe_file
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|camdd_io_opts
modifier|*
name|io_opts
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|camdd_dev
modifier|*
name|dev
init|=
name|NULL
decl_stmt|;
name|struct
name|camdd_dev_file
modifier|*
name|file_dev
decl_stmt|;
name|uint64_t
name|blocksize
init|=
name|io_opts
operator|->
name|blocksize
decl_stmt|;
name|dev
operator|=
name|camdd_alloc_dev
argument_list|(
name|CAMDD_DEV_FILE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
name|file_dev
operator|=
operator|&
name|dev
operator|->
name|dev_spec
operator|.
name|file
expr_stmt|;
name|file_dev
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|strlcpy
argument_list|(
name|file_dev
operator|->
name|filename
argument_list|,
name|io_opts
operator|->
name|dev_name
argument_list|,
sizeof|sizeof
argument_list|(
name|file_dev
operator|->
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|dev
operator|->
name|device_name
argument_list|,
name|io_opts
operator|->
name|dev_name
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|device_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocksize
operator|==
literal|0
condition|)
name|dev
operator|->
name|blocksize
operator|=
name|CAMDD_FILE_DEFAULT_BLOCK
expr_stmt|;
else|else
name|dev
operator|->
name|blocksize
operator|=
name|blocksize
expr_stmt|;
if|if
condition|(
operator|(
name|io_opts
operator|->
name|queue_depth
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|io_opts
operator|->
name|queue_depth
operator|!=
literal|1
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Queue depth %ju for %s ignored, only 1 outstanding "
literal|"command supported"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|io_opts
operator|->
name|queue_depth
argument_list|,
name|io_opts
operator|->
name|dev_name
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|target_queue_depth
operator|=
name|CAMDD_FILE_DEFAULT_DEPTH
expr_stmt|;
name|dev
operator|->
name|run
operator|=
name|camdd_file_run
expr_stmt|;
name|dev
operator|->
name|fetch
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We can effectively access files on byte boundaries.  We'll reset 	 * this for devices like disks that can be accessed on sector 	 * boundaries. 	 */
name|dev
operator|->
name|sector_size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|!=
name|STDIN_FILENO
operator|)
operator|&&
operator|(
name|fd
operator|!=
name|STDOUT_FILENO
operator|)
condition|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|file_dev
operator|->
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Cannot stat %s"
argument_list|,
name|dev
operator|->
name|device_name
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
if|if
condition|(
name|S_ISREG
argument_list|(
name|file_dev
operator|->
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|file_dev
operator|->
name|file_type
operator|=
name|CAMDD_FILE_REG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISCHR
argument_list|(
name|file_dev
operator|->
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|int
name|type
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIODTYPE
argument_list|,
operator|&
name|type
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"FIODTYPE ioctl failed on %s"
argument_list|,
name|dev
operator|->
name|device_name
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|type
operator|&
name|D_TAPE
condition|)
name|file_dev
operator|->
name|file_type
operator|=
name|CAMDD_FILE_TAPE
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|&
name|D_DISK
condition|)
name|file_dev
operator|->
name|file_type
operator|=
name|CAMDD_FILE_DISK
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|&
name|D_MEM
condition|)
name|file_dev
operator|->
name|file_type
operator|=
name|CAMDD_FILE_MEM
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|&
name|D_TTY
condition|)
name|file_dev
operator|->
name|file_type
operator|=
name|CAMDD_FILE_TTY
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|S_ISDIR
argument_list|(
name|file_dev
operator|->
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"cannot operate on directory %s"
argument_list|,
name|dev
operator|->
name|device_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|file_dev
operator|->
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|file_dev
operator|->
name|file_type
operator|=
name|CAMDD_FILE_PIPE
expr_stmt|;
block|}
else|else
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Cannot determine file type for %s"
argument_list|,
name|dev
operator|->
name|device_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|file_dev
operator|->
name|file_type
condition|)
block|{
case|case
name|CAMDD_FILE_REG
case|:
if|if
condition|(
name|file_dev
operator|->
name|sb
operator|.
name|st_size
operator|!=
literal|0
condition|)
name|dev
operator|->
name|max_sector
operator|=
name|file_dev
operator|->
name|sb
operator|.
name|st_size
operator|-
literal|1
expr_stmt|;
else|else
name|dev
operator|->
name|max_sector
operator|=
literal|0
expr_stmt|;
name|file_dev
operator|->
name|file_flags
operator||=
name|CAMDD_FF_CAN_SEEK
expr_stmt|;
break|break;
case|case
name|CAMDD_FILE_TAPE
case|:
block|{
name|uint64_t
name|max_iosize
decl_stmt|,
name|max_blk
decl_stmt|,
name|min_blk
decl_stmt|,
name|blk_gran
decl_stmt|;
comment|/* 			 * Check block limits and maximum effective iosize. 			 * Make sure the blocksize is within the block 			 * limits (and a multiple of the minimum blocksize) 			 * and that the blocksize is<= maximum effective 			 * iosize. 			 */
name|retval
operator|=
name|camdd_probe_tape
argument_list|(
name|fd
argument_list|,
name|dev
operator|->
name|device_name
argument_list|,
operator|&
name|max_iosize
argument_list|,
operator|&
name|max_blk
argument_list|,
operator|&
name|min_blk
argument_list|,
operator|&
name|blk_gran
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unable to probe tape %s"
argument_list|,
name|dev
operator|->
name|device_name
argument_list|)
expr_stmt|;
comment|/* 			 * The blocksize needs to be<= the maximum 			 * effective I/O size of the tape device.  Note 			 * that this also takes into account the maximum 			 * blocksize reported by READ BLOCK LIMITS. 			 */
if|if
condition|(
name|dev
operator|->
name|blocksize
operator|>
name|max_iosize
condition|)
block|{
name|warnx
argument_list|(
literal|"Blocksize %u too big for %s, limiting "
literal|"to %ju"
argument_list|,
name|dev
operator|->
name|blocksize
argument_list|,
name|dev
operator|->
name|device_name
argument_list|,
name|max_iosize
argument_list|)
expr_stmt|;
name|dev
operator|->
name|blocksize
operator|=
name|max_iosize
expr_stmt|;
block|}
comment|/* 			 * The blocksize needs to be at least min_blk; 			 */
if|if
condition|(
name|dev
operator|->
name|blocksize
operator|<
name|min_blk
condition|)
block|{
name|warnx
argument_list|(
literal|"Blocksize %u too small for %s, "
literal|"increasing to %ju"
argument_list|,
name|dev
operator|->
name|blocksize
argument_list|,
name|dev
operator|->
name|device_name
argument_list|,
name|min_blk
argument_list|)
expr_stmt|;
name|dev
operator|->
name|blocksize
operator|=
name|min_blk
expr_stmt|;
block|}
comment|/* 			 * And the blocksize needs to be a multiple of 			 * the block granularity. 			 */
if|if
condition|(
operator|(
name|blk_gran
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|blocksize
operator|%
operator|(
literal|1
operator|<<
name|blk_gran
operator|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Blocksize %u for %s not a multiple of "
literal|"%d, adjusting to %d"
argument_list|,
name|dev
operator|->
name|blocksize
argument_list|,
name|dev
operator|->
name|device_name
argument_list|,
operator|(
literal|1
operator|<<
name|blk_gran
operator|)
argument_list|,
name|dev
operator|->
name|blocksize
operator|&
operator|~
operator|(
operator|(
literal|1
operator|<<
name|blk_gran
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|blocksize
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
name|blk_gran
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|blocksize
operator|==
literal|0
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unable to derive valid blocksize for "
literal|"%s"
argument_list|,
name|dev
operator|->
name|device_name
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * For tape drives, set the sector size to the 			 * blocksize so that we make sure not to write 			 * less than the blocksize out to the drive. 			 */
name|dev
operator|->
name|sector_size
operator|=
name|dev
operator|->
name|blocksize
expr_stmt|;
break|break;
block|}
case|case
name|CAMDD_FILE_DISK
case|:
block|{
name|off_t
name|media_size
decl_stmt|;
name|unsigned
name|int
name|sector_size
decl_stmt|;
name|file_dev
operator|->
name|file_flags
operator||=
name|CAMDD_FF_CAN_SEEK
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|DIOCGSECTORSIZE
argument_list|,
operator|&
name|sector_size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGSECTORSIZE ioctl failed on %s"
argument_list|,
name|dev
operator|->
name|device_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sector_size
operator|==
literal|0
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"DIOCGSECTORSIZE ioctl returned "
literal|"invalid sector size %u for %s"
argument_list|,
name|sector_size
argument_list|,
name|dev
operator|->
name|device_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|DIOCGMEDIASIZE
argument_list|,
operator|&
name|media_size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"DIOCGMEDIASIZE ioctl failed on %s"
argument_list|,
name|dev
operator|->
name|device_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|media_size
operator|==
literal|0
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"DIOCGMEDIASIZE ioctl returned "
literal|"invalid media size %ju for %s"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|media_size
argument_list|,
name|dev
operator|->
name|device_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|blocksize
operator|%
name|sector_size
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s blocksize %u not a multiple of "
literal|"sector size %u"
argument_list|,
name|dev
operator|->
name|device_name
argument_list|,
name|dev
operator|->
name|blocksize
argument_list|,
name|sector_size
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|sector_size
operator|=
name|sector_size
expr_stmt|;
name|dev
operator|->
name|max_sector
operator|=
operator|(
name|media_size
operator|/
name|sector_size
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
case|case
name|CAMDD_FILE_MEM
case|:
name|file_dev
operator|->
name|file_flags
operator||=
name|CAMDD_FF_CAN_SEEK
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|io_opts
operator|->
name|offset
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|file_dev
operator|->
name|file_flags
operator|&
name|CAMDD_FF_CAN_SEEK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Offset %ju specified for %s, but we cannot seek on %s"
argument_list|,
name|io_opts
operator|->
name|offset
argument_list|,
name|io_opts
operator|->
name|dev_name
argument_list|,
name|io_opts
operator|->
name|dev_name
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
if|#
directive|if
literal|0
block|else if ((io_opts->offset != 0)&& ((io_opts->offset % dev->sector_size) != 0)) { 		warnx("Offset %ju for %s is not a multiple of the " 		      "sector size %u", io_opts->offset,  		      io_opts->dev_name, dev->sector_size); 		goto bailout_error; 	} else { 		dev->start_offset_bytes = io_opts->offset; 	}
endif|#
directive|endif
name|bailout
label|:
return|return
operator|(
name|dev
operator|)
return|;
name|bailout_error
label|:
name|camdd_free_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Need to implement this.  Do a basic probe:  * - Check the inquiry data, make sure we're talking to a device that we  *   can reasonably expect to talk to -- direct, RBC, CD, WORM.  * - Send a test unit ready, make sure the device is available.  * - Get the capacity and block size.  */
end_comment

begin_function
name|struct
name|camdd_dev
modifier|*
name|camdd_probe_pass
parameter_list|(
name|struct
name|cam_device
modifier|*
name|cam_dev
parameter_list|,
name|struct
name|camdd_io_opts
modifier|*
name|io_opts
parameter_list|,
name|camdd_argmask
name|arglist
parameter_list|,
name|int
name|probe_retry_count
parameter_list|,
name|int
name|probe_timeout
parameter_list|,
name|int
name|io_retry_count
parameter_list|,
name|int
name|io_timeout
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|uint64_t
name|maxsector
decl_stmt|;
name|uint32_t
name|cpi_maxio
decl_stmt|,
name|max_iosize
decl_stmt|,
name|pass_numblocks
decl_stmt|;
name|uint32_t
name|block_len
decl_stmt|;
name|struct
name|scsi_read_capacity_data
name|rcap
decl_stmt|;
name|struct
name|scsi_read_capacity_data_long
name|rcaplong
decl_stmt|;
name|struct
name|camdd_dev
modifier|*
name|dev
decl_stmt|;
name|struct
name|camdd_dev_pass
modifier|*
name|pass_dev
decl_stmt|;
name|struct
name|kevent
name|ke
decl_stmt|;
name|int
name|scsi_dev_type
decl_stmt|;
name|dev
operator|=
name|NULL
expr_stmt|;
name|scsi_dev_type
operator|=
name|SID_TYPE
argument_list|(
operator|&
name|cam_dev
operator|->
name|inq_data
argument_list|)
expr_stmt|;
name|maxsector
operator|=
literal|0
expr_stmt|;
name|block_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * For devices that support READ CAPACITY, we'll attempt to get the 	 * capacity.  Otherwise, we really don't support tape or other 	 * devices via SCSI passthrough, so just return an error in that case. 	 */
switch|switch
condition|(
name|scsi_dev_type
condition|)
block|{
case|case
name|T_DIRECT
case|:
case|case
name|T_WORM
case|:
case|case
name|T_CDROM
case|:
case|case
name|T_OPTICAL
case|:
case|case
name|T_RBC
case|:
case|case
name|T_ZBC_HM
case|:
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Unsupported SCSI device type %d"
argument_list|,
name|scsi_dev_type
argument_list|)
expr_stmt|;
break|break;
comment|/*NOTREACHED*/
block|}
name|ccb
operator|=
name|cam_getccb
argument_list|(
name|cam_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s: error allocating ccb"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|CCB_CLEAR_ALL_EXCEPT_HDR
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
name|scsi_read_capacity
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|probe_retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
operator|&
name|rcap
argument_list|,
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|probe_timeout
condition|?
name|probe_timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAMDD_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending READ CAPACITY command"
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_error_print
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|maxsector
operator|=
name|scsi_4btoul
argument_list|(
name|rcap
operator|.
name|addr
argument_list|)
expr_stmt|;
name|block_len
operator|=
name|scsi_4btoul
argument_list|(
name|rcap
operator|.
name|length
argument_list|)
expr_stmt|;
comment|/* 	 * A last block of 2^32-1 means that the true capacity is over 2TB, 	 * and we need to issue the long READ CAPACITY to get the real 	 * capacity.  Otherwise, we're all set. 	 */
if|if
condition|(
name|maxsector
operator|!=
literal|0xffffffff
condition|)
goto|goto
name|rcap_done
goto|;
name|scsi_read_capacity_16
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|probe_retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*lba*/
literal|0
argument_list|,
comment|/*reladdr*/
literal|0
argument_list|,
comment|/*pmi*/
literal|0
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|rcaplong
argument_list|,
sizeof|sizeof
argument_list|(
name|rcaplong
argument_list|)
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|probe_timeout
condition|?
name|probe_timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|arglist
operator|&
name|CAMDD_ARG_ERR_RECOVER
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending READ CAPACITY (16) command"
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
operator|(
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
operator|)
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_error_print
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|maxsector
operator|=
name|scsi_8btou64
argument_list|(
name|rcaplong
operator|.
name|addr
argument_list|)
expr_stmt|;
name|block_len
operator|=
name|scsi_4btoul
argument_list|(
name|rcaplong
operator|.
name|length
argument_list|)
expr_stmt|;
name|rcap_done
label|:
if|if
condition|(
name|block_len
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Sector size for %s%u is 0, cannot continue"
argument_list|,
name|cam_dev
operator|->
name|device_name
argument_list|,
name|cam_dev
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|CCB_CLEAR_ALL_EXCEPT_HDR
argument_list|(
operator|&
name|ccb
operator|->
name|cpi
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator|=
name|CAM_DIR_NONE
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|retry_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cam_send_ccb
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"error sending XPT_PATH_INQ CCB"
argument_list|)
expr_stmt|;
name|cam_error_print
argument_list|(
name|cam_dev
argument_list|,
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|EV_SET
argument_list|(
operator|&
name|ke
argument_list|,
name|cam_dev
operator|->
name|fd
argument_list|,
name|EVFILT_READ
argument_list|,
name|EV_ADD
operator||
name|EV_ENABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dev
operator|=
name|camdd_alloc_dev
argument_list|(
name|CAMDD_DEV_PASS
argument_list|,
operator|&
name|ke
argument_list|,
literal|1
argument_list|,
name|io_retry_count
argument_list|,
name|io_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
name|pass_dev
operator|=
operator|&
name|dev
operator|->
name|dev_spec
operator|.
name|pass
expr_stmt|;
name|pass_dev
operator|->
name|scsi_dev_type
operator|=
name|scsi_dev_type
expr_stmt|;
name|pass_dev
operator|->
name|dev
operator|=
name|cam_dev
expr_stmt|;
name|pass_dev
operator|->
name|max_sector
operator|=
name|maxsector
expr_stmt|;
name|pass_dev
operator|->
name|block_len
operator|=
name|block_len
expr_stmt|;
name|pass_dev
operator|->
name|cpi_maxio
operator|=
name|ccb
operator|->
name|cpi
operator|.
name|maxio
expr_stmt|;
name|snprintf
argument_list|(
name|dev
operator|->
name|device_name
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|device_name
argument_list|)
argument_list|,
literal|"%s%u"
argument_list|,
name|pass_dev
operator|->
name|dev
operator|->
name|device_name
argument_list|,
name|pass_dev
operator|->
name|dev
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|dev
operator|->
name|sector_size
operator|=
name|block_len
expr_stmt|;
name|dev
operator|->
name|max_sector
operator|=
name|maxsector
expr_stmt|;
comment|/* 	 * Determine the optimal blocksize to use for this device. 	 */
comment|/* 	 * If the controller has not specified a maximum I/O size, 	 * just go with 128K as a somewhat conservative value. 	 */
if|if
condition|(
name|pass_dev
operator|->
name|cpi_maxio
operator|==
literal|0
condition|)
name|cpi_maxio
operator|=
literal|131072
expr_stmt|;
else|else
name|cpi_maxio
operator|=
name|pass_dev
operator|->
name|cpi_maxio
expr_stmt|;
comment|/* 	 * If the controller has a large maximum I/O size, limit it 	 * to something smaller so that the kernel doesn't have trouble 	 * allocating buffers to copy data in and out for us. 	 * XXX KDM this is until we have unmapped I/O support in the kernel. 	 */
name|max_iosize
operator|=
name|min
argument_list|(
name|cpi_maxio
argument_list|,
name|CAMDD_PASS_MAX_BLOCK
argument_list|)
expr_stmt|;
comment|/* 	 * If we weren't able to get a block size for some reason, 	 * default to 512 bytes. 	 */
name|block_len
operator|=
name|pass_dev
operator|->
name|block_len
expr_stmt|;
if|if
condition|(
name|block_len
operator|==
literal|0
condition|)
name|block_len
operator|=
literal|512
expr_stmt|;
comment|/* 	 * Figure out how many blocksize chunks will fit in the 	 * maximum I/O size. 	 */
name|pass_numblocks
operator|=
name|max_iosize
operator|/
name|block_len
expr_stmt|;
comment|/* 	 * And finally, multiple the number of blocks by the LBA 	 * length to get our maximum block size; 	 */
name|dev
operator|->
name|blocksize
operator|=
name|pass_numblocks
operator|*
name|block_len
expr_stmt|;
if|if
condition|(
name|io_opts
operator|->
name|blocksize
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|io_opts
operator|->
name|blocksize
operator|%
name|dev
operator|->
name|sector_size
operator|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"Blocksize %ju for %s is not a multiple of "
literal|"sector size %u"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|io_opts
operator|->
name|blocksize
argument_list|,
name|dev
operator|->
name|device_name
argument_list|,
name|dev
operator|->
name|sector_size
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
name|dev
operator|->
name|blocksize
operator|=
name|io_opts
operator|->
name|blocksize
expr_stmt|;
block|}
name|dev
operator|->
name|target_queue_depth
operator|=
name|CAMDD_PASS_DEFAULT_DEPTH
expr_stmt|;
if|if
condition|(
name|io_opts
operator|->
name|queue_depth
operator|!=
literal|0
condition|)
name|dev
operator|->
name|target_queue_depth
operator|=
name|io_opts
operator|->
name|queue_depth
expr_stmt|;
if|if
condition|(
name|io_opts
operator|->
name|offset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|io_opts
operator|->
name|offset
operator|>
operator|(
name|dev
operator|->
name|max_sector
operator|*
name|dev
operator|->
name|sector_size
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Offset %ju is past the end of device %s"
argument_list|,
name|io_opts
operator|->
name|offset
argument_list|,
name|dev
operator|->
name|device_name
argument_list|)
expr_stmt|;
goto|goto
name|bailout_error
goto|;
block|}
if|#
directive|if
literal|0
block|else if ((io_opts->offset % dev->sector_size) != 0) { 			warnx("Offset %ju for %s is not a multiple of the " 			      "sector size %u", io_opts->offset,  			      dev->device_name, dev->sector_size); 			goto bailout_error; 		} 		dev->start_offset_bytes = io_opts->offset;
endif|#
directive|endif
block|}
name|dev
operator|->
name|min_cmd_size
operator|=
name|io_opts
operator|->
name|min_cmd_size
expr_stmt|;
name|dev
operator|->
name|run
operator|=
name|camdd_pass_run
expr_stmt|;
name|dev
operator|->
name|fetch
operator|=
name|camdd_pass_fetch
expr_stmt|;
name|bailout
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
return|return
operator|(
name|dev
operator|)
return|;
name|bailout_error
label|:
name|cam_freeccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|camdd_free_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|camdd_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|camdd_dev
modifier|*
name|dev
init|=
name|arg
decl_stmt|;
name|struct
name|camdd_buf
modifier|*
name|buf
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|kq_ts
decl_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|CAMDD_DEV_FLAG_ACTIVE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|kevent
name|ke
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* 		 * XXX KDM check the reorder queue depth? 		 */
if|if
condition|(
name|dev
operator|->
name|write_dev
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|our_depth
decl_stmt|,
name|peer_depth
decl_stmt|,
name|peer_bytes
decl_stmt|,
name|our_bytes
decl_stmt|;
name|uint32_t
name|target_depth
init|=
name|dev
operator|->
name|target_queue_depth
decl_stmt|;
name|uint32_t
name|peer_target_depth
init|=
name|dev
operator|->
name|peer_dev
operator|->
name|target_queue_depth
decl_stmt|;
name|uint32_t
name|peer_blocksize
init|=
name|dev
operator|->
name|peer_dev
operator|->
name|blocksize
decl_stmt|;
name|camdd_get_depth
argument_list|(
name|dev
argument_list|,
operator|&
name|our_depth
argument_list|,
operator|&
name|peer_depth
argument_list|,
operator|&
name|our_bytes
argument_list|,
operator|&
name|peer_bytes
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|while (((our_depth< target_depth)&& (peer_depth< peer_target_depth)) 			    || ((peer_bytes + our_bytes)< 				 (peer_blocksize * 2))) {
endif|#
directive|endif
while|while
condition|(
operator|(
operator|(
name|our_depth
operator|+
name|peer_depth
operator|)
operator|<
operator|(
name|target_depth
operator|+
name|peer_target_depth
operator|)
operator|)
operator|||
operator|(
operator|(
name|peer_bytes
operator|+
name|our_bytes
operator|)
operator|<
operator|(
name|peer_blocksize
operator|*
literal|3
operator|)
operator|)
condition|)
block|{
name|retval
operator|=
name|camdd_queue
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|1
condition|)
break|break;
elseif|else
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|error_exit
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|camdd_get_depth
argument_list|(
name|dev
argument_list|,
operator|&
name|our_depth
argument_list|,
operator|&
name|peer_depth
argument_list|,
operator|&
name|our_bytes
argument_list|,
operator|&
name|peer_bytes
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * See if we have any I/O that is ready to execute. 		 */
name|buf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|dev
operator|->
name|target_queue_depth
operator|>
name|dev
operator|->
name|cur_active_io
condition|)
block|{
name|retval
operator|=
name|dev
operator|->
name|run
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|dev
operator|->
name|flags
operator||=
name|CAMDD_DEV_FLAG_EOF
expr_stmt|;
name|error_exit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/* 		 * We've reached EOF, or our partner has reached EOF. 		 */
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAMDD_DEV_FLAG_EOF
operator|)
operator|||
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAMDD_DEV_FLAG_PEER_EOF
operator|)
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|write_dev
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|dev
operator|->
name|work_queue
argument_list|)
operator|)
operator|&&
operator|(
name|dev
operator|->
name|num_run_queue
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|cur_active_io
operator|==
literal|0
operator|)
condition|)
block|{
goto|goto
name|bailout
goto|;
block|}
block|}
else|else
block|{
comment|/* 				 * If we're the reader, and the writer 				 * got EOF, he is already done.  If we got 				 * the EOF, then we need to wait until 				 * everything is flushed out for the writer. 				 */
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|CAMDD_DEV_FLAG_PEER_EOF
condition|)
block|{
goto|goto
name|bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dev
operator|->
name|num_peer_work_queue
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|num_peer_done_queue
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|cur_active_io
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|num_run_queue
operator|==
literal|0
operator|)
condition|)
block|{
goto|goto
name|bailout
goto|;
block|}
block|}
comment|/* 			 * XXX KDM need to do something about the pending 			 * queue and cleanup resources. 			 */
block|}
if|if
condition|(
operator|(
name|dev
operator|->
name|write_dev
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|cur_active_io
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|peer_bytes_queued
operator|<
name|dev
operator|->
name|peer_dev
operator|->
name|blocksize
operator|)
condition|)
name|kq_ts
operator|=
operator|&
name|ts
expr_stmt|;
else|else
name|kq_ts
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Run kevent to see if there are events to process. 		 */
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|retval
operator|=
name|kevent
argument_list|(
name|dev
operator|->
name|kq
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|ke
argument_list|,
literal|1
argument_list|,
name|kq_ts
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"%s: error returned from kevent"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
elseif|else
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|ke
operator|.
name|filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
if|if
condition|(
name|dev
operator|->
name|fetch
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|dev
operator|->
name|fetch
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|error_exit
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
break|break;
case|case
name|EVFILT_SIGNAL
case|:
comment|/* 				 * We register for this so we don't get 				 * an error as a result of a SIGINFO or a 				 * SIGINT.  It will actually get handled 				 * by the signal handler.  If we get a 				 * SIGINT, bail out without printing an 				 * error message.  Any other signals  				 * will result in the error message above. 				 */
if|if
condition|(
name|ke
operator|.
name|ident
operator|==
name|SIGINT
condition|)
goto|goto
name|bailout
goto|;
break|break;
case|case
name|EVFILT_USER
case|:
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Check to see if the other thread has 				 * queued any I/O for us to do.  (In this 				 * case we're the writer.) 				 */
for|for
control|(
name|buf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|work_queue
argument_list|)
init|;
name|buf
operator|!=
name|NULL
condition|;
name|buf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|work_queue
argument_list|)
control|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|work_queue
argument_list|,
name|work_links
argument_list|)
expr_stmt|;
name|retval
operator|=
name|camdd_queue
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* 					 * We keep going unless we get an 					 * actual error.  If we get EOF, we 					 * still want to remove the buffers 					 * from the queue and send the back 					 * to the reader thread. 					 */
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|error_exit
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
else|else
name|retval
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 				 * Next check to see if the other thread has 				 * queued any completed buffers back to us. 				 * (In this case we're the reader.) 				 */
for|for
control|(
name|buf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|peer_done_queue
argument_list|)
init|;
name|buf
operator|!=
name|NULL
condition|;
name|buf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|peer_done_queue
argument_list|)
control|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|peer_done_queue
argument_list|,
name|work_links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_peer_done_queue
operator|--
expr_stmt|;
name|camdd_peer_done
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|warnx
argument_list|(
literal|"%s: unknown kevent filter %d"
argument_list|,
name|__func__
argument_list|,
name|ke
operator|.
name|filter
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|bailout
label|:
name|dev
operator|->
name|flags
operator|&=
operator|~
name|CAMDD_DEV_FLAG_ACTIVE
expr_stmt|;
comment|/* XXX KDM cleanup resources here? */
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|need_exit
operator|=
literal|1
expr_stmt|;
name|sem_post
argument_list|(
operator|&
name|camdd_sem
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simplistic translation of CCB status to our local status.  */
end_comment

begin_function
name|camdd_buf_status
name|camdd_ccb_status
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
name|camdd_buf_status
name|status
init|=
name|CAMDD_STATUS_NONE
decl_stmt|;
name|cam_status
name|ccb_status
decl_stmt|;
name|ccb_status
operator|=
name|ccb
operator|->
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
switch|switch
condition|(
name|ccb_status
condition|)
block|{
case|case
name|CAM_REQ_CMP
case|:
block|{
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|resid
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|CAMDD_STATUS_OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccb
operator|->
name|csio
operator|.
name|dxfer_len
operator|>
name|ccb
operator|->
name|csio
operator|.
name|resid
condition|)
block|{
name|status
operator|=
name|CAMDD_STATUS_SHORT_IO
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|CAMDD_STATUS_EOF
expr_stmt|;
block|}
break|break;
block|}
case|case
name|CAM_SCSI_STATUS_ERROR
case|:
block|{
switch|switch
condition|(
name|ccb
operator|->
name|csio
operator|.
name|scsi_status
condition|)
block|{
case|case
name|SCSI_STATUS_OK
case|:
case|case
name|SCSI_STATUS_COND_MET
case|:
case|case
name|SCSI_STATUS_INTERMED
case|:
case|case
name|SCSI_STATUS_INTERMED_COND_MET
case|:
name|status
operator|=
name|CAMDD_STATUS_OK
expr_stmt|;
break|break;
case|case
name|SCSI_STATUS_CMD_TERMINATED
case|:
case|case
name|SCSI_STATUS_CHECK_COND
case|:
case|case
name|SCSI_STATUS_QUEUE_FULL
case|:
case|case
name|SCSI_STATUS_BUSY
case|:
case|case
name|SCSI_STATUS_RESERV_CONFLICT
case|:
default|default:
name|status
operator|=
name|CAMDD_STATUS_ERROR
expr_stmt|;
break|break;
block|}
break|break;
block|}
default|default:
name|status
operator|=
name|CAMDD_STATUS_ERROR
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a buffer to our peer's work thread for writing.  *  * Returns 0 for success, -1 for failure, 1 if the other thread exited.  */
end_comment

begin_function
name|int
name|camdd_queue_peer_buf
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|kevent
name|ke
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|camdd_buf
argument_list|)
name|local_queue
expr_stmt|;
name|struct
name|camdd_buf
modifier|*
name|buf1
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
name|struct
name|camdd_buf_data
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|peer_bytes_queued
init|=
literal|0
decl_stmt|;
name|int
name|active
init|=
literal|1
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|local_queue
argument_list|)
expr_stmt|;
comment|/* 	 * Since we're the reader, we need to queue our I/O to the writer 	 * in sequential order in order to make sure it gets written out 	 * in sequential order. 	 * 	 * Check the next expected I/O starting offset.  If this doesn't 	 * match, put it on the reorder queue. 	 */
if|if
condition|(
operator|(
name|buf
operator|->
name|lba
operator|*
name|dev
operator|->
name|sector_size
operator|)
operator|!=
name|dev
operator|->
name|next_completion_pos_bytes
condition|)
block|{
comment|/* 		 * If there is nothing on the queue, there is no sorting 		 * needed. 		 */
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
name|dev
operator|->
name|reorder_queue
argument_list|)
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|reorder_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_reorder_queue
operator|++
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 		 * Sort in ascending order by starting LBA.  There should 		 * be no identical LBAs. 		 */
for|for
control|(
name|buf1
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|reorder_queue
argument_list|)
init|;
name|buf1
operator|!=
name|NULL
condition|;
name|buf1
operator|=
name|buf2
control|)
block|{
name|buf2
operator|=
name|STAILQ_NEXT
argument_list|(
name|buf1
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|lba
operator|<
name|buf1
operator|->
name|lba
condition|)
block|{
comment|/* 				 * If we're less than the first one, then 				 * we insert at the head of the list 				 * because this has to be the first element 				 * on the list. 				 */
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|reorder_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_reorder_queue
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|lba
operator|>
name|buf1
operator|->
name|lba
condition|)
block|{
if|if
condition|(
name|buf2
operator|==
name|NULL
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|reorder_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_reorder_queue
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|buf
operator|->
name|lba
operator|<
name|buf2
operator|->
name|lba
condition|)
block|{
name|STAILQ_INSERT_AFTER
argument_list|(
operator|&
name|dev
operator|->
name|reorder_queue
argument_list|,
name|buf1
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_reorder_queue
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Found buffers with duplicate LBA %ju!"
argument_list|,
name|buf
operator|->
name|lba
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|bailout
goto|;
block|}
else|else
block|{
comment|/* 		 * We're the next expected I/O completion, so put ourselves 		 * on the local queue to be sent to the writer.  We use 		 * work_links here so that we can queue this to the  		 * peer_work_queue before taking the buffer off of the 		 * local_queue. 		 */
name|dev
operator|->
name|next_completion_pos_bytes
operator|+=
name|buf
operator|->
name|len
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|local_queue
argument_list|,
name|buf
argument_list|,
name|work_links
argument_list|)
expr_stmt|;
comment|/* 		 * Go through the reorder queue looking for more sequential 		 * I/O and add it to the local queue. 		 */
for|for
control|(
name|buf1
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|reorder_queue
argument_list|)
init|;
name|buf1
operator|!=
name|NULL
condition|;
name|buf1
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|reorder_queue
argument_list|)
control|)
block|{
comment|/* 			 * As soon as we see an I/O that is out of sequence, 			 * we're done. 			 */
if|if
condition|(
operator|(
name|buf1
operator|->
name|lba
operator|*
name|dev
operator|->
name|sector_size
operator|)
operator|!=
name|dev
operator|->
name|next_completion_pos_bytes
condition|)
break|break;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|reorder_queue
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_reorder_queue
operator|--
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|local_queue
argument_list|,
name|buf1
argument_list|,
name|work_links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|next_completion_pos_bytes
operator|+=
name|buf1
operator|->
name|len
expr_stmt|;
block|}
block|}
comment|/* 	 * Setup the event to let the other thread know that it has work 	 * pending. 	 */
name|EV_SET
argument_list|(
operator|&
name|ke
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|dev
operator|->
name|peer_dev
operator|->
name|work_queue
argument_list|,
name|EVFILT_USER
argument_list|,
literal|0
argument_list|,
name|NOTE_TRIGGER
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Put this on our shadow queue so that we know what we've queued 	 * to the other thread. 	 */
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|buf1
argument_list|,
argument|&local_queue
argument_list|,
argument|work_links
argument_list|,
argument|buf2
argument_list|)
block|{
if|if
condition|(
name|buf1
operator|->
name|buf_type
operator|!=
name|CAMDD_BUF_DATA
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: should have a data buffer, not an "
literal|"indirect buffer"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
operator|&
name|buf1
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
comment|/* 		 * We only need to send one EOF to the writer, and don't 		 * need to continue sending EOFs after that. 		 */
if|if
condition|(
name|buf1
operator|->
name|status
operator|==
name|CAMDD_STATUS_EOF
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|CAMDD_DEV_FLAG_EOF_SENT
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|local_queue
argument_list|,
name|buf1
argument_list|,
name|camdd_buf
argument_list|,
name|work_links
argument_list|)
expr_stmt|;
name|camdd_release_buf
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|dev
operator|->
name|flags
operator||=
name|CAMDD_DEV_FLAG_EOF_SENT
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|peer_work_queue
argument_list|,
name|buf1
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|peer_bytes_queued
operator|+=
operator|(
name|data
operator|->
name|fill_len
operator|-
name|data
operator|->
name|resid
operator|)
expr_stmt|;
name|dev
operator|->
name|peer_bytes_queued
operator|+=
operator|(
name|data
operator|->
name|fill_len
operator|-
name|data
operator|->
name|resid
operator|)
expr_stmt|;
name|dev
operator|->
name|num_peer_work_queue
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|local_queue
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|bailout
goto|;
comment|/* 	 * Drop our mutex and pick up the other thread's mutex.  We need to 	 * do this to avoid deadlocks. 	 */
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|peer_dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|peer_dev
operator|->
name|flags
operator|&
name|CAMDD_DEV_FLAG_ACTIVE
condition|)
block|{
comment|/* 		 * Put the buffers on the other thread's incoming work queue. 		 */
for|for
control|(
name|buf1
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|local_queue
argument_list|)
init|;
name|buf1
operator|!=
name|NULL
condition|;
name|buf1
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|local_queue
argument_list|)
control|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|local_queue
argument_list|,
name|work_links
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|peer_dev
operator|->
name|work_queue
argument_list|,
name|buf1
argument_list|,
name|work_links
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Send an event to the other thread's kqueue to let it know 		 * that there is something on the work queue. 		 */
name|retval
operator|=
name|kevent
argument_list|(
name|dev
operator|->
name|peer_dev
operator|->
name|kq
argument_list|,
operator|&
name|ke
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"%s: unable to add peer work_queue kevent"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|active
operator|=
literal|0
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|peer_dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* 	 * If the other side isn't active, run through the queue and 	 * release all of the buffers. 	 */
if|if
condition|(
name|active
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|buf1
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|local_queue
argument_list|)
init|;
name|buf1
operator|!=
name|NULL
condition|;
name|buf1
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|local_queue
argument_list|)
control|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|local_queue
argument_list|,
name|work_links
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|dev
operator|->
name|peer_work_queue
argument_list|,
name|buf1
argument_list|,
name|camdd_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_peer_work_queue
operator|--
expr_stmt|;
name|camdd_release_buf
argument_list|(
name|buf1
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|peer_bytes_queued
operator|-=
name|peer_bytes_queued
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a buffer to the reader thread when we have completed writing it.  */
end_comment

begin_function
name|int
name|camdd_complete_peer_buf
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|camdd_buf
modifier|*
name|peer_buf
parameter_list|)
block|{
name|struct
name|kevent
name|ke
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* 	 * Setup the event to let the other thread know that we have 	 * completed a buffer. 	 */
name|EV_SET
argument_list|(
operator|&
name|ke
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|dev
operator|->
name|peer_dev
operator|->
name|peer_done_queue
argument_list|,
name|EVFILT_USER
argument_list|,
literal|0
argument_list|,
name|NOTE_TRIGGER
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Drop our lock and acquire the other thread's lock before 	 * manipulating  	 */
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|peer_dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Put the buffer on the reader thread's peer done queue now that 	 * we have completed it. 	 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|peer_dev
operator|->
name|peer_done_queue
argument_list|,
name|peer_buf
argument_list|,
name|work_links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|peer_dev
operator|->
name|num_peer_done_queue
operator|++
expr_stmt|;
comment|/* 	 * Send an event to the peer thread to let it know that we've added 	 * something to its peer done queue. 	 */
name|retval
operator|=
name|kevent
argument_list|(
name|dev
operator|->
name|peer_dev
operator|->
name|kq
argument_list|,
operator|&
name|ke
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"%s: unable to add peer_done_queue kevent"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Drop the other thread's lock and reacquire ours. 	 */
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|peer_dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a buffer that was written out by the writer thread and returned to  * the reader thread.  */
end_comment

begin_function
name|void
name|camdd_peer_done
parameter_list|(
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|camdd_dev
modifier|*
name|dev
decl_stmt|;
name|struct
name|camdd_buf_data
modifier|*
name|data
decl_stmt|;
name|dev
operator|=
name|buf
operator|->
name|dev
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|buf_type
operator|!=
name|CAMDD_BUF_DATA
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: should have a data buffer, not an "
literal|"indirect buffer"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|dev
operator|->
name|peer_work_queue
argument_list|,
name|buf
argument_list|,
name|camdd_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_peer_work_queue
operator|--
expr_stmt|;
name|dev
operator|->
name|peer_bytes_queued
operator|-=
operator|(
name|data
operator|->
name|fill_len
operator|-
name|data
operator|->
name|resid
operator|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|status
operator|==
name|CAMDD_STATUS_EOF
condition|)
name|dev
operator|->
name|flags
operator||=
name|CAMDD_DEV_FLAG_PEER_EOF
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|free_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Assumes caller holds the lock for this device.  */
end_comment

begin_function
name|void
name|camdd_complete_buf
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|camdd_buf
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|error_count
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* 	 * If we're the reader, we need to send the completed I/O 	 * to the writer.  If we're the writer, we need to just 	 * free up resources, or let the reader know if we've 	 * encountered an error. 	 */
if|if
condition|(
name|dev
operator|->
name|write_dev
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|camdd_queue_peer_buf
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
operator|(
operator|*
name|error_count
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|struct
name|camdd_buf
modifier|*
name|tmp_buf
decl_stmt|,
modifier|*
name|next_buf
decl_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|tmp_buf
argument_list|,
argument|&buf->src_list
argument_list|,
argument|src_links
argument_list|,
argument|next_buf
argument_list|)
block|{
name|struct
name|camdd_buf
modifier|*
name|src_buf
decl_stmt|;
name|struct
name|camdd_buf_indirect
modifier|*
name|indirect
decl_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|buf
operator|->
name|src_list
argument_list|,
name|tmp_buf
argument_list|,
name|camdd_buf
argument_list|,
name|src_links
argument_list|)
expr_stmt|;
name|tmp_buf
operator|->
name|status
operator|=
name|buf
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|tmp_buf
operator|->
name|buf_type
operator|==
name|CAMDD_BUF_DATA
condition|)
block|{
name|camdd_complete_peer_buf
argument_list|(
name|dev
argument_list|,
name|tmp_buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|indirect
operator|=
operator|&
name|tmp_buf
operator|->
name|buf_type_spec
operator|.
name|indirect
expr_stmt|;
name|src_buf
operator|=
name|indirect
operator|->
name|src_buf
expr_stmt|;
name|src_buf
operator|->
name|refcount
operator|--
expr_stmt|;
comment|/* 			 * XXX KDM we probably need to account for 			 * exactly how many bytes we were able to 			 * write.  Allocate the residual to the 			 * first N buffers?  Or just track the 			 * number of bytes written?  Right now the reader 			 * doesn't do anything with a residual. 			 */
name|src_buf
operator|->
name|status
operator|=
name|buf
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|src_buf
operator|->
name|refcount
operator|<=
literal|0
condition|)
name|camdd_complete_peer_buf
argument_list|(
name|dev
argument_list|,
name|src_buf
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|free_indirect_queue
argument_list|,
name|tmp_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|free_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fetch all completed commands from the pass(4) device.  *  * Returns the number of commands received, or -1 if any of the commands  * completed with an error.  Returns 0 if no commands are available.  */
end_comment

begin_function
name|int
name|camdd_pass_fetch
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|camdd_dev_pass
modifier|*
name|pass_dev
init|=
operator|&
name|dev
operator|->
name|dev_spec
operator|.
name|pass
decl_stmt|;
name|union
name|ccb
name|ccb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|,
name|num_fetched
init|=
literal|0
decl_stmt|,
name|error_count
init|=
literal|0
decl_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* 	 * XXX KDM we don't distinguish between EFAULT and ENOENT. 	 */
while|while
condition|(
operator|(
name|retval
operator|=
name|ioctl
argument_list|(
name|pass_dev
operator|->
name|dev
operator|->
name|fd
argument_list|,
name|CAMIOGET
argument_list|,
operator|&
name|ccb
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|struct
name|camdd_buf
modifier|*
name|buf
decl_stmt|;
name|struct
name|camdd_buf_data
modifier|*
name|data
decl_stmt|;
name|cam_status
name|ccb_status
decl_stmt|;
name|union
name|ccb
modifier|*
name|buf_ccb
decl_stmt|;
name|buf
operator|=
name|ccb
operator|.
name|ccb_h
operator|.
name|ccb_buf
expr_stmt|;
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
name|buf_ccb
operator|=
operator|&
name|data
operator|->
name|ccb
expr_stmt|;
name|num_fetched
operator|++
expr_stmt|;
comment|/* 		 * Copy the CCB back out so we get status, sense data, etc. 		 */
name|bcopy
argument_list|(
operator|&
name|ccb
argument_list|,
name|buf_ccb
argument_list|,
sizeof|sizeof
argument_list|(
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* 		 * We're now done, so take this off the active queue. 		 */
name|STAILQ_REMOVE
argument_list|(
operator|&
name|dev
operator|->
name|active_queue
argument_list|,
name|buf
argument_list|,
name|camdd_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|cur_active_io
operator|--
expr_stmt|;
name|ccb_status
operator|=
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|&
name|CAM_STATUS_MASK
expr_stmt|;
if|if
condition|(
name|ccb_status
operator|!=
name|CAM_REQ_CMP
condition|)
block|{
name|cam_error_print
argument_list|(
name|pass_dev
operator|->
name|dev
argument_list|,
operator|&
name|ccb
argument_list|,
name|CAM_ESF_ALL
argument_list|,
name|CAM_EPF_ALL
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|resid
operator|=
name|ccb
operator|.
name|csio
operator|.
name|resid
expr_stmt|;
name|dev
operator|->
name|bytes_transferred
operator|+=
operator|(
name|ccb
operator|.
name|csio
operator|.
name|dxfer_len
operator|-
name|ccb
operator|.
name|csio
operator|.
name|resid
operator|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|status
operator|==
name|CAMDD_STATUS_NONE
condition|)
name|buf
operator|->
name|status
operator|=
name|camdd_ccb_status
argument_list|(
operator|&
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|status
operator|==
name|CAMDD_STATUS_ERROR
condition|)
name|error_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
operator|->
name|status
operator|==
name|CAMDD_STATUS_EOF
condition|)
block|{
comment|/* 			 * Once we queue this buffer to our partner thread, 			 * he will know that we've hit EOF. 			 */
name|dev
operator|->
name|flags
operator||=
name|CAMDD_DEV_FLAG_EOF
expr_stmt|;
block|}
name|camdd_complete_buf
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
operator|&
name|error_count
argument_list|)
expr_stmt|;
comment|/* 		 * Unlock in preparation for the ioctl call. 		 */
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_count
operator|>
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|num_fetched
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns -1 for error, 0 for success/continue, and 1 for resource  * shortage/stop processing.  */
end_comment

begin_function
name|int
name|camdd_file_run
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|camdd_dev_file
modifier|*
name|file_dev
init|=
operator|&
name|dev
operator|->
name|dev_spec
operator|.
name|file
decl_stmt|;
name|struct
name|camdd_buf_data
modifier|*
name|data
decl_stmt|;
name|struct
name|camdd_buf
modifier|*
name|buf
decl_stmt|;
name|off_t
name|io_offset
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|,
name|write_dev
init|=
name|dev
operator|->
name|write_dev
decl_stmt|;
name|int
name|error_count
init|=
literal|0
decl_stmt|,
name|no_resources
init|=
literal|0
decl_stmt|,
name|double_buf_needed
init|=
literal|0
decl_stmt|;
name|uint32_t
name|num_sectors
init|=
literal|0
decl_stmt|,
name|db_len
init|=
literal|0
decl_stmt|;
name|buf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|no_resources
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dev
operator|->
name|write_dev
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|flags
operator|&
operator|(
name|CAMDD_DEV_FLAG_EOF
operator||
name|CAMDD_DEV_FLAG_EOF_SENT
operator|)
operator|)
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|,
name|buf
argument_list|,
name|camdd_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_run_queue
operator|--
expr_stmt|;
name|buf
operator|->
name|status
operator|=
name|CAMDD_STATUS_EOF
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * If we're writing, we need to go through the source buffer list 	 * and create an S/G list. 	 */
if|if
condition|(
name|write_dev
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
name|camdd_buf_sg_create
argument_list|(
name|buf
argument_list|,
comment|/*iovec*/
literal|1
argument_list|,
name|dev
operator|->
name|sector_size
argument_list|,
operator|&
name|num_sectors
argument_list|,
operator|&
name|double_buf_needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|no_resources
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
name|STAILQ_REMOVE
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|,
name|buf
argument_list|,
name|camdd_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_run_queue
operator|--
expr_stmt|;
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
comment|/* 	 * pread(2) and pwrite(2) offsets are byte offsets. 	 */
name|io_offset
operator|=
name|buf
operator|->
name|lba
operator|*
name|dev
operator|->
name|sector_size
expr_stmt|;
comment|/* 	 * Unlock the mutex while we read or write. 	 */
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we don't need to double buffer if we're the reader 	 * because in that case, we have allocated a single buffer of 	 * sufficient size to do the read.  This copy is necessary on 	 * writes because if one of the components of the S/G list is not 	 * a sector size multiple, the kernel will reject the write.  This 	 * is unfortunate but not surprising.  So this will make sure that 	 * we're using a single buffer that is a multiple of the sector size. 	 */
if|if
condition|(
operator|(
name|double_buf_needed
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|data
operator|->
name|sg_count
operator|>
literal|1
operator|)
operator|&&
operator|(
name|write_dev
operator|!=
literal|0
operator|)
condition|)
block|{
name|uint32_t
name|cur_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|file_dev
operator|->
name|tmp_buf
operator|==
name|NULL
condition|)
name|file_dev
operator|->
name|tmp_buf
operator|=
name|calloc
argument_list|(
name|dev
operator|->
name|blocksize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_dev
operator|->
name|tmp_buf
operator|==
name|NULL
condition|)
block|{
name|buf
operator|->
name|status
operator|=
name|CAMDD_STATUS_ERROR
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|cur_offset
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|sg_count
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|data
operator|->
name|iovec
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
operator|&
name|file_dev
operator|->
name|tmp_buf
index|[
name|cur_offset
index|]
argument_list|,
name|data
operator|->
name|iovec
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|cur_offset
operator|+=
name|data
operator|->
name|iovec
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|db_len
operator|=
name|cur_offset
expr_stmt|;
block|}
if|if
condition|(
name|file_dev
operator|->
name|file_flags
operator|&
name|CAMDD_FF_CAN_SEEK
condition|)
block|{
if|if
condition|(
name|write_dev
operator|==
literal|0
condition|)
block|{
comment|/* 			 * XXX KDM is there any way we would need a S/G 			 * list here? 			 */
name|retval
operator|=
name|pread
argument_list|(
name|file_dev
operator|->
name|fd
argument_list|,
name|data
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|io_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|double_buf_needed
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
name|pwrite
argument_list|(
name|file_dev
operator|->
name|fd
argument_list|,
name|file_dev
operator|->
name|tmp_buf
argument_list|,
name|db_len
argument_list|,
name|io_offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|sg_count
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|pwrite
argument_list|(
name|file_dev
operator|->
name|fd
argument_list|,
name|data
operator|->
name|buf
argument_list|,
name|data
operator|->
name|fill_len
argument_list|,
name|io_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|pwritev
argument_list|(
name|file_dev
operator|->
name|fd
argument_list|,
name|data
operator|->
name|iovec
argument_list|,
name|data
operator|->
name|sg_count
argument_list|,
name|io_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|write_dev
operator|==
literal|0
condition|)
block|{
comment|/* 			 * XXX KDM is there any way we would need a S/G 			 * list here? 			 */
name|retval
operator|=
name|read
argument_list|(
name|file_dev
operator|->
name|fd
argument_list|,
name|data
operator|->
name|buf
argument_list|,
name|buf
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|double_buf_needed
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
name|write
argument_list|(
name|file_dev
operator|->
name|fd
argument_list|,
name|file_dev
operator|->
name|tmp_buf
argument_list|,
name|db_len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|sg_count
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|write
argument_list|(
name|file_dev
operator|->
name|fd
argument_list|,
name|data
operator|->
name|buf
argument_list|,
name|data
operator|->
name|fill_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|writev
argument_list|(
name|file_dev
operator|->
name|fd
argument_list|,
name|data
operator|->
name|iovec
argument_list|,
name|data
operator|->
name|sg_count
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* We're done, re-acquire the lock */
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|>=
operator|(
name|ssize_t
operator|)
name|data
operator|->
name|fill_len
condition|)
block|{
comment|/* 		 * If the bytes transferred is more than the request size, 		 * that indicates an overrun, which should only happen at 		 * the end of a transfer if we have to round up to a sector 		 * boundary. 		 */
if|if
condition|(
name|buf
operator|->
name|status
operator|==
name|CAMDD_STATUS_NONE
condition|)
name|buf
operator|->
name|status
operator|=
name|CAMDD_STATUS_OK
expr_stmt|;
name|data
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|bytes_transferred
operator|+=
name|retval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"Error %s %s"
argument_list|,
operator|(
name|write_dev
operator|)
condition|?
literal|"writing to"
else|:
literal|"reading from"
argument_list|,
name|file_dev
operator|->
name|filename
argument_list|)
expr_stmt|;
name|buf
operator|->
name|status
operator|=
name|CAMDD_STATUS_ERROR
expr_stmt|;
name|data
operator|->
name|resid
operator|=
name|data
operator|->
name|fill_len
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|debug
operator|==
literal|0
condition|)
goto|goto
name|bailout
goto|;
if|if
condition|(
operator|(
name|double_buf_needed
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|write_dev
operator|!=
literal|0
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: fd %d, DB buf %p, len %u lba %ju "
literal|"offset %ju\n"
argument_list|,
name|__func__
argument_list|,
name|file_dev
operator|->
name|fd
argument_list|,
name|file_dev
operator|->
name|tmp_buf
argument_list|,
name|db_len
argument_list|,
operator|(
name|uintmax_t
operator|)
name|buf
operator|->
name|lba
argument_list|,
operator|(
name|uintmax_t
operator|)
name|io_offset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|->
name|sg_count
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: fd %d, buf %p, len %u, lba %ju "
literal|"offset %ju\n"
argument_list|,
name|__func__
argument_list|,
name|file_dev
operator|->
name|fd
argument_list|,
name|data
operator|->
name|buf
argument_list|,
name|data
operator|->
name|fill_len
argument_list|,
operator|(
name|uintmax_t
operator|)
name|buf
operator|->
name|lba
argument_list|,
operator|(
name|uintmax_t
operator|)
name|io_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: fd %d, len %u, lba %ju "
literal|"offset %ju\n"
argument_list|,
name|__func__
argument_list|,
name|file_dev
operator|->
name|fd
argument_list|,
name|data
operator|->
name|fill_len
argument_list|,
operator|(
name|uintmax_t
operator|)
name|buf
operator|->
name|lba
argument_list|,
operator|(
name|uintmax_t
operator|)
name|io_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|data
operator|->
name|sg_count
condition|;
name|i
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"index %d ptr %p len %zu\n"
argument_list|,
name|i
argument_list|,
name|data
operator|->
name|iovec
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
name|data
operator|->
name|iovec
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
name|buf
operator|->
name|status
operator|=
name|CAMDD_STATUS_EOF
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|debug
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: got EOF from %s!\n"
argument_list|,
name|__func__
argument_list|,
name|file_dev
operator|->
name|filename
argument_list|)
expr_stmt|;
name|data
operator|->
name|resid
operator|=
name|data
operator|->
name|fill_len
expr_stmt|;
name|error_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retval
operator|<
operator|(
name|ssize_t
operator|)
name|data
operator|->
name|fill_len
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|status
operator|==
name|CAMDD_STATUS_NONE
condition|)
name|buf
operator|->
name|status
operator|=
name|CAMDD_STATUS_SHORT_IO
expr_stmt|;
name|data
operator|->
name|resid
operator|=
name|data
operator|->
name|fill_len
operator|-
name|retval
expr_stmt|;
name|dev
operator|->
name|bytes_transferred
operator|+=
name|retval
expr_stmt|;
block|}
name|bailout
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
operator|->
name|status
operator|==
name|CAMDD_STATUS_EOF
condition|)
block|{
name|struct
name|camdd_buf
modifier|*
name|buf2
decl_stmt|;
name|dev
operator|->
name|flags
operator||=
name|CAMDD_DEV_FLAG_EOF
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|buf2
argument_list|,
argument|&dev->run_queue
argument_list|,
argument|links
argument_list|)
name|buf2
operator|->
name|status
operator|=
name|CAMDD_STATUS_EOF
expr_stmt|;
block|}
name|camdd_complete_buf
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
operator|&
name|error_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error_count
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|no_resources
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Execute one command from the run queue.  Returns 0 for success, 1 for  * stop processing, and -1 for error.  */
end_comment

begin_function
name|int
name|camdd_pass_run
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|camdd_buf
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|struct
name|camdd_dev_pass
modifier|*
name|pass_dev
init|=
operator|&
name|dev
operator|->
name|dev_spec
operator|.
name|pass
decl_stmt|;
name|struct
name|camdd_buf_data
modifier|*
name|data
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|,
name|sectors_used
init|=
literal|0
decl_stmt|;
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|,
name|is_write
init|=
name|dev
operator|->
name|write_dev
decl_stmt|;
name|int
name|double_buf_needed
init|=
literal|0
decl_stmt|;
name|buf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * If we're writing, we need to go through the source buffer list 	 * and create an S/G list. 	 */
if|if
condition|(
name|is_write
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
name|camdd_buf_sg_create
argument_list|(
name|buf
argument_list|,
comment|/*iovec*/
literal|0
argument_list|,
name|dev
operator|->
name|sector_size
argument_list|,
operator|&
name|sectors_used
argument_list|,
operator|&
name|double_buf_needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
name|STAILQ_REMOVE
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|,
name|buf
argument_list|,
name|camdd_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_run_queue
operator|--
expr_stmt|;
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
name|ccb
operator|=
operator|&
name|data
operator|->
name|ccb
expr_stmt|;
name|CCB_CLEAR_ALL_EXCEPT_HDR
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|)
expr_stmt|;
comment|/* 	 * In almost every case the number of blocks should be the device 	 * block size.  The exception may be at the end of an I/O stream 	 * for a partial block or at the end of a device. 	 */
if|if
condition|(
name|is_write
operator|!=
literal|0
condition|)
name|num_blocks
operator|=
name|sectors_used
expr_stmt|;
else|else
name|num_blocks
operator|=
name|data
operator|->
name|fill_len
operator|/
name|pass_dev
operator|->
name|block_len
expr_stmt|;
name|scsi_read_write
argument_list|(
operator|&
name|ccb
operator|->
name|csio
argument_list|,
comment|/*retries*/
name|dev
operator|->
name|retry_count
argument_list|,
comment|/*cbfcnp*/
name|NULL
argument_list|,
comment|/*tag_action*/
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/*readop*/
operator|(
name|dev
operator|->
name|write_dev
operator|==
literal|0
operator|)
condition|?
name|SCSI_RW_READ
else|:
name|SCSI_RW_WRITE
argument_list|,
comment|/*byte2*/
literal|0
argument_list|,
comment|/*minimum_cmd_size*/
name|dev
operator|->
name|min_cmd_size
argument_list|,
comment|/*lba*/
name|buf
operator|->
name|lba
argument_list|,
comment|/*block_count*/
name|num_blocks
argument_list|,
comment|/*data_ptr*/
operator|(
name|data
operator|->
name|sg_count
operator|!=
literal|0
operator|)
condition|?
operator|(
name|uint8_t
operator|*
operator|)
name|data
operator|->
name|segs
else|:
name|data
operator|->
name|buf
argument_list|,
comment|/*dxfer_len*/
operator|(
name|num_blocks
operator|*
name|pass_dev
operator|->
name|block_len
operator|)
argument_list|,
comment|/*sense_len*/
name|SSD_FULL_SIZE
argument_list|,
comment|/*timeout*/
name|dev
operator|->
name|io_timeout
argument_list|)
expr_stmt|;
comment|/* Disable freezing the device queue */
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DEV_QFRZDIS
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|retry_count
operator|!=
literal|0
condition|)
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_PASS_ERR_RECOVER
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|sg_count
operator|!=
literal|0
condition|)
block|{
name|ccb
operator|->
name|csio
operator|.
name|sglist_cnt
operator|=
name|data
operator|->
name|sg_count
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|flags
operator||=
name|CAM_DATA_SG
expr_stmt|;
block|}
comment|/* 	 * Store a pointer to the buffer in the CCB.  The kernel will 	 * restore this when we get it back, and we'll use it to identify 	 * the buffer this CCB came from. 	 */
name|ccb
operator|->
name|ccb_h
operator|.
name|ccb_buf
operator|=
name|buf
expr_stmt|;
comment|/* 	 * Unlock our mutex in preparation for issuing the ioctl. 	 */
name|pthread_mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Queue the CCB to the pass(4) driver. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|pass_dev
operator|->
name|dev
operator|->
name|fd
argument_list|,
name|CAMIOQUEUE
argument_list|,
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s: error sending CAMIOQUEUE ioctl to %s%u"
argument_list|,
name|__func__
argument_list|,
name|pass_dev
operator|->
name|dev
operator|->
name|device_name
argument_list|,
name|pass_dev
operator|->
name|dev
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s: CCB address is %p"
argument_list|,
name|__func__
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|free_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pthread_mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|dev
operator|->
name|cur_active_io
operator|++
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|active_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|camdd_get_next_lba_len
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|uint64_t
modifier|*
name|lba
parameter_list|,
name|ssize_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|camdd_dev_pass
modifier|*
name|pass_dev
decl_stmt|;
name|uint32_t
name|num_blocks
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|pass_dev
operator|=
operator|&
name|dev
operator|->
name|dev_spec
operator|.
name|pass
expr_stmt|;
operator|*
name|lba
operator|=
name|dev
operator|->
name|next_io_pos_bytes
operator|/
name|dev
operator|->
name|sector_size
expr_stmt|;
operator|*
name|len
operator|=
name|dev
operator|->
name|blocksize
expr_stmt|;
name|num_blocks
operator|=
operator|*
name|len
operator|/
name|dev
operator|->
name|sector_size
expr_stmt|;
comment|/* 	 * If max_sector is 0, then we have no set limit.  This can happen 	 * if we're writing to a file in a filesystem, or reading from 	 * something like /dev/zero. 	 */
if|if
condition|(
operator|(
name|dev
operator|->
name|max_sector
operator|!=
literal|0
operator|)
operator|||
operator|(
name|dev
operator|->
name|sector_io_limit
operator|!=
literal|0
operator|)
condition|)
block|{
name|uint64_t
name|max_sector
decl_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|max_sector
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|dev
operator|->
name|sector_io_limit
operator|!=
literal|0
operator|)
condition|)
name|max_sector
operator|=
name|min
argument_list|(
name|dev
operator|->
name|sector_io_limit
argument_list|,
name|dev
operator|->
name|max_sector
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|->
name|max_sector
operator|!=
literal|0
condition|)
name|max_sector
operator|=
name|dev
operator|->
name|max_sector
expr_stmt|;
else|else
name|max_sector
operator|=
name|dev
operator|->
name|sector_io_limit
expr_stmt|;
comment|/* 		 * Check to see whether we're starting off past the end of 		 * the device.  If so, we need to just send an EOF 	 		 * notification to the writer. 		 */
if|if
condition|(
operator|*
name|lba
operator|>
name|max_sector
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|lba
operator|+
name|num_blocks
operator|)
operator|>
name|max_sector
operator|+
literal|1
operator|)
operator|||
operator|(
operator|(
operator|*
name|lba
operator|+
name|num_blocks
operator|)
operator|<
operator|*
name|lba
operator|)
condition|)
block|{
comment|/* 			 * If we get here (but pass the first check), we 			 * can trim the request length down to go to the 			 * end of the device. 			 */
name|num_blocks
operator|=
operator|(
name|max_sector
operator|+
literal|1
operator|)
operator|-
operator|*
name|lba
expr_stmt|;
operator|*
name|len
operator|=
name|num_blocks
operator|*
name|dev
operator|->
name|sector_size
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|dev
operator|->
name|next_io_pos_bytes
operator|+=
operator|*
name|len
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 0 for success, 1 for EOF detected, and -1 for failure.  */
end_comment

begin_function
name|int
name|camdd_queue
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|camdd_buf
modifier|*
name|read_buf
parameter_list|)
block|{
name|struct
name|camdd_buf
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|struct
name|camdd_buf_data
modifier|*
name|data
decl_stmt|;
name|struct
name|camdd_dev_pass
modifier|*
name|pass_dev
decl_stmt|;
name|size_t
name|new_len
decl_stmt|;
name|struct
name|camdd_buf_data
modifier|*
name|rb_data
decl_stmt|;
name|int
name|is_write
init|=
name|dev
operator|->
name|write_dev
decl_stmt|;
name|int
name|eof_flush_needed
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pass_dev
operator|=
operator|&
name|dev
operator|->
name|dev_spec
operator|.
name|pass
expr_stmt|;
comment|/* 	 * If we've gotten EOF or our partner has, we should not continue 	 * queueing I/O.  If we're a writer, though, we should continue 	 * to write any buffers that don't have EOF status. 	 */
if|if
condition|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAMDD_DEV_FLAG_EOF
operator|)
operator|||
operator|(
operator|(
name|dev
operator|->
name|flags
operator|&
name|CAMDD_DEV_FLAG_PEER_EOF
operator|)
operator|&&
operator|(
name|is_write
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Tell the worker thread that we have seen EOF. 		 */
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* 		 * If we're the writer, send the buffer back with EOF status. 		 */
if|if
condition|(
name|is_write
condition|)
block|{
name|read_buf
operator|->
name|status
operator|=
name|CAMDD_STATUS_EOF
expr_stmt|;
name|error
operator|=
name|camdd_complete_peer_buf
argument_list|(
name|dev
argument_list|,
name|read_buf
argument_list|)
expr_stmt|;
block|}
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|is_write
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
name|camdd_get_buf
argument_list|(
name|dev
argument_list|,
name|CAMDD_BUF_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
name|retval
operator|=
name|camdd_get_next_lba_len
argument_list|(
name|dev
argument_list|,
operator|&
name|buf
operator|->
name|lba
argument_list|,
operator|&
name|buf
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|buf
operator|->
name|status
operator|=
name|CAMDD_STATUS_EOF
expr_stmt|;
if|if
condition|(
operator|(
name|buf
operator|->
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|dev
operator|->
name|flags
operator|&
operator|(
name|CAMDD_DEV_FLAG_EOF_SENT
operator||
name|CAMDD_DEV_FLAG_EOF_QUEUED
operator|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|camdd_release_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|dev
operator|->
name|flags
operator||=
name|CAMDD_DEV_FLAG_EOF_QUEUED
expr_stmt|;
block|}
name|data
operator|->
name|fill_len
operator|=
name|buf
operator|->
name|len
expr_stmt|;
name|data
operator|->
name|src_start_offset
operator|=
name|buf
operator|->
name|lba
operator|*
name|dev
operator|->
name|sector_size
expr_stmt|;
comment|/* 		 * Put this on the run queue. 		 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_run_queue
operator|++
expr_stmt|;
comment|/* We're done. */
goto|goto
name|bailout
goto|;
block|}
comment|/* 	 * Check for new EOF status from the reader. 	 */
if|if
condition|(
operator|(
name|read_buf
operator|->
name|status
operator|==
name|CAMDD_STATUS_EOF
operator|)
operator|||
operator|(
name|read_buf
operator|->
name|status
operator|==
name|CAMDD_STATUS_ERROR
operator|)
condition|)
block|{
name|dev
operator|->
name|flags
operator||=
name|CAMDD_DEV_FLAG_PEER_EOF
expr_stmt|;
if|if
condition|(
operator|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|pending_queue
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|read_buf
operator|->
name|len
operator|==
literal|0
operator|)
condition|)
block|{
name|camdd_complete_peer_buf
argument_list|(
name|dev
argument_list|,
name|read_buf
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
else|else
name|eof_flush_needed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * See if we have a buffer we're composing with pieces from our 	 * partner thread. 	 */
name|buf
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|dev
operator|->
name|pending_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|uint64_t
name|lba
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|retval
operator|=
name|camdd_get_next_lba_len
argument_list|(
name|dev
argument_list|,
operator|&
name|lba
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|read_buf
operator|->
name|status
operator|=
name|CAMDD_STATUS_EOF
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|dev
operator|->
name|flags
operator||=
name|CAMDD_DEV_FLAG_EOF
expr_stmt|;
name|error
operator|=
name|camdd_complete_peer_buf
argument_list|(
name|dev
argument_list|,
name|read_buf
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
comment|/* 		 * If we don't have a pending buffer, we need to grab a new 		 * one from the free list or allocate another one. 		 */
name|buf
operator|=
name|camdd_get_buf
argument_list|(
name|dev
argument_list|,
name|CAMDD_BUF_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|buf
operator|->
name|lba
operator|=
name|lba
expr_stmt|;
name|buf
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|pending_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_pending_queue
operator|++
expr_stmt|;
block|}
name|data
operator|=
operator|&
name|buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
name|rb_data
operator|=
operator|&
name|read_buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|rb_data
operator|->
name|src_start_offset
operator|!=
name|dev
operator|->
name|next_peer_pos_bytes
operator|)
operator|&&
operator|(
name|dev
operator|->
name|debug
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING: reader offset %#jx != expected offset "
literal|"%#jx\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|rb_data
operator|->
name|src_start_offset
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dev
operator|->
name|next_peer_pos_bytes
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|next_peer_pos_bytes
operator|=
name|rb_data
operator|->
name|src_start_offset
operator|+
operator|(
name|rb_data
operator|->
name|fill_len
operator|-
name|rb_data
operator|->
name|resid
operator|)
expr_stmt|;
name|new_len
operator|=
operator|(
name|rb_data
operator|->
name|fill_len
operator|-
name|rb_data
operator|->
name|resid
operator|)
operator|+
name|data
operator|->
name|fill_len
expr_stmt|;
if|if
condition|(
name|new_len
operator|<
name|buf
operator|->
name|len
condition|)
block|{
comment|/* 		 * There are three cases here: 		 * 1. We need more data to fill up a block, so we put  		 *    this I/O on the queue and wait for more I/O. 		 * 2. We have a pending buffer in the queue that is 		 *    smaller than our blocksize, but we got an EOF.  So we 		 *    need to go ahead and flush the write out. 		 * 3. We got an error. 		 */
comment|/* 		 * Increment our fill length. 		 */
name|data
operator|->
name|fill_len
operator|+=
operator|(
name|rb_data
operator|->
name|fill_len
operator|-
name|rb_data
operator|->
name|resid
operator|)
expr_stmt|;
comment|/* 		 * Add the new read buffer to the list for writing. 		 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|buf
operator|->
name|src_list
argument_list|,
name|read_buf
argument_list|,
name|src_links
argument_list|)
expr_stmt|;
comment|/* Increment the count */
name|buf
operator|->
name|src_count
operator|++
expr_stmt|;
if|if
condition|(
name|eof_flush_needed
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We need to exit, because we don't have enough 			 * data yet. 			 */
goto|goto
name|bailout
goto|;
block|}
else|else
block|{
comment|/* 			 * Take the buffer off of the pending queue. 			 */
name|STAILQ_REMOVE
argument_list|(
operator|&
name|dev
operator|->
name|pending_queue
argument_list|,
name|buf
argument_list|,
name|camdd_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_pending_queue
operator|--
expr_stmt|;
comment|/* 			 * If we need an EOF flush, but there is no data 			 * to flush, go ahead and return this buffer. 			 */
if|if
condition|(
name|data
operator|->
name|fill_len
operator|==
literal|0
condition|)
block|{
name|camdd_complete_buf
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
comment|/*error_count*/
literal|0
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* 			 * Put this on the next queue for execution. 			 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_run_queue
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|new_len
operator|==
name|buf
operator|->
name|len
condition|)
block|{
comment|/* 		 * We have enough data to completey fill one block, 		 * so we're ready to issue the I/O. 		 */
comment|/* 		 * Take the buffer off of the pending queue. 		 */
name|STAILQ_REMOVE
argument_list|(
operator|&
name|dev
operator|->
name|pending_queue
argument_list|,
name|buf
argument_list|,
name|camdd_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_pending_queue
operator|--
expr_stmt|;
comment|/* 		 * Add the new read buffer to the list for writing. 		 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|buf
operator|->
name|src_list
argument_list|,
name|read_buf
argument_list|,
name|src_links
argument_list|)
expr_stmt|;
comment|/* Increment the count */
name|buf
operator|->
name|src_count
operator|++
expr_stmt|;
comment|/* 		 * Increment our fill length. 		 */
name|data
operator|->
name|fill_len
operator|+=
operator|(
name|rb_data
operator|->
name|fill_len
operator|-
name|rb_data
operator|->
name|resid
operator|)
expr_stmt|;
comment|/* 		 * Put this on the next queue for execution. 		 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_run_queue
operator|++
expr_stmt|;
block|}
else|else
block|{
name|struct
name|camdd_buf
modifier|*
name|idb
decl_stmt|;
name|struct
name|camdd_buf_indirect
modifier|*
name|indirect
decl_stmt|;
name|uint32_t
name|len_to_go
decl_stmt|,
name|cur_offset
decl_stmt|;
name|idb
operator|=
name|camdd_get_buf
argument_list|(
name|dev
argument_list|,
name|CAMDD_BUF_INDIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|idb
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|indirect
operator|=
operator|&
name|idb
operator|->
name|buf_type_spec
operator|.
name|indirect
expr_stmt|;
name|indirect
operator|->
name|src_buf
operator|=
name|read_buf
expr_stmt|;
name|read_buf
operator|->
name|refcount
operator|++
expr_stmt|;
name|indirect
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|indirect
operator|->
name|start_ptr
operator|=
name|rb_data
operator|->
name|buf
expr_stmt|;
comment|/* 		 * We've already established that there is more 		 * data in read_buf than we have room for in our 		 * current write request.  So this particular chunk 		 * of the request should just be the remainder 		 * needed to fill up a block. 		 */
name|indirect
operator|->
name|len
operator|=
name|buf
operator|->
name|len
operator|-
operator|(
name|data
operator|->
name|fill_len
operator|-
name|data
operator|->
name|resid
operator|)
expr_stmt|;
name|camdd_buf_add_child
argument_list|(
name|buf
argument_list|,
name|idb
argument_list|)
expr_stmt|;
comment|/* 		 * This buffer is ready to execute, so we can take 		 * it off the pending queue and put it on the run 		 * queue. 		 */
name|STAILQ_REMOVE
argument_list|(
operator|&
name|dev
operator|->
name|pending_queue
argument_list|,
name|buf
argument_list|,
name|camdd_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_pending_queue
operator|--
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|,
name|buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_run_queue
operator|++
expr_stmt|;
name|cur_offset
operator|=
name|indirect
operator|->
name|offset
operator|+
name|indirect
operator|->
name|len
expr_stmt|;
comment|/* 		 * The resulting I/O would be too large to fit in 		 * one block.  We need to split this I/O into 		 * multiple pieces.  Allocate as many buffers as needed. 		 */
for|for
control|(
name|len_to_go
operator|=
name|rb_data
operator|->
name|fill_len
operator|-
name|rb_data
operator|->
name|resid
operator|-
name|indirect
operator|->
name|len
init|;
name|len_to_go
operator|>
literal|0
condition|;
control|)
block|{
name|struct
name|camdd_buf
modifier|*
name|new_buf
decl_stmt|;
name|struct
name|camdd_buf_data
modifier|*
name|new_data
decl_stmt|;
name|uint64_t
name|lba
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|retval
operator|=
name|camdd_get_next_lba_len
argument_list|(
name|dev
argument_list|,
operator|&
name|lba
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|len
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 * The device has already been marked 				 * as EOF, and there is no space left. 				 */
goto|goto
name|bailout
goto|;
block|}
name|new_buf
operator|=
name|camdd_get_buf
argument_list|(
name|dev
argument_list|,
name|CAMDD_BUF_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_buf
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|new_buf
operator|->
name|lba
operator|=
name|lba
expr_stmt|;
name|new_buf
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|idb
operator|=
name|camdd_get_buf
argument_list|(
name|dev
argument_list|,
name|CAMDD_BUF_INDIRECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|idb
operator|==
name|NULL
condition|)
block|{
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|indirect
operator|=
operator|&
name|idb
operator|->
name|buf_type_spec
operator|.
name|indirect
expr_stmt|;
name|indirect
operator|->
name|src_buf
operator|=
name|read_buf
expr_stmt|;
name|read_buf
operator|->
name|refcount
operator|++
expr_stmt|;
name|indirect
operator|->
name|offset
operator|=
name|cur_offset
expr_stmt|;
name|indirect
operator|->
name|start_ptr
operator|=
name|rb_data
operator|->
name|buf
operator|+
name|cur_offset
expr_stmt|;
name|indirect
operator|->
name|len
operator|=
name|min
argument_list|(
name|len_to_go
argument_list|,
name|new_buf
operator|->
name|len
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (((indirect->len % dev->sector_size) != 0) 			 || ((indirect->offset % dev->sector_size) != 0)) { 				warnx("offset %ju len %ju not aligned with " 				    "sector size %u", indirect->offset, 				    (uintmax_t)indirect->len, dev->sector_size); 			}
endif|#
directive|endif
name|cur_offset
operator|+=
name|indirect
operator|->
name|len
expr_stmt|;
name|len_to_go
operator|-=
name|indirect
operator|->
name|len
expr_stmt|;
name|camdd_buf_add_child
argument_list|(
name|new_buf
argument_list|,
name|idb
argument_list|)
expr_stmt|;
name|new_data
operator|=
operator|&
name|new_buf
operator|->
name|buf_type_spec
operator|.
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|new_data
operator|->
name|fill_len
operator|==
name|new_buf
operator|->
name|len
operator|)
operator|||
operator|(
name|eof_flush_needed
operator|!=
literal|0
operator|)
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|run_queue
argument_list|,
name|new_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_run_queue
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_data
operator|->
name|fill_len
operator|<
name|buf
operator|->
name|len
condition|)
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|dev
operator|->
name|pending_queue
argument_list|,
name|new_buf
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|dev
operator|->
name|num_pending_queue
operator|++
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"%s: too much data in new "
literal|"buffer!"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
block|}
name|bailout
label|:
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|camdd_get_depth
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|dev
parameter_list|,
name|uint32_t
modifier|*
name|our_depth
parameter_list|,
name|uint32_t
modifier|*
name|peer_depth
parameter_list|,
name|uint32_t
modifier|*
name|our_bytes
parameter_list|,
name|uint32_t
modifier|*
name|peer_bytes
parameter_list|)
block|{
operator|*
name|our_depth
operator|=
name|dev
operator|->
name|cur_active_io
operator|+
name|dev
operator|->
name|num_run_queue
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|num_peer_work_queue
operator|>
name|dev
operator|->
name|num_peer_done_queue
condition|)
operator|*
name|peer_depth
operator|=
name|dev
operator|->
name|num_peer_work_queue
operator|-
name|dev
operator|->
name|num_peer_done_queue
expr_stmt|;
else|else
operator|*
name|peer_depth
operator|=
literal|0
expr_stmt|;
operator|*
name|our_bytes
operator|=
operator|*
name|our_depth
operator|*
name|dev
operator|->
name|blocksize
expr_stmt|;
operator|*
name|peer_bytes
operator|=
name|dev
operator|->
name|peer_bytes_queued
expr_stmt|;
block|}
end_function

begin_function
name|void
name|camdd_sig_handler
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
if|if
condition|(
name|sig
operator|==
name|SIGINFO
condition|)
name|need_status
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|need_exit
operator|=
literal|1
expr_stmt|;
name|error_exit
operator|=
literal|1
expr_stmt|;
block|}
name|sem_post
argument_list|(
operator|&
name|camdd_sem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|camdd_print_status
parameter_list|(
name|struct
name|camdd_dev
modifier|*
name|camdd_dev
parameter_list|,
name|struct
name|camdd_dev
modifier|*
name|other_dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|start_time
parameter_list|)
block|{
name|struct
name|timespec
name|done_time
decl_stmt|;
name|uint64_t
name|total_ns
decl_stmt|;
name|long
name|double
name|mb_sec
decl_stmt|,
name|total_sec
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|clock_gettime
argument_list|(
name|CLOCK_MONOTONIC_PRECISE
argument_list|,
operator|&
name|done_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Unable to get done time"
argument_list|)
expr_stmt|;
return|return;
block|}
name|timespecsub
argument_list|(
operator|&
name|done_time
argument_list|,
name|start_time
argument_list|)
expr_stmt|;
name|total_ns
operator|=
name|done_time
operator|.
name|tv_nsec
operator|+
operator|(
name|done_time
operator|.
name|tv_sec
operator|*
literal|1000000000
operator|)
expr_stmt|;
name|total_sec
operator|=
name|total_ns
expr_stmt|;
name|total_sec
operator|/=
literal|1000000000
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%ju bytes %s %s\n%ju bytes %s %s\n"
literal|"%.4Lf seconds elapsed\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|camdd_dev
operator|->
name|bytes_transferred
argument_list|,
operator|(
name|camdd_dev
operator|->
name|write_dev
operator|==
literal|0
operator|)
condition|?
literal|"read from"
else|:
literal|"written to"
argument_list|,
name|camdd_dev
operator|->
name|device_name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|other_dev
operator|->
name|bytes_transferred
argument_list|,
operator|(
name|other_dev
operator|->
name|write_dev
operator|==
literal|0
operator|)
condition|?
literal|"read from"
else|:
literal|"written to"
argument_list|,
name|other_dev
operator|->
name|device_name
argument_list|,
name|total_sec
argument_list|)
expr_stmt|;
name|mb_sec
operator|=
name|min
argument_list|(
name|other_dev
operator|->
name|bytes_transferred
argument_list|,
name|camdd_dev
operator|->
name|bytes_transferred
argument_list|)
expr_stmt|;
name|mb_sec
operator|/=
literal|1024
operator|*
literal|1024
expr_stmt|;
name|mb_sec
operator|*=
literal|1000000000
expr_stmt|;
name|mb_sec
operator|/=
name|total_ns
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%.2Lf MB/sec\n"
argument_list|,
name|mb_sec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|camdd_rw
parameter_list|(
name|struct
name|camdd_io_opts
modifier|*
name|io_opts
parameter_list|,
name|int
name|num_io_opts
parameter_list|,
name|uint64_t
name|max_io
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|cam_device
modifier|*
name|new_cam_dev
init|=
name|NULL
decl_stmt|;
name|struct
name|camdd_dev
modifier|*
name|devs
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|timespec
name|start_time
decl_stmt|;
name|pthread_t
name|threads
index|[
literal|2
index|]
decl_stmt|;
name|int
name|unit
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|num_io_opts
operator|!=
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"Must have one input and one output path"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|bzero
argument_list|(
name|devs
argument_list|,
sizeof|sizeof
argument_list|(
name|devs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_io_opts
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|io_opts
index|[
name|i
index|]
operator|.
name|dev_type
condition|)
block|{
case|case
name|CAMDD_DEV_PASS
case|:
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|io_opts
index|[
name|i
index|]
operator|.
name|dev_name
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|camdd_argmask
name|new_arglist
init|=
name|CAMDD_ARG_NONE
decl_stmt|;
name|int
name|bus
init|=
literal|0
decl_stmt|,
name|target
init|=
literal|0
decl_stmt|,
name|lun
init|=
literal|0
decl_stmt|;
name|int
name|rv
decl_stmt|;
comment|/* device specified as bus:target[:lun] */
name|rv
operator|=
name|parse_btl
argument_list|(
name|io_opts
index|[
name|i
index|]
operator|.
name|dev_name
argument_list|,
operator|&
name|bus
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|lun
argument_list|,
operator|&
name|new_arglist
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<
literal|2
condition|)
block|{
name|warnx
argument_list|(
literal|"numeric device specification "
literal|"must be either bus:target, or "
literal|"bus:target:lun"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
comment|/* default to 0 if lun was not specified */
if|if
condition|(
operator|(
name|new_arglist
operator|&
name|CAMDD_ARG_LUN
operator|)
operator|==
literal|0
condition|)
block|{
name|lun
operator|=
literal|0
expr_stmt|;
name|new_arglist
operator||=
name|CAMDD_ARG_LUN
expr_stmt|;
block|}
name|new_cam_dev
operator|=
name|cam_open_btl
argument_list|(
name|bus
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|O_RDWR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|name
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|cam_get_device
argument_list|(
name|io_opts
index|[
name|i
index|]
operator|.
name|dev_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
operator|&
name|unit
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|cam_errbuf
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|new_cam_dev
operator|=
name|cam_open_spec_device
argument_list|(
name|name
argument_list|,
name|unit
argument_list|,
name|O_RDWR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_cam_dev
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s"
argument_list|,
name|cam_errbuf
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|devs
index|[
name|i
index|]
operator|=
name|camdd_probe_pass
argument_list|(
name|new_cam_dev
argument_list|,
comment|/*io_opts*/
operator|&
name|io_opts
index|[
name|i
index|]
argument_list|,
name|CAMDD_ARG_ERR_RECOVER
argument_list|,
comment|/*probe_retry_count*/
literal|3
argument_list|,
comment|/*probe_timeout*/
literal|5000
argument_list|,
comment|/*io_retry_count*/
name|retry_count
argument_list|,
comment|/*io_timeout*/
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|devs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"Unable to probe device %s%u"
argument_list|,
name|new_cam_dev
operator|->
name|device_name
argument_list|,
name|new_cam_dev
operator|->
name|dev_unit_num
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
case|case
name|CAMDD_DEV_FILE
case|:
block|{
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|io_opts
index|[
name|i
index|]
operator|.
name|dev_name
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|io_opts
index|[
name|i
index|]
operator|.
name|write_dev
operator|!=
literal|0
condition|)
name|fd
operator|=
name|STDOUT_FILENO
expr_stmt|;
else|else
name|fd
operator|=
name|STDIN_FILENO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|io_opts
index|[
name|i
index|]
operator|.
name|write_dev
operator|!=
literal|0
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|io_opts
index|[
name|i
index|]
operator|.
name|dev_name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
name|S_IWUSR
operator||
name|S_IRUSR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fd
operator|=
name|open
argument_list|(
name|io_opts
index|[
name|i
index|]
operator|.
name|dev_name
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"error opening file %s"
argument_list|,
name|io_opts
index|[
name|i
index|]
operator|.
name|dev_name
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|devs
index|[
name|i
index|]
operator|=
name|camdd_probe_file
argument_list|(
name|fd
argument_list|,
operator|&
name|io_opts
index|[
name|i
index|]
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|devs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
block|}
default|default:
name|warnx
argument_list|(
literal|"Unknown device type %d (%s)"
argument_list|,
name|io_opts
index|[
name|i
index|]
operator|.
name|dev_type
argument_list|,
name|io_opts
index|[
name|i
index|]
operator|.
name|dev_name
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
break|break;
comment|/*NOTREACHED */
block|}
name|devs
index|[
name|i
index|]
operator|->
name|write_dev
operator|=
name|io_opts
index|[
name|i
index|]
operator|.
name|write_dev
expr_stmt|;
name|devs
index|[
name|i
index|]
operator|->
name|start_offset_bytes
operator|=
name|io_opts
index|[
name|i
index|]
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|max_io
operator|!=
literal|0
condition|)
block|{
name|devs
index|[
name|i
index|]
operator|->
name|sector_io_limit
operator|=
operator|(
name|devs
index|[
name|i
index|]
operator|->
name|start_offset_bytes
operator|/
name|devs
index|[
name|i
index|]
operator|->
name|sector_size
operator|)
operator|+
operator|(
name|max_io
operator|/
name|devs
index|[
name|i
index|]
operator|->
name|sector_size
operator|)
operator|-
literal|1
expr_stmt|;
name|devs
index|[
name|i
index|]
operator|->
name|sector_io_limit
operator|=
operator|(
name|devs
index|[
name|i
index|]
operator|->
name|start_offset_bytes
operator|/
name|devs
index|[
name|i
index|]
operator|->
name|sector_size
operator|)
operator|+
operator|(
name|max_io
operator|/
name|devs
index|[
name|i
index|]
operator|->
name|sector_size
operator|)
operator|-
literal|1
expr_stmt|;
block|}
name|devs
index|[
name|i
index|]
operator|->
name|next_io_pos_bytes
operator|=
name|devs
index|[
name|i
index|]
operator|->
name|start_offset_bytes
expr_stmt|;
name|devs
index|[
name|i
index|]
operator|->
name|next_completion_pos_bytes
operator|=
name|devs
index|[
name|i
index|]
operator|->
name|start_offset_bytes
expr_stmt|;
block|}
name|devs
index|[
literal|0
index|]
operator|->
name|peer_dev
operator|=
name|devs
index|[
literal|1
index|]
expr_stmt|;
name|devs
index|[
literal|1
index|]
operator|->
name|peer_dev
operator|=
name|devs
index|[
literal|0
index|]
expr_stmt|;
name|devs
index|[
literal|0
index|]
operator|->
name|next_peer_pos_bytes
operator|=
name|devs
index|[
literal|0
index|]
operator|->
name|peer_dev
operator|->
name|next_io_pos_bytes
expr_stmt|;
name|devs
index|[
literal|1
index|]
operator|->
name|next_peer_pos_bytes
operator|=
name|devs
index|[
literal|1
index|]
operator|->
name|peer_dev
operator|->
name|next_io_pos_bytes
expr_stmt|;
name|sem_init
argument_list|(
operator|&
name|camdd_sem
argument_list|,
comment|/*pshared*/
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINFO
argument_list|,
name|camdd_sig_handler
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|camdd_sig_handler
argument_list|)
expr_stmt|;
name|error
operator|=
name|clock_gettime
argument_list|(
name|CLOCK_MONOTONIC_PRECISE
argument_list|,
operator|&
name|start_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"Unable to get start time"
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_io_opts
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|pthread_create
argument_list|(
operator|&
name|threads
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
name|camdd_worker
argument_list|,
operator|(
name|void
operator|*
operator|)
name|devs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|warnc
argument_list|(
name|error
argument_list|,
literal|"pthread_create() failed"
argument_list|)
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|sem_wait
argument_list|(
operator|&
name|camdd_sem
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|need_exit
operator|!=
literal|0
operator|)
condition|)
block|{
name|struct
name|kevent
name|ke
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_io_opts
condition|;
name|i
operator|++
control|)
block|{
name|EV_SET
argument_list|(
operator|&
name|ke
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|&
name|devs
index|[
name|i
index|]
operator|->
name|work_queue
argument_list|,
name|EVFILT_USER
argument_list|,
literal|0
argument_list|,
name|NOTE_TRIGGER
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|devs
index|[
name|i
index|]
operator|->
name|flags
operator||=
name|CAMDD_DEV_FLAG_EOF
expr_stmt|;
name|error
operator|=
name|kevent
argument_list|(
name|devs
index|[
name|i
index|]
operator|->
name|kq
argument_list|,
operator|&
name|ke
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|warn
argument_list|(
literal|"%s: unable to wake up thread"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|need_status
operator|!=
literal|0
condition|)
block|{
name|camdd_print_status
argument_list|(
name|devs
index|[
literal|0
index|]
argument_list|,
name|devs
index|[
literal|1
index|]
argument_list|,
operator|&
name|start_time
argument_list|)
expr_stmt|;
name|need_status
operator|=
literal|0
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_io_opts
condition|;
name|i
operator|++
control|)
block|{
name|pthread_join
argument_list|(
name|threads
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|camdd_print_status
argument_list|(
name|devs
index|[
literal|0
index|]
argument_list|,
name|devs
index|[
literal|1
index|]
argument_list|,
operator|&
name|start_time
argument_list|)
expr_stmt|;
name|bailout
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_io_opts
condition|;
name|i
operator|++
control|)
name|camdd_free_dev
argument_list|(
name|devs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|+
name|error_exit
operator|)
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage:  camdd<-i|-o pass=pass0,bs=1M,offset=1M,depth=4>\n"
literal|"<-i|-o file=/tmp/file,bs=512K,offset=1M>\n"
literal|"<-i|-o file=/dev/da0,bs=512K,offset=1M>\n"
literal|"<-i|-o file=/dev/nsa0,bs=512K>\n"
literal|"              [-C retry_count][-E][-m max_io_amt][-t timeout_secs][-v][-h]\n"
literal|"Option description\n"
literal|"-i<arg=val>  Specify input device/file and parameters\n"
literal|"-o<arg=val>  Specify output device/file and parameters\n"
literal|"Input and Output parameters\n"
literal|"pass=name     Specify a pass(4) device like pass0 or /dev/pass0\n"
literal|"file=name     Specify a file or device, /tmp/foo, /dev/da0, /dev/null\n"
literal|"              or - for stdin/stdout\n"
literal|"bs=blocksize  Specify blocksize in bytes, or using K, M, G, etc. suffix\n"
literal|"offset=len    Specify starting offset in bytes or using K, M, G suffix\n"
literal|"              NOTE: offset cannot be specified on tapes, pipes, stdin/out\n"
literal|"depth=N       Specify a numeric queue depth.  This only applies to pass(4)\n"
literal|"mcs=N         Specify a minimum cmd size for pass(4) read/write commands\n"
literal|"Optional arguments\n"
literal|"-C retry_cnt  Specify a retry count for pass(4) devices\n"
literal|"-E            Enable CAM error recovery for pass(4) devices\n"
literal|"-m max_io     Specify the maximum amount to be transferred in bytes or\n"
literal|"              using K, G, M, etc. suffixes\n"
literal|"-t timeout    Specify the I/O timeout to use with pass(4) devices\n"
literal|"-v            Enable verbose error recovery\n"
literal|"-h            Print this message\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|camdd_parse_io_opts
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|is_write
parameter_list|,
name|struct
name|camdd_io_opts
modifier|*
name|io_opts
parameter_list|)
block|{
name|char
modifier|*
name|tmpstr
decl_stmt|,
modifier|*
name|tmpstr2
decl_stmt|;
name|char
modifier|*
name|orig_tmpstr
init|=
name|NULL
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|io_opts
operator|->
name|write_dev
operator|=
name|is_write
expr_stmt|;
name|tmpstr
operator|=
name|strdup
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpstr
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"strdup failed"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|orig_tmpstr
operator|=
name|tmpstr
expr_stmt|;
while|while
condition|(
operator|(
name|tmpstr2
operator|=
name|strsep
argument_list|(
operator|&
name|tmpstr
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
comment|/* 		 * If the user creates an empty parameter by putting in two 		 * commas, skip over it and look for the next field. 		 */
if|if
condition|(
operator|*
name|tmpstr2
operator|==
literal|'\0'
condition|)
continue|continue;
name|name
operator|=
name|strsep
argument_list|(
operator|&
name|tmpstr2
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"Got empty I/O parameter name"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
name|value
operator|=
name|strsep
argument_list|(
operator|&
name|tmpstr2
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|value
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"Empty I/O parameter value for %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"file"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|io_opts
operator|->
name|dev_type
operator|=
name|CAMDD_DEV_FILE
expr_stmt|;
name|io_opts
operator|->
name|dev_name
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_opts
operator|->
name|dev_name
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"Error allocating memory"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"pass"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|io_opts
operator|->
name|dev_type
operator|=
name|CAMDD_DEV_PASS
expr_stmt|;
name|io_opts
operator|->
name|dev_name
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_opts
operator|->
name|dev_name
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"Error allocating memory"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"bs"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"blocksize"
argument_list|,
literal|9
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|retval
operator|=
name|expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|io_opts
operator|->
name|blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"expand_number(3) failed on %s=%s"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"depth"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|io_opts
operator|->
name|queue_depth
operator|=
name|strtoull
argument_list|(
name|value
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid queue depth %s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"mcs"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|io_opts
operator|->
name|min_cmd_size
operator|=
name|strtol
argument_list|(
name|value
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|endptr
operator|!=
literal|'\0'
operator|)
operator|||
operator|(
operator|(
name|io_opts
operator|->
name|min_cmd_size
operator|>
literal|16
operator|)
operator|||
operator|(
name|io_opts
operator|->
name|min_cmd_size
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid minimum cmd size %s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"offset"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|retval
operator|=
name|expand_number
argument_list|(
name|value
argument_list|,
operator|&
name|io_opts
operator|->
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"expand_number(3) failed on %s=%s"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"debug"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|endptr
decl_stmt|;
name|io_opts
operator|->
name|debug
operator|=
name|strtoull
argument_list|(
name|value
argument_list|,
operator|&
name|endptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endptr
operator|!=
literal|'\0'
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid debug level %s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"Unrecognized parameter %s=%s"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
name|bailout
label|:
name|free
argument_list|(
name|orig_tmpstr
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|camdd_argmask
name|arglist
init|=
name|CAMDD_ARG_NONE
decl_stmt|;
name|int
name|timeout
init|=
literal|0
decl_stmt|,
name|retry_count
init|=
literal|1
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|max_io
init|=
literal|0
decl_stmt|;
name|struct
name|camdd_io_opts
modifier|*
name|opt_list
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|opt_list
operator|=
name|calloc
argument_list|(
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|camdd_io_opts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_list
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"Unable to allocate option list"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"C:Ehi:m:o:t:v"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'C'
case|:
name|retry_count
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retry_count
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"retry count %d is< 0"
argument_list|,
name|retry_count
argument_list|)
expr_stmt|;
name|arglist
operator||=
name|CAMDD_ARG_RETRIES
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|arglist
operator||=
name|CAMDD_ARG_ERR_RECOVER
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'o'
case|:
if|if
condition|(
operator|(
operator|(
name|c
operator|==
literal|'i'
operator|)
operator|&&
operator|(
name|opt_list
index|[
literal|0
index|]
operator|.
name|dev_type
operator|!=
name|CAMDD_DEV_NONE
operator|)
operator|)
operator|||
operator|(
operator|(
name|c
operator|==
literal|'o'
operator|)
operator|&&
operator|(
name|opt_list
index|[
literal|1
index|]
operator|.
name|dev_type
operator|!=
name|CAMDD_DEV_NONE
operator|)
operator|)
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Only one input and output path "
literal|"allowed"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|camdd_parse_io_opts
argument_list|(
name|optarg
argument_list|,
operator|(
name|c
operator|==
literal|'o'
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
operator|(
name|c
operator|==
literal|'o'
operator|)
condition|?
operator|&
name|opt_list
index|[
literal|1
index|]
else|:
operator|&
name|opt_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bailout
goto|;
break|break;
case|case
literal|'m'
case|:
name|error
operator|=
name|expand_number
argument_list|(
name|optarg
argument_list|,
operator|&
name|max_io
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"invalid maximum I/O amount %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|bailout
goto|;
block|}
break|break;
case|case
literal|'t'
case|:
name|timeout
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid timeout %d"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* Convert the timeout from seconds to ms */
name|timeout
operator|*=
literal|1000
expr_stmt|;
name|arglist
operator||=
name|CAMDD_ARG_TIMEOUT
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|arglist
operator||=
name|CAMDD_ARG_VERBOSE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
comment|/*NOTREACHED*/
block|}
block|}
if|if
condition|(
operator|(
name|opt_list
index|[
literal|0
index|]
operator|.
name|dev_type
operator|==
name|CAMDD_DEV_NONE
operator|)
operator|||
operator|(
name|opt_list
index|[
literal|1
index|]
operator|.
name|dev_type
operator|==
name|CAMDD_DEV_NONE
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Must specify both -i and -o"
argument_list|)
expr_stmt|;
comment|/* 	 * Set the timeout if the user hasn't specified one. 	 */
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
name|timeout
operator|=
name|CAMDD_PASS_RW_TIMEOUT
expr_stmt|;
name|error
operator|=
name|camdd_rw
argument_list|(
name|opt_list
argument_list|,
literal|2
argument_list|,
name|max_io
argument_list|,
name|retry_count
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|bailout
label|:
name|free
argument_list|(
name|opt_list
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

