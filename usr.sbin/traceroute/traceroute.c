begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"@(#)$Header: traceroute.c,v 1.27 95/10/18 00:17:06 leres Exp $ (LBL)"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * traceroute host  - trace the route ip packets follow going to "host".  *  * Attempt to trace the route an ip packet would follow to some  * internet host.  We find out intermediate hops by launching probe  * packets with a small ttl (time to live) then listening for an  * icmp "time exceeded" reply from a gateway.  We start our probes  * with a ttl of one and increase by one until we get an icmp "port  * unreachable" (which means we got to "host") or hit a max (which  * defaults to 30 hops& can be changed with the -m flag).  Three  * probes (change with -q flag) are sent at each ttl setting and a  * line is printed showing the ttl, address of the gateway and  * round trip time of each probe.  If the probe answers come from  * different gateways, the address of each responding system will  * be printed.  If there is no response within a 5 sec. timeout  * interval (changed with the -w flag), a "*" is printed for that  * probe.  *  * Probe packets are UDP format.  We don't want the destination  * host to process them so the destination port is set to an  * unlikely value (if some clod on the destination is using that  * value, it can be changed with the -p flag).  *  * A sample use might be:  *  *     [yak 71]% traceroute nis.nsf.net.  *     traceroute to nis.nsf.net (35.1.1.48), 30 hops max, 56 byte packet  *      1  helios.ee.lbl.gov (128.3.112.1)  19 ms  19 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  39 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  39 ms  *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  39 ms  39 ms  39 ms  *      6  128.32.197.4 (128.32.197.4)  40 ms  59 ms  59 ms  *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  59 ms  *      8  129.140.70.13 (129.140.70.13)  99 ms  99 ms  80 ms  *      9  129.140.71.6 (129.140.71.6)  139 ms  239 ms  319 ms  *     10  129.140.81.7 (129.140.81.7)  220 ms  199 ms  199 ms  *     11  nic.merit.edu (35.1.1.48)  239 ms  239 ms  239 ms  *  * Note that lines 2& 3 are the same.  This is due to a buggy  * kernel on the 2nd hop system -- lbl-csam.arpa -- that forwards  * packets with a zero ttl.  *  * A more interesting example is:  *  *     [yak 72]% traceroute allspice.lcs.mit.edu.  *     traceroute to allspice.lcs.mit.edu (18.26.0.115), 30 hops max  *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  19 ms  19 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  19 ms  39 ms  39 ms  *      5  ccn-nerif22.Berkeley.EDU (128.32.168.22)  20 ms  39 ms  39 ms  *      6  128.32.197.4 (128.32.197.4)  59 ms  119 ms  39 ms  *      7  131.119.2.5 (131.119.2.5)  59 ms  59 ms  39 ms  *      8  129.140.70.13 (129.140.70.13)  80 ms  79 ms  99 ms  *      9  129.140.71.6 (129.140.71.6)  139 ms  139 ms  159 ms  *     10  129.140.81.7 (129.140.81.7)  199 ms  180 ms  300 ms  *     11  129.140.72.17 (129.140.72.17)  300 ms  239 ms  239 ms  *     12  * * *  *     13  128.121.54.72 (128.121.54.72)  259 ms  499 ms  279 ms  *     14  * * *  *     15  * * *  *     16  * * *  *     17  * * *  *     18  ALLSPICE.LCS.MIT.EDU (18.26.0.115)  339 ms  279 ms  279 ms  *  * (I start to see why I'm having so much trouble with mail to  * MIT.)  Note that the gateways 12, 14, 15, 16& 17 hops away  * either don't send ICMP "time exceeded" messages or send them  * with a ttl too small to reach us.  14 - 17 are running the  * MIT C Gateway code that doesn't send "time exceeded"s.  God  * only knows what's going on with 12.  *  * The silent gateway 12 in the above may be the result of a bug in  * the 4.[23]BSD network code (and its derivatives):  4.x (x<= 3)  * sends an unreachable message using whatever ttl remains in the  * original datagram.  Since, for gateways, the remaining ttl is  * zero, the icmp "time exceeded" is guaranteed to not make it back  * to us.  The behavior of this bug is slightly more interesting  * when it appears on the destination system:  *  *      1  helios.ee.lbl.gov (128.3.112.1)  0 ms  0 ms  0 ms  *      2  lilac-dmc.Berkeley.EDU (128.32.216.1)  39 ms  19 ms  39 ms  *      3  lilac-dmc.Berkeley.EDU (128.32.216.1)  19 ms  39 ms  19 ms  *      4  ccngw-ner-cc.Berkeley.EDU (128.32.136.23)  39 ms  40 ms  19 ms  *      5  ccn-nerif35.Berkeley.EDU (128.32.168.35)  39 ms  39 ms  39 ms  *      6  csgw.Berkeley.EDU (128.32.133.254)  39 ms  59 ms  39 ms  *      7  * * *  *      8  * * *  *      9  * * *  *     10  * * *  *     11  * * *  *     12  * * *  *     13  rip.Berkeley.EDU (128.32.131.22)  59 ms !  39 ms !  39 ms !  *  * Notice that there are 12 "gateways" (13 is the final  * destination) and exactly the last half of them are "missing".  * What's really happening is that rip (a Sun-3 running Sun OS3.5)  * is using the ttl from our arriving datagram as the ttl in its  * icmp reply.  So, the reply will time out on the return path  * (with no notice sent to anyone since icmp's aren't sent for  * icmp's) until we probe with a ttl that's at least twice the path  * length.  I.e., rip is really only 7 hops away.  A reply that  * returns with a ttl of 1 is a clue this problem exists.  * Traceroute prints a "!" after the time if the ttl is<= 1.  * Since vendors ship a lot of obsolete (DEC's Ultrix, Sun 3.x) or  * non-standard (HPUX) software, expect to see this problem  * frequently and/or take care picking the target host of your  * probes.  *  * Other possible annotations after the time are !H, !N, !P (got a host,  * network or protocol unreachable, respectively), !S or !F (source  * route failed or fragmentation needed -- neither of these should  * ever occur and the associated gateway is busted if you see one).  If  * almost all the probes result in some kind of unreachable, traceroute  * will give up and exit.  *  * Notes  * -----  * This program must be run by root or be setuid.  (I suggest that  * you *don't* make it setuid -- casual use could result in a lot  * of unnecessary traffic on our poor, congested nets.)  *  * This program requires a kernel mod that does not appear in any  * system available from Berkeley:  A raw ip socket using proto  * IPPROTO_RAW must interpret the data sent as an ip datagram (as  * opposed to data to be wrapped in a ip datagram).  See the README  * file that came with the source to this program for a description  * of the mods I made to /sys/netinet/raw_ip.c.  Your mileage may  * vary.  But, again, ANY 4.x (x< 4) BSD KERNEL WILL HAVE TO BE  * MODIFIED TO RUN THIS PROGRAM.  *  * The udp port usage may appear bizarre (well, ok, it is bizarre).  * The problem is that an icmp message only contains 8 bytes of  * data from the original datagram.  8 bytes is the size of a udp  * header so, if we want to associate replies with the original  * datagram, the necessary information must be encoded into the  * udp header (the ip id could be used but there's no way to  * interlock with the kernel's assignment of ip id's and, anyway,  * it would have taken a lot more kernel hacking to allow this  * code to set the ip id).  So, to allow two or more users to  * use traceroute simultaneously, we use this task's pid as the  * source port (the high bit is set to move the port number out  * of the "likely" range).  To keep track of which probe is being  * replied to (so times and/or hop counts don't get confused by a  * reply that was delayed in transit), we increment the destination  * port number before each probe.  *  * Don't use this as a coding example.  I was trying to find a  * routing problem and this code sort-of popped out after 48 hours  * without sleep.  I was amazed it ever compiled, much less ran.  *  * I stole the idea for this program from Steve Deering.  Since  * the first release, I've learned that had I attended the right  * IETF working group meetings, I also could have stolen it from Guy  * Almes or Matt Mathis.  I don't know (or care) who came up with  * the idea first.  I envy the originators' perspicacity and I'm  * glad they didn't keep the idea a secret.  *  * Tim Seaver, Ken Adelman and C. Philip Wood provided bug fixes and/or  * enhancements to the original distribution.  *  * I've hacked up a round-trip-route version of this that works by  * sending a loose-source-routed udp datagram through the destination  * back to yourself.  Unfortunately, SO many gateways botch source  * routing, the thing is almost worthless.  Maybe one day...  *  *  -- Van Jacobson (van@ee.lbl.gov)  *     Tue Dec 20 03:50:13 PST 1988  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"gnuc.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_OS_PROTO_H
end_ifdef

begin_include
include|#
directive|include
file|"os-proto.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXPACKET
value|65535
end_define

begin_comment
comment|/* max ip packet size */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXHOSTNAMELEN
end_ifndef

begin_define
define|#
directive|define
name|MAXHOSTNAMELEN
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_BZERO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|bzero
argument_list|)
end_if

begin_define
define|#
directive|define
name|bzero
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
value|memset(s, 0, n)
end_define

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|n
parameter_list|)
value|memcpy(d, s, n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_SETLINEBUF
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|setlinebuf
argument_list|)
end_if

begin_define
define|#
directive|define
name|setlinebuf
parameter_list|(
name|f
parameter_list|)
value|setvbuf(f, NULL, _IOLBF, 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Fprintf
value|(void)fprintf
end_define

begin_define
define|#
directive|define
name|Sprintf
value|(void)sprintf
end_define

begin_define
define|#
directive|define
name|Printf
value|(void)printf
end_define

begin_comment
comment|/*  * format of a (udp) probe packet.  */
end_comment

begin_struct
struct|struct
name|opacket
block|{
name|struct
name|ip
name|ip
decl_stmt|;
name|struct
name|udphdr
name|udp
decl_stmt|;
name|u_char
name|seq
decl_stmt|;
comment|/* sequence number of this packet */
name|u_char
name|ttl
decl_stmt|;
comment|/* ttl packet left with */
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* time packet left */
block|}
struct|;
end_struct

begin_decl_stmt
name|u_char
name|packet
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last inbound (icmp) packet */
end_comment

begin_decl_stmt
name|struct
name|opacket
modifier|*
name|outpacket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last output (udp) packet */
end_comment

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* receive (icmp) socket file descriptor */
end_comment

begin_decl_stmt
name|int
name|sndsock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* send (udp) socket file descriptor */
end_comment

begin_decl_stmt
name|struct
name|sockaddr
name|whereto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Who to try to reach */
end_comment

begin_decl_stmt
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How much data */
end_comment

begin_decl_stmt
name|char
modifier|*
name|source
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|hnamebuf
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nprobes
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max_ttl
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|ident
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|port
init|=
literal|32768
operator|+
literal|666
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start udp dest port # for probe packets */
end_comment

begin_decl_stmt
name|int
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket options */
end_comment

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|waittime
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time to wait for response (in seconds) */
end_comment

begin_decl_stmt
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* print addresses numerically */
end_comment

begin_decl_stmt
name|char
name|usage
index|[]
init|=
literal|"Usage: traceroute [-dnrv] [-w wait] [-m max_ttl] [-p port#] [-q nqueries] [-t tos] [-s src_addr] [-g gateway] host [data size]\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forwards */
end_comment

begin_function_decl
name|double
name|deltaT
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wait_for_reply
parameter_list|(
name|int
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|send_probe
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|pr_type
parameter_list|(
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|packet_ok
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tvsub
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|inetname
parameter_list|(
name|struct
name|in_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|double
name|deltaT
parameter_list|(
name|struct
name|timeval
modifier|*
name|t1p
parameter_list|,
name|struct
name|timeval
modifier|*
name|t2p
parameter_list|)
block|{
specifier|register
name|double
name|dt
decl_stmt|;
name|dt
operator|=
call|(
name|double
call|)
argument_list|(
name|t2p
operator|->
name|tv_sec
operator|-
name|t1p
operator|->
name|tv_sec
argument_list|)
operator|*
literal|1000.0
operator|+
call|(
name|double
call|)
argument_list|(
name|t2p
operator|->
name|tv_usec
operator|-
name|t1p
operator|->
name|tv_usec
argument_list|)
operator|/
literal|1000.0
expr_stmt|;
return|return
operator|(
name|dt
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
init|=
name|argv
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|to
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|whereto
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
name|struct
name|protoent
modifier|*
name|pe
decl_stmt|;
name|int
name|ttl
decl_stmt|,
name|probe
decl_stmt|,
name|i
decl_stmt|;
name|int
name|seq
init|=
literal|0
decl_stmt|;
name|int
name|tos
init|=
literal|0
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|lsrr
init|=
literal|0
decl_stmt|;
name|u_long
name|gw
decl_stmt|;
name|u_char
name|optlist
index|[
name|MAX_IPOPTLEN
index|]
decl_stmt|,
modifier|*
name|oix
decl_stmt|;
name|oix
operator|=
name|optlist
expr_stmt|;
name|bzero
argument_list|(
name|optlist
argument_list|,
sizeof|sizeof
argument_list|(
name|optlist
argument_list|)
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|av
operator|++
expr_stmt|;
while|while
condition|(
name|argc
operator|&&
operator|*
name|av
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
while|while
condition|(
operator|*
operator|++
name|av
index|[
literal|0
index|]
condition|)
switch|switch
condition|(
operator|*
name|av
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'d'
case|:
name|options
operator||=
name|SO_DEBUG
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|argc
operator|--
operator|,
name|av
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|lsrr
operator|+
literal|1
operator|)
operator|>=
operator|(
operator|(
name|MAX_IPOPTLEN
operator|-
name|IPOPT_MINOFF
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|)
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No more than %d gateways\n"
argument_list|,
call|(
name|u_int
call|)
argument_list|(
operator|(
name|MAX_IPOPTLEN
operator|-
name|IPOPT_MINOFF
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lsrr
operator|==
literal|0
condition|)
block|{
operator|*
name|oix
operator|++
operator|=
name|IPOPT_LSRR
expr_stmt|;
name|oix
operator|++
expr_stmt|;
comment|/* Fill in total length later */
operator|*
name|oix
operator|++
operator|=
name|IPOPT_MINOFF
expr_stmt|;
comment|/* Pointer to LSRR addresses */
block|}
name|lsrr
operator|++
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|av
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|gw
operator|=
name|inet_addr
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|gw
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|gw
argument_list|,
name|oix
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown host %s\n"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
name|oix
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown host %s\n"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|oix
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
goto|goto
name|nextarg
goto|;
case|case
literal|'m'
case|:
name|argc
operator|--
operator|,
name|av
operator|++
expr_stmt|;
name|max_ttl
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_ttl
operator|<=
literal|1
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"max ttl must be>1\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|nextarg
goto|;
case|case
literal|'n'
case|:
name|nflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|argc
operator|--
operator|,
name|av
operator|++
expr_stmt|;
name|port
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|1
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"port must be>0\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|nextarg
goto|;
case|case
literal|'q'
case|:
name|argc
operator|--
operator|,
name|av
operator|++
expr_stmt|;
name|nprobes
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|nprobes
operator|<
literal|1
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"nprobes must be>0\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|nextarg
goto|;
case|case
literal|'r'
case|:
name|options
operator||=
name|SO_DONTROUTE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* 				 * set the ip source address of the outbound 				 * probe (e.g., on a multi-homed host). 				 */
name|argc
operator|--
operator|,
name|av
operator|++
expr_stmt|;
name|source
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
goto|goto
name|nextarg
goto|;
case|case
literal|'t'
case|:
name|argc
operator|--
operator|,
name|av
operator|++
expr_stmt|;
name|tos
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tos
operator|<
literal|0
operator|||
name|tos
operator|>
literal|255
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tos must be 0 to 255\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|nextarg
goto|;
case|case
literal|'v'
case|:
name|verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|argc
operator|--
operator|,
name|av
operator|++
expr_stmt|;
name|waittime
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|waittime
operator|<=
literal|1
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"wait must be>1 sec\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|nextarg
goto|;
default|default:
name|Printf
argument_list|(
name|usage
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nextarg
label|:
name|argc
operator|--
operator|,
name|av
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|Printf
argument_list|(
name|usage
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|whereto
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|to
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|hnamebuf
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|hnamebuf
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
name|to
operator|->
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|to
operator|->
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|hostname
operator|=
name|strdup
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Printf
argument_list|(
literal|"%s: unknown host %s\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|>=
literal|2
condition|)
name|datalen
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
operator|<
literal|0
operator|||
name|datalen
operator|>=
name|MAXPACKET
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|opacket
argument_list|)
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute: packet size must be 0<= s< %d\n"
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|MAXPACKET
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|opacket
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|opacket
argument_list|)
expr_stmt|;
name|outpacket
operator|=
operator|(
expr|struct
name|opacket
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outpacket
condition|)
block|{
name|perror
argument_list|(
literal|"traceroute: malloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|outpacket
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|outpacket
operator|->
name|ip
operator|.
name|ip_dst
operator|=
name|to
operator|->
name|sin_addr
expr_stmt|;
name|outpacket
operator|->
name|ip
operator|.
name|ip_tos
operator|=
name|tos
expr_stmt|;
name|outpacket
operator|->
name|ip
operator|.
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|outpacket
operator|->
name|ip
operator|.
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|ident
operator|=
operator|(
name|getpid
argument_list|()
operator|&
literal|0xffff
operator|)
operator||
literal|0x8000
expr_stmt|;
if|if
condition|(
operator|(
name|pe
operator|=
name|getprotobyname
argument_list|(
literal|"icmp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"icmp: unknown protocol\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|pe
operator|->
name|p_proto
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"traceroute: icmp socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
name|SO_DEBUG
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DEBUG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|SO_DONTROUTE
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DONTROUTE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sndsock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_RAW
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"traceroute: raw socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lsrr
operator|>
literal|0
condition|)
block|{
name|lsrr
operator|++
expr_stmt|;
name|optlist
index|[
name|IPOPT_OLEN
index|]
operator|=
name|IPOPT_MINOFF
operator|-
literal|1
operator|+
operator|(
name|lsrr
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|to
operator|->
name|sin_addr
argument_list|,
name|oix
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|oix
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|oix
operator|-
name|optlist
operator|)
operator|&
literal|3
condition|)
name|oix
operator|++
expr_stmt|;
comment|/* Pad to an even boundry */
if|if
condition|(
operator|(
name|pe
operator|=
name|getprotobyname
argument_list|(
literal|"ip"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"traceroute: unknown protocol ip\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IP_OPTIONS
if|if
condition|(
operator|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|pe
operator|->
name|p_proto
argument_list|,
name|IP_OPTIONS
argument_list|,
name|optlist
argument_list|,
name|oix
operator|-
name|optlist
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"traceroute: lsrr options"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SO_SNDBUF
if|if
condition|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|datalen
argument_list|,
sizeof|sizeof
argument_list|(
name|datalen
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"traceroute: SO_SNDBUF"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|SO_SNDBUF
ifdef|#
directive|ifdef
name|IP_HDRINCL
if|if
condition|(
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_HDRINCL
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"traceroute: IP_HDRINCL"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|IP_HDRINCL
if|if
condition|(
name|options
operator|&
name|SO_DEBUG
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DEBUG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|SO_DONTROUTE
condition|)
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sndsock
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DONTROUTE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|from
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
operator|-
literal|1
condition|)
block|{
name|Printf
argument_list|(
literal|"traceroute: unknown host %s\n"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|outpacket
operator|->
name|ip
operator|.
name|ip_src
operator|=
name|from
operator|.
name|sin_addr
expr_stmt|;
ifndef|#
directive|ifndef
name|IP_HDRINCL
if|if
condition|(
name|bind
argument_list|(
name|sndsock
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"traceroute: bind:"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|IP_HDRINCL
block|}
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|"traceroute to %s (%s)"
argument_list|,
name|hostname
argument_list|,
name|inet_ntoa
argument_list|(
name|to
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
condition|)
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|" from %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
name|Fprintf
argument_list|(
name|stderr
argument_list|,
literal|", %d hops max, %d byte packets\n"
argument_list|,
name|max_ttl
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|ttl
operator|=
literal|1
init|;
name|ttl
operator|<=
name|max_ttl
condition|;
operator|++
name|ttl
control|)
block|{
name|u_long
name|lastaddr
init|=
literal|0
decl_stmt|;
name|int
name|got_there
init|=
literal|0
decl_stmt|;
name|int
name|unreachable
init|=
literal|0
decl_stmt|;
name|Printf
argument_list|(
literal|"%2d "
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
for|for
control|(
name|probe
operator|=
literal|0
init|;
name|probe
operator|<
name|nprobes
condition|;
operator|++
name|probe
control|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|timeval
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|struct
name|timezone
name|tz
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
name|send_probe
argument_list|(
operator|++
name|seq
argument_list|,
name|ttl
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cc
operator|=
name|wait_for_reply
argument_list|(
name|s
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|t1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|tz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|packet_ok
argument_list|(
name|packet
argument_list|,
name|cc
argument_list|,
operator|&
name|from
argument_list|,
name|seq
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|lastaddr
condition|)
block|{
name|print
argument_list|(
name|packet
argument_list|,
name|cc
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
name|lastaddr
operator|=
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
block|}
name|Printf
argument_list|(
literal|"  %.3f ms"
argument_list|,
name|deltaT
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|t2
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
operator|-
literal|1
condition|)
block|{
case|case
name|ICMP_UNREACH_PORT
case|:
ifndef|#
directive|ifndef
name|ARCHAIC
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|packet
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
literal|1
condition|)
name|Printf
argument_list|(
literal|" !"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|ARCHAIC
operator|++
name|got_there
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_NET
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !N"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_HOST
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !H"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_PROTOCOL
case|:
operator|++
name|got_there
expr_stmt|;
name|Printf
argument_list|(
literal|" !P"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_NEEDFRAG
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !F"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ICMP_UNREACH_SRCFAIL
case|:
operator|++
name|unreachable
expr_stmt|;
name|Printf
argument_list|(
literal|" !S"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
name|Printf
argument_list|(
literal|" *"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|got_there
operator|||
name|unreachable
operator|>=
name|nprobes
operator|-
literal|1
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|wait_for_reply
parameter_list|(
name|int
name|sock
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|from
parameter_list|,
name|struct
name|timeval
modifier|*
name|sent
parameter_list|)
block|{
name|fd_set
name|fds
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|wait
decl_stmt|;
name|int
name|cc
init|=
literal|0
decl_stmt|;
name|int
name|fromlen
init|=
sizeof|sizeof
argument_list|(
operator|*
name|from
argument_list|)
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|sock
argument_list|,
operator|&
name|fds
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wait
operator|.
name|tv_sec
operator|=
operator|(
name|sent
operator|->
name|tv_sec
operator|+
name|waittime
operator|)
operator|-
name|now
operator|.
name|tv_sec
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
name|sent
operator|->
name|tv_usec
operator|-
name|now
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|wait
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|wait
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|wait
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|wait
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|wait
operator|.
name|tv_sec
operator|=
name|wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|sock
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|wait
argument_list|)
operator|>
literal|0
condition|)
name|cc
operator|=
name|recvfrom
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
name|packet
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|cc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|send_probe
parameter_list|(
name|int
name|seq
parameter_list|,
name|int
name|ttl
parameter_list|,
name|struct
name|timeval
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|opacket
modifier|*
name|op
init|=
name|outpacket
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
operator|&
name|op
operator|->
name|ip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|up
init|=
operator|&
name|op
operator|->
name|udp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ip
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|datalen
expr_stmt|;
name|ip
operator|->
name|ip_ttl
operator|=
name|ttl
expr_stmt|;
name|up
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|up
operator|->
name|uh_dport
operator|=
name|htons
argument_list|(
name|port
operator|+
name|seq
argument_list|)
expr_stmt|;
name|up
operator|->
name|uh_ulen
operator|=
name|htons
argument_list|(
call|(
name|u_short
call|)
argument_list|(
name|datalen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|->
name|uh_sum
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|seq
operator|=
name|seq
expr_stmt|;
name|op
operator|->
name|ttl
operator|=
name|ttl
expr_stmt|;
name|op
operator|->
name|tv
operator|=
operator|*
name|tp
expr_stmt|;
name|i
operator|=
name|sendto
argument_list|(
name|sndsock
argument_list|,
operator|(
name|char
operator|*
operator|)
name|outpacket
argument_list|,
name|datalen
argument_list|,
literal|0
argument_list|,
operator|&
name|whereto
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|!=
name|datalen
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"sendto"
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|"traceroute: wrote %s %d chars, ret=%d\n"
argument_list|,
name|hostname
argument_list|,
name|datalen
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Convert an ICMP "type" field to a printable string.  */
end_comment

begin_function
name|char
modifier|*
name|pr_type
parameter_list|(
name|u_char
name|t
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|ttab
index|[]
init|=
block|{
literal|"Echo Reply"
block|,
literal|"ICMP 1"
block|,
literal|"ICMP 2"
block|,
literal|"Dest Unreachable"
block|,
literal|"Source Quench"
block|,
literal|"Redirect"
block|,
literal|"ICMP 6"
block|,
literal|"ICMP 7"
block|,
literal|"Echo"
block|,
literal|"ICMP 9"
block|,
literal|"ICMP 10"
block|,
literal|"Time Exceeded"
block|,
literal|"Param Problem"
block|,
literal|"Timestamp"
block|,
literal|"Timestamp Reply"
block|,
literal|"Info Request"
block|,
literal|"Info Reply"
block|}
decl_stmt|;
if|if
condition|(
name|t
operator|>
literal|16
condition|)
return|return
operator|(
literal|"OUT-OF-RANGE"
operator|)
return|;
return|return
operator|(
name|ttab
index|[
name|t
index|]
operator|)
return|;
block|}
end_function

begin_function
name|int
name|packet_ok
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|cc
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|from
parameter_list|,
name|int
name|seq
parameter_list|)
block|{
specifier|register
name|struct
name|icmp
modifier|*
name|icp
decl_stmt|;
name|u_char
name|type
decl_stmt|,
name|code
decl_stmt|;
name|int
name|hlen
decl_stmt|;
ifndef|#
directive|ifndef
name|ARCHAIC
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|buf
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|cc
operator|<
name|hlen
operator|+
name|ICMP_MINLEN
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|Printf
argument_list|(
literal|"packet too short (%d bytes) from %s\n"
argument_list|,
name|cc
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cc
operator|-=
name|hlen
expr_stmt|;
name|icp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
name|buf
operator|+
name|hlen
operator|)
expr_stmt|;
else|#
directive|else
name|icp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
name|buf
expr_stmt|;
endif|#
directive|endif
endif|ARCHAIC
name|type
operator|=
name|icp
operator|->
name|icmp_type
expr_stmt|;
name|code
operator|=
name|icp
operator|->
name|icmp_code
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|ICMP_TIMXCEED
operator|&&
name|code
operator|==
name|ICMP_TIMXCEED_INTRANS
operator|)
operator|||
name|type
operator|==
name|ICMP_UNREACH
condition|)
block|{
name|struct
name|ip
modifier|*
name|hip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|up
decl_stmt|;
name|hip
operator|=
operator|&
name|icp
operator|->
name|icmp_ip
expr_stmt|;
name|hlen
operator|=
name|hip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|up
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|hip
operator|+
name|hlen
operator|)
expr_stmt|;
if|if
condition|(
name|hlen
operator|+
literal|12
operator|<=
name|cc
operator|&&
name|hip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
operator|&&
name|up
operator|->
name|uh_sport
operator|==
name|htons
argument_list|(
name|ident
argument_list|)
operator|&&
name|up
operator|->
name|uh_dport
operator|==
name|htons
argument_list|(
name|port
operator|+
name|seq
argument_list|)
condition|)
return|return
operator|(
name|type
operator|==
name|ICMP_TIMXCEED
condition|?
operator|-
literal|1
else|:
name|code
operator|+
literal|1
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|ARCHAIC
if|if
condition|(
name|verbose
condition|)
block|{
name|int
name|i
decl_stmt|;
name|u_long
modifier|*
name|lp
init|=
operator|(
name|u_long
operator|*
operator|)
operator|&
name|icp
operator|->
name|icmp_ip
decl_stmt|;
name|Printf
argument_list|(
literal|"\n%d bytes from %s to %s"
argument_list|,
name|cc
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|)
expr_stmt|;
name|Printf
argument_list|(
literal|": icmp type %d (%s) code %d\n"
argument_list|,
name|type
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|icp
operator|->
name|icmp_code
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
name|cc
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
control|)
name|Printf
argument_list|(
literal|"%2d: x%8.8lx\n"
argument_list|,
name|i
argument_list|,
operator|*
name|lp
operator|++
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|ARCHAIC
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|cc
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|from
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|buf
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|cc
operator|-=
name|hlen
expr_stmt|;
if|if
condition|(
name|nflag
condition|)
name|Printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|Printf
argument_list|(
literal|" %s (%s)"
argument_list|,
name|inetname
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|Printf
argument_list|(
literal|" %d bytes to %s"
argument_list|,
name|cc
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * Checksum routine for Internet Protocol family headers (C Version)  */
end_comment

begin_macro
name|in_cksum
argument_list|(
argument|u_short *addr
argument_list|,
argument|int len
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|nleft
init|=
name|len
decl_stmt|;
specifier|register
name|u_short
modifier|*
name|w
init|=
name|addr
decl_stmt|;
specifier|register
name|u_short
name|answer
decl_stmt|;
specifier|register
name|int
name|sum
init|=
literal|0
decl_stmt|;
comment|/* 	 *  Our algorithm is simple, using a 32 bit accumulator (sum), 	 *  we add sequential 16 bit words to it, and at the end, fold 	 *  back all the carry bits from the top 16 bits into the lower 	 *  16 bits. 	 */
while|while
condition|(
name|nleft
operator|>
literal|1
condition|)
block|{
name|sum
operator|+=
operator|*
name|w
operator|++
expr_stmt|;
name|nleft
operator|-=
literal|2
expr_stmt|;
block|}
comment|/* mop up an odd byte, if necessary */
if|if
condition|(
name|nleft
operator|==
literal|1
condition|)
name|sum
operator|+=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|w
expr_stmt|;
comment|/* 	 * add back carry outs from top 16 bits to low 16 bits 	 */
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
comment|/* add hi 16 to low 16 */
name|sum
operator|+=
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* add carry */
name|answer
operator|=
operator|~
name|sum
expr_stmt|;
comment|/* truncate to 16 bits */
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|notyet
end_endif

begin_comment
comment|/*  * Subtract 2 timeval structs:  out = out - in.  * Out is assumed to be>= in.  */
end_comment

begin_function
name|void
name|tvsub
parameter_list|(
specifier|register
name|struct
name|timeval
modifier|*
name|out
parameter_list|,
specifier|register
name|struct
name|timeval
modifier|*
name|in
parameter_list|)
block|{
if|if
condition|(
operator|(
name|out
operator|->
name|tv_usec
operator|-=
name|in
operator|->
name|tv_usec
operator|)
operator|<
literal|0
condition|)
block|{
name|out
operator|->
name|tv_sec
operator|--
expr_stmt|;
name|out
operator|->
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
name|out
operator|->
name|tv_sec
operator|-=
name|in
operator|->
name|tv_sec
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct an Internet address representation.  * If the nflag has been supplied, give  * numeric value, otherwise try for symbolic name.  */
end_comment

begin_function
name|char
modifier|*
name|inetname
parameter_list|(
name|struct
name|in_addr
name|in
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
name|line
index|[
literal|50
index|]
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|static
name|char
name|domain
index|[
name|MAXHOSTNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|first
operator|&&
operator|!
name|nflag
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gethostname
argument_list|(
name|domain
argument_list|,
name|MAXHOSTNAMELEN
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|domain
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|domain
argument_list|,
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|domain
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|nflag
operator|&&
name|in
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|in
argument_list|,
sizeof|sizeof
argument_list|(
name|in
argument_list|)
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|hp
operator|->
name|h_name
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|cp
operator|+
literal|1
argument_list|,
name|domain
argument_list|)
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|hp
operator|->
name|h_name
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|line
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
block|{
name|in
operator|.
name|s_addr
operator|=
name|ntohl
argument_list|(
name|in
operator|.
name|s_addr
argument_list|)
expr_stmt|;
define|#
directive|define
name|C
parameter_list|(
name|x
parameter_list|)
value|((x)& 0xff)
name|Sprintf
argument_list|(
name|line
argument_list|,
literal|"%lu.%lu.%lu.%lu"
argument_list|,
name|C
argument_list|(
name|in
operator|.
name|s_addr
operator|>>
literal|24
argument_list|)
argument_list|,
name|C
argument_list|(
name|in
operator|.
name|s_addr
operator|>>
literal|16
argument_list|)
argument_list|,
name|C
argument_list|(
name|in
operator|.
name|s_addr
operator|>>
literal|8
argument_list|)
argument_list|,
name|C
argument_list|(
name|in
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|line
operator|)
return|;
block|}
end_function

end_unit

