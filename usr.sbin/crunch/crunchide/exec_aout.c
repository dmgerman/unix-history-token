begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: exec_aout.c,v 1.6 1997/08/02 21:30:17 perry Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1997 Christopher G. Demetriou.  All rights reserved.  * Copyright (c) 1994 University of Maryland  * All Rights Reserved.  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the name of U.M. not be used in advertising or  * publicity pertaining to distribution of the software without specific,  * written prior permission.  U.M. makes no representations about the  * suitability of this software for any purpose.  It is provided "as is"  * without express or implied warranty.  *  * U.M. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL U.M.  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * Author: James da Silva, Systems Design and Analysis Group  *			   Computer Science Department  *			   University of Maryland at College Park  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: exec_aout.c,v 1.6 1997/08/02 21:30:17 perry Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NLIST_AOUT
argument_list|)
end_if

begin_decl_stmt
name|int
name|nsyms
decl_stmt|,
name|ntextrel
decl_stmt|,
name|ndatarel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|exec
modifier|*
name|hdrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|aoutdata
decl_stmt|,
modifier|*
name|strbase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|relocation_info
modifier|*
name|textrel
decl_stmt|,
modifier|*
name|datarel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|symbase
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SYMSTR
parameter_list|(
name|sp
parameter_list|)
value|(&strbase[(sp)->n_un.n_strx])
end_define

begin_comment
comment|/* is the symbol a global symbol defined in the current file? */
end_comment

begin_define
define|#
directive|define
name|IS_GLOBAL_DEFINED
parameter_list|(
name|sp
parameter_list|)
define|\
value|(((sp)->n_type& N_EXT)&& ((sp)->n_type& N_TYPE) != N_UNDF)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc
end_ifdef

begin_comment
comment|/* is the relocation entry dependent on a symbol? */
end_comment

begin_define
define|#
directive|define
name|IS_SYMBOL_RELOC
parameter_list|(
name|rp
parameter_list|)
define|\
value|((rp)->r_extern || \ 	((rp)->r_type>= RELOC_BASE10&& (rp)->r_type<= RELOC_BASE22) || \ 	(rp)->r_type == RELOC_JMP_TBL)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* is the relocation entry dependent on a symbol? */
end_comment

begin_define
define|#
directive|define
name|IS_SYMBOL_RELOC
parameter_list|(
name|rp
parameter_list|)
define|\
value|((rp)->r_extern||(rp)->r_baserel||(rp)->r_jmptable)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|check_reloc
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|relocation_info
modifier|*
name|relp
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|check_aout
parameter_list|(
name|int
name|inf
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|stat
name|infstat
decl_stmt|;
name|struct
name|exec
name|eh
decl_stmt|;
comment|/*      * check the header to make sure it's an a.out-format file.      */
if|if
condition|(
name|fstat
argument_list|(
name|inf
argument_list|,
operator|&
name|infstat
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|infstat
operator|.
name|st_size
operator|<
sizeof|sizeof
name|eh
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|read
argument_list|(
name|inf
argument_list|,
operator|&
name|eh
argument_list|,
sizeof|sizeof
name|eh
argument_list|)
operator|!=
sizeof|sizeof
name|eh
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|eh
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|hide_aout
parameter_list|(
name|int
name|inf
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|stat
name|infstat
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|relp
decl_stmt|;
name|struct
name|nlist
modifier|*
name|symp
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/*      * do some error checking.      */
if|if
condition|(
name|fstat
argument_list|(
name|inf
argument_list|,
operator|&
name|infstat
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*      * Read the entire file into memory.  XXX - Really, we only need to      * read the header and from TRELOFF to the end of the file.      */
if|if
condition|(
operator|(
name|aoutdata
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|infstat
operator|.
name|st_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: too big to read into memory\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|read
argument_list|(
name|inf
argument_list|,
name|aoutdata
argument_list|,
name|infstat
operator|.
name|st_size
argument_list|)
operator|)
operator|<
name|infstat
operator|.
name|st_size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read error: %s\n"
argument_list|,
name|filename
argument_list|,
name|rc
operator|==
operator|-
literal|1
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"short read"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*      * Calculate offsets and sizes from the header.      */
name|hdrp
operator|=
operator|(
expr|struct
name|exec
operator|*
operator|)
name|aoutdata
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|textrel
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_RELOFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|)
expr_stmt|;
name|datarel
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_RELOFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|+
name|hdrp
operator|->
name|a_trsize
operator|)
expr_stmt|;
else|#
directive|else
name|textrel
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_TRELOFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|)
expr_stmt|;
name|datarel
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_DRELOFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|symbase
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_SYMOFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|)
expr_stmt|;
name|strbase
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_STROFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|)
expr_stmt|;
name|ntextrel
operator|=
name|hdrp
operator|->
name|a_trsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
name|ndatarel
operator|=
name|hdrp
operator|->
name|a_drsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|hdrp
operator|->
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
comment|/*      * Zap the type field of all globally-defined symbols.  The linker will      * subsequently ignore these entries.  Don't zap any symbols in the      * keep list.      */
for|for
control|(
name|symp
operator|=
name|symbase
init|;
name|symp
operator|<
name|symbase
operator|+
name|nsyms
condition|;
name|symp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|IS_GLOBAL_DEFINED
argument_list|(
name|symp
argument_list|)
condition|)
comment|/* keep undefined syms */
continue|continue;
comment|/* keep (C) symbols which are on the keep list */
if|if
condition|(
name|SYMSTR
argument_list|(
name|symp
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|in_keep_list
argument_list|(
name|SYMSTR
argument_list|(
name|symp
argument_list|)
operator|+
literal|1
argument_list|)
condition|)
continue|continue;
name|symp
operator|->
name|n_type
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Check whether the relocation entries reference any symbols that we      * just zapped.  I don't know whether ld can handle this case, but I      * haven't encountered it yet.  These checks are here so that the program      * doesn't fail silently should such symbols be encountered.      */
for|for
control|(
name|relp
operator|=
name|textrel
init|;
name|relp
operator|<
name|textrel
operator|+
name|ntextrel
condition|;
name|relp
operator|++
control|)
name|check_reloc
argument_list|(
name|filename
argument_list|,
name|relp
argument_list|)
expr_stmt|;
for|for
control|(
name|relp
operator|=
name|datarel
init|;
name|relp
operator|<
name|datarel
operator|+
name|ndatarel
condition|;
name|relp
operator|++
control|)
name|check_reloc
argument_list|(
name|filename
argument_list|,
name|relp
argument_list|)
expr_stmt|;
comment|/*      * Write the .o file back out to disk.  XXX - Really, we only need to      * write the symbol table entries back out.      */
name|lseek
argument_list|(
name|inf
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|write
argument_list|(
name|inf
argument_list|,
name|aoutdata
argument_list|,
name|infstat
operator|.
name|st_size
argument_list|)
operator|)
operator|<
name|infstat
operator|.
name|st_size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write error: %s\n"
argument_list|,
name|filename
argument_list|,
name|rc
operator|==
operator|-
literal|1
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"short write"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_reloc
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|relocation_info
modifier|*
name|relp
parameter_list|)
block|{
comment|/* bail out if we zapped a symbol that is needed */
if|if
condition|(
name|IS_SYMBOL_RELOC
argument_list|(
name|relp
argument_list|)
operator|&&
name|symbase
index|[
name|relp
operator|->
name|r_symbolnum
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: oops, have hanging relocation for %s: bailing out!\n"
argument_list|,
name|filename
argument_list|,
name|SYMSTR
argument_list|(
operator|&
name|symbase
index|[
name|relp
operator|->
name|r_symbolnum
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(NLIST_AOUT) */
end_comment

end_unit

