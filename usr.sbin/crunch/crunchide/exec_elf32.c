begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 Christopher G. Demetriou.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Christopher G. Demetriou  *	for the NetBSD Project.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|__RCSID("$NetBSD: exec_elf32.c,v 1.4 1997/08/12 06:07:24 mikel Exp $");
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ELFSIZE
end_ifndef

begin_define
define|#
directive|define
name|ELFSIZE
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|NLIST_ELF32
argument_list|)
operator|&&
operator|(
name|ELFSIZE
operator|==
literal|32
operator|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|NLIST_ELF64
argument_list|)
operator|&&
operator|(
name|ELFSIZE
operator|==
literal|64
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|__ELF_WORD_SIZE
value|ELFSIZE
end_define

begin_if
if|#
directive|if
operator|(
name|ELFSIZE
operator|==
literal|32
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/elf32.h>
end_include

begin_define
define|#
directive|define
name|xewtoh
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? be32toh(x) : le32toh(x))
end_define

begin_define
define|#
directive|define
name|htoxew
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? htobe32(x) : htole32(x))
end_define

begin_elif
elif|#
directive|elif
operator|(
name|ELFSIZE
operator|==
literal|64
operator|)
end_elif

begin_include
include|#
directive|include
file|<sys/elf64.h>
end_include

begin_define
define|#
directive|define
name|xewtoh
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? be64toh(x) : le64toh(x))
end_define

begin_define
define|#
directive|define
name|htoxew
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? htobe64(x) : htole64(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/elf_generic.h>
end_include

begin_define
define|#
directive|define
name|CONCAT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|__CONCAT(x,y)
end_define

begin_define
define|#
directive|define
name|ELFNAME
parameter_list|(
name|x
parameter_list|)
value|CONCAT(elf,CONCAT(ELFSIZE,CONCAT(_,x)))
end_define

begin_define
define|#
directive|define
name|ELFNAME2
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CONCAT(x,CONCAT(_elf,CONCAT(ELFSIZE,CONCAT(_,y))))
end_define

begin_define
define|#
directive|define
name|ELFNAMEEND
parameter_list|(
name|x
parameter_list|)
value|CONCAT(x,CONCAT(_elf,ELFSIZE))
end_define

begin_define
define|#
directive|define
name|ELFDEFNNAME
parameter_list|(
name|x
parameter_list|)
value|CONCAT(ELF,CONCAT(ELFSIZE,CONCAT(_,x)))
end_define

begin_define
define|#
directive|define
name|xe16toh
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? be16toh(x) : le16toh(x))
end_define

begin_define
define|#
directive|define
name|xe32toh
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? be32toh(x) : le32toh(x))
end_define

begin_define
define|#
directive|define
name|htoxe32
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? htobe32(x) : htole32(x))
end_define

begin_struct
struct|struct
name|listelem
block|{
name|struct
name|listelem
modifier|*
name|next
decl_stmt|;
name|void
modifier|*
name|mem
decl_stmt|;
name|off_t
name|file
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|ssize_t
name|xreadatoff
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|off_t
name|off
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|ssize_t
name|rv
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|off
condition|)
block|{
name|perror
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
name|size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read error: %s\n"
argument_list|,
name|fn
argument_list|,
name|rv
operator|==
operator|-
literal|1
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"short read"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xwriteatoff
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|off_t
name|off
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|ssize_t
name|rv
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|off
condition|)
block|{
name|perror
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
name|size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write error: %s\n"
argument_list|,
name|fn
argument_list|,
name|rv
operator|==
operator|-
literal|1
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"short write"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|use
parameter_list|)
block|{
name|void
modifier|*
name|rv
decl_stmt|;
name|rv
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: out of memory (allocating for %s)\n"
argument_list|,
name|fn
argument_list|,
name|use
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ELFNAMEEND
function|(
name|check
function|)
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|Elf_Ehdr
name|eh
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|unsigned
name|char
name|data
decl_stmt|;
comment|/* 	 * Check the header to maek sure it's an ELF file (of the 	 * appropriate size). 	 */
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|<
sizeof|sizeof
name|eh
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|eh
argument_list|,
sizeof|sizeof
name|eh
argument_list|)
operator|!=
sizeof|sizeof
name|eh
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|IS_ELF
argument_list|(
name|eh
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|data
operator|=
name|eh
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
expr_stmt|;
switch|switch
condition|(
name|xe16toh
argument_list|(
name|eh
operator|.
name|e_machine
argument_list|)
condition|)
block|{
case|case
name|EM_386
case|:
break|break;
case|case
name|EM_ALPHA
case|:
break|break;
ifndef|#
directive|ifndef
name|EM_IA_64
define|#
directive|define
name|EM_IA_64
value|50
endif|#
directive|endif
case|case
name|EM_IA_64
case|:
break|break;
ifndef|#
directive|ifndef
name|EM_PPC
define|#
directive|define
name|EM_PPC
value|20
endif|#
directive|endif
case|case
name|EM_PPC
case|:
break|break;
ifndef|#
directive|ifndef
name|EM_SPARCV9
define|#
directive|define
name|EM_SPARCV9
value|43
endif|#
directive|endif
case|case
name|EM_SPARCV9
case|:
break|break;
ifndef|#
directive|ifndef
name|EM_X86_64
define|#
directive|define
name|EM_X86_64
value|62
endif|#
directive|endif
case|case
name|EM_X86_64
case|:
break|break;
comment|/*        ELFDEFNNAME(MACHDEP_ID_CASES) */
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ELFNAMEEND
function|(
name|hide
function|)
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|Elf_Ehdr
name|ehdr
decl_stmt|;
name|Elf_Shdr
modifier|*
name|shdrp
init|=
name|NULL
decl_stmt|,
modifier|*
name|symtabshdr
decl_stmt|,
modifier|*
name|strtabshdr
decl_stmt|;
name|Elf_Sym
modifier|*
name|symtabp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|strtabp
init|=
name|NULL
decl_stmt|;
name|Elf_Word
modifier|*
name|symfwmap
init|=
name|NULL
decl_stmt|,
modifier|*
name|symrvmap
init|=
name|NULL
decl_stmt|,
name|nsyms
decl_stmt|,
name|nlocalsyms
decl_stmt|,
name|ewi
decl_stmt|;
name|struct
name|listelem
modifier|*
name|relalist
init|=
name|NULL
decl_stmt|,
modifier|*
name|rellist
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmpl
decl_stmt|;
name|ssize_t
name|shdrsize
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|i
decl_stmt|,
name|weird
decl_stmt|;
name|unsigned
name|char
name|data
decl_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xreadatoff
argument_list|(
name|fd
argument_list|,
operator|&
name|ehdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ehdr
argument_list|,
name|fn
argument_list|)
operator|!=
sizeof|sizeof
name|ehdr
condition|)
goto|goto
name|bad
goto|;
name|data
operator|=
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
expr_stmt|;
name|shdrsize
operator|=
name|xe16toh
argument_list|(
name|ehdr
operator|.
name|e_shnum
argument_list|)
operator|*
name|xe16toh
argument_list|(
name|ehdr
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|shdrp
operator|=
name|xmalloc
argument_list|(
name|shdrsize
argument_list|,
name|fn
argument_list|,
literal|"section header table"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|xreadatoff
argument_list|(
name|fd
argument_list|,
name|shdrp
argument_list|,
name|xewtoh
argument_list|(
name|ehdr
operator|.
name|e_shoff
argument_list|)
argument_list|,
name|shdrsize
argument_list|,
name|fn
argument_list|)
operator|!=
name|shdrsize
condition|)
goto|goto
name|bad
goto|;
name|symtabshdr
operator|=
name|strtabshdr
operator|=
name|NULL
expr_stmt|;
name|weird
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xe16toh
argument_list|(
name|ehdr
operator|.
name|e_shnum
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|xe32toh
argument_list|(
name|shdrp
index|[
name|i
index|]
operator|.
name|sh_type
argument_list|)
condition|)
block|{
case|case
name|SHT_SYMTAB
case|:
if|if
condition|(
name|symtabshdr
operator|!=
name|NULL
condition|)
name|weird
operator|=
literal|1
expr_stmt|;
name|symtabshdr
operator|=
operator|&
name|shdrp
index|[
name|i
index|]
expr_stmt|;
name|strtabshdr
operator|=
operator|&
name|shdrp
index|[
name|xe32toh
argument_list|(
name|shdrp
index|[
name|i
index|]
operator|.
name|sh_link
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|SHT_RELA
case|:
name|tmpl
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|tmpl
argument_list|,
name|fn
argument_list|,
literal|"rela list element"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|tmpl
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
name|tmpl
operator|->
name|file
operator|=
name|shdrp
index|[
name|i
index|]
operator|.
name|sh_offset
expr_stmt|;
name|tmpl
operator|->
name|size
operator|=
name|shdrp
index|[
name|i
index|]
operator|.
name|sh_size
expr_stmt|;
name|tmpl
operator|->
name|next
operator|=
name|relalist
expr_stmt|;
name|relalist
operator|=
name|tmpl
expr_stmt|;
break|break;
case|case
name|SHT_REL
case|:
name|tmpl
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|tmpl
argument_list|,
name|fn
argument_list|,
literal|"rel list element"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|tmpl
operator|->
name|mem
operator|=
name|NULL
expr_stmt|;
name|tmpl
operator|->
name|file
operator|=
name|shdrp
index|[
name|i
index|]
operator|.
name|sh_offset
expr_stmt|;
name|tmpl
operator|->
name|size
operator|=
name|shdrp
index|[
name|i
index|]
operator|.
name|sh_size
expr_stmt|;
name|tmpl
operator|->
name|next
operator|=
name|rellist
expr_stmt|;
name|rellist
operator|=
name|tmpl
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|symtabshdr
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|strtabshdr
operator|==
name|NULL
condition|)
name|weird
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|weird
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: weird executable (unsupported)\n"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * load up everything we need 	 */
comment|/* symbol table */
if|if
condition|(
operator|(
name|symtabp
operator|=
name|xmalloc
argument_list|(
name|xewtoh
argument_list|(
name|symtabshdr
operator|->
name|sh_size
argument_list|)
argument_list|,
name|fn
argument_list|,
literal|"symbol table"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|xreadatoff
argument_list|(
name|fd
argument_list|,
name|symtabp
argument_list|,
name|xewtoh
argument_list|(
name|symtabshdr
operator|->
name|sh_offset
argument_list|)
argument_list|,
name|xewtoh
argument_list|(
name|symtabshdr
operator|->
name|sh_size
argument_list|)
argument_list|,
name|fn
argument_list|)
operator|!=
name|xewtoh
argument_list|(
name|symtabshdr
operator|->
name|sh_size
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* string table */
if|if
condition|(
operator|(
name|strtabp
operator|=
name|xmalloc
argument_list|(
name|xewtoh
argument_list|(
name|strtabshdr
operator|->
name|sh_size
argument_list|)
argument_list|,
name|fn
argument_list|,
literal|"string table"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|xreadatoff
argument_list|(
name|fd
argument_list|,
name|strtabp
argument_list|,
name|xewtoh
argument_list|(
name|strtabshdr
operator|->
name|sh_offset
argument_list|)
argument_list|,
name|xewtoh
argument_list|(
name|strtabshdr
operator|->
name|sh_size
argument_list|)
argument_list|,
name|fn
argument_list|)
operator|!=
name|xewtoh
argument_list|(
name|strtabshdr
operator|->
name|sh_size
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* any rela tables */
for|for
control|(
name|tmpl
operator|=
name|relalist
init|;
name|tmpl
operator|!=
name|NULL
condition|;
name|tmpl
operator|=
name|tmpl
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|tmpl
operator|->
name|mem
operator|=
name|xmalloc
argument_list|(
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
argument_list|,
name|fn
argument_list|,
literal|"rela table"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|xreadatoff
argument_list|(
name|fd
argument_list|,
name|tmpl
operator|->
name|mem
argument_list|,
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|file
argument_list|)
argument_list|,
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
argument_list|,
name|fn
argument_list|)
operator|!=
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* any rel tables */
for|for
control|(
name|tmpl
operator|=
name|rellist
init|;
name|tmpl
operator|!=
name|NULL
condition|;
name|tmpl
operator|=
name|tmpl
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|tmpl
operator|->
name|mem
operator|=
name|xmalloc
argument_list|(
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
argument_list|,
name|fn
argument_list|,
literal|"rel table"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|xreadatoff
argument_list|(
name|fd
argument_list|,
name|tmpl
operator|->
name|mem
argument_list|,
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|file
argument_list|)
argument_list|,
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
argument_list|,
name|fn
argument_list|)
operator|!=
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* Prepare data structures for symbol movement. */
name|nsyms
operator|=
name|xewtoh
argument_list|(
name|symtabshdr
operator|->
name|sh_size
argument_list|)
operator|/
name|xewtoh
argument_list|(
name|symtabshdr
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
name|nlocalsyms
operator|=
name|xe32toh
argument_list|(
name|symtabshdr
operator|->
name|sh_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|symfwmap
operator|=
name|xmalloc
argument_list|(
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Word
argument_list|)
argument_list|,
name|fn
argument_list|,
literal|"symbol forward mapping table"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|(
name|symrvmap
operator|=
name|xmalloc
argument_list|(
name|nsyms
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Word
argument_list|)
argument_list|,
name|fn
argument_list|,
literal|"symbol reverse mapping table"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* init location -> symbol # table */
for|for
control|(
name|ewi
operator|=
literal|0
init|;
name|ewi
operator|<
name|nsyms
condition|;
name|ewi
operator|++
control|)
name|symrvmap
index|[
name|ewi
index|]
operator|=
name|ewi
expr_stmt|;
comment|/* move symbols, making them local */
for|for
control|(
name|ewi
operator|=
name|nlocalsyms
init|;
name|ewi
operator|<
name|nsyms
condition|;
name|ewi
operator|++
control|)
block|{
name|Elf_Sym
modifier|*
name|sp
decl_stmt|,
name|symswap
decl_stmt|;
name|Elf_Word
name|mapswap
decl_stmt|;
name|sp
operator|=
operator|&
name|symtabp
index|[
name|ewi
index|]
expr_stmt|;
comment|/* if it's on our keep list, don't move it */
if|if
condition|(
name|in_keep_list
argument_list|(
name|strtabp
operator|+
name|xe32toh
argument_list|(
name|sp
operator|->
name|st_name
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* if it's an undefined symbol, keep it */
if|if
condition|(
name|xe16toh
argument_list|(
name|sp
operator|->
name|st_shndx
argument_list|)
operator|==
name|SHN_UNDEF
condition|)
continue|continue;
comment|/* adjust the symbol so that it's local */
name|sp
operator|->
name|st_info
operator|=
name|ELF_ST_INFO
argument_list|(
name|STB_LOCAL
argument_list|,
name|sp
operator|->
name|st_info
argument_list|)
expr_stmt|;
comment|/*		    (STB_LOCAL<< 4) | ELF_SYM_TYPE(sp->st_info); */
comment|/* XXX */
comment|/* 		 * move the symbol to its new location 		 */
comment|/* note that symbols in those locations have been swapped */
name|mapswap
operator|=
name|symrvmap
index|[
name|ewi
index|]
expr_stmt|;
name|symrvmap
index|[
name|ewi
index|]
operator|=
name|symrvmap
index|[
name|nlocalsyms
index|]
expr_stmt|;
name|symrvmap
index|[
name|nlocalsyms
index|]
operator|=
name|mapswap
expr_stmt|;
comment|/* and swap the symbols */
name|symswap
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|sp
operator|=
name|symtabp
index|[
name|nlocalsyms
index|]
expr_stmt|;
name|symtabp
index|[
name|nlocalsyms
index|]
operator|=
name|symswap
expr_stmt|;
name|nlocalsyms
operator|++
expr_stmt|;
comment|/* note new local sym */
block|}
name|symtabshdr
operator|->
name|sh_info
operator|=
name|htoxe32
argument_list|(
name|nlocalsyms
argument_list|)
expr_stmt|;
comment|/* set up symbol # -> location mapping table */
for|for
control|(
name|ewi
operator|=
literal|0
init|;
name|ewi
operator|<
name|nsyms
condition|;
name|ewi
operator|++
control|)
name|symfwmap
index|[
name|symrvmap
index|[
name|ewi
index|]
index|]
operator|=
name|ewi
expr_stmt|;
comment|/* any rela tables */
for|for
control|(
name|tmpl
operator|=
name|relalist
init|;
name|tmpl
operator|!=
name|NULL
condition|;
name|tmpl
operator|=
name|tmpl
operator|->
name|next
control|)
block|{
name|Elf_Rela
modifier|*
name|relap
init|=
name|tmpl
operator|->
name|mem
decl_stmt|;
for|for
control|(
name|ewi
operator|=
literal|0
init|;
name|ewi
operator|<
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|relap
argument_list|)
condition|;
name|ewi
operator|++
control|)
block|{
name|relap
index|[
name|ewi
index|]
operator|.
name|r_info
operator|=
name|htoxew
argument_list|(
name|ELF_R_INFO
argument_list|(
name|symfwmap
index|[
name|ELF_R_SYM
argument_list|(
name|xewtoh
argument_list|(
name|relap
index|[
name|ewi
index|]
operator|.
name|r_info
argument_list|)
argument_list|)
index|]
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|xewtoh
argument_list|(
name|relap
index|[
name|ewi
index|]
operator|.
name|r_info
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* any rel tables */
for|for
control|(
name|tmpl
operator|=
name|rellist
init|;
name|tmpl
operator|!=
name|NULL
condition|;
name|tmpl
operator|=
name|tmpl
operator|->
name|next
control|)
block|{
name|Elf_Rel
modifier|*
name|relp
init|=
name|tmpl
operator|->
name|mem
decl_stmt|;
for|for
control|(
name|ewi
operator|=
literal|0
init|;
name|ewi
operator|<
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
operator|/
sizeof|sizeof
expr|*
name|relp
condition|;
name|ewi
operator|++
control|)
block|{
name|relp
index|[
name|ewi
index|]
operator|.
name|r_info
operator|=
name|htoxew
argument_list|(
name|ELF_R_INFO
argument_list|(
name|symfwmap
index|[
name|ELF_R_SYM
argument_list|(
name|xewtoh
argument_list|(
name|relp
index|[
name|ewi
index|]
operator|.
name|r_info
argument_list|)
argument_list|)
index|]
argument_list|,
name|ELF_R_TYPE
argument_list|(
name|xewtoh
argument_list|(
name|relp
index|[
name|ewi
index|]
operator|.
name|r_info
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * write new tables to the file 	 */
if|if
condition|(
name|xwriteatoff
argument_list|(
name|fd
argument_list|,
name|shdrp
argument_list|,
name|xewtoh
argument_list|(
name|ehdr
operator|.
name|e_shoff
argument_list|)
argument_list|,
name|shdrsize
argument_list|,
name|fn
argument_list|)
operator|!=
name|shdrsize
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|xwriteatoff
argument_list|(
name|fd
argument_list|,
name|symtabp
argument_list|,
name|xewtoh
argument_list|(
name|symtabshdr
operator|->
name|sh_offset
argument_list|)
argument_list|,
name|xewtoh
argument_list|(
name|symtabshdr
operator|->
name|sh_size
argument_list|)
argument_list|,
name|fn
argument_list|)
operator|!=
name|xewtoh
argument_list|(
name|symtabshdr
operator|->
name|sh_size
argument_list|)
condition|)
goto|goto
name|bad
goto|;
for|for
control|(
name|tmpl
operator|=
name|relalist
init|;
name|tmpl
operator|!=
name|NULL
condition|;
name|tmpl
operator|=
name|tmpl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|xwriteatoff
argument_list|(
name|fd
argument_list|,
name|tmpl
operator|->
name|mem
argument_list|,
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|file
argument_list|)
argument_list|,
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
argument_list|,
name|fn
argument_list|)
operator|!=
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
for|for
control|(
name|tmpl
operator|=
name|rellist
init|;
name|tmpl
operator|!=
name|NULL
condition|;
name|tmpl
operator|=
name|tmpl
operator|->
name|next
control|)
block|{
if|if
condition|(
name|xwriteatoff
argument_list|(
name|fd
argument_list|,
name|tmpl
operator|->
name|mem
argument_list|,
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|file
argument_list|)
argument_list|,
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
argument_list|,
name|fn
argument_list|)
operator|!=
name|xewtoh
argument_list|(
name|tmpl
operator|->
name|size
argument_list|)
condition|)
goto|goto
name|bad
goto|;
block|}
name|out
label|:
if|if
condition|(
name|shdrp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|shdrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtabp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|symtabp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtabp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|strtabp
argument_list|)
expr_stmt|;
if|if
condition|(
name|symfwmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|symfwmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|symrvmap
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|symrvmap
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|tmpl
operator|=
name|relalist
operator|)
operator|!=
name|NULL
condition|)
block|{
name|relalist
operator|=
name|tmpl
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tmpl
operator|->
name|mem
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tmpl
operator|->
name|mem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|tmpl
operator|=
name|rellist
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rellist
operator|=
name|tmpl
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tmpl
operator|->
name|mem
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|tmpl
operator|->
name|mem
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmpl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
name|bad
label|:
name|rv
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* include this size of ELF */
end_comment

end_unit

