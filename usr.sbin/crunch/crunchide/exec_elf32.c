begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997 Christopher G. Demetriou.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Christopher G. Demetriou  *	for the NetBSD Project.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|__RCSID("$NetBSD: exec_elf32.c,v 1.6 1999/09/20 04:12:16 christos Exp $");
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ELFSIZE
end_ifndef

begin_define
define|#
directive|define
name|ELFSIZE
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|NLIST_ELF32
argument_list|)
operator|&&
operator|(
name|ELFSIZE
operator|==
literal|32
operator|)
operator|)
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|NLIST_ELF64
argument_list|)
operator|&&
operator|(
name|ELFSIZE
operator|==
literal|64
operator|)
operator|)
end_if

begin_define
define|#
directive|define
name|__ELF_WORD_SIZE
value|ELFSIZE
end_define

begin_if
if|#
directive|if
operator|(
name|ELFSIZE
operator|==
literal|32
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/elf32.h>
end_include

begin_define
define|#
directive|define
name|xewtoh
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? be32toh(x) : le32toh(x))
end_define

begin_define
define|#
directive|define
name|htoxew
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? htobe32(x) : htole32(x))
end_define

begin_define
define|#
directive|define
name|wewtoh
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? be32toh(x) : le32toh(x))
end_define

begin_define
define|#
directive|define
name|htowew
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? htobe32(x) : htole32(x))
end_define

begin_elif
elif|#
directive|elif
operator|(
name|ELFSIZE
operator|==
literal|64
operator|)
end_elif

begin_include
include|#
directive|include
file|<sys/elf64.h>
end_include

begin_define
define|#
directive|define
name|xewtoh
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? be64toh(x) : le64toh(x))
end_define

begin_define
define|#
directive|define
name|htoxew
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? htobe64(x) : htole64(x))
end_define

begin_comment
comment|/* elf64 Elf64_Word are 32 bits */
end_comment

begin_define
define|#
directive|define
name|wewtoh
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? be32toh(x) : le32toh(x))
end_define

begin_define
define|#
directive|define
name|htowew
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? htobe32(x) : htole32(x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/elf_generic.h>
end_include

begin_define
define|#
directive|define
name|CONCAT
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|__CONCAT(x,y)
end_define

begin_define
define|#
directive|define
name|ELFNAME
parameter_list|(
name|x
parameter_list|)
value|CONCAT(elf,CONCAT(ELFSIZE,CONCAT(_,x)))
end_define

begin_define
define|#
directive|define
name|ELFNAME2
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|CONCAT(x,CONCAT(_elf,CONCAT(ELFSIZE,CONCAT(_,y))))
end_define

begin_define
define|#
directive|define
name|ELFNAMEEND
parameter_list|(
name|x
parameter_list|)
value|CONCAT(x,CONCAT(_elf,ELFSIZE))
end_define

begin_define
define|#
directive|define
name|ELFDEFNNAME
parameter_list|(
name|x
parameter_list|)
value|CONCAT(ELF,CONCAT(ELFSIZE,CONCAT(_,x)))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|ELFCLASS
end_ifndef

begin_define
define|#
directive|define
name|ELFCLASS
value|CONCAT(ELFCLASS,ELFSIZE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|xe16toh
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? be16toh(x) : le16toh(x))
end_define

begin_define
define|#
directive|define
name|xe32toh
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? be32toh(x) : le32toh(x))
end_define

begin_define
define|#
directive|define
name|htoxe32
parameter_list|(
name|x
parameter_list|)
value|((data == ELFDATA2MSB) ? htobe32(x) : htole32(x))
end_define

begin_struct
struct|struct
name|shlayout
block|{
name|Elf_Shdr
modifier|*
name|shdr
decl_stmt|;
name|void
modifier|*
name|bufp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|ssize_t
name|xreadatoff
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|off_t
name|off
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|ssize_t
name|rv
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|off
condition|)
block|{
name|perror
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|rv
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
argument_list|)
operator|!=
name|size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read error: %s\n"
argument_list|,
name|fn
argument_list|,
name|rv
operator|==
operator|-
literal|1
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"short read"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|xwriteatoff
parameter_list|(
name|int
name|fd
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|off_t
name|off
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|ssize_t
name|rv
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|off
condition|)
block|{
name|perror
argument_list|(
name|fn
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|rv
operator|=
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
argument_list|)
operator|!=
name|size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write error: %s\n"
argument_list|,
name|fn
argument_list|,
name|rv
operator|==
operator|-
literal|1
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"short write"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|size
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|use
parameter_list|)
block|{
name|void
modifier|*
name|rv
decl_stmt|;
name|rv
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: out of memory (allocating for %s)\n"
argument_list|,
name|fn
argument_list|,
name|use
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|xrealloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
specifier|const
name|char
modifier|*
name|use
parameter_list|)
block|{
name|void
modifier|*
name|rv
decl_stmt|;
name|rv
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: out of memory (reallocating for %s)\n"
argument_list|,
name|fn
argument_list|,
name|use
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ELFNAMEEND
function|(
name|check
function|)
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|Elf_Ehdr
name|eh
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|unsigned
name|char
name|data
decl_stmt|;
comment|/* 	 * Check the header to maek sure it's an ELF file (of the 	 * appropriate size). 	 */
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sb
operator|.
name|st_size
operator|<
call|(
name|off_t
call|)
argument_list|(
sizeof|sizeof
name|eh
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|eh
argument_list|,
sizeof|sizeof
name|eh
argument_list|)
operator|!=
sizeof|sizeof
name|eh
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|IS_ELF
argument_list|(
name|eh
argument_list|)
operator|==
literal|0
operator|||
name|eh
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELFCLASS
condition|)
return|return
literal|0
return|;
name|data
operator|=
name|eh
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
expr_stmt|;
switch|switch
condition|(
name|xe16toh
argument_list|(
name|eh
operator|.
name|e_machine
argument_list|)
condition|)
block|{
case|case
name|EM_386
case|:
break|break;
case|case
name|EM_ALPHA
case|:
break|break;
ifndef|#
directive|ifndef
name|EM_AARCH64
define|#
directive|define
name|EM_AARCH64
value|183
endif|#
directive|endif
case|case
name|EM_AARCH64
case|:
break|break;
case|case
name|EM_ARM
case|:
break|break;
case|case
name|EM_IA_64
case|:
break|break;
case|case
name|EM_MIPS
case|:
break|break;
case|case
comment|/* EM_MIPS_RS3_LE */
name|EM_MIPS_RS4_BE
case|:
break|break;
case|case
name|EM_PPC
case|:
break|break;
case|case
name|EM_PPC64
case|:
break|break;
ifndef|#
directive|ifndef
name|EM_RISCV
define|#
directive|define
name|EM_RISCV
value|243
endif|#
directive|endif
case|case
name|EM_RISCV
case|:
break|break;
case|case
name|EM_SPARCV9
case|:
break|break;
case|case
name|EM_X86_64
case|:
break|break;
comment|/*        ELFDEFNNAME(MACHDEP_ID_CASES) */
default|default:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This function 'hides' (some of) ELF executable file's symbols.  * It hides them by renaming them to "_$$hide$$<filename><symbolname>".  * Symbols in the global keep list, or which are marked as being undefined,  * are left alone.  *  * An old version of this code shuffled various tables around, turning  * global symbols to be hidden into local symbols.  That lost on the  * mips, because CALL16 relocs must reference global symbols, and, if  * those symbols were being hidden, they were no longer global.  *  * The new renaming behaviour doesn't take global symbols out of the  * namespace.  However, it's ... unlikely that there will ever be  * any collisions in practice because of the new method.  */
end_comment

begin_function
name|int
name|ELFNAMEEND
function|(
name|hide
function|)
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|Elf_Ehdr
name|ehdr
decl_stmt|;
name|struct
name|shlayout
modifier|*
name|layoutp
init|=
name|NULL
decl_stmt|;
name|Elf_Shdr
modifier|*
name|shdrp
init|=
name|NULL
decl_stmt|,
modifier|*
name|symtabshdr
decl_stmt|,
modifier|*
name|strtabshdr
decl_stmt|,
modifier|*
name|shstrtabshdr
decl_stmt|;
name|Elf_Shdr
name|shdrshdr
decl_stmt|;
name|Elf_Sym
modifier|*
name|symtabp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|shstrtabp
init|=
name|NULL
decl_stmt|,
modifier|*
name|strtabp
init|=
name|NULL
decl_stmt|;
name|Elf_Size
name|nsyms
decl_stmt|,
name|ewi
decl_stmt|;
name|Elf_Off
name|off
decl_stmt|;
name|ssize_t
name|shdrsize
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|i
decl_stmt|,
name|weird
decl_stmt|,
name|l
decl_stmt|,
name|m
decl_stmt|,
name|r
decl_stmt|,
name|strtabidx
decl_stmt|;
name|size_t
name|nstrtab_size
decl_stmt|,
name|nstrtab_nextoff
decl_stmt|,
name|fn_size
decl_stmt|,
name|size
decl_stmt|;
name|char
modifier|*
name|nstrtabp
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|weirdreason
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|Elf_Half
name|shnum
decl_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xreadatoff
argument_list|(
name|fd
argument_list|,
operator|&
name|ehdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ehdr
argument_list|,
name|fn
argument_list|)
operator|!=
sizeof|sizeof
name|ehdr
condition|)
goto|goto
name|bad
goto|;
name|data
operator|=
name|ehdr
operator|.
name|e_ident
index|[
name|EI_DATA
index|]
expr_stmt|;
name|shnum
operator|=
name|xe16toh
argument_list|(
name|ehdr
operator|.
name|e_shnum
argument_list|)
expr_stmt|;
name|shdrsize
operator|=
name|shnum
operator|*
name|xe16toh
argument_list|(
name|ehdr
operator|.
name|e_shentsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|shdrp
operator|=
name|xmalloc
argument_list|(
name|shdrsize
argument_list|,
name|fn
argument_list|,
literal|"section header table"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|xreadatoff
argument_list|(
name|fd
argument_list|,
name|shdrp
argument_list|,
name|xewtoh
argument_list|(
name|ehdr
operator|.
name|e_shoff
argument_list|)
argument_list|,
name|shdrsize
argument_list|,
name|fn
argument_list|)
operator|!=
name|shdrsize
condition|)
goto|goto
name|bad
goto|;
name|symtabshdr
operator|=
name|strtabshdr
operator|=
name|shstrtabshdr
operator|=
name|NULL
expr_stmt|;
name|weird
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shnum
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|xe32toh
argument_list|(
name|shdrp
index|[
name|i
index|]
operator|.
name|sh_type
argument_list|)
condition|)
block|{
case|case
name|SHT_SYMTAB
case|:
if|if
condition|(
name|symtabshdr
operator|!=
name|NULL
condition|)
block|{
name|weird
operator|=
literal|1
expr_stmt|;
name|weirdreason
operator|=
literal|"multiple symbol tables"
expr_stmt|;
block|}
name|symtabshdr
operator|=
operator|&
name|shdrp
index|[
name|i
index|]
expr_stmt|;
name|strtabshdr
operator|=
operator|&
name|shdrp
index|[
name|xe32toh
argument_list|(
name|shdrp
index|[
name|i
index|]
operator|.
name|sh_link
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|SHT_STRTAB
case|:
if|if
condition|(
name|i
operator|==
name|xe16toh
argument_list|(
name|ehdr
operator|.
name|e_shstrndx
argument_list|)
condition|)
name|shstrtabshdr
operator|=
operator|&
name|shdrp
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|symtabshdr
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|strtabshdr
operator|==
name|NULL
condition|)
block|{
name|weird
operator|=
literal|1
expr_stmt|;
name|weirdreason
operator|=
literal|"string table does not exist"
expr_stmt|;
block|}
if|if
condition|(
name|shstrtabshdr
operator|==
name|NULL
condition|)
block|{
name|weird
operator|=
literal|1
expr_stmt|;
name|weirdreason
operator|=
literal|"section header string table does not exist"
expr_stmt|;
block|}
if|if
condition|(
name|weirdreason
operator|==
name|NULL
condition|)
name|weirdreason
operator|=
literal|"unsupported"
expr_stmt|;
if|if
condition|(
name|weird
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: weird executable (%s)\n"
argument_list|,
name|fn
argument_list|,
name|weirdreason
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * sort section layout table by offset 	 */
name|layoutp
operator|=
name|xmalloc
argument_list|(
operator|(
name|shnum
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|shlayout
argument_list|)
argument_list|,
name|fn
argument_list|,
literal|"layout table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|layoutp
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* add a pseudo entry to represent the section header table */
name|shdrshdr
operator|.
name|sh_offset
operator|=
name|ehdr
operator|.
name|e_shoff
expr_stmt|;
name|shdrshdr
operator|.
name|sh_size
operator|=
name|htoxew
argument_list|(
name|shdrsize
argument_list|)
expr_stmt|;
name|shdrshdr
operator|.
name|sh_addralign
operator|=
name|htoxew
argument_list|(
name|ELFSIZE
operator|/
literal|8
argument_list|)
expr_stmt|;
name|layoutp
index|[
name|shnum
index|]
operator|.
name|shdr
operator|=
operator|&
name|shdrshdr
expr_stmt|;
comment|/* insert and sort normal section headers */
for|for
control|(
name|i
operator|=
name|shnum
init|;
name|i
operator|--
operator|!=
literal|0
condition|;
control|)
block|{
name|l
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|r
operator|=
name|shnum
expr_stmt|;
while|while
condition|(
name|l
operator|<=
name|r
condition|)
block|{
name|m
operator|=
operator|(
name|l
operator|+
name|r
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|xewtoh
argument_list|(
name|shdrp
index|[
name|i
index|]
operator|.
name|sh_offset
argument_list|)
operator|>
name|xewtoh
argument_list|(
name|layoutp
index|[
name|m
index|]
operator|.
name|shdr
operator|->
name|sh_offset
argument_list|)
condition|)
name|l
operator|=
name|m
operator|+
literal|1
expr_stmt|;
else|else
name|r
operator|=
name|m
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
name|i
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|layoutp
index|[
name|i
index|]
argument_list|,
operator|&
name|layoutp
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|shlayout
argument_list|)
operator|*
operator|(
name|r
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
name|layoutp
index|[
name|r
index|]
operator|.
name|shdr
operator|=
operator|&
name|shdrp
index|[
name|i
index|]
expr_stmt|;
name|layoutp
index|[
name|r
index|]
operator|.
name|bufp
operator|=
name|NULL
expr_stmt|;
block|}
operator|++
name|shnum
expr_stmt|;
comment|/* 	 * load up everything we need 	 */
comment|/* load section string table for debug use */
if|if
condition|(
operator|(
name|size
operator|=
name|xewtoh
argument_list|(
name|shstrtabshdr
operator|->
name|sh_size
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|(
name|shstrtabp
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|,
name|fn
argument_list|,
literal|"section string table"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|xreadatoff
argument_list|(
name|fd
argument_list|,
name|shstrtabp
argument_list|,
name|xewtoh
argument_list|(
name|shstrtabshdr
operator|->
name|sh_offset
argument_list|)
argument_list|,
name|size
argument_list|,
name|fn
argument_list|)
operator|!=
name|size
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|shstrtabp
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad
goto|;
comment|/* we need symtab, strtab, and everything behind strtab */
name|strtabidx
operator|=
name|INT_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|==
operator|&
name|shdrshdr
condition|)
block|{
comment|/* not load section header again */
name|layoutp
index|[
name|i
index|]
operator|.
name|bufp
operator|=
name|shdrp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|==
name|shstrtabshdr
condition|)
block|{
comment|/* not load section string table again */
name|layoutp
index|[
name|i
index|]
operator|.
name|bufp
operator|=
name|shstrtabp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|==
name|strtabshdr
condition|)
name|strtabidx
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|==
name|symtabshdr
operator|||
name|i
operator|>=
name|strtabidx
condition|)
block|{
name|off
operator|=
name|xewtoh
argument_list|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|xewtoh
argument_list|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|->
name|sh_size
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|layoutp
index|[
name|i
index|]
operator|.
name|bufp
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|,
name|fn
argument_list|,
name|shstrtabp
operator|+
name|xewtoh
argument_list|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|->
name|sh_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|layoutp
index|[
name|i
index|]
operator|.
name|bufp
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|xreadatoff
argument_list|(
name|fd
argument_list|,
name|layoutp
index|[
name|i
index|]
operator|.
name|bufp
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|fn
argument_list|)
operator|!=
name|size
condition|)
goto|goto
name|bad
goto|;
comment|/* set symbol table and string table */
if|if
condition|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|==
name|symtabshdr
condition|)
block|{
name|symtabp
operator|=
name|layoutp
index|[
name|i
index|]
operator|.
name|bufp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|==
name|strtabshdr
condition|)
block|{
name|strtabp
operator|=
name|layoutp
index|[
name|i
index|]
operator|.
name|bufp
expr_stmt|;
if|if
condition|(
name|strtabp
index|[
name|size
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
goto|goto
name|bad
goto|;
block|}
block|}
block|}
name|nstrtab_size
operator|=
literal|256
expr_stmt|;
name|nstrtabp
operator|=
name|xmalloc
argument_list|(
name|nstrtab_size
argument_list|,
name|fn
argument_list|,
literal|"new string table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstrtabp
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|nstrtab_nextoff
operator|=
literal|0
expr_stmt|;
name|fn_size
operator|=
name|strlen
argument_list|(
name|fn
argument_list|)
expr_stmt|;
comment|/* Prepare data structures for symbol movement. */
name|nsyms
operator|=
name|xewtoh
argument_list|(
name|symtabshdr
operator|->
name|sh_size
argument_list|)
operator|/
name|xewtoh
argument_list|(
name|symtabshdr
operator|->
name|sh_entsize
argument_list|)
expr_stmt|;
comment|/* move symbols, making them local */
for|for
control|(
name|ewi
operator|=
literal|0
init|;
name|ewi
operator|<
name|nsyms
condition|;
name|ewi
operator|++
control|)
block|{
name|Elf_Sym
modifier|*
name|sp
init|=
operator|&
name|symtabp
index|[
name|ewi
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
init|=
name|strtabp
operator|+
name|xe32toh
argument_list|(
name|sp
operator|->
name|st_name
argument_list|)
decl_stmt|;
name|size_t
name|newent_len
decl_stmt|;
comment|/* 		 * make sure there's size for the next entry, even if it's 		 * as large as it can be. 		 * 		 * "_$$hide$$<filename><symname><NUL>" -> 		 *    9 + 3 + sizes of fn and sym name 		 */
while|while
condition|(
operator|(
name|nstrtab_size
operator|-
name|nstrtab_nextoff
operator|)
operator|<
name|strlen
argument_list|(
name|symname
argument_list|)
operator|+
name|fn_size
operator|+
literal|12
condition|)
block|{
name|nstrtab_size
operator|*=
literal|2
expr_stmt|;
name|nstrtabp
operator|=
name|xrealloc
argument_list|(
name|nstrtabp
argument_list|,
name|nstrtab_size
argument_list|,
name|fn
argument_list|,
literal|"new string table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstrtabp
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
name|sp
operator|->
name|st_name
operator|=
name|htowew
argument_list|(
name|nstrtab_nextoff
argument_list|)
expr_stmt|;
comment|/* if it's a keeper or is undefined, don't rename it. */
if|if
condition|(
name|in_keep_list
argument_list|(
name|symname
argument_list|)
operator|||
operator|(
name|xe16toh
argument_list|(
name|sp
operator|->
name|st_shndx
argument_list|)
operator|==
name|SHN_UNDEF
operator|)
condition|)
block|{
name|newent_len
operator|=
name|sprintf
argument_list|(
name|nstrtabp
operator|+
name|nstrtab_nextoff
argument_list|,
literal|"%s"
argument_list|,
name|symname
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|newent_len
operator|=
name|sprintf
argument_list|(
name|nstrtabp
operator|+
name|nstrtab_nextoff
argument_list|,
literal|"_$$hide$$ %s %s"
argument_list|,
name|fn
argument_list|,
name|symname
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|nstrtab_nextoff
operator|+=
name|newent_len
expr_stmt|;
block|}
name|strtabshdr
operator|->
name|sh_size
operator|=
name|htoxew
argument_list|(
name|nstrtab_nextoff
argument_list|)
expr_stmt|;
comment|/* 	 * update section header table in ascending order of offset 	 */
for|for
control|(
name|i
operator|=
name|strtabidx
operator|+
literal|1
init|;
name|i
operator|<
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Off
name|off
decl_stmt|,
name|align
decl_stmt|;
name|off
operator|=
name|xewtoh
argument_list|(
name|layoutp
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|shdr
operator|->
name|sh_offset
argument_list|)
operator|+
name|xewtoh
argument_list|(
name|layoutp
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|shdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
name|align
operator|=
name|xewtoh
argument_list|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|->
name|sh_addralign
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|off
operator|+
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|->
name|sh_offset
operator|=
name|htoxew
argument_list|(
name|off
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * write data to the file in descending order of offset 	 */
for|for
control|(
name|i
operator|=
name|shnum
init|;
name|i
operator|--
operator|!=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|==
name|strtabshdr
condition|)
block|{
comment|/* new string table */
name|buf
operator|=
name|nstrtabp
expr_stmt|;
block|}
else|else
name|buf
operator|=
name|layoutp
index|[
name|i
index|]
operator|.
name|bufp
expr_stmt|;
if|if
condition|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|==
operator|&
name|shdrshdr
operator|||
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|==
name|symtabshdr
operator|||
name|i
operator|>=
name|strtabidx
condition|)
block|{
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* 			 * update the offset of section header table in elf 			 * header if needed. 			 */
if|if
condition|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|==
operator|&
name|shdrshdr
operator|&&
name|ehdr
operator|.
name|e_shoff
operator|!=
name|shdrshdr
operator|.
name|sh_offset
condition|)
block|{
name|ehdr
operator|.
name|e_shoff
operator|=
name|shdrshdr
operator|.
name|sh_offset
expr_stmt|;
name|off
operator|=
name|offsetof
argument_list|(
name|Elf_Ehdr
argument_list|,
name|e_shoff
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Off
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|xwriteatoff
argument_list|(
name|fd
argument_list|,
operator|&
name|ehdr
operator|.
name|e_shoff
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|fn
argument_list|)
operator|!=
name|size
condition|)
goto|goto
name|bad
goto|;
block|}
name|off
operator|=
name|xewtoh
argument_list|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|->
name|sh_offset
argument_list|)
expr_stmt|;
name|size
operator|=
name|xewtoh
argument_list|(
name|layoutp
index|[
name|i
index|]
operator|.
name|shdr
operator|->
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|xwriteatoff
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|fn
argument_list|)
operator|!=
name|size
condition|)
goto|goto
name|bad
goto|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|layoutp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|layoutp
index|[
name|i
index|]
operator|.
name|bufp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|layoutp
index|[
name|i
index|]
operator|.
name|bufp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|layoutp
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|nstrtabp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
name|bad
label|:
name|rv
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* include this size of ELF */
end_comment

end_unit

