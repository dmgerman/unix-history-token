begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 University of Maryland  * All Rights Reserved.  *  * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the name of U.M. not be used in advertising or  * publicity pertaining to distribution of the software without specific,  * written prior permission.  U.M. makes no representations about the  * suitability of this software for any purpose.  It is provided "as is"  * without express or implied warranty.  *  * U.M. DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL U.M.  * BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION  * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  *  * Author: James da Silva, Systems Design and Analysis Group  *			   Computer Science Department  *			   University of Maryland at College Park  */
end_comment

begin_comment
comment|/*  * crunchide.c - tiptoes through an a.out symbol table, hiding all defined  *	global symbols.  Allows the user to supply a "keep list" of symbols  *	that are not to be hidden.  This program relies on the use of the  * 	linker's -dc flag to actually put global bss data into the file's  * 	bss segment (rather than leaving it as undefined "common" data).  *  * 	The point of all this is to allow multiple programs to be linked  *	together without getting multiple-defined errors.  *  *	For example, consider a program "foo.c".  It can be linked with a  *	small stub routine, called "foostub.c", eg:  *	    int foo_main(int argc, char **argv){ return main(argc, argv); }  *      like so:  *	    cc -c foo.c foostub.c  *	    ld -dc -r foo.o foostub.o -o foo.combined.o  *	    crunchide -k _foo_main foo.combined.o  *	at this point, foo.combined.o can be linked with another program  * 	and invoked with "foo_main(argc, argv)".  foo's main() and any  * 	other globals are hidden and will not conflict with other symbols.  *  * TODO:  *	- resolve the theoretical hanging reloc problem (see check_reloc()  *	  below). I have yet to see this problem actually occur in any real  *	  program. In what cases will gcc/gas generate code that needs a  *	  relative reloc from a global symbol, other than PIC?  The  *	  solution is to not hide the symbol from the linker in this case,  *	  but to generate some random name for it so that it doesn't link  *	  with anything but holds the place for the reloc.  *      - arrange that all the BSS segments start at the same address, so  *	  that the final crunched binary BSS size is the max of all the  *	  component programs' BSS sizes, rather than their sum.  */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_decl_stmt
name|char
modifier|*
name|pname
init|=
literal|"crunchide"
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_to_keep_list
parameter_list|(
name|char
modifier|*
name|symbol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|add_file_to_keep_list
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|hide_syms
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
name|pname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"k:f:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'k'
case|:
name|add_to_keep_list
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|add_file_to_keep_list
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
while|while
condition|(
name|argc
condition|)
block|{
name|hide_syms
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-k<symbol-name>] [-f<keep-list-file>]<files> ...\n"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------------- */
end_comment

begin_struct
struct|struct
name|keep
block|{
name|struct
name|keep
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
block|}
modifier|*
name|keep_list
struct|;
end_struct

begin_function
name|void
name|add_to_keep_list
parameter_list|(
name|char
modifier|*
name|symbol
parameter_list|)
block|{
name|struct
name|keep
modifier|*
name|newp
decl_stmt|,
modifier|*
name|prevp
decl_stmt|,
modifier|*
name|curp
decl_stmt|;
name|int
name|cmp
decl_stmt|;
for|for
control|(
name|curp
operator|=
name|keep_list
operator|,
name|prevp
operator|=
name|NULL
init|;
name|curp
condition|;
name|prevp
operator|=
name|curp
operator|,
name|curp
operator|=
name|curp
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|cmp
operator|=
name|strcmp
argument_list|(
name|symbol
argument_list|,
name|curp
operator|->
name|sym
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|curp
operator|&&
name|cmp
operator|==
literal|0
condition|)
return|return;
comment|/* already in table */
name|newp
operator|=
operator|(
expr|struct
name|keep
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|keep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newp
condition|)
name|newp
operator|->
name|sym
operator|=
name|strdup
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|newp
operator|==
name|NULL
operator|||
name|newp
operator|->
name|sym
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: out of memory for keep list\n"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|newp
operator|->
name|next
operator|=
name|curp
expr_stmt|;
if|if
condition|(
name|prevp
condition|)
name|prevp
operator|->
name|next
operator|=
name|newp
expr_stmt|;
else|else
name|keep_list
operator|=
name|newp
expr_stmt|;
block|}
end_function

begin_function
name|int
name|in_keep_list
parameter_list|(
name|char
modifier|*
name|symbol
parameter_list|)
block|{
name|struct
name|keep
modifier|*
name|curp
decl_stmt|;
name|int
name|cmp
decl_stmt|;
for|for
control|(
name|curp
operator|=
name|keep_list
init|;
name|curp
condition|;
name|curp
operator|=
name|curp
operator|->
name|next
control|)
if|if
condition|(
operator|(
name|cmp
operator|=
name|strcmp
argument_list|(
name|symbol
argument_list|,
name|curp
operator|->
name|sym
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
return|return
name|curp
operator|&&
name|cmp
operator|==
literal|0
return|;
block|}
end_function

begin_function
name|void
name|add_file_to_keep_list
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|keepf
decl_stmt|;
name|char
name|symbol
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|keepf
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|symbol
argument_list|,
literal|1024
argument_list|,
name|keepf
argument_list|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|symbol
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|symbol
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|add_to_keep_list
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|keepf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ---------------------- */
end_comment

begin_decl_stmt
name|int
name|nsyms
decl_stmt|,
name|ntextrel
decl_stmt|,
name|ndatarel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|exec
modifier|*
name|hdrp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|aoutdata
decl_stmt|,
modifier|*
name|strbase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|relocation_info
modifier|*
name|textrel
decl_stmt|,
modifier|*
name|datarel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|symbase
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SYMSTR
parameter_list|(
name|sp
parameter_list|)
value|&strbase[(sp)->n_un.n_strx]
end_define

begin_comment
comment|/* is the symbol a global symbol defined in the current file? */
end_comment

begin_define
define|#
directive|define
name|IS_GLOBAL_DEFINED
parameter_list|(
name|sp
parameter_list|)
define|\
value|(((sp)->n_type& N_EXT)&& ((sp)->n_type& N_TYPE) != N_UNDF)
end_define

begin_comment
comment|/* is the relocation entry dependent on a symbol? */
end_comment

begin_define
define|#
directive|define
name|IS_SYMBOL_RELOC
parameter_list|(
name|rp
parameter_list|)
define|\
value|((rp)->r_extern||(rp)->r_baserel||(rp)->r_jmptable)
end_define

begin_function_decl
name|void
name|check_reloc
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|relocation_info
modifier|*
name|relp
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|hide_syms
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|inf
decl_stmt|,
name|outf
decl_stmt|,
name|rc
decl_stmt|;
name|struct
name|stat
name|infstat
decl_stmt|;
name|struct
name|relocation_info
modifier|*
name|relp
decl_stmt|;
name|struct
name|nlist
modifier|*
name|symp
decl_stmt|;
comment|/*      * Open the file and do some error checking.      */
if|if
condition|(
operator|(
name|inf
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|inf
argument_list|,
operator|&
name|infstat
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|infstat
operator|.
name|st_size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|exec
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: short file\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Read the entire file into memory.  XXX - Really, we only need to      * read the header and from TRELOFF to the end of the file.      */
if|if
condition|(
operator|(
name|aoutdata
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|infstat
operator|.
name|st_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: too big to read into memory\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|read
argument_list|(
name|inf
argument_list|,
name|aoutdata
argument_list|,
name|infstat
operator|.
name|st_size
argument_list|)
operator|)
operator|<
name|infstat
operator|.
name|st_size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: read error: %s\n"
argument_list|,
name|filename
argument_list|,
name|rc
operator|==
operator|-
literal|1
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"short read"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Check the header and calculate offsets and sizes from it.      */
name|hdrp
operator|=
operator|(
expr|struct
name|exec
operator|*
operator|)
name|aoutdata
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
operator|*
name|hdrp
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: bad magic: not an a.out file\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|textrel
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_RELOFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|)
expr_stmt|;
name|datarel
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_RELOFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|+
name|hdrp
operator|->
name|a_trsize
operator|)
expr_stmt|;
else|#
directive|else
name|textrel
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_TRELOFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|)
expr_stmt|;
name|datarel
operator|=
operator|(
expr|struct
name|relocation_info
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_DRELOFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|symbase
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_SYMOFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|)
expr_stmt|;
name|strbase
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|aoutdata
operator|+
name|N_STROFF
argument_list|(
operator|*
name|hdrp
argument_list|)
operator|)
expr_stmt|;
name|ntextrel
operator|=
name|hdrp
operator|->
name|a_trsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
name|ndatarel
operator|=
name|hdrp
operator|->
name|a_drsize
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|relocation_info
argument_list|)
expr_stmt|;
name|nsyms
operator|=
name|hdrp
operator|->
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
comment|/*      * Zap the type field of all globally-defined symbols.  The linker will      * subsequently ignore these entries.  Don't zap any symbols in the      * keep list.      */
for|for
control|(
name|symp
operator|=
name|symbase
init|;
name|symp
operator|<
name|symbase
operator|+
name|nsyms
condition|;
name|symp
operator|++
control|)
if|if
condition|(
name|IS_GLOBAL_DEFINED
argument_list|(
name|symp
argument_list|)
operator|&&
operator|!
name|in_keep_list
argument_list|(
name|SYMSTR
argument_list|(
name|symp
argument_list|)
argument_list|)
condition|)
name|symp
operator|->
name|n_type
operator|=
literal|0
expr_stmt|;
comment|/*      * Check whether the relocation entries reference any symbols that we      * just zapped.  I don't know whether ld can handle this case, but I      * haven't encountered it yet.  These checks are here so that the program      * doesn't fail silently should such symbols be encountered.      */
for|for
control|(
name|relp
operator|=
name|textrel
init|;
name|relp
operator|<
name|textrel
operator|+
name|ntextrel
condition|;
name|relp
operator|++
control|)
name|check_reloc
argument_list|(
name|filename
argument_list|,
name|relp
argument_list|)
expr_stmt|;
for|for
control|(
name|relp
operator|=
name|datarel
init|;
name|relp
operator|<
name|datarel
operator|+
name|ndatarel
condition|;
name|relp
operator|++
control|)
name|check_reloc
argument_list|(
name|filename
argument_list|,
name|relp
argument_list|)
expr_stmt|;
comment|/*      * Write the .o file back out to disk.  XXX - Really, we only need to      * write the symbol table entries back out.      */
name|lseek
argument_list|(
name|inf
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|write
argument_list|(
name|inf
argument_list|,
name|aoutdata
argument_list|,
name|infstat
operator|.
name|st_size
argument_list|)
operator|)
operator|<
name|infstat
operator|.
name|st_size
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: write error: %s\n"
argument_list|,
name|filename
argument_list|,
name|rc
operator|==
operator|-
literal|1
condition|?
name|strerror
argument_list|(
name|errno
argument_list|)
else|:
literal|"short write"
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|check_reloc
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|relocation_info
modifier|*
name|relp
parameter_list|)
block|{
comment|/* bail out if we zapped a symbol that is needed */
if|if
condition|(
name|IS_SYMBOL_RELOC
argument_list|(
name|relp
argument_list|)
operator|&&
name|symbase
index|[
name|relp
operator|->
name|r_symbolnum
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: oops, have hanging relocation for %s: bailing out!\n"
argument_list|,
name|filename
argument_list|,
name|SYMSTR
argument_list|(
operator|&
name|symbase
index|[
name|relp
operator|->
name|r_symbolnum
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

