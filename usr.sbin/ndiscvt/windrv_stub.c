begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005  *      Bill Paul<wpaul@windriver.com>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_define
define|#
directive|define
name|NDIS_REGVALS
end_define

begin_struct
struct|struct
name|ndis_cfg
block|{
name|char
modifier|*
name|nc_cfgkey
decl_stmt|;
name|char
modifier|*
name|nc_cfgdesc
decl_stmt|;
name|char
name|nc_val
index|[
literal|256
index|]
decl_stmt|;
name|int
name|nc_idx
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ndis_cfg
name|ndis_cfg
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"windrv.h"
end_include

begin_struct
struct|struct
name|ndis_pci_type
block|{
name|uint16_t
name|ndis_vid
decl_stmt|;
name|uint16_t
name|ndis_did
decl_stmt|;
name|uint32_t
name|ndis_subsys
decl_stmt|;
name|char
modifier|*
name|ndis_name
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ndis_pccard_type
block|{
specifier|const
name|char
modifier|*
name|ndis_vid
decl_stmt|;
specifier|const
name|char
modifier|*
name|ndis_did
decl_stmt|;
name|char
modifier|*
name|ndis_name
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|NDIS_PCI_DEV_TABLE
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|ndis_pci_type
name|ndis_devs_pci
index|[]
init|=
block|{
name|NDIS_PCI_DEV_TABLE
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NDIS_PCMCIA_DEV_TABLE
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|ndis_pccard_type
name|ndis_devs_pccard
index|[]
init|=
block|{
name|NDIS_PCMCIA_DEV_TABLE
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|interface_type
block|{
name|InterfaceTypeUndefined
init|=
operator|-
literal|1
block|,
name|Internal
block|,
name|Isa
block|,
name|Eisa
block|,
name|MicroChannel
block|,
name|TurboChannel
block|,
name|PCIBus
block|,
name|VMEBus
block|,
name|NuBus
block|,
name|PCMCIABus
block|,
name|CBus
block|,
name|MPIBus
block|,
name|MPSABus
block|,
name|ProcessorInternal
block|,
name|InternalPowerBus
block|,
name|PNPISABus
block|,
name|PNPBus
block|,
name|MaximumInterfaceType
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|enum
name|interface_type
name|interface_type
typedef|;
end_typedef

begin_comment
comment|/*  * XXX  * Ordinarily, device_probe_desc is defined in device_if.h, which  * is created from device_if.m. The problem is, the latter file  * is only available if you have the kernel source code installed,  * and not all users choose to install it. I'd like to let people  * load Windows driver modules with the minimal amount of hassle  * and dependencies.<sys/bus.h> wants both device_if.h and bus_if.h  * to be defined, but it turns out the only thing we really need  * to get this module compiled is device_probe_desc, so we define  * that here, and let the build script create empty copies of  * device_if.h and bus_if.h to make the compiler happy.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|kobjop_desc
name|device_probe_desc
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
name|device_probe_t
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|extern
name|int
name|windrv_load
parameter_list|(
name|module_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|size_t
parameter_list|,
name|interface_type
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|windrv_unload
parameter_list|(
name|module_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|DRV_DATA_START
end_ifndef

begin_define
define|#
directive|define
name|DRV_DATA_START
value|UNDEF_START
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DRV_DATA_END
end_ifndef

begin_define
define|#
directive|define
name|DRV_DATA_END
value|UNDEF_END
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DRV_NAME
end_ifndef

begin_define
define|#
directive|define
name|DRV_NAME
value|UNDEF_NAME
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|uint8_t
name|DRV_DATA_START
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uint8_t
name|DRV_DATA_END
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following is stub code that makes it look as though we want  * to be a child device of all the buses that our supported devices  * might want to attach to. Our probe routine always fails. The  * reason we need this code is so that loading an ELF-ified Windows  * driver module will trigger a bus reprobe.  */
end_comment

begin_define
define|#
directive|define
name|MODULE_DECL
parameter_list|(
name|x
parameter_list|)
define|\
value|MODULE_DEPEND(x, ndisapi, 1, 1, 1);	\ 	MODULE_DEPEND(x, ndis, 1, 1, 1)
end_define

begin_expr_stmt
name|MODULE_DECL
argument_list|(
name|DRV_NAME
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|windrv_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|windrv_modevent
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|windrv_loaded
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|windrv_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|windrv_probe
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|windrv_driver
init|=
block|{
literal|"windrv_stub"
block|,
name|windrv_methods
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|windrv_devclass
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DRIVER_DECL
parameter_list|(
name|x
parameter_list|)
define|\
value|DRIVER_MODULE(x, pci, windrv_driver,		\ 	    windrv_devclass, windrv_modevent, NULL);	\ 	DRIVER_MODULE(x, cardbus, windrv_driver,	\ 	    windrv_devclass, windrv_modevent, NULL);	\ 	DRIVER_MODULE(x, pccard, windrv_driver,		\ 	    windrv_devclass, windrv_modevent, NULL);	\ 	DRIVER_MODULE(x, uhub, windrv_driver,		\ 	    windrv_devclass, windrv_modevent, NULL);	\ 	MODULE_VERSION(x, 1)
end_define

begin_expr_stmt
name|DRIVER_DECL
argument_list|(
name|DRV_NAME
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|windrv_probe
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|windrv_modevent
parameter_list|(
name|mod
parameter_list|,
name|cmd
parameter_list|,
name|arg
parameter_list|)
name|module_t
name|mod
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|drv_data_len
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|vm_offset_t
name|drv_data_start
decl_stmt|;
name|vm_offset_t
name|drv_data_end
decl_stmt|;
name|drv_data_start
operator|=
operator|(
name|vm_offset_t
operator|)
operator|&
name|DRV_DATA_START
expr_stmt|;
name|drv_data_end
operator|=
operator|(
name|vm_offset_t
operator|)
operator|&
name|DRV_DATA_END
expr_stmt|;
name|drv_data_len
operator|=
name|drv_data_end
operator|-
name|drv_data_start
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|windrv_loaded
operator|++
expr_stmt|;
if|if
condition|(
name|windrv_loaded
operator|>
literal|1
condition|)
break|break;
ifdef|#
directive|ifdef
name|NDIS_PCI_DEV_TABLE
name|windrv_load
argument_list|(
name|mod
argument_list|,
name|drv_data_start
argument_list|,
name|drv_data_len
argument_list|,
name|PCIBus
argument_list|,
name|ndis_devs_pci
argument_list|,
operator|&
name|ndis_regvals
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NDIS_PCMCIA_DEV_TABLE
name|windrv_load
argument_list|(
name|mod
argument_list|,
name|drv_data_start
argument_list|,
name|drv_data_len
argument_list|,
name|PCMCIABus
argument_list|,
name|ndis_devs_pccard
argument_list|,
operator|&
name|ndis_regvals
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|MOD_UNLOAD
case|:
name|windrv_loaded
operator|--
expr_stmt|;
if|if
condition|(
name|windrv_loaded
operator|>
literal|0
condition|)
break|break;
ifdef|#
directive|ifdef
name|NDIS_PCI_DEV_TABLE
name|windrv_unload
argument_list|(
name|mod
argument_list|,
name|drv_data_start
argument_list|,
name|drv_data_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NDIS_PCMCIA_DEV_TABLE
name|windrv_unload
argument_list|(
name|mod
argument_list|,
name|drv_data_start
argument_list|,
name|drv_data_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

