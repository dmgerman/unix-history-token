begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995, 1996  *	Bill Paul<wpaul@ctr.columbia.edu>. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Do standard and reverse DNS lookups using the resolver library.  * Take care of all the dirty work here so the main program only has to  * pass us a pointer to an array of characters.  *  * We have to use direct resolver calls here otherwise the YP server  * could end up looping by calling itself over and over again until  * it disappeared up its own belly button.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/yp.h>
end_include

begin_include
include|#
directive|include
file|"yp_extern.h"
end_include

begin_function
specifier|static
name|char
modifier|*
name|parse
parameter_list|(
name|hp
parameter_list|)
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
block|{
specifier|static
name|char
name|result
index|[
name|MAXHOSTNAMELEN
operator|*
literal|2
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|len
operator|=
literal|16
operator|+
name|strlen
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hp
operator|->
name|h_aliases
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|hp
operator|->
name|h_aliases
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|result
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|result
argument_list|,
sizeof|sizeof
argument_list|(
name|result
argument_list|)
argument_list|,
literal|"%s %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|hp
operator|->
name|h_aliases
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|strcat
argument_list|(
name|result
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|result
argument_list|,
name|hp
operator|->
name|h_aliases
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXPACKET
value|1024
end_define

begin_define
define|#
directive|define
name|DEF_TTL
value|50
end_define

begin_define
define|#
directive|define
name|BY_DNS_ID
value|1
end_define

begin_define
define|#
directive|define
name|BY_RPC_XID
value|2
end_define

begin_decl_stmt
specifier|extern
name|struct
name|hostent
modifier|*
name|__dns_getanswer
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|dns_qhead
argument_list|,
argument|circleq_dnsentry
argument_list|)
name|qhead
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|circleq_dnsentry
block|{
name|SVCXPRT
modifier|*
name|xprt
decl_stmt|;
name|unsigned
name|long
name|xid
decl_stmt|;
name|struct
name|sockaddr_in
name|client_addr
decl_stmt|;
name|unsigned
name|long
name|ypvers
decl_stmt|;
name|unsigned
name|long
name|id
decl_stmt|;
name|unsigned
name|long
name|ttl
decl_stmt|;
name|unsigned
name|long
name|type
decl_stmt|;
name|unsigned
name|short
name|prot_type
decl_stmt|;
name|char
modifier|*
modifier|*
name|domain
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|circleq_dnsentry
argument_list|)
name|links
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|pending
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|yp_init_resolver
parameter_list|()
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|qhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|&&
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"res_init failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|resfd
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"couldn't create socket"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fcntl
argument_list|(
name|resfd
argument_list|,
name|F_SETFL
argument_list|,
name|O_NONBLOCK
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"couldn't make resolver socket non-blocking"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|circleq_dnsentry
modifier|*
name|yp_malloc_dnsent
parameter_list|()
block|{
specifier|register
name|struct
name|circleq_dnsentry
modifier|*
name|q
decl_stmt|;
name|q
operator|=
operator|(
expr|struct
name|circleq_dnsentry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|circleq_dnsentry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"failed to malloc() circleq dns entry"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit a query.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|yp_send_dns_query
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|char
name|buf
index|[
name|MAXPACKET
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|HEADER
modifier|*
name|hptr
decl_stmt|;
name|int
name|ns
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|unsigned
name|long
name|id
decl_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|name
argument_list|,
name|C_IN
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|yp_error
argument_list|(
literal|"res_mkquery failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hptr
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|&
name|buf
expr_stmt|;
name|id
operator|=
name|ntohs
argument_list|(
name|hptr
operator|->
name|id
argument_list|)
expr_stmt|;
for|for
control|(
name|ns
operator|=
literal|0
init|;
name|ns
operator|<
name|_res
operator|.
name|nscount
condition|;
name|ns
operator|++
control|)
block|{
name|rval
operator|=
name|sendto
argument_list|(
name|resfd
argument_list|,
name|buf
argument_list|,
name|n
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|_res
operator|.
name|nsaddr_list
index|[
name|ns
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"sendto failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|circleq_dnsentry
modifier|*
name|yp_find_dnsqent
parameter_list|(
name|id
parameter_list|,
name|type
parameter_list|)
name|unsigned
name|long
name|id
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
specifier|register
name|struct
name|circleq_dnsentry
modifier|*
name|q
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&qhead
argument_list|,
argument|links
argument_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BY_RPC_XID
case|:
if|if
condition|(
name|id
operator|==
name|q
operator|->
name|xid
condition|)
return|return
operator|(
name|q
operator|)
return|;
break|break;
case|case
name|BY_DNS_ID
case|:
default|default:
if|if
condition|(
name|id
operator|==
name|q
operator|->
name|id
condition|)
return|return
operator|(
name|q
operator|)
return|;
break|break;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|yp_send_dns_reply
parameter_list|(
name|q
parameter_list|,
name|buf
parameter_list|)
name|struct
name|circleq_dnsentry
modifier|*
name|q
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|ypresponse
name|result_v1
decl_stmt|;
name|ypresp_val
name|result_v2
decl_stmt|;
name|unsigned
name|long
name|xid
decl_stmt|;
name|struct
name|sockaddr_in
name|client_addr
decl_stmt|;
name|xdrproc_t
name|xdrfunc
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* 	 * Set up correct reply struct and 	 * XDR filter depending on ypvers. 	 */
switch|switch
condition|(
name|q
operator|->
name|ypvers
condition|)
block|{
case|case
name|YPVERS
case|:
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|result_v2
argument_list|,
sizeof|sizeof
argument_list|(
name|result_v2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|result_v2
operator|.
name|stat
operator|=
name|YP_NOKEY
expr_stmt|;
else|else
block|{
name|result_v2
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|result_v2
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|buf
expr_stmt|;
name|result_v2
operator|.
name|stat
operator|=
name|YP_TRUE
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|result_v2
expr_stmt|;
name|xdrfunc
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_ypresp_val
expr_stmt|;
break|break;
case|case
name|YPOLDVERS
case|:
comment|/* 		 * The odds are we will _never_ execute this 		 * particular code, but we include it anyway 		 * for the sake of completeness. 		 */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|result_v1
argument_list|,
sizeof|sizeof
argument_list|(
name|result_v1
argument_list|)
argument_list|)
expr_stmt|;
name|result_v1
operator|.
name|yp_resptype
operator|=
name|YPRESP_VAL
expr_stmt|;
define|#
directive|define
name|YPVAL
value|ypresponse_u.yp_resp_valtype
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|result_v1
operator|.
name|YPVAL
operator|.
name|stat
operator|=
name|YP_NOKEY
expr_stmt|;
else|else
block|{
name|result_v1
operator|.
name|YPVAL
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|result_v1
operator|.
name|YPVAL
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|buf
expr_stmt|;
name|result_v1
operator|.
name|YPVAL
operator|.
name|stat
operator|=
name|YP_TRUE
expr_stmt|;
block|}
name|result
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|result_v1
expr_stmt|;
name|xdrfunc
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_ypresponse
expr_stmt|;
break|break;
default|default:
name|yp_error
argument_list|(
literal|"bad YP program version (%lu)!"
argument_list|,
name|q
operator|->
name|ypvers
argument_list|)
expr_stmt|;
return|return;
break|break;
block|}
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"sending dns reply to %s (%lu)"
argument_list|,
name|inet_ntoa
argument_list|(
name|q
operator|->
name|client_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|q
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * XXX This is disgusting. There's basically one transport 	 * handle for UDP, but we're holding off on replying to a 	 * client until we're ready, by which time we may have received 	 * several other queries from other clients with different 	 * transaction IDs. So to make the delayed response thing work, 	 * we have to save the transaction ID and client address of 	 * each request, then jam them into the transport handle when 	 * we're ready to send a reply. Then after we've send the reply, 	 * we put the old transaction ID and remote address back the 	 * way we found 'em. This is _INCREDIBLY_ non-portable; it's 	 * not even supported by the RPC library. 	 */
comment|/* 	 * XXX Don't frob the transaction ID for TCP handles. 	 */
if|if
condition|(
name|q
operator|->
name|prot_type
operator|==
name|SOCK_DGRAM
condition|)
name|xid
operator|=
name|svcudp_set_xid
argument_list|(
name|q
operator|->
name|xprt
argument_list|,
name|q
operator|->
name|xid
argument_list|)
expr_stmt|;
name|client_addr
operator|=
name|q
operator|->
name|xprt
operator|->
name|xp_raddr
expr_stmt|;
name|q
operator|->
name|xprt
operator|->
name|xp_raddr
operator|=
name|q
operator|->
name|client_addr
expr_stmt|;
if|if
condition|(
operator|!
name|svc_sendreply
argument_list|(
name|q
operator|->
name|xprt
argument_list|,
name|xdrfunc
argument_list|,
name|result
argument_list|)
condition|)
name|yp_error
argument_list|(
literal|"svc_sendreply failed"
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we sent the reply, 	 * put the handle back the way it was. 	 */
if|if
condition|(
name|q
operator|->
name|prot_type
operator|==
name|SOCK_DGRAM
condition|)
name|svcudp_set_xid
argument_list|(
name|q
operator|->
name|xprt
argument_list|,
name|xid
argument_list|)
expr_stmt|;
name|q
operator|->
name|xprt
operator|->
name|xp_raddr
operator|=
name|client_addr
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Decrement TTL on all queue entries, possibly nuking  * any that have been around too long without being serviced.  */
end_comment

begin_function
name|void
name|yp_prune_dnsq
parameter_list|()
block|{
specifier|register
name|struct
name|circleq_dnsentry
modifier|*
name|q
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|q
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|qhead
argument_list|)
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|q
operator|->
name|ttl
operator|--
expr_stmt|;
name|n
operator|=
name|TAILQ_NEXT
argument_list|(
name|q
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|ttl
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|qhead
argument_list|,
name|q
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|pending
operator|--
expr_stmt|;
block|}
name|q
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|pending
operator|<
literal|0
condition|)
name|pending
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Data is pending on the DNS socket; check for valid replies  * to our queries and dispatch them to waiting clients.  */
end_comment

begin_function
name|void
name|yp_run_dnsq
parameter_list|()
block|{
specifier|register
name|struct
name|circleq_dnsentry
modifier|*
name|q
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
operator|+
name|MAXPACKET
index|]
decl_stmt|;
name|char
name|retrybuf
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|int
name|len
decl_stmt|;
name|HEADER
modifier|*
name|hptr
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hent
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"running dns queue"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|rval
operator|=
name|recvfrom
argument_list|(
name|resfd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
operator|-
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"recvfrom failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We may have data left in the socket that represents 	 * replies to earlier queries that we don't care about 	 * anymore. If there are no lookups pending or the packet 	 * ID doesn't match any of the queue IDs, just drop it 	 * on the floor. 	 */
name|hptr
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|&
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|pending
operator|||
operator|(
name|q
operator|=
name|yp_find_dnsqent
argument_list|(
name|ntohs
argument_list|(
name|hptr
operator|->
name|id
argument_list|)
argument_list|,
name|BY_DNS_ID
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* ignore */
return|return;
block|}
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"got dns reply from %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|hent
operator|=
name|__dns_getanswer
argument_list|(
name|buf
argument_list|,
name|rval
argument_list|,
name|q
operator|->
name|name
argument_list|,
name|q
operator|->
name|type
argument_list|)
expr_stmt|;
comment|/* 	 * If the lookup failed, try appending one of the domains 	 * from resolv.conf. If we have no domains to test, the 	 * query has failed. 	 */
if|if
condition|(
name|hent
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|h_errno
operator|==
name|TRY_AGAIN
operator|||
name|h_errno
operator|==
name|NO_RECOVERY
operator|)
operator|&&
name|q
operator|->
name|domain
operator|&&
operator|*
name|q
operator|->
name|domain
condition|)
block|{
name|snprintf
argument_list|(
name|retrybuf
argument_list|,
sizeof|sizeof
argument_list|(
name|retrybuf
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|q
operator|->
name|name
argument_list|,
operator|*
name|q
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"retrying with: %s"
argument_list|,
name|retrybuf
argument_list|)
expr_stmt|;
name|q
operator|->
name|id
operator|=
name|yp_send_dns_query
argument_list|(
name|retrybuf
argument_list|,
name|q
operator|->
name|type
argument_list|)
expr_stmt|;
name|q
operator|->
name|ttl
operator|=
name|DEF_TTL
expr_stmt|;
name|q
operator|->
name|domain
operator|++
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|q
operator|->
name|type
operator|==
name|T_PTR
condition|)
block|{
name|hent
operator|->
name|h_addr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|q
operator|->
name|addr
operator|.
name|s_addr
expr_stmt|;
name|hent
operator|->
name|h_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Got an answer ready for a client -- send it off. */
name|yp_send_dns_reply
argument_list|(
name|q
argument_list|,
name|parse
argument_list|(
name|hent
argument_list|)
argument_list|)
expr_stmt|;
name|pending
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|qhead
argument_list|,
name|q
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* Decrement TTLs on other entries while we're here. */
name|yp_prune_dnsq
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Queue and transmit an asynchronous DNS hostname lookup.  */
end_comment

begin_function
name|ypstat
name|yp_async_lookup_name
parameter_list|(
name|rqstp
parameter_list|,
name|name
parameter_list|)
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|circleq_dnsentry
modifier|*
name|q
decl_stmt|;
name|int
name|type
decl_stmt|,
name|len
decl_stmt|;
comment|/* Check for SOCK_DGRAM or SOCK_STREAM -- we need to know later */
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|rqstp
operator|->
name|rq_xprt
operator|->
name|xp_fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_TYPE
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"getsockopt failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|YP_YPERR
operator|)
return|;
block|}
comment|/* Avoid transmitting dupe requests. */
if|if
condition|(
name|type
operator|==
name|SOCK_DGRAM
operator|&&
name|yp_find_dnsqent
argument_list|(
name|svcudp_get_xid
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
argument_list|,
name|BY_RPC_XID
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|YP_TRUE
operator|)
return|;
if|if
condition|(
operator|(
name|q
operator|=
name|yp_malloc_dnsent
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|YP_YPERR
operator|)
return|;
name|q
operator|->
name|type
operator|=
name|T_A
expr_stmt|;
name|q
operator|->
name|ttl
operator|=
name|DEF_TTL
expr_stmt|;
name|q
operator|->
name|xprt
operator|=
name|rqstp
operator|->
name|rq_xprt
expr_stmt|;
name|q
operator|->
name|ypvers
operator|=
name|rqstp
operator|->
name|rq_vers
expr_stmt|;
name|q
operator|->
name|prot_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|prot_type
operator|==
name|SOCK_DGRAM
condition|)
name|q
operator|->
name|xid
operator|=
name|svcudp_get_xid
argument_list|(
name|q
operator|->
name|xprt
argument_list|)
expr_stmt|;
name|q
operator|->
name|client_addr
operator|=
name|q
operator|->
name|xprt
operator|->
name|xp_raddr
expr_stmt|;
name|q
operator|->
name|domain
operator|=
name|_res
operator|.
name|dnsrch
expr_stmt|;
name|q
operator|->
name|id
operator|=
name|yp_send_dns_query
argument_list|(
name|name
argument_list|,
name|q
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|id
operator|==
literal|0
condition|)
block|{
name|yp_error
argument_list|(
literal|"DNS query failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|YP_YPERR
operator|)
return|;
block|}
name|q
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|qhead
argument_list|,
name|q
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|pending
operator|++
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"queueing async DNS name lookup (%d)"
argument_list|,
name|q
operator|->
name|id
argument_list|)
expr_stmt|;
name|yp_prune_dnsq
argument_list|()
expr_stmt|;
return|return
operator|(
name|YP_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue and transmit an asynchronous DNS IP address lookup.  */
end_comment

begin_function
name|ypstat
name|yp_async_lookup_addr
parameter_list|(
name|rqstp
parameter_list|,
name|addr
parameter_list|)
name|struct
name|svc_req
modifier|*
name|rqstp
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
block|{
specifier|register
name|struct
name|circleq_dnsentry
modifier|*
name|q
decl_stmt|;
name|char
name|buf
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
name|int
name|a
decl_stmt|,
name|b
decl_stmt|,
name|c
decl_stmt|,
name|d
decl_stmt|;
name|int
name|type
decl_stmt|,
name|len
decl_stmt|;
comment|/* Check for SOCK_DGRAM or SOCK_STREAM -- we need to know later */
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|rqstp
operator|->
name|rq_xprt
operator|->
name|xp_fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_TYPE
argument_list|,
operator|&
name|type
argument_list|,
operator|&
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|yp_error
argument_list|(
literal|"getsockopt failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|YP_YPERR
operator|)
return|;
block|}
comment|/* Avoid transmitting dupe requests. */
if|if
condition|(
name|type
operator|==
name|SOCK_DGRAM
operator|&&
name|yp_find_dnsqent
argument_list|(
name|svcudp_get_xid
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
argument_list|,
name|BY_RPC_XID
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|YP_TRUE
operator|)
return|;
if|if
condition|(
operator|(
name|q
operator|=
name|yp_malloc_dnsent
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|YP_YPERR
operator|)
return|;
if|if
condition|(
name|sscanf
argument_list|(
name|addr
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|d
argument_list|)
operator|!=
literal|4
condition|)
return|return
operator|(
name|YP_NOKEY
operator|)
return|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d.%d.%d.%d.in-addr.arpa"
argument_list|,
name|d
argument_list|,
name|c
argument_list|,
name|b
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"DNS address is: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|q
operator|->
name|type
operator|=
name|T_PTR
expr_stmt|;
name|q
operator|->
name|ttl
operator|=
name|DEF_TTL
expr_stmt|;
name|q
operator|->
name|xprt
operator|=
name|rqstp
operator|->
name|rq_xprt
expr_stmt|;
name|q
operator|->
name|ypvers
operator|=
name|rqstp
operator|->
name|rq_vers
expr_stmt|;
name|q
operator|->
name|domain
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|prot_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|prot_type
operator|==
name|SOCK_DGRAM
condition|)
name|q
operator|->
name|xid
operator|=
name|svcudp_get_xid
argument_list|(
name|q
operator|->
name|xprt
argument_list|)
expr_stmt|;
name|q
operator|->
name|client_addr
operator|=
name|q
operator|->
name|xprt
operator|->
name|xp_raddr
expr_stmt|;
name|q
operator|->
name|id
operator|=
name|yp_send_dns_query
argument_list|(
name|buf
argument_list|,
name|q
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|id
operator|==
literal|0
condition|)
block|{
name|yp_error
argument_list|(
literal|"DNS query failed"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|YP_YPERR
operator|)
return|;
block|}
name|inet_aton
argument_list|(
name|addr
argument_list|,
operator|&
name|q
operator|->
name|addr
argument_list|)
expr_stmt|;
name|q
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|qhead
argument_list|,
name|q
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|pending
operator|++
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"queueing async DNS address lookup (%d)"
argument_list|,
name|q
operator|->
name|id
argument_list|)
expr_stmt|;
name|yp_prune_dnsq
argument_list|()
expr_stmt|;
return|return
operator|(
name|YP_TRUE
operator|)
return|;
block|}
end_function

end_unit

