begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"yp.h"
end_include

begin_include
include|#
directive|include
file|"yp_extern.h"
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_decl_stmt
name|int
name|forked
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|children
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MASTER_STRING
value|"YP_MASTER_NAME"
end_define

begin_define
define|#
directive|define
name|MASTER_SZ
value|sizeof(MASTER_STRING) - 1
end_define

begin_define
define|#
directive|define
name|ORDER_STRING
value|"YP_LAST_MODIFIED"
end_define

begin_define
define|#
directive|define
name|ORDER_SZ
value|sizeof(ORDER_STRING) - 1
end_define

begin_comment
comment|/*  * NIS v2 support. This is where most of the action happens.  */
end_comment

begin_function
name|void
modifier|*
name|ypproc_null_2_svc
parameter_list|(
name|void
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|result
decl_stmt|;
specifier|static
name|char
name|rval
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
name|result
operator|=
operator|&
name|rval
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|result
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
modifier|*
name|ypproc_domain_2_svc
parameter_list|(
name|domainname
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|bool_t
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|result
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|==
name|NULL
operator|||
name|yp_validdomain
argument_list|(
operator|*
name|argp
argument_list|)
condition|)
name|result
operator|=
name|FALSE
expr_stmt|;
else|else
name|result
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|bool_t
modifier|*
name|ypproc_domain_nonack_2_svc
parameter_list|(
name|domainname
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|bool_t
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|argp
operator|==
name|NULL
operator|||
name|yp_validdomain
argument_list|(
operator|*
name|argp
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
name|result
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|ypresp_val
modifier|*
name|ypproc_match_2_svc
parameter_list|(
name|ypreq_key
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_val
name|result
decl_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
literal|""
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
operator|||
name|argp
operator|->
name|map
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_select_map
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|&
name|argp
operator|->
name|key
argument_list|,
literal|1
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|yp_errno
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|result
operator|.
name|stat
operator|=
name|yp_getbykey
argument_list|(
operator|&
name|argp
operator|->
name|key
argument_list|,
operator|&
name|result
operator|.
name|val
argument_list|)
expr_stmt|;
comment|/* 	 * Do DNS lookups for hosts maps if database lookup failed. 	 */
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|result
operator|.
name|stat
operator|!=
name|YP_TRUE
operator|&&
operator|(
name|yp_testflag
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
name|YP_INTERDOMAIN
argument_list|)
operator|||
operator|(
name|strstr
argument_list|(
name|argp
operator|->
name|map
argument_list|,
literal|"hosts"
argument_list|)
operator|&&
name|do_dns
operator|)
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|do_dns
operator|&&
name|result
operator|.
name|stat
operator|!=
name|YP_TRUE
operator|&&
name|strstr
argument_list|(
name|argp
operator|->
name|map
argument_list|,
literal|"hosts"
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|char
name|nbuf
index|[
name|YPMAXRECORD
index|]
decl_stmt|;
comment|/* NUL terminate! NUL terminate!! NUL TERMINATE!!! */
name|bcopy
argument_list|(
name|argp
operator|->
name|key
operator|.
name|keydat_val
argument_list|,
name|nbuf
argument_list|,
name|argp
operator|->
name|key
operator|.
name|keydat_len
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|argp
operator|->
name|key
operator|.
name|keydat_len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"doing DNS lookup of %s"
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argp
operator|->
name|map
argument_list|,
literal|"hosts.byname"
argument_list|)
condition|)
name|result
operator|.
name|stat
operator|=
name|yp_async_lookup_name
argument_list|(
name|rqstp
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argp
operator|->
name|map
argument_list|,
literal|"hosts.byaddr"
argument_list|)
condition|)
name|result
operator|.
name|stat
operator|=
name|yp_async_lookup_addr
argument_list|(
name|rqstp
argument_list|,
name|nbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|ypresp_key_val
modifier|*
name|ypproc_first_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_key_val
name|result
decl_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|result
operator|.
name|key
operator|.
name|keydat_val
operator|=
literal|""
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|result
operator|.
name|key
operator|.
name|keydat_len
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_select_map
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|&
name|result
operator|.
name|key
argument_list|,
literal|0
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|yp_errno
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|result
operator|.
name|stat
operator|=
name|yp_firstbykey
argument_list|(
operator|&
name|result
operator|.
name|key
argument_list|,
operator|&
name|result
operator|.
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|ypresp_key_val
modifier|*
name|ypproc_next_2_svc
parameter_list|(
name|ypreq_key
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_key_val
name|result
decl_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|result
operator|.
name|key
operator|.
name|keydat_val
operator|=
literal|""
expr_stmt|;
name|result
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|result
operator|.
name|key
operator|.
name|keydat_len
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
operator|||
name|argp
operator|->
name|map
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_select_map
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|&
name|argp
operator|->
name|key
argument_list|,
literal|0
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|yp_errno
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|result
operator|.
name|key
operator|.
name|keydat_len
operator|=
name|argp
operator|->
name|key
operator|.
name|keydat_len
expr_stmt|;
name|result
operator|.
name|key
operator|.
name|keydat_val
operator|=
name|argp
operator|->
name|key
operator|.
name|keydat_val
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|yp_nextbykey
argument_list|(
operator|&
name|result
operator|.
name|key
argument_list|,
operator|&
name|result
operator|.
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
specifier|static
name|void
name|ypxfr_callback
parameter_list|(
name|rval
parameter_list|,
name|addr
parameter_list|,
name|transid
parameter_list|,
name|prognum
parameter_list|,
name|port
parameter_list|)
name|ypxfrstat
name|rval
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|addr
decl_stmt|;
name|unsigned
name|int
name|transid
decl_stmt|;
name|unsigned
name|int
name|prognum
decl_stmt|;
name|unsigned
name|long
name|port
decl_stmt|;
block|{
name|CLIENT
modifier|*
name|clnt
decl_stmt|;
name|int
name|sock
init|=
name|RPC_ANYSOCK
decl_stmt|;
name|struct
name|timeval
name|timeout
decl_stmt|;
name|yppushresp_xfr
name|ypxfr_resp
decl_stmt|;
name|struct
name|rpc_err
name|err
decl_stmt|;
name|timeout
operator|.
name|tv_sec
operator|=
literal|5
expr_stmt|;
name|timeout
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clnt
operator|=
name|clntudp_create
argument_list|(
name|addr
argument_list|,
name|prognum
argument_list|,
literal|1
argument_list|,
name|timeout
argument_list|,
operator|&
name|sock
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"%s: %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|clnt_spcreateerror
argument_list|(
literal|"failed to establish callback handle"
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ypxfr_resp
operator|.
name|status
operator|=
name|rval
expr_stmt|;
name|ypxfr_resp
operator|.
name|transid
operator|=
name|transid
expr_stmt|;
comment|/* Turn the timeout off -- we don't want to block. */
name|timeout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|clnt_control
argument_list|(
name|clnt
argument_list|,
name|CLSET_TIMEOUT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|timeout
argument_list|)
operator|==
name|FALSE
condition|)
name|yp_error
argument_list|(
literal|"failed to set timeout on ypproc_xfr callback"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yppushproc_xfrresp_1
argument_list|(
operator|&
name|ypxfr_resp
argument_list|,
name|clnt
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|clnt_geterr
argument_list|(
name|clnt
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|.
name|re_status
operator|!=
name|RPC_SUCCESS
operator|&&
name|err
operator|.
name|re_status
operator|!=
name|RPC_TIMEDOUT
condition|)
name|yp_error
argument_list|(
literal|"%s"
argument_list|,
name|clnt_sperror
argument_list|(
name|clnt
argument_list|,
literal|"ypxfr callback failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|clnt_destroy
argument_list|(
name|clnt
argument_list|)
expr_stmt|;
return|return;
block|}
define|#
directive|define
name|YPXFR_RETURN
parameter_list|(
name|CODE
parameter_list|)
define|\
comment|/* Order is important: send regular RPC reply, then callback */
define|\
value|result.xfrstat = CODE; 						\ 	svc_sendreply(rqstp->rq_xprt, xdr_ypresp_xfr, (char *)&result); \ 	ypxfr_callback(CODE,rqhost,argp->transid, 			\ 					argp->prog,argp->port); 	\ 	return(NULL);
name|ypresp_xfr
modifier|*
name|ypproc_xfr_2_svc
parameter_list|(
name|ypreq_xfr
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_xfr
name|result
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rqhost
decl_stmt|;
name|ypresp_master
modifier|*
name|mres
decl_stmt|;
name|ypreq_nokey
name|mreq
decl_stmt|;
name|result
operator|.
name|transid
operator|=
name|argp
operator|->
name|transid
expr_stmt|;
name|rqhost
operator|=
name|svc_getcaller
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map_parms
operator|.
name|map
argument_list|,
name|argp
operator|->
name|map_parms
operator|.
name|domain
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map_parms
operator|.
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|YPXFR_RETURN
argument_list|(
argument|YPXFR_REFUSED
argument_list|)
block|}
if|if
condition|(
name|argp
operator|->
name|map_parms
operator|.
name|domain
operator|==
name|NULL
condition|)
block|{
name|YPXFR_RETURN
argument_list|(
argument|YPXFR_BADARGS
argument_list|)
block|}
if|if
condition|(
name|yp_validdomain
argument_list|(
name|argp
operator|->
name|map_parms
operator|.
name|domain
argument_list|)
condition|)
block|{
name|YPXFR_RETURN
argument_list|(
argument|YPXFR_NODOM
argument_list|)
block|}
comment|/* 	 * Determine the master host ourselves. The caller may 	 * be up to no good. This has the side effect of verifying 	 * that the requested map and domain actually exist. 	 */
name|mreq
operator|.
name|domain
operator|=
name|argp
operator|->
name|map_parms
operator|.
name|domain
expr_stmt|;
name|mreq
operator|.
name|map
operator|=
name|argp
operator|->
name|map_parms
operator|.
name|map
expr_stmt|;
name|mres
operator|=
name|ypproc_master_2_svc
argument_list|(
operator|&
name|mreq
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mres
operator|->
name|stat
operator|!=
name|YP_TRUE
condition|)
block|{
name|yp_error
argument_list|(
literal|"couldn't find master for map %s@%s"
argument_list|,
name|argp
operator|->
name|map_parms
operator|.
name|map
argument_list|,
name|argp
operator|->
name|map_parms
operator|.
name|domain
argument_list|)
expr_stmt|;
name|yp_error
argument_list|(
literal|"host at %s (%s) may be pulling my leg"
argument_list|,
name|argp
operator|->
name|map_parms
operator|.
name|peer
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|YPXFR_RETURN
argument_list|(
argument|YPXFR_REFUSED
argument_list|)
block|}
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
block|{
name|char
name|g
index|[
literal|11
index|]
decl_stmt|,
name|t
index|[
literal|11
index|]
decl_stmt|,
name|p
index|[
literal|11
index|]
decl_stmt|;
name|char
name|ypxfr_command
index|[
name|MAXPATHLEN
operator|+
literal|2
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|ypxfr_command
argument_list|,
literal|"%sypxfr"
argument_list|,
name|_PATH_LIBEXEC
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|t
argument_list|,
literal|"%u"
argument_list|,
name|argp
operator|->
name|transid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|g
argument_list|,
literal|"%u"
argument_list|,
name|argp
operator|->
name|prog
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%u"
argument_list|,
name|argp
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|yp_dir
argument_list|,
name|_PATH_YP
argument_list|)
condition|)
block|{
name|execl
argument_list|(
name|ypxfr_command
argument_list|,
literal|"ypxfr"
argument_list|,
literal|"-d"
argument_list|,
name|argp
operator|->
name|map_parms
operator|.
name|domain
argument_list|,
literal|"-h"
argument_list|,
name|mres
operator|->
name|peer
argument_list|,
literal|"-p"
argument_list|,
name|yp_dir
argument_list|,
literal|"-C"
argument_list|,
name|t
argument_list|,
name|g
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|p
argument_list|,
name|argp
operator|->
name|map_parms
operator|.
name|map
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|execl
argument_list|(
name|ypxfr_command
argument_list|,
literal|"ypxfr"
argument_list|,
literal|"-d"
argument_list|,
name|argp
operator|->
name|map_parms
operator|.
name|domain
argument_list|,
literal|"-h"
argument_list|,
name|mres
operator|->
name|peer
argument_list|,
literal|"-C"
argument_list|,
name|t
argument_list|,
name|g
argument_list|,
name|inet_ntoa
argument_list|(
name|rqhost
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|p
argument_list|,
name|argp
operator|->
name|map_parms
operator|.
name|map
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|forked
operator|++
expr_stmt|;
name|yp_error
argument_list|(
literal|"ypxfr execl(%s): %s"
argument_list|,
name|ypxfr_command
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|YPXFR_RETURN
argument_list|(
argument|YPXFR_XFRERR
argument_list|)
break|break;
block|}
case|case
operator|-
literal|1
case|:
name|yp_error
argument_list|(
literal|"ypxfr fork(): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|YPXFR_RETURN
argument_list|(
argument|YPXFR_XFRERR
argument_list|)
break|break;
default|default:
name|result
operator|.
name|xfrstat
operator|=
name|YPXFR_SUCC
expr_stmt|;
name|children
operator|++
expr_stmt|;
name|forked
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
undef|#
directive|undef
name|YPXFR_RETURN
name|void
modifier|*
name|ypproc_clear_2_svc
parameter_list|(
name|void
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|result
decl_stmt|;
specifier|static
name|char
name|rval
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|DB_CACHE
comment|/* clear out the database cache */
name|yp_flush_all
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Re-read the securenets database for the hell of it. */
name|load_securenets
argument_list|()
expr_stmt|;
name|result
operator|=
operator|&
name|rval
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|result
operator|)
return|;
block|}
comment|/*  * For ypproc_all, we have to send a stream of ypresp_all structures  * via TCP, but the XDR filter generated from the yp.x protocol  * definition file only serializes one such structure. This means that  * to send the whole stream, you need a wrapper which feeds all the  * records into the underlying XDR routine until it hits an 'EOF.'  * But to use the wrapper, you have to violate the boundaries between  * RPC layers by calling svc_sendreply() directly from the ypproc_all  * service routine instead of letting the RPC dispatcher do it.  *  * Bleah.  */
comment|/*  * Custom XDR routine for serialzing results of ypproc_all: keep  * reading from the database and spew until we run out of records  * or encounter an error.  */
specifier|static
name|bool_t
name|xdr_my_ypresp_all
parameter_list|(
specifier|register
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|ypresp_all
modifier|*
name|objp
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Get a record. */
if|if
condition|(
operator|(
name|objp
operator|->
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|yp_nextbykey
argument_list|(
operator|&
name|objp
operator|->
name|ypresp_all_u
operator|.
name|val
operator|.
name|key
argument_list|,
operator|&
name|objp
operator|->
name|ypresp_all_u
operator|.
name|val
operator|.
name|val
argument_list|)
operator|)
operator|==
name|YP_TRUE
condition|)
block|{
name|objp
operator|->
name|more
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|objp
operator|->
name|more
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Serialize. */
if|if
condition|(
operator|!
name|xdr_ypresp_all
argument_list|(
name|xdrs
argument_list|,
name|objp
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|objp
operator|->
name|more
operator|==
name|FALSE
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
name|ypresp_all
modifier|*
name|ypproc_all_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_all
name|result
decl_stmt|;
comment|/* 	 * Set this here so that the client will be forced to make 	 * at least one attempt to read from us even if all we're 	 * doing is returning an error. 	 */
name|result
operator|.
name|more
operator|=
name|TRUE
expr_stmt|;
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|key
operator|.
name|keydat_len
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|key
operator|.
name|keydat_val
operator|=
literal|""
expr_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
operator|||
name|argp
operator|->
name|map
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/* 	 * XXX If we hit the child limit, fail the request. 	 * If we don't, and the map is large, we could block for 	 * a long time in the parent. 	 */
if|if
condition|(
name|children
operator|>=
name|MAX_CHILDREN
condition|)
block|{
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/* 	 * The ypproc_all procedure can take a while to complete. 	 * Best to handle it in a subprocess so the parent doesn't 	 * block. (Is there a better way to do this? Maybe with 	 * async socket I/O?) 	 */
if|if
condition|(
operator|!
name|debug
operator|&&
name|children
operator|<
name|MAX_CHILDREN
operator|&&
name|fork
argument_list|()
condition|)
block|{
name|children
operator|++
expr_stmt|;
name|forked
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|forked
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|yp_select_map
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|&
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|key
argument_list|,
literal|0
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|ypresp_all_u
operator|.
name|val
operator|.
name|stat
operator|=
name|yp_errno
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/* Kick off the actual data transfer. */
name|svc_sendreply
argument_list|(
name|rqstp
operator|->
name|rq_xprt
argument_list|,
name|xdr_my_ypresp_all
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|result
argument_list|)
expr_stmt|;
comment|/* 	 * Returning NULL prevents the dispatcher from calling 	 * svc_sendreply() since we already did it. 	 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ypresp_master
modifier|*
name|ypproc_master_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_master
name|result
decl_stmt|;
specifier|static
name|char
name|ypvalbuf
index|[
name|YPMAXRECORD
index|]
decl_stmt|;
name|keydat
name|key
init|=
block|{
name|MASTER_SZ
block|,
name|MASTER_STRING
block|}
decl_stmt|;
name|valdat
name|val
decl_stmt|;
name|result
operator|.
name|peer
operator|=
literal|""
expr_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_select_map
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|&
name|key
argument_list|,
literal|1
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|yp_errno
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/* 	 * Note that we copy the data retrieved from the database to 	 * a private buffer and NUL terminate the buffer rather than 	 * terminating the data in place. We do this because by stuffing 	 * a '\0' into data.data, we will actually be corrupting memory 	 * allocated by the DB package. This is a bad thing now that we 	 * cache DB handles rather than closing the database immediately. 	 */
name|result
operator|.
name|stat
operator|=
name|yp_getbykey
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|val
operator|.
name|valdat_val
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ypvalbuf
argument_list|,
name|val
operator|.
name|valdat_len
argument_list|)
expr_stmt|;
name|ypvalbuf
index|[
name|val
operator|.
name|valdat_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
operator|.
name|peer
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|ypvalbuf
expr_stmt|;
block|}
else|else
name|result
operator|.
name|peer
operator|=
literal|""
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|ypresp_order
modifier|*
name|ypproc_order_2_svc
parameter_list|(
name|ypreq_nokey
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_order
name|result
decl_stmt|;
name|keydat
name|key
init|=
block|{
name|ORDER_SZ
block|,
name|ORDER_STRING
block|}
decl_stmt|;
name|valdat
name|val
decl_stmt|;
name|result
operator|.
name|ordernum
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|argp
operator|->
name|map
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|->
name|domain
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/* 	 * We could just check the timestamp on the map file, 	 * but that's a hack: we'll only know the last time the file 	 * was touched, not the last time the database contents were 	 * updated. 	 */
if|if
condition|(
name|yp_select_map
argument_list|(
name|argp
operator|->
name|map
argument_list|,
name|argp
operator|->
name|domain
argument_list|,
operator|&
name|key
argument_list|,
literal|1
argument_list|)
operator|!=
name|YP_TRUE
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|yp_errno
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|result
operator|.
name|stat
operator|=
name|yp_getbykey
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|stat
operator|==
name|YP_TRUE
condition|)
name|result
operator|.
name|ordernum
operator|=
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|val
operator|.
name|valdat_val
argument_list|)
expr_stmt|;
else|else
name|result
operator|.
name|ordernum
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
specifier|static
name|void
name|yp_maplist_free
parameter_list|(
name|yp_maplist
parameter_list|)
name|struct
name|ypmaplist
modifier|*
name|yp_maplist
decl_stmt|;
block|{
specifier|register
name|struct
name|ypmaplist
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|yp_maplist
condition|)
block|{
name|next
operator|=
name|yp_maplist
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|yp_maplist
operator|->
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|yp_maplist
argument_list|)
expr_stmt|;
name|yp_maplist
operator|=
name|next
expr_stmt|;
block|}
return|return;
block|}
specifier|static
name|struct
name|ypmaplist
modifier|*
name|yp_maplist_create
parameter_list|(
name|domain
parameter_list|)
specifier|const
name|char
modifier|*
name|domain
decl_stmt|;
block|{
name|char
name|yp_mapdir
index|[
name|MAXPATHLEN
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|yp_mapname
index|[
name|MAXPATHLEN
operator|+
literal|2
index|]
decl_stmt|;
name|struct
name|ypmaplist
modifier|*
name|cur
init|=
name|NULL
decl_stmt|;
name|struct
name|ypmaplist
modifier|*
name|yp_maplist
init|=
name|NULL
decl_stmt|;
name|DIR
modifier|*
name|dird
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dirp
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|snprintf
argument_list|(
name|yp_mapdir
argument_list|,
sizeof|sizeof
argument_list|(
name|yp_mapdir
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|yp_dir
argument_list|,
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dird
operator|=
name|opendir
argument_list|(
name|yp_mapdir
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"opendir(%s) failed: %s"
argument_list|,
name|yp_mapdir
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|dirp
operator|=
name|readdir
argument_list|(
name|dird
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
literal|"."
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|yp_mapname
argument_list|,
sizeof|sizeof
argument_list|(
name|yp_mapname
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|yp_mapdir
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|yp_mapname
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
operator|||
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cur
operator|=
operator|(
expr|struct
name|ypmaplist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ypmaplist
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"malloc() failed"
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dird
argument_list|)
expr_stmt|;
name|yp_maplist_free
argument_list|(
name|yp_maplist
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cur
operator|->
name|map
operator|=
operator|(
name|char
operator|*
operator|)
name|strdup
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"strdup() failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dird
argument_list|)
expr_stmt|;
name|yp_maplist_free
argument_list|(
name|yp_maplist
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cur
operator|->
name|next
operator|=
name|yp_maplist
expr_stmt|;
name|yp_maplist
operator|=
name|cur
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|yp_error
argument_list|(
literal|"map: %s"
argument_list|,
name|yp_maplist
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
block|}
name|closedir
argument_list|(
name|dird
argument_list|)
expr_stmt|;
return|return
operator|(
name|yp_maplist
operator|)
return|;
block|}
name|ypresp_maplist
modifier|*
name|ypproc_maplist_2_svc
parameter_list|(
name|domainname
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresp_maplist
name|result
init|=
block|{
literal|0
block|,
name|NULL
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|DB_CACHE
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|yp_access
argument_list|(
name|NULL
argument_list|,
operator|(
expr|struct
name|svc_req
operator|*
operator|)
name|rqstp
argument_list|)
condition|)
block|{
endif|#
directive|endif
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|argp
operator|==
name|NULL
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
if|if
condition|(
name|yp_validdomain
argument_list|(
operator|*
name|argp
argument_list|)
condition|)
block|{
name|result
operator|.
name|stat
operator|=
name|YP_NODOM
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/* 	 * We have to construct a linked list for the ypproc_maplist 	 * procedure using dynamically allocated memory. Since the XDR 	 * layer won't free this list for us, we have to deal with it 	 * ourselves. We call yp_maplist_free() first to free any 	 * previously allocated data we may have accumulated to insure 	 * that we have only one linked list in memory at any given 	 * time. 	 */
name|yp_maplist_free
argument_list|(
name|result
operator|.
name|maps
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|result
operator|.
name|maps
operator|=
name|yp_maplist_create
argument_list|(
operator|*
name|argp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|yp_error
argument_list|(
literal|"yp_maplist_create failed"
argument_list|)
expr_stmt|;
name|result
operator|.
name|stat
operator|=
name|YP_YPERR
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
else|else
name|result
operator|.
name|stat
operator|=
name|YP_TRUE
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/*  * NIS v1 support. The nullproc, domain and domain_nonack  * functions from v1 are identical to those in v2, so all  * we have to do is hand off to them.  *  * The other functions are mostly just wrappers around their v2  * counterparts. For example, for the v1 'match' procedure, we  * crack open the argument structure, make a request to the v2  * 'match' function, repackage the data into a v1 response and  * then send it on its way.  *  * Note that we don't support the pull, push and get procedures.  * There's little documentation available to show what they  * do, and I suspect they're meant largely for map transfers  * between master and slave servers.  */
name|void
modifier|*
name|ypoldproc_null_1_svc
parameter_list|(
name|void
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
return|return
operator|(
name|ypproc_null_2_svc
argument_list|(
name|argp
argument_list|,
name|rqstp
argument_list|)
operator|)
return|;
block|}
name|bool_t
modifier|*
name|ypoldproc_domain_1_svc
parameter_list|(
name|domainname
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
return|return
operator|(
name|ypproc_domain_2_svc
argument_list|(
name|argp
argument_list|,
name|rqstp
argument_list|)
operator|)
return|;
block|}
name|bool_t
modifier|*
name|ypoldproc_domain_nonack_1_svc
parameter_list|(
name|domainname
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
return|return
operator|(
name|ypproc_domain_nonack_2_svc
argument_list|(
name|argp
argument_list|,
name|rqstp
argument_list|)
operator|)
return|;
block|}
comment|/*  * the 'match' procedure sends a response of type YPRESP_VAL  */
name|ypresponse
modifier|*
name|ypoldproc_match_1_svc
parameter_list|(
name|yprequest
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresponse
name|result
decl_stmt|;
name|ypresp_val
modifier|*
name|v2_result
decl_stmt|;
name|result
operator|.
name|yp_resptype
operator|=
name|YPRESP_VAL
expr_stmt|;
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_valtype
operator|.
name|val
operator|.
name|valdat_val
operator|=
literal|""
expr_stmt|;
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_valtype
operator|.
name|val
operator|.
name|valdat_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|yp_reqtype
operator|!=
name|YPREQ_KEY
condition|)
block|{
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_valtype
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|v2_result
operator|=
name|ypproc_match_2_svc
argument_list|(
operator|&
name|argp
operator|->
name|yprequest_u
operator|.
name|yp_req_keytype
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2_result
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|v2_result
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_valtype
argument_list|,
sizeof|sizeof
argument_list|(
name|ypresp_val
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/*  * the 'first' procedure sends a response of type YPRESP_KEY_VAL  */
name|ypresponse
modifier|*
name|ypoldproc_first_1_svc
parameter_list|(
name|yprequest
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresponse
name|result
decl_stmt|;
name|ypresp_key_val
modifier|*
name|v2_result
decl_stmt|;
name|result
operator|.
name|yp_resptype
operator|=
name|YPRESP_KEY_VAL
expr_stmt|;
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
operator|.
name|key
operator|.
name|keydat_val
operator|=
literal|""
expr_stmt|;
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
operator|.
name|key
operator|.
name|keydat_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|yp_reqtype
operator|!=
name|YPREQ_NOKEY
condition|)
block|{
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|v2_result
operator|=
name|ypproc_first_2_svc
argument_list|(
operator|&
name|argp
operator|->
name|yprequest_u
operator|.
name|yp_req_nokeytype
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2_result
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|v2_result
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
argument_list|,
sizeof|sizeof
argument_list|(
name|ypresp_key_val
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/*  * the 'next' procedure sends a response of type YPRESP_KEY_VAL  */
name|ypresponse
modifier|*
name|ypoldproc_next_1_svc
parameter_list|(
name|yprequest
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresponse
name|result
decl_stmt|;
name|ypresp_key_val
modifier|*
name|v2_result
decl_stmt|;
name|result
operator|.
name|yp_resptype
operator|=
name|YPRESP_KEY_VAL
expr_stmt|;
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
operator|.
name|val
operator|.
name|valdat_val
operator|=
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
operator|.
name|key
operator|.
name|keydat_val
operator|=
literal|""
expr_stmt|;
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
operator|.
name|val
operator|.
name|valdat_len
operator|=
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
operator|.
name|key
operator|.
name|keydat_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|yp_reqtype
operator|!=
name|YPREQ_KEY
condition|)
block|{
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
operator|.
name|stat
operator|=
name|YP_BADARGS
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|v2_result
operator|=
name|ypproc_next_2_svc
argument_list|(
operator|&
name|argp
operator|->
name|yprequest_u
operator|.
name|yp_req_keytype
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2_result
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|v2_result
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_key_valtype
argument_list|,
sizeof|sizeof
argument_list|(
name|ypresp_key_val
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
comment|/*  * the 'poll' procedure sends a response of type YPRESP_MAP_PARMS  */
name|ypresponse
modifier|*
name|ypoldproc_poll_1_svc
parameter_list|(
name|yprequest
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresponse
name|result
decl_stmt|;
name|ypresp_master
modifier|*
name|v2_result1
decl_stmt|;
name|ypresp_order
modifier|*
name|v2_result2
decl_stmt|;
name|result
operator|.
name|yp_resptype
operator|=
name|YPRESP_MAP_PARMS
expr_stmt|;
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_map_parmstype
operator|.
name|domain
operator|=
name|argp
operator|->
name|yprequest_u
operator|.
name|yp_req_nokeytype
operator|.
name|domain
expr_stmt|;
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_map_parmstype
operator|.
name|map
operator|=
name|argp
operator|->
name|yprequest_u
operator|.
name|yp_req_nokeytype
operator|.
name|map
expr_stmt|;
comment|/* 	 * Hmm... there is no 'status' value in the 	 * yp_resp_map_parmstype structure, so I have to 	 * guess at what to do to indicate a failure. 	 * I hope this is right. 	 */
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_map_parmstype
operator|.
name|ordernum
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_map_parmstype
operator|.
name|peer
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|yp_reqtype
operator|!=
name|YPREQ_MAP_PARMS
condition|)
block|{
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|v2_result1
operator|=
name|ypproc_master_2_svc
argument_list|(
operator|&
name|argp
operator|->
name|yprequest_u
operator|.
name|yp_req_nokeytype
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2_result1
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|v2_result1
operator|->
name|stat
operator|!=
name|YP_TRUE
condition|)
block|{
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|v2_result2
operator|=
name|ypproc_order_2_svc
argument_list|(
operator|&
name|argp
operator|->
name|yprequest_u
operator|.
name|yp_req_nokeytype
argument_list|,
name|rqstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|v2_result2
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|v2_result2
operator|->
name|stat
operator|!=
name|YP_TRUE
condition|)
block|{
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_map_parmstype
operator|.
name|peer
operator|=
name|v2_result1
operator|->
name|peer
expr_stmt|;
name|result
operator|.
name|ypresponse_u
operator|.
name|yp_resp_map_parmstype
operator|.
name|ordernum
operator|=
name|v2_result2
operator|->
name|ordernum
expr_stmt|;
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|ypresponse
modifier|*
name|ypoldproc_push_1_svc
parameter_list|(
name|yprequest
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresponse
name|result
decl_stmt|;
comment|/* 	 * Not implemented. 	 */
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|ypresponse
modifier|*
name|ypoldproc_pull_1_svc
parameter_list|(
name|yprequest
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresponse
name|result
decl_stmt|;
comment|/* 	 * Not implemented. 	 */
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
name|ypresponse
modifier|*
name|ypoldproc_get_1_svc
parameter_list|(
name|yprequest
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
specifier|static
name|ypresponse
name|result
decl_stmt|;
comment|/* 	 * Not implemented. 	 */
return|return
operator|(
operator|&
name|result
operator|)
return|;
block|}
end_function

end_unit

