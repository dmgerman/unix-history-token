begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2009,2010 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  *     and: Thomas E. Dickey                        1996-on                 *  *     and: Juergen Pfeifer                         2009                    *  ****************************************************************************/
end_comment

begin_comment
comment|/* lib_color.c  *  * Handles color emulation of SYS V curses  */
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_include
include|#
directive|include
file|<tic.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CUR
end_ifndef

begin_define
define|#
directive|define
name|CUR
value|SP_TERMTYPE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: lib_color.c,v 1.98 2010/04/24 22:57:53 tom Exp $"
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|USE_TERM_DRIVER
end_ifdef

begin_define
define|#
directive|define
name|CanChange
value|InfoOf(SP_PARM).canchange
end_define

begin_define
define|#
directive|define
name|DefaultPalette
value|InfoOf(SP_PARM).defaultPalette
end_define

begin_define
define|#
directive|define
name|HasColor
value|InfoOf(SP_PARM).hascolor
end_define

begin_define
define|#
directive|define
name|InitColor
value|InfoOf(SP_PARM).initcolor
end_define

begin_define
define|#
directive|define
name|MaxColors
value|InfoOf(SP_PARM).maxcolors
end_define

begin_define
define|#
directive|define
name|MaxPairs
value|InfoOf(SP_PARM).maxpairs
end_define

begin_define
define|#
directive|define
name|UseHlsPalette
value|(DefaultPalette == _nc_hls_palette)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CanChange
value|can_change
end_define

begin_define
define|#
directive|define
name|DefaultPalette
value|(hue_lightness_saturation ? hls_palette : cga_palette)
end_define

begin_define
define|#
directive|define
name|HasColor
value|has_color
end_define

begin_define
define|#
directive|define
name|InitColor
value|initialize_color
end_define

begin_define
define|#
directive|define
name|MaxColors
value|max_colors
end_define

begin_define
define|#
directive|define
name|MaxPairs
value|max_pairs
end_define

begin_define
define|#
directive|define
name|UseHlsPalette
value|(hue_lightness_saturation)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USE_TERM_DRIVER
end_ifndef

begin_comment
comment|/*  * These should be screen structure members.  They need to be globals for  * historical reasons.  So we assign them in start_color() and also in  * set_term()'s screen-switching logic.  */
end_comment

begin_if
if|#
directive|if
name|USE_REENTRANT
end_if

begin_function
name|NCURSES_EXPORT
function|(
name|int
function|)
name|NCURSES_PUBLIC_VAR
argument_list|(
argument|COLOR_PAIRS
argument_list|)
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|SP
condition|?
name|SP
operator|->
name|_pair_count
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|NCURSES_EXPORT
function|(
name|int
function|)
name|NCURSES_PUBLIC_VAR
argument_list|(
argument|COLORS
argument_list|)
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|SP
condition|?
name|SP
operator|->
name|_color_count
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|int
argument_list|)
end_macro

begin_expr_stmt
name|COLOR_PAIRS
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|int
argument_list|)
end_macro

begin_expr_stmt
name|COLORS
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_TERM_DRIVER */
end_comment

begin_define
define|#
directive|define
name|DATA
parameter_list|(
name|r
parameter_list|,
name|g
parameter_list|,
name|b
parameter_list|)
value|{r,g,b, 0,0,0, 0}
end_define

begin_define
define|#
directive|define
name|TYPE_CALLOC
parameter_list|(
name|type
parameter_list|,
name|elts
parameter_list|)
value|typeCalloc(type, (unsigned)(elts))
end_define

begin_define
define|#
directive|define
name|MAX_PALETTE
value|8
end_define

begin_define
define|#
directive|define
name|OkColorHi
parameter_list|(
name|n
parameter_list|)
value|(((n)< COLORS)&& ((n)< maxcolors))
end_define

begin_define
define|#
directive|define
name|InPalette
parameter_list|(
name|n
parameter_list|)
value|((n)>= 0&& (n)< MAX_PALETTE)
end_define

begin_comment
comment|/*  * Given a RGB range of 0..1000, we'll normally set the individual values  * to about 2/3 of the maximum, leaving full-range for bold/bright colors.  */
end_comment

begin_define
define|#
directive|define
name|RGB_ON
value|680
end_define

begin_define
define|#
directive|define
name|RGB_OFF
value|0
end_define

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|color_t
name|cga_palette
index|[]
init|=
block|{
comment|/*  R               G               B */
name|DATA
argument_list|(
name|RGB_OFF
argument_list|,
name|RGB_OFF
argument_list|,
name|RGB_OFF
argument_list|)
block|,
comment|/* COLOR_BLACK */
name|DATA
argument_list|(
name|RGB_ON
argument_list|,
name|RGB_OFF
argument_list|,
name|RGB_OFF
argument_list|)
block|,
comment|/* COLOR_RED */
name|DATA
argument_list|(
name|RGB_OFF
argument_list|,
name|RGB_ON
argument_list|,
name|RGB_OFF
argument_list|)
block|,
comment|/* COLOR_GREEN */
name|DATA
argument_list|(
name|RGB_ON
argument_list|,
name|RGB_ON
argument_list|,
name|RGB_OFF
argument_list|)
block|,
comment|/* COLOR_YELLOW */
name|DATA
argument_list|(
name|RGB_OFF
argument_list|,
name|RGB_OFF
argument_list|,
name|RGB_ON
argument_list|)
block|,
comment|/* COLOR_BLUE */
name|DATA
argument_list|(
name|RGB_ON
argument_list|,
name|RGB_OFF
argument_list|,
name|RGB_ON
argument_list|)
block|,
comment|/* COLOR_MAGENTA */
name|DATA
argument_list|(
name|RGB_OFF
argument_list|,
name|RGB_ON
argument_list|,
name|RGB_ON
argument_list|)
block|,
comment|/* COLOR_CYAN */
name|DATA
argument_list|(
name|RGB_ON
argument_list|,
name|RGB_ON
argument_list|,
name|RGB_ON
argument_list|)
block|,
comment|/* COLOR_WHITE */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|color_t
name|hls_palette
index|[]
init|=
block|{
comment|/*  	H       L       S */
name|DATA
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|,
comment|/* COLOR_BLACK */
name|DATA
argument_list|(
literal|120
argument_list|,
literal|50
argument_list|,
literal|100
argument_list|)
block|,
comment|/* COLOR_RED */
name|DATA
argument_list|(
literal|240
argument_list|,
literal|50
argument_list|,
literal|100
argument_list|)
block|,
comment|/* COLOR_GREEN */
name|DATA
argument_list|(
literal|180
argument_list|,
literal|50
argument_list|,
literal|100
argument_list|)
block|,
comment|/* COLOR_YELLOW */
name|DATA
argument_list|(
literal|330
argument_list|,
literal|50
argument_list|,
literal|100
argument_list|)
block|,
comment|/* COLOR_BLUE */
name|DATA
argument_list|(
literal|60
argument_list|,
literal|50
argument_list|,
literal|100
argument_list|)
block|,
comment|/* COLOR_MAGENTA */
name|DATA
argument_list|(
literal|300
argument_list|,
literal|50
argument_list|,
literal|100
argument_list|)
block|,
comment|/* COLOR_CYAN */
name|DATA
argument_list|(
literal|0
argument_list|,
literal|50
argument_list|,
literal|100
argument_list|)
block|,
comment|/* COLOR_WHITE */
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_TERM_DRIVER
end_ifdef

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|const color_t*
argument_list|)
end_macro

begin_expr_stmt
name|_nc_cga_palette
operator|=
name|cga_palette
expr_stmt|;
end_expr_stmt

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|const color_t*
argument_list|)
end_macro

begin_expr_stmt
name|_nc_hls_palette
operator|=
name|hls_palette
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_comment
comment|/*  * Ensure that we use color pairs only when colors have been started, and also  * that the index is within the limits of the table which we allocated.  */
end_comment

begin_define
define|#
directive|define
name|ValidPair
parameter_list|(
name|pair
parameter_list|)
define|\
value|((SP_PARM != 0)&& (pair>= 0)&& (pair< SP_PARM->_pair_limit)&& SP_PARM->_coloron)
end_define

begin_if
if|#
directive|if
name|NCURSES_EXT_FUNCS
end_if

begin_comment
comment|/*  * These are called from _nc_do_color(), which in turn is called from  * vidattr - so we have to assume that sp may be null.  */
end_comment

begin_function
specifier|static
name|int
name|default_fg
parameter_list|(
name|NCURSES_SP_DCL0
parameter_list|)
block|{
return|return
operator|(
name|SP_PARM
operator|!=
literal|0
operator|)
condition|?
name|SP_PARM
operator|->
name|_default_fg
else|:
name|COLOR_WHITE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|default_bg
parameter_list|(
name|NCURSES_SP_DCL0
parameter_list|)
block|{
return|return
name|SP_PARM
operator|!=
literal|0
condition|?
name|SP_PARM
operator|->
name|_default_bg
else|:
name|COLOR_BLACK
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|default_fg
parameter_list|(
name|sp
parameter_list|)
value|COLOR_WHITE
end_define

begin_define
define|#
directive|define
name|default_bg
parameter_list|(
name|sp
parameter_list|)
value|COLOR_BLACK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USE_TERM_DRIVER
end_ifndef

begin_comment
comment|/*  * SVr4 curses is known to interchange color codes (1,4) and (3,6), possibly  * to maintain compatibility with a pre-ANSI scheme.  The same scheme is  * also used in the FreeBSD syscons.  */
end_comment

begin_function
specifier|static
name|int
name|toggled_colors
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|<
literal|16
condition|)
block|{
specifier|static
specifier|const
name|int
name|table
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|,
literal|8
block|,
literal|12
block|,
literal|10
block|,
literal|14
block|,
literal|9
block|,
literal|13
block|,
literal|11
block|,
literal|15
block|}
decl_stmt|;
name|c
operator|=
name|table
index|[
name|c
index|]
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|set_background_color
parameter_list|(
name|NCURSES_SP_DCLx
name|int
name|bg
parameter_list|,
name|NCURSES_SP_OUTC
name|outc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_TERM_DRIVER
name|CallDriver_3
argument_list|(
name|SP_PARM
argument_list|,
name|color
argument_list|,
name|FALSE
argument_list|,
name|bg
argument_list|,
name|outc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|set_a_background
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"set_a_background"
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
argument|tputs
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|TPARM_1
argument_list|(
name|set_a_background
argument_list|,
name|bg
argument_list|)
operator|,
literal|1
operator|,
name|outc
operator|)
expr_stmt|;
block|}
else|else
block|{
name|TPUTS_TRACE
argument_list|(
literal|"set_background"
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
argument|tputs
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|TPARM_1
argument_list|(
name|set_background
argument_list|,
name|toggled_colors
argument_list|(
name|bg
argument_list|)
argument_list|)
operator|,
literal|1
operator|,
name|outc
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|set_foreground_color
parameter_list|(
name|NCURSES_SP_DCLx
name|int
name|fg
parameter_list|,
name|NCURSES_SP_OUTC
name|outc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_TERM_DRIVER
name|CallDriver_3
argument_list|(
name|SP_PARM
argument_list|,
name|color
argument_list|,
name|TRUE
argument_list|,
name|fg
argument_list|,
name|outc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|set_a_foreground
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"set_a_foreground"
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
argument|tputs
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|TPARM_1
argument_list|(
name|set_a_foreground
argument_list|,
name|fg
argument_list|)
operator|,
literal|1
operator|,
name|outc
operator|)
expr_stmt|;
block|}
else|else
block|{
name|TPUTS_TRACE
argument_list|(
literal|"set_foreground"
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
argument|tputs
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|TPARM_1
argument_list|(
name|set_foreground
argument_list|,
name|toggled_colors
argument_list|(
name|fg
argument_list|)
argument_list|)
operator|,
literal|1
operator|,
name|outc
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|init_color_table
parameter_list|(
name|NCURSES_SP_DCL0
parameter_list|)
block|{
specifier|const
name|color_t
modifier|*
name|tp
init|=
name|DefaultPalette
decl_stmt|;
name|int
name|n
decl_stmt|;
name|assert
argument_list|(
name|tp
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|COLORS
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|InPalette
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|SP_PARM
operator|->
name|_color_table
index|[
name|n
index|]
operator|=
name|tp
index|[
name|n
index|]
expr_stmt|;
block|}
else|else
block|{
name|SP_PARM
operator|->
name|_color_table
index|[
name|n
index|]
operator|=
name|tp
index|[
name|n
operator|%
name|MAX_PALETTE
index|]
expr_stmt|;
if|if
condition|(
name|UseHlsPalette
condition|)
block|{
name|SP_PARM
operator|->
name|_color_table
index|[
name|n
index|]
operator|.
name|green
operator|=
literal|100
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SP_PARM
operator|->
name|_color_table
index|[
name|n
index|]
operator|.
name|red
condition|)
name|SP_PARM
operator|->
name|_color_table
index|[
name|n
index|]
operator|.
name|red
operator|=
literal|1000
expr_stmt|;
if|if
condition|(
name|SP_PARM
operator|->
name|_color_table
index|[
name|n
index|]
operator|.
name|green
condition|)
name|SP_PARM
operator|->
name|_color_table
index|[
name|n
index|]
operator|.
name|green
operator|=
literal|1000
expr_stmt|;
if|if
condition|(
name|SP_PARM
operator|->
name|_color_table
index|[
name|n
index|]
operator|.
name|blue
condition|)
name|SP_PARM
operator|->
name|_color_table
index|[
name|n
index|]
operator|.
name|blue
operator|=
literal|1000
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Reset the color pair, e.g., to whatever color pair 0 is.  */
end_comment

begin_function
specifier|static
name|bool
name|reset_color_pair
parameter_list|(
name|NCURSES_SP_DCL0
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_TERM_DRIVER
return|return
name|CallDriver
argument_list|(
name|SP_PARM
argument_list|,
name|rescol
argument_list|)
return|;
else|#
directive|else
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
operator|(
name|void
operator|)
name|SP_PARM
expr_stmt|;
if|if
condition|(
name|orig_pair
operator|!=
literal|0
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"orig_pair"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|orig_pair
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|result
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Reset color pairs and definitions.  Actually we do both more to accommodate  * badly-written terminal descriptions than for the relatively rare case where  * someone has changed the color definitions.  */
end_comment

begin_function
name|NCURSES_EXPORT
function|(
name|bool
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|_nc_reset_colors
argument_list|)
parameter_list|(
name|NCURSES_SP_DCL0
parameter_list|)
block|{
name|int
name|result
init|=
name|FALSE
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"_nc_reset_colors(%p)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|SP_PARM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP_PARM
operator|->
name|_color_defs
operator|>
literal|0
condition|)
name|SP_PARM
operator|->
name|_color_defs
operator|=
operator|-
operator|(
name|SP_PARM
operator|->
name|_color_defs
operator|)
expr_stmt|;
if|if
condition|(
name|reset_color_pair
argument_list|(
name|NCURSES_SP_ARG
argument_list|)
condition|)
name|result
operator|=
name|TRUE
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_TERM_DRIVER
name|result
operator|=
name|CallDriver
argument_list|(
name|SP_PARM
argument_list|,
name|rescolors
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|orig_colors
operator|!=
literal|0
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"orig_colors"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|orig_colors
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
name|returnBool
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|bool
argument_list|)
end_macro

begin_macro
name|_nc_reset_colors
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
return|return
name|NCURSES_SP_NAME
argument_list|(
name|_nc_reset_colors
argument_list|)
argument_list|(
name|CURRENT_SCREEN
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|NCURSES_EXPORT
function|(
name|int
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|start_color
argument_list|)
parameter_list|(
name|NCURSES_SP_DCL0
parameter_list|)
block|{
name|int
name|result
init|=
name|ERR
decl_stmt|;
name|int
name|maxpairs
init|=
literal|0
decl_stmt|,
name|maxcolors
init|=
literal|0
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"start_color(%p)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|SP_PARM
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP_PARM
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|ERR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SP_PARM
operator|->
name|_coloron
condition|)
block|{
name|result
operator|=
name|OK
expr_stmt|;
block|}
else|else
block|{
name|maxpairs
operator|=
name|MaxPairs
expr_stmt|;
name|maxcolors
operator|=
name|MaxColors
expr_stmt|;
if|if
condition|(
name|reset_color_pair
argument_list|(
name|NCURSES_SP_ARG
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|set_foreground_color
argument_list|(
argument|NCURSES_SP_ARGx 				 default_fg(NCURSES_SP_ARG)
argument_list|,
argument|NCURSES_SP_NAME(_nc_outch)
argument_list|)
empty_stmt|;
name|set_background_color
argument_list|(
argument|NCURSES_SP_ARGx 				 default_bg(NCURSES_SP_ARG)
argument_list|,
argument|NCURSES_SP_NAME(_nc_outch)
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|maxpairs
operator|>
literal|0
operator|&&
name|maxcolors
operator|>
literal|0
condition|)
block|{
name|SP_PARM
operator|->
name|_pair_limit
operator|=
name|maxpairs
expr_stmt|;
if|#
directive|if
name|NCURSES_EXT_FUNCS
comment|/* 	     * If using default colors, allocate extra space in table to 	     * allow for default-color as a component of a color-pair. 	     */
name|SP_PARM
operator|->
name|_pair_limit
operator|+=
operator|(
literal|1
operator|+
operator|(
literal|2
operator|*
name|maxcolors
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|SP_PARM
operator|->
name|_pair_count
operator|=
name|maxpairs
expr_stmt|;
name|SP_PARM
operator|->
name|_color_count
operator|=
name|maxcolors
expr_stmt|;
if|#
directive|if
operator|!
name|USE_REENTRANT
name|COLOR_PAIRS
operator|=
name|maxpairs
expr_stmt|;
name|COLORS
operator|=
name|maxcolors
expr_stmt|;
endif|#
directive|endif
name|SP_PARM
operator|->
name|_color_pairs
operator|=
name|TYPE_CALLOC
argument_list|(
name|colorpair_t
argument_list|,
name|SP_PARM
operator|->
name|_pair_limit
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP_PARM
operator|->
name|_color_pairs
operator|!=
literal|0
condition|)
block|{
name|SP_PARM
operator|->
name|_color_table
operator|=
name|TYPE_CALLOC
argument_list|(
name|color_t
argument_list|,
name|maxcolors
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP_PARM
operator|->
name|_color_table
operator|!=
literal|0
condition|)
block|{
name|SP_PARM
operator|->
name|_color_pairs
index|[
literal|0
index|]
operator|=
name|PAIR_OF
argument_list|(
name|default_fg
argument_list|(
name|NCURSES_SP_ARG
argument_list|)
argument_list|,
name|default_bg
argument_list|(
name|NCURSES_SP_ARG
argument_list|)
argument_list|)
expr_stmt|;
name|init_color_table
argument_list|(
name|NCURSES_SP_ARG
argument_list|)
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"started color: COLORS = %d, COLOR_PAIRS = %d"
operator|,
name|COLORS
operator|,
name|COLOR_PAIRS
operator|)
argument_list|)
expr_stmt|;
name|SP_PARM
operator|->
name|_coloron
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|OK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SP_PARM
operator|->
name|_color_pairs
operator|!=
literal|0
condition|)
block|{
name|FreeAndNull
argument_list|(
name|SP_PARM
operator|->
name|_color_pairs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|result
operator|=
name|OK
expr_stmt|;
block|}
block|}
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|start_color
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
return|return
name|NCURSES_SP_NAME
argument_list|(
name|start_color
argument_list|)
argument_list|(
name|CURRENT_SCREEN
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function was originally written by Daniel Weaver<danw@znyx.com> */
end_comment

begin_function
specifier|static
name|void
name|rgb2hls
parameter_list|(
name|short
name|r
parameter_list|,
name|short
name|g
parameter_list|,
name|short
name|b
parameter_list|,
name|short
modifier|*
name|h
parameter_list|,
name|short
modifier|*
name|l
parameter_list|,
name|short
modifier|*
name|s
parameter_list|)
comment|/* convert RGB to HLS system */
block|{
name|short
name|min
decl_stmt|,
name|max
decl_stmt|,
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|min
operator|=
name|g
operator|<
name|r
condition|?
name|g
else|:
name|r
operator|)
operator|>
name|b
condition|)
name|min
operator|=
name|b
expr_stmt|;
if|if
condition|(
operator|(
name|max
operator|=
name|g
operator|>
name|r
condition|?
name|g
else|:
name|r
operator|)
operator|<
name|b
condition|)
name|max
operator|=
name|b
expr_stmt|;
comment|/* calculate lightness */
operator|*
name|l
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
name|min
operator|+
name|max
operator|)
operator|/
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|==
name|max
condition|)
block|{
comment|/* black, white and all shades of gray */
operator|*
name|h
operator|=
literal|0
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* calculate saturation */
if|if
condition|(
operator|*
name|l
operator|<
literal|50
condition|)
operator|*
name|s
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|*
literal|100
operator|)
operator|/
operator|(
name|max
operator|+
name|min
operator|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|s
operator|=
call|(
name|short
call|)
argument_list|(
operator|(
operator|(
name|max
operator|-
name|min
operator|)
operator|*
literal|100
operator|)
operator|/
operator|(
literal|2000
operator|-
name|max
operator|-
name|min
operator|)
argument_list|)
expr_stmt|;
comment|/* calculate hue */
if|if
condition|(
name|r
operator|==
name|max
condition|)
name|t
operator|=
call|(
name|short
call|)
argument_list|(
literal|120
operator|+
operator|(
operator|(
name|g
operator|-
name|b
operator|)
operator|*
literal|60
operator|)
operator|/
operator|(
name|max
operator|-
name|min
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|g
operator|==
name|max
condition|)
name|t
operator|=
call|(
name|short
call|)
argument_list|(
literal|240
operator|+
operator|(
operator|(
name|b
operator|-
name|r
operator|)
operator|*
literal|60
operator|)
operator|/
operator|(
name|max
operator|-
name|min
operator|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
call|(
name|short
call|)
argument_list|(
literal|360
operator|+
operator|(
operator|(
name|r
operator|-
name|g
operator|)
operator|*
literal|60
operator|)
operator|/
operator|(
name|max
operator|-
name|min
operator|)
argument_list|)
expr_stmt|;
operator|*
name|h
operator|=
name|t
operator|%
literal|360
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Extension (1997/1/18) - Allow negative f/b values to set default color  * values.  */
end_comment

begin_function
name|NCURSES_EXPORT
function|(
name|int
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|init_pair
argument_list|)
parameter_list|(
name|NCURSES_SP_DCLx
name|short
name|pair
parameter_list|,
name|short
name|f
parameter_list|,
name|short
name|b
parameter_list|)
block|{
name|colorpair_t
name|result
decl_stmt|;
name|colorpair_t
name|previous
decl_stmt|;
name|int
name|maxcolors
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"init_pair(%p,%d,%d,%d)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|SP_PARM
operator|,
name|pair
operator|,
name|f
operator|,
name|b
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ValidPair
argument_list|(
name|pair
argument_list|)
condition|)
name|returnCode
argument_list|(
name|ERR
argument_list|)
expr_stmt|;
name|maxcolors
operator|=
name|MaxColors
expr_stmt|;
name|previous
operator|=
name|SP_PARM
operator|->
name|_color_pairs
index|[
name|pair
index|]
expr_stmt|;
if|#
directive|if
name|NCURSES_EXT_FUNCS
if|if
condition|(
name|SP_PARM
operator|->
name|_default_color
condition|)
block|{
name|bool
name|isDefault
init|=
name|FALSE
decl_stmt|;
name|bool
name|wasDefault
init|=
name|FALSE
decl_stmt|;
name|int
name|default_pairs
init|=
name|SP_PARM
operator|->
name|_default_pairs
decl_stmt|;
comment|/* 	 * Map caller's color number, e.g., -1, 0, 1, .., 7, etc., into 	 * internal unsigned values which we will store in the _color_pairs[] 	 * table. 	 */
if|if
condition|(
name|isDefaultColor
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|f
operator|=
name|COLOR_DEFAULT
expr_stmt|;
name|isDefault
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|OkColorHi
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|returnCode
argument_list|(
name|ERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isDefaultColor
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|b
operator|=
name|COLOR_DEFAULT
expr_stmt|;
name|isDefault
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|OkColorHi
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|returnCode
argument_list|(
name|ERR
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check if the table entry that we are going to init/update used 	 * default colors. 	 */
if|if
condition|(
operator|(
name|FORE_OF
argument_list|(
name|previous
argument_list|)
operator|==
name|COLOR_DEFAULT
operator|)
operator|||
operator|(
name|BACK_OF
argument_list|(
name|previous
argument_list|)
operator|==
name|COLOR_DEFAULT
operator|)
condition|)
name|wasDefault
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 * Keep track of the number of entries in the color pair table which 	 * used a default color. 	 */
if|if
condition|(
name|isDefault
operator|&&
operator|!
name|wasDefault
condition|)
block|{
operator|++
name|default_pairs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wasDefault
operator|&&
operator|!
name|isDefault
condition|)
block|{
operator|--
name|default_pairs
expr_stmt|;
block|}
comment|/* 	 * As an extension, ncurses allows the pair number to exceed the 	 * terminal's color_pairs value for pairs using a default color. 	 * 	 * Note that updating a pair which used a default color with one 	 * that does not will decrement the count - and possibly interfere 	 * with sequentially adding new pairs. 	 */
if|if
condition|(
name|pair
operator|>
operator|(
name|SP_PARM
operator|->
name|_pair_count
operator|+
name|default_pairs
operator|)
condition|)
block|{
name|returnCode
argument_list|(
name|ERR
argument_list|)
expr_stmt|;
block|}
name|SP_PARM
operator|->
name|_default_pairs
operator|=
name|default_pairs
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
operator|(
name|f
operator|<
literal|0
operator|)
operator|||
operator|!
name|OkColorHi
argument_list|(
name|f
argument_list|)
operator|||
operator|(
name|b
operator|<
literal|0
operator|)
operator|||
operator|!
name|OkColorHi
argument_list|(
name|b
argument_list|)
operator|||
operator|(
name|pair
operator|<
literal|1
operator|)
condition|)
name|returnCode
argument_list|(
name|ERR
argument_list|)
expr_stmt|;
block|}
comment|/*      * When a pair's content is changed, replace its colors (if pair was      * initialized before a screen update is performed replacing original      * pair colors with the new ones).      */
name|result
operator|=
name|PAIR_OF
argument_list|(
name|f
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous
operator|!=
literal|0
operator|&&
name|previous
operator|!=
name|result
condition|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<=
name|CurScreen
argument_list|(
name|SP_PARM
argument_list|)
operator|->
name|_maxy
condition|;
name|y
operator|++
control|)
block|{
name|struct
name|ldat
modifier|*
name|ptr
init|=
operator|&
operator|(
name|CurScreen
argument_list|(
name|SP_PARM
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|)
decl_stmt|;
name|bool
name|changed
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|CurScreen
argument_list|(
name|SP_PARM
argument_list|)
operator|->
name|_maxx
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|GetPair
argument_list|(
name|ptr
operator|->
name|text
index|[
name|x
index|]
argument_list|)
operator|==
name|pair
condition|)
block|{
comment|/* Set the old cell to zero to ensure it will be 		       updated on the next doupdate() */
name|SetChar
argument_list|(
name|ptr
operator|->
name|text
index|[
name|x
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHANGED_CELL
argument_list|(
name|ptr
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|changed
condition|)
name|NCURSES_SP_NAME
function_decl|(
name|_nc_make_oldhash
function_decl|)
parameter_list|(
name|NCURSES_SP_ARGx
name|y
parameter_list|)
function_decl|;
block|}
block|}
name|SP_PARM
operator|->
name|_color_pairs
index|[
name|pair
index|]
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|GET_SCREEN_PAIR
argument_list|(
name|SP_PARM
argument_list|)
operator|==
name|pair
condition|)
name|SET_SCREEN_PAIR
argument_list|(
name|SP_PARM
argument_list|,
call|(
name|chtype
call|)
argument_list|(
operator|~
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* force attribute update */
ifdef|#
directive|ifdef
name|USE_TERM_DRIVER
name|CallDriver_3
argument_list|(
name|SP_PARM
argument_list|,
name|initpair
argument_list|,
name|pair
argument_list|,
name|f
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|initialize_pair
operator|&&
name|InPalette
argument_list|(
name|f
argument_list|)
operator|&&
name|InPalette
argument_list|(
name|b
argument_list|)
condition|)
block|{
specifier|const
name|color_t
modifier|*
name|tp
init|=
name|DefaultPalette
decl_stmt|;
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"
operator|,
name|pair
operator|,
name|tp
index|[
name|f
index|]
operator|.
name|red
operator|,
name|tp
index|[
name|f
index|]
operator|.
name|green
operator|,
name|tp
index|[
name|f
index|]
operator|.
name|blue
operator|,
name|tp
index|[
name|b
index|]
operator|.
name|red
operator|,
name|tp
index|[
name|b
index|]
operator|.
name|green
operator|,
name|tp
index|[
name|b
index|]
operator|.
name|blue
operator|)
argument_list|)
expr_stmt|;
name|TPUTS_TRACE
argument_list|(
literal|"initialize_pair"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|TPARM_7
argument_list|(
name|initialize_pair
argument_list|,
name|pair
argument_list|,
name|tp
index|[
name|f
index|]
operator|.
name|red
argument_list|,
name|tp
index|[
name|f
index|]
operator|.
name|green
argument_list|,
name|tp
index|[
name|f
index|]
operator|.
name|blue
argument_list|,
name|tp
index|[
name|b
index|]
operator|.
name|red
argument_list|,
name|tp
index|[
name|b
index|]
operator|.
name|green
argument_list|,
name|tp
index|[
name|b
index|]
operator|.
name|blue
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|returnCode
argument_list|(
name|OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|init_pair
argument_list|(
argument|short pair
argument_list|,
argument|short f
argument_list|,
argument|short b
argument_list|)
end_macro

begin_block
block|{
return|return
name|NCURSES_SP_NAME
argument_list|(
name|init_pair
argument_list|)
argument_list|(
name|CURRENT_SCREEN
argument_list|,
name|pair
argument_list|,
name|f
argument_list|,
name|b
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|okRGB
parameter_list|(
name|n
parameter_list|)
value|((n)>= 0&& (n)<= 1000)
end_define

begin_function
name|NCURSES_EXPORT
function|(
name|int
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|init_color
argument_list|)
parameter_list|(
name|NCURSES_SP_DCLx
name|short
name|color
parameter_list|,
name|short
name|r
parameter_list|,
name|short
name|g
parameter_list|,
name|short
name|b
parameter_list|)
block|{
name|int
name|result
init|=
name|ERR
decl_stmt|;
name|int
name|maxcolors
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"init_color(%p,%d,%d,%d,%d)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|SP_PARM
operator|,
name|color
operator|,
name|r
operator|,
name|g
operator|,
name|b
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP_PARM
operator|==
literal|0
condition|)
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|maxcolors
operator|=
name|MaxColors
expr_stmt|;
if|if
condition|(
name|InitColor
operator|&&
name|SP_PARM
operator|->
name|_coloron
operator|&&
operator|(
name|color
operator|>=
literal|0
operator|&&
name|OkColorHi
argument_list|(
name|color
argument_list|)
operator|)
operator|&&
operator|(
name|okRGB
argument_list|(
name|r
argument_list|)
operator|&&
name|okRGB
argument_list|(
name|g
argument_list|)
operator|&&
name|okRGB
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|init
operator|=
literal|1
expr_stmt|;
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|r
operator|=
name|r
expr_stmt|;
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|g
operator|=
name|g
expr_stmt|;
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|b
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|UseHlsPalette
condition|)
block|{
name|rgb2hls
argument_list|(
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
operator|&
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|red
argument_list|,
operator|&
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|green
argument_list|,
operator|&
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|blue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|red
operator|=
name|r
expr_stmt|;
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|green
operator|=
name|g
expr_stmt|;
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|blue
operator|=
name|b
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_TERM_DRIVER
name|CallDriver_4
argument_list|(
name|SP_PARM
argument_list|,
name|initcolor
argument_list|,
name|color
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|#
directive|else
name|TPUTS_TRACE
argument_list|(
literal|"initialize_color"
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|TPARM_4
argument_list|(
name|initialize_color
argument_list|,
name|color
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SP_PARM
operator|->
name|_color_defs
operator|=
name|max
argument_list|(
name|color
operator|+
literal|1
argument_list|,
name|SP_PARM
operator|->
name|_color_defs
argument_list|)
expr_stmt|;
name|result
operator|=
name|OK
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|init_color
argument_list|(
argument|short color
argument_list|,
argument|short r
argument_list|,
argument|short g
argument_list|,
argument|short b
argument_list|)
end_macro

begin_block
block|{
return|return
name|NCURSES_SP_NAME
argument_list|(
name|init_color
argument_list|)
argument_list|(
name|CURRENT_SCREEN
argument_list|,
name|color
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|NCURSES_EXPORT
function|(
name|bool
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|can_change_color
argument_list|)
parameter_list|(
name|NCURSES_SP_DCL
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"can_change_color(%p)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|SP_PARM
operator|)
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
operator|(
name|CanChange
operator|!=
literal|0
operator|)
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|bool
argument_list|)
end_macro

begin_macro
name|can_change_color
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
return|return
name|NCURSES_SP_NAME
argument_list|(
name|can_change_color
argument_list|)
argument_list|(
name|CURRENT_SCREEN
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|NCURSES_EXPORT
function|(
name|bool
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|has_colors
argument_list|)
parameter_list|(
name|NCURSES_SP_DCL0
parameter_list|)
block|{
name|int
name|code
decl_stmt|;
operator|(
name|void
operator|)
name|SP_PARM
expr_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"has_colors()"
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_TERM_DRIVER
name|code
operator|=
name|HasColor
expr_stmt|;
else|#
directive|else
name|code
operator|=
operator|(
operator|(
name|VALID_NUMERIC
argument_list|(
name|max_colors
argument_list|)
operator|&&
name|VALID_NUMERIC
argument_list|(
name|max_pairs
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|set_foreground
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|set_background
operator|!=
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|(
name|set_a_foreground
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|set_a_background
operator|!=
name|NULL
operator|)
operator|)
operator|||
name|set_color_pair
operator|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
expr_stmt|;
endif|#
directive|endif
name|returnCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|bool
argument_list|)
end_macro

begin_macro
name|has_colors
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
return|return
name|NCURSES_SP_NAME
argument_list|(
name|has_colors
argument_list|)
argument_list|(
name|CURRENT_SCREEN
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|NCURSES_EXPORT
function|(
name|int
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|color_content
argument_list|)
parameter_list|(
name|NCURSES_SP_DCLx
name|short
name|color
parameter_list|,
name|short
modifier|*
name|r
parameter_list|,
name|short
modifier|*
name|g
parameter_list|,
name|short
modifier|*
name|b
parameter_list|)
block|{
name|int
name|result
init|=
name|ERR
decl_stmt|;
name|int
name|maxcolors
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"color_content(%p,%d,%p,%p,%p)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|SP_PARM
operator|,
name|color
operator|,
operator|(
name|void
operator|*
operator|)
name|r
operator|,
operator|(
name|void
operator|*
operator|)
name|g
operator|,
operator|(
name|void
operator|*
operator|)
name|b
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP_PARM
operator|==
literal|0
condition|)
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|maxcolors
operator|=
name|MaxColors
expr_stmt|;
if|if
condition|(
name|color
operator|<
literal|0
operator|||
operator|!
name|OkColorHi
argument_list|(
name|color
argument_list|)
operator|||
operator|!
name|SP_PARM
operator|->
name|_coloron
condition|)
block|{
name|result
operator|=
name|ERR
expr_stmt|;
block|}
else|else
block|{
name|NCURSES_COLOR_T
name|c_r
init|=
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|red
decl_stmt|;
name|NCURSES_COLOR_T
name|c_g
init|=
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|green
decl_stmt|;
name|NCURSES_COLOR_T
name|c_b
init|=
name|SP_PARM
operator|->
name|_color_table
index|[
name|color
index|]
operator|.
name|blue
decl_stmt|;
if|if
condition|(
name|r
condition|)
operator|*
name|r
operator|=
name|c_r
expr_stmt|;
if|if
condition|(
name|g
condition|)
operator|*
name|g
operator|=
name|c_g
expr_stmt|;
if|if
condition|(
name|b
condition|)
operator|*
name|b
operator|=
name|c_b
expr_stmt|;
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"...color_content(%d,%d,%d,%d)"
operator|,
name|color
operator|,
name|c_r
operator|,
name|c_g
operator|,
name|c_b
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|OK
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|color_content
argument_list|(
argument|short color
argument_list|,
argument|short *r
argument_list|,
argument|short *g
argument_list|,
argument|short *b
argument_list|)
end_macro

begin_block
block|{
return|return
name|NCURSES_SP_NAME
argument_list|(
name|color_content
argument_list|)
argument_list|(
name|CURRENT_SCREEN
argument_list|,
name|color
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|NCURSES_EXPORT
function|(
name|int
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|pair_content
argument_list|)
parameter_list|(
name|NCURSES_SP_DCLx
name|short
name|pair
parameter_list|,
name|short
modifier|*
name|f
parameter_list|,
name|short
modifier|*
name|b
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"pair_content(%p,%d,%p,%p)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|SP_PARM
operator|,
name|pair
operator|,
operator|(
name|void
operator|*
operator|)
name|f
operator|,
operator|(
name|void
operator|*
operator|)
name|b
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ValidPair
argument_list|(
name|pair
argument_list|)
condition|)
block|{
name|result
operator|=
name|ERR
expr_stmt|;
block|}
else|else
block|{
name|NCURSES_COLOR_T
name|fg
init|=
name|FORE_OF
argument_list|(
name|SP_PARM
operator|->
name|_color_pairs
index|[
name|pair
index|]
argument_list|)
decl_stmt|;
name|NCURSES_COLOR_T
name|bg
init|=
name|BACK_OF
argument_list|(
name|SP_PARM
operator|->
name|_color_pairs
index|[
name|pair
index|]
argument_list|)
decl_stmt|;
if|#
directive|if
name|NCURSES_EXT_FUNCS
if|if
condition|(
name|fg
operator|==
name|COLOR_DEFAULT
condition|)
name|fg
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bg
operator|==
name|COLOR_DEFAULT
condition|)
name|bg
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|f
condition|)
operator|*
name|f
operator|=
name|fg
expr_stmt|;
if|if
condition|(
name|b
condition|)
operator|*
name|b
operator|=
name|bg
expr_stmt|;
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"...pair_content(%p,%d,%d,%d)"
operator|,
operator|(
name|void
operator|*
operator|)
name|SP_PARM
operator|,
name|pair
operator|,
name|fg
operator|,
name|bg
operator|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|OK
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|pair_content
argument_list|(
argument|short pair
argument_list|,
argument|short *f
argument_list|,
argument|short *b
argument_list|)
end_macro

begin_block
block|{
return|return
name|NCURSES_SP_NAME
argument_list|(
name|pair_content
argument_list|)
argument_list|(
name|CURRENT_SCREEN
argument_list|,
name|pair
argument_list|,
name|f
argument_list|,
name|b
argument_list|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|NCURSES_EXPORT
function|(
name|void
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|_nc_do_color
argument_list|)
parameter_list|(
name|NCURSES_SP_DCLx
name|short
name|old_pair
parameter_list|,
name|short
name|pair
parameter_list|,
name|bool
name|reverse
parameter_list|,
name|NCURSES_SP_OUTC
name|outc
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_TERM_DRIVER
name|CallDriver_4
argument_list|(
name|SP_PARM
argument_list|,
name|docolor
argument_list|,
name|old_pair
argument_list|,
name|pair
argument_list|,
name|reverse
argument_list|,
name|outc
argument_list|)
expr_stmt|;
else|#
directive|else
name|NCURSES_COLOR_T
name|fg
init|=
name|COLOR_DEFAULT
decl_stmt|;
name|NCURSES_COLOR_T
name|bg
init|=
name|COLOR_DEFAULT
decl_stmt|;
name|NCURSES_COLOR_T
name|old_fg
decl_stmt|,
name|old_bg
decl_stmt|;
if|if
condition|(
operator|!
name|ValidPair
argument_list|(
name|pair
argument_list|)
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|pair
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|set_color_pair
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"set_color_pair"
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
argument|tputs
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|TPARM_1
argument_list|(
name|set_color_pair
argument_list|,
name|pair
argument_list|)
operator|,
literal|1
operator|,
name|outc
operator|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|SP_PARM
operator|!=
literal|0
condition|)
block|{
name|pair_content
argument_list|(
operator|(
name|short
operator|)
name|pair
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old_pair
operator|>=
literal|0
operator|&&
name|SP_PARM
operator|!=
literal|0
operator|&&
name|pair_content
argument_list|(
name|old_pair
argument_list|,
operator|&
name|old_fg
argument_list|,
operator|&
name|old_bg
argument_list|)
operator|!=
name|ERR
condition|)
block|{
if|if
condition|(
operator|(
name|isDefaultColor
argument_list|(
name|fg
argument_list|)
operator|&&
operator|!
name|isDefaultColor
argument_list|(
name|old_fg
argument_list|)
operator|)
operator|||
operator|(
name|isDefaultColor
argument_list|(
name|bg
argument_list|)
operator|&&
operator|!
name|isDefaultColor
argument_list|(
name|old_bg
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|NCURSES_EXT_FUNCS
comment|/* 	     * A minor optimization - but extension.  If "AX" is specified in 	     * the terminal description, treat it as screen's indicator of ECMA 	     * SGR 39 and SGR 49, and assume the two sequences are independent. 	     */
if|if
condition|(
name|SP_PARM
operator|->
name|_has_sgr_39_49
operator|&&
name|isDefaultColor
argument_list|(
name|old_bg
argument_list|)
operator|&&
operator|!
name|isDefaultColor
argument_list|(
name|old_fg
argument_list|)
condition|)
block|{
name|NCURSES_SP_NAME
argument_list|(
name|tputs
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"\033[39m"
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SP_PARM
operator|->
name|_has_sgr_39_49
operator|&&
name|isDefaultColor
argument_list|(
name|old_fg
argument_list|)
operator|&&
operator|!
name|isDefaultColor
argument_list|(
name|old_bg
argument_list|)
condition|)
block|{
name|NCURSES_SP_NAME
argument_list|(
name|tputs
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"\033[49m"
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|reset_color_pair
argument_list|(
name|NCURSES_SP_ARG
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|reset_color_pair
argument_list|(
name|NCURSES_SP_ARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_pair
operator|<
literal|0
condition|)
return|return;
block|}
if|#
directive|if
name|NCURSES_EXT_FUNCS
if|if
condition|(
name|isDefaultColor
argument_list|(
name|fg
argument_list|)
condition|)
name|fg
operator|=
operator|(
name|short
operator|)
name|default_fg
argument_list|(
name|NCURSES_SP_ARG
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDefaultColor
argument_list|(
name|bg
argument_list|)
condition|)
name|bg
operator|=
operator|(
name|short
operator|)
name|default_bg
argument_list|(
name|NCURSES_SP_ARG
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|reverse
condition|)
block|{
name|NCURSES_COLOR_T
name|xx
init|=
name|fg
decl_stmt|;
name|fg
operator|=
name|bg
expr_stmt|;
name|bg
operator|=
name|xx
expr_stmt|;
block|}
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"setting colors: pair = %d, fg = %d, bg = %d"
operator|,
name|pair
operator|,
name|fg
operator|,
name|bg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isDefaultColor
argument_list|(
name|fg
argument_list|)
condition|)
block|{
name|set_foreground_color
argument_list|(
argument|NCURSES_SP_ARGx fg
argument_list|,
argument|outc
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
operator|!
name|isDefaultColor
argument_list|(
name|bg
argument_list|)
condition|)
block|{
name|set_background_color
argument_list|(
argument|NCURSES_SP_ARGx bg
argument_list|,
argument|outc
argument_list|)
empty_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_do_color
argument_list|(
argument|short old_pair
argument_list|,
argument|short pair
argument_list|,
argument|bool reverse
argument_list|,
argument|NCURSES_OUTC outc
argument_list|)
end_macro

begin_block
block|{
name|SetSafeOutcWrapper
argument_list|(
name|outc
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
function_decl|(
name|_nc_do_color
function_decl|)
parameter_list|(
name|CURRENT_SCREEN
parameter_list|,
name|old_pair
parameter_list|,
name|pair
parameter_list|,
name|reverse
parameter_list|,
name|_nc_outc_wrapper
parameter_list|)
function_decl|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

