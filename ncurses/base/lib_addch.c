begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2006,2008 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/* **	lib_addch.c ** **	The routine waddch(). ** */
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: lib_addch.c,v 1.113 2008/08/16 19:20:04 tom Exp $"
argument_list|)
end_macro

begin_decl_stmt
specifier|static
specifier|const
name|NCURSES_CH_T
name|blankchar
init|=
name|NewChar
argument_list|(
name|BLANK_TEXT
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Ugly microtweaking alert.  Everything from here to end of module is  * likely to be speed-critical -- profiling data sure says it is!  * Most of the important screen-painting functions are shells around  * waddch().  So we make every effort to reduce function-call overhead  * by inlining stuff, even at the cost of making wrapped copies for  * export.  Also we supply some internal versions that don't call the  * window sync hook, for use by string-put functions.  */
end_comment

begin_comment
comment|/* Return bit mask for clearing color pair number if given ch has color */
end_comment

begin_define
define|#
directive|define
name|COLOR_MASK
parameter_list|(
name|ch
parameter_list|)
value|(~(attr_t)((ch)& A_COLOR ? A_COLOR : 0))
end_define

begin_function
specifier|static
name|NCURSES_INLINE
name|NCURSES_CH_T
name|render_char
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|NCURSES_CH_T
name|ch
parameter_list|)
comment|/* compute a rendition of the given char correct for the current context */
block|{
name|attr_t
name|a
init|=
name|WINDOW_ATTRS
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|int
name|pair
init|=
name|GetPair
argument_list|(
name|ch
argument_list|)
decl_stmt|;
if|if
condition|(
name|ISBLANK
argument_list|(
name|ch
argument_list|)
operator|&&
name|AttrOf
argument_list|(
name|ch
argument_list|)
operator|==
name|A_NORMAL
operator|&&
name|pair
operator|==
literal|0
condition|)
block|{
comment|/* color/pair in attrs has precedence over bkgrnd */
name|ch
operator|=
name|win
operator|->
name|_nc_bkgd
expr_stmt|;
name|SetAttr
argument_list|(
name|ch
argument_list|,
name|a
operator||
name|AttrOf
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pair
operator|=
name|GET_WINDOW_PAIR
argument_list|(
name|win
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|pair
operator|=
name|GetPair
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
expr_stmt|;
name|SetPair
argument_list|(
name|ch
argument_list|,
name|pair
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* color in attrs has precedence over bkgrnd */
name|a
operator||=
name|AttrOf
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
operator|&
name|COLOR_MASK
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* color in ch has precedence */
if|if
condition|(
name|pair
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pair
operator|=
name|GET_WINDOW_PAIR
argument_list|(
name|win
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|pair
operator|=
name|GetPair
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (pair> 255) { 	    NCURSES_CH_T fixme = ch; 	    SetPair(fixme, pair); 	}
endif|#
directive|endif
name|AddAttr
argument_list|(
name|ch
argument_list|,
operator|(
name|a
operator|&
name|COLOR_MASK
argument_list|(
name|AttrOf
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SetPair
argument_list|(
name|ch
argument_list|,
name|pair
argument_list|)
expr_stmt|;
block|}
name|TR
argument_list|(
name|TRACE_VIRTPUT
argument_list|,
operator|(
literal|"render_char bkg %s (%d), attrs %s (%d) -> ch %s (%d)"
operator|,
name|_tracech_t2
argument_list|(
literal|1
argument_list|,
name|CHREF
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
argument_list|)
operator|,
name|GetPair
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
operator|,
name|_traceattr
argument_list|(
name|WINDOW_ATTRS
argument_list|(
name|win
argument_list|)
argument_list|)
operator|,
name|GET_WINDOW_PAIR
argument_list|(
name|win
argument_list|)
operator|,
name|_tracech_t2
argument_list|(
literal|3
argument_list|,
name|CHREF
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|,
name|GetPair
argument_list|(
name|ch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|NCURSES_CH_T
argument_list|)
end_macro

begin_macro
name|_nc_render
argument_list|(
argument|WINDOW *win
argument_list|,
argument|NCURSES_CH_T ch
argument_list|)
end_macro

begin_comment
comment|/* make render_char() visible while still allowing us to inline it below */
end_comment

begin_block
block|{
return|return
name|render_char
argument_list|(
name|win
argument_list|,
name|ch
argument_list|)
return|;
block|}
end_block

begin_comment
comment|/* check if position is legal; if not, return error */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|/* treat this like an assertion */
end_comment

begin_define
define|#
directive|define
name|CHECK_POSITION
parameter_list|(
name|win
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|if (y> win->_maxy \ 	 || x> win->_maxx \ 	 || y< 0 \ 	 || x< 0) { \ 		TR(TRACE_VIRTPUT, ("Alert! Win=%p _curx = %d, _cury = %d " \ 				   "(_maxx = %d, _maxy = %d)", win, x, y, \ 				   win->_maxx, win->_maxy)); \ 		return(ERR); \ 	}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECK_POSITION
parameter_list|(
name|win
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bool
name|newline_forces_scroll
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|NCURSES_SIZE_T
modifier|*
name|ypos
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|*
name|ypos
operator|>=
name|win
operator|->
name|_regtop
operator|&&
operator|*
name|ypos
operator|==
name|win
operator|->
name|_regbottom
condition|)
block|{
operator|*
name|ypos
operator|=
name|win
operator|->
name|_regbottom
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ypos
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * The _WRAPPED flag is useful only for telling an application that we've just  * wrapped the cursor.  We don't do anything with this flag except set it when  * wrapping, and clear it whenever we move the cursor.  If we try to wrap at  * the lower-right corner of a window, we cannot move the cursor (since that  * wouldn't be legal).  So we return an error (which is what SVr4 does).   * Unlike SVr4, we can successfully add a character to the lower-right corner  * (Solaris 2.6 does this also, however).  */
end_comment

begin_function
specifier|static
name|int
name|wrap_to_next_line
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|win
operator|->
name|_flags
operator||=
name|_WRAPPED
expr_stmt|;
if|if
condition|(
name|newline_forces_scroll
argument_list|(
name|win
argument_list|,
operator|&
operator|(
name|win
operator|->
name|_cury
operator|)
argument_list|)
condition|)
block|{
name|win
operator|->
name|_curx
operator|=
name|win
operator|->
name|_maxx
expr_stmt|;
if|if
condition|(
operator|!
name|win
operator|->
name|_scroll
condition|)
return|return
operator|(
name|ERR
operator|)
return|;
name|scroll
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
name|win
operator|->
name|_curx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_function_decl
specifier|static
name|int
name|waddch_literal
parameter_list|(
name|WINDOW
modifier|*
parameter_list|,
name|NCURSES_CH_T
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Fill the given number of cells with blanks using the current background  * rendition.  This saves/restores the current x-position.  */
end_comment

begin_function
specifier|static
name|void
name|fill_cells
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|NCURSES_CH_T
name|blank
init|=
name|blankchar
decl_stmt|;
name|int
name|save_x
init|=
name|win
operator|->
name|_curx
decl_stmt|;
name|int
name|save_y
init|=
name|win
operator|->
name|_cury
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|waddch_literal
argument_list|(
name|win
argument_list|,
name|blank
argument_list|)
operator|==
name|ERR
condition|)
break|break;
block|}
name|win
operator|->
name|_curx
operator|=
name|save_x
expr_stmt|;
name|win
operator|->
name|_cury
operator|=
name|save_y
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Build up the bytes for a multibyte character, returning the length when  * complete (a positive number), -1 for error and -2 for incomplete.  */
end_comment

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_build_wch
argument_list|(
argument|WINDOW *win
argument_list|,
argument|ARG_CH_T ch
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|buffer
init|=
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_work
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|x
init|=
name|win
operator|->
name|_curx
decl_stmt|;
name|int
name|y
init|=
name|win
operator|->
name|_cury
decl_stmt|;
name|mbstate_t
name|state
decl_stmt|;
name|wchar_t
name|result
decl_stmt|;
if|if
condition|(
operator|(
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_used
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_x
argument_list|)
operator|!=
name|x
operator|||
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_y
argument_list|)
operator|!=
name|y
operator|)
condition|)
block|{
comment|/* discard the incomplete multibyte character */
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_used
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TR
argument_list|(
name|TRACE_VIRTPUT
argument_list|,
operator|(
literal|"Alert discarded multibyte on move (%d,%d) -> (%d,%d)"
operator|,
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_y
argument_list|)
operator|,
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_x
argument_list|)
operator|,
name|y
operator|,
name|x
operator|)
argument_list|)
expr_stmt|;
block|}
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_x
argument_list|)
operator|=
name|x
expr_stmt|;
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_y
argument_list|)
operator|=
name|y
expr_stmt|;
name|init_mb
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|buffer
index|[
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_used
argument_list|)
index|]
operator|=
operator|(
name|char
operator|)
name|CharOf
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_used
argument_list|)
operator|+=
literal|1
expr_stmt|;
name|buffer
index|[
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_used
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|mbrtowc
argument_list|(
operator|&
name|result
argument_list|,
name|buffer
argument_list|,
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_used
argument_list|)
argument_list|,
operator|&
name|state
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|attr_t
name|attrs
init|=
name|AttrOf
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|)
decl_stmt|;
name|if_EXT_COLORS
argument_list|(
argument|int pair = GetPair(CHDEREF(ch))
argument_list|)
empty_stmt|;
name|SetChar
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|,
name|result
argument_list|,
name|attrs
argument_list|)
expr_stmt|;
name|if_EXT_COLORS
argument_list|(
name|SetPair
argument_list|(
name|CHDEREF
argument_list|(
name|ch
argument_list|)
argument_list|,
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_used
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 	 * An error occurred.  We could either discard everything, 	 * or assume that the error was in the previous input. 	 * Try the latter. 	 */
name|TR
argument_list|(
name|TRACE_VIRTPUT
argument_list|,
operator|(
literal|"Alert! mbrtowc returns error"
operator|)
argument_list|)
expr_stmt|;
comment|/* handle this with unctrl() */
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_used
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WIDEC_SUPPORT */
end_comment

begin_function
specifier|static
if|#
directive|if
operator|!
name|USE_WIDEC_SUPPORT
comment|/* cannot be inline if it is recursive */
name|NCURSES_INLINE
endif|#
directive|endif
name|int
name|waddch_literal
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|NCURSES_CH_T
name|ch
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|struct
name|ldat
modifier|*
name|line
decl_stmt|;
name|x
operator|=
name|win
operator|->
name|_curx
expr_stmt|;
name|y
operator|=
name|win
operator|->
name|_cury
expr_stmt|;
name|CHECK_POSITION
argument_list|(
name|win
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|ch
operator|=
name|render_char
argument_list|(
name|win
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|line
operator|=
name|win
operator|->
name|_line
operator|+
name|y
expr_stmt|;
name|CHANGED_CELL
argument_list|(
name|line
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/*      * Build up multibyte characters until we have a wide-character.      */
name|if_WIDEC
argument_list|(
argument|{ 	if (WINDOW_EXT(win, addch_used) !=
literal|0
argument||| !Charable(ch)) { 	    int len = _nc_build_wch(win, CHREF(ch));  	    if (len>= -
literal|1
argument|) {
comment|/* handle EILSEQ */
argument|if (is8bits(CharOf(ch))) { 		    const char *s = unctrl((chtype) CharOf(ch)); 		    if (s[
literal|1
argument|] !=
literal|0
argument|) { 			return waddstr(win, s); 		    } 		} 		if (len == -
literal|1
argument|) 		    return waddch(win,
literal|' '
argument|); 	    } else { 		return OK; 	    } 	}     }
argument_list|)
empty_stmt|;
comment|/*      * Non-spacing characters are added to the current cell.      *      * Spacing characters that are wider than one column require some display      * adjustments.      */
name|if_WIDEC
argument_list|(
argument|{ 	int len = wcwidth(CharOf(ch)); 	int i; 	int j; 	wchar_t *chars;  	if (len ==
literal|0
argument|) {
comment|/* non-spacing */
argument|if ((x>
literal|0
argument|&& y>=
literal|0
argument|) 		|| (win->_maxx>=
literal|0
argument|&& win->_cury>=
literal|1
argument|)) { 		if (x>
literal|0
argument|&& y>=
literal|0
argument|) 		    chars = (win->_line[y].text[x -
literal|1
argument|].chars); 		else 		    chars = (win->_line[y -
literal|1
argument|].text[win->_maxx].chars); 		for (i =
literal|0
argument|; i< CCHARW_MAX; ++i) { 		    if (chars[i] ==
literal|0
argument|) { 			TR(TRACE_VIRTPUT, 			   (
literal|"added non-spacing %d: %x"
argument|, 			    x, (int) CharOf(ch))); 			chars[i] = CharOf(ch); 			break; 		    } 		} 	    } 	    goto testwrapping; 	} else if (len>
literal|1
argument|) {
comment|/* multi-column characters */
comment|/* 	     * Check if the character will fit on the current line.  If it does 	     * not fit, fill in the remainder of the line with blanks.  and 	     * move to the next line. 	     */
argument|if (len> win->_maxx +
literal|1
argument|) { 		TR(TRACE_VIRTPUT, (
literal|"character will not fit"
argument|)); 		return ERR; 	    } else if (x + len> win->_maxx +
literal|1
argument|) { 		int count = win->_maxx +
literal|1
argument|- x; 		TR(TRACE_VIRTPUT, (
literal|"fill %d remaining cells"
argument|, count)); 		fill_cells(win, count); 		if (wrap_to_next_line(win) == ERR) 		    return ERR; 		x = win->_curx; 		y = win->_cury; 	    }
comment|/* 	     * Check for cells which are orphaned by adding this character, set 	     * those to blanks. 	     * 	     * FIXME: this actually could fill j-i cells, more complicated to 	     * setup though. 	     */
argument|for (i =
literal|0
argument|; i< len; ++i) { 		if (isWidecBase(win->_line[y].text[x + i])) { 		    break; 		} else if (isWidecExt(win->_line[y].text[x + i])) { 		    for (j = i; x + j<= win->_maxx; ++j) { 			if (!isWidecExt(win->_line[y].text[x + j])) { 			    TR(TRACE_VIRTPUT, (
literal|"fill %d orphan cells"
argument|, j)); 			    fill_cells(win, j); 			    break; 			} 		    } 		    break; 		} 	    }
comment|/* 	     * Finally, add the cells for this character. 	     */
argument|for (i =
literal|0
argument|; i< len; ++i) { 		NCURSES_CH_T value = ch; 		SetWidecExt(value, i); 		TR(TRACE_VIRTPUT, (
literal|"multicolumn %d:%d (%d,%d)"
argument|, 				   i +
literal|1
argument|, len, 				   win->_begy + y, win->_begx + x)); 		line->text[x] = value; 		CHANGED_CELL(line, x); 		++x; 	    } 	    goto testwrapping; 	}     }
argument_list|)
empty_stmt|;
comment|/*      * Single-column characters.      */
name|line
operator|->
name|text
index|[
name|x
operator|++
index|]
operator|=
name|ch
expr_stmt|;
comment|/*      * This label is used only for wide-characters.      */
name|if_WIDEC
argument_list|(
name|testwrapping
operator|:
argument_list|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_VIRTPUT
argument_list|,
operator|(
literal|"cell (%ld, %ld..%d) = %s"
operator|,
operator|(
name|long
operator|)
name|win
operator|->
name|_cury
operator|,
operator|(
name|long
operator|)
name|win
operator|->
name|_curx
operator|,
name|x
operator|-
literal|1
operator|,
name|_tracech_t
argument_list|(
name|CHREF
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|win
operator|->
name|_maxx
condition|)
block|{
return|return
name|wrap_to_next_line
argument_list|(
name|win
argument_list|)
return|;
block|}
name|win
operator|->
name|_curx
operator|=
name|x
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
name|int
name|waddch_nosync
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
specifier|const
name|NCURSES_CH_T
name|ch
parameter_list|)
comment|/* the workhorse function -- add a character to the given window */
block|{
name|NCURSES_SIZE_T
name|x
decl_stmt|,
name|y
decl_stmt|;
name|chtype
name|t
init|=
name|CharOf
argument_list|(
name|ch
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|unctrl
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/*      * If we are using the alternate character set, forget about locale.      * Otherwise, if unctrl() returns a single-character or the locale      * claims the code is printable, treat it that way.      */
if|if
condition|(
operator|(
name|AttrOf
argument_list|(
name|ch
argument_list|)
operator|&
name|A_ALTCHARSET
operator|)
operator|||
operator|(
if|#
directive|if
name|USE_WIDEC_SUPPORT
operator|(
name|SP
operator|!=
literal|0
operator|&&
name|SP
operator|->
name|_legacy_coding
operator|)
operator|&&
endif|#
directive|endif
name|s
index|[
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|isprint
argument_list|(
name|t
argument_list|)
if|#
directive|if
name|USE_WIDEC_SUPPORT
operator|||
operator|(
operator|(
name|SP
operator|==
literal|0
operator|||
operator|!
name|SP
operator|->
name|_legacy_coding
operator|)
operator|&&
operator|(
name|WINDOW_EXT
argument_list|(
name|win
argument_list|,
name|addch_used
argument_list|)
operator|||
operator|!
name|_nc_is_charable
argument_list|(
name|CharOf
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|)
operator|)
endif|#
directive|endif
operator|)
condition|)
return|return
name|waddch_literal
argument_list|(
name|win
argument_list|,
name|ch
argument_list|)
return|;
comment|/*      * Handle carriage control and other codes that are not printable, or are      * known to expand to more than one character according to unctrl().      */
name|x
operator|=
name|win
operator|->
name|_curx
expr_stmt|;
name|y
operator|=
name|win
operator|->
name|_cury
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
literal|'\t'
case|:
name|x
operator|+=
operator|(
name|TABSIZE
operator|-
operator|(
name|x
operator|%
name|TABSIZE
operator|)
operator|)
expr_stmt|;
comment|/* 	 * Space-fill the tab on the bottom line so that we'll get the 	 * "correct" cursor position. 	 */
if|if
condition|(
operator|(
operator|!
name|win
operator|->
name|_scroll
operator|&&
operator|(
name|y
operator|==
name|win
operator|->
name|_regbottom
operator|)
operator|)
operator|||
operator|(
name|x
operator|<=
name|win
operator|->
name|_maxx
operator|)
condition|)
block|{
name|NCURSES_CH_T
name|blank
init|=
name|blankchar
decl_stmt|;
name|AddAttr
argument_list|(
name|blank
argument_list|,
name|AttrOf
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|win
operator|->
name|_curx
operator|<
name|x
condition|)
block|{
if|if
condition|(
name|waddch_literal
argument_list|(
name|win
argument_list|,
name|blank
argument_list|)
operator|==
name|ERR
condition|)
return|return
operator|(
name|ERR
operator|)
return|;
block|}
break|break;
block|}
else|else
block|{
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|win
operator|->
name|_flags
operator||=
name|_WRAPPED
expr_stmt|;
if|if
condition|(
name|newline_forces_scroll
argument_list|(
name|win
argument_list|,
operator|&
name|y
argument_list|)
condition|)
block|{
name|x
operator|=
name|win
operator|->
name|_maxx
expr_stmt|;
if|if
condition|(
name|win
operator|->
name|_scroll
condition|)
block|{
name|scroll
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'\n'
case|:
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|newline_forces_scroll
argument_list|(
name|win
argument_list|,
operator|&
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|win
operator|->
name|_scroll
condition|)
name|scroll
argument_list|(
name|win
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|ERR
operator|)
return|;
block|}
comment|/* FALLTHRU */
case|case
literal|'\r'
case|:
name|x
operator|=
literal|0
expr_stmt|;
name|win
operator|->
name|_flags
operator|&=
operator|~
name|_WRAPPED
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
operator|(
name|OK
operator|)
return|;
name|x
operator|--
expr_stmt|;
name|win
operator|->
name|_flags
operator|&=
operator|~
name|_WRAPPED
expr_stmt|;
break|break;
default|default:
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|NCURSES_CH_T
name|sch
decl_stmt|;
name|SetChar
argument_list|(
name|sch
argument_list|,
operator|*
name|s
operator|++
argument_list|,
name|AttrOf
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
name|if_EXT_COLORS
argument_list|(
name|SetPair
argument_list|(
name|sch
argument_list|,
name|GetPair
argument_list|(
name|ch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|waddch_literal
argument_list|(
name|win
argument_list|,
name|sch
argument_list|)
operator|==
name|ERR
condition|)
return|return
name|ERR
return|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
name|win
operator|->
name|_curx
operator|=
name|x
expr_stmt|;
name|win
operator|->
name|_cury
operator|=
name|y
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|_nc_waddch_nosync
argument_list|(
argument|WINDOW *win
argument_list|,
argument|const NCURSES_CH_T c
argument_list|)
end_macro

begin_comment
comment|/* export copy of waddch_nosync() so the string-put functions can use it */
end_comment

begin_block
block|{
return|return
operator|(
name|waddch_nosync
argument_list|(
name|win
argument_list|,
name|c
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The versions below call _nc_synchook().  We wanted to avoid this in the  * version exported for string puts; they'll call _nc_synchook once at end  * of run.  */
end_comment

begin_comment
comment|/* These are actual entry points */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|waddch
argument_list|(
argument|WINDOW *win
argument_list|,
argument|const chtype ch
argument_list|)
end_macro

begin_block
block|{
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|NCURSES_CH_T
name|wch
decl_stmt|;
name|SetChar2
argument_list|(
name|wch
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_VIRTPUT
operator||
name|TRACE_CCALLS
argument_list|,
operator|(
name|T_CALLED
argument_list|(
literal|"waddch(%p, %s)"
argument_list|)
operator|,
name|win
operator|,
name|_tracechtype
argument_list|(
name|ch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|&&
operator|(
name|waddch_nosync
argument_list|(
name|win
argument_list|,
name|wch
argument_list|)
operator|!=
name|ERR
operator|)
condition|)
block|{
name|_nc_synchook
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|code
operator|=
name|OK
expr_stmt|;
block|}
name|TR
argument_list|(
name|TRACE_VIRTPUT
operator||
name|TRACE_CCALLS
argument_list|,
operator|(
name|T_RETURN
argument_list|(
literal|"%d"
argument_list|)
operator|,
name|code
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|wechochar
argument_list|(
argument|WINDOW *win
argument_list|,
argument|const chtype ch
argument_list|)
end_macro

begin_block
block|{
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|NCURSES_CH_T
name|wch
decl_stmt|;
name|SetChar2
argument_list|(
name|wch
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_VIRTPUT
operator||
name|TRACE_CCALLS
argument_list|,
operator|(
name|T_CALLED
argument_list|(
literal|"wechochar(%p, %s)"
argument_list|)
operator|,
name|win
operator|,
name|_tracechtype
argument_list|(
name|ch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|&&
operator|(
name|waddch_nosync
argument_list|(
name|win
argument_list|,
name|wch
argument_list|)
operator|!=
name|ERR
operator|)
condition|)
block|{
name|bool
name|save_immed
init|=
name|win
operator|->
name|_immed
decl_stmt|;
name|win
operator|->
name|_immed
operator|=
name|TRUE
expr_stmt|;
name|_nc_synchook
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|win
operator|->
name|_immed
operator|=
name|save_immed
expr_stmt|;
name|code
operator|=
name|OK
expr_stmt|;
block|}
name|TR
argument_list|(
name|TRACE_VIRTPUT
operator||
name|TRACE_CCALLS
argument_list|,
operator|(
name|T_RETURN
argument_list|(
literal|"%d"
argument_list|)
operator|,
name|code
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
end_block

end_unit

