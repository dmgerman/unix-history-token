begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 2004-2009,2010 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/* **	lib_add_wch.c ** **	The routine wadd_wch(). ** */
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_if
if|#
directive|if
name|HAVE_WCTYPE_H
end_if

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: lib_add_wch.c,v 1.11 2010/12/19 01:32:55 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/* clone/adapt lib_addch.c */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|cchar_t
name|blankchar
init|=
name|NewChar
argument_list|(
name|BLANK_TEXT
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Ugly microtweaking alert.  Everything from here to end of module is  * likely to be speed-critical -- profiling data sure says it is!  * Most of the important screen-painting functions are shells around  * wadd_wch().  So we make every effort to reduce function-call overhead  * by inlining stuff, even at the cost of making wrapped copies for  * export.  Also we supply some internal versions that don't call the  * window sync hook, for use by string-put functions.  */
end_comment

begin_comment
comment|/* Return bit mask for clearing color pair number if given ch has color */
end_comment

begin_define
define|#
directive|define
name|COLOR_MASK
parameter_list|(
name|ch
parameter_list|)
value|(~(attr_t)((ch)& A_COLOR ? A_COLOR : 0))
end_define

begin_function
specifier|static
name|NCURSES_INLINE
name|cchar_t
name|render_char
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|cchar_t
name|ch
parameter_list|)
comment|/* compute a rendition of the given char correct for the current context */
block|{
name|attr_t
name|a
init|=
name|WINDOW_ATTRS
argument_list|(
name|win
argument_list|)
decl_stmt|;
name|int
name|pair
init|=
name|GetPair
argument_list|(
name|ch
argument_list|)
decl_stmt|;
if|if
condition|(
name|ISBLANK
argument_list|(
name|ch
argument_list|)
operator|&&
name|AttrOf
argument_list|(
name|ch
argument_list|)
operator|==
name|A_NORMAL
operator|&&
name|pair
operator|==
literal|0
condition|)
block|{
comment|/* color/pair in attrs has precedence over bkgrnd */
name|ch
operator|=
name|win
operator|->
name|_nc_bkgd
expr_stmt|;
name|SetAttr
argument_list|(
name|ch
argument_list|,
name|a
operator||
name|AttrOf
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pair
operator|=
name|GET_WINDOW_PAIR
argument_list|(
name|win
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|pair
operator|=
name|GetPair
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
expr_stmt|;
name|SetPair
argument_list|(
name|ch
argument_list|,
name|pair
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* color in attrs has precedence over bkgrnd */
name|a
operator||=
name|AttrOf
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
operator|&
name|COLOR_MASK
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* color in ch has precedence */
if|if
condition|(
name|pair
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|pair
operator|=
name|GET_WINDOW_PAIR
argument_list|(
name|win
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|pair
operator|=
name|GetPair
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
expr_stmt|;
block|}
name|AddAttr
argument_list|(
name|ch
argument_list|,
operator|(
name|a
operator|&
name|COLOR_MASK
argument_list|(
name|AttrOf
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SetPair
argument_list|(
name|ch
argument_list|,
name|pair
argument_list|)
expr_stmt|;
block|}
name|TR
argument_list|(
name|TRACE_VIRTPUT
argument_list|,
operator|(
literal|"render_char bkg %s (%d), attrs %s (%d) -> ch %s (%d)"
operator|,
name|_tracech_t2
argument_list|(
literal|1
argument_list|,
name|CHREF
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
argument_list|)
operator|,
name|GetPair
argument_list|(
name|win
operator|->
name|_nc_bkgd
argument_list|)
operator|,
name|_traceattr
argument_list|(
name|WINDOW_ATTRS
argument_list|(
name|win
argument_list|)
argument_list|)
operator|,
name|GET_WINDOW_PAIR
argument_list|(
name|win
argument_list|)
operator|,
name|_tracech_t2
argument_list|(
literal|3
argument_list|,
name|CHREF
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|,
name|GetPair
argument_list|(
name|ch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_comment
comment|/* check if position is legal; if not, return error */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_comment
comment|/* treat this like an assertion */
end_comment

begin_define
define|#
directive|define
name|CHECK_POSITION
parameter_list|(
name|win
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|if (y> win->_maxy \ 	 || x> win->_maxx \ 	 || y< 0 \ 	 || x< 0) { \ 		TR(TRACE_VIRTPUT, ("Alert! Win=%p _curx = %d, _cury = %d " \ 				   "(_maxx = %d, _maxy = %d)", win, x, y, \ 				   win->_maxx, win->_maxy)); \ 		return(ERR); \ 	}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECK_POSITION
parameter_list|(
name|win
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bool
name|newline_forces_scroll
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|NCURSES_SIZE_T
modifier|*
name|ypos
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|*
name|ypos
operator|>=
name|win
operator|->
name|_regtop
operator|&&
operator|*
name|ypos
operator|==
name|win
operator|->
name|_regbottom
condition|)
block|{
operator|*
name|ypos
operator|=
name|win
operator|->
name|_regbottom
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ypos
operator|=
call|(
name|NCURSES_SIZE_T
call|)
argument_list|(
operator|*
name|ypos
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * The _WRAPPED flag is useful only for telling an application that we've just  * wrapped the cursor.  We don't do anything with this flag except set it when  * wrapping, and clear it whenever we move the cursor.  If we try to wrap at  * the lower-right corner of a window, we cannot move the cursor (since that  * wouldn't be legal).  So we return an error (which is what SVr4 does).   * Unlike SVr4, we can successfully add a character to the lower-right corner  * (Solaris 2.6 does this also, however).  */
end_comment

begin_function
specifier|static
name|int
name|wrap_to_next_line
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|win
operator|->
name|_flags
operator||=
name|_WRAPPED
expr_stmt|;
if|if
condition|(
name|newline_forces_scroll
argument_list|(
name|win
argument_list|,
operator|&
operator|(
name|win
operator|->
name|_cury
operator|)
argument_list|)
condition|)
block|{
name|win
operator|->
name|_curx
operator|=
name|win
operator|->
name|_maxx
expr_stmt|;
if|if
condition|(
operator|!
name|win
operator|->
name|_scroll
condition|)
return|return
operator|(
name|ERR
operator|)
return|;
name|scroll
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
name|win
operator|->
name|_curx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|wadd_wch_literal
parameter_list|(
name|WINDOW
modifier|*
parameter_list|,
name|cchar_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Fill the given number of cells with blanks using the current background  * rendition.  This saves/restores the current x-position.  */
end_comment

begin_function
specifier|static
name|void
name|fill_cells
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|cchar_t
name|blank
init|=
name|blankchar
decl_stmt|;
name|int
name|save_x
init|=
name|win
operator|->
name|_curx
decl_stmt|;
name|int
name|save_y
init|=
name|win
operator|->
name|_cury
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|wadd_wch_literal
argument_list|(
name|win
argument_list|,
name|blank
argument_list|)
operator|==
name|ERR
condition|)
break|break;
block|}
name|win
operator|->
name|_curx
operator|=
operator|(
name|NCURSES_SIZE_T
operator|)
name|save_x
expr_stmt|;
name|win
operator|->
name|_cury
operator|=
operator|(
name|NCURSES_SIZE_T
operator|)
name|save_y
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wadd_wch_literal
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|cchar_t
name|ch
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|y
decl_stmt|;
name|struct
name|ldat
modifier|*
name|line
decl_stmt|;
name|x
operator|=
name|win
operator|->
name|_curx
expr_stmt|;
name|y
operator|=
name|win
operator|->
name|_cury
expr_stmt|;
name|CHECK_POSITION
argument_list|(
name|win
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|ch
operator|=
name|render_char
argument_list|(
name|win
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|line
operator|=
name|win
operator|->
name|_line
operator|+
name|y
expr_stmt|;
name|CHANGED_CELL
argument_list|(
name|line
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/*      * Non-spacing characters are added to the current cell.      *      * Spacing characters that are wider than one column require some display      * adjustments.      */
block|{
name|int
name|len
init|=
name|wcwidth
argument_list|(
name|CharOf
argument_list|(
name|ch
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|wchar_t
modifier|*
name|chars
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* non-spacing */
if|if
condition|(
operator|(
name|x
operator|>
literal|0
operator|&&
name|y
operator|>=
literal|0
operator|)
operator|||
operator|(
name|win
operator|->
name|_maxx
operator|>=
literal|0
operator|&&
name|win
operator|->
name|_cury
operator|>=
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|x
operator|>
literal|0
operator|&&
name|y
operator|>=
literal|0
condition|)
name|chars
operator|=
operator|(
name|win
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x
operator|-
literal|1
index|]
operator|.
name|chars
operator|)
expr_stmt|;
else|else
name|chars
operator|=
operator|(
name|win
operator|->
name|_line
index|[
name|y
operator|-
literal|1
index|]
operator|.
name|text
index|[
name|win
operator|->
name|_maxx
index|]
operator|.
name|chars
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CCHARW_MAX
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|chars
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|TR
argument_list|(
name|TRACE_VIRTPUT
argument_list|,
operator|(
literal|"added non-spacing %d: %x"
operator|,
name|x
operator|,
operator|(
name|int
operator|)
name|CharOf
argument_list|(
name|ch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|chars
index|[
name|i
index|]
operator|=
name|CharOf
argument_list|(
name|ch
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
goto|goto
name|testwrapping
goto|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
comment|/* multi-column characters */
comment|/* 	     * Check if the character will fit on the current line.  If it does 	     * not fit, fill in the remainder of the line with blanks.  and 	     * move to the next line. 	     */
if|if
condition|(
name|len
operator|>
name|win
operator|->
name|_maxx
operator|+
literal|1
condition|)
block|{
name|TR
argument_list|(
name|TRACE_VIRTPUT
argument_list|,
operator|(
literal|"character will not fit"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ERR
return|;
block|}
elseif|else
if|if
condition|(
name|x
operator|+
name|len
operator|>
name|win
operator|->
name|_maxx
operator|+
literal|1
condition|)
block|{
name|int
name|count
init|=
name|win
operator|->
name|_maxx
operator|+
literal|1
operator|-
name|x
decl_stmt|;
name|TR
argument_list|(
name|TRACE_VIRTPUT
argument_list|,
operator|(
literal|"fill %d remaining cells"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|fill_cells
argument_list|(
name|win
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrap_to_next_line
argument_list|(
name|win
argument_list|)
operator|==
name|ERR
condition|)
return|return
name|ERR
return|;
name|x
operator|=
name|win
operator|->
name|_curx
expr_stmt|;
name|y
operator|=
name|win
operator|->
name|_cury
expr_stmt|;
name|line
operator|=
name|win
operator|->
name|_line
operator|+
name|y
expr_stmt|;
block|}
comment|/* 	     * Check for cells which are orphaned by adding this character, set 	     * those to blanks. 	     * 	     * FIXME: this actually could fill j-i cells, more complicated to 	     * setup though. 	     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|isWidecBase
argument_list|(
name|win
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x
operator|+
name|i
index|]
argument_list|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|isWidecExt
argument_list|(
name|win
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x
operator|+
name|i
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|x
operator|+
name|j
operator|<=
name|win
operator|->
name|_maxx
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
operator|!
name|isWidecExt
argument_list|(
name|win
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x
operator|+
name|j
index|]
argument_list|)
condition|)
block|{
name|TR
argument_list|(
name|TRACE_VIRTPUT
argument_list|,
operator|(
literal|"fill %d orphan cells"
operator|,
name|j
operator|)
argument_list|)
expr_stmt|;
name|fill_cells
argument_list|(
name|win
argument_list|,
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
block|}
comment|/* 	     * Finally, add the cells for this character. 	     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|cchar_t
name|value
init|=
name|ch
decl_stmt|;
name|SetWidecExt
argument_list|(
name|value
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|TR
argument_list|(
name|TRACE_VIRTPUT
argument_list|,
operator|(
literal|"multicolumn %d:%d (%d,%d)"
operator|,
name|i
operator|+
literal|1
operator|,
name|len
operator|,
name|win
operator|->
name|_begy
operator|+
name|y
operator|,
name|win
operator|->
name|_begx
operator|+
name|x
operator|)
argument_list|)
expr_stmt|;
name|line
operator|->
name|text
index|[
name|x
index|]
operator|=
name|value
expr_stmt|;
name|CHANGED_CELL
argument_list|(
name|line
argument_list|,
name|x
argument_list|)
expr_stmt|;
operator|++
name|x
expr_stmt|;
block|}
goto|goto
name|testwrapping
goto|;
block|}
block|}
comment|/*      * Single-column characters.      */
name|line
operator|->
name|text
index|[
name|x
operator|++
index|]
operator|=
name|ch
expr_stmt|;
comment|/*      * This label is used only for wide-characters.      */
name|testwrapping
label|:
name|TR
argument_list|(
name|TRACE_VIRTPUT
argument_list|,
operator|(
literal|"cell (%ld, %ld..%d) = %s"
operator|,
operator|(
name|long
operator|)
name|win
operator|->
name|_cury
operator|,
operator|(
name|long
operator|)
name|win
operator|->
name|_curx
operator|,
name|x
operator|-
literal|1
operator|,
name|_tracech_t
argument_list|(
name|CHREF
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|win
operator|->
name|_maxx
condition|)
block|{
return|return
name|wrap_to_next_line
argument_list|(
name|win
argument_list|)
return|;
block|}
name|win
operator|->
name|_curx
operator|=
operator|(
name|NCURSES_SIZE_T
operator|)
name|x
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|NCURSES_INLINE
name|int
name|wadd_wch_nosync
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|cchar_t
name|ch
parameter_list|)
comment|/* the workhorse function -- add a character to the given window */
block|{
name|NCURSES_SIZE_T
name|x
decl_stmt|,
name|y
decl_stmt|;
name|wchar_t
modifier|*
name|s
decl_stmt|;
name|int
name|tabsize
init|=
literal|8
decl_stmt|;
if|#
directive|if
name|USE_REENTRANT
name|SCREEN
modifier|*
name|sp
init|=
name|_nc_screen_of
argument_list|(
name|win
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/*      * If we are using the alternate character set, forget about locale.      * Otherwise, if the locale * claims the code is printable, treat it that      * way.      */
if|if
condition|(
operator|(
name|AttrOf
argument_list|(
name|ch
argument_list|)
operator|&
name|A_ALTCHARSET
operator|)
operator|||
name|iswprint
argument_list|(
operator|(
name|wint_t
operator|)
name|CharOf
argument_list|(
name|ch
argument_list|)
argument_list|)
condition|)
return|return
name|wadd_wch_literal
argument_list|(
name|win
argument_list|,
name|ch
argument_list|)
return|;
comment|/*      * Handle carriage control and other codes that are not printable, or are      * known to expand to more than one character according to unctrl().      */
name|x
operator|=
name|win
operator|->
name|_curx
expr_stmt|;
name|y
operator|=
name|win
operator|->
name|_cury
expr_stmt|;
switch|switch
condition|(
name|CharOf
argument_list|(
name|ch
argument_list|)
condition|)
block|{
case|case
literal|'\t'
case|:
if|#
directive|if
name|USE_REENTRANT
name|tabsize
operator|=
operator|*
name|ptrTabsize
argument_list|(
name|sp
argument_list|)
expr_stmt|;
else|#
directive|else
name|tabsize
operator|=
name|TABSIZE
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
call|(
name|NCURSES_SIZE_T
call|)
argument_list|(
name|x
operator|+
operator|(
name|tabsize
operator|-
operator|(
name|x
operator|%
name|tabsize
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Space-fill the tab on the bottom line so that we'll get the 	 * "correct" cursor position. 	 */
if|if
condition|(
operator|(
operator|!
name|win
operator|->
name|_scroll
operator|&&
operator|(
name|y
operator|==
name|win
operator|->
name|_regbottom
operator|)
operator|)
operator|||
operator|(
name|x
operator|<=
name|win
operator|->
name|_maxx
operator|)
condition|)
block|{
name|cchar_t
name|blank
init|=
name|blankchar
decl_stmt|;
name|AddAttr
argument_list|(
name|blank
argument_list|,
name|AttrOf
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|win
operator|->
name|_curx
operator|<
name|x
condition|)
block|{
if|if
condition|(
name|wadd_wch_literal
argument_list|(
name|win
argument_list|,
name|blank
argument_list|)
operator|==
name|ERR
condition|)
return|return
operator|(
name|ERR
operator|)
return|;
block|}
break|break;
block|}
else|else
block|{
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|win
operator|->
name|_flags
operator||=
name|_WRAPPED
expr_stmt|;
if|if
condition|(
name|newline_forces_scroll
argument_list|(
name|win
argument_list|,
operator|&
name|y
argument_list|)
condition|)
block|{
name|x
operator|=
name|win
operator|->
name|_maxx
expr_stmt|;
if|if
condition|(
name|win
operator|->
name|_scroll
condition|)
block|{
name|scroll
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|x
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'\n'
case|:
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|newline_forces_scroll
argument_list|(
name|win
argument_list|,
operator|&
name|y
argument_list|)
condition|)
block|{
if|if
condition|(
name|win
operator|->
name|_scroll
condition|)
name|scroll
argument_list|(
name|win
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|ERR
operator|)
return|;
block|}
comment|/* FALLTHRU */
case|case
literal|'\r'
case|:
name|x
operator|=
literal|0
expr_stmt|;
name|win
operator|->
name|_flags
operator|&=
operator|~
name|_WRAPPED
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
operator|(
name|OK
operator|)
return|;
name|x
operator|--
expr_stmt|;
name|win
operator|->
name|_flags
operator|&=
operator|~
name|_WRAPPED
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|s
operator|=
name|wunctrl
argument_list|(
operator|&
name|ch
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|cchar_t
name|sch
decl_stmt|;
name|SetChar
argument_list|(
name|sch
argument_list|,
operator|*
name|s
operator|++
argument_list|,
name|AttrOf
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
name|if_EXT_COLORS
argument_list|(
name|SetPair
argument_list|(
name|sch
argument_list|,
name|GetPair
argument_list|(
name|ch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wadd_wch_literal
argument_list|(
name|win
argument_list|,
name|sch
argument_list|)
operator|==
name|ERR
condition|)
return|return
name|ERR
return|;
block|}
return|return
name|OK
return|;
block|}
return|return
name|ERR
return|;
block|}
name|win
operator|->
name|_curx
operator|=
name|x
expr_stmt|;
name|win
operator|->
name|_cury
operator|=
name|y
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*  * The versions below call _nc_synchook().  We wanted to avoid this in the  * version exported for string puts; they'll call _nc_synchook once at end  * of run.  */
end_comment

begin_comment
comment|/* These are actual entry points */
end_comment

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|wadd_wch
argument_list|(
argument|WINDOW *win
argument_list|,
argument|const cchar_t *wch
argument_list|)
end_macro

begin_block
block|{
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|TR
argument_list|(
name|TRACE_VIRTPUT
operator||
name|TRACE_CCALLS
argument_list|,
operator|(
name|T_CALLED
argument_list|(
literal|"wadd_wch(%p, %s)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|win
operator|,
name|_tracecchar_t
argument_list|(
name|wch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|&&
operator|(
name|wadd_wch_nosync
argument_list|(
name|win
argument_list|,
operator|*
name|wch
argument_list|)
operator|!=
name|ERR
operator|)
condition|)
block|{
name|_nc_synchook
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|code
operator|=
name|OK
expr_stmt|;
block|}
name|TR
argument_list|(
name|TRACE_VIRTPUT
operator||
name|TRACE_CCALLS
argument_list|,
operator|(
name|T_RETURN
argument_list|(
literal|"%d"
argument_list|)
operator|,
name|code
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
end_block

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|int
argument_list|)
end_macro

begin_macro
name|wecho_wchar
argument_list|(
argument|WINDOW *win
argument_list|,
argument|const cchar_t *wch
argument_list|)
end_macro

begin_block
block|{
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|TR
argument_list|(
name|TRACE_VIRTPUT
operator||
name|TRACE_CCALLS
argument_list|,
operator|(
name|T_CALLED
argument_list|(
literal|"wechochar(%p, %s)"
argument_list|)
operator|,
operator|(
name|void
operator|*
operator|)
name|win
operator|,
name|_tracecchar_t
argument_list|(
name|wch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|win
operator|&&
operator|(
name|wadd_wch_nosync
argument_list|(
name|win
argument_list|,
operator|*
name|wch
argument_list|)
operator|!=
name|ERR
operator|)
condition|)
block|{
name|bool
name|save_immed
init|=
name|win
operator|->
name|_immed
decl_stmt|;
name|win
operator|->
name|_immed
operator|=
name|TRUE
expr_stmt|;
name|_nc_synchook
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|win
operator|->
name|_immed
operator|=
name|save_immed
expr_stmt|;
name|code
operator|=
name|OK
expr_stmt|;
block|}
name|TR
argument_list|(
name|TRACE_VIRTPUT
operator||
name|TRACE_CCALLS
argument_list|,
operator|(
name|T_RETURN
argument_list|(
literal|"%d"
argument_list|)
operator|,
name|code
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
end_block

end_unit

