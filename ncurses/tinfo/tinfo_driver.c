begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 2008-2009,2010 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Juergen Pfeifer                                                 *  *                                                                          *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_define
define|#
directive|define
name|CUR
value|((TERMINAL*)TCB)->type.
end_define

begin_include
include|#
directive|include
file|<tic.h>
end_include

begin_if
if|#
directive|if
name|HAVE_NANOSLEEP
end_if

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_if
if|#
directive|if
name|HAVE_SYS_TIME_H
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* needed for MacOS X DP3 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|HAVE_SIZECHANGE
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|sun
argument_list|)
operator|||
operator|!
name|TERMIOS
end_if

begin_if
if|#
directive|if
name|HAVE_SYS_IOCTL_H
end_if

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: tinfo_driver.c,v 1.13 2010/12/20 01:47:09 tom Exp $"
argument_list|)
end_macro

begin_comment
comment|/*  * SCO defines TIOCGSIZE and the corresponding struct.  Other systems (SunOS,  * Solaris, IRIX) define TIOCGWINSZ and struct winsize.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGSIZE
end_ifdef

begin_define
define|#
directive|define
name|IOCTL_WINSIZE
value|TIOCGSIZE
end_define

begin_define
define|#
directive|define
name|STRUCT_WINSIZE
value|struct ttysize
end_define

begin_define
define|#
directive|define
name|WINSIZE_ROWS
parameter_list|(
name|n
parameter_list|)
value|(int)n.ts_lines
end_define

begin_define
define|#
directive|define
name|WINSIZE_COLS
parameter_list|(
name|n
parameter_list|)
value|(int)n.ts_cols
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCGWINSZ
end_ifdef

begin_define
define|#
directive|define
name|IOCTL_WINSIZE
value|TIOCGWINSZ
end_define

begin_define
define|#
directive|define
name|STRUCT_WINSIZE
value|struct winsize
end_define

begin_define
define|#
directive|define
name|WINSIZE_ROWS
parameter_list|(
name|n
parameter_list|)
value|(int)n.ws_row
end_define

begin_define
define|#
directive|define
name|WINSIZE_COLS
parameter_list|(
name|n
parameter_list|)
value|(int)n.ws_col
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These should be screen structure members.  They need to be globals for  * historical reasons.  So we assign them in start_color() and also in  * set_term()'s screen-switching logic.  */
end_comment

begin_if
if|#
directive|if
name|USE_REENTRANT
end_if

begin_function
name|NCURSES_EXPORT
function|(
name|int
function|)
name|NCURSES_PUBLIC_VAR
argument_list|(
argument|COLOR_PAIRS
argument_list|)
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|CURRENT_SCREEN
condition|?
name|CURRENT_SCREEN
operator|->
name|_pair_count
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|NCURSES_EXPORT
function|(
name|int
function|)
name|NCURSES_PUBLIC_VAR
argument_list|(
argument|COLORS
argument_list|)
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|CURRENT_SCREEN
condition|?
name|CURRENT_SCREEN
operator|->
name|_color_count
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|int
argument_list|)
end_macro

begin_expr_stmt
name|COLOR_PAIRS
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|int
argument_list|)
end_macro

begin_expr_stmt
name|COLORS
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TCBMAGIC
value|NCDRV_MAGIC(NCDRV_TINFO)
end_define

begin_define
define|#
directive|define
name|AssertTCB
parameter_list|()
value|assert(TCB!=0&& TCB->magic==TCBMAGIC)
end_define

begin_define
define|#
directive|define
name|SetSP
parameter_list|()
value|assert(TCB->csp!=0); sp = TCB->csp
end_define

begin_comment
comment|/*  * This routine needs to do all the work to make curscr look  * like newscr.  */
end_comment

begin_function
specifier|static
name|int
name|drv_doupdate
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|AssertTCB
argument_list|()
expr_stmt|;
return|return
name|TINFO_DOUPDATE
argument_list|(
name|TCB
operator|->
name|csp
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ret_error
parameter_list|(
name|code
parameter_list|,
name|fmt
parameter_list|,
name|arg
parameter_list|)
value|if (errret) {\ 					    *errret = code;\ 					    return(FALSE); \ 					} else {\ 					    fprintf(stderr, fmt, arg);\ 					    exit(EXIT_FAILURE);\ 					}
end_define

begin_define
define|#
directive|define
name|ret_error0
parameter_list|(
name|code
parameter_list|,
name|msg
parameter_list|)
value|if (errret) {\ 					    *errret = code;\ 					    return(FALSE);\ 					} else {\ 					    fprintf(stderr, msg);\ 					    exit(EXIT_FAILURE);\ 					}
end_define

begin_function
specifier|static
name|bool
name|drv_CanHandle
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
specifier|const
name|char
modifier|*
name|tname
parameter_list|,
name|int
modifier|*
name|errret
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
name|int
name|status
decl_stmt|;
name|TERMINAL
modifier|*
name|termp
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|assert
argument_list|(
name|TCB
operator|!=
literal|0
operator|&&
name|tname
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|termp
operator|=
operator|(
name|TERMINAL
operator|*
operator|)
name|TCB
expr_stmt|;
name|sp
operator|=
name|TCB
operator|->
name|csp
expr_stmt|;
name|TCB
operator|->
name|magic
operator|=
name|TCBMAGIC
expr_stmt|;
if|#
directive|if
operator|(
name|USE_DATABASE
operator|||
name|USE_TERMCAP
operator|)
name|status
operator|=
name|_nc_setup_tinfo
argument_list|(
name|tname
argument_list|,
operator|&
name|termp
operator|->
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|TGETENT_NO
expr_stmt|;
endif|#
directive|endif
comment|/* try fallback list if entry on disk */
if|if
condition|(
name|status
operator|!=
name|TGETENT_YES
condition|)
block|{
specifier|const
name|TERMTYPE
modifier|*
name|fallback
init|=
name|_nc_fallback
argument_list|(
name|tname
argument_list|)
decl_stmt|;
if|if
condition|(
name|fallback
condition|)
block|{
name|termp
operator|->
name|type
operator|=
operator|*
name|fallback
expr_stmt|;
name|status
operator|=
name|TGETENT_YES
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|!=
name|TGETENT_YES
condition|)
block|{
name|NCURSES_SP_NAME
function_decl|(
name|del_curterm
function_decl|)
parameter_list|(
name|NCURSES_SP_ARGx
name|termp
parameter_list|)
function_decl|;
if|if
condition|(
name|status
operator|==
name|TGETENT_ERR
condition|)
block|{
name|ret_error0
argument_list|(
name|status
argument_list|,
literal|"terminals database is inaccessible\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|TGETENT_NO
condition|)
block|{
name|ret_error
argument_list|(
name|status
argument_list|,
literal|"'%s': unknown terminal type.\n"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
operator|!
name|USE_REENTRANT
name|strncpy
argument_list|(
name|ttytype
argument_list|,
name|termp
operator|->
name|type
operator|.
name|term_names
argument_list|,
name|NAMESIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ttytype
index|[
name|NAMESIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|command_character
condition|)
name|_nc_tinfo_cmdch
argument_list|(
name|termp
argument_list|,
operator|*
name|command_character
argument_list|)
expr_stmt|;
if|if
condition|(
name|generic_type
condition|)
block|{
name|ret_error
argument_list|(
name|TGETENT_NO
argument_list|,
literal|"'%s': I need something more specific.\n"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hard_copy
condition|)
block|{
name|ret_error
argument_list|(
name|TGETENT_YES
argument_list|,
literal|"'%s': I can't handle hardcopy terminals.\n"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_dobeepflash
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|bool
name|beepFlag
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|int
name|res
init|=
name|ERR
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
comment|/* FIXME: should make sure that we are not in altchar mode */
if|if
condition|(
name|beepFlag
condition|)
block|{
if|if
condition|(
name|bell
condition|)
block|{
name|res
operator|=
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"bell"
argument_list|,
name|bell
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
function_decl|(
name|_nc_flush
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
block|}
elseif|else
if|if
condition|(
name|flash_screen
condition|)
block|{
name|res
operator|=
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"flash_screen"
argument_list|,
name|flash_screen
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
function_decl|(
name|_nc_flush
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|flash_screen
condition|)
block|{
name|res
operator|=
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"flash_screen"
argument_list|,
name|flash_screen
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
function_decl|(
name|_nc_flush
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
block|}
elseif|else
if|if
condition|(
name|bell
condition|)
block|{
name|res
operator|=
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"bell"
argument_list|,
name|bell
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
function_decl|(
name|_nc_flush
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
block|}
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*  * SVr4 curses is known to interchange color codes (1,4) and (3,6), possibly  * to maintain compatibility with a pre-ANSI scheme.  The same scheme is  * also used in the FreeBSD syscons.  */
end_comment

begin_function
specifier|static
name|int
name|toggled_colors
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|<
literal|16
condition|)
block|{
specifier|static
specifier|const
name|int
name|table
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|,
literal|8
block|,
literal|12
block|,
literal|10
block|,
literal|14
block|,
literal|9
block|,
literal|13
block|,
literal|11
block|,
literal|15
block|}
decl_stmt|;
name|c
operator|=
name|table
index|[
name|c
index|]
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_print
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|#
directive|if
name|NCURSES_EXT_FUNCS
return|return
name|NCURSES_SP_NAME
argument_list|(
name|mcprint
argument_list|)
argument_list|(
name|TCB
operator|->
name|csp
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
else|#
directive|else
return|return
name|ERR
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|drv_defaultcolors
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|fg
parameter_list|,
name|int
name|bg
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
literal|0
operator|&&
name|orig_pair
operator|&&
name|orig_colors
operator|&&
operator|(
name|initialize_pair
operator|!=
literal|0
operator|)
condition|)
block|{
if|#
directive|if
name|NCURSES_EXT_FUNCS
name|sp
operator|->
name|_default_color
operator|=
name|isDefaultColor
argument_list|(
name|fg
argument_list|)
operator|||
name|isDefaultColor
argument_list|(
name|bg
argument_list|)
expr_stmt|;
name|sp
operator|->
name|_has_sgr_39_49
operator|=
operator|(
name|NCURSES_SP_NAME
argument_list|(
name|tigetflag
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"AX"
argument_list|)
operator|==
name|TRUE
operator|)
expr_stmt|;
name|sp
operator|->
name|_default_fg
operator|=
name|isDefaultColor
argument_list|(
name|fg
argument_list|)
condition|?
name|COLOR_DEFAULT
else|:
operator|(
name|fg
operator|&
name|C_MASK
operator|)
expr_stmt|;
name|sp
operator|->
name|_default_bg
operator|=
name|isDefaultColor
argument_list|(
name|bg
argument_list|)
condition|?
name|COLOR_DEFAULT
else|:
operator|(
name|bg
operator|&
name|C_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|_color_pairs
operator|!=
literal|0
condition|)
block|{
name|bool
name|save
init|=
name|sp
operator|->
name|_default_color
decl_stmt|;
name|sp
operator|->
name|_default_color
operator|=
name|TRUE
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
name|init_pair
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|0
argument_list|,
operator|(
name|short
operator|)
name|fg
argument_list|,
operator|(
name|short
operator|)
name|bg
argument_list|)
expr_stmt|;
name|sp
operator|->
name|_default_color
operator|=
name|save
expr_stmt|;
block|}
endif|#
directive|endif
name|code
operator|=
name|OK
expr_stmt|;
block|}
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_setcolor
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|bool
name|fore
parameter_list|,
name|int
name|color
parameter_list|,
name|NCURSES_SP_OUTC
name|outc
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|if
condition|(
name|fore
condition|)
block|{
if|if
condition|(
name|set_a_foreground
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"set_a_foreground"
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
argument|tputs
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|TPARM_1
argument_list|(
name|set_a_foreground
argument_list|,
name|color
argument_list|)
operator|,
literal|1
operator|,
name|outc
operator|)
expr_stmt|;
block|}
else|else
block|{
name|TPUTS_TRACE
argument_list|(
literal|"set_foreground"
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
argument|tputs
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|TPARM_1
argument_list|(
name|set_foreground
argument_list|,
name|toggled_colors
argument_list|(
name|color
argument_list|)
argument_list|)
operator|,
literal|1
operator|,
name|outc
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|set_a_background
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"set_a_background"
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
argument|tputs
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|TPARM_1
argument_list|(
name|set_a_background
argument_list|,
name|color
argument_list|)
operator|,
literal|1
operator|,
name|outc
operator|)
expr_stmt|;
block|}
else|else
block|{
name|TPUTS_TRACE
argument_list|(
literal|"set_background"
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
argument|tputs
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|TPARM_1
argument_list|(
name|set_background
argument_list|,
name|toggled_colors
argument_list|(
name|color
argument_list|)
argument_list|)
operator|,
literal|1
operator|,
name|outc
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|drv_rescol
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|if
condition|(
name|orig_pair
operator|!=
literal|0
condition|)
block|{
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"orig_pair"
argument_list|,
name|orig_pair
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drv_rescolors
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|int
name|result
init|=
name|FALSE
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|if
condition|(
name|orig_colors
operator|!=
literal|0
condition|)
block|{
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"orig_colors"
argument_list|,
name|orig_colors
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_size
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
modifier|*
name|linep
parameter_list|,
name|int
modifier|*
name|colp
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|bool
name|useEnv
init|=
name|TRUE
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|sp
operator|=
name|TCB
operator|->
name|csp
expr_stmt|;
comment|/* can be null here */
if|if
condition|(
name|sp
condition|)
block|{
name|useEnv
operator|=
name|sp
operator|->
name|_use_env
expr_stmt|;
block|}
else|else
name|useEnv
operator|=
name|_nc_prescreen
operator|.
name|use_env
expr_stmt|;
comment|/* figure out the size of the screen */
name|T
argument_list|(
operator|(
literal|"screen size: terminfo lines = %d columns = %d"
operator|,
name|lines
operator|,
name|columns
operator|)
argument_list|)
expr_stmt|;
operator|*
name|linep
operator|=
operator|(
name|int
operator|)
name|lines
expr_stmt|;
operator|*
name|colp
operator|=
operator|(
name|int
operator|)
name|columns
expr_stmt|;
if|if
condition|(
name|useEnv
condition|)
block|{
name|int
name|value
decl_stmt|;
ifdef|#
directive|ifdef
name|__EMX__
block|{
name|int
name|screendata
index|[
literal|2
index|]
decl_stmt|;
name|_scrsize
argument_list|(
name|screendata
argument_list|)
expr_stmt|;
operator|*
name|colp
operator|=
name|screendata
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|linep
operator|=
name|screendata
index|[
literal|1
index|]
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"EMX screen size: environment LINES = %d COLUMNS = %d"
operator|,
operator|*
name|linep
operator|,
operator|*
name|colp
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|HAVE_SIZECHANGE
comment|/* try asking the OS */
block|{
name|TERMINAL
modifier|*
name|termp
init|=
operator|(
name|TERMINAL
operator|*
operator|)
name|TCB
decl_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|termp
operator|->
name|Filedes
argument_list|)
condition|)
block|{
name|STRUCT_WINSIZE
name|size
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|termp
operator|->
name|Filedes
argument_list|,
name|IOCTL_WINSIZE
argument_list|,
operator|&
name|size
argument_list|)
operator|>=
literal|0
condition|)
block|{
operator|*
name|linep
operator|=
operator|(
operator|(
name|sp
operator|!=
literal|0
operator|&&
name|sp
operator|->
name|_filtered
operator|)
condition|?
literal|1
else|:
name|WINSIZE_ROWS
argument_list|(
name|size
argument_list|)
operator|)
expr_stmt|;
operator|*
name|colp
operator|=
name|WINSIZE_COLS
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"SYS screen size: environment LINES = %d COLUMNS = %d"
operator|,
operator|*
name|linep
operator|,
operator|*
name|colp
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|errno
operator|==
name|EINTR
condition|)
do|;
block|}
block|}
endif|#
directive|endif
comment|/* HAVE_SIZECHANGE */
comment|/* 	 * Finally, look for environment variables. 	 * 	 * Solaris lets users override either dimension with an environment 	 * variable. 	 */
if|if
condition|(
operator|(
name|value
operator|=
name|_nc_getenv_num
argument_list|(
literal|"LINES"
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
operator|*
name|linep
operator|=
name|value
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"screen size: environment LINES = %d"
operator|,
operator|*
name|linep
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|value
operator|=
name|_nc_getenv_num
argument_list|(
literal|"COLUMNS"
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
operator|*
name|colp
operator|=
name|value
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"screen size: environment COLUMNS = %d"
operator|,
operator|*
name|colp
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* if we can't get dynamic info about the size, use static */
if|if
condition|(
operator|*
name|linep
operator|<=
literal|0
condition|)
block|{
operator|*
name|linep
operator|=
operator|(
name|int
operator|)
name|lines
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|colp
operator|<=
literal|0
condition|)
block|{
operator|*
name|colp
operator|=
operator|(
name|int
operator|)
name|columns
expr_stmt|;
block|}
comment|/* the ultimate fallback, assume fixed 24x80 size */
if|if
condition|(
operator|*
name|linep
operator|<=
literal|0
condition|)
block|{
operator|*
name|linep
operator|=
literal|24
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|colp
operator|<=
literal|0
condition|)
block|{
operator|*
name|colp
operator|=
literal|80
expr_stmt|;
block|}
comment|/* 	 * Put the derived values back in the screen-size caps, so 	 * tigetnum() and tgetnum() will do the right thing. 	 */
name|lines
operator|=
call|(
name|short
call|)
argument_list|(
operator|*
name|linep
argument_list|)
expr_stmt|;
name|columns
operator|=
call|(
name|short
call|)
argument_list|(
operator|*
name|colp
argument_list|)
expr_stmt|;
block|}
name|T
argument_list|(
operator|(
literal|"screen size is %dx%d"
operator|,
operator|*
name|linep
operator|,
operator|*
name|colp
operator|)
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_getsize
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
modifier|*
name|l
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
name|AssertTCB
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|l
operator|!=
literal|0
operator|&&
name|c
operator|!=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|l
operator|=
name|lines
expr_stmt|;
operator|*
name|c
operator|=
name|columns
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_setsize
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|l
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|AssertTCB
argument_list|()
expr_stmt|;
name|lines
operator|=
operator|(
name|short
operator|)
name|l
expr_stmt|;
name|columns
operator|=
operator|(
name|short
operator|)
name|c
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_sgmode
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|bool
name|setFlag
parameter_list|,
name|TTY
modifier|*
name|buf
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
init|=
name|TCB
operator|->
name|csp
decl_stmt|;
name|TERMINAL
modifier|*
name|_term
init|=
operator|(
name|TERMINAL
operator|*
operator|)
name|TCB
decl_stmt|;
name|int
name|result
init|=
name|OK
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|setFlag
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|SET_TTY
argument_list|(
name|_term
operator|->
name|Filedes
argument_list|,
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
if|if
condition|(
name|errno
operator|==
name|ENOTTY
condition|)
block|{
if|if
condition|(
name|sp
condition|)
name|sp
operator|->
name|_notty
operator|=
name|TRUE
expr_stmt|;
block|}
name|result
operator|=
name|ERR
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|GET_TTY
argument_list|(
name|_term
operator|->
name|Filedes
argument_list|,
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|result
operator|=
name|ERR
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_mode
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|bool
name|progFlag
parameter_list|,
name|bool
name|defFlag
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|TERMINAL
modifier|*
name|_term
init|=
operator|(
name|TERMINAL
operator|*
operator|)
name|TCB
decl_stmt|;
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|sp
operator|=
name|TCB
operator|->
name|csp
expr_stmt|;
if|if
condition|(
name|progFlag
condition|)
comment|/* prog mode */
block|{
if|if
condition|(
name|defFlag
condition|)
block|{
comment|/* def_prog_mode */
comment|/* 	     * Turn off the XTABS bit in the tty structure if it was on. 	     */
if|if
condition|(
operator|(
name|drv_sgmode
argument_list|(
name|TCB
argument_list|,
name|FALSE
argument_list|,
operator|&
operator|(
name|_term
operator|->
name|Nttyb
operator|)
argument_list|)
operator|==
name|OK
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TERMIOS
name|_term
operator|->
name|Nttyb
operator|.
name|c_oflag
operator|&=
operator|(
name|unsigned
operator|)
operator|~
name|OFLAGS_TABS
expr_stmt|;
else|#
directive|else
name|_term
operator|->
name|Nttyb
operator|.
name|sg_flags
operator|&=
operator|(
name|unsigned
operator|)
operator|~
name|XTABS
expr_stmt|;
endif|#
directive|endif
name|code
operator|=
name|OK
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* reset_prog_mode */
if|if
condition|(
name|drv_sgmode
argument_list|(
name|TCB
argument_list|,
name|TRUE
argument_list|,
operator|&
operator|(
name|_term
operator|->
name|Nttyb
operator|)
argument_list|)
operator|==
name|OK
condition|)
block|{
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|_keypad_on
condition|)
name|_nc_keypad
argument_list|(
name|sp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|NC_BUFFERED
argument_list|(
name|sp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|OK
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* shell mode */
if|if
condition|(
name|defFlag
condition|)
block|{
comment|/* def_shell_mode */
comment|/* 	     * If XTABS was on, remove the tab and backtab capabilities. 	     */
if|if
condition|(
name|drv_sgmode
argument_list|(
name|TCB
argument_list|,
name|FALSE
argument_list|,
operator|&
operator|(
name|_term
operator|->
name|Ottyb
operator|)
argument_list|)
operator|==
name|OK
condition|)
block|{
ifdef|#
directive|ifdef
name|TERMIOS
if|if
condition|(
name|_term
operator|->
name|Ottyb
operator|.
name|c_oflag
operator|&
name|OFLAGS_TABS
condition|)
name|tab
operator|=
name|back_tab
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|_term
operator|->
name|Ottyb
operator|.
name|sg_flags
operator|&
name|XTABS
condition|)
name|tab
operator|=
name|back_tab
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|code
operator|=
name|OK
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* reset_shell_mode */
if|if
condition|(
name|sp
condition|)
block|{
name|_nc_keypad
argument_list|(
name|sp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
function_decl|(
name|_nc_flush
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
name|NC_BUFFERED
argument_list|(
name|sp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|drv_sgmode
argument_list|(
name|TCB
argument_list|,
name|TRUE
argument_list|,
operator|&
operator|(
name|_term
operator|->
name|Ottyb
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_wrap
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|)
block|{
if|if
condition|(
name|sp
condition|)
block|{
name|sp
operator|->
name|_mouse_wrap
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
function_decl|(
name|_nc_screen_wrap
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
name|NCURSES_SP_NAME
function_decl|(
name|_nc_mvcur_wrap
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
comment|/* wrap up cursor addressing */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|drv_release
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
name|GCC_UNUSED
parameter_list|)
block|{ }
end_function

begin_define
define|#
directive|define
name|SGR0_TEST
parameter_list|(
name|mode
parameter_list|)
value|(mode != 0)&& (exit_attribute_mode == 0 || strcmp(mode, exit_attribute_mode))
end_define

begin_function
specifier|static
name|void
name|drv_screen_init
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|)
block|{
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
init|=
name|TCBOf
argument_list|(
name|sp
argument_list|)
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
comment|/*      * Check for mismatched graphic-rendition capabilities.  Most SVr4      * terminfo trees contain entries that have rmul or rmso equated to      * sgr0 (Solaris curses copes with those entries).  We do this only      * for curses, since many termcap applications assume that      * smso/rmso and smul/rmul are paired, and will not function      * properly if we remove rmso or rmul.  Curses applications      * shouldn't be looking at this detail.      */
name|sp
operator|->
name|_use_rmso
operator|=
name|SGR0_TEST
argument_list|(
name|exit_standout_mode
argument_list|)
expr_stmt|;
name|sp
operator|->
name|_use_rmul
operator|=
name|SGR0_TEST
argument_list|(
name|exit_underline_mode
argument_list|)
expr_stmt|;
comment|/*      * Check whether we can optimize scrolling under dumb terminals in      * case we do not have any of these capabilities, scrolling      * optimization will be useless.      */
name|sp
operator|->
name|_scrolling
operator|=
operator|(
operator|(
name|scroll_forward
operator|&&
name|scroll_reverse
operator|)
operator|||
operator|(
operator|(
name|parm_rindex
operator|||
name|parm_insert_line
operator|||
name|insert_line
operator|)
operator|&&
operator|(
name|parm_index
operator|||
name|parm_delete_line
operator|||
name|delete_line
operator|)
operator|)
operator|)
expr_stmt|;
name|NCURSES_SP_NAME
function_decl|(
name|baudrate
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
name|NCURSES_SP_NAME
function_decl|(
name|_nc_mvcur_init
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
comment|/* initialize terminal to a sane state */
name|NCURSES_SP_NAME
function_decl|(
name|_nc_screen_init
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_init
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|TERMINAL
modifier|*
name|trm
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|trm
operator|=
operator|(
name|TERMINAL
operator|*
operator|)
name|TCB
expr_stmt|;
name|sp
operator|=
name|TCB
operator|->
name|csp
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|initcolor
operator|=
name|initialize_color
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|canchange
operator|=
name|can_change
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|hascolor
operator|=
operator|(
operator|(
name|VALID_NUMERIC
argument_list|(
name|max_colors
argument_list|)
operator|&&
name|VALID_NUMERIC
argument_list|(
name|max_pairs
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|set_foreground
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|set_background
operator|!=
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|(
name|set_a_foreground
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|set_a_background
operator|!=
name|NULL
operator|)
operator|)
operator|||
name|set_color_pair
operator|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
operator|)
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|caninit
operator|=
operator|!
operator|(
name|exit_ca_mode
operator|&&
name|non_rev_rmcup
operator|)
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|maxpairs
operator|=
name|VALID_NUMERIC
argument_list|(
name|max_pairs
argument_list|)
condition|?
name|max_pairs
else|:
literal|0
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|maxcolors
operator|=
name|VALID_NUMERIC
argument_list|(
name|max_colors
argument_list|)
condition|?
name|max_colors
else|:
literal|0
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|numlabels
operator|=
name|VALID_NUMERIC
argument_list|(
name|num_labels
argument_list|)
condition|?
name|num_labels
else|:
literal|0
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|labelwidth
operator|=
name|VALID_NUMERIC
argument_list|(
name|label_width
argument_list|)
condition|?
name|label_width
else|:
literal|0
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|labelheight
operator|=
name|VALID_NUMERIC
argument_list|(
name|label_height
argument_list|)
condition|?
name|label_height
else|:
literal|0
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|nocolorvideo
operator|=
name|VALID_NUMERIC
argument_list|(
name|no_color_video
argument_list|)
condition|?
name|no_color_video
else|:
literal|0
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|tabsize
operator|=
name|VALID_NUMERIC
argument_list|(
name|init_tabs
argument_list|)
condition|?
operator|(
name|int
operator|)
name|init_tabs
else|:
literal|8
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|defaultPalette
operator|=
name|hue_lightness_saturation
condition|?
name|_nc_hls_palette
else|:
name|_nc_cga_palette
expr_stmt|;
comment|/*      * If an application calls setupterm() rather than initscr() or      * newterm(), we will not have the def_prog_mode() call in      * _nc_setupscreen().  Do it now anyway, so we can initialize the      * baudrate.      */
if|if
condition|(
name|isatty
argument_list|(
name|trm
operator|->
name|Filedes
argument_list|)
condition|)
block|{
name|TCB
operator|->
name|drv
operator|->
name|mode
argument_list|(
name|TCB
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MAX_PALETTE
value|8
end_define

begin_define
define|#
directive|define
name|InPalette
parameter_list|(
name|n
parameter_list|)
value|((n)>= 0&& (n)< MAX_PALETTE)
end_define

begin_function
specifier|static
name|void
name|drv_initpair
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|short
name|pair
parameter_list|,
name|short
name|f
parameter_list|,
name|short
name|b
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|initialize_pair
operator|!=
name|NULL
operator|)
operator|&&
name|InPalette
argument_list|(
name|f
argument_list|)
operator|&&
name|InPalette
argument_list|(
name|b
argument_list|)
condition|)
block|{
specifier|const
name|color_t
modifier|*
name|tp
init|=
name|InfoOf
argument_list|(
name|sp
argument_list|)
operator|.
name|defaultPalette
decl_stmt|;
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"
operator|,
name|pair
operator|,
name|tp
index|[
name|f
index|]
operator|.
name|red
operator|,
name|tp
index|[
name|f
index|]
operator|.
name|green
operator|,
name|tp
index|[
name|f
index|]
operator|.
name|blue
operator|,
name|tp
index|[
name|b
index|]
operator|.
name|red
operator|,
name|tp
index|[
name|b
index|]
operator|.
name|green
operator|,
name|tp
index|[
name|b
index|]
operator|.
name|blue
operator|)
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"initialize_pair"
argument_list|,
name|TPARM_7
argument_list|(
name|initialize_pair
argument_list|,
name|pair
argument_list|,
name|tp
index|[
name|f
index|]
operator|.
name|red
argument_list|,
name|tp
index|[
name|f
index|]
operator|.
name|green
argument_list|,
name|tp
index|[
name|f
index|]
operator|.
name|blue
argument_list|,
name|tp
index|[
name|b
index|]
operator|.
name|red
argument_list|,
name|tp
index|[
name|b
index|]
operator|.
name|green
argument_list|,
name|tp
index|[
name|b
index|]
operator|.
name|blue
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|default_fg
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|)
block|{
if|#
directive|if
name|NCURSES_EXT_FUNCS
return|return
operator|(
name|sp
operator|!=
literal|0
operator|)
condition|?
name|sp
operator|->
name|_default_fg
else|:
name|COLOR_WHITE
return|;
else|#
directive|else
return|return
name|COLOR_WHITE
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|default_bg
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|)
block|{
if|#
directive|if
name|NCURSES_EXT_FUNCS
return|return
name|sp
operator|!=
literal|0
condition|?
name|sp
operator|->
name|_default_bg
else|:
name|COLOR_BLACK
return|;
else|#
directive|else
return|return
name|COLOR_BLACK
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|drv_initcolor
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|short
name|color
parameter_list|,
name|short
name|r
parameter_list|,
name|short
name|g
parameter_list|,
name|short
name|b
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
init|=
name|TCB
operator|->
name|csp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|initialize_color
operator|!=
name|NULL
condition|)
block|{
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"initialize_color"
argument_list|,
name|TPARM_4
argument_list|(
name|initialize_color
argument_list|,
name|color
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|drv_do_color
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|short
name|old_pair
parameter_list|,
name|short
name|pair
parameter_list|,
name|bool
name|reverse
parameter_list|,
name|NCURSES_SP_OUTC
name|outc
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
init|=
name|TCB
operator|->
name|csp
decl_stmt|;
name|NCURSES_COLOR_T
name|fg
init|=
name|COLOR_DEFAULT
decl_stmt|;
name|NCURSES_COLOR_T
name|bg
init|=
name|COLOR_DEFAULT
decl_stmt|;
name|NCURSES_COLOR_T
name|old_fg
decl_stmt|,
name|old_bg
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|pair
operator|<
literal|0
operator|||
name|pair
operator|>=
name|COLOR_PAIRS
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|pair
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|set_color_pair
condition|)
block|{
name|TPUTS_TRACE
argument_list|(
literal|"set_color_pair"
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
argument_list|(
argument|tputs
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|TPARM_1
argument_list|(
name|set_color_pair
argument_list|,
name|pair
argument_list|)
operator|,
literal|1
operator|,
name|outc
operator|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sp
operator|!=
literal|0
condition|)
block|{
name|NCURSES_SP_NAME
argument_list|(
name|pair_content
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
argument_list|(
argument|short
argument_list|)
name|pair
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old_pair
operator|>=
literal|0
operator|&&
name|sp
operator|!=
literal|0
operator|&&
name|NCURSES_SP_NAME
argument_list|(
argument|pair_content
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|old_pair
operator|,
operator|&
name|old_fg
operator|,
operator|&
name|old_bg
operator|)
operator|!=
name|ERR
condition|)
block|{
if|if
condition|(
operator|(
name|isDefaultColor
argument_list|(
name|fg
argument_list|)
operator|&&
operator|!
name|isDefaultColor
argument_list|(
name|old_fg
argument_list|)
operator|)
operator|||
operator|(
name|isDefaultColor
argument_list|(
name|bg
argument_list|)
operator|&&
operator|!
name|isDefaultColor
argument_list|(
name|old_bg
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|NCURSES_EXT_FUNCS
comment|/* 	     * A minor optimization - but extension.  If "AX" is specified in 	     * the terminal description, treat it as screen's indicator of ECMA 	     * SGR 39 and SGR 49, and assume the two sequences are independent. 	     */
if|if
condition|(
name|sp
operator|->
name|_has_sgr_39_49
operator|&&
name|isDefaultColor
argument_list|(
name|old_bg
argument_list|)
operator|&&
operator|!
name|isDefaultColor
argument_list|(
name|old_fg
argument_list|)
condition|)
block|{
name|NCURSES_SP_NAME
argument_list|(
name|tputs
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"\033[39m"
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|_has_sgr_39_49
operator|&&
name|isDefaultColor
argument_list|(
name|old_fg
argument_list|)
operator|&&
operator|!
name|isDefaultColor
argument_list|(
name|old_bg
argument_list|)
condition|)
block|{
name|NCURSES_SP_NAME
argument_list|(
name|tputs
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"\033[49m"
argument_list|,
literal|1
argument_list|,
name|outc
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|drv_rescol
argument_list|(
name|TCB
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|drv_rescol
argument_list|(
name|TCB
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_pair
operator|<
literal|0
condition|)
return|return;
block|}
if|#
directive|if
name|NCURSES_EXT_FUNCS
if|if
condition|(
name|isDefaultColor
argument_list|(
name|fg
argument_list|)
condition|)
name|fg
operator|=
operator|(
name|NCURSES_COLOR_T
operator|)
name|default_fg
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isDefaultColor
argument_list|(
name|bg
argument_list|)
condition|)
name|bg
operator|=
operator|(
name|NCURSES_COLOR_T
operator|)
name|default_bg
argument_list|(
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|reverse
condition|)
block|{
name|NCURSES_COLOR_T
name|xx
init|=
name|fg
decl_stmt|;
name|fg
operator|=
name|bg
expr_stmt|;
name|bg
operator|=
name|xx
expr_stmt|;
block|}
name|TR
argument_list|(
name|TRACE_ATTRS
argument_list|,
operator|(
literal|"setting colors: pair = %d, fg = %d, bg = %d"
operator|,
name|pair
operator|,
name|fg
operator|,
name|bg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isDefaultColor
argument_list|(
name|fg
argument_list|)
condition|)
block|{
name|drv_setcolor
argument_list|(
name|TCB
argument_list|,
name|TRUE
argument_list|,
name|fg
argument_list|,
name|outc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isDefaultColor
argument_list|(
name|bg
argument_list|)
condition|)
block|{
name|drv_setcolor
argument_list|(
name|TCB
argument_list|,
name|FALSE
argument_list|,
name|bg
argument_list|,
name|outc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|xterm_kmous
value|"\033[M"
end_define

begin_function
specifier|static
name|void
name|init_xterm_mouse
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|)
block|{
name|sp
operator|->
name|_mouse_type
operator|=
name|M_XTERM
expr_stmt|;
name|sp
operator|->
name|_mouse_xtermcap
operator|=
name|NCURSES_SP_NAME
argument_list|(
name|tigetstr
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"XM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VALID_STRING
argument_list|(
name|sp
operator|->
name|_mouse_xtermcap
argument_list|)
condition|)
name|sp
operator|->
name|_mouse_xtermcap
operator|=
literal|"\033[?1000%?%p1%{1}%=%th%el%;"
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_initmouse
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
comment|/* we know how to recognize mouse events under "xterm" */
if|if
condition|(
name|sp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|key_mouse
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|key_mouse
argument_list|,
name|xterm_kmous
argument_list|)
operator|||
name|strstr
argument_list|(
name|TerminalOf
argument_list|(
name|sp
argument_list|)
operator|->
name|type
operator|.
name|term_names
argument_list|,
literal|"xterm"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|init_xterm_mouse
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|TerminalOf
argument_list|(
name|sp
argument_list|)
operator|->
name|type
operator|.
name|term_names
argument_list|,
literal|"xterm"
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|_nc_add_to_try
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|_keytry
operator|)
argument_list|,
name|xterm_kmous
argument_list|,
name|KEY_MOUSE
argument_list|)
operator|==
name|OK
condition|)
name|init_xterm_mouse
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|drv_testmouse
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|#
directive|if
name|USE_SYSMOUSE
if|if
condition|(
operator|(
name|sp
operator|->
name|_mouse_type
operator|==
name|M_SYSMOUSE
operator|)
operator|&&
operator|(
name|sp
operator|->
name|_sysmouse_head
operator|<
name|sp
operator|->
name|_sysmouse_tail
operator|)
condition|)
block|{
name|rc
operator|=
name|TW_MOUSE
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|rc
operator|=
name|TCBOf
argument_list|(
name|sp
argument_list|)
operator|->
name|drv
operator|->
name|twait
argument_list|(
name|TCBOf
argument_list|(
name|sp
argument_list|)
argument_list|,
name|TWAIT_MASK
argument_list|,
name|delay
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
name|EVENTLIST_2nd
argument_list|(
name|evl
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_SYSMOUSE
if|if
condition|(
operator|(
name|sp
operator|->
name|_mouse_type
operator|==
name|M_SYSMOUSE
operator|)
operator|&&
operator|(
name|sp
operator|->
name|_sysmouse_head
operator|<
name|sp
operator|->
name|_sysmouse_tail
operator|)
operator|&&
operator|(
name|rc
operator|==
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
block|{
name|rc
operator||=
name|TW_MOUSE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_mvcur
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|yold
parameter_list|,
name|int
name|xold
parameter_list|,
name|int
name|ynew
parameter_list|,
name|int
name|xnew
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
init|=
name|TCB
operator|->
name|csp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
return|return
name|TINFO_MVCUR
argument_list|(
name|sp
argument_list|,
name|yold
argument_list|,
name|xold
argument_list|,
name|ynew
argument_list|,
name|xnew
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_hwlabel
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|labnum
parameter_list|,
name|char
modifier|*
name|text
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
init|=
name|TCB
operator|->
name|csp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|labnum
operator|>
literal|0
operator|&&
name|labnum
operator|<=
name|num_labels
condition|)
block|{
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"plab_norm"
argument_list|,
name|TPARM_2
argument_list|(
name|plab_norm
argument_list|,
name|labnum
argument_list|,
name|text
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|drv_hwlabelOnOff
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|bool
name|OnFlag
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
init|=
name|TCB
operator|->
name|csp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|OnFlag
condition|)
block|{
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"label_on"
argument_list|,
name|label_on
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"label_off"
argument_list|,
name|label_off
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|chtype
name|drv_conattr
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
init|=
name|TCB
operator|->
name|csp
decl_stmt|;
name|chtype
name|attrs
init|=
name|A_NORMAL
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|enter_alt_charset_mode
condition|)
name|attrs
operator||=
name|A_ALTCHARSET
expr_stmt|;
if|if
condition|(
name|enter_blink_mode
condition|)
name|attrs
operator||=
name|A_BLINK
expr_stmt|;
if|if
condition|(
name|enter_bold_mode
condition|)
name|attrs
operator||=
name|A_BOLD
expr_stmt|;
if|if
condition|(
name|enter_dim_mode
condition|)
name|attrs
operator||=
name|A_DIM
expr_stmt|;
if|if
condition|(
name|enter_reverse_mode
condition|)
name|attrs
operator||=
name|A_REVERSE
expr_stmt|;
if|if
condition|(
name|enter_standout_mode
condition|)
name|attrs
operator||=
name|A_STANDOUT
expr_stmt|;
if|if
condition|(
name|enter_protected_mode
condition|)
name|attrs
operator||=
name|A_PROTECT
expr_stmt|;
if|if
condition|(
name|enter_secure_mode
condition|)
name|attrs
operator||=
name|A_INVIS
expr_stmt|;
if|if
condition|(
name|enter_underline_mode
condition|)
name|attrs
operator||=
name|A_UNDERLINE
expr_stmt|;
if|if
condition|(
name|sp
operator|&&
name|sp
operator|->
name|_coloron
condition|)
name|attrs
operator||=
name|A_COLOR
expr_stmt|;
return|return
operator|(
name|attrs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_setfilter
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|AssertTCB
argument_list|()
expr_stmt|;
name|clear_screen
operator|=
literal|0
expr_stmt|;
name|cursor_down
operator|=
name|parm_down_cursor
operator|=
literal|0
expr_stmt|;
name|cursor_address
operator|=
literal|0
expr_stmt|;
name|cursor_up
operator|=
name|parm_up_cursor
operator|=
literal|0
expr_stmt|;
name|row_address
operator|=
literal|0
expr_stmt|;
name|cursor_home
operator|=
name|carriage_return
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_initacs
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|chtype
modifier|*
name|real_map
parameter_list|,
name|chtype
modifier|*
name|fake_map
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
init|=
name|TCB
operator|->
name|csp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|sp
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ena_acs
operator|!=
name|NULL
condition|)
block|{
name|NCURSES_SP_NAME
argument_list|(
name|_nc_putp
argument_list|)
argument_list|(
name|NCURSES_SP_ARGx
literal|"ena_acs"
argument_list|,
name|ena_acs
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NCURSES_EXT_FUNCS
comment|/*      * Linux console "supports" the "PC ROM" character set by the coincidence      * that smpch/rmpch and smacs/rmacs have the same values.  ncurses has      * no codepage support (see SCO Merge for an example).  Outside of the      * values defined in acsc, there are no definitions for the "PC ROM"      * character set (assumed by some applications to be codepage 437), but we      * allow those applications to use those codepoints.      *      * test/blue.c uses this feature.      */
define|#
directive|define
name|PCH_KLUDGE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a != 0&& b != 0&& !strcmp(a,b))
if|if
condition|(
name|PCH_KLUDGE
argument_list|(
name|enter_pc_charset_mode
argument_list|,
name|enter_alt_charset_mode
argument_list|)
operator|&&
name|PCH_KLUDGE
argument_list|(
name|exit_pc_charset_mode
argument_list|,
name|exit_alt_charset_mode
argument_list|)
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ACS_LEN
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|real_map
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|real_map
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|real_map
operator|!=
name|fake_map
condition|)
block|{
if|if
condition|(
name|sp
operator|!=
literal|0
condition|)
name|sp
operator|->
name|_screen_acs_map
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|acs_chars
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|i
init|=
literal|0
decl_stmt|;
name|size_t
name|length
init|=
name|strlen
argument_list|(
name|acs_chars
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|+
literal|1
operator|<
name|length
condition|)
block|{
if|if
condition|(
name|acs_chars
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|UChar
argument_list|(
name|acs_chars
index|[
name|i
index|]
argument_list|)
operator|<
name|ACS_LEN
condition|)
block|{
name|real_map
index|[
name|UChar
argument_list|(
name|acs_chars
index|[
name|i
index|]
argument_list|)
index|]
operator|=
name|UChar
argument_list|(
name|acs_chars
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
operator||
name|A_ALTCHARSET
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
literal|0
condition|)
name|sp
operator|->
name|_screen_acs_map
index|[
name|UChar
argument_list|(
name|acs_chars
index|[
name|i
index|]
argument_list|)
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|TRACE
comment|/* Show the equivalent mapping, noting if it does not match the      * given attribute, whether by re-ordering or duplication.      */
if|if
condition|(
name|USE_TRACEF
argument_list|(
name|TRACE_CALLS
argument_list|)
condition|)
block|{
name|size_t
name|n
decl_stmt|,
name|m
decl_stmt|;
name|char
name|show
index|[
name|ACS_LEN
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|1
operator|,
name|m
operator|=
literal|0
init|;
name|n
operator|<
name|ACS_LEN
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|real_map
index|[
name|n
index|]
operator|!=
literal|0
condition|)
block|{
name|show
index|[
name|m
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|n
expr_stmt|;
name|show
index|[
name|m
operator|++
index|]
operator|=
operator|(
name|char
operator|)
name|ChCharOf
argument_list|(
name|real_map
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|show
index|[
name|m
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acs_chars
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|acs_chars
argument_list|,
name|show
argument_list|)
condition|)
name|_tracef
argument_list|(
literal|"%s acs_chars %s"
argument_list|,
operator|(
name|acs_chars
operator|==
name|NULL
operator|)
condition|?
literal|"NULL"
else|:
literal|"READ"
argument_list|,
name|_nc_visbuf
argument_list|(
name|acs_chars
argument_list|)
argument_list|)
expr_stmt|;
name|_tracef
argument_list|(
literal|"%s acs_chars %s"
argument_list|,
operator|(
name|acs_chars
operator|==
name|NULL
operator|)
condition|?
literal|"NULL"
else|:
operator|(
name|strcmp
argument_list|(
name|acs_chars
argument_list|,
name|show
argument_list|)
condition|?
literal|"DIFF"
else|:
literal|"SAME"
operator|)
argument_list|,
name|_nc_visbuf
argument_list|(
name|show
argument_list|)
argument_list|)
expr_stmt|;
name|_nc_unlock_global
argument_list|(
name|tracef
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* TRACE */
block|}
end_function

begin_define
define|#
directive|define
name|ENSURE_TINFO
parameter_list|(
name|sp
parameter_list|)
value|(TCBOf(sp)->drv->isTerminfo)
end_define

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_cookie_init
argument_list|(
argument|SCREEN *sp
argument_list|)
end_macro

begin_block
block|{
name|bool
name|support_cookies
init|=
name|USE_XMC_SUPPORT
decl_stmt|;
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
init|=
operator|(
name|TERMINAL_CONTROL_BLOCK
operator|*
operator|)
operator|(
name|sp
operator|->
name|_term
operator|)
decl_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
operator|||
operator|!
name|ENSURE_TINFO
argument_list|(
name|sp
argument_list|)
condition|)
return|return;
if|#
directive|if
name|USE_XMC_SUPPORT
comment|/*      * If we have no magic-cookie support compiled-in, or if it is suppressed      * in the environment, reset the support-flag.      */
if|if
condition|(
name|magic_cookie_glitch
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|getenv
argument_list|(
literal|"NCURSES_NO_MAGIC_COOKIE"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|support_cookies
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|support_cookies
operator|&&
name|magic_cookie_glitch
operator|>=
literal|0
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"will disable attributes to work w/o magic cookies"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|magic_cookie_glitch
operator|>
literal|0
condition|)
block|{
comment|/* tvi, wyse */
name|sp
operator|->
name|_xmc_triggers
operator|=
name|sp
operator|->
name|_ok_attributes
operator|&
operator|(
name|A_STANDOUT
operator||
name|A_UNDERLINE
operator||
name|A_REVERSE
operator||
name|A_BLINK
operator||
name|A_DIM
operator||
name|A_BOLD
operator||
name|A_INVIS
operator||
name|A_PROTECT
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * We "should" treat colors as an attribute.  The wyse350 (and its 	 * clones) appear to be the only ones that have both colors and magic 	 * cookies. 	 */
block|if (has_colors()) { 	    sp->_xmc_triggers |= A_COLOR; 	}
endif|#
directive|endif
name|sp
operator|->
name|_xmc_suppress
operator|=
name|sp
operator|->
name|_xmc_triggers
operator|&
operator|(
name|chtype
operator|)
operator|~
operator|(
name|A_BOLD
operator|)
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"magic cookie attributes %s"
operator|,
name|_traceattr
argument_list|(
name|sp
operator|->
name|_xmc_suppress
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Supporting line-drawing may be possible.  But make the regular 	 * video attributes work first. 	 */
name|acs_chars
operator|=
name|ABSENT_STRING
expr_stmt|;
name|ena_acs
operator|=
name|ABSENT_STRING
expr_stmt|;
name|enter_alt_charset_mode
operator|=
name|ABSENT_STRING
expr_stmt|;
name|exit_alt_charset_mode
operator|=
name|ABSENT_STRING
expr_stmt|;
if|#
directive|if
name|USE_XMC_SUPPORT
comment|/* 	 * To keep the cookie support simple, suppress all of the optimization 	 * hooks except for clear_screen and the cursor addressing. 	 */
if|if
condition|(
name|support_cookies
condition|)
block|{
name|clr_eol
operator|=
name|ABSENT_STRING
expr_stmt|;
name|clr_eos
operator|=
name|ABSENT_STRING
expr_stmt|;
name|set_attributes
operator|=
name|ABSENT_STRING
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|magic_cookie_glitch
operator|==
literal|0
condition|)
block|{
comment|/* hpterm */
block|}
comment|/*      * If magic cookies are not supported, cancel the strings that set      * video attributes.      */
if|if
condition|(
operator|!
name|support_cookies
operator|&&
name|magic_cookie_glitch
operator|>=
literal|0
condition|)
block|{
name|magic_cookie_glitch
operator|=
name|ABSENT_NUMERIC
expr_stmt|;
name|set_attributes
operator|=
name|ABSENT_STRING
expr_stmt|;
name|enter_blink_mode
operator|=
name|ABSENT_STRING
expr_stmt|;
name|enter_bold_mode
operator|=
name|ABSENT_STRING
expr_stmt|;
name|enter_dim_mode
operator|=
name|ABSENT_STRING
expr_stmt|;
name|enter_reverse_mode
operator|=
name|ABSENT_STRING
expr_stmt|;
name|enter_standout_mode
operator|=
name|ABSENT_STRING
expr_stmt|;
name|enter_underline_mode
operator|=
name|ABSENT_STRING
expr_stmt|;
block|}
comment|/* initialize normal acs before wide, since we use mapping in the latter */
if|#
directive|if
operator|!
name|USE_WIDEC_SUPPORT
if|if
condition|(
name|_nc_unicode_locale
argument_list|()
operator|&&
name|_nc_locale_breaks_acs
argument_list|(
name|sp
operator|->
name|_term
argument_list|)
condition|)
block|{
name|acs_chars
operator|=
name|NULL
expr_stmt|;
name|ena_acs
operator|=
name|NULL
expr_stmt|;
name|enter_alt_charset_mode
operator|=
name|NULL
expr_stmt|;
name|exit_alt_charset_mode
operator|=
name|NULL
expr_stmt|;
name|set_attributes
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|drv_twait
argument_list|(
name|TERMINAL_CONTROL_BLOCK
operator|*
name|TCB
argument_list|,
name|int
name|mode
argument_list|,
name|int
name|milliseconds
argument_list|,
name|int
operator|*
name|timeleft
name|EVENTLIST_2nd
argument_list|(
name|_nc_eventlist
operator|*
name|evl
argument_list|)
argument_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
return|return
name|_nc_timed_wait
argument_list|(
argument|sp
argument_list|,
argument|mode
argument_list|,
argument|milliseconds
argument_list|,
argument|timeleft EVENTLIST_2nd(evl)
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|drv_read
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
modifier|*
name|buf
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|char
name|c2
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|#
directive|if
name|USE_PTHREADS_EINTR
if|if
condition|(
operator|(
name|pthread_self
operator|)
operator|&&
operator|(
name|pthread_kill
operator|)
operator|&&
operator|(
name|pthread_equal
operator|)
condition|)
name|_nc_globals
operator|.
name|read_thread
operator|=
name|pthread_self
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|read
argument_list|(
name|sp
operator|->
name|_ifd
argument_list|,
operator|&
name|c2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|USE_PTHREADS_EINTR
name|_nc_globals
operator|.
name|read_thread
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|*
name|buf
operator|=
operator|(
name|int
operator|)
name|c2
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_nap
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
name|GCC_UNUSED
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
if|#
directive|if
name|HAVE_NANOSLEEP
block|{
name|struct
name|timespec
name|request
decl_stmt|,
name|remaining
decl_stmt|;
name|request
operator|.
name|tv_sec
operator|=
name|ms
operator|/
literal|1000
expr_stmt|;
name|request
operator|.
name|tv_nsec
operator|=
operator|(
name|ms
operator|%
literal|1000
operator|)
operator|*
literal|1000000
expr_stmt|;
while|while
condition|(
name|nanosleep
argument_list|(
operator|&
name|request
argument_list|,
operator|&
name|remaining
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
block|{
name|request
operator|=
name|remaining
expr_stmt|;
block|}
block|}
else|#
directive|else
name|_nc_timed_wait
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|ms
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
name|EVENTLIST_2nd
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__nc_putp
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
name|GCC_UNUSED
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|rc
init|=
name|ERR
decl_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|rc
operator|=
name|NCURSES_SP_NAME
argument_list|(
argument|_nc_putp
argument_list|)
operator|(
name|NCURSES_SP_ARGx
name|name
operator|,
name|value
operator|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__nc_putp_flush
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|rc
init|=
name|__nc_putp
argument_list|(
name|sp
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|!=
name|ERR
condition|)
block|{
name|NCURSES_SP_NAME
function_decl|(
name|_nc_flush
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_kpad
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|bool
name|flag
parameter_list|)
block|{
name|int
name|ret
init|=
name|ERR
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|sp
operator|=
name|TCB
operator|->
name|csp
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
name|flag
condition|)
block|{
operator|(
name|void
operator|)
name|__nc_putp_flush
argument_list|(
name|sp
argument_list|,
literal|"keypad_xmit"
argument_list|,
name|keypad_xmit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flag
operator|&&
name|keypad_local
condition|)
block|{
operator|(
name|void
operator|)
name|__nc_putp_flush
argument_list|(
name|sp
argument_list|,
literal|"keypad_local"
argument_list|,
name|keypad_local
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&&
operator|!
name|sp
operator|->
name|_tried
condition|)
block|{
name|_nc_init_keytry
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|_tried
operator|=
name|TRUE
expr_stmt|;
block|}
name|ret
operator|=
name|OK
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_keyok
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|c
parameter_list|,
name|bool
name|flag
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
block|{
name|unsigned
name|ch
init|=
operator|(
name|unsigned
operator|)
name|c
decl_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
while|while
condition|(
operator|(
name|s
operator|=
name|_nc_expand_try
argument_list|(
name|sp
operator|->
name|_key_ok
argument_list|,
name|ch
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|_nc_remove_key
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|_key_ok
operator|)
argument_list|,
name|ch
argument_list|)
condition|)
block|{
name|code
operator|=
name|_nc_add_to_try
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|_keytry
operator|)
argument_list|,
name|s
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|OK
condition|)
break|break;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|(
name|s
operator|=
name|_nc_expand_try
argument_list|(
name|sp
operator|->
name|_keytry
argument_list|,
name|ch
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|_nc_remove_key
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|_keytry
operator|)
argument_list|,
name|ch
argument_list|)
condition|)
block|{
name|code
operator|=
name|_nc_add_to_try
argument_list|(
operator|&
operator|(
name|sp
operator|->
name|_key_ok
operator|)
argument_list|,
name|s
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|OK
condition|)
break|break;
block|}
block|}
block|}
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drv_kyExist
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|key
parameter_list|)
block|{
name|bool
name|res
init|=
name|FALSE
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|TCB
operator|->
name|csp
condition|)
name|res
operator|=
name|TINFO_HAS_KEY
argument_list|(
name|TCB
operator|->
name|csp
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|TERM_DRIVER
argument_list|)
end_macro

begin_expr_stmt
name|_nc_TINFO_DRIVER
operator|=
block|{
name|TRUE
block|,
name|drv_CanHandle
block|,
comment|/* CanHandle */
name|drv_init
block|,
comment|/* init */
name|drv_release
block|,
comment|/* release */
name|drv_size
block|,
comment|/* size */
name|drv_sgmode
block|,
comment|/* sgmode */
name|drv_conattr
block|,
comment|/* conattr */
name|drv_mvcur
block|,
comment|/* hwcur */
name|drv_mode
block|,
comment|/* mode */
name|drv_rescol
block|,
comment|/* rescol */
name|drv_rescolors
block|,
comment|/* rescolors */
name|drv_setcolor
block|,
comment|/* color */
name|drv_dobeepflash
block|,
comment|/* doBeepOrFlash */
name|drv_initpair
block|,
comment|/* initpair */
name|drv_initcolor
block|,
comment|/* initcolor */
name|drv_do_color
block|,
comment|/* docolor */
name|drv_initmouse
block|,
comment|/* initmouse */
name|drv_testmouse
block|,
comment|/* testmouse */
name|drv_setfilter
block|,
comment|/* setfilter */
name|drv_hwlabel
block|,
comment|/* hwlabel */
name|drv_hwlabelOnOff
block|,
comment|/* hwlabelOnOff */
name|drv_doupdate
block|,
comment|/* update */
name|drv_defaultcolors
block|,
comment|/* defaultcolors */
name|drv_print
block|,
comment|/* print */
name|drv_getsize
block|,
comment|/* getsize */
name|drv_setsize
block|,
comment|/* setsize */
name|drv_initacs
block|,
comment|/* initacs */
name|drv_screen_init
block|,
comment|/* scinit */
name|drv_wrap
block|,
comment|/* scexit */
name|drv_twait
block|,
comment|/* twait  */
name|drv_read
block|,
comment|/* read */
name|drv_nap
block|,
comment|/* nap */
name|drv_kpad
block|,
comment|/* kpad */
name|drv_keyok
block|,
comment|/* kyOk */
name|drv_kyExist
comment|/* kyExist */
block|}
expr_stmt|;
end_expr_stmt

end_unit

