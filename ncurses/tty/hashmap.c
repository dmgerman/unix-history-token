begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2009,2010 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Zeyd M. Ben-Halim<zmbenhal@netcom.com> 1992,1995               *  *     and: Eric S. Raymond<esr@snark.thyrsus.com>                         *  ****************************************************************************/
end_comment

begin_comment
comment|/******************************************************************************  NAME    hashmap.c -- fill in scramble vector based on text hashes  SYNOPSIS    void _nc_hash_map(void)  DESCRIPTION:    This code attempts to recognize pairs of old and new lines in the physical and virtual screens.  When a line pair is recognized, the old line index is placed in the oldindex member of the virtual screen line, to be used by the vertical-motion optimizer portion of the update logic (see hardscroll.c).     Line pairs are recognized by applying a modified Heckel's algorithm, sped up by hashing.  If a line hash is unique in both screens, those lines must be a pair. Then if the lines just before or after the pair are the same or similar, they are a pair too.     We don't worry about false pairs produced by hash collisions, on the assumption that such cases are rare and will only make the latter stages of update less efficient, not introduce errors.  HOW TO TEST THIS:  Use the following production:  hashmap: hashmap.c 	$(CC) -g -DHASHDEBUG hashmap.c hardscroll.c ../objects/lib_trace.o -o hashmap  AUTHOR     Eric S. Raymond<esr@snark.thyrsus.com>, May 1996     Bug fixes and improvements by Alexander V. Lukyanov<lav@yars.free.net>, 1997  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CUR
end_ifndef

begin_define
define|#
directive|define
name|CUR
value|SP_TERMTYPE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: hashmap.c,v 1.62 2010/04/24 23:46:07 tom Exp $"
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|HASHDEBUG
end_ifdef

begin_define
define|#
directive|define
name|_tracef
value|printf
end_define

begin_undef
undef|#
directive|undef
name|TR
end_undef

begin_define
define|#
directive|define
name|TR
parameter_list|(
name|n
parameter_list|,
name|a
parameter_list|)
value|if (_nc_tracing& (n)) { _tracef a ; putchar('\n'); }
end_define

begin_undef
undef|#
directive|undef
name|screen_lines
end_undef

begin_define
define|#
directive|define
name|screen_lines
value|MAXLINES
end_define

begin_define
define|#
directive|define
name|TEXTWIDTH
value|1
end_define

begin_decl_stmt
name|int
name|oldnums
index|[
name|MAXLINES
index|]
decl_stmt|,
name|reallines
index|[
name|MAXLINES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NCURSES_CH_T
name|oldtext
index|[
name|MAXLINES
index|]
index|[
name|TEXTWIDTH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NCURSES_CH_T
name|newtext
index|[
name|MAXLINES
index|]
index|[
name|TEXTWIDTH
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|OLDNUM
parameter_list|(
name|sp
parameter_list|,
name|n
parameter_list|)
value|oldnums[n]
end_define

begin_define
define|#
directive|define
name|OLDTEXT
parameter_list|(
name|sp
parameter_list|,
name|n
parameter_list|)
value|oldtext[n]
end_define

begin_define
define|#
directive|define
name|NEWTEXT
parameter_list|(
name|sp
parameter_list|,
name|m
parameter_list|)
value|newtext[m]
end_define

begin_define
define|#
directive|define
name|PENDING
parameter_list|(
name|sp
parameter_list|,
name|n
parameter_list|)
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HASHDEBUG */
end_comment

begin_define
define|#
directive|define
name|OLDNUM
parameter_list|(
name|sp
parameter_list|,
name|n
parameter_list|)
value|(sp)->_oldnum_list[n]
end_define

begin_define
define|#
directive|define
name|OLDTEXT
parameter_list|(
name|sp
parameter_list|,
name|n
parameter_list|)
value|CurScreen(sp)->_line[n].text
end_define

begin_define
define|#
directive|define
name|NEWTEXT
parameter_list|(
name|sp
parameter_list|,
name|m
parameter_list|)
value|NewScreen(sp)->_line[m].text
end_define

begin_define
define|#
directive|define
name|TEXTWIDTH
parameter_list|(
name|sp
parameter_list|)
value|(CurScreen(sp)->_maxx + 1)
end_define

begin_define
define|#
directive|define
name|PENDING
parameter_list|(
name|sp
parameter_list|,
name|n
parameter_list|)
value|(NewScreen(sp)->_line[n].firstchar != _NOCHANGE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HASHDEBUG */
end_comment

begin_define
define|#
directive|define
name|oldhash
parameter_list|(
name|sp
parameter_list|)
value|((sp)->oldhash)
end_define

begin_define
define|#
directive|define
name|newhash
parameter_list|(
name|sp
parameter_list|)
value|((sp)->newhash)
end_define

begin_define
define|#
directive|define
name|hashtab
parameter_list|(
name|sp
parameter_list|)
value|((sp)->hashtab)
end_define

begin_define
define|#
directive|define
name|lines_alloc
parameter_list|(
name|sp
parameter_list|)
value|((sp)->hashtab_len)
end_define

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_define
define|#
directive|define
name|HASH_VAL
parameter_list|(
name|ch
parameter_list|)
value|(ch.chars[0])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HASH_VAL
parameter_list|(
name|ch
parameter_list|)
value|(ch)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|NCURSES_CH_T
name|blankchar
init|=
name|NewChar
argument_list|(
name|BLANK_TEXT
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|NCURSES_INLINE
name|unsigned
name|long
name|hash
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|,
name|NCURSES_CH_T
modifier|*
name|text
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|NCURSES_CH_T
name|ch
decl_stmt|;
name|unsigned
name|long
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TEXTWIDTH
argument_list|(
name|sp
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|ch
operator|=
operator|*
name|text
operator|++
expr_stmt|;
name|result
operator|+=
operator|(
name|result
operator|<<
literal|5
operator|)
operator|+
operator|(
name|unsigned
name|long
operator|)
name|HASH_VAL
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* approximate update cost */
end_comment

begin_function
specifier|static
name|int
name|update_cost
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|,
name|NCURSES_CH_T
modifier|*
name|from
parameter_list|,
name|NCURSES_CH_T
modifier|*
name|to
parameter_list|)
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TEXTWIDTH
argument_list|(
name|sp
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|from
operator|++
operator|,
name|to
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|CharEq
argument_list|(
operator|*
name|from
argument_list|,
operator|*
name|to
argument_list|)
operator|)
condition|)
name|cost
operator|++
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|update_cost_from_blank
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|,
name|NCURSES_CH_T
modifier|*
name|to
parameter_list|)
block|{
name|int
name|cost
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|NCURSES_CH_T
name|blank
init|=
name|blankchar
decl_stmt|;
if|if
condition|(
name|back_color_erase
condition|)
name|SetPair
argument_list|(
name|blank
argument_list|,
name|GetPair
argument_list|(
name|stdscr
operator|->
name|_nc_bkgd
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TEXTWIDTH
argument_list|(
name|sp
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|to
operator|++
control|)
if|if
condition|(
operator|!
operator|(
name|CharEq
argument_list|(
name|blank
argument_list|,
operator|*
name|to
argument_list|)
operator|)
condition|)
name|cost
operator|++
expr_stmt|;
return|return
name|cost
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true when moving line 'from' to line 'to' seems to be cost  * effective. 'blank' indicates whether the line 'to' would become blank.  */
end_comment

begin_function
specifier|static
name|NCURSES_INLINE
name|bool
name|cost_effective
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|,
specifier|const
name|int
name|from
parameter_list|,
specifier|const
name|int
name|to
parameter_list|,
specifier|const
name|bool
name|blank
parameter_list|)
block|{
name|int
name|new_from
decl_stmt|;
if|if
condition|(
name|from
operator|==
name|to
condition|)
return|return
name|FALSE
return|;
name|new_from
operator|=
name|OLDNUM
argument_list|(
name|sp
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_from
operator|==
name|_NEWINDEX
condition|)
name|new_from
operator|=
name|from
expr_stmt|;
comment|/*      * On the left side of>= is the cost before moving;      * on the right side -- cost after moving.      */
return|return
operator|(
operator|(
operator|(
name|blank
condition|?
name|update_cost_from_blank
argument_list|(
name|sp
argument_list|,
name|NEWTEXT
argument_list|(
name|sp
argument_list|,
name|to
argument_list|)
argument_list|)
else|:
name|update_cost
argument_list|(
name|sp
argument_list|,
name|OLDTEXT
argument_list|(
name|sp
argument_list|,
name|to
argument_list|)
argument_list|,
name|NEWTEXT
argument_list|(
name|sp
argument_list|,
name|to
argument_list|)
argument_list|)
operator|)
operator|+
name|update_cost
argument_list|(
name|sp
argument_list|,
name|OLDTEXT
argument_list|(
name|sp
argument_list|,
name|new_from
argument_list|)
argument_list|,
name|NEWTEXT
argument_list|(
name|sp
argument_list|,
name|from
argument_list|)
argument_list|)
operator|)
operator|>=
operator|(
operator|(
name|new_from
operator|==
name|from
condition|?
name|update_cost_from_blank
argument_list|(
name|sp
argument_list|,
name|NEWTEXT
argument_list|(
name|sp
argument_list|,
name|from
argument_list|)
argument_list|)
else|:
name|update_cost
argument_list|(
name|sp
argument_list|,
name|OLDTEXT
argument_list|(
name|sp
argument_list|,
name|new_from
argument_list|)
argument_list|,
name|NEWTEXT
argument_list|(
name|sp
argument_list|,
name|from
argument_list|)
argument_list|)
operator|)
operator|+
name|update_cost
argument_list|(
name|sp
argument_list|,
name|OLDTEXT
argument_list|(
name|sp
argument_list|,
name|from
argument_list|)
argument_list|,
name|NEWTEXT
argument_list|(
name|sp
argument_list|,
name|to
argument_list|)
argument_list|)
operator|)
operator|)
condition|?
name|TRUE
else|:
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|grow_hunks
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|shift
decl_stmt|;
name|int
name|back_limit
decl_stmt|,
name|forward_limit
decl_stmt|;
comment|/* limits for cells to fill */
name|int
name|back_ref_limit
decl_stmt|,
name|forward_ref_limit
decl_stmt|;
comment|/* limits for refrences */
name|int
name|i
decl_stmt|;
name|int
name|next_hunk
decl_stmt|;
comment|/*      * This is tricky part.  We have unique pairs to use as anchors.      * Use these to deduce the presence of spans of identical lines.      */
name|back_limit
operator|=
literal|0
expr_stmt|;
name|back_ref_limit
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|screen_lines
argument_list|(
name|sp
argument_list|)
operator|&&
name|OLDNUM
argument_list|(
name|sp
argument_list|,
name|i
argument_list|)
operator|==
name|_NEWINDEX
condition|)
name|i
operator|++
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|screen_lines
argument_list|(
name|sp
argument_list|)
condition|;
name|i
operator|=
name|next_hunk
control|)
block|{
name|start
operator|=
name|i
expr_stmt|;
name|shift
operator|=
name|OLDNUM
argument_list|(
name|sp
argument_list|,
name|i
argument_list|)
operator|-
name|i
expr_stmt|;
comment|/* get forward limit */
name|i
operator|=
name|start
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|screen_lines
argument_list|(
name|sp
argument_list|)
operator|&&
name|OLDNUM
argument_list|(
name|sp
argument_list|,
name|i
argument_list|)
operator|!=
name|_NEWINDEX
operator|&&
name|OLDNUM
argument_list|(
name|sp
argument_list|,
name|i
argument_list|)
operator|-
name|i
operator|==
name|shift
condition|)
name|i
operator|++
expr_stmt|;
name|end
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|screen_lines
argument_list|(
name|sp
argument_list|)
operator|&&
name|OLDNUM
argument_list|(
name|sp
argument_list|,
name|i
argument_list|)
operator|==
name|_NEWINDEX
condition|)
name|i
operator|++
expr_stmt|;
name|next_hunk
operator|=
name|i
expr_stmt|;
name|forward_limit
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|screen_lines
argument_list|(
name|sp
argument_list|)
operator|||
name|OLDNUM
argument_list|(
name|sp
argument_list|,
name|i
argument_list|)
operator|>=
name|i
condition|)
name|forward_ref_limit
operator|=
name|i
expr_stmt|;
else|else
name|forward_ref_limit
operator|=
name|OLDNUM
argument_list|(
name|sp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|start
operator|-
literal|1
expr_stmt|;
comment|/* grow back */
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
name|back_limit
operator|=
name|back_ref_limit
operator|+
operator|(
operator|-
name|shift
operator|)
expr_stmt|;
while|while
condition|(
name|i
operator|>=
name|back_limit
condition|)
block|{
if|if
condition|(
name|newhash
argument_list|(
name|sp
argument_list|)
index|[
name|i
index|]
operator|==
name|oldhash
argument_list|(
name|sp
argument_list|)
index|[
name|i
operator|+
name|shift
index|]
operator|||
name|cost_effective
argument_list|(
name|sp
argument_list|,
name|i
operator|+
name|shift
argument_list|,
name|i
argument_list|,
name|shift
operator|<
literal|0
argument_list|)
condition|)
block|{
name|OLDNUM
argument_list|(
name|sp
argument_list|,
name|i
argument_list|)
operator|=
name|i
operator|+
name|shift
expr_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"connected new line %d to old line %d (backward continuation)"
operator|,
name|i
operator|,
name|i
operator|+
name|shift
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"not connecting new line %d to old line %d (backward continuation)"
operator|,
name|i
operator|,
name|i
operator|+
name|shift
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|--
expr_stmt|;
block|}
name|i
operator|=
name|end
expr_stmt|;
comment|/* grow forward */
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
name|forward_limit
operator|=
name|forward_ref_limit
operator|-
name|shift
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|forward_limit
condition|)
block|{
if|if
condition|(
name|newhash
argument_list|(
name|sp
argument_list|)
index|[
name|i
index|]
operator|==
name|oldhash
argument_list|(
name|sp
argument_list|)
index|[
name|i
operator|+
name|shift
index|]
operator|||
name|cost_effective
argument_list|(
name|sp
argument_list|,
name|i
operator|+
name|shift
argument_list|,
name|i
argument_list|,
name|shift
operator|>
literal|0
argument_list|)
condition|)
block|{
name|OLDNUM
argument_list|(
name|sp
argument_list|,
name|i
argument_list|)
operator|=
name|i
operator|+
name|shift
expr_stmt|;
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"connected new line %d to old line %d (forward continuation)"
operator|,
name|i
operator|,
name|i
operator|+
name|shift
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"not connecting new line %d to old line %d (forward continuation)"
operator|,
name|i
operator|,
name|i
operator|+
name|shift
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|back_ref_limit
operator|=
name|back_limit
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|shift
operator|>
literal|0
condition|)
name|back_ref_limit
operator|+=
name|shift
expr_stmt|;
block|}
block|}
end_function

begin_function
name|NCURSES_EXPORT
function|(
name|void
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|_nc_hash_map
argument_list|)
parameter_list|(
name|NCURSES_SP_DCL0
parameter_list|)
block|{
name|HASHMAP
modifier|*
name|hsp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|start
decl_stmt|,
name|shift
decl_stmt|,
name|size
decl_stmt|;
if|if
condition|(
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
operator|>
name|lines_alloc
argument_list|(
name|SP_PARM
argument_list|)
condition|)
block|{
if|if
condition|(
name|hashtab
argument_list|(
name|SP_PARM
argument_list|)
condition|)
name|free
argument_list|(
name|hashtab
argument_list|(
name|SP_PARM
argument_list|)
argument_list|)
expr_stmt|;
name|hashtab
argument_list|(
name|SP_PARM
argument_list|)
operator|=
name|typeMalloc
argument_list|(
name|HASHMAP
argument_list|,
operator|(
operator|(
name|size_t
operator|)
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashtab
argument_list|(
name|SP_PARM
argument_list|)
condition|)
block|{
if|if
condition|(
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
condition|)
block|{
name|FreeAndNull
argument_list|(
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|lines_alloc
argument_list|(
name|SP_PARM
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|lines_alloc
argument_list|(
name|SP_PARM
argument_list|)
operator|=
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
operator|&&
name|newhash
argument_list|(
name|SP_PARM
argument_list|)
condition|)
block|{
comment|/* re-hash only changed lines */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|PENDING
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
condition|)
name|newhash
argument_list|(
name|SP_PARM
argument_list|)
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|SP_PARM
argument_list|,
name|NEWTEXT
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* re-hash all */
if|if
condition|(
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
operator|==
literal|0
condition|)
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
operator|=
name|typeCalloc
argument_list|(
argument|unsigned long
argument_list|,
argument|(size_t) screen_lines(SP_PARM)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newhash
argument_list|(
name|SP_PARM
argument_list|)
operator|==
literal|0
condition|)
name|newhash
argument_list|(
name|SP_PARM
argument_list|)
operator|=
name|typeCalloc
argument_list|(
argument|unsigned long
argument_list|,
argument|(size_t) screen_lines(SP_PARM)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
operator|||
operator|!
name|newhash
argument_list|(
name|SP_PARM
argument_list|)
condition|)
return|return;
comment|/* malloc failure */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|newhash
argument_list|(
name|SP_PARM
argument_list|)
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|SP_PARM
argument_list|,
name|NEWTEXT
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|SP_PARM
argument_list|,
name|OLDTEXT
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|HASH_VERIFY
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|newhash
argument_list|(
name|SP_PARM
argument_list|)
index|[
name|i
index|]
operator|!=
name|hash
argument_list|(
name|SP_PARM
argument_list|,
name|NEWTEXT
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error in newhash[%d]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
index|[
name|i
index|]
operator|!=
name|hash
argument_list|(
name|SP_PARM
argument_list|,
name|OLDTEXT
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error in oldhash[%d]\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * Set up and count line-hash values.      */
name|memset
argument_list|(
name|hashtab
argument_list|(
name|SP_PARM
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|hashtab
argument_list|(
name|SP_PARM
argument_list|)
operator|)
argument_list|)
operator|*
operator|(
operator|(
name|size_t
operator|)
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|hashval
init|=
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|hsp
operator|=
name|hashtab
argument_list|(
name|SP_PARM
argument_list|)
init|;
name|hsp
operator|->
name|hashval
condition|;
name|hsp
operator|++
control|)
if|if
condition|(
name|hsp
operator|->
name|hashval
operator|==
name|hashval
condition|)
break|break;
name|hsp
operator|->
name|hashval
operator|=
name|hashval
expr_stmt|;
comment|/* in case this is a new entry */
name|hsp
operator|->
name|oldcount
operator|++
expr_stmt|;
name|hsp
operator|->
name|oldindex
operator|=
name|i
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|long
name|hashval
init|=
name|newhash
argument_list|(
name|SP_PARM
argument_list|)
index|[
name|i
index|]
decl_stmt|;
for|for
control|(
name|hsp
operator|=
name|hashtab
argument_list|(
name|SP_PARM
argument_list|)
init|;
name|hsp
operator|->
name|hashval
condition|;
name|hsp
operator|++
control|)
if|if
condition|(
name|hsp
operator|->
name|hashval
operator|==
name|hashval
condition|)
break|break;
name|hsp
operator|->
name|hashval
operator|=
name|hashval
expr_stmt|;
comment|/* in case this is a new entry */
name|hsp
operator|->
name|newcount
operator|++
expr_stmt|;
name|hsp
operator|->
name|newindex
operator|=
name|i
expr_stmt|;
name|OLDNUM
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
operator|=
name|_NEWINDEX
expr_stmt|;
comment|/* initialize old indices array */
block|}
comment|/*      * Mark line pairs corresponding to unique hash pairs.      *      * We don't mark lines with offset 0, because it can make fail      * extending hunks by cost_effective. Otherwise, it does not      * have any side effects.      */
for|for
control|(
name|hsp
operator|=
name|hashtab
argument_list|(
name|SP_PARM
argument_list|)
init|;
name|hsp
operator|->
name|hashval
condition|;
name|hsp
operator|++
control|)
if|if
condition|(
name|hsp
operator|->
name|oldcount
operator|==
literal|1
operator|&&
name|hsp
operator|->
name|newcount
operator|==
literal|1
operator|&&
name|hsp
operator|->
name|oldindex
operator|!=
name|hsp
operator|->
name|newindex
condition|)
block|{
name|TR
argument_list|(
name|TRACE_UPDATE
operator||
name|TRACE_MOVE
argument_list|,
operator|(
literal|"new line %d is hash-identical to old line %d (unique)"
operator|,
name|hsp
operator|->
name|newindex
operator|,
name|hsp
operator|->
name|oldindex
operator|)
argument_list|)
expr_stmt|;
name|OLDNUM
argument_list|(
name|SP_PARM
argument_list|,
name|hsp
operator|->
name|newindex
argument_list|)
operator|=
name|hsp
operator|->
name|oldindex
expr_stmt|;
block|}
name|grow_hunks
argument_list|(
name|SP_PARM
argument_list|)
expr_stmt|;
comment|/*      * Eliminate bad or impossible shifts -- this includes removing      * those hunks which could not grow because of conflicts, as well      * those which are to be moved too far, they are likely to destroy      * more than carry.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
condition|;
control|)
block|{
while|while
condition|(
name|i
operator|<
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
operator|&&
name|OLDNUM
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
operator|==
name|_NEWINDEX
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
condition|)
break|break;
name|start
operator|=
name|i
expr_stmt|;
name|shift
operator|=
name|OLDNUM
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
operator|-
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|screen_lines
argument_list|(
name|SP_PARM
argument_list|)
operator|&&
name|OLDNUM
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
operator|!=
name|_NEWINDEX
operator|&&
name|OLDNUM
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
operator|-
name|i
operator|==
name|shift
condition|)
name|i
operator|++
expr_stmt|;
name|size
operator|=
name|i
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|3
operator|||
name|size
operator|+
name|min
argument_list|(
name|size
operator|/
literal|8
argument_list|,
literal|2
argument_list|)
operator|<
name|abs
argument_list|(
name|shift
argument_list|)
condition|)
block|{
while|while
condition|(
name|start
operator|<
name|i
condition|)
block|{
name|OLDNUM
argument_list|(
name|SP_PARM
argument_list|,
name|start
argument_list|)
operator|=
name|_NEWINDEX
expr_stmt|;
name|start
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* After clearing invalid hunks, try grow the rest. */
name|grow_hunks
argument_list|(
name|SP_PARM
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_hash_map
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
name|NCURSES_SP_NAME
function_decl|(
name|_nc_hash_map
function_decl|)
parameter_list|(
name|CURRENT_SCREEN
parameter_list|)
function_decl|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|NCURSES_EXPORT
function|(
name|void
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|_nc_make_oldhash
argument_list|)
parameter_list|(
name|NCURSES_SP_DCLx
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
condition|)
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|SP_PARM
argument_list|,
name|OLDTEXT
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_make_oldhash
argument_list|(
argument|int i
argument_list|)
end_macro

begin_block
block|{
name|NCURSES_SP_NAME
function_decl|(
name|_nc_make_oldhash
function_decl|)
parameter_list|(
name|CURRENT_SCREEN
parameter_list|,
name|i
parameter_list|)
function_decl|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|NCURSES_EXPORT
function|(
name|void
function|)
name|NCURSES_SP_NAME
argument_list|(
argument|_nc_scroll_oldhash
argument_list|)
parameter_list|(
name|NCURSES_SP_DCLx
name|int
name|n
parameter_list|,
name|int
name|top
parameter_list|,
name|int
name|bot
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
condition|)
return|return;
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
operator|)
argument_list|)
operator|*
call|(
name|size_t
call|)
argument_list|(
name|bot
operator|-
name|top
operator|+
literal|1
operator|-
name|abs
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|memmove
argument_list|(
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
operator|+
name|top
argument_list|,
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
operator|+
name|top
operator|+
name|n
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bot
init|;
name|i
operator|>
name|bot
operator|-
name|n
condition|;
name|i
operator|--
control|)
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|SP_PARM
argument_list|,
name|OLDTEXT
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memmove
argument_list|(
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
operator|+
name|top
operator|-
name|n
argument_list|,
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
operator|+
name|top
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|top
init|;
name|i
operator|<
name|top
operator|-
name|n
condition|;
name|i
operator|++
control|)
name|oldhash
argument_list|(
name|SP_PARM
argument_list|)
index|[
name|i
index|]
operator|=
name|hash
argument_list|(
name|SP_PARM
argument_list|,
name|OLDTEXT
argument_list|(
name|SP_PARM
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|NCURSES_SP_FUNCS
end_if

begin_macro
name|NCURSES_EXPORT
argument_list|(
argument|void
argument_list|)
end_macro

begin_macro
name|_nc_scroll_oldhash
argument_list|(
argument|int n
argument_list|,
argument|int top
argument_list|,
argument|int bot
argument_list|)
end_macro

begin_block
block|{
name|NCURSES_SP_NAME
function_decl|(
name|_nc_scroll_oldhash
function_decl|)
parameter_list|(
name|CURRENT_SCREEN
parameter_list|,
name|n
parameter_list|,
name|top
parameter_list|,
name|bot
parameter_list|)
function_decl|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HASHDEBUG
end_ifdef

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|table
index|[]
init|=
block|{
literal|"hashmap test-driver"
block|,
literal|""
block|,
literal|"#  comment"
block|,
literal|"l  get initial line number vector"
block|,
literal|"n  use following letters as text of new lines"
block|,
literal|"o  use following letters as text of old lines"
block|,
literal|"d  dump state of test arrays"
block|,
literal|"h  apply hash mapper and see scroll optimization"
block|,
literal|"?  this message"
block|}
decl_stmt|;
name|size_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|table
index|[
literal|0
index|]
argument_list|)
condition|;
name|n
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|table
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
name|GCC_UNUSED
parameter_list|,
name|char
modifier|*
name|argv
index|[]
name|GCC_UNUSED
parameter_list|)
block|{
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|st
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|setupterm
argument_list|(
name|NULL
argument_list|,
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|==
name|ERR
condition|)
return|return
name|EXIT_FAILURE
return|;
operator|(
name|void
operator|)
name|_nc_alloc_screen
argument_list|()
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
block|{
name|reallines
index|[
name|n
index|]
operator|=
name|n
expr_stmt|;
name|oldnums
index|[
name|n
index|]
operator|=
name|_NEWINDEX
expr_stmt|;
name|CharOf
argument_list|(
name|oldtext
index|[
name|n
index|]
index|[
literal|0
index|]
argument_list|)
operator|=
name|CharOf
argument_list|(
name|newtext
index|[
name|n
index|]
index|[
literal|0
index|]
argument_list|)
operator|=
literal|'.'
expr_stmt|;
block|}
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|_nc_tracing
operator|=
name|TRACE_MOVE
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* grab a test command */
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
break|break;
switch|switch
condition|(
name|line
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'#'
case|:
comment|/* comment */
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|line
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* get initial line number vector */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
block|{
name|reallines
index|[
name|n
index|]
operator|=
name|n
expr_stmt|;
name|oldnums
index|[
name|n
index|]
operator|=
name|_NEWINDEX
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
name|st
operator|=
name|strtok
argument_list|(
name|line
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
do|do
block|{
name|oldnums
index|[
name|n
operator|++
index|]
operator|=
name|atoi
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|st
operator|=
name|strtok
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|" "
argument_list|)
operator|)
operator|!=
literal|0
condition|)
do|;
break|break;
case|case
literal|'n'
case|:
comment|/* use following letters as text of new lines */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
name|CharOf
argument_list|(
name|newtext
index|[
name|n
index|]
index|[
literal|0
index|]
argument_list|)
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|line
index|[
name|n
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
break|break;
else|else
name|CharOf
argument_list|(
name|newtext
index|[
name|n
index|]
index|[
literal|0
index|]
argument_list|)
operator|=
name|line
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* use following letters as text of old lines */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
name|CharOf
argument_list|(
name|oldtext
index|[
name|n
index|]
index|[
literal|0
index|]
argument_list|)
operator|=
literal|'.'
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|line
index|[
name|n
operator|+
literal|1
index|]
operator|==
literal|'\n'
condition|)
break|break;
else|else
name|CharOf
argument_list|(
name|oldtext
index|[
name|n
index|]
index|[
literal|0
index|]
argument_list|)
operator|=
name|line
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* dump state of test arrays */
ifdef|#
directive|ifdef
name|TRACE
name|_nc_linedump
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Old lines: ["
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
name|putchar
argument_list|(
name|CharOf
argument_list|(
name|oldtext
index|[
name|n
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"New lines: ["
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|screen_lines
condition|;
name|n
operator|++
control|)
name|putchar
argument_list|(
name|CharOf
argument_list|(
name|newtext
index|[
name|n
index|]
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|']'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* apply hash mapper and see scroll optimization */
name|_nc_hash_map
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Result:\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|_nc_linedump
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|_nc_scroll_optimize
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Done.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
name|NO_LEAKS
name|_nc_free_and_exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
else|#
directive|else
return|return
name|EXIT_SUCCESS
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HASHDEBUG */
end_comment

begin_comment
comment|/* hashmap.c ends here */
end_comment

end_unit

