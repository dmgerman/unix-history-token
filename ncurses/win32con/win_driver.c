begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  * Copyright (c) 1998-2013,2014 Free Software Foundation, Inc.              *  *                                                                          *  * Permission is hereby granted, free of charge, to any person obtaining a  *  * copy of this software and associated documentation files (the            *  * "Software"), to deal in the Software without restriction, including      *  * without limitation the rights to use, copy, modify, merge, publish,      *  * distribute, distribute with modifications, sublicense, and/or sell       *  * copies of the Software, and to permit persons to whom the Software is    *  * furnished to do so, subject to the following conditions:                 *  *                                                                          *  * The above copyright notice and this permission notice shall be included  *  * in all copies or substantial portions of the Software.                   *  *                                                                          *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *  * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *  * IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *  * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *  * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *  * THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *  *                                                                          *  * Except as contained in this notice, the name(s) of the above copyright   *  * holders shall not be used in advertising or otherwise to promote the     *  * sale, use or other dealings in this Software without prior written       *  * authorization.                                                           *  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Author: Juergen Pfeifer                                                 *  ****************************************************************************/
end_comment

begin_comment
comment|/*  * TODO - GetMousePos(POINT * result) from ntconio.c  * TODO - implement nodelay  * TODO - when $NCGDB is set, implement non-buffered output, like PDCurses  */
end_comment

begin_include
include|#
directive|include
file|<curses.priv.h>
end_include

begin_define
define|#
directive|define
name|CUR
value|my_term.type.
end_define

begin_macro
name|MODULE_ID
argument_list|(
literal|"$Id: win_driver.c,v 1.24 2014/02/23 01:23:29 tom Exp $"
argument_list|)
end_macro

begin_define
define|#
directive|define
name|WINMAGIC
value|NCDRV_MAGIC(NCDRV_WINCONSOLE)
end_define

begin_define
define|#
directive|define
name|EXP_OPTIMIZE
value|0
end_define

begin_define
define|#
directive|define
name|okConsoleHandle
parameter_list|(
name|TCB
parameter_list|)
value|(TCB != 0&& !InvalidConsoleHandle(TCB->hdl))
end_define

begin_define
define|#
directive|define
name|AssertTCB
parameter_list|()
value|assert(TCB != 0&& (TCB->magic == WINMAGIC))
end_define

begin_define
define|#
directive|define
name|SetSP
parameter_list|()
value|assert(TCB->csp != 0); sp = TCB->csp; (void) sp
end_define

begin_define
define|#
directive|define
name|GenMap
parameter_list|(
name|vKey
parameter_list|,
name|key
parameter_list|)
value|MAKELONG(key, vKey)
end_define

begin_define
define|#
directive|define
name|AdjustY
parameter_list|(
name|p
parameter_list|)
value|((p)->buffered ? 0 : (int) (p)->SBI.srWindow.Top)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|LONG
name|keylist
index|[]
init|=
block|{
name|GenMap
argument_list|(
name|VK_PRIOR
argument_list|,
name|KEY_PPAGE
argument_list|)
block|,
name|GenMap
argument_list|(
name|VK_NEXT
argument_list|,
name|KEY_NPAGE
argument_list|)
block|,
name|GenMap
argument_list|(
name|VK_END
argument_list|,
name|KEY_END
argument_list|)
block|,
name|GenMap
argument_list|(
name|VK_HOME
argument_list|,
name|KEY_HOME
argument_list|)
block|,
name|GenMap
argument_list|(
name|VK_LEFT
argument_list|,
name|KEY_LEFT
argument_list|)
block|,
name|GenMap
argument_list|(
name|VK_UP
argument_list|,
name|KEY_UP
argument_list|)
block|,
name|GenMap
argument_list|(
name|VK_RIGHT
argument_list|,
name|KEY_RIGHT
argument_list|)
block|,
name|GenMap
argument_list|(
name|VK_DOWN
argument_list|,
name|KEY_DOWN
argument_list|)
block|,
name|GenMap
argument_list|(
name|VK_DELETE
argument_list|,
name|KEY_DC
argument_list|)
block|,
name|GenMap
argument_list|(
argument|VK_INSERT
argument_list|,
argument|KEY_IC
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|N_INI
value|((int)(sizeof(keylist)/sizeof(keylist[0])))
end_define

begin_define
define|#
directive|define
name|FKEYS
value|24
end_define

begin_define
define|#
directive|define
name|MAPSIZE
value|(FKEYS + N_INI)
end_define

begin_define
define|#
directive|define
name|NUMPAIRS
value|64
end_define

begin_typedef
typedef|typedef
struct|struct
name|props
block|{
name|CONSOLE_SCREEN_BUFFER_INFO
name|SBI
decl_stmt|;
name|bool
name|progMode
decl_stmt|;
name|TERM_HANDLE
name|lastOut
decl_stmt|;
name|DWORD
name|map
index|[
name|MAPSIZE
index|]
decl_stmt|;
name|DWORD
name|rmap
index|[
name|MAPSIZE
index|]
decl_stmt|;
name|WORD
name|pairs
index|[
name|NUMPAIRS
index|]
decl_stmt|;
name|bool
name|buffered
decl_stmt|;
name|COORD
name|origin
decl_stmt|;
name|CHAR_INFO
modifier|*
name|save_screen
decl_stmt|;
block|}
name|Properties
typedef|;
end_typedef

begin_define
define|#
directive|define
name|PropOf
parameter_list|(
name|TCB
parameter_list|)
value|((Properties*)TCB->prop)
end_define

begin_function
name|int
name|_nc_mingw_ioctl
parameter_list|(
name|int
name|fd
name|GCC_UNUSED
parameter_list|,
name|long
name|int
name|request
name|GCC_UNUSED
parameter_list|,
name|struct
name|termios
modifier|*
name|arg
name|GCC_UNUSED
parameter_list|)
block|{
return|return
literal|0
return|;
name|endwin
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"TERMINFO currently not supported on Windows.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|WORD
name|MapColor
parameter_list|(
name|bool
name|fore
parameter_list|,
name|int
name|color
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|_cmap
index|[]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|}
decl_stmt|;
name|int
name|a
decl_stmt|;
if|if
condition|(
name|color
operator|<
literal|0
operator|||
name|color
operator|>
literal|7
condition|)
name|a
operator|=
name|fore
condition|?
literal|7
else|:
literal|0
expr_stmt|;
else|else
name|a
operator|=
name|_cmap
index|[
name|color
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|fore
condition|)
name|a
operator|=
name|a
operator|<<
literal|4
expr_stmt|;
return|return
operator|(
name|WORD
operator|)
name|a
return|;
block|}
end_function

begin_function
specifier|static
name|WORD
name|MapAttr
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|WORD
name|res
parameter_list|,
name|attr_t
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|&
name|A_COLOR
condition|)
block|{
name|int
name|p
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
name|p
operator|=
name|PairNumber
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
literal|0
operator|&&
name|p
operator|<
name|NUMPAIRS
operator|&&
name|TCB
operator|!=
literal|0
operator|&&
name|sp
operator|!=
literal|0
condition|)
block|{
name|WORD
name|a
decl_stmt|;
name|a
operator|=
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|pairs
index|[
name|p
index|]
expr_stmt|;
name|res
operator|=
operator|(
name|res
operator|&
literal|0xff00
operator|)
operator||
name|a
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ch
operator|&
name|A_REVERSE
condition|)
name|res
operator|=
operator|(
operator|(
name|res
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
operator|(
name|res
operator|&
literal|0x07
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|res
operator|&
literal|0x70
operator|)
operator|>>
literal|4
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ch
operator|&
name|A_STANDOUT
condition|)
name|res
operator|=
operator|(
operator|(
name|res
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
operator|(
name|res
operator|&
literal|0x07
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|res
operator|&
literal|0x70
operator|)
operator|>>
literal|4
operator|)
operator|)
operator||
name|BACKGROUND_INTENSITY
operator|)
expr_stmt|;
if|if
condition|(
name|ch
operator|&
name|A_BOLD
condition|)
name|res
operator||=
name|FOREGROUND_INTENSITY
expr_stmt|;
if|if
condition|(
name|ch
operator|&
name|A_DIM
condition|)
name|res
operator||=
name|BACKGROUND_INTENSITY
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_if
if|#
directive|if
name|USE_WIDEC_SUPPORT
end_if

begin_comment
comment|/*  * TODO: support surrogate pairs  * TODO: support combining characters  * TODO: support acsc  * TODO: check wcwidth of base character, fill if needed for double-width  * TODO: _nc_wacs should be part of sp.  */
end_comment

begin_function
specifier|static
name|BOOL
name|con_write16
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|cchar_t
modifier|*
name|str
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|int
name|actual
init|=
literal|0
decl_stmt|;
name|CHAR_INFO
name|ci
index|[
name|limit
index|]
decl_stmt|;
name|COORD
name|loc
decl_stmt|,
name|siz
decl_stmt|;
name|SMALL_RECT
name|rec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cchar_t
name|ch
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|Properties
modifier|*
name|p
init|=
name|PropOf
argument_list|(
name|TCB
argument_list|)
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
name|actual
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|isWidecExt
argument_list|(
name|ch
argument_list|)
condition|)
continue|continue;
name|ci
index|[
name|actual
index|]
operator|.
name|Char
operator|.
name|UnicodeChar
operator|=
name|CharOf
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ci
index|[
name|actual
index|]
operator|.
name|Attributes
operator|=
name|MapAttr
argument_list|(
name|TCB
argument_list|,
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|SBI
operator|.
name|wAttributes
argument_list|,
name|AttrOf
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|AttrOf
argument_list|(
name|ch
argument_list|)
operator|&
name|A_ALTCHARSET
condition|)
block|{
if|if
condition|(
name|_nc_wacs
condition|)
block|{
name|int
name|which
init|=
name|CharOf
argument_list|(
name|ch
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
operator|>
literal|0
operator|&&
name|which
operator|<
name|ACS_LEN
operator|&&
name|CharOf
argument_list|(
name|_nc_wacs
index|[
name|which
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ci
index|[
name|actual
index|]
operator|.
name|Char
operator|.
name|UnicodeChar
operator|=
name|CharOf
argument_list|(
name|_nc_wacs
index|[
name|which
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ci
index|[
name|actual
index|]
operator|.
name|Char
operator|.
name|UnicodeChar
operator|=
literal|' '
expr_stmt|;
block|}
block|}
block|}
operator|++
name|actual
expr_stmt|;
block|}
name|loc
operator|.
name|X
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
name|loc
operator|.
name|Y
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
name|siz
operator|.
name|X
operator|=
operator|(
name|short
operator|)
name|actual
expr_stmt|;
name|siz
operator|.
name|Y
operator|=
literal|1
expr_stmt|;
name|rec
operator|.
name|Left
operator|=
operator|(
name|short
operator|)
name|x
expr_stmt|;
name|rec
operator|.
name|Top
operator|=
call|(
name|SHORT
call|)
argument_list|(
name|y
operator|+
name|AdjustY
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|rec
operator|.
name|Right
operator|=
call|(
name|short
call|)
argument_list|(
name|x
operator|+
name|limit
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rec
operator|.
name|Bottom
operator|=
name|rec
operator|.
name|Top
expr_stmt|;
return|return
name|WriteConsoleOutputW
argument_list|(
name|TCB
operator|->
name|hdl
argument_list|,
name|ci
argument_list|,
name|siz
argument_list|,
name|loc
argument_list|,
operator|&
name|rec
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|con_write
parameter_list|(
name|tcb
parameter_list|,
name|y
parameter_list|,
name|x
parameter_list|,
name|str
parameter_list|,
name|n
parameter_list|)
value|con_write16(tcb, y, x, str, n)
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|BOOL
name|con_write8
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|chtype
modifier|*
name|str
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|CHAR_INFO
name|ci
index|[
name|n
index|]
decl_stmt|;
name|COORD
name|loc
decl_stmt|,
name|siz
decl_stmt|;
name|SMALL_RECT
name|rec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|chtype
name|ch
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
name|ci
index|[
name|i
index|]
operator|.
name|Char
operator|.
name|AsciiChar
operator|=
name|ChCharOf
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|ci
index|[
name|i
index|]
operator|.
name|Attributes
operator|=
name|MapAttr
argument_list|(
name|TCB
argument_list|,
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|SBI
operator|.
name|wAttributes
argument_list|,
name|ChAttrOf
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ChAttrOf
argument_list|(
name|ch
argument_list|)
operator|&
name|A_ALTCHARSET
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|_acs_map
condition|)
name|ci
index|[
name|i
index|]
operator|.
name|Char
operator|.
name|AsciiChar
operator|=
name|ChCharOf
argument_list|(
name|NCURSES_SP_NAME
argument_list|(
name|_nc_acs_char
argument_list|)
argument_list|(
name|sp
argument_list|,
name|ChCharOf
argument_list|(
name|ch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|loc
operator|.
name|X
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
name|loc
operator|.
name|Y
operator|=
operator|(
name|short
operator|)
literal|0
expr_stmt|;
name|siz
operator|.
name|X
operator|=
operator|(
name|short
operator|)
name|n
expr_stmt|;
name|siz
operator|.
name|Y
operator|=
literal|1
expr_stmt|;
name|rec
operator|.
name|Left
operator|=
operator|(
name|short
operator|)
name|x
expr_stmt|;
name|rec
operator|.
name|Top
operator|=
operator|(
name|short
operator|)
name|y
expr_stmt|;
name|rec
operator|.
name|Right
operator|=
call|(
name|short
call|)
argument_list|(
name|x
operator|+
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
name|rec
operator|.
name|Bottom
operator|=
name|rec
operator|.
name|Top
expr_stmt|;
return|return
name|WriteConsoleOutput
argument_list|(
name|TCB
operator|->
name|hdl
argument_list|,
name|ci
argument_list|,
name|siz
argument_list|,
name|loc
argument_list|,
operator|&
name|rec
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|con_write
parameter_list|(
name|tcb
parameter_list|,
name|y
parameter_list|,
name|x
parameter_list|,
name|str
parameter_list|,
name|n
parameter_list|)
value|con_write8(tcb, y, x, str, n)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|EXP_OPTIMIZE
end_if

begin_comment
comment|/*  * Comparing new/current screens, determine the last column-index for a change  * beginning on the given row,col position.  Unlike a serial terminal, there is  * no cost for "moving" the "cursor" on the line as we update it.  */
end_comment

begin_function
specifier|static
name|int
name|find_end_of_change
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|int
name|result
init|=
name|col
decl_stmt|;
name|struct
name|ldat
modifier|*
name|curdat
init|=
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
operator|+
name|row
decl_stmt|;
name|struct
name|ldat
modifier|*
name|newdat
init|=
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
operator|+
name|row
decl_stmt|;
while|while
condition|(
name|col
operator|<=
name|newdat
operator|->
name|lastchar
condition|)
block|{
if|#
directive|if
name|USE_WIDEC_SUPPORT
if|if
condition|(
name|isWidecExt
argument_list|(
name|curdat
operator|->
name|text
index|[
name|col
index|]
argument_list|)
operator|||
name|isWidecExt
argument_list|(
name|newdat
operator|->
name|text
index|[
name|col
index|]
argument_list|)
condition|)
block|{
name|result
operator|=
name|col
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|curdat
operator|->
name|text
index|[
name|col
index|]
argument_list|,
operator|&
name|newdat
operator|->
name|text
index|[
name|col
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|curdat
operator|->
name|text
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|=
name|col
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
else|#
directive|else
if|if
condition|(
name|curdat
operator|->
name|text
index|[
name|col
index|]
operator|!=
name|newdat
operator|->
name|text
index|[
name|col
index|]
condition|)
block|{
name|result
operator|=
name|col
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
endif|#
directive|endif
operator|++
name|col
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Given a row,col position at the end of a change-chunk, look for the  * beginning of the next change-chunk.  */
end_comment

begin_function
specifier|static
name|int
name|find_next_change
parameter_list|(
name|SCREEN
modifier|*
name|sp
parameter_list|,
name|int
name|row
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|struct
name|ldat
modifier|*
name|curdat
init|=
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
operator|+
name|row
decl_stmt|;
name|struct
name|ldat
modifier|*
name|newdat
init|=
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
operator|+
name|row
decl_stmt|;
name|int
name|result
init|=
name|newdat
operator|->
name|lastchar
operator|+
literal|1
decl_stmt|;
while|while
condition|(
operator|++
name|col
operator|<=
name|newdat
operator|->
name|lastchar
condition|)
block|{
if|#
directive|if
name|USE_WIDEC_SUPPORT
if|if
condition|(
name|isWidecExt
argument_list|(
name|curdat
operator|->
name|text
index|[
name|col
index|]
argument_list|)
operator|!=
name|isWidecExt
argument_list|(
name|newdat
operator|->
name|text
index|[
name|col
index|]
argument_list|)
condition|)
block|{
name|result
operator|=
name|col
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|curdat
operator|->
name|text
index|[
name|col
index|]
argument_list|,
operator|&
name|newdat
operator|->
name|text
index|[
name|col
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|curdat
operator|->
name|text
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|=
name|col
expr_stmt|;
break|break;
block|}
else|#
directive|else
if|if
condition|(
name|curdat
operator|->
name|text
index|[
name|col
index|]
operator|!=
name|newdat
operator|->
name|text
index|[
name|col
index|]
condition|)
block|{
name|result
operator|=
name|col
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|EndChange
parameter_list|(
name|first
parameter_list|)
define|\
value|find_end_of_change(sp, y, first)
end_define

begin_define
define|#
directive|define
name|NextChange
parameter_list|(
name|last
parameter_list|)
define|\
value|find_next_change(sp, y, last)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EXP_OPTIMIZE */
end_comment

begin_define
define|#
directive|define
name|MARK_NOCHANGE
parameter_list|(
name|win
parameter_list|,
name|row
parameter_list|)
define|\
value|win->_line[row].firstchar = _NOCHANGE; \ 		win->_line[row].lastchar  = _NOCHANGE
end_define

begin_function
specifier|static
name|void
name|selectActiveHandle
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
if|if
condition|(
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|lastOut
operator|!=
name|TCB
operator|->
name|hdl
condition|)
block|{
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|lastOut
operator|=
name|TCB
operator|->
name|hdl
expr_stmt|;
name|SetConsoleActiveScreenBuffer
argument_list|(
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|lastOut
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|drv_doupdate
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|int
name|result
init|=
name|ERR
decl_stmt|;
name|int
name|y
decl_stmt|,
name|nonempty
decl_stmt|,
name|n
decl_stmt|,
name|x0
decl_stmt|,
name|x1
decl_stmt|,
name|Width
decl_stmt|,
name|Height
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"win32con::drv_doupdate(%p)"
argument_list|)
operator|,
name|TCB
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|okConsoleHandle
argument_list|(
name|TCB
argument_list|)
condition|)
block|{
name|Width
operator|=
name|screen_columns
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|Height
operator|=
name|screen_lines
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|nonempty
operator|=
name|min
argument_list|(
name|Height
argument_list|,
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_maxy
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_clear
operator|||
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_clear
operator|)
condition|)
block|{
name|int
name|x
decl_stmt|;
if|#
directive|if
name|USE_WIDEC_SUPPORT
name|cchar_t
name|empty
index|[
name|Width
index|]
decl_stmt|;
name|wchar_t
name|blank
index|[
literal|2
index|]
init|=
block|{
literal|L'
expr|'
block|,
literal|L'
expr|\0'
block|}
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|Width
condition|;
name|x
operator|++
control|)
name|setcchar
argument_list|(
operator|&
name|empty
index|[
name|x
index|]
argument_list|,
name|blank
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|chtype
name|empty
index|[
name|Width
index|]
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|Width
condition|;
name|x
operator|++
control|)
name|empty
index|[
name|x
index|]
operator|=
literal|' '
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|nonempty
condition|;
name|y
operator|++
control|)
block|{
name|con_write
argument_list|(
name|TCB
argument_list|,
name|y
argument_list|,
literal|0
argument_list|,
name|empty
argument_list|,
name|Width
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|empty
argument_list|,
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
argument_list|,
operator|(
name|size_t
operator|)
name|Width
operator|*
sizeof|sizeof
argument_list|(
name|empty
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_clear
operator|=
name|FALSE
expr_stmt|;
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_clear
operator|=
name|FALSE
expr_stmt|;
name|touchwin
argument_list|(
name|NewScreen
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|nonempty
condition|;
name|y
operator|++
control|)
block|{
name|x0
operator|=
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|firstchar
expr_stmt|;
if|if
condition|(
name|x0
operator|!=
name|_NOCHANGE
condition|)
block|{
if|#
directive|if
name|EXP_OPTIMIZE
name|int
name|x2
decl_stmt|;
name|int
name|limit
init|=
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|lastchar
decl_stmt|;
while|while
condition|(
operator|(
name|x1
operator|=
name|EndChange
argument_list|(
name|x0
argument_list|)
operator|)
operator|<=
name|limit
condition|)
block|{
while|while
condition|(
operator|(
name|x2
operator|=
name|NextChange
argument_list|(
name|x1
argument_list|)
operator|)
operator|<=
name|limit
operator|&&
name|x2
operator|<=
operator|(
name|x1
operator|+
literal|2
operator|)
condition|)
block|{
name|x1
operator|=
name|x2
expr_stmt|;
block|}
name|n
operator|=
name|x1
operator|-
name|x0
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x0
index|]
argument_list|,
operator|&
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x0
index|]
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|con_write
argument_list|(
name|TCB
argument_list|,
name|y
argument_list|,
name|x0
argument_list|,
operator|&
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x0
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|x0
operator|=
name|NextChange
argument_list|(
name|x1
argument_list|)
expr_stmt|;
block|}
comment|/* mark line changed successfully */
if|if
condition|(
name|y
operator|<=
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_maxy
condition|)
block|{
name|MARK_NOCHANGE
argument_list|(
name|NewScreen
argument_list|(
name|sp
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<=
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_maxy
condition|)
block|{
name|MARK_NOCHANGE
argument_list|(
name|CurScreen
argument_list|(
name|sp
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|x1
operator|=
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|lastchar
expr_stmt|;
name|n
operator|=
name|x1
operator|-
name|x0
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x0
index|]
argument_list|,
operator|&
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x0
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|n
operator|*
sizeof|sizeof
argument_list|(
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|con_write
argument_list|(
name|TCB
argument_list|,
name|y
argument_list|,
name|x0
argument_list|,
operator|&
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_line
index|[
name|y
index|]
operator|.
name|text
index|[
name|x0
index|]
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* mark line changed successfully */
if|if
condition|(
name|y
operator|<=
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_maxy
condition|)
block|{
name|MARK_NOCHANGE
argument_list|(
name|NewScreen
argument_list|(
name|sp
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<=
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_maxy
condition|)
block|{
name|MARK_NOCHANGE
argument_list|(
name|CurScreen
argument_list|(
name|sp
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
block|}
comment|/* put everything back in sync */
for|for
control|(
name|y
operator|=
name|nonempty
init|;
name|y
operator|<=
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_maxy
condition|;
name|y
operator|++
control|)
block|{
name|MARK_NOCHANGE
argument_list|(
name|NewScreen
argument_list|(
name|sp
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|y
operator|=
name|nonempty
init|;
name|y
operator|<=
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_maxy
condition|;
name|y
operator|++
control|)
block|{
name|MARK_NOCHANGE
argument_list|(
name|CurScreen
argument_list|(
name|sp
argument_list|)
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_leaveok
condition|)
block|{
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_curx
operator|=
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_curx
expr_stmt|;
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_cury
operator|=
name|NewScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_cury
expr_stmt|;
name|TCB
operator|->
name|drv
operator|->
name|hwcur
argument_list|(
name|TCB
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_cury
argument_list|,
name|CurScreen
argument_list|(
name|sp
argument_list|)
operator|->
name|_curx
argument_list|)
expr_stmt|;
block|}
name|selectActiveHandle
argument_list|(
name|TCB
argument_list|)
expr_stmt|;
name|result
operator|=
name|OK
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drv_CanHandle
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
specifier|const
name|char
modifier|*
name|tname
parameter_list|,
name|int
modifier|*
name|errret
name|GCC_UNUSED
parameter_list|)
block|{
name|bool
name|code
init|=
name|FALSE
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"win32con::drv_CanHandle(%p)"
argument_list|)
operator|,
name|TCB
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|TCB
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tname
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|TCB
operator|->
name|magic
operator|=
name|WINMAGIC
expr_stmt|;
if|if
condition|(
operator|*
name|tname
operator|==
literal|0
operator|||
operator|*
name|tname
operator|==
literal|0
operator|||
operator|*
name|tname
operator|==
literal|'#'
condition|)
block|{
name|code
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|TERMINAL
name|my_term
decl_stmt|;
name|int
name|status
decl_stmt|;
name|code
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
operator|(
name|NCURSES_USE_DATABASE
operator|||
name|NCURSES_USE_TERMCAP
operator|)
name|status
operator|=
name|_nc_setup_tinfo
argument_list|(
name|tname
argument_list|,
operator|&
name|my_term
operator|.
name|type
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|TGETENT_NO
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|!=
name|TGETENT_YES
condition|)
block|{
specifier|const
name|TERMTYPE
modifier|*
name|fallback
init|=
name|_nc_fallback
argument_list|(
name|tname
argument_list|)
decl_stmt|;
if|if
condition|(
name|fallback
condition|)
block|{
name|my_term
operator|.
name|type
operator|=
operator|*
name|fallback
expr_stmt|;
name|status
operator|=
name|TGETENT_YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|tname
argument_list|,
literal|"unknown"
argument_list|)
condition|)
block|{
name|code
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
operator|==
name|TGETENT_YES
condition|)
block|{
if|if
condition|(
name|generic_type
operator|||
name|hard_copy
condition|)
name|code
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|code
condition|)
block|{
if|if
condition|(
operator|(
name|TCB
operator|->
name|term
operator|.
name|type
operator|.
name|Booleans
operator|)
operator|==
literal|0
condition|)
block|{
name|_nc_init_termtype
argument_list|(
operator|&
operator|(
name|TCB
operator|->
name|term
operator|.
name|type
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|returnBool
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_dobeepflash
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|beepFlag
name|GCC_UNUSED
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|int
name|res
init|=
name|ERR
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_print
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|char
modifier|*
name|data
name|GCC_UNUSED
parameter_list|,
name|int
name|len
name|GCC_UNUSED
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_defaultcolors
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|fg
name|GCC_UNUSED
parameter_list|,
name|int
name|bg
name|GCC_UNUSED
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|get_SBI
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|bool
name|rc
init|=
name|FALSE
decl_stmt|;
name|Properties
modifier|*
name|p
init|=
name|PropOf
argument_list|(
name|TCB
argument_list|)
decl_stmt|;
if|if
condition|(
name|GetConsoleScreenBufferInfo
argument_list|(
name|TCB
operator|->
name|hdl
argument_list|,
operator|&
operator|(
name|p
operator|->
name|SBI
operator|)
argument_list|)
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"GetConsoleScreenBufferInfo"
operator|)
argument_list|)
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"... buffer(X:%d Y:%d)"
operator|,
name|p
operator|->
name|SBI
operator|.
name|dwSize
operator|.
name|X
operator|,
name|p
operator|->
name|SBI
operator|.
name|dwSize
operator|.
name|Y
operator|)
argument_list|)
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"... window(X:%d Y:%d)"
operator|,
name|p
operator|->
name|SBI
operator|.
name|dwMaximumWindowSize
operator|.
name|X
operator|,
name|p
operator|->
name|SBI
operator|.
name|dwMaximumWindowSize
operator|.
name|Y
operator|)
argument_list|)
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"... cursor(X:%d Y:%d)"
operator|,
name|p
operator|->
name|SBI
operator|.
name|dwCursorPosition
operator|.
name|X
operator|,
name|p
operator|->
name|SBI
operator|.
name|dwCursorPosition
operator|.
name|Y
operator|)
argument_list|)
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"... display(Top:%d Bottom:%d Left:%d Right:%d)"
operator|,
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Top
operator|,
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Bottom
operator|,
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Left
operator|,
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Right
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|buffered
condition|)
block|{
name|p
operator|->
name|origin
operator|.
name|X
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|origin
operator|.
name|Y
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|origin
operator|.
name|X
operator|=
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Left
expr_stmt|;
name|p
operator|->
name|origin
operator|.
name|Y
operator|=
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Top
expr_stmt|;
block|}
name|rc
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|T
argument_list|(
operator|(
literal|"GetConsoleScreenBufferInfo ERR"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|drv_setcolor
argument_list|(
name|TERMINAL_CONTROL_BLOCK
operator|*
name|TCB
argument_list|,
name|int
name|fore
argument_list|,
name|int
name|color
argument_list|,
name|int
argument_list|(
argument|*outc
argument_list|)
operator|(
name|SCREEN
operator|*
operator|,
name|int
operator|)
name|GCC_UNUSED
argument_list|)
block|{
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|okConsoleHandle
argument_list|(
name|TCB
argument_list|)
operator|&&
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|WORD
name|a
init|=
name|MapColor
argument_list|(
name|fore
argument_list|,
name|color
argument_list|)
decl_stmt|;
name|a
operator||=
call|(
name|WORD
call|)
argument_list|(
operator|(
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|SBI
operator|.
name|wAttributes
operator|)
operator|&
operator|(
name|fore
condition|?
literal|0xfff8
else|:
literal|0xff8f
operator|)
argument_list|)
expr_stmt|;
name|SetConsoleTextAttribute
argument_list|(
name|TCB
operator|->
name|hdl
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|get_SBI
argument_list|(
name|TCB
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_function
specifier|static
name|bool
name|drv_rescol
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|bool
name|res
init|=
name|FALSE
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|okConsoleHandle
argument_list|(
name|TCB
argument_list|)
condition|)
block|{
name|WORD
name|a
init|=
name|FOREGROUND_BLUE
operator||
name|FOREGROUND_RED
operator||
name|FOREGROUND_GREEN
decl_stmt|;
name|SetConsoleTextAttribute
argument_list|(
name|TCB
operator|->
name|hdl
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|get_SBI
argument_list|(
name|TCB
argument_list|)
expr_stmt|;
name|res
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drv_rescolors
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|int
name|result
init|=
name|FALSE
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_size
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
modifier|*
name|Lines
parameter_list|,
name|int
modifier|*
name|Cols
parameter_list|)
block|{
name|int
name|result
init|=
name|ERR
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"win32con::drv_size(%p)"
argument_list|)
operator|,
name|TCB
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|okConsoleHandle
argument_list|(
name|TCB
argument_list|)
operator|&&
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|!=
literal|0
operator|&&
name|Lines
operator|!=
name|NULL
operator|&&
name|Cols
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|buffered
condition|)
block|{
operator|*
name|Lines
operator|=
call|(
name|int
call|)
argument_list|(
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|SBI
operator|.
name|dwSize
operator|.
name|Y
argument_list|)
expr_stmt|;
operator|*
name|Cols
operator|=
call|(
name|int
call|)
argument_list|(
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|SBI
operator|.
name|dwSize
operator|.
name|X
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|Lines
operator|=
call|(
name|int
call|)
argument_list|(
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Bottom
operator|+
literal|1
operator|-
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Top
argument_list|)
expr_stmt|;
operator|*
name|Cols
operator|=
call|(
name|int
call|)
argument_list|(
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Right
operator|+
literal|1
operator|-
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Left
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|OK
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_setsize
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
name|GCC_UNUSED
parameter_list|,
name|int
name|l
name|GCC_UNUSED
parameter_list|,
name|int
name|c
name|GCC_UNUSED
parameter_list|)
block|{
name|AssertTCB
argument_list|()
expr_stmt|;
return|return
name|ERR
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_sgmode
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|setFlag
parameter_list|,
name|TTY
modifier|*
name|buf
parameter_list|)
block|{
name|DWORD
name|dwFlag
init|=
literal|0
decl_stmt|;
name|tcflag_t
name|iflag
decl_stmt|;
name|tcflag_t
name|lflag
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|TCB
operator|==
literal|0
operator|||
name|buf
operator|==
name|NULL
condition|)
return|return
name|ERR
return|;
if|if
condition|(
name|setFlag
condition|)
block|{
name|iflag
operator|=
name|buf
operator|->
name|c_iflag
expr_stmt|;
name|lflag
operator|=
name|buf
operator|->
name|c_lflag
expr_stmt|;
name|GetConsoleMode
argument_list|(
name|TCB
operator|->
name|inp
argument_list|,
operator|&
name|dwFlag
argument_list|)
expr_stmt|;
if|if
condition|(
name|lflag
operator|&
name|ICANON
condition|)
name|dwFlag
operator||=
name|ENABLE_LINE_INPUT
expr_stmt|;
else|else
name|dwFlag
operator|&=
call|(
name|DWORD
call|)
argument_list|(
operator|~
name|ENABLE_LINE_INPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|lflag
operator|&
name|ECHO
condition|)
name|dwFlag
operator||=
name|ENABLE_ECHO_INPUT
expr_stmt|;
else|else
name|dwFlag
operator|&=
call|(
name|DWORD
call|)
argument_list|(
operator|~
name|ENABLE_ECHO_INPUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|BRKINT
condition|)
name|dwFlag
operator||=
name|ENABLE_PROCESSED_INPUT
expr_stmt|;
else|else
name|dwFlag
operator|&=
call|(
name|DWORD
call|)
argument_list|(
operator|~
name|ENABLE_PROCESSED_INPUT
argument_list|)
expr_stmt|;
name|dwFlag
operator||=
name|ENABLE_MOUSE_INPUT
expr_stmt|;
name|buf
operator|->
name|c_iflag
operator|=
name|iflag
expr_stmt|;
name|buf
operator|->
name|c_lflag
operator|=
name|lflag
expr_stmt|;
name|SetConsoleMode
argument_list|(
name|TCB
operator|->
name|inp
argument_list|,
name|dwFlag
argument_list|)
expr_stmt|;
name|TCB
operator|->
name|term
operator|.
name|Nttyb
operator|=
operator|*
name|buf
expr_stmt|;
block|}
else|else
block|{
name|iflag
operator|=
name|TCB
operator|->
name|term
operator|.
name|Nttyb
operator|.
name|c_iflag
expr_stmt|;
name|lflag
operator|=
name|TCB
operator|->
name|term
operator|.
name|Nttyb
operator|.
name|c_lflag
expr_stmt|;
name|GetConsoleMode
argument_list|(
name|TCB
operator|->
name|inp
argument_list|,
operator|&
name|dwFlag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwFlag
operator|&
name|ENABLE_LINE_INPUT
condition|)
name|lflag
operator||=
name|ICANON
expr_stmt|;
else|else
name|lflag
operator|&=
call|(
name|tcflag_t
call|)
argument_list|(
operator|~
name|ICANON
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwFlag
operator|&
name|ENABLE_ECHO_INPUT
condition|)
name|lflag
operator||=
name|ECHO
expr_stmt|;
else|else
name|lflag
operator|&=
call|(
name|tcflag_t
call|)
argument_list|(
operator|~
name|ECHO
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwFlag
operator|&
name|ENABLE_PROCESSED_INPUT
condition|)
name|iflag
operator||=
name|BRKINT
expr_stmt|;
else|else
name|iflag
operator|&=
call|(
name|tcflag_t
call|)
argument_list|(
operator|~
name|BRKINT
argument_list|)
expr_stmt|;
name|TCB
operator|->
name|term
operator|.
name|Nttyb
operator|.
name|c_iflag
operator|=
name|iflag
expr_stmt|;
name|TCB
operator|->
name|term
operator|.
name|Nttyb
operator|.
name|c_lflag
operator|=
name|lflag
expr_stmt|;
operator|*
name|buf
operator|=
name|TCB
operator|->
name|term
operator|.
name|Nttyb
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_mode
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|progFlag
parameter_list|,
name|int
name|defFlag
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|TERMINAL
modifier|*
name|_term
init|=
operator|(
name|TERMINAL
operator|*
operator|)
name|TCB
decl_stmt|;
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|sp
operator|=
name|TCB
operator|->
name|csp
expr_stmt|;
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|progMode
operator|=
name|progFlag
expr_stmt|;
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|lastOut
operator|=
name|progFlag
condition|?
name|TCB
operator|->
name|hdl
else|:
name|TCB
operator|->
name|out
expr_stmt|;
name|SetConsoleActiveScreenBuffer
argument_list|(
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|lastOut
argument_list|)
expr_stmt|;
if|if
condition|(
name|progFlag
condition|)
comment|/* prog mode */
block|{
if|if
condition|(
name|defFlag
condition|)
block|{
if|if
condition|(
operator|(
name|drv_sgmode
argument_list|(
name|TCB
argument_list|,
name|FALSE
argument_list|,
operator|&
operator|(
name|_term
operator|->
name|Nttyb
operator|)
argument_list|)
operator|==
name|OK
operator|)
condition|)
block|{
name|_term
operator|->
name|Nttyb
operator|.
name|c_oflag
operator|&=
call|(
name|tcflag_t
call|)
argument_list|(
operator|~
name|OFLAGS_TABS
argument_list|)
expr_stmt|;
name|code
operator|=
name|OK
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* reset_prog_mode */
if|if
condition|(
name|drv_sgmode
argument_list|(
name|TCB
argument_list|,
name|TRUE
argument_list|,
operator|&
operator|(
name|_term
operator|->
name|Nttyb
operator|)
argument_list|)
operator|==
name|OK
condition|)
block|{
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|_keypad_on
condition|)
name|_nc_keypad
argument_list|(
name|sp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|NC_BUFFERED
argument_list|(
name|sp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|OK
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* shell mode */
if|if
condition|(
name|defFlag
condition|)
block|{
comment|/* def_shell_mode */
if|if
condition|(
name|drv_sgmode
argument_list|(
name|TCB
argument_list|,
name|FALSE
argument_list|,
operator|&
operator|(
name|_term
operator|->
name|Ottyb
operator|)
argument_list|)
operator|==
name|OK
condition|)
block|{
name|code
operator|=
name|OK
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* reset_shell_mode */
if|if
condition|(
name|sp
condition|)
block|{
name|_nc_keypad
argument_list|(
name|sp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|NCURSES_SP_NAME
function_decl|(
name|_nc_flush
function_decl|)
parameter_list|(
name|sp
parameter_list|)
function_decl|;
name|NC_BUFFERED
argument_list|(
name|sp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
name|drv_sgmode
argument_list|(
name|TCB
argument_list|,
name|TRUE
argument_list|,
operator|&
operator|(
name|_term
operator|->
name|Ottyb
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_screen_init
parameter_list|(
name|SCREEN
modifier|*
name|sp
name|GCC_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|drv_wrap
parameter_list|(
name|SCREEN
modifier|*
name|sp
name|GCC_UNUSED
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|rkeycompare
parameter_list|(
specifier|const
name|void
modifier|*
name|el1
parameter_list|,
specifier|const
name|void
modifier|*
name|el2
parameter_list|)
block|{
name|WORD
name|key1
init|=
operator|(
name|LOWORD
argument_list|(
operator|(
operator|*
operator|(
operator|(
specifier|const
name|LONG
operator|*
operator|)
name|el1
operator|)
operator|)
argument_list|)
operator|)
operator|&
literal|0x7fff
decl_stmt|;
name|WORD
name|key2
init|=
operator|(
name|LOWORD
argument_list|(
operator|(
operator|*
operator|(
operator|(
specifier|const
name|LONG
operator|*
operator|)
name|el2
operator|)
operator|)
argument_list|)
operator|)
operator|&
literal|0x7fff
decl_stmt|;
return|return
operator|(
operator|(
name|key1
operator|<
name|key2
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|key1
operator|==
name|key2
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|keycompare
parameter_list|(
specifier|const
name|void
modifier|*
name|el1
parameter_list|,
specifier|const
name|void
modifier|*
name|el2
parameter_list|)
block|{
name|WORD
name|key1
init|=
name|HIWORD
argument_list|(
operator|(
operator|*
operator|(
operator|(
specifier|const
name|LONG
operator|*
operator|)
name|el1
operator|)
operator|)
argument_list|)
decl_stmt|;
name|WORD
name|key2
init|=
name|HIWORD
argument_list|(
operator|(
operator|*
operator|(
operator|(
specifier|const
name|LONG
operator|*
operator|)
name|el2
operator|)
operator|)
argument_list|)
decl_stmt|;
return|return
operator|(
operator|(
name|key1
operator|<
name|key2
operator|)
condition|?
operator|-
literal|1
else|:
operator|(
operator|(
name|key1
operator|==
name|key2
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|MapKey
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|WORD
name|vKey
parameter_list|)
block|{
name|WORD
name|nKey
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|res
decl_stmt|;
name|LONG
name|key
init|=
name|GenMap
argument_list|(
name|vKey
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|code
init|=
operator|-
literal|1
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|res
operator|=
name|bsearch
argument_list|(
operator|&
name|key
argument_list|,
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|map
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|N_INI
operator|+
name|FKEYS
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|keycompare
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|key
operator|=
operator|*
operator|(
operator|(
name|LONG
operator|*
operator|)
name|res
operator|)
expr_stmt|;
name|nKey
operator|=
name|LOWORD
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|code
operator|=
call|(
name|int
call|)
argument_list|(
name|nKey
operator|&
literal|0x7fff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nKey
operator|&
literal|0x8000
condition|)
name|code
operator|=
operator|-
name|code
expr_stmt|;
block|}
return|return
name|code
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_release
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"win32con::drv_release(%p)"
argument_list|)
operator|,
name|TCB
operator|)
argument_list|)
expr_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|TCB
operator|->
name|prop
condition|)
name|free
argument_list|(
name|TCB
operator|->
name|prop
argument_list|)
expr_stmt|;
name|returnVoid
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt to save the screen contents.  PDCurses does this if  * PDC_RESTORE_SCREEN is set, giving the same visual appearance on restoration  * as if the library had allocated a console buffer.  */
end_comment

begin_function
specifier|static
name|bool
name|save_original_screen
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
name|Properties
modifier|*
name|p
init|=
name|PropOf
argument_list|(
name|TCB
argument_list|)
decl_stmt|;
name|COORD
name|bufferSize
decl_stmt|;
name|COORD
name|bufferCoord
decl_stmt|;
name|SMALL_RECT
name|readRegion
decl_stmt|;
name|size_t
name|want
decl_stmt|;
name|bufferSize
operator|.
name|X
operator|=
name|p
operator|->
name|SBI
operator|.
name|dwSize
operator|.
name|X
expr_stmt|;
name|bufferSize
operator|.
name|Y
operator|=
name|p
operator|->
name|SBI
operator|.
name|dwSize
operator|.
name|Y
expr_stmt|;
name|want
operator|=
call|(
name|size_t
call|)
argument_list|(
name|bufferSize
operator|.
name|X
operator|*
name|bufferSize
operator|.
name|Y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|save_screen
operator|=
name|malloc
argument_list|(
name|want
operator|*
sizeof|sizeof
argument_list|(
name|CHAR_INFO
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bufferCoord
operator|.
name|X
operator|=
name|bufferCoord
operator|.
name|Y
operator|=
literal|0
expr_stmt|;
name|readRegion
operator|.
name|Top
operator|=
literal|0
expr_stmt|;
name|readRegion
operator|.
name|Left
operator|=
literal|0
expr_stmt|;
name|readRegion
operator|.
name|Bottom
operator|=
call|(
name|SHORT
call|)
argument_list|(
name|bufferSize
operator|.
name|Y
operator|-
literal|1
argument_list|)
expr_stmt|;
name|readRegion
operator|.
name|Right
operator|=
call|(
name|SHORT
call|)
argument_list|(
name|bufferSize
operator|.
name|X
operator|-
literal|1
argument_list|)
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"... reading console buffer %dx%d into %d,%d - %d,%d at %d,%d"
operator|,
name|bufferSize
operator|.
name|Y
operator|,
name|bufferSize
operator|.
name|X
operator|,
name|readRegion
operator|.
name|Top
operator|,
name|readRegion
operator|.
name|Left
operator|,
name|readRegion
operator|.
name|Bottom
operator|,
name|readRegion
operator|.
name|Right
operator|,
name|bufferCoord
operator|.
name|Y
operator|,
name|bufferCoord
operator|.
name|X
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ReadConsoleOutput
argument_list|(
name|TCB
operator|->
name|hdl
argument_list|,
name|p
operator|->
name|save_screen
argument_list|,
name|bufferSize
argument_list|,
name|bufferCoord
argument_list|,
operator|&
name|readRegion
argument_list|)
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|T
argument_list|(
operator|(
literal|" error %#lx"
operator|,
operator|(
name|unsigned
name|long
operator|)
name|GetLastError
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|FreeAndNull
argument_list|(
name|p
operator|->
name|save_screen
argument_list|)
expr_stmt|;
name|bufferSize
operator|.
name|X
operator|=
call|(
name|SHORT
call|)
argument_list|(
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Right
operator|-
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Left
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bufferSize
operator|.
name|Y
operator|=
call|(
name|SHORT
call|)
argument_list|(
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Bottom
operator|-
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Top
operator|+
literal|1
argument_list|)
expr_stmt|;
name|want
operator|=
call|(
name|size_t
call|)
argument_list|(
name|bufferSize
operator|.
name|X
operator|*
name|bufferSize
operator|.
name|Y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|save_screen
operator|=
name|malloc
argument_list|(
name|want
operator|*
sizeof|sizeof
argument_list|(
name|CHAR_INFO
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bufferCoord
operator|.
name|X
operator|=
name|bufferCoord
operator|.
name|Y
operator|=
literal|0
expr_stmt|;
name|readRegion
operator|.
name|Top
operator|=
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Top
expr_stmt|;
name|readRegion
operator|.
name|Left
operator|=
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Left
expr_stmt|;
name|readRegion
operator|.
name|Bottom
operator|=
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Bottom
expr_stmt|;
name|readRegion
operator|.
name|Right
operator|=
name|p
operator|->
name|SBI
operator|.
name|srWindow
operator|.
name|Right
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"... reading console window %dx%d into %d,%d - %d,%d at %d,%d"
operator|,
name|bufferSize
operator|.
name|Y
operator|,
name|bufferSize
operator|.
name|X
operator|,
name|readRegion
operator|.
name|Top
operator|,
name|readRegion
operator|.
name|Left
operator|,
name|readRegion
operator|.
name|Bottom
operator|,
name|readRegion
operator|.
name|Right
operator|,
name|bufferCoord
operator|.
name|Y
operator|,
name|bufferCoord
operator|.
name|X
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ReadConsoleOutput
argument_list|(
name|TCB
operator|->
name|hdl
argument_list|,
name|p
operator|->
name|save_screen
argument_list|,
name|bufferSize
argument_list|,
name|bufferCoord
argument_list|,
operator|&
name|readRegion
argument_list|)
condition|)
block|{
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|T
argument_list|(
operator|(
literal|" error %#lx"
operator|,
operator|(
name|unsigned
name|long
operator|)
name|GetLastError
argument_list|()
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|T
argument_list|(
operator|(
literal|"... save original screen contents %s"
operator|,
name|result
condition|?
literal|"ok"
else|:
literal|"err"
operator|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_init
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|DWORD
name|num_buttons
decl_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"win32con::drv_init(%p)"
argument_list|)
operator|,
name|TCB
operator|)
argument_list|)
expr_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
if|if
condition|(
name|TCB
condition|)
block|{
name|BOOL
name|b
init|=
name|AllocConsole
argument_list|()
decl_stmt|;
name|WORD
name|a
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|buffered
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|b
operator|=
name|AttachConsole
argument_list|(
name|ATTACH_PARENT_PROCESS
argument_list|)
expr_stmt|;
name|TCB
operator|->
name|inp
operator|=
name|GetStdHandle
argument_list|(
name|STD_INPUT_HANDLE
argument_list|)
expr_stmt|;
name|TCB
operator|->
name|out
operator|=
name|GetStdHandle
argument_list|(
name|STD_OUTPUT_HANDLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"NCGDB"
argument_list|)
condition|)
block|{
name|TCB
operator|->
name|hdl
operator|=
name|TCB
operator|->
name|out
expr_stmt|;
name|buffered
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|TCB
operator|->
name|hdl
operator|=
name|CreateConsoleScreenBuffer
argument_list|(
name|GENERIC_READ
operator||
name|GENERIC_WRITE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|CONSOLE_TEXTMODE_BUFFER
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|InvalidConsoleHandle
argument_list|(
name|TCB
operator|->
name|hdl
argument_list|)
condition|)
block|{
name|returnVoid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|TCB
operator|->
name|prop
operator|=
name|typeCalloc
argument_list|(
name|Properties
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|buffered
operator|=
name|buffered
expr_stmt|;
if|if
condition|(
operator|!
name|get_SBI
argument_list|(
name|TCB
argument_list|)
condition|)
block|{
name|FreeAndNull
argument_list|(
name|TCB
operator|->
name|prop
argument_list|)
expr_stmt|;
comment|/* force error in drv_size */
name|returnVoid
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|buffered
condition|)
block|{
if|if
condition|(
operator|!
name|save_original_screen
argument_list|(
name|TCB
argument_list|)
condition|)
block|{
name|FreeAndNull
argument_list|(
name|TCB
operator|->
name|prop
argument_list|)
expr_stmt|;
comment|/* force error in drv_size */
name|returnVoid
expr_stmt|;
block|}
block|}
block|}
name|TCB
operator|->
name|info
operator|.
name|initcolor
operator|=
name|TRUE
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|canchange
operator|=
name|FALSE
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|hascolor
operator|=
name|TRUE
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|caninit
operator|=
name|TRUE
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|maxpairs
operator|=
name|NUMPAIRS
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|maxcolors
operator|=
literal|8
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|numlabels
operator|=
literal|0
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|labelwidth
operator|=
literal|0
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|labelheight
operator|=
literal|0
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|nocolorvideo
operator|=
literal|1
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|tabsize
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|GetNumberOfConsoleMouseButtons
argument_list|(
operator|&
name|num_buttons
argument_list|)
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"mouse has %ld buttons"
operator|,
name|num_buttons
operator|)
argument_list|)
expr_stmt|;
name|TCB
operator|->
name|info
operator|.
name|numbuttons
operator|=
operator|(
name|int
operator|)
name|num_buttons
expr_stmt|;
block|}
else|else
block|{
name|TCB
operator|->
name|info
operator|.
name|numbuttons
operator|=
literal|1
expr_stmt|;
block|}
name|TCB
operator|->
name|info
operator|.
name|defaultPalette
operator|=
name|_nc_cga_palette
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|N_INI
operator|+
name|FKEYS
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|N_INI
condition|)
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|rmap
index|[
name|i
index|]
operator|=
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|map
index|[
name|i
index|]
operator|=
operator|(
name|DWORD
operator|)
name|keylist
index|[
name|i
index|]
expr_stmt|;
else|else
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|rmap
index|[
name|i
index|]
operator|=
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|map
index|[
name|i
index|]
operator|=
name|GenMap
argument_list|(
operator|(
name|VK_F1
operator|+
operator|(
name|i
operator|-
name|N_INI
operator|)
operator|)
argument_list|,
operator|(
name|KEY_F
argument_list|(
literal|1
argument_list|)
operator|+
operator|(
name|i
operator|-
name|N_INI
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|qsort
argument_list|(
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|map
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|MAPSIZE
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|keycompare
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|rmap
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|MAPSIZE
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|rkeycompare
argument_list|)
expr_stmt|;
name|a
operator|=
name|MapColor
argument_list|(
name|true
argument_list|,
name|COLOR_WHITE
argument_list|)
operator||
name|MapColor
argument_list|(
name|false
argument_list|,
name|COLOR_BLACK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMPAIRS
condition|;
name|i
operator|++
control|)
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|pairs
index|[
name|i
index|]
operator|=
name|a
expr_stmt|;
block|}
name|returnVoid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_initpair
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|pair
parameter_list|,
name|int
name|f
parameter_list|,
name|int
name|b
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|pair
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pair
operator|<
name|NUMPAIRS
operator|)
operator|&&
operator|(
name|f
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|f
operator|<
literal|8
operator|)
operator|&&
operator|(
name|b
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|b
operator|<
literal|8
operator|)
condition|)
block|{
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|pairs
index|[
name|pair
index|]
operator|=
name|MapColor
argument_list|(
name|true
argument_list|,
name|f
argument_list|)
operator||
name|MapColor
argument_list|(
name|false
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|drv_initcolor
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|color
name|GCC_UNUSED
parameter_list|,
name|int
name|r
name|GCC_UNUSED
parameter_list|,
name|int
name|g
name|GCC_UNUSED
parameter_list|,
name|int
name|b
name|GCC_UNUSED
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|drv_do_color
argument_list|(
name|TERMINAL_CONTROL_BLOCK
operator|*
name|TCB
argument_list|,
name|int
name|old_pair
name|GCC_UNUSED
argument_list|,
name|int
name|pair
name|GCC_UNUSED
argument_list|,
name|int
name|reverse
name|GCC_UNUSED
argument_list|,
name|int
argument_list|(
argument|*outc
argument_list|)
operator|(
name|SCREEN
operator|*
operator|,
name|int
operator|)
name|GCC_UNUSED
argument_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|drv_initmouse
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
name|sp
operator|->
name|_mouse_type
operator|=
name|M_TERM_DRIVER
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_testmouse
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|_drv_mouse_head
operator|<
name|sp
operator|->
name|_drv_mouse_tail
condition|)
block|{
name|rc
operator|=
name|TW_MOUSE
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|TCBOf
argument_list|(
name|sp
argument_list|)
operator|->
name|drv
operator|->
name|twait
argument_list|(
name|TCBOf
argument_list|(
name|sp
argument_list|)
argument_list|,
name|TWAIT_MASK
argument_list|,
name|delay
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
name|EVENTLIST_2nd
argument_list|(
name|evl
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_mvcur
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|yold
name|GCC_UNUSED
parameter_list|,
name|int
name|xold
name|GCC_UNUSED
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|int
name|ret
init|=
name|ERR
decl_stmt|;
if|if
condition|(
name|okConsoleHandle
argument_list|(
name|TCB
argument_list|)
condition|)
block|{
name|Properties
modifier|*
name|p
init|=
name|PropOf
argument_list|(
name|TCB
argument_list|)
decl_stmt|;
name|COORD
name|loc
decl_stmt|;
name|loc
operator|.
name|X
operator|=
operator|(
name|short
operator|)
name|x
expr_stmt|;
name|loc
operator|.
name|Y
operator|=
call|(
name|short
call|)
argument_list|(
name|y
operator|+
name|AdjustY
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|SetConsoleCursorPosition
argument_list|(
name|TCB
operator|->
name|hdl
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|OK
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_hwlabel
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|labnum
name|GCC_UNUSED
parameter_list|,
name|char
modifier|*
name|text
name|GCC_UNUSED
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_hwlabelOnOff
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|OnFlag
name|GCC_UNUSED
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|chtype
name|drv_conattr
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
name|GCC_UNUSED
parameter_list|)
block|{
name|chtype
name|res
init|=
name|A_NORMAL
decl_stmt|;
name|res
operator||=
operator|(
name|A_BOLD
operator||
name|A_DIM
operator||
name|A_REVERSE
operator||
name|A_STANDOUT
operator||
name|A_COLOR
operator|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_setfilter
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drv_initacs
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|chtype
modifier|*
name|real_map
name|GCC_UNUSED
parameter_list|,
name|chtype
modifier|*
name|fake_map
name|GCC_UNUSED
parameter_list|)
block|{
define|#
directive|define
name|DATA
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{ a, b }
specifier|static
struct|struct
block|{
name|int
name|acs_code
decl_stmt|;
name|int
name|use_code
decl_stmt|;
block|}
name|table
index|[]
init|=
block|{
name|DATA
argument_list|(
literal|'a'
argument_list|,
literal|0xb1
argument_list|)
block|,
comment|/* ACS_CKBOARD  */
name|DATA
argument_list|(
literal|'f'
argument_list|,
literal|0xf8
argument_list|)
block|,
comment|/* ACS_DEGREE   */
name|DATA
argument_list|(
literal|'g'
argument_list|,
literal|0xf1
argument_list|)
block|,
comment|/* ACS_PLMINUS  */
name|DATA
argument_list|(
literal|'j'
argument_list|,
literal|0xd9
argument_list|)
block|,
comment|/* ACS_LRCORNER */
name|DATA
argument_list|(
literal|'l'
argument_list|,
literal|0xda
argument_list|)
block|,
comment|/* ACS_ULCORNER */
name|DATA
argument_list|(
literal|'k'
argument_list|,
literal|0xbf
argument_list|)
block|,
comment|/* ACS_URCORNER */
name|DATA
argument_list|(
literal|'m'
argument_list|,
literal|0xc0
argument_list|)
block|,
comment|/* ACS_LLCORNER */
name|DATA
argument_list|(
literal|'n'
argument_list|,
literal|0xc5
argument_list|)
block|,
comment|/* ACS_PLUS     */
name|DATA
argument_list|(
literal|'q'
argument_list|,
literal|0xc4
argument_list|)
block|,
comment|/* ACS_HLINE    */
name|DATA
argument_list|(
literal|'t'
argument_list|,
literal|0xc3
argument_list|)
block|,
comment|/* ACS_LTEE     */
name|DATA
argument_list|(
literal|'u'
argument_list|,
literal|0xb4
argument_list|)
block|,
comment|/* ACS_RTEE     */
name|DATA
argument_list|(
literal|'v'
argument_list|,
literal|0xc1
argument_list|)
block|,
comment|/* ACS_BTEE     */
name|DATA
argument_list|(
literal|'w'
argument_list|,
literal|0xc2
argument_list|)
block|,
comment|/* ACS_TTEE     */
name|DATA
argument_list|(
literal|'x'
argument_list|,
literal|0xb3
argument_list|)
block|,
comment|/* ACS_VLINE    */
name|DATA
argument_list|(
literal|'y'
argument_list|,
literal|0xf3
argument_list|)
block|,
comment|/* ACS_LEQUAL   */
name|DATA
argument_list|(
literal|'z'
argument_list|,
literal|0xf2
argument_list|)
block|,
comment|/* ACS_GEQUAL   */
name|DATA
argument_list|(
literal|'0'
argument_list|,
literal|0xdb
argument_list|)
block|,
comment|/* ACS_BLOCK    */
name|DATA
argument_list|(
literal|'{'
argument_list|,
literal|0xe3
argument_list|)
block|,
comment|/* ACS_PI       */
name|DATA
argument_list|(
literal|'}'
argument_list|,
literal|0x9c
argument_list|)
block|,
comment|/* ACS_STERLING */
name|DATA
argument_list|(
literal|','
argument_list|,
literal|0xae
argument_list|)
block|,
comment|/* ACS_LARROW   */
name|DATA
argument_list|(
literal|'+'
argument_list|,
literal|0xaf
argument_list|)
block|,
comment|/* ACS_RARROW   */
name|DATA
argument_list|(
literal|'~'
argument_list|,
literal|0xf9
argument_list|)
block|,
comment|/* ACS_BULLET   */
block|}
struct|;
undef|#
directive|undef
name|DATA
name|unsigned
name|n
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SIZEOF
argument_list|(
name|table
argument_list|)
condition|;
operator|++
name|n
control|)
block|{
name|real_map
index|[
name|table
index|[
name|n
index|]
operator|.
name|acs_code
index|]
operator|=
operator|(
name|chtype
operator|)
name|table
index|[
name|n
index|]
operator|.
name|use_code
operator||
name|A_ALTCHARSET
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
literal|0
condition|)
name|sp
operator|->
name|_screen_acs_map
index|[
name|table
index|[
name|n
index|]
operator|.
name|acs_code
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|ULONGLONG
name|tdiff
parameter_list|(
name|FILETIME
name|fstart
parameter_list|,
name|FILETIME
name|fend
parameter_list|)
block|{
name|ULARGE_INTEGER
name|ustart
decl_stmt|;
name|ULARGE_INTEGER
name|uend
decl_stmt|;
name|ULONGLONG
name|diff
decl_stmt|;
name|ustart
operator|.
name|LowPart
operator|=
name|fstart
operator|.
name|dwLowDateTime
expr_stmt|;
name|ustart
operator|.
name|HighPart
operator|=
name|fstart
operator|.
name|dwHighDateTime
expr_stmt|;
name|uend
operator|.
name|LowPart
operator|=
name|fend
operator|.
name|dwLowDateTime
expr_stmt|;
name|uend
operator|.
name|HighPart
operator|=
name|fend
operator|.
name|dwHighDateTime
expr_stmt|;
name|diff
operator|=
operator|(
name|uend
operator|.
name|QuadPart
operator|-
name|ustart
operator|.
name|QuadPart
operator|)
operator|/
literal|10000
expr_stmt|;
return|return
name|diff
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|Adjust
parameter_list|(
name|int
name|milliseconds
parameter_list|,
name|int
name|diff
parameter_list|)
block|{
if|if
condition|(
name|milliseconds
operator|==
name|INFINITY
condition|)
return|return
name|milliseconds
return|;
name|milliseconds
operator|-=
name|diff
expr_stmt|;
if|if
condition|(
name|milliseconds
operator|<
literal|0
condition|)
name|milliseconds
operator|=
literal|0
expr_stmt|;
return|return
name|milliseconds
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BUTTON_MASK
value|(FROM_LEFT_1ST_BUTTON_PRESSED | \ 		     FROM_LEFT_2ND_BUTTON_PRESSED | \ 		     FROM_LEFT_3RD_BUTTON_PRESSED | \ 		     FROM_LEFT_4TH_BUTTON_PRESSED | \ 		     RIGHTMOST_BUTTON_PRESSED)
end_define

begin_function
specifier|static
name|int
name|decode_mouse
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|FROM_LEFT_1ST_BUTTON_PRESSED
condition|)
name|result
operator||=
name|BUTTON1_PRESSED
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|FROM_LEFT_2ND_BUTTON_PRESSED
condition|)
name|result
operator||=
name|BUTTON2_PRESSED
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|FROM_LEFT_3RD_BUTTON_PRESSED
condition|)
name|result
operator||=
name|BUTTON3_PRESSED
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|FROM_LEFT_4TH_BUTTON_PRESSED
condition|)
name|result
operator||=
name|BUTTON4_PRESSED
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|RIGHTMOST_BUTTON_PRESSED
condition|)
block|{
switch|switch
condition|(
name|TCB
operator|->
name|info
operator|.
name|numbuttons
condition|)
block|{
case|case
literal|1
case|:
name|result
operator||=
name|BUTTON1_PRESSED
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|result
operator||=
name|BUTTON2_PRESSED
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|result
operator||=
name|BUTTON3_PRESSED
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|result
operator||=
name|BUTTON4_PRESSED
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|drv_twait
argument_list|(
name|TERMINAL_CONTROL_BLOCK
operator|*
name|TCB
argument_list|,
name|int
name|mode
argument_list|,
name|int
name|milliseconds
argument_list|,
name|int
operator|*
name|timeleft
name|EVENTLIST_2nd
argument_list|(
name|_nc_eventlist
operator|*
name|evl
argument_list|)
argument_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|INPUT_RECORD
name|inp_rec
decl_stmt|;
name|BOOL
name|b
decl_stmt|;
name|DWORD
name|nRead
init|=
literal|0
decl_stmt|,
name|rc
init|=
call|(
name|DWORD
call|)
argument_list|(
operator|-
literal|1
argument_list|)
decl_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
name|FILETIME
name|fstart
decl_stmt|;
name|FILETIME
name|fend
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|bool
name|isImmed
init|=
operator|(
name|milliseconds
operator|==
literal|0
operator|)
decl_stmt|;
define|#
directive|define
name|CONSUME
parameter_list|()
value|ReadConsoleInput(TCB->inp,&inp_rec,1,&nRead)
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
name|TR
argument_list|(
name|TRACE_IEVENT
argument_list|,
operator|(
literal|"start twait: %d milliseconds, mode: %d"
operator|,
name|milliseconds
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|milliseconds
operator|<
literal|0
condition|)
name|milliseconds
operator|=
name|INFINITY
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inp_rec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inp_rec
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|true
condition|)
block|{
name|GetSystemTimeAsFileTime
argument_list|(
operator|&
name|fstart
argument_list|)
expr_stmt|;
name|rc
operator|=
name|WaitForSingleObject
argument_list|(
name|TCB
operator|->
name|inp
argument_list|,
operator|(
name|DWORD
operator|)
name|milliseconds
argument_list|)
expr_stmt|;
name|GetSystemTimeAsFileTime
argument_list|(
operator|&
name|fend
argument_list|)
expr_stmt|;
name|diff
operator|=
operator|(
name|int
operator|)
name|tdiff
argument_list|(
name|fstart
argument_list|,
name|fend
argument_list|)
expr_stmt|;
name|milliseconds
operator|=
name|Adjust
argument_list|(
name|milliseconds
argument_list|,
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isImmed
operator|&&
name|milliseconds
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|rc
operator|==
name|WAIT_OBJECT_0
condition|)
block|{
if|if
condition|(
name|mode
condition|)
block|{
name|b
operator|=
name|GetNumberOfConsoleInputEvents
argument_list|(
name|TCB
operator|->
name|inp
argument_list|,
operator|&
name|nRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|&&
name|nRead
operator|>
literal|0
condition|)
block|{
name|b
operator|=
name|PeekConsoleInput
argument_list|(
name|TCB
operator|->
name|inp
argument_list|,
operator|&
name|inp_rec
argument_list|,
literal|1
argument_list|,
operator|&
name|nRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|&&
name|nRead
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|inp_rec
operator|.
name|EventType
condition|)
block|{
case|case
name|KEY_EVENT
case|:
if|if
condition|(
name|mode
operator|&
name|TW_INPUT
condition|)
block|{
name|WORD
name|vk
init|=
name|inp_rec
operator|.
name|Event
operator|.
name|KeyEvent
operator|.
name|wVirtualKeyCode
decl_stmt|;
name|char
name|ch
init|=
name|inp_rec
operator|.
name|Event
operator|.
name|KeyEvent
operator|.
name|uChar
operator|.
name|AsciiChar
decl_stmt|;
if|if
condition|(
name|inp_rec
operator|.
name|Event
operator|.
name|KeyEvent
operator|.
name|bKeyDown
condition|)
block|{
if|if
condition|(
literal|0
operator|==
name|ch
condition|)
block|{
name|int
name|nKey
init|=
name|MapKey
argument_list|(
name|TCB
argument_list|,
name|vk
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|nKey
operator|<
literal|0
operator|)
operator|||
name|FALSE
operator|==
name|sp
operator|->
name|_keypad_on
condition|)
block|{
name|CONSUME
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
name|code
operator|=
name|TW_INPUT
expr_stmt|;
goto|goto
name|end
goto|;
block|}
else|else
block|{
name|CONSUME
argument_list|()
expr_stmt|;
block|}
block|}
continue|continue;
case|case
name|MOUSE_EVENT
case|:
if|if
condition|(
name|decode_mouse
argument_list|(
name|TCB
argument_list|,
operator|(
name|inp_rec
operator|.
name|Event
operator|.
name|MouseEvent
operator|.
name|dwButtonState
operator|&
name|BUTTON_MASK
operator|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|CONSUME
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|&
name|TW_MOUSE
condition|)
block|{
name|code
operator|=
name|TW_MOUSE
expr_stmt|;
goto|goto
name|end
goto|;
block|}
continue|continue;
default|default:
name|selectActiveHandle
argument_list|(
name|TCB
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
block|}
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|rc
operator|!=
name|WAIT_TIMEOUT
condition|)
block|{
name|code
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
else|else
block|{
name|code
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
name|end
label|:
name|TR
argument_list|(
name|TRACE_IEVENT
argument_list|,
operator|(
literal|"end twait: returned %d (%d), remaining time %d msec"
operator|,
name|code
operator|,
name|errno
operator|,
name|milliseconds
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeleft
condition|)
operator|*
name|timeleft
operator|=
name|milliseconds
expr_stmt|;
return|return
name|code
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|bool
name|handle_mouse
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|MOUSE_EVENT_RECORD
name|mer
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|MEVENT
name|work
decl_stmt|;
name|bool
name|result
init|=
name|FALSE
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
name|sp
operator|->
name|_drv_mouse_old_buttons
operator|=
name|sp
operator|->
name|_drv_mouse_new_buttons
expr_stmt|;
name|sp
operator|->
name|_drv_mouse_new_buttons
operator|=
name|mer
operator|.
name|dwButtonState
operator|&
name|BUTTON_MASK
expr_stmt|;
comment|/*      * We're only interested if the button is pressed or released.      * FIXME: implement continuous event-tracking.      */
if|if
condition|(
name|sp
operator|->
name|_drv_mouse_new_buttons
operator|!=
name|sp
operator|->
name|_drv_mouse_old_buttons
condition|)
block|{
name|Properties
modifier|*
name|p
init|=
name|PropOf
argument_list|(
name|TCB
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|work
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|_drv_mouse_new_buttons
condition|)
block|{
name|work
operator|.
name|bstate
operator||=
operator|(
name|mmask_t
operator|)
name|decode_mouse
argument_list|(
name|TCB
argument_list|,
name|sp
operator|->
name|_drv_mouse_new_buttons
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* cf: BUTTON_PRESSED, BUTTON_RELEASED */
name|work
operator|.
name|bstate
operator||=
call|(
name|mmask_t
call|)
argument_list|(
name|decode_mouse
argument_list|(
name|TCB
argument_list|,
name|sp
operator|->
name|_drv_mouse_old_buttons
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|TRUE
expr_stmt|;
block|}
name|work
operator|.
name|x
operator|=
name|mer
operator|.
name|dwMousePosition
operator|.
name|X
expr_stmt|;
name|work
operator|.
name|y
operator|=
name|mer
operator|.
name|dwMousePosition
operator|.
name|Y
operator|-
name|AdjustY
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sp
operator|->
name|_drv_mouse_fifo
index|[
name|sp
operator|->
name|_drv_mouse_tail
index|]
operator|=
name|work
expr_stmt|;
name|sp
operator|->
name|_drv_mouse_tail
operator|+=
literal|1
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_read
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
modifier|*
name|buf
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|int
name|n
init|=
literal|1
decl_stmt|;
name|INPUT_RECORD
name|inp_rec
decl_stmt|;
name|BOOL
name|b
decl_stmt|;
name|DWORD
name|nRead
decl_stmt|;
name|WORD
name|vk
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inp_rec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inp_rec
argument_list|)
argument_list|)
expr_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"win32con::drv_read(%p)"
argument_list|)
operator|,
name|TCB
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|b
operator|=
name|ReadConsoleInput
argument_list|(
name|TCB
operator|->
name|inp
argument_list|,
operator|&
name|inp_rec
argument_list|,
literal|1
argument_list|,
operator|&
name|nRead
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|b
operator|&&
name|nRead
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|inp_rec
operator|.
name|EventType
operator|==
name|KEY_EVENT
condition|)
block|{
if|if
condition|(
operator|!
name|inp_rec
operator|.
name|Event
operator|.
name|KeyEvent
operator|.
name|bKeyDown
condition|)
continue|continue;
operator|*
name|buf
operator|=
operator|(
name|int
operator|)
name|inp_rec
operator|.
name|Event
operator|.
name|KeyEvent
operator|.
name|uChar
operator|.
name|AsciiChar
expr_stmt|;
name|vk
operator|=
name|inp_rec
operator|.
name|Event
operator|.
name|KeyEvent
operator|.
name|wVirtualKeyCode
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|_keypad_on
condition|)
block|{
operator|*
name|buf
operator|=
name|MapKey
argument_list|(
name|TCB
argument_list|,
name|vk
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>
operator|(
operator|*
name|buf
operator|)
condition|)
continue|continue;
else|else
break|break;
block|}
else|else
continue|continue;
block|}
else|else
block|{
comment|/* *buf != 0 */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|inp_rec
operator|.
name|EventType
operator|==
name|MOUSE_EVENT
condition|)
block|{
if|if
condition|(
name|handle_mouse
argument_list|(
name|TCB
argument_list|,
name|inp_rec
operator|.
name|Event
operator|.
name|MouseEvent
argument_list|)
condition|)
block|{
operator|*
name|buf
operator|=
name|KEY_MOUSE
expr_stmt|;
break|break;
block|}
block|}
continue|continue;
block|}
block|}
name|returnCode
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_nap
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
name|GCC_UNUSED
parameter_list|,
name|int
name|ms
parameter_list|)
block|{
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"win32con::drv_nap(%p, %d)"
argument_list|)
operator|,
name|TCB
operator|,
name|ms
operator|)
argument_list|)
expr_stmt|;
name|Sleep
argument_list|(
operator|(
name|DWORD
operator|)
name|ms
argument_list|)
expr_stmt|;
name|returnCode
argument_list|(
name|OK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|drv_kyExist
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|keycode
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|WORD
name|nKey
decl_stmt|;
name|void
modifier|*
name|res
decl_stmt|;
name|bool
name|found
init|=
name|FALSE
decl_stmt|;
name|LONG
name|key
init|=
name|GenMap
argument_list|(
literal|0
argument_list|,
operator|(
name|WORD
operator|)
name|keycode
argument_list|)
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"win32con::drv_kyExist(%p, %d)"
argument_list|)
operator|,
name|TCB
operator|,
name|keycode
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|bsearch
argument_list|(
operator|&
name|key
argument_list|,
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|rmap
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|N_INI
operator|+
name|FKEYS
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|rkeycompare
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|key
operator|=
operator|*
operator|(
operator|(
name|LONG
operator|*
operator|)
name|res
operator|)
expr_stmt|;
name|nKey
operator|=
name|LOWORD
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nKey
operator|&
literal|0x8000
operator|)
condition|)
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|found
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_kpad
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|flag
name|GCC_UNUSED
parameter_list|)
block|{
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|sp
operator|=
name|TCB
operator|->
name|csp
expr_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"win32con::drv_kpad(%p, %d)"
argument_list|)
operator|,
name|TCB
operator|,
name|flag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
name|code
operator|=
name|OK
expr_stmt|;
block|}
name|returnCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|drv_keyok
parameter_list|(
name|TERMINAL_CONTROL_BLOCK
modifier|*
name|TCB
parameter_list|,
name|int
name|keycode
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|code
init|=
name|ERR
decl_stmt|;
name|SCREEN
modifier|*
name|sp
decl_stmt|;
name|WORD
name|nKey
decl_stmt|;
name|WORD
name|vKey
decl_stmt|;
name|void
modifier|*
name|res
decl_stmt|;
name|LONG
name|key
init|=
name|GenMap
argument_list|(
literal|0
argument_list|,
operator|(
name|WORD
operator|)
name|keycode
argument_list|)
decl_stmt|;
name|AssertTCB
argument_list|()
expr_stmt|;
name|SetSP
argument_list|()
expr_stmt|;
name|T
argument_list|(
operator|(
name|T_CALLED
argument_list|(
literal|"win32con::drv_keyok(%p, %d, %d)"
argument_list|)
operator|,
name|TCB
operator|,
name|keycode
operator|,
name|flag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
name|res
operator|=
name|bsearch
argument_list|(
operator|&
name|key
argument_list|,
name|PropOf
argument_list|(
name|TCB
argument_list|)
operator|->
name|rmap
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|N_INI
operator|+
name|FKEYS
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|keylist
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|rkeycompare
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|key
operator|=
operator|*
operator|(
operator|(
name|LONG
operator|*
operator|)
name|res
operator|)
expr_stmt|;
name|vKey
operator|=
name|HIWORD
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|nKey
operator|=
operator|(
name|LOWORD
argument_list|(
name|key
argument_list|)
operator|)
operator|&
literal|0x7fff
expr_stmt|;
if|if
condition|(
operator|!
name|flag
condition|)
name|nKey
operator||=
literal|0x8000
expr_stmt|;
operator|*
operator|(
name|LONG
operator|*
operator|)
name|res
operator|=
name|GenMap
argument_list|(
name|vKey
argument_list|,
name|nKey
argument_list|)
expr_stmt|;
block|}
block|}
name|returnCode
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|NCURSES_EXPORT_VAR
argument_list|(
argument|TERM_DRIVER
argument_list|)
end_macro

begin_expr_stmt
name|_nc_WIN_DRIVER
operator|=
block|{
name|FALSE
block|,
name|drv_CanHandle
block|,
comment|/* CanHandle */
name|drv_init
block|,
comment|/* init */
name|drv_release
block|,
comment|/* release */
name|drv_size
block|,
comment|/* size */
name|drv_sgmode
block|,
comment|/* sgmode */
name|drv_conattr
block|,
comment|/* conattr */
name|drv_mvcur
block|,
comment|/* hwcur */
name|drv_mode
block|,
comment|/* mode */
name|drv_rescol
block|,
comment|/* rescol */
name|drv_rescolors
block|,
comment|/* rescolors */
name|drv_setcolor
block|,
comment|/* color */
name|drv_dobeepflash
block|,
comment|/* DoBeepFlash */
name|drv_initpair
block|,
comment|/* initpair */
name|drv_initcolor
block|,
comment|/* initcolor */
name|drv_do_color
block|,
comment|/* docolor */
name|drv_initmouse
block|,
comment|/* initmouse */
name|drv_testmouse
block|,
comment|/* testmouse */
name|drv_setfilter
block|,
comment|/* setfilter */
name|drv_hwlabel
block|,
comment|/* hwlabel */
name|drv_hwlabelOnOff
block|,
comment|/* hwlabelOnOff */
name|drv_doupdate
block|,
comment|/* update */
name|drv_defaultcolors
block|,
comment|/* defaultcolors */
name|drv_print
block|,
comment|/* print */
name|drv_size
block|,
comment|/* getsize */
name|drv_setsize
block|,
comment|/* setsize */
name|drv_initacs
block|,
comment|/* initacs */
name|drv_screen_init
block|,
comment|/* scinit */
name|drv_wrap
block|,
comment|/* scexit */
name|drv_twait
block|,
comment|/* twait */
name|drv_read
block|,
comment|/* read */
name|drv_nap
block|,
comment|/* nap */
name|drv_kpad
block|,
comment|/* kpad */
name|drv_keyok
block|,
comment|/* kyOk */
name|drv_kyExist
comment|/* kyExist */
block|}
expr_stmt|;
end_expr_stmt

end_unit

