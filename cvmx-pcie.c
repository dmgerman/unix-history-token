begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2011  Cavium, Inc.<support@cavium.com>.  All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to PCIe as a host(RC) or target(EP)  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-config.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-clock.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-ciu-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-dpi-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-mio-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-npi-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-npei-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pci-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pcieepx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pciercx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pemx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pexp-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pescx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sli-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sriox-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-jtag.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_CAVIUM_DECODE_RSL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-error.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-board.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-errata.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-qlm.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pcie.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sysinfo.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-swap.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-wqe.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-csr-db.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pcie.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-swap.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-wqe.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-error.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-errata.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-qlm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MRRS_CN5XXX
value|0
end_define

begin_comment
comment|/* 128 byte Max Read Request Size */
end_comment

begin_define
define|#
directive|define
name|MPS_CN5XXX
value|0
end_define

begin_comment
comment|/* 128 byte Max Packet Size (Limit of most PCs) */
end_comment

begin_define
define|#
directive|define
name|MRRS_CN6XXX
value|3
end_define

begin_comment
comment|/* 1024 byte Max Read Request Size */
end_comment

begin_define
define|#
directive|define
name|MPS_CN6XXX
value|0
end_define

begin_comment
comment|/* 128 byte Max Packet Size (Limit of most PCs) */
end_comment

begin_comment
comment|/**  * Return the Core virtual base address for PCIe IO access. IOs are  * read/written as an offset from this address.  *  * @param pcie_port PCIe port the IO is for  *  * @return 64bit Octeon IO base address for read/write  */
end_comment

begin_function
name|uint64_t
name|cvmx_pcie_get_io_base_address
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|cvmx_pcie_address_t
name|pcie_addr
decl_stmt|;
name|pcie_addr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|upper
operator|=
literal|0
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|io
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|did
operator|=
literal|3
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|subdid
operator|=
literal|2
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|es
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|port
operator|=
name|pcie_port
expr_stmt|;
return|return
name|pcie_addr
operator|.
name|u64
return|;
block|}
end_function

begin_comment
comment|/**  * Size of the IO address region returned at address  * cvmx_pcie_get_io_base_address()  *  * @param pcie_port PCIe port the IO is for  *  * @return Size of the IO window  */
end_comment

begin_function
name|uint64_t
name|cvmx_pcie_get_io_size
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
return|return
literal|1ull
operator|<<
literal|32
return|;
block|}
end_function

begin_comment
comment|/**  * Return the Core virtual base address for PCIe MEM access. Memory is  * read/written as an offset from this address.  *  * @param pcie_port PCIe port the IO is for  *  * @return 64bit Octeon IO base address for read/write  */
end_comment

begin_function
name|uint64_t
name|cvmx_pcie_get_mem_base_address
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|cvmx_pcie_address_t
name|pcie_addr
decl_stmt|;
name|pcie_addr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pcie_addr
operator|.
name|mem
operator|.
name|upper
operator|=
literal|0
expr_stmt|;
name|pcie_addr
operator|.
name|mem
operator|.
name|io
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|mem
operator|.
name|did
operator|=
literal|3
expr_stmt|;
name|pcie_addr
operator|.
name|mem
operator|.
name|subdid
operator|=
literal|3
operator|+
name|pcie_port
expr_stmt|;
return|return
name|pcie_addr
operator|.
name|u64
return|;
block|}
end_function

begin_comment
comment|/**  * Size of the Mem address region returned at address  * cvmx_pcie_get_mem_base_address()  *  * @param pcie_port PCIe port the IO is for  *  * @return Size of the Mem window  */
end_comment

begin_function
name|uint64_t
name|cvmx_pcie_get_mem_size
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
return|return
literal|1ull
operator|<<
literal|36
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Initialize the RC config space CSRs  *  * @param pcie_port PCIe port to initialize  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_pcie_rc_initialize_config_space
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
comment|/* Max Payload Size (PCIE*_CFG030[MPS]) */
comment|/* Max Read Request Size (PCIE*_CFG030[MRRS]) */
comment|/* Relaxed-order, no-snoop enables (PCIE*_CFG030[RO_EN,NS_EN] */
comment|/* Error Message Enables (PCIE*_CFG030[CE_EN,NFE_EN,FE_EN,UR_EN]) */
block|{
name|cvmx_pciercx_cfg030_t
name|pciercx_cfg030
decl_stmt|;
name|pciercx_cfg030
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG030
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
block|{
name|pciercx_cfg030
operator|.
name|s
operator|.
name|mps
operator|=
name|MPS_CN5XXX
expr_stmt|;
name|pciercx_cfg030
operator|.
name|s
operator|.
name|mrrs
operator|=
name|MRRS_CN5XXX
expr_stmt|;
block|}
else|else
block|{
name|pciercx_cfg030
operator|.
name|s
operator|.
name|mps
operator|=
name|MPS_CN6XXX
expr_stmt|;
name|pciercx_cfg030
operator|.
name|s
operator|.
name|mrrs
operator|=
name|MRRS_CN6XXX
expr_stmt|;
block|}
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ro_en
operator|=
literal|1
expr_stmt|;
comment|/* Enable relaxed order processing. This will allow devices to affect read response ordering */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ns_en
operator|=
literal|1
expr_stmt|;
comment|/* Enable no snoop processing. Not used by Octeon */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ce_en
operator|=
literal|1
expr_stmt|;
comment|/* Correctable error reporting enable. */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|nfe_en
operator|=
literal|1
expr_stmt|;
comment|/* Non-fatal error reporting enable. */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|fe_en
operator|=
literal|1
expr_stmt|;
comment|/* Fatal error reporting enable. */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ur_en
operator|=
literal|1
expr_stmt|;
comment|/* Unsupported request reporting enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG030
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg030
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
comment|/* Max Payload Size (NPEI_CTL_STATUS2[MPS]) must match PCIE*_CFG030[MPS] */
comment|/* Max Read Request Size (NPEI_CTL_STATUS2[MRRS]) must not exceed PCIE*_CFG030[MRRS] */
name|cvmx_npei_ctl_status2_t
name|npei_ctl_status2
decl_stmt|;
name|npei_ctl_status2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS2
argument_list|)
expr_stmt|;
name|npei_ctl_status2
operator|.
name|s
operator|.
name|mps
operator|=
name|MPS_CN5XXX
expr_stmt|;
comment|/* Max payload size = 128 bytes for best Octeon DMA performance */
name|npei_ctl_status2
operator|.
name|s
operator|.
name|mrrs
operator|=
name|MRRS_CN5XXX
expr_stmt|;
comment|/* Max read request size = 128 bytes for best Octeon DMA performance */
if|if
condition|(
name|pcie_port
condition|)
name|npei_ctl_status2
operator|.
name|s
operator|.
name|c1_b1_s
operator|=
literal|3
expr_stmt|;
comment|/* Port1 BAR1 Size 256MB */
else|else
name|npei_ctl_status2
operator|.
name|s
operator|.
name|c0_b1_s
operator|=
literal|3
expr_stmt|;
comment|/* Port0 BAR1 Size 256MB */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS2
argument_list|,
name|npei_ctl_status2
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Max Payload Size (DPI_SLI_PRTX_CFG[MPS]) must match PCIE*_CFG030[MPS] */
comment|/* Max Read Request Size (DPI_SLI_PRTX_CFG[MRRS]) must not exceed PCIE*_CFG030[MRRS] */
name|cvmx_dpi_sli_prtx_cfg_t
name|prt_cfg
decl_stmt|;
name|cvmx_sli_s2m_portx_ctl_t
name|sli_s2m_portx_ctl
decl_stmt|;
name|prt_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DPI_SLI_PRTX_CFG
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|prt_cfg
operator|.
name|s
operator|.
name|mps
operator|=
name|MPS_CN6XXX
expr_stmt|;
name|prt_cfg
operator|.
name|s
operator|.
name|mrrs
operator|=
name|MRRS_CN6XXX
expr_stmt|;
comment|/* Max outstanding load request. */
name|prt_cfg
operator|.
name|s
operator|.
name|molr
operator|=
literal|32
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_SLI_PRTX_CFG
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|prt_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|sli_s2m_portx_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_S2M_PORTX_CTL
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|sli_s2m_portx_ctl
operator|.
name|s
operator|.
name|mrrs
operator|=
name|MRRS_CN6XXX
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_S2M_PORTX_CTL
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|sli_s2m_portx_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* ECRC Generation (PCIE*_CFG070[GE,CE]) */
block|{
name|cvmx_pciercx_cfg070_t
name|pciercx_cfg070
decl_stmt|;
name|pciercx_cfg070
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG070
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg070
operator|.
name|s
operator|.
name|ge
operator|=
literal|1
expr_stmt|;
comment|/* ECRC generation enable. */
name|pciercx_cfg070
operator|.
name|s
operator|.
name|ce
operator|=
literal|1
expr_stmt|;
comment|/* ECRC check enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG070
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg070
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Access Enables (PCIE*_CFG001[MSAE,ME]) */
comment|/* ME and MSAE should always be set. */
comment|/* Interrupt Disable (PCIE*_CFG001[I_DIS]) */
comment|/* System Error Message Enable (PCIE*_CFG001[SEE]) */
block|{
name|cvmx_pciercx_cfg001_t
name|pciercx_cfg001
decl_stmt|;
name|pciercx_cfg001
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG001
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg001
operator|.
name|s
operator|.
name|msae
operator|=
literal|1
expr_stmt|;
comment|/* Memory space enable. */
name|pciercx_cfg001
operator|.
name|s
operator|.
name|me
operator|=
literal|1
expr_stmt|;
comment|/* Bus master enable. */
name|pciercx_cfg001
operator|.
name|s
operator|.
name|i_dis
operator|=
literal|1
expr_stmt|;
comment|/* INTx assertion disable. */
name|pciercx_cfg001
operator|.
name|s
operator|.
name|see
operator|=
literal|1
expr_stmt|;
comment|/* SERR# enable */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG001
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg001
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Advanced Error Recovery Message Enables */
comment|/* (PCIE*_CFG066,PCIE*_CFG067,PCIE*_CFG069) */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG066
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use CVMX_PCIERCX_CFG067 hardware default */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG069
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Active State Power Management (PCIE*_CFG032[ASLPC]) */
block|{
name|cvmx_pciercx_cfg032_t
name|pciercx_cfg032
decl_stmt|;
name|pciercx_cfg032
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG032
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg032
operator|.
name|s
operator|.
name|aslpc
operator|=
literal|0
expr_stmt|;
comment|/* Active state Link PM control. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG032
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg032
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Link Width Mode (PCIERCn_CFG452[LME]) - Set during cvmx_pcie_rc_initialize_link() */
comment|/* Primary Bus Number (PCIERCn_CFG006[PBNUM]) */
block|{
comment|/* We set the primary bus number to 1 so IDT bridges are happy. They don't like zero */
name|cvmx_pciercx_cfg006_t
name|pciercx_cfg006
decl_stmt|;
name|pciercx_cfg006
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|pciercx_cfg006
operator|.
name|s
operator|.
name|pbnum
operator|=
literal|1
expr_stmt|;
name|pciercx_cfg006
operator|.
name|s
operator|.
name|sbnum
operator|=
literal|1
expr_stmt|;
name|pciercx_cfg006
operator|.
name|s
operator|.
name|subbnum
operator|=
literal|1
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG006
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg006
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Memory-mapped I/O BAR (PCIERCn_CFG008) */
comment|/* Most applications should disable the memory-mapped I/O BAR by */
comment|/* setting PCIERCn_CFG008[ML_ADDR]< PCIERCn_CFG008[MB_ADDR] */
block|{
name|cvmx_pciercx_cfg008_t
name|pciercx_cfg008
decl_stmt|;
name|pciercx_cfg008
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|pciercx_cfg008
operator|.
name|s
operator|.
name|mb_addr
operator|=
literal|0x100
expr_stmt|;
name|pciercx_cfg008
operator|.
name|s
operator|.
name|ml_addr
operator|=
literal|0
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG008
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg008
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Prefetchable BAR (PCIERCn_CFG009,PCIERCn_CFG010,PCIERCn_CFG011) */
comment|/* Most applications should disable the prefetchable BAR by setting */
comment|/* PCIERCn_CFG011[UMEM_LIMIT],PCIERCn_CFG009[LMEM_LIMIT]< */
comment|/* PCIERCn_CFG010[UMEM_BASE],PCIERCn_CFG009[LMEM_BASE] */
block|{
name|cvmx_pciercx_cfg009_t
name|pciercx_cfg009
decl_stmt|;
name|cvmx_pciercx_cfg010_t
name|pciercx_cfg010
decl_stmt|;
name|cvmx_pciercx_cfg011_t
name|pciercx_cfg011
decl_stmt|;
name|pciercx_cfg009
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG009
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg010
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG010
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg011
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG011
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg009
operator|.
name|s
operator|.
name|lmem_base
operator|=
literal|0x100
expr_stmt|;
name|pciercx_cfg009
operator|.
name|s
operator|.
name|lmem_limit
operator|=
literal|0
expr_stmt|;
name|pciercx_cfg010
operator|.
name|s
operator|.
name|umem_base
operator|=
literal|0x100
expr_stmt|;
name|pciercx_cfg011
operator|.
name|s
operator|.
name|umem_limit
operator|=
literal|0
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG009
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg009
operator|.
name|u32
argument_list|)
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG010
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg010
operator|.
name|u32
argument_list|)
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG011
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg011
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* System Error Interrupt Enables (PCIERCn_CFG035[SECEE,SEFEE,SENFEE]) */
comment|/* PME Interrupt Enables (PCIERCn_CFG035[PMEIE]) */
block|{
name|cvmx_pciercx_cfg035_t
name|pciercx_cfg035
decl_stmt|;
name|pciercx_cfg035
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG035
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg035
operator|.
name|s
operator|.
name|secee
operator|=
literal|1
expr_stmt|;
comment|/* System error on correctable error enable. */
name|pciercx_cfg035
operator|.
name|s
operator|.
name|sefee
operator|=
literal|1
expr_stmt|;
comment|/* System error on fatal error enable. */
name|pciercx_cfg035
operator|.
name|s
operator|.
name|senfee
operator|=
literal|1
expr_stmt|;
comment|/* System error on non-fatal error enable. */
name|pciercx_cfg035
operator|.
name|s
operator|.
name|pmeie
operator|=
literal|1
expr_stmt|;
comment|/* PME interrupt enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG035
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg035
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Advanced Error Recovery Interrupt Enables */
comment|/* (PCIERCn_CFG075[CERE,NFERE,FERE]) */
block|{
name|cvmx_pciercx_cfg075_t
name|pciercx_cfg075
decl_stmt|;
name|pciercx_cfg075
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG075
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg075
operator|.
name|s
operator|.
name|cere
operator|=
literal|1
expr_stmt|;
comment|/* Correctable error reporting enable. */
name|pciercx_cfg075
operator|.
name|s
operator|.
name|nfere
operator|=
literal|1
expr_stmt|;
comment|/* Non-fatal error reporting enable. */
name|pciercx_cfg075
operator|.
name|s
operator|.
name|fere
operator|=
literal|1
expr_stmt|;
comment|/* Fatal error reporting enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG075
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg075
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* HP Interrupt Enables (PCIERCn_CFG034[HPINT_EN], */
comment|/* PCIERCn_CFG034[DLLS_EN,CCINT_EN]) */
block|{
name|cvmx_pciercx_cfg034_t
name|pciercx_cfg034
decl_stmt|;
name|pciercx_cfg034
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG034
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg034
operator|.
name|s
operator|.
name|hpint_en
operator|=
literal|1
expr_stmt|;
comment|/* Hot-plug interrupt enable. */
name|pciercx_cfg034
operator|.
name|s
operator|.
name|dlls_en
operator|=
literal|1
expr_stmt|;
comment|/* Data Link Layer state changed enable */
name|pciercx_cfg034
operator|.
name|s
operator|.
name|ccint_en
operator|=
literal|1
expr_stmt|;
comment|/* Command completed interrupt enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG034
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg034
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Initialize a host mode PCIe gen 1 link. This function takes a PCIe  * port from reset to a link up state. Software can then begin  * configuring the rest of the link.  *  * @param pcie_port PCIe port to initialize  *  * @return Zero on success  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_pcie_rc_initialize_link_gen1
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|uint64_t
name|start_cycle
decl_stmt|;
name|cvmx_pescx_ctl_status_t
name|pescx_ctl_status
decl_stmt|;
name|cvmx_pciercx_cfg452_t
name|pciercx_cfg452
decl_stmt|;
name|cvmx_pciercx_cfg032_t
name|pciercx_cfg032
decl_stmt|;
name|cvmx_pciercx_cfg448_t
name|pciercx_cfg448
decl_stmt|;
comment|/* Set the lane width */
name|pciercx_cfg452
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG452
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pescx_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pescx_ctl_status
operator|.
name|s
operator|.
name|qlm_cfg
operator|==
literal|0
condition|)
block|{
comment|/* We're in 8 lane (56XX) or 4 lane (54XX) mode */
name|pciercx_cfg452
operator|.
name|s
operator|.
name|lme
operator|=
literal|0xf
expr_stmt|;
block|}
else|else
block|{
comment|/* We're in 4 lane (56XX) or 2 lane (52XX) mode */
name|pciercx_cfg452
operator|.
name|s
operator|.
name|lme
operator|=
literal|0x7
expr_stmt|;
block|}
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG452
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg452
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|/* CN52XX pass 1.x has an errata where length mismatches on UR responses can         cause bus errors on 64bit memory reads. Turning off length error         checking fixes this */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
condition|)
block|{
name|cvmx_pciercx_cfg455_t
name|pciercx_cfg455
decl_stmt|;
name|pciercx_cfg455
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG455
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg455
operator|.
name|s
operator|.
name|m_cpl_len_err
operator|=
literal|1
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG455
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg455
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Lane swap needs to be manually enabled for CN52XX */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
name|pcie_port
operator|==
literal|1
operator|)
condition|)
block|{
name|pescx_ctl_status
operator|.
name|s
operator|.
name|lane_swp
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pescx_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Bring up the link */
name|pescx_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pescx_ctl_status
operator|.
name|s
operator|.
name|lnk_enb
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pescx_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* CN52XX pass 1.0: Due to a bug in 2nd order CDR, it needs to be disabled */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_0
argument_list|)
condition|)
name|__cvmx_helper_errata_qlm_disable_2nd_order_cdr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for the link to come up */
name|start_cycle
operator|=
name|cvmx_get_cycle
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cvmx_get_cycle
argument_list|()
operator|-
name|start_cycle
operator|>
literal|2
operator|*
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d link timeout\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|pciercx_cfg032
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG032
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pciercx_cfg032
operator|.
name|s
operator|.
name|dlla
operator|==
literal|0
condition|)
do|;
comment|/* Clear all pending errors */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_INT_SUM
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_INT_SUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the Replay Time Limit. Empirically, some PCIe devices take a         little longer to respond than expected under load. As a workaround for         this we configure the Replay Time Limit to the value expected for a 512         byte MPS instead of our actual 256 byte MPS. The numbers below are         directly from the PCIe spec table 3-4 */
name|pciercx_cfg448
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG448
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pciercx_cfg032
operator|.
name|s
operator|.
name|nlw
condition|)
block|{
case|case
literal|1
case|:
comment|/* 1 lane */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|1677
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 2 lanes */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|867
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* 4 lanes */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|462
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* 8 lanes */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|258
expr_stmt|;
break|break;
block|}
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG448
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg448
operator|.
name|u32
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_increment_ba
parameter_list|(
name|cvmx_sli_mem_access_subidx_t
modifier|*
name|pmas
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
name|pmas
operator|->
name|cn68xx
operator|.
name|ba
operator|++
expr_stmt|;
else|else
name|pmas
operator|->
name|cn63xx
operator|.
name|ba
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Initialize a PCIe gen 1 port for use in host(RC) mode. It doesn't enumerate  * the bus.  *  * @param pcie_port PCIe port to initialize  *  * @return Zero on success  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_pcie_rc_initialize_gen1
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|base
decl_stmt|;
name|uint64_t
name|addr_swizzle
decl_stmt|;
name|cvmx_ciu_soft_prst_t
name|ciu_soft_prst
decl_stmt|;
name|cvmx_pescx_bist_status_t
name|pescx_bist_status
decl_stmt|;
name|cvmx_pescx_bist_status2_t
name|pescx_bist_status2
decl_stmt|;
name|cvmx_npei_ctl_status_t
name|npei_ctl_status
decl_stmt|;
name|cvmx_npei_mem_access_ctl_t
name|npei_mem_access_ctl
decl_stmt|;
name|cvmx_npei_mem_access_subidx_t
name|mem_access_subid
decl_stmt|;
name|cvmx_npei_dbg_data_t
name|npei_dbg_data
decl_stmt|;
name|cvmx_pescx_ctl_status2_t
name|pescx_ctl_status2
decl_stmt|;
name|cvmx_pciercx_cfg032_t
name|pciercx_cfg032
decl_stmt|;
name|cvmx_npei_bar1_indexx_t
name|bar1_index
decl_stmt|;
name|retry
label|:
comment|/* Make sure we aren't trying to setup a target mode interface in host mode */
name|npei_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcie_port
operator|==
literal|0
operator|)
operator|&&
operator|!
name|npei_ctl_status
operator|.
name|s
operator|.
name|host_mode
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d in endpoint mode\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make sure a CN52XX isn't trying to bring up port 1 when it is disabled */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
block|{
name|npei_dbg_data
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcie_port
operator|==
literal|1
operator|)
operator|&&
name|npei_dbg_data
operator|.
name|cn52xx
operator|.
name|qlm0_link_width
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: ERROR: cvmx_pcie_rc_initialize() called on port1, but port1 is disabled\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* PCIe switch arbitration mode. '0' == fixed priority NPEI, PCIe0, then PCIe1. '1' == round robin. */
name|npei_ctl_status
operator|.
name|s
operator|.
name|arb
operator|=
literal|1
expr_stmt|;
comment|/* Allow up to 0x20 config retries */
name|npei_ctl_status
operator|.
name|s
operator|.
name|cfg_rtry
operator|=
literal|0x20
expr_stmt|;
comment|/* CN52XX pass1.x has an errata where P0_NTAGS and P1_NTAGS don't reset */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
condition|)
block|{
name|npei_ctl_status
operator|.
name|s
operator|.
name|p0_ntags
operator|=
literal|0x20
expr_stmt|;
name|npei_ctl_status
operator|.
name|s
operator|.
name|p1_ntags
operator|=
literal|0x20
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS
argument_list|,
name|npei_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Bring the PCIe out of reset */
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBH5200
condition|)
block|{
comment|/* The EBH5200 board swapped the PCIe reset lines on the board. As a             workaround for this bug, we bring both PCIe ports out of reset at             the same time instead of on separate calls. So for port 0, we bring             both out of reset and do nothing on port 1 */
if|if
condition|(
name|pcie_port
operator|==
literal|0
condition|)
block|{
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
comment|/* After a chip reset the PCIe will also be in reset. If it isn't,                 most likely someone is trying to init it again without a proper                 PCIe reset */
if|if
condition|(
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|==
literal|0
condition|)
block|{
comment|/* Reset the ports */
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait until pcie resets the ports. */
name|cvmx_wait_usec
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The normal case: The PCIe ports are completely separate and can be             brought out of reset independently */
if|if
condition|(
name|pcie_port
condition|)
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
else|else
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
comment|/* After a chip reset the PCIe will also be in reset. If it isn't,             most likely someone is trying to init it again without a proper             PCIe reset */
if|if
condition|(
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|==
literal|0
condition|)
block|{
comment|/* Reset the port */
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pcie_port
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait until pcie resets the ports. */
name|cvmx_wait_usec
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pcie_port
condition|)
block|{
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Wait for PCIe reset to complete. Due to errata PCIE-700, we don't poll        PESCX_CTL_STATUS2[PCIERST], but simply wait a fixed number of cycles */
name|cvmx_wait
argument_list|(
literal|400000
argument_list|)
expr_stmt|;
comment|/* PESCX_BIST_STATUS2[PCLK_RUN] was missing on pass 1 of CN56XX and         CN52XX, so we only probe it on newer chips */
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS1_X
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
condition|)
block|{
comment|/* Clear PCLK_RUN so we can check if the clock is running */
name|pescx_ctl_status2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS2
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pescx_ctl_status2
operator|.
name|s
operator|.
name|pclk_run
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS2
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pescx_ctl_status2
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Now that we cleared PCLK_RUN, wait for it to be set again telling             us the clock is running */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PESCX_CTL_STATUS2
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|cvmx_pescx_ctl_status2_t
argument_list|,
name|pclk_run
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d isn't clocked, skipping.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Check and make sure PCIe came out of reset. If it doesn't the board         probably hasn't wired the clocks up and the interface should be         skipped */
name|pescx_ctl_status2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS2
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pescx_ctl_status2
operator|.
name|s
operator|.
name|pcierst
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d stuck in reset, skipping.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check BIST2 status. If any bits are set skip this interface. This         is an attempt to catch PCIE-813 on pass 1 parts */
name|pescx_bist_status2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_BIST_STATUS2
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pescx_bist_status2
operator|.
name|u64
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d BIST2 failed. Most likely this port isn't hooked up, skipping.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check BIST status */
name|pescx_bist_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_BIST_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pescx_bist_status
operator|.
name|u64
condition|)
name|cvmx_dprintf
argument_list|(
literal|"PCIe: BIST FAILED for port %d (0x%016llx)\n"
argument_list|,
name|pcie_port
argument_list|,
name|CAST64
argument_list|(
name|pescx_bist_status
operator|.
name|u64
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the config space CSRs */
name|__cvmx_pcie_rc_initialize_config_space
argument_list|(
name|pcie_port
argument_list|)
expr_stmt|;
comment|/* Bring the link up */
if|if
condition|(
name|__cvmx_pcie_rc_initialize_link_gen1
argument_list|(
name|pcie_port
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Failed to initialize port %d, probably the slot is empty\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Store merge control (NPEI_MEM_ACCESS_CTL[TIMER,MAX_WORD]) */
name|npei_mem_access_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_MEM_ACCESS_CTL
argument_list|)
expr_stmt|;
name|npei_mem_access_ctl
operator|.
name|s
operator|.
name|max_word
operator|=
literal|0
expr_stmt|;
comment|/* Allow 16 words to combine */
name|npei_mem_access_ctl
operator|.
name|s
operator|.
name|timer
operator|=
literal|127
expr_stmt|;
comment|/* Wait up to 127 cycles for more data */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_MEM_ACCESS_CTL
argument_list|,
name|npei_mem_access_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Setup Mem access SubDIDs */
name|mem_access_subid
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|mem_access_subid
operator|.
name|s
operator|.
name|port
operator|=
name|pcie_port
expr_stmt|;
comment|/* Port the request is sent to. */
name|mem_access_subid
operator|.
name|s
operator|.
name|nmerge
operator|=
literal|1
expr_stmt|;
comment|/* Due to an errata on pass 1 chips, no merging is allowed. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esr
operator|=
literal|1
expr_stmt|;
comment|/* Endian-swap for Reads. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esw
operator|=
literal|1
expr_stmt|;
comment|/* Endian-swap for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|nsr
operator|=
literal|0
expr_stmt|;
comment|/* Enable Snooping for Reads. Octeon doesn't care, but devices might want this more conservative setting */
name|mem_access_subid
operator|.
name|s
operator|.
name|nsw
operator|=
literal|0
expr_stmt|;
comment|/* Enable Snoop for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|ror
operator|=
literal|0
expr_stmt|;
comment|/* Disable Relaxed Ordering for Reads. */
name|mem_access_subid
operator|.
name|s
operator|.
name|row
operator|=
literal|0
expr_stmt|;
comment|/* Disable Relaxed Ordering for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|ba
operator|=
literal|0
expr_stmt|;
comment|/* PCIe Adddress Bits<63:34>. */
comment|/* Setup mem access 12-15 for port 0, 16-19 for port 1, supplying 36 bits of address space */
for|for
control|(
name|i
operator|=
literal|12
operator|+
name|pcie_port
operator|*
literal|4
init|;
name|i
operator|<
literal|16
operator|+
name|pcie_port
operator|*
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_MEM_ACCESS_SUBIDX
argument_list|(
name|i
argument_list|)
argument_list|,
name|mem_access_subid
operator|.
name|u64
argument_list|)
expr_stmt|;
name|mem_access_subid
operator|.
name|s
operator|.
name|ba
operator|+=
literal|1
expr_stmt|;
comment|/* Set each SUBID to extend the addressable range */
block|}
comment|/* Disable the peer to peer forwarding register. This must be setup         by the OS after it enumerates the bus and assigns addresses to the         PCIe busses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_P2P_BARX_START
argument_list|(
name|i
argument_list|,
name|pcie_port
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_P2P_BARX_END
argument_list|(
name|i
argument_list|,
name|pcie_port
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Set Octeon's BAR0 to decode 0-16KB. It overlaps with Bar2 */
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_P2N_BAR0_START
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* BAR1 follows BAR2 with a gap so it has the same address as for gen2. */
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_P2N_BAR1_START
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|CVMX_PCIE_BAR1_RC_BASE
argument_list|)
expr_stmt|;
name|bar1_index
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|bar1_index
operator|.
name|s
operator|.
name|addr_idx
operator|=
operator|(
name|CVMX_PCIE_BAR1_PHYS_BASE
operator|>>
literal|22
operator|)
expr_stmt|;
name|bar1_index
operator|.
name|s
operator|.
name|ca
operator|=
literal|1
expr_stmt|;
comment|/* Not Cached */
name|bar1_index
operator|.
name|s
operator|.
name|end_swp
operator|=
literal|1
expr_stmt|;
comment|/* Endian Swap mode */
name|bar1_index
operator|.
name|s
operator|.
name|addr_v
operator|=
literal|1
expr_stmt|;
comment|/* Valid entry */
name|base
operator|=
name|pcie_port
condition|?
literal|16
else|:
literal|0
expr_stmt|;
comment|/* Big endian swizzle for 32-bit PEXP_NCB register. */
ifdef|#
directive|ifdef
name|__MIPSEB__
name|addr_swizzle
operator|=
literal|4
expr_stmt|;
else|#
directive|else
name|addr_swizzle
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_write64_uint32
argument_list|(
operator|(
name|CVMX_PEXP_NPEI_BAR1_INDEXX
argument_list|(
name|base
argument_list|)
operator|^
name|addr_swizzle
operator|)
argument_list|,
name|bar1_index
operator|.
name|u32
argument_list|)
expr_stmt|;
name|base
operator|++
expr_stmt|;
comment|/* 256MB / 16>> 22 == 4 */
name|bar1_index
operator|.
name|s
operator|.
name|addr_idx
operator|+=
operator|(
operator|(
operator|(
literal|1ull
operator|<<
literal|28
operator|)
operator|/
literal|16ull
operator|)
operator|>>
literal|22
operator|)
expr_stmt|;
block|}
comment|/* Set Octeon's BAR2 to decode 0-2^39. Bar0 and Bar1 take precedence         where they overlap. It also overlaps with the device addresses, so         make sure the peer to peer forwarding is set right */
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_P2N_BAR2_START
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup BAR2 attributes */
comment|/* Relaxed Ordering (NPEI_CTL_PORTn[PTLP_RO,CTLP_RO, WAIT_COM]) */
comment|/* ­ PTLP_RO,CTLP_RO should normally be set (except for debug). */
comment|/* ­ WAIT_COM=0 will likely work for all applications. */
comment|/* Load completion relaxed ordering (NPEI_CTL_PORTn[WAITL_COM]) */
if|if
condition|(
name|pcie_port
condition|)
block|{
name|cvmx_npei_ctl_port1_t
name|npei_ctl_port
decl_stmt|;
name|npei_ctl_port
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_PORT1
argument_list|)
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_enb
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_esx
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_cax
operator|=
literal|0
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|ptlp_ro
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|ctlp_ro
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|wait_com
operator|=
literal|0
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|waitl_com
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_PORT1
argument_list|,
name|npei_ctl_port
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_npei_ctl_port0_t
name|npei_ctl_port
decl_stmt|;
name|npei_ctl_port
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_PORT0
argument_list|)
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_enb
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_esx
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_cax
operator|=
literal|0
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|ptlp_ro
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|ctlp_ro
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|wait_com
operator|=
literal|0
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|waitl_com
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_PORT0
argument_list|,
name|npei_ctl_port
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Both pass 1 and pass 2 of CN52XX and CN56XX have an errata that causes         TLP ordering to not be preserved after multiple PCIe port resets. This         code detects this fault and corrects it by aligning the TLP counters         properly. Another link reset is then performed. See PCIE-13340 */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS2_X
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS2_X
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS1_X
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
condition|)
block|{
name|cvmx_npei_dbg_data_t
name|dbg_data
decl_stmt|;
name|int
name|old_in_fif_p_count
decl_stmt|;
name|int
name|in_fif_p_count
decl_stmt|;
name|int
name|out_p_count
decl_stmt|;
name|int
name|in_p_offset
init|=
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS1_X
argument_list|)
operator|)
condition|?
literal|4
else|:
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Choose a write address of 1MB. It should be harmless as all bars             haven't been setup */
name|uint64_t
name|write_address
init|=
operator|(
name|cvmx_pcie_get_mem_base_address
argument_list|(
name|pcie_port
argument_list|)
operator|+
literal|0x100000
operator|)
operator||
operator|(
literal|1ull
operator|<<
literal|63
operator|)
decl_stmt|;
comment|/* Make sure at least in_p_offset have been executed before we try and             read in_fif_p_count */
name|i
operator|=
name|in_p_offset
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|cvmx_write64_uint32
argument_list|(
name|write_address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/* Read the IN_FIF_P_COUNT from the debug select. IN_FIF_P_COUNT can be             unstable sometimes so read it twice with a write between the reads.             This way we can tell the value is good as it will increment by one             due to the write */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_SELECT
argument_list|,
operator|(
name|pcie_port
operator|)
condition|?
literal|0xd7fc
else|:
literal|0xcffc
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_SELECT
argument_list|)
expr_stmt|;
do|do
block|{
name|dbg_data
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_DATA
argument_list|)
expr_stmt|;
name|old_in_fif_p_count
operator|=
name|dbg_data
operator|.
name|s
operator|.
name|data
operator|&
literal|0xff
expr_stmt|;
name|cvmx_write64_uint32
argument_list|(
name|write_address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|dbg_data
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_DATA
argument_list|)
expr_stmt|;
name|in_fif_p_count
operator|=
name|dbg_data
operator|.
name|s
operator|.
name|data
operator|&
literal|0xff
expr_stmt|;
block|}
do|while
condition|(
name|in_fif_p_count
operator|!=
operator|(
operator|(
name|old_in_fif_p_count
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
condition|)
do|;
comment|/* Update in_fif_p_count for it's offset with respect to out_p_count */
name|in_fif_p_count
operator|=
operator|(
name|in_fif_p_count
operator|+
name|in_p_offset
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Read the OUT_P_COUNT from the debug select */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_SELECT
argument_list|,
operator|(
name|pcie_port
operator|)
condition|?
literal|0xd00f
else|:
literal|0xc80f
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_SELECT
argument_list|)
expr_stmt|;
name|dbg_data
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_DATA
argument_list|)
expr_stmt|;
name|out_p_count
operator|=
operator|(
name|dbg_data
operator|.
name|s
operator|.
name|data
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Check that the two counters are aligned */
if|if
condition|(
name|out_p_count
operator|!=
name|in_fif_p_count
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d aligning TLP counters as workaround to maintain ordering\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
while|while
condition|(
name|in_fif_p_count
operator|!=
literal|0
condition|)
block|{
name|cvmx_write64_uint32
argument_list|(
name|write_address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|in_fif_p_count
operator|=
operator|(
name|in_fif_p_count
operator|+
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* The EBH5200 board swapped the PCIe reset lines on the board. This                 means we must bring both links down and up, which will cause the                 PCIe0 to need alignment again. Lots of messages will be displayed,                 but everything should work */
if|if
condition|(
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBH5200
operator|)
operator|&&
operator|(
name|pcie_port
operator|==
literal|1
operator|)
condition|)
name|cvmx_pcie_rc_initialize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Rety bringing this port up */
goto|goto
name|retry
goto|;
block|}
block|}
comment|/* Display the link status */
name|pciercx_cfg032
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG032
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d link active, %d lanes\n"
argument_list|,
name|pcie_port
argument_list|,
name|pciercx_cfg032
operator|.
name|s
operator|.
name|nlw
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Initialize a host mode PCIe gen 2 link. This function takes a PCIe  * port from reset to a link up state. Software can then begin  * configuring the rest of the link.  *  * @param pcie_port PCIe port to initialize  *  * @return Zero on success  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_pcie_rc_initialize_link_gen2
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|uint64_t
name|start_cycle
decl_stmt|;
name|cvmx_pemx_ctl_status_t
name|pem_ctl_status
decl_stmt|;
name|cvmx_pciercx_cfg032_t
name|pciercx_cfg032
decl_stmt|;
name|cvmx_pciercx_cfg448_t
name|pciercx_cfg448
decl_stmt|;
comment|/* Bring up the link */
name|pem_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEMX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pem_ctl_status
operator|.
name|s
operator|.
name|lnk_enb
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEMX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pem_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait for the link to come up */
name|start_cycle
operator|=
name|cvmx_get_cycle
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cvmx_get_cycle
argument_list|()
operator|-
name|start_cycle
operator|>
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|pciercx_cfg032
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG032
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|pciercx_cfg032
operator|.
name|s
operator|.
name|dlla
operator|==
literal|0
operator|)
operator|||
operator|(
name|pciercx_cfg032
operator|.
name|s
operator|.
name|lt
operator|==
literal|1
operator|)
condition|)
do|;
comment|/* Update the Replay Time Limit. Empirically, some PCIe devices take a         little longer to respond than expected under load. As a workaround for         this we configure the Replay Time Limit to the value expected for a 512         byte MPS instead of our actual 256 byte MPS. The numbers below are         directly from the PCIe spec table 3-4 */
name|pciercx_cfg448
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG448
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pciercx_cfg032
operator|.
name|s
operator|.
name|nlw
condition|)
block|{
case|case
literal|1
case|:
comment|/* 1 lane */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|1677
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 2 lanes */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|867
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* 4 lanes */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|462
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* 8 lanes */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|258
expr_stmt|;
break|break;
block|}
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG448
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg448
operator|.
name|u32
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a PCIe gen 2 port for use in host(RC) mode. It doesn't enumerate  * the bus.  *  * @param pcie_port PCIe port to initialize  *  * @return Zero on success  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_pcie_rc_initialize_gen2
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cvmx_ciu_soft_prst_t
name|ciu_soft_prst
decl_stmt|;
name|cvmx_mio_rst_ctlx_t
name|mio_rst_ctl
decl_stmt|;
name|cvmx_pemx_bar_ctl_t
name|pemx_bar_ctl
decl_stmt|;
name|cvmx_pemx_ctl_status_t
name|pemx_ctl_status
decl_stmt|;
name|cvmx_pemx_bist_status_t
name|pemx_bist_status
decl_stmt|;
name|cvmx_pemx_bist_status2_t
name|pemx_bist_status2
decl_stmt|;
name|cvmx_pciercx_cfg032_t
name|pciercx_cfg032
decl_stmt|;
name|cvmx_pciercx_cfg515_t
name|pciercx_cfg515
decl_stmt|;
name|cvmx_sli_ctl_portx_t
name|sli_ctl_portx
decl_stmt|;
name|cvmx_sli_mem_access_ctl_t
name|sli_mem_access_ctl
decl_stmt|;
name|cvmx_sli_mem_access_subidx_t
name|mem_access_subid
decl_stmt|;
name|cvmx_pemx_bar1_indexx_t
name|bar1_index
decl_stmt|;
name|int
name|ep_mode
decl_stmt|;
comment|/* Make sure this interface is PCIe */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
condition|)
block|{
comment|/* Requires reading the MIO_QLMX_CFG register to figure            out the port type. */
name|int
name|qlm
init|=
name|pcie_port
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
name|qlm
operator|=
literal|3
operator|-
operator|(
name|pcie_port
operator|*
literal|2
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
condition|)
block|{
name|cvmx_mio_qlmx_cfg_t
name|qlm_cfg
decl_stmt|;
name|qlm_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_QLMX_CFG
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qlm_cfg
operator|.
name|s
operator|.
name|qlm_cfg
operator|==
literal|1
condition|)
name|qlm
operator|=
literal|1
expr_stmt|;
block|}
comment|/* PCIe is allowed only in QLM1, 1 PCIe port in x2 or             2 PCIe ports in x1 */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
condition|)
name|qlm
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|cvmx_qlm_get_status
argument_list|(
name|qlm
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|4
operator|||
name|status
operator|==
literal|5
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d is SRIO, skipping.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d is SGMII, skipping.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|status
operator|==
literal|2
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d is XAUI, skipping.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|status
operator|==
operator|-
literal|1
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d is unknown, skipping.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* This code is so that the PCIe analyzer is able to see 63XX traffic */
block|cvmx_dprintf("PCIE : init for pcie analyzer.\n");     cvmx_helper_qlm_jtag_init();     cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 85);     cvmx_helper_qlm_jtag_shift(pcie_port, 1, 1);     cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 300-86);     cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 85);     cvmx_helper_qlm_jtag_shift(pcie_port, 1, 1);     cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 300-86);     cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 85);     cvmx_helper_qlm_jtag_shift(pcie_port, 1, 1);     cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 300-86);     cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 85);     cvmx_helper_qlm_jtag_shift(pcie_port, 1, 1);     cvmx_helper_qlm_jtag_shift_zeros(pcie_port, 300-86);     cvmx_helper_qlm_jtag_update(pcie_port);
endif|#
directive|endif
comment|/* Make sure we aren't trying to setup a target mode interface in host mode */
name|mio_rst_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_RST_CTLX
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|ep_mode
operator|=
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
argument_list|)
condition|?
operator|(
name|mio_rst_ctl
operator|.
name|s
operator|.
name|prtmode
operator|!=
literal|1
operator|)
else|:
operator|(
operator|!
name|mio_rst_ctl
operator|.
name|s
operator|.
name|host_mode
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ep_mode
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d in endpoint mode.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis be programmed */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_0
argument_list|)
condition|)
block|{
if|if
condition|(
name|pcie_port
condition|)
block|{
name|cvmx_ciu_qlm1_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM1
argument_list|)
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|5
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
literal|0x17
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM1
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_ciu_qlm0_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM0
argument_list|)
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|5
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
literal|0x17
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM0
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Bring the PCIe out of reset */
if|if
condition|(
name|pcie_port
condition|)
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
else|else
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
comment|/* After a chip reset the PCIe will also be in reset. If it isn't,         most likely someone is trying to init it again without a proper         PCIe reset */
if|if
condition|(
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|==
literal|0
condition|)
block|{
comment|/* Reset the port */
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pcie_port
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait until pcie resets the ports. */
name|cvmx_wait_usec
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pcie_port
condition|)
block|{
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Wait for PCIe reset to complete */
name|cvmx_wait_usec
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Check and make sure PCIe came out of reset. If it doesn't the board         probably hasn't wired the clocks up and the interface should be         skipped */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_MIO_RST_CTLX
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|cvmx_mio_rst_ctlx_t
argument_list|,
name|rst_done
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d stuck in reset, skipping.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check BIST status */
name|pemx_bist_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEMX_BIST_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pemx_bist_status
operator|.
name|u64
condition|)
name|cvmx_dprintf
argument_list|(
literal|"PCIe: BIST FAILED for port %d (0x%016llx)\n"
argument_list|,
name|pcie_port
argument_list|,
name|CAST64
argument_list|(
name|pemx_bist_status
operator|.
name|u64
argument_list|)
argument_list|)
expr_stmt|;
name|pemx_bist_status2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEMX_BIST_STATUS2
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Errata PCIE-14766 may cause the lower 6 bits to be randomly set on CN63XXp1 */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
name|pemx_bist_status2
operator|.
name|u64
operator|&=
operator|~
literal|0x3full
expr_stmt|;
if|if
condition|(
name|pemx_bist_status2
operator|.
name|u64
condition|)
name|cvmx_dprintf
argument_list|(
literal|"PCIe: BIST2 FAILED for port %d (0x%016llx)\n"
argument_list|,
name|pcie_port
argument_list|,
name|CAST64
argument_list|(
name|pemx_bist_status2
operator|.
name|u64
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the config space CSRs */
name|__cvmx_pcie_rc_initialize_config_space
argument_list|(
name|pcie_port
argument_list|)
expr_stmt|;
comment|/* Enable gen2 speed selection */
name|pciercx_cfg515
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG515
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg515
operator|.
name|s
operator|.
name|dsc
operator|=
literal|1
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG515
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg515
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|/* Bring the link up */
if|if
condition|(
name|__cvmx_pcie_rc_initialize_link_gen2
argument_list|(
name|pcie_port
argument_list|)
condition|)
block|{
comment|/* Some gen1 devices don't handle the gen 2 training correctly. Disable             gen2 and try again with only gen1 */
name|cvmx_pciercx_cfg031_t
name|pciercx_cfg031
decl_stmt|;
name|pciercx_cfg031
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG031
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg031
operator|.
name|s
operator|.
name|mls
operator|=
literal|1
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG031
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg031
operator|.
name|u32
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_pcie_rc_initialize_link_gen2
argument_list|(
name|pcie_port
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Link timeout on port %d, probably the slot is empty\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Store merge control (SLI_MEM_ACCESS_CTL[TIMER,MAX_WORD]) */
name|sli_mem_access_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_CTL
argument_list|)
expr_stmt|;
name|sli_mem_access_ctl
operator|.
name|s
operator|.
name|max_word
operator|=
literal|0
expr_stmt|;
comment|/* Allow 16 words to combine */
name|sli_mem_access_ctl
operator|.
name|s
operator|.
name|timer
operator|=
literal|127
expr_stmt|;
comment|/* Wait up to 127 cycles for more data */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_CTL
argument_list|,
name|sli_mem_access_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Setup Mem access SubDIDs */
name|mem_access_subid
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|mem_access_subid
operator|.
name|s
operator|.
name|port
operator|=
name|pcie_port
expr_stmt|;
comment|/* Port the request is sent to. */
name|mem_access_subid
operator|.
name|s
operator|.
name|nmerge
operator|=
literal|0
expr_stmt|;
comment|/* Allow merging as it works on CN6XXX. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esr
operator|=
literal|1
expr_stmt|;
comment|/* Endian-swap for Reads. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esw
operator|=
literal|1
expr_stmt|;
comment|/* Endian-swap for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|wtype
operator|=
literal|0
expr_stmt|;
comment|/* "No snoop" and "Relaxed ordering" are not set */
name|mem_access_subid
operator|.
name|s
operator|.
name|rtype
operator|=
literal|0
expr_stmt|;
comment|/* "No snoop" and "Relaxed ordering" are not set */
comment|/* PCIe Adddress Bits<63:34>. */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
name|mem_access_subid
operator|.
name|cn68xx
operator|.
name|ba
operator|=
literal|0
expr_stmt|;
else|else
name|mem_access_subid
operator|.
name|cn63xx
operator|.
name|ba
operator|=
literal|0
expr_stmt|;
comment|/* Setup mem access 12-15 for port 0, 16-19 for port 1, supplying 36 bits of address space */
for|for
control|(
name|i
operator|=
literal|12
operator|+
name|pcie_port
operator|*
literal|4
init|;
name|i
operator|<
literal|16
operator|+
name|pcie_port
operator|*
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX
argument_list|(
name|i
argument_list|)
argument_list|,
name|mem_access_subid
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Set each SUBID to extend the addressable range */
name|__cvmx_increment_ba
argument_list|(
operator|&
name|mem_access_subid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
condition|)
block|{
comment|/* Disable the peer to peer forwarding register. This must be setup             by the OS after it enumerates the bus and assigns addresses to the             PCIe busses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_PEMX_P2P_BARX_START
argument_list|(
name|i
argument_list|,
name|pcie_port
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEMX_P2P_BARX_END
argument_list|(
name|i
argument_list|,
name|pcie_port
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Set Octeon's BAR0 to decode 0-16KB. It overlaps with Bar2 */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEMX_P2N_BAR0_START
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set Octeon's BAR2 to decode 0-2^41. Bar0 and Bar1 take precedence         where they overlap. It also overlaps with the device addresses, so         make sure the peer to peer forwarding is set right */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEMX_P2N_BAR2_START
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup BAR2 attributes */
comment|/* Relaxed Ordering (NPEI_CTL_PORTn[PTLP_RO,CTLP_RO, WAIT_COM]) */
comment|/* ­ PTLP_RO,CTLP_RO should normally be set (except for debug). */
comment|/* ­ WAIT_COM=0 will likely work for all applications. */
comment|/* Load completion relaxed ordering (NPEI_CTL_PORTn[WAITL_COM]) */
name|pemx_bar_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEMX_BAR_CTL
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pemx_bar_ctl
operator|.
name|s
operator|.
name|bar1_siz
operator|=
literal|3
expr_stmt|;
comment|/* 256MB BAR1*/
name|pemx_bar_ctl
operator|.
name|s
operator|.
name|bar2_enb
operator|=
literal|1
expr_stmt|;
name|pemx_bar_ctl
operator|.
name|s
operator|.
name|bar2_esx
operator|=
literal|1
expr_stmt|;
name|pemx_bar_ctl
operator|.
name|s
operator|.
name|bar2_cax
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEMX_BAR_CTL
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pemx_bar_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|sli_ctl_portx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_CTL_PORTX
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|sli_ctl_portx
operator|.
name|s
operator|.
name|ptlp_ro
operator|=
literal|1
expr_stmt|;
name|sli_ctl_portx
operator|.
name|s
operator|.
name|ctlp_ro
operator|=
literal|1
expr_stmt|;
name|sli_ctl_portx
operator|.
name|s
operator|.
name|wait_com
operator|=
literal|0
expr_stmt|;
name|sli_ctl_portx
operator|.
name|s
operator|.
name|waitl_com
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_CTL_PORTX
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|sli_ctl_portx
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* BAR1 follows BAR2 */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEMX_P2N_BAR1_START
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|CVMX_PCIE_BAR1_RC_BASE
argument_list|)
expr_stmt|;
name|bar1_index
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|bar1_index
operator|.
name|s
operator|.
name|addr_idx
operator|=
operator|(
name|CVMX_PCIE_BAR1_PHYS_BASE
operator|>>
literal|22
operator|)
expr_stmt|;
name|bar1_index
operator|.
name|s
operator|.
name|ca
operator|=
literal|1
expr_stmt|;
comment|/* Not Cached */
name|bar1_index
operator|.
name|s
operator|.
name|end_swp
operator|=
literal|1
expr_stmt|;
comment|/* Endian Swap mode */
name|bar1_index
operator|.
name|s
operator|.
name|addr_v
operator|=
literal|1
expr_stmt|;
comment|/* Valid entry */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_PEMX_BAR1_INDEXX
argument_list|(
name|i
argument_list|,
name|pcie_port
argument_list|)
argument_list|,
name|bar1_index
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 256MB / 16>> 22 == 4 */
name|bar1_index
operator|.
name|s
operator|.
name|addr_idx
operator|+=
operator|(
operator|(
operator|(
literal|1ull
operator|<<
literal|28
operator|)
operator|/
literal|16ull
operator|)
operator|>>
literal|22
operator|)
expr_stmt|;
block|}
comment|/* Allow config retries for 250ms. Count is based off the 5Ghz SERDES         clock */
name|pemx_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEMX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pemx_ctl_status
operator|.
name|s
operator|.
name|cfg_rtry
operator|=
literal|250
operator|*
literal|5000000
operator|/
literal|0x10000
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEMX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pemx_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Display the link status */
name|pciercx_cfg032
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG032
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d link active, %d lanes, speed gen%d\n"
argument_list|,
name|pcie_port
argument_list|,
name|pciercx_cfg032
operator|.
name|s
operator|.
name|nlw
argument_list|,
name|pciercx_cfg032
operator|.
name|s
operator|.
name|ls
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a PCIe port for use in host(RC) mode. It doesn't enumerate the bus.  *  * @param pcie_port PCIe port to initialize  *  * @return Zero on success  */
end_comment

begin_function
name|int
name|cvmx_pcie_rc_initialize
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
name|result
operator|=
name|__cvmx_pcie_rc_initialize_gen1
argument_list|(
name|pcie_port
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|__cvmx_pcie_rc_initialize_gen2
argument_list|(
name|pcie_port
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|CONFIG_CAVIUM_DECODE_RSL
argument_list|)
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_PCI
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * Shutdown a PCIe port and put it in reset  *  * @param pcie_port PCIe port to shutdown  *  * @return Zero on success  */
end_comment

begin_function
name|int
name|cvmx_pcie_rc_shutdown
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|CONFIG_CAVIUM_DECODE_RSL
argument_list|)
name|cvmx_error_disable_group
argument_list|(
name|CVMX_ERROR_GROUP_PCI
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Wait for all pending operations to complete */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PESCX_CPL_LUT_VALID
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|cvmx_pescx_cpl_lut_valid_t
argument_list|,
name|tag
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|2000
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d shutdown timeout\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PEMX_CPL_LUT_VALID
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|cvmx_pemx_cpl_lut_valid_t
argument_list|,
name|tag
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|2000
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d shutdown timeout\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
block|}
comment|/* Force reset */
if|if
condition|(
name|pcie_port
condition|)
block|{
name|cvmx_ciu_soft_prst_t
name|ciu_soft_prst
decl_stmt|;
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_ciu_soft_prst_t
name|ciu_soft_prst
decl_stmt|;
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Build a PCIe config space request address for a device  *  * @param pcie_port PCIe port to access  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  *  * @return 64bit Octeon IO address  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|__cvmx_pcie_build_config_addr
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|cvmx_pcie_address_t
name|pcie_addr
decl_stmt|;
name|cvmx_pciercx_cfg006_t
name|pciercx_cfg006
decl_stmt|;
name|pciercx_cfg006
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG006
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bus
operator|<=
name|pciercx_cfg006
operator|.
name|s
operator|.
name|pbnum
operator|)
operator|&&
operator|(
name|dev
operator|!=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
name|pcie_addr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|upper
operator|=
literal|2
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|io
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|did
operator|=
literal|3
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|subdid
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|es
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|port
operator|=
name|pcie_port
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|ty
operator|=
operator|(
name|bus
operator|>
name|pciercx_cfg006
operator|.
name|s
operator|.
name|pbnum
operator|)
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|bus
operator|=
name|bus
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|func
operator|=
name|fn
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
return|return
name|pcie_addr
operator|.
name|u64
return|;
block|}
end_function

begin_comment
comment|/**  * Read 8bits from a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  *  * @return Result of the read  */
end_comment

begin_function
name|uint8_t
name|cvmx_pcie_config_read8
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
return|return
name|cvmx_read64_uint8
argument_list|(
name|address
argument_list|)
return|;
else|else
return|return
literal|0xff
return|;
block|}
end_function

begin_comment
comment|/**  * Read 16bits from a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  *  * @return Result of the read  */
end_comment

begin_function
name|uint16_t
name|cvmx_pcie_config_read16
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
return|return
name|cvmx_le16_to_cpu
argument_list|(
name|cvmx_read64_uint16
argument_list|(
name|address
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/**  * Read 32bits from a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  *  * @return Result of the read  */
end_comment

begin_function
name|uint32_t
name|cvmx_pcie_config_read32
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
return|return
name|cvmx_le32_to_cpu
argument_list|(
name|cvmx_read64_uint32
argument_list|(
name|address
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|0xffffffff
return|;
block|}
end_function

begin_comment
comment|/**  * Write 8bits to a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  * @param val       Value to write  */
end_comment

begin_function
name|void
name|cvmx_pcie_config_write8
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
name|cvmx_write64_uint8
argument_list|(
name|address
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Write 16bits to a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  * @param val       Value to write  */
end_comment

begin_function
name|void
name|cvmx_pcie_config_write16
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
name|cvmx_write64_uint16
argument_list|(
name|address
argument_list|,
name|cvmx_cpu_to_le16
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Write 32bits to a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  * @param val       Value to write  */
end_comment

begin_function
name|void
name|cvmx_pcie_config_write32
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
name|cvmx_write64_uint32
argument_list|(
name|address
argument_list|,
name|cvmx_cpu_to_le32
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read a PCIe config space register indirectly. This is used for  * registers of the form PCIEEP_CFG??? and PCIERC?_CFG???.  *  * @param pcie_port  PCIe port to read from  * @param cfg_offset Address to read  *  * @return Value read  */
end_comment

begin_function
name|uint32_t
name|cvmx_pcie_cfgx_read
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|uint32_t
name|cfg_offset
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
name|cvmx_pescx_cfg_rd_t
name|pescx_cfg_rd
decl_stmt|;
name|pescx_cfg_rd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pescx_cfg_rd
operator|.
name|s
operator|.
name|addr
operator|=
name|cfg_offset
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_CFG_RD
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pescx_cfg_rd
operator|.
name|u64
argument_list|)
expr_stmt|;
name|pescx_cfg_rd
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_CFG_RD
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pescx_cfg_rd
operator|.
name|s
operator|.
name|data
return|;
block|}
else|else
block|{
name|cvmx_pemx_cfg_rd_t
name|pemx_cfg_rd
decl_stmt|;
name|pemx_cfg_rd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pemx_cfg_rd
operator|.
name|s
operator|.
name|addr
operator|=
name|cfg_offset
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEMX_CFG_RD
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pemx_cfg_rd
operator|.
name|u64
argument_list|)
expr_stmt|;
name|pemx_cfg_rd
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEMX_CFG_RD
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pemx_cfg_rd
operator|.
name|s
operator|.
name|data
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Write a PCIe config space register indirectly. This is used for  * registers of the form PCIEEP_CFG??? and PCIERC?_CFG???.  *  * @param pcie_port  PCIe port to write to  * @param cfg_offset Address to write  * @param val        Value to write  */
end_comment

begin_function
name|void
name|cvmx_pcie_cfgx_write
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|uint32_t
name|cfg_offset
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
name|cvmx_pescx_cfg_wr_t
name|pescx_cfg_wr
decl_stmt|;
name|pescx_cfg_wr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pescx_cfg_wr
operator|.
name|s
operator|.
name|addr
operator|=
name|cfg_offset
expr_stmt|;
name|pescx_cfg_wr
operator|.
name|s
operator|.
name|data
operator|=
name|val
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_CFG_WR
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pescx_cfg_wr
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_pemx_cfg_wr_t
name|pemx_cfg_wr
decl_stmt|;
name|pemx_cfg_wr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pemx_cfg_wr
operator|.
name|s
operator|.
name|addr
operator|=
name|cfg_offset
expr_stmt|;
name|pemx_cfg_wr
operator|.
name|s
operator|.
name|data
operator|=
name|val
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEMX_CFG_WR
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pemx_cfg_wr
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Initialize a PCIe port for use in target(EP) mode.  *  * @param pcie_port PCIe port to initialize  *  * @return Zero on success  */
end_comment

begin_function
name|int
name|cvmx_pcie_ep_initialize
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
name|cvmx_npei_ctl_status_t
name|npei_ctl_status
decl_stmt|;
name|npei_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|npei_ctl_status
operator|.
name|s
operator|.
name|host_mode
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|cvmx_mio_rst_ctlx_t
name|mio_rst_ctl
decl_stmt|;
name|int
name|ep_mode
decl_stmt|;
name|mio_rst_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_RST_CTLX
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|ep_mode
operator|=
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
condition|?
operator|(
name|mio_rst_ctl
operator|.
name|s
operator|.
name|prtmode
operator|!=
literal|0
operator|)
else|:
name|mio_rst_ctl
operator|.
name|s
operator|.
name|host_mode
operator|)
expr_stmt|;
if|if
condition|(
name|ep_mode
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis be programmed */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_0
argument_list|)
condition|)
block|{
if|if
condition|(
name|pcie_port
condition|)
block|{
name|cvmx_ciu_qlm1_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM1
argument_list|)
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|5
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
literal|0x17
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM1
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_ciu_qlm0_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM0
argument_list|)
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|5
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
literal|0x17
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM0
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enable bus master and memory */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIEEPX_CFG001
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
comment|/* Max Payload Size (PCIE*_CFG030[MPS]) */
comment|/* Max Read Request Size (PCIE*_CFG030[MRRS]) */
comment|/* Relaxed-order, no-snoop enables (PCIE*_CFG030[RO_EN,NS_EN] */
comment|/* Error Message Enables (PCIE*_CFG030[CE_EN,NFE_EN,FE_EN,UR_EN]) */
block|{
name|cvmx_pcieepx_cfg030_t
name|pcieepx_cfg030
decl_stmt|;
name|pcieepx_cfg030
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIEEPX_CFG030
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
block|{
name|pcieepx_cfg030
operator|.
name|s
operator|.
name|mps
operator|=
name|MPS_CN5XXX
expr_stmt|;
name|pcieepx_cfg030
operator|.
name|s
operator|.
name|mrrs
operator|=
name|MRRS_CN5XXX
expr_stmt|;
block|}
else|else
block|{
name|pcieepx_cfg030
operator|.
name|s
operator|.
name|mps
operator|=
name|MPS_CN6XXX
expr_stmt|;
name|pcieepx_cfg030
operator|.
name|s
operator|.
name|mrrs
operator|=
name|MRRS_CN6XXX
expr_stmt|;
block|}
name|pcieepx_cfg030
operator|.
name|s
operator|.
name|ro_en
operator|=
literal|1
expr_stmt|;
comment|/* Enable relaxed ordering. */
name|pcieepx_cfg030
operator|.
name|s
operator|.
name|ns_en
operator|=
literal|1
expr_stmt|;
comment|/* Enable no snoop. */
name|pcieepx_cfg030
operator|.
name|s
operator|.
name|ce_en
operator|=
literal|1
expr_stmt|;
comment|/* Correctable error reporting enable. */
name|pcieepx_cfg030
operator|.
name|s
operator|.
name|nfe_en
operator|=
literal|1
expr_stmt|;
comment|/* Non-fatal error reporting enable. */
name|pcieepx_cfg030
operator|.
name|s
operator|.
name|fe_en
operator|=
literal|1
expr_stmt|;
comment|/* Fatal error reporting enable. */
name|pcieepx_cfg030
operator|.
name|s
operator|.
name|ur_en
operator|=
literal|1
expr_stmt|;
comment|/* Unsupported request reporting enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIEEPX_CFG030
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pcieepx_cfg030
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
comment|/* Max Payload Size (NPEI_CTL_STATUS2[MPS]) must match PCIE*_CFG030[MPS] */
comment|/* Max Read Request Size (NPEI_CTL_STATUS2[MRRS]) must not exceed PCIE*_CFG030[MRRS] */
name|cvmx_npei_ctl_status2_t
name|npei_ctl_status2
decl_stmt|;
name|npei_ctl_status2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS2
argument_list|)
expr_stmt|;
name|npei_ctl_status2
operator|.
name|s
operator|.
name|mps
operator|=
name|MPS_CN5XXX
expr_stmt|;
comment|/* Max payload size = 128 bytes (Limit of most PCs) */
name|npei_ctl_status2
operator|.
name|s
operator|.
name|mrrs
operator|=
name|MRRS_CN5XXX
expr_stmt|;
comment|/* Max read request size = 128 bytes for best Octeon DMA performance */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS2
argument_list|,
name|npei_ctl_status2
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Max Payload Size (DPI_SLI_PRTX_CFG[MPS]) must match PCIE*_CFG030[MPS] */
comment|/* Max Read Request Size (DPI_SLI_PRTX_CFG[MRRS]) must not exceed PCIE*_CFG030[MRRS] */
name|cvmx_dpi_sli_prtx_cfg_t
name|prt_cfg
decl_stmt|;
name|cvmx_sli_s2m_portx_ctl_t
name|sli_s2m_portx_ctl
decl_stmt|;
name|prt_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DPI_SLI_PRTX_CFG
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|prt_cfg
operator|.
name|s
operator|.
name|mps
operator|=
name|MPS_CN6XXX
expr_stmt|;
name|prt_cfg
operator|.
name|s
operator|.
name|mrrs
operator|=
name|MRRS_CN6XXX
expr_stmt|;
comment|/* Max outstanding load request. */
name|prt_cfg
operator|.
name|s
operator|.
name|molr
operator|=
literal|32
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_SLI_PRTX_CFG
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|prt_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|sli_s2m_portx_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_S2M_PORTX_CTL
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|sli_s2m_portx_ctl
operator|.
name|s
operator|.
name|mrrs
operator|=
name|MRRS_CN6XXX
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_S2M_PORTX_CTL
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|sli_s2m_portx_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Setup Mem access SubDID 12 to access Host memory */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
name|cvmx_npei_mem_access_subidx_t
name|mem_access_subid
decl_stmt|;
name|mem_access_subid
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|mem_access_subid
operator|.
name|s
operator|.
name|port
operator|=
name|pcie_port
expr_stmt|;
comment|/* Port the request is sent to. */
name|mem_access_subid
operator|.
name|s
operator|.
name|nmerge
operator|=
literal|1
expr_stmt|;
comment|/* Merging is not allowed in this window. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esr
operator|=
literal|0
expr_stmt|;
comment|/* Endian-swap for Reads. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esw
operator|=
literal|0
expr_stmt|;
comment|/* Endian-swap for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|nsr
operator|=
literal|0
expr_stmt|;
comment|/* Enable Snooping for Reads. Octeon doesn't care, but devices might want this more conservative setting */
name|mem_access_subid
operator|.
name|s
operator|.
name|nsw
operator|=
literal|0
expr_stmt|;
comment|/* Enable Snoop for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|ror
operator|=
literal|0
expr_stmt|;
comment|/* Disable Relaxed Ordering for Reads. */
name|mem_access_subid
operator|.
name|s
operator|.
name|row
operator|=
literal|0
expr_stmt|;
comment|/* Disable Relaxed Ordering for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|ba
operator|=
literal|0
expr_stmt|;
comment|/* PCIe Adddress Bits<63:34>. */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_MEM_ACCESS_SUBIDX
argument_list|(
literal|12
argument_list|)
argument_list|,
name|mem_access_subid
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_sli_mem_access_subidx_t
name|mem_access_subid
decl_stmt|;
name|mem_access_subid
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|mem_access_subid
operator|.
name|s
operator|.
name|port
operator|=
name|pcie_port
expr_stmt|;
comment|/* Port the request is sent to. */
name|mem_access_subid
operator|.
name|s
operator|.
name|nmerge
operator|=
literal|0
expr_stmt|;
comment|/* Merging is allowed in this window. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esr
operator|=
literal|0
expr_stmt|;
comment|/* Endian-swap for Reads. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esw
operator|=
literal|0
expr_stmt|;
comment|/* Endian-swap for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|wtype
operator|=
literal|0
expr_stmt|;
comment|/* "No snoop" and "Relaxed ordering" are not set */
name|mem_access_subid
operator|.
name|s
operator|.
name|rtype
operator|=
literal|0
expr_stmt|;
comment|/* "No snoop" and "Relaxed ordering" are not set */
comment|/* PCIe Adddress Bits<63:34>. */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
name|mem_access_subid
operator|.
name|cn68xx
operator|.
name|ba
operator|=
literal|0
expr_stmt|;
else|else
name|mem_access_subid
operator|.
name|cn63xx
operator|.
name|ba
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX
argument_list|(
literal|12
operator|+
name|pcie_port
operator|*
literal|4
argument_list|)
argument_list|,
name|mem_access_subid
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Wait for posted PCIe read/writes to reach the other side of  * the internal PCIe switch. This will insure that core  * read/writes are posted before anything after this function  * is called. This may be necessary when writing to memory that  * will later be read using the DMA/PKT engines.  *  * @param pcie_port PCIe port to wait for  */
end_comment

begin_function
name|void
name|cvmx_pcie_wait_for_pending
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NPEI
argument_list|)
condition|)
block|{
name|cvmx_npei_data_out_cnt_t
name|npei_data_out_cnt
decl_stmt|;
name|int
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* See section 9.8, PCIe Core-initiated Requests, in the manual for a             description of how this code works */
name|npei_data_out_cnt
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DATA_OUT_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_port
condition|)
block|{
if|if
condition|(
operator|!
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p1_fcnt
condition|)
return|return;
name|a
operator|=
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p1_ucnt
expr_stmt|;
name|b
operator|=
operator|(
name|a
operator|+
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p1_fcnt
operator|-
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p0_fcnt
condition|)
return|return;
name|a
operator|=
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p0_ucnt
expr_stmt|;
name|b
operator|=
operator|(
name|a
operator|+
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p0_fcnt
operator|-
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|npei_data_out_cnt
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DATA_OUT_CNT
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|pcie_port
operator|)
condition|?
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p1_ucnt
else|:
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p0_ucnt
expr_stmt|;
if|if
condition|(
name|a
operator|<=
name|b
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|<
name|a
operator|)
operator|||
operator|(
name|c
operator|>
name|b
operator|)
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|c
operator|>
name|b
operator|)
operator|&&
operator|(
name|c
operator|<
name|a
operator|)
condition|)
return|return;
block|}
block|}
block|}
else|else
block|{
name|cvmx_sli_data_out_cnt_t
name|sli_data_out_cnt
decl_stmt|;
name|int
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
name|int
name|c
decl_stmt|;
name|sli_data_out_cnt
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_DATA_OUT_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_port
condition|)
block|{
if|if
condition|(
operator|!
name|sli_data_out_cnt
operator|.
name|s
operator|.
name|p1_fcnt
condition|)
return|return;
name|a
operator|=
name|sli_data_out_cnt
operator|.
name|s
operator|.
name|p1_ucnt
expr_stmt|;
name|b
operator|=
operator|(
name|a
operator|+
name|sli_data_out_cnt
operator|.
name|s
operator|.
name|p1_fcnt
operator|-
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|sli_data_out_cnt
operator|.
name|s
operator|.
name|p0_fcnt
condition|)
return|return;
name|a
operator|=
name|sli_data_out_cnt
operator|.
name|s
operator|.
name|p0_ucnt
expr_stmt|;
name|b
operator|=
operator|(
name|a
operator|+
name|sli_data_out_cnt
operator|.
name|s
operator|.
name|p0_fcnt
operator|-
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|sli_data_out_cnt
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_DATA_OUT_CNT
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|pcie_port
operator|)
condition|?
name|sli_data_out_cnt
operator|.
name|s
operator|.
name|p1_ucnt
else|:
name|sli_data_out_cnt
operator|.
name|s
operator|.
name|p0_ucnt
expr_stmt|;
if|if
condition|(
name|a
operator|<=
name|b
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|<
name|a
operator|)
operator|||
operator|(
name|c
operator|>
name|b
operator|)
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|c
operator|>
name|b
operator|)
operator|&&
operator|(
name|c
operator|<
name|a
operator|)
condition|)
return|return;
block|}
block|}
block|}
block|}
end_function

end_unit

