begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright 1987,1989 by the Massachusetts Institute of Technology.  *  * For copying and distribution information, please see the file  *<mit-copyright.h>.  *  *	from: acl_files.c,v 4.4 89/12/19 13:30:53 jtkohl Exp $  * $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char rcsid[] = "$FreeBSD$";
endif|#
directive|endif
endif|lint
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*** Routines for manipulating access control list files ***/
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"krb.h"
end_include

begin_decl_stmt
name|__BEGIN_DECLS
specifier|static
name|int
name|acl_abort
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|__END_DECLS
ifndef|#
directive|ifndef
name|KRB_REALM
define|#
directive|define
name|KRB_REALM
value|"ATHENA.MIT.EDU"
endif|#
directive|endif
comment|/* "aname.inst@realm" */
define|#
directive|define
name|MAX_PRINCIPAL_SIZE
value|(ANAME_SZ + INST_SZ + REALM_SZ + 3)
define|#
directive|define
name|INST_SEP
value|'.'
define|#
directive|define
name|REALM_SEP
value|'@'
define|#
directive|define
name|LINESIZE
value|2048
comment|/* Maximum line length in an acl file */
define|#
directive|define
name|NEW_FILE
value|"%s.~NEWACL~"
comment|/* Format for name of altered acl file */
define|#
directive|define
name|WAIT_TIME
value|300
comment|/* Maximum time allowed write acl file */
define|#
directive|define
name|CACHED_ACLS
value|8
comment|/* How many acls to cache */
comment|/* Each acl costs 1 open file descriptor */
define|#
directive|define
name|ACL_LEN
value|16
comment|/* Twice a reasonable acl length */
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)>(b))?(a):(b))
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
define|#
directive|define
name|COR
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a!=NULL)?(a):(b))
comment|/* Canonicalize a principal name */
comment|/* If instance is missing, it becomes "" */
comment|/* If realm is missing, it becomes the local realm */
comment|/* Canonicalized form is put in canon, which must be big enough to hold    MAX_PRINCIPAL_SIZE characters */
name|void
name|acl_canonicalize_principal
parameter_list|(
name|principal
parameter_list|,
name|canon
parameter_list|)
name|char
modifier|*
name|principal
decl_stmt|;
name|char
modifier|*
name|canon
decl_stmt|;
block|{
name|char
modifier|*
name|dot
decl_stmt|,
modifier|*
name|atsign
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|len
decl_stmt|;
name|dot
operator|=
name|index
argument_list|(
name|principal
argument_list|,
name|INST_SEP
argument_list|)
expr_stmt|;
name|atsign
operator|=
name|index
argument_list|(
name|principal
argument_list|,
name|REALM_SEP
argument_list|)
expr_stmt|;
comment|/* Maybe we're done already */
if|if
condition|(
name|dot
operator|!=
name|NULL
operator|&&
name|atsign
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dot
operator|<
name|atsign
condition|)
block|{
comment|/* It's for real */
comment|/* Copy into canon */
name|strncpy
argument_list|(
name|canon
argument_list|,
name|principal
argument_list|,
name|MAX_PRINCIPAL_SIZE
argument_list|)
expr_stmt|;
name|canon
index|[
name|MAX_PRINCIPAL_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Nope, it's part of the realm */
name|dot
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* No such luck */
name|end
operator|=
name|principal
operator|+
name|strlen
argument_list|(
name|principal
argument_list|)
expr_stmt|;
comment|/* Get the principal name */
name|len
operator|=
name|MIN
argument_list|(
name|ANAME_SZ
argument_list|,
name|COR
argument_list|(
name|dot
argument_list|,
name|COR
argument_list|(
name|atsign
argument_list|,
name|end
argument_list|)
argument_list|)
operator|-
name|principal
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|canon
argument_list|,
name|principal
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|canon
operator|+=
name|len
expr_stmt|;
comment|/* Add INST_SEP */
operator|*
name|canon
operator|++
operator|=
name|INST_SEP
expr_stmt|;
comment|/* Get the instance, if it exists */
if|if
condition|(
name|dot
operator|!=
name|NULL
condition|)
block|{
operator|++
name|dot
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|INST_SZ
argument_list|,
name|COR
argument_list|(
name|atsign
argument_list|,
name|end
argument_list|)
operator|-
name|dot
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|canon
argument_list|,
name|dot
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|canon
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Add REALM_SEP */
operator|*
name|canon
operator|++
operator|=
name|REALM_SEP
expr_stmt|;
comment|/* Get the realm, if it exists */
comment|/* Otherwise, default to local realm */
if|if
condition|(
name|atsign
operator|!=
name|NULL
condition|)
block|{
operator|++
name|atsign
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|REALM_SZ
argument_list|,
name|end
operator|-
name|atsign
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|canon
argument_list|,
name|atsign
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|canon
operator|+=
name|len
expr_stmt|;
operator|*
name|canon
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|krb_get_lrealm
argument_list|(
name|canon
argument_list|,
literal|1
argument_list|)
operator|!=
name|KSUCCESS
condition|)
block|{
name|strcpy
argument_list|(
name|canon
argument_list|,
name|KRB_REALM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a lock to modify acl_file */
end_comment

begin_comment
comment|/* Return new FILE pointer */
end_comment

begin_comment
comment|/* or NULL if file cannot be modified */
end_comment

begin_comment
comment|/* REQUIRES WRITE PERMISSION TO CONTAINING DIRECTORY */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|acl_lock_file
parameter_list|(
name|acl_file
parameter_list|)
name|char
modifier|*
name|acl_file
decl_stmt|;
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|char
name|new
index|[
name|LINESIZE
index|]
decl_stmt|;
name|int
name|nfd
decl_stmt|;
name|FILE
modifier|*
name|nf
decl_stmt|;
name|int
name|mode
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|acl_file
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mode
operator|=
name|s
operator|.
name|st_mode
expr_stmt|;
name|sprintf
argument_list|(
name|new
argument_list|,
name|NEW_FILE
argument_list|,
name|acl_file
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Open the new file */
if|if
condition|(
operator|(
name|nfd
operator|=
name|open
argument_list|(
name|new
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
block|{
comment|/* Maybe somebody got here already, maybe it's just old */
if|if
condition|(
name|stat
argument_list|(
name|new
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|time
argument_list|(
literal|0
argument_list|)
operator|-
name|s
operator|.
name|st_ctime
operator|>
name|WAIT_TIME
condition|)
block|{
comment|/* File is stale, kill it */
name|unlink
argument_list|(
name|new
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* Wait and try again */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* Some other error, we lose */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* If we got to here, the lock file is ours and ok */
comment|/* Reopen it under stdio */
if|if
condition|(
operator|(
name|nf
operator|=
name|fdopen
argument_list|(
name|nfd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Oops, clean up */
name|unlink
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nf
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Commit changes to acl_file written onto FILE *f */
end_comment

begin_comment
comment|/* Returns zero if successful */
end_comment

begin_comment
comment|/* Returns> 0 if lock was broken */
end_comment

begin_comment
comment|/* Returns< 0 if some other error occurs */
end_comment

begin_comment
comment|/* Closes f */
end_comment

begin_function
specifier|static
name|int
name|acl_commit
parameter_list|(
name|acl_file
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|acl_file
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|char
name|new
index|[
name|LINESIZE
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|sprintf
argument_list|(
name|new
argument_list|,
name|NEW_FILE
argument_list|,
name|acl_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflush
argument_list|(
name|f
argument_list|)
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
operator|||
name|s
operator|.
name|st_nlink
operator|==
literal|0
condition|)
block|{
name|acl_abort
argument_list|(
name|acl_file
argument_list|,
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|rename
argument_list|(
name|new
argument_list|,
name|acl_file
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Abort changes to acl_file written onto FILE *f  * Returns 0 if successful,< 0 otherwise  * Closes f  */
end_comment

begin_function
specifier|static
name|int
name|acl_abort
parameter_list|(
name|acl_file
parameter_list|,
name|f
parameter_list|)
name|char
modifier|*
name|acl_file
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
name|char
name|new
index|[
name|LINESIZE
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
comment|/* make sure we aren't nuking someone else's file */
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
operator|||
name|s
operator|.
name|st_nlink
operator|==
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|new
argument_list|,
name|NEW_FILE
argument_list|,
name|acl_file
argument_list|)
expr_stmt|;
name|ret
operator|=
name|unlink
argument_list|(
name|new
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize an acl_file */
end_comment

begin_comment
comment|/* Creates the file with permissions perm if it does not exist */
end_comment

begin_comment
comment|/* Erases it if it does */
end_comment

begin_comment
comment|/* Returns return value of acl_commit */
end_comment

begin_function
name|int
name|acl_initialize
parameter_list|(
name|acl_file
parameter_list|,
name|perm
parameter_list|)
name|char
modifier|*
name|acl_file
decl_stmt|;
name|int
name|perm
decl_stmt|;
block|{
name|FILE
modifier|*
name|new
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* Check if the file exists already */
if|if
condition|(
operator|(
name|new
operator|=
name|acl_lock_file
argument_list|(
name|acl_file
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|acl_commit
argument_list|(
name|acl_file
argument_list|,
name|new
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* File must be readable and writable by owner */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|acl_file
argument_list|,
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|perm
operator||
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Eliminate all whitespace character in buf */
end_comment

begin_comment
comment|/* Modifies its argument */
end_comment

begin_function
specifier|static
name|void
name|nuke_whitespace
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|pin
decl_stmt|,
modifier|*
name|pout
decl_stmt|;
for|for
control|(
name|pin
operator|=
name|pout
operator|=
name|buf
init|;
operator|*
name|pin
operator|!=
literal|'\0'
condition|;
name|pin
operator|++
control|)
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|pin
argument_list|)
condition|)
operator|*
name|pout
operator|++
operator|=
operator|*
name|pin
expr_stmt|;
operator|*
name|pout
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate the string */
block|}
end_function

begin_comment
comment|/* Hash table stuff */
end_comment

begin_struct
struct|struct
name|hashtbl
block|{
name|int
name|size
decl_stmt|;
comment|/* Max number of entries */
name|int
name|entries
decl_stmt|;
comment|/* Actual number of entries */
name|char
modifier|*
modifier|*
name|tbl
decl_stmt|;
comment|/* Pointer to start of table */
block|}
struct|;
end_struct

begin_comment
comment|/* Make an empty hash table of size s */
end_comment

begin_function
specifier|static
name|struct
name|hashtbl
modifier|*
name|make_hash
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|struct
name|hashtbl
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|size
operator|<
literal|1
condition|)
name|size
operator|=
literal|1
expr_stmt|;
name|h
operator|=
operator|(
expr|struct
name|hashtbl
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hashtbl
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|h
operator|->
name|entries
operator|=
literal|0
expr_stmt|;
name|h
operator|->
name|tbl
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Destroy a hash table */
end_comment

begin_function
specifier|static
name|void
name|destroy_hash
parameter_list|(
name|h
parameter_list|)
name|struct
name|hashtbl
modifier|*
name|h
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|h
operator|->
name|tbl
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|h
operator|->
name|tbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|h
operator|->
name|tbl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute hash value for a string */
end_comment

begin_function
specifier|static
name|unsigned
name|hashval
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|unsigned
name|hv
decl_stmt|;
for|for
control|(
name|hv
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
name|hv
operator|^=
operator|(
operator|(
name|hv
operator|<<
literal|3
operator|)
operator|^
operator|*
name|s
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|hv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Add an element to a hash table */
end_comment

begin_function
specifier|static
name|void
name|add_hash
parameter_list|(
name|h
parameter_list|,
name|el
parameter_list|)
name|struct
name|hashtbl
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|el
decl_stmt|;
block|{
name|unsigned
name|hv
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
modifier|*
name|old
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Make space if it isn't there already */
if|if
condition|(
name|h
operator|->
name|entries
operator|+
literal|1
operator|>
operator|(
name|h
operator|->
name|size
operator|>>
literal|1
operator|)
condition|)
block|{
name|old
operator|=
name|h
operator|->
name|tbl
expr_stmt|;
name|h
operator|->
name|tbl
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|h
operator|->
name|size
operator|<<
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|old
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|hv
operator|=
name|hashval
argument_list|(
name|old
index|[
name|i
index|]
argument_list|)
operator|%
operator|(
name|h
operator|->
name|size
operator|<<
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|tbl
index|[
name|hv
index|]
operator|!=
name|NULL
condition|)
name|hv
operator|=
operator|(
name|hv
operator|+
literal|1
operator|)
operator|%
operator|(
name|h
operator|->
name|size
operator|<<
literal|1
operator|)
expr_stmt|;
name|h
operator|->
name|tbl
index|[
name|hv
index|]
operator|=
name|old
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|h
operator|->
name|size
operator|=
name|h
operator|->
name|size
operator|<<
literal|1
expr_stmt|;
name|free
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
name|hv
operator|=
name|hashval
argument_list|(
name|el
argument_list|)
operator|%
name|h
operator|->
name|size
expr_stmt|;
while|while
condition|(
name|h
operator|->
name|tbl
index|[
name|hv
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|h
operator|->
name|tbl
index|[
name|hv
index|]
argument_list|,
name|el
argument_list|)
condition|)
name|hv
operator|=
operator|(
name|hv
operator|+
literal|1
operator|)
operator|%
name|h
operator|->
name|size
expr_stmt|;
name|s
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|el
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|el
argument_list|)
expr_stmt|;
name|h
operator|->
name|tbl
index|[
name|hv
index|]
operator|=
name|s
expr_stmt|;
name|h
operator|->
name|entries
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if el is in h */
end_comment

begin_function
specifier|static
name|int
name|check_hash
parameter_list|(
name|h
parameter_list|,
name|el
parameter_list|)
name|struct
name|hashtbl
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|el
decl_stmt|;
block|{
name|unsigned
name|hv
decl_stmt|;
for|for
control|(
name|hv
operator|=
name|hashval
argument_list|(
name|el
argument_list|)
operator|%
name|h
operator|->
name|size
init|;
name|h
operator|->
name|tbl
index|[
name|hv
index|]
operator|!=
name|NULL
condition|;
name|hv
operator|=
operator|(
name|hv
operator|+
literal|1
operator|)
operator|%
name|h
operator|->
name|size
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|h
operator|->
name|tbl
index|[
name|hv
index|]
argument_list|,
name|el
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|acl
block|{
name|char
name|filename
index|[
name|LINESIZE
index|]
decl_stmt|;
comment|/* Name of acl file */
name|int
name|fd
decl_stmt|;
comment|/* File descriptor for acl file */
name|struct
name|stat
name|status
decl_stmt|;
comment|/* File status at last read */
name|struct
name|hashtbl
modifier|*
name|acl
decl_stmt|;
comment|/* Acl entries */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|acl
name|acl_cache
index|[
name|CACHED_ACLS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|acl_cache_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|acl_cache_next
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Returns< 0 if unsuccessful in loading acl */
end_comment

begin_comment
comment|/* Returns index into acl_cache otherwise */
end_comment

begin_comment
comment|/* Note that if acl is already loaded, this is just a lookup */
end_comment

begin_function
specifier|static
name|int
name|acl_load
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|stat
name|s
decl_stmt|;
name|char
name|buf
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
name|char
name|canon
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
comment|/* See if it's there already */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl_cache_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|filename
argument_list|,
name|name
argument_list|)
operator|&&
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
operator|>=
literal|0
condition|)
goto|goto
name|got_it
goto|;
block|}
comment|/* It isn't, load it in */
comment|/* maybe there's still room */
if|if
condition|(
name|acl_cache_count
operator|<
name|CACHED_ACLS
condition|)
block|{
name|i
operator|=
name|acl_cache_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* No room, clean one out */
name|i
operator|=
name|acl_cache_next
expr_stmt|;
name|acl_cache_next
operator|=
operator|(
name|acl_cache_next
operator|+
literal|1
operator|)
operator|%
name|CACHED_ACLS
expr_stmt|;
name|close
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
condition|)
block|{
name|destroy_hash
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
argument_list|)
expr_stmt|;
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
operator|=
operator|(
expr|struct
name|hashtbl
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
comment|/* Set up the acl */
name|strcpy
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|filename
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Force reload */
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
operator|=
operator|(
expr|struct
name|hashtbl
operator|*
operator|)
literal|0
expr_stmt|;
name|got_it
label|:
comment|/*      * See if the stat matches      *      * Use stat(), not fstat(), as the file may have been re-created by      * acl_add or acl_delete.  If this happens, the old inode will have      * no changes in the mod-time and the following test will fail.      */
if|if
condition|(
name|stat
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|filename
argument_list|,
operator|&
name|s
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
operator|==
operator|(
expr|struct
name|hashtbl
operator|*
operator|)
literal|0
operator|||
name|s
operator|.
name|st_nlink
operator|!=
name|acl_cache
index|[
name|i
index|]
operator|.
name|status
operator|.
name|st_nlink
operator|||
name|s
operator|.
name|st_mtime
operator|!=
name|acl_cache
index|[
name|i
index|]
operator|.
name|status
operator|.
name|st_mtime
operator|||
name|s
operator|.
name|st_ctime
operator|!=
name|acl_cache
index|[
name|i
index|]
operator|.
name|status
operator|.
name|st_ctime
condition|)
block|{
comment|/* Gotta reload */
if|if
condition|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|f
operator|=
name|fdopen
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
condition|)
name|destroy_hash
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
argument_list|)
expr_stmt|;
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
operator|=
name|make_hash
argument_list|(
name|ACL_LEN
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|nuke_whitespace
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|acl_canonicalize_principal
argument_list|(
name|buf
argument_list|,
name|canon
argument_list|)
expr_stmt|;
name|add_hash
argument_list|(
name|acl_cache
index|[
name|i
index|]
operator|.
name|acl
argument_list|,
name|canon
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|acl_cache
index|[
name|i
index|]
operator|.
name|status
operator|=
name|s
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if it can be determined that acl contains principal */
end_comment

begin_comment
comment|/* Principal is not canonicalized, and no wildcarding is done */
end_comment

begin_function
name|int
name|acl_exact_match
parameter_list|(
name|acl
parameter_list|,
name|principal
parameter_list|)
name|char
modifier|*
name|acl
decl_stmt|;
name|char
modifier|*
name|principal
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
return|return
operator|(
operator|(
name|idx
operator|=
name|acl_load
argument_list|(
name|acl
argument_list|)
operator|)
operator|>=
literal|0
operator|&&
name|check_hash
argument_list|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
argument_list|,
name|principal
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Returns nonzero if it can be determined that acl contains principal */
end_comment

begin_comment
comment|/* Recognizes wildcards in acl of the form    name.*@realm, *.*@realm, and *.*@* */
end_comment

begin_function
name|int
name|acl_check
parameter_list|(
name|acl
parameter_list|,
name|principal
parameter_list|)
name|char
modifier|*
name|acl
decl_stmt|;
name|char
modifier|*
name|principal
decl_stmt|;
block|{
name|char
name|buf
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
name|char
name|canon
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|realm
decl_stmt|;
name|acl_canonicalize_principal
argument_list|(
name|principal
argument_list|,
name|canon
argument_list|)
expr_stmt|;
comment|/* Is it there? */
if|if
condition|(
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
name|canon
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Try the wildcards */
name|realm
operator|=
name|index
argument_list|(
name|canon
argument_list|,
name|REALM_SEP
argument_list|)
expr_stmt|;
operator|*
name|index
argument_list|(
name|canon
argument_list|,
name|INST_SEP
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* Chuck the instance */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s.*%s"
argument_list|,
name|canon
argument_list|,
name|realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"*.*%s"
argument_list|,
name|realm
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
name|buf
argument_list|)
operator|||
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
literal|"*.*@*"
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Adds principal to acl */
end_comment

begin_comment
comment|/* Wildcards are interpreted literally */
end_comment

begin_function
name|int
name|acl_add
parameter_list|(
name|acl
parameter_list|,
name|principal
parameter_list|)
name|char
modifier|*
name|acl
decl_stmt|;
name|char
modifier|*
name|principal
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|new
decl_stmt|;
name|char
name|canon
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
name|acl_canonicalize_principal
argument_list|(
name|principal
argument_list|,
name|canon
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|acl_lock_file
argument_list|(
name|acl
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
name|canon
argument_list|)
operator|)
operator|||
operator|(
name|idx
operator|=
name|acl_load
argument_list|(
name|acl
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|acl_abort
argument_list|(
name|acl
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* It isn't there yet, copy the file and put it in */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|tbl
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fputs
argument_list|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|tbl
index|[
name|i
index|]
argument_list|,
name|new
argument_list|)
operator|==
name|NULL
operator|||
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|new
argument_list|)
operator|!=
literal|'\n'
condition|)
block|{
name|acl_abort
argument_list|(
name|acl
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
name|fputs
argument_list|(
name|canon
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
name|acl_commit
argument_list|(
name|acl
argument_list|,
name|new
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Removes principal from acl */
end_comment

begin_comment
comment|/* Wildcards are interpreted literally */
end_comment

begin_function
name|int
name|acl_delete
parameter_list|(
name|acl
parameter_list|,
name|principal
parameter_list|)
name|char
modifier|*
name|acl
decl_stmt|;
name|char
modifier|*
name|principal
decl_stmt|;
block|{
name|int
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
name|new
decl_stmt|;
name|char
name|canon
index|[
name|MAX_PRINCIPAL_SIZE
index|]
decl_stmt|;
name|acl_canonicalize_principal
argument_list|(
name|principal
argument_list|,
name|canon
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|acl_lock_file
argument_list|(
name|acl
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
operator|!
name|acl_exact_match
argument_list|(
name|acl
argument_list|,
name|canon
argument_list|)
operator|)
operator|||
operator|(
name|idx
operator|=
name|acl_load
argument_list|(
name|acl
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|acl_abort
argument_list|(
name|acl
argument_list|,
name|new
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* It isn't there yet, copy the file and put it in */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|tbl
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|tbl
index|[
name|i
index|]
argument_list|,
name|canon
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
name|acl_cache
index|[
name|idx
index|]
operator|.
name|acl
operator|->
name|tbl
index|[
name|i
index|]
argument_list|,
name|new
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|acl_commit
argument_list|(
name|acl
argument_list|,
name|new
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

