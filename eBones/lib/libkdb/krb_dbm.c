begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1988 by the Massachusetts Institute of Technology.   * For copying and distribution information, please see the file  *<Copyright.MIT>.   *  *	from: krb_dbm.c,v 4.9 89/04/18 16:15:13 wesommer Exp $  *	$Id: krb_dbm.c,v 1.1.1.1 1994/09/30 14:49:55 csgr Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: krb_dbm.c,v 1.1.1.1 1994/09/30 14:49:55 csgr Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|NDBM
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<des.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NDBM
end_ifdef

begin_include
include|#
directive|include
file|<ndbm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*NDBM*/
end_comment

begin_include
include|#
directive|include
file|<dbm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*NDBM*/
end_comment

begin_comment
comment|/* before krb_db.h */
end_comment

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<krb_db.h>
end_include

begin_define
define|#
directive|define
name|KERB_DB_MAX_RETRY
value|5
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|kerb_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|init
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|default_db_name
index|[]
init|=
name|DBM_FILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|current_db_name
init|=
name|default_db_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|encode_princ_key
argument_list|()
decl_stmt|,
name|decode_princ_key
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|encode_princ_contents
argument_list|()
decl_stmt|,
name|decode_princ_contents
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|kerb_dbl_fini
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kerb_dbl_lock
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kerb_dbl_unlock
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|timestamp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current time of request */
end_comment

begin_decl_stmt
specifier|static
name|int
name|non_blocking
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This module contains all of the code which directly interfaces to  * the underlying representation of the Kerberos database; this  * implementation uses a DBM or NDBM indexed "file" (actually  * implemented as two separate files) to store the relations, plus a  * third file as a semaphore to allow the database to be replaced out  * from underneath the KDC server.  */
end_comment

begin_comment
comment|/*  * Locking:  *   * There are two distinct locking protocols used.  One is designed to  * lock against processes (the admin_server, for one) which make  * incremental changes to the database; the other is designed to lock  * against utilities (kdb_util, kpropd) which replace the entire  * database in one fell swoop.  *  * The first locking protocol is implemented using flock() in the   * krb_dbl_lock() and krb_dbl_unlock routines.  *  * The second locking protocol is necessary because DBM "files" are  * actually implemented as two separate files, and it is impossible to  * atomically rename two files simultaneously.  It assumes that the  * database is replaced only very infrequently in comparison to the time  * needed to do a database read operation.  *  * A third file is used as a "version" semaphore; the modification  * time of this file is the "version number" of the database.  * At the start of a read operation, the reader checks the version  * number; at the end of the read operation, it checks again.  If the  * version number changed, or if the semaphore was nonexistant at  * either time, the reader sleeps for a second to let things  * stabilize, and then tries again; if it does not succeed after  * KERB_DB_MAX_RETRY attempts, it gives up.  *   * On update, the semaphore file is deleted (if it exists) before any  * update takes place; at the end of the update, it is replaced, with  * a version number strictly greater than the version number which  * existed at the start of the update.  *   * If the system crashes in the middle of an update, the semaphore  * file is not automatically created on reboot; this is a feature, not  * a bug, since the database may be inconsistant.  Note that the  * absence of a semaphore file does not prevent another _update_ from  * taking place later.  Database replacements take place automatically  * only on slave servers; a crash in the middle of an update will be  * fixed by the next slave propagation.  A crash in the middle of an  * update on the master would be somewhat more serious, but this would  * likely be noticed by an administrator, who could fix the problem and  * retry the operation.  */
end_comment

begin_comment
comment|/* Macros to convert ndbm names to dbm names.  * Note that dbm_nextkey() cannot be simply converted using a macro, since  * it is invoked giving the database, and nextkey() needs the previous key.  *  * Instead, all routines call "dbm_next" instead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NDBM
end_ifndef

begin_typedef
typedef|typedef
name|char
name|DBM
typedef|;
end_typedef

begin_define
define|#
directive|define
name|dbm_open
parameter_list|(
name|file
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|)
value|((dbminit(file) == 0)?"":((char *)0))
end_define

begin_define
define|#
directive|define
name|dbm_fetch
parameter_list|(
name|db
parameter_list|,
name|key
parameter_list|)
value|fetch(key)
end_define

begin_define
define|#
directive|define
name|dbm_store
parameter_list|(
name|db
parameter_list|,
name|key
parameter_list|,
name|content
parameter_list|,
name|flag
parameter_list|)
value|store(key, content)
end_define

begin_define
define|#
directive|define
name|dbm_firstkey
parameter_list|(
name|db
parameter_list|)
value|firstkey()
end_define

begin_define
define|#
directive|define
name|dbm_next
parameter_list|(
name|db
parameter_list|,
name|key
parameter_list|)
value|nextkey(key)
end_define

begin_define
define|#
directive|define
name|dbm_close
parameter_list|(
name|db
parameter_list|)
value|dbmclose()
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dbm_next
parameter_list|(
name|db
parameter_list|,
name|key
parameter_list|)
value|dbm_nextkey(db)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Utility routine: generate name of database file.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|gen_dbsuffix
parameter_list|(
name|db_name
parameter_list|,
name|sfx
parameter_list|)
name|char
modifier|*
name|db_name
decl_stmt|;
name|char
modifier|*
name|sfx
decl_stmt|;
block|{
name|char
modifier|*
name|dbsuffix
decl_stmt|;
if|if
condition|(
name|sfx
operator|==
name|NULL
condition|)
name|sfx
operator|=
literal|".ok"
expr_stmt|;
name|dbsuffix
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|db_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|sfx
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dbsuffix
argument_list|,
name|db_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|dbsuffix
argument_list|,
name|sfx
argument_list|)
expr_stmt|;
return|return
name|dbsuffix
return|;
block|}
end_function

begin_comment
comment|/*  * initialization for data base routines.  */
end_comment

begin_macro
name|kerb_db_init
argument_list|()
end_macro

begin_block
block|{
name|init
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * gracefully shut down database--must be called by ANY program that does  * a kerb_db_init   */
end_comment

begin_macro
name|kerb_db_fini
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_comment
comment|/*  * Set the "name" of the current database to some alternate value.  *  * Passing a null pointer as "name" will set back to the default.  * If the alternate database doesn't exist, nothing is changed.  */
end_comment

begin_macro
name|kerb_db_set_name
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DBM
modifier|*
name|db
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|default_db_name
expr_stmt|;
name|db
operator|=
name|dbm_open
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
return|return
name|errno
return|;
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|kerb_dbl_fini
argument_list|()
expr_stmt|;
name|current_db_name
operator|=
name|name
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Return the last modification time of the database.  */
end_comment

begin_function
name|long
name|kerb_get_db_age
parameter_list|()
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|okname
decl_stmt|;
name|long
name|age
decl_stmt|;
name|okname
operator|=
name|gen_dbsuffix
argument_list|(
name|current_db_name
argument_list|,
literal|".ok"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|okname
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|age
operator|=
literal|0
expr_stmt|;
else|else
name|age
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|free
argument_list|(
name|okname
argument_list|)
expr_stmt|;
return|return
name|age
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the semaphore file; indicates that database is currently  * under renovation.  *  * This is only for use when moving the database out from underneath  * the server (for example, during slave updates).  */
end_comment

begin_function
specifier|static
name|long
name|kerb_start_update
parameter_list|(
name|db_name
parameter_list|)
name|char
modifier|*
name|db_name
decl_stmt|;
block|{
name|char
modifier|*
name|okname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".ok"
argument_list|)
decl_stmt|;
name|long
name|age
init|=
name|kerb_get_db_age
argument_list|()
decl_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|okname
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|age
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|okname
argument_list|)
expr_stmt|;
return|return
name|age
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|kerb_end_update
parameter_list|(
name|db_name
parameter_list|,
name|age
parameter_list|)
name|char
modifier|*
name|db_name
decl_stmt|;
name|long
name|age
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|new_okname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".ok#"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|okname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".ok"
argument_list|)
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|new_okname
argument_list|,
name|O_CREAT
operator||
name|O_RDWR
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|retval
operator|=
name|errno
expr_stmt|;
else|else
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|;
comment|/* make sure that semaphore is "after" previous value. */
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|st
operator|.
name|st_mtime
operator|<=
name|age
condition|)
block|{
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|st
operator|.
name|st_atime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|age
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* set times.. */
name|utimes
argument_list|(
name|new_okname
argument_list|,
name|tv
argument_list|)
expr_stmt|;
name|fsync
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|new_okname
argument_list|,
name|okname
argument_list|)
operator|<
literal|0
condition|)
name|retval
operator|=
name|errno
expr_stmt|;
block|}
name|free
argument_list|(
name|new_okname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|okname
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|kerb_start_read
parameter_list|()
block|{
return|return
name|kerb_get_db_age
argument_list|()
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|kerb_end_read
parameter_list|(
name|age
parameter_list|)
name|u_long
name|age
decl_stmt|;
block|{
if|if
condition|(
name|kerb_get_db_age
argument_list|()
operator|!=
name|age
operator|||
name|age
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Create the database, assuming it's not there.  */
end_comment

begin_macro
name|kerb_db_create
argument_list|(
argument|db_name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|db_name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|okname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".ok"
argument_list|)
decl_stmt|;
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|ret
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|NDBM
name|DBM
modifier|*
name|db
decl_stmt|;
name|db
operator|=
name|dbm_open
argument_list|(
name|db_name
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|==
name|NULL
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
else|else
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|dirname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".dir"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pagname
init|=
name|gen_dbsuffix
argument_list|(
name|db_name
argument_list|,
literal|".pag"
argument_list|)
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|dirname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
else|else
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|pagname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
else|else
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbminit
argument_list|(
name|db_name
argument_list|)
operator|<
literal|0
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|okname
argument_list|,
name|O_CREAT
operator||
name|O_RDWR
operator||
name|O_TRUNC
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_block

begin_comment
comment|/*  * "Atomically" rename the database in a way that locks out read  * access in the middle of the rename.  *  * Not perfect; if we crash in the middle of an update, we don't  * necessarily know to complete the transaction the rename, but...  */
end_comment

begin_macro
name|kerb_db_rename
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|__FreeBSD__
name|char
modifier|*
name|fromdir
init|=
name|gen_dbsuffix
argument_list|(
name|from
argument_list|,
literal|".dir"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|todir
init|=
name|gen_dbsuffix
argument_list|(
name|to
argument_list|,
literal|".dir"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|frompag
init|=
name|gen_dbsuffix
argument_list|(
name|from
argument_list|,
literal|".pag"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|topag
init|=
name|gen_dbsuffix
argument_list|(
name|to
argument_list|,
literal|".pag"
argument_list|)
decl_stmt|;
else|#
directive|else
name|char
modifier|*
name|fromdb
init|=
name|gen_dbsuffix
argument_list|(
name|from
argument_list|,
literal|".db"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|todb
init|=
name|gen_dbsuffix
argument_list|(
name|to
argument_list|,
literal|".db"
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|fromok
init|=
name|gen_dbsuffix
argument_list|(
name|from
argument_list|,
literal|".ok"
argument_list|)
decl_stmt|;
name|long
name|trans
init|=
name|kerb_start_update
argument_list|(
name|to
argument_list|)
decl_stmt|;
name|int
name|ok
decl_stmt|;
ifndef|#
directive|ifndef
name|__FreeBSD__
if|if
condition|(
operator|(
name|rename
argument_list|(
name|fromdir
argument_list|,
name|todir
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rename
argument_list|(
name|frompag
argument_list|,
name|topag
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|rename
argument_list|(
name|fromdb
argument_list|,
name|todb
argument_list|)
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|fromok
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
block|}
name|free
argument_list|(
name|fromok
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__FreeBSD__
name|free
argument_list|(
name|fromdir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|todir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|frompag
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|topag
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|fromdb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|todb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ok
condition|)
return|return
name|kerb_end_update
argument_list|(
name|to
argument_list|,
name|trans
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
comment|/*  * look up a principal in the data base returns number of principals  * found , and whether there were more than requested.   */
name|kerb_db_get_principal
argument_list|(
argument|name
argument_list|,
argument|inst
argument_list|,
argument|principal
argument_list|,
argument|max
argument_list|,
argument|more
argument_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* could have wild card */
name|char
modifier|*
name|inst
decl_stmt|;
comment|/* could have wild card */
name|Principal
modifier|*
name|principal
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
comment|/* max number of name structs to return */
name|int
modifier|*
name|more
decl_stmt|;
comment|/* where there more than 'max' tuples? */
block|{
name|int
name|found
init|=
literal|0
decl_stmt|,
name|code
decl_stmt|;
specifier|extern
name|int
name|errorproc
parameter_list|()
function_decl|;
name|int
name|wildp
decl_stmt|,
name|wildi
decl_stmt|;
name|datum
name|key
decl_stmt|,
name|contents
decl_stmt|;
name|char
name|testname
index|[
name|ANAME_SZ
index|]
decl_stmt|,
name|testinst
index|[
name|INST_SZ
index|]
decl_stmt|;
name|u_long
name|trans
decl_stmt|;
name|int
name|try
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
name|kerb_db_init
argument_list|()
expr_stmt|;
comment|/* initialize database routines */
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<
name|KERB_DB_MAX_RETRY
condition|;
name|try
operator|++
control|)
block|{
name|trans
operator|=
name|kerb_start_read
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|kerb_dbl_lock
argument_list|(
name|KERB_DBL_SHARED
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|db
operator|=
name|dbm_open
argument_list|(
name|current_db_name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
operator|*
name|more
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: db_get_principal for %s %s max = %d"
argument_list|,
name|progname
argument_list|,
name|name
argument_list|,
name|inst
argument_list|,
name|max
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wildp
operator|=
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|wildi
operator|=
operator|!
name|strcmp
argument_list|(
name|inst
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wildi
operator|&&
operator|!
name|wildp
condition|)
block|{
comment|/* nothing's wild */
name|encode_princ_key
argument_list|(
operator|&
name|key
argument_list|,
name|name
argument_list|,
name|inst
argument_list|)
expr_stmt|;
name|contents
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|.
name|dptr
operator|==
name|NULL
condition|)
block|{
name|found
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|decode_princ_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|principal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t found %s %s p_n length %d t_n length %d\n"
argument_list|,
name|principal
operator|->
name|name
argument_list|,
name|principal
operator|->
name|instance
argument_list|,
name|strlen
argument_list|(
name|principal
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|principal
operator|->
name|instance
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|found
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* process wild cards by looping through entire database */
for|for
control|(
name|key
operator|=
name|dbm_firstkey
argument_list|(
name|db
argument_list|)
init|;
name|key
operator|.
name|dptr
operator|!=
name|NULL
condition|;
name|key
operator|=
name|dbm_next
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
control|)
block|{
name|decode_princ_key
argument_list|(
operator|&
name|key
argument_list|,
name|testname
argument_list|,
name|testinst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wildp
operator|||
operator|!
name|strcmp
argument_list|(
name|testname
argument_list|,
name|name
argument_list|)
operator|)
operator|&&
operator|(
name|wildi
operator|||
operator|!
name|strcmp
argument_list|(
name|testinst
argument_list|,
name|inst
argument_list|)
operator|)
condition|)
block|{
comment|/* have a match */
if|if
condition|(
name|found
operator|>=
name|max
condition|)
block|{
operator|*
name|more
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|found
operator|++
expr_stmt|;
name|contents
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|decode_princ_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|principal
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tfound %s %s p_n length %d t_n length %d\n"
argument_list|,
name|principal
operator|->
name|name
argument_list|,
name|principal
operator|->
name|instance
argument_list|,
name|strlen
argument_list|(
name|principal
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|principal
operator|->
name|instance
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|principal
operator|++
expr_stmt|;
comment|/* point to next */
block|}
block|}
block|}
name|done
label|:
name|kerb_dbl_unlock
argument_list|()
expr_stmt|;
comment|/* unlock read lock */
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerb_end_read
argument_list|(
name|trans
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|found
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|non_blocking
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
comment|/*  * Update a name in the data base.  Returns number of names  * successfully updated.  */
name|kerb_db_put_principal
argument_list|(
argument|principal
argument_list|,
argument|max
argument_list|)
name|Principal
modifier|*
name|principal
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
comment|/* number of principal structs to 				 * update */
block|{
name|int
name|found
init|=
literal|0
decl_stmt|,
name|code
decl_stmt|;
name|u_long
name|i
decl_stmt|;
specifier|extern
name|int
name|errorproc
parameter_list|()
function_decl|;
name|datum
name|key
decl_stmt|,
name|contents
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|timestamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|init
condition|)
name|kerb_db_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
name|kerb_dbl_lock
argument_list|(
name|KERB_DBL_EXCLUSIVE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|db
operator|=
name|dbm_open
argument_list|(
name|current_db_name
argument_list|,
name|O_RDWR
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|2
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: kerb_db_put_principal  max = %d"
argument_list|,
name|progname
argument_list|,
name|max
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* for each one, stuff temps, and do replace/append */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
name|encode_princ_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|principal
argument_list|)
expr_stmt|;
name|encode_princ_key
argument_list|(
operator|&
name|key
argument_list|,
name|principal
operator|->
name|name
argument_list|,
name|principal
operator|->
name|instance
argument_list|)
expr_stmt|;
name|dbm_store
argument_list|(
name|db
argument_list|,
name|key
argument_list|,
name|contents
argument_list|,
name|DBM_REPLACE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|kerb_debug
operator|&
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n put %s %s\n"
argument_list|,
name|principal
operator|->
name|name
argument_list|,
name|principal
operator|->
name|instance
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|found
operator|++
expr_stmt|;
name|principal
operator|++
expr_stmt|;
comment|/* bump to next struct			   */
block|}
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|kerb_dbl_unlock
argument_list|()
expr_stmt|;
comment|/* unlock database */
return|return
operator|(
name|found
operator|)
return|;
block|}
specifier|static
name|void
name|encode_princ_key
parameter_list|(
name|key
parameter_list|,
name|name
parameter_list|,
name|instance
parameter_list|)
name|datum
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|instance
decl_stmt|;
block|{
specifier|static
name|char
name|keystring
index|[
name|ANAME_SZ
operator|+
name|INST_SZ
index|]
decl_stmt|;
name|bzero
argument_list|(
name|keystring
argument_list|,
name|ANAME_SZ
operator|+
name|INST_SZ
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|keystring
argument_list|,
name|name
argument_list|,
name|ANAME_SZ
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|&
name|keystring
index|[
name|ANAME_SZ
index|]
argument_list|,
name|instance
argument_list|,
name|INST_SZ
argument_list|)
expr_stmt|;
name|key
operator|->
name|dptr
operator|=
name|keystring
expr_stmt|;
name|key
operator|->
name|dsize
operator|=
name|ANAME_SZ
operator|+
name|INST_SZ
expr_stmt|;
block|}
specifier|static
name|void
name|decode_princ_key
parameter_list|(
name|key
parameter_list|,
name|name
parameter_list|,
name|instance
parameter_list|)
name|datum
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|instance
decl_stmt|;
block|{
name|strncpy
argument_list|(
name|name
argument_list|,
name|key
operator|->
name|dptr
argument_list|,
name|ANAME_SZ
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|instance
argument_list|,
name|key
operator|->
name|dptr
operator|+
name|ANAME_SZ
argument_list|,
name|INST_SZ
argument_list|)
expr_stmt|;
name|name
index|[
name|ANAME_SZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|instance
index|[
name|INST_SZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
specifier|static
name|void
name|encode_princ_contents
parameter_list|(
name|contents
parameter_list|,
name|principal
parameter_list|)
name|datum
modifier|*
name|contents
decl_stmt|;
name|Principal
modifier|*
name|principal
decl_stmt|;
block|{
name|contents
operator|->
name|dsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|principal
argument_list|)
expr_stmt|;
name|contents
operator|->
name|dptr
operator|=
operator|(
name|char
operator|*
operator|)
name|principal
expr_stmt|;
block|}
specifier|static
name|void
name|decode_princ_contents
parameter_list|(
name|contents
parameter_list|,
name|principal
parameter_list|)
name|datum
modifier|*
name|contents
decl_stmt|;
name|Principal
modifier|*
name|principal
decl_stmt|;
block|{
name|bcopy
argument_list|(
name|contents
operator|->
name|dptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|principal
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|principal
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kerb_db_get_stat
argument_list|(
argument|s
argument_list|)
name|DB_stat
modifier|*
name|s
decl_stmt|;
block|{
name|gettimeofday
argument_list|(
operator|&
name|timestamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|->
name|cpu
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|elapsed
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|dio
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|pfault
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|t_stamp
operator|=
name|timestamp
operator|.
name|tv_sec
expr_stmt|;
name|s
operator|->
name|n_retrieve
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|n_replace
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|n_append
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|n_get_stat
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|n_put_stat
operator|=
literal|0
expr_stmt|;
comment|/* update local copy too */
block|}
name|kerb_db_put_stat
argument_list|(
argument|s
argument_list|)
name|DB_stat
modifier|*
name|s
decl_stmt|;
block|{ }
name|delta_stat
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|)
name|DB_stat
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|c
decl_stmt|;
block|{
comment|/* c = a - b then b = a for the next time */
name|c
operator|->
name|cpu
operator|=
name|a
operator|->
name|cpu
operator|-
name|b
operator|->
name|cpu
expr_stmt|;
name|c
operator|->
name|elapsed
operator|=
name|a
operator|->
name|elapsed
operator|-
name|b
operator|->
name|elapsed
expr_stmt|;
name|c
operator|->
name|dio
operator|=
name|a
operator|->
name|dio
operator|-
name|b
operator|->
name|dio
expr_stmt|;
name|c
operator|->
name|pfault
operator|=
name|a
operator|->
name|pfault
operator|-
name|b
operator|->
name|pfault
expr_stmt|;
name|c
operator|->
name|t_stamp
operator|=
name|a
operator|->
name|t_stamp
operator|-
name|b
operator|->
name|t_stamp
expr_stmt|;
name|c
operator|->
name|n_retrieve
operator|=
name|a
operator|->
name|n_retrieve
operator|-
name|b
operator|->
name|n_retrieve
expr_stmt|;
name|c
operator|->
name|n_replace
operator|=
name|a
operator|->
name|n_replace
operator|-
name|b
operator|->
name|n_replace
expr_stmt|;
name|c
operator|->
name|n_append
operator|=
name|a
operator|->
name|n_append
operator|-
name|b
operator|->
name|n_append
expr_stmt|;
name|c
operator|->
name|n_get_stat
operator|=
name|a
operator|->
name|n_get_stat
operator|-
name|b
operator|->
name|n_get_stat
expr_stmt|;
name|c
operator|->
name|n_put_stat
operator|=
name|a
operator|->
name|n_put_stat
operator|-
name|b
operator|->
name|n_put_stat
expr_stmt|;
name|bcopy
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|DB_stat
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * look up a dba in the data base returns number of dbas found , and  * whether there were more than requested.   */
name|kerb_db_get_dba
argument_list|(
argument|dba_name
argument_list|,
argument|dba_inst
argument_list|,
argument|dba
argument_list|,
argument|max
argument_list|,
argument|more
argument_list|)
name|char
modifier|*
name|dba_name
decl_stmt|;
comment|/* could have wild card */
name|char
modifier|*
name|dba_inst
decl_stmt|;
comment|/* could have wild card */
name|Dba
modifier|*
name|dba
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
comment|/* max number of name structs to return */
name|int
modifier|*
name|more
decl_stmt|;
comment|/* where there more than 'max' tuples? */
block|{
operator|*
name|more
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|kerb_db_iterate
argument_list|(
argument|func
argument_list|,
argument|arg
argument_list|)
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|char
modifier|*
name|arg
decl_stmt|;
comment|/* void *, really */
block|{
name|datum
name|key
decl_stmt|,
name|contents
decl_stmt|;
name|Principal
modifier|*
name|principal
decl_stmt|;
name|int
name|code
decl_stmt|;
name|DBM
modifier|*
name|db
decl_stmt|;
name|kerb_db_init
argument_list|()
expr_stmt|;
comment|/* initialize and open the database */
if|if
condition|(
operator|(
name|code
operator|=
name|kerb_dbl_lock
argument_list|(
name|KERB_DBL_SHARED
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|code
return|;
name|db
operator|=
name|dbm_open
argument_list|(
name|current_db_name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
for|for
control|(
name|key
operator|=
name|dbm_firstkey
argument_list|(
name|db
argument_list|)
init|;
name|key
operator|.
name|dptr
operator|!=
name|NULL
condition|;
name|key
operator|=
name|dbm_next
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
control|)
block|{
name|contents
operator|=
name|dbm_fetch
argument_list|(
name|db
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* XXX may not be properly aligned */
name|principal
operator|=
operator|(
name|Principal
operator|*
operator|)
name|contents
operator|.
name|dptr
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|arg
argument_list|,
name|principal
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|code
return|;
block|}
name|dbm_close
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|kerb_dbl_unlock
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
specifier|static
name|int
name|dblfd
init|=
operator|-
literal|1
decl_stmt|;
specifier|static
name|int
name|mylock
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
specifier|static
name|kerb_dbl_init
argument_list|()
block|{
if|if
condition|(
operator|!
name|inited
condition|)
block|{
name|char
modifier|*
name|filename
init|=
name|gen_dbsuffix
argument_list|(
name|current_db_name
argument_list|,
literal|".ok"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|dblfd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"kerb_dbl_init: couldn't open %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|inited
operator|++
expr_stmt|;
block|}
end_block

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_function
unit|}  static
name|void
name|kerb_dbl_fini
parameter_list|()
block|{
name|close
argument_list|(
name|dblfd
argument_list|)
expr_stmt|;
name|dblfd
operator|=
operator|-
literal|1
expr_stmt|;
name|inited
operator|=
literal|0
expr_stmt|;
name|mylock
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|kerb_dbl_lock
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
name|int
name|flock_mode
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
name|kerb_dbl_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|mylock
condition|)
block|{
comment|/* Detect lock call when lock already 				 * locked */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Kerberos locking error (mylock)\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|KERB_DBL_EXCLUSIVE
case|:
name|flock_mode
operator|=
name|LOCK_EX
expr_stmt|;
break|break;
case|case
name|KERB_DBL_SHARED
case|:
name|flock_mode
operator|=
name|LOCK_SH
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"invalid lock mode %d\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|non_blocking
condition|)
name|flock_mode
operator||=
name|LOCK_NB
expr_stmt|;
if|if
condition|(
name|flock
argument_list|(
name|dblfd
argument_list|,
name|flock_mode
argument_list|)
operator|<
literal|0
condition|)
return|return
name|errno
return|;
name|mylock
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kerb_dbl_unlock
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mylock
condition|)
block|{
comment|/* lock already unlocked */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Kerberos database lock not locked when unlocking.\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flock
argument_list|(
name|dblfd
argument_list|,
name|LOCK_UN
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Kerberos database lock error. (unlocking)\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"flock"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mylock
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|kerb_db_set_lockmode
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
name|int
name|old
init|=
name|non_blocking
decl_stmt|;
name|non_blocking
operator|=
name|mode
expr_stmt|;
return|return
name|old
return|;
block|}
end_function

end_unit

