begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1988 by the Massachusetts Institute of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  * Purpose:  * This module was developed to parse the "~/.klogin" files for  * Kerberos-authenticated rlogin/rcp/rsh services.  However, it is  * general purpose and can be used to parse any such parameter file.  *  * The parameter file should consist of one or more entries, with each  * entry on a separate line and consisting of zero or more  * "keyword=value" combinations.  The keyword is case insensitive, but  * the value is not.  Any string may be enclosed in quotes, and  * c-style "\" literals are supported.  A comma may be used to  * separate the k/v combinations, and multiple commas are ignored.  * Whitespace (blank or tab) may be used freely and is ignored.  *  * Full error processing is available.  When PS_BAD_KEYWORD or  * PS_SYNTAX is returned from fGetParameterSet(), the string ErrorMsg  * contains a meaningful error message.  *  * Keywords and their default values are programmed by an external  * table.  *  * Routines:  * fGetParameterSet()      parse one line of the parameter file  * fGetKeywordValue()      parse one "keyword=value" combo  * fGetToken()             parse one token  *  *  *	from: kparse.c,v 4.5 89/01/21 17:20:39 jtkohl Exp $  *	$Id: kparse.c,v 1.2 1994/07/19 19:25:42 g89r4222 Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: kparse.c,v 1.2 1994/07/19 19:25:42 g89r4222 Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<kparse.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|void
value|int
end_define

begin_define
define|#
directive|define
name|MAXKEY
value|80
end_define

begin_define
define|#
directive|define
name|MAXVALUE
value|80
end_define

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|LineNbr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line nbr in parameter file */
end_comment

begin_decl_stmt
name|char
name|ErrorMsg
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* meaningful only when KV_SYNTAX, PS_SYNTAX,                          * or PS_BAD_KEYWORD is returned by                          * fGetKeywordValue or fGetParameterSet */
end_comment

begin_escape
end_escape

begin_function
name|int
name|fGetParameterSet
parameter_list|(
name|fp
parameter_list|,
name|parm
parameter_list|,
name|parmcount
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|parmtable
name|parm
index|[]
decl_stmt|;
name|int
name|parmcount
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|char
name|keyword
index|[
name|MAXKEY
index|]
decl_stmt|;
name|char
name|value
index|[
name|MAXVALUE
index|]
decl_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|rc
operator|=
name|fGetKeywordValue
argument_list|(
name|fp
argument_list|,
name|keyword
argument_list|,
name|MAXKEY
argument_list|,
name|value
argument_list|,
name|MAXVALUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|KV_EOF
case|:
return|return
operator|(
name|PS_EOF
operator|)
return|;
case|case
name|KV_EOL
case|:
return|return
operator|(
name|PS_OKAY
operator|)
return|;
case|case
name|KV_SYNTAX
case|:
return|return
operator|(
name|PS_SYNTAX
operator|)
return|;
case|case
name|KV_OKAY
case|:
comment|/*              * got a reasonable keyword/value pair.  Search the              * parameter table to see if we recognize the keyword; if              * not, return an error.  If we DO recognize it, make sure              * it has not already been given.  If not already given,              * save the value.              */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|parmcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|strutol
argument_list|(
name|keyword
argument_list|)
argument_list|,
name|parm
index|[
name|i
index|]
operator|.
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|parm
index|[
name|i
index|]
operator|.
name|value
condition|)
block|{
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"duplicate keyword \"%s\" found"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
return|return
operator|(
name|PS_BAD_KEYWORD
operator|)
return|;
block|}
name|parm
index|[
name|i
index|]
operator|.
name|value
operator|=
name|strsave
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|parmcount
condition|)
block|{
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"unrecognized keyword \"%s\" found"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
return|return
operator|(
name|PS_BAD_KEYWORD
operator|)
return|;
block|}
break|break;
default|default:
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"panic: bad return (%d) from fGetToken()"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Routine: ParmCompare  *  * Purpose:  * ParmCompare checks a specified value for a particular keyword.  * fails if keyword not found or keyword found but the value was  * different. Like strcmp, ParmCompare returns 0 for a match found, -1  * otherwise  */
end_comment

begin_function
name|int
name|ParmCompare
parameter_list|(
name|parm
parameter_list|,
name|parmcount
parameter_list|,
name|keyword
parameter_list|,
name|value
parameter_list|)
name|parmtable
name|parm
index|[]
decl_stmt|;
name|int
name|parmcount
decl_stmt|;
name|char
modifier|*
name|keyword
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|parmcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|parm
index|[
name|i
index|]
operator|.
name|keyword
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|parm
index|[
name|i
index|]
operator|.
name|value
condition|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|parm
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|value
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|parm
index|[
name|i
index|]
operator|.
name|defvalue
argument_list|,
name|value
argument_list|)
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|FreeParameterSet
parameter_list|(
name|parm
parameter_list|,
name|parmcount
parameter_list|)
name|parmtable
name|parm
index|[]
decl_stmt|;
name|int
name|parmcount
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|parmcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|parm
index|[
name|i
index|]
operator|.
name|value
condition|)
block|{
name|free
argument_list|(
name|parm
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|parm
index|[
name|i
index|]
operator|.
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|fGetKeywordValue
parameter_list|(
name|fp
parameter_list|,
name|keyword
parameter_list|,
name|klen
parameter_list|,
name|value
parameter_list|,
name|vlen
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|keyword
decl_stmt|;
name|int
name|klen
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|int
name|vlen
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|;
name|int
name|gotit
decl_stmt|;
operator|*
name|keyword
operator|=
operator|*
name|value
operator|=
literal|'\0'
expr_stmt|;
comment|/* preset strings to NULL */
comment|/*      * Looking for a keyword.      *          return an exception for EOF or BAD_QSTRING      *          ignore leading WHITEspace      *          ignore any number of leading commas      *          newline means we have all the parms for this      *          	statement; give an indication that there is      *          	nothing more on this line.      *          stop looking if we find QSTRING, STRING, or NUMBER      *          return syntax error for any other PUNKtuation      */
name|gotit
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
name|rc
operator|=
name|fGetToken
argument_list|(
name|fp
argument_list|,
name|keyword
argument_list|,
name|klen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|GTOK_WHITE
case|:
break|break;
case|case
name|GTOK_EOF
case|:
return|return
operator|(
name|KV_EOF
operator|)
return|;
case|case
name|GTOK_BAD_QSTRING
case|:
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"unterminated string \"%s found"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
return|return
operator|(
name|KV_SYNTAX
operator|)
return|;
case|case
name|GTOK_PUNK
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"\n"
argument_list|,
name|keyword
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|KV_EOL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|","
argument_list|,
name|keyword
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"expecting rvalue, found \'%s\'"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GTOK_STRING
case|:
case|case
name|GTOK_QSTRING
case|:
case|case
name|GTOK_NUMBER
case|:
name|gotit
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"panic: bad return (%d) from fGetToken()"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|KV_SYNTAX
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
name|gotit
condition|)
do|;
comment|/*      * now we expect an equal sign.      *          skip any whitespace      *          stop looking if we find an equal sign      *          anything else causes a syntax error      */
name|gotit
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
name|rc
operator|=
name|fGetToken
argument_list|(
name|fp
argument_list|,
name|value
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|GTOK_WHITE
case|:
break|break;
case|case
name|GTOK_BAD_QSTRING
case|:
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"expecting \'=\', found unterminated string \"%s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|KV_SYNTAX
operator|)
return|;
case|case
name|GTOK_PUNK
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"="
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gotit
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"\n"
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"expecting \"=\", found newline"
argument_list|)
expr_stmt|;
name|fUngetChar
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"expecting rvalue, found \'%s\'"
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|KV_SYNTAX
operator|)
return|;
block|}
break|break;
case|case
name|GTOK_STRING
case|:
case|case
name|GTOK_QSTRING
case|:
case|case
name|GTOK_NUMBER
case|:
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"expecting \'=\', found \"%s\""
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|KV_SYNTAX
operator|)
return|;
case|case
name|GTOK_EOF
case|:
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"expecting \'=\', found EOF"
argument_list|)
expr_stmt|;
return|return
operator|(
name|KV_SYNTAX
operator|)
return|;
default|default:
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"panic: bad return (%d) from fGetToken()"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|KV_SYNTAX
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
name|gotit
condition|)
do|;
comment|/*      * got the keyword and equal sign, now get a value.      *          ignore any whitespace      *          any punctuation is a syntax error      */
name|gotit
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
name|rc
operator|=
name|fGetToken
argument_list|(
name|fp
argument_list|,
name|value
argument_list|,
name|vlen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|GTOK_WHITE
case|:
break|break;
case|case
name|GTOK_EOF
case|:
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"expecting rvalue, found EOF"
argument_list|)
expr_stmt|;
return|return
operator|(
name|KV_SYNTAX
operator|)
return|;
case|case
name|GTOK_BAD_QSTRING
case|:
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"unterminated quoted string \"%s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|KV_SYNTAX
operator|)
return|;
case|case
name|GTOK_PUNK
case|:
if|if
condition|(
name|strcmp
argument_list|(
literal|"\n"
argument_list|,
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"expecting rvalue, found newline"
argument_list|)
expr_stmt|;
name|fUngetChar
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"expecting rvalue, found \'%s\'"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|KV_SYNTAX
operator|)
return|;
break|break;
case|case
name|GTOK_STRING
case|:
case|case
name|GTOK_QSTRING
case|:
case|case
name|GTOK_NUMBER
case|:
name|gotit
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|KV_OKAY
operator|)
return|;
default|default:
name|sprintf
argument_list|(
name|ErrorMsg
argument_list|,
literal|"panic: bad return (%d) from fGetToken()"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|KV_SYNTAX
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
name|gotit
condition|)
do|;
comment|/*NOTREACHED*/
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Routine Name: fGetToken  *  * Function: read the next token from the specified file.  * A token is defined as a group of characters  * terminated by a white space char (SPACE, CR,  * LF, FF, TAB). The token returned is stripped of  * both leading and trailing white space, and is  * terminated by a NULL terminator.  An alternate  * definition of a token is a string enclosed in  * single or double quotes.  *  * Explicit Parameters:  * fp              pointer to the input FILE  * dest    pointer to destination buffer  * maxlen  length of the destination buffer. The buffer  * length INCLUDES the NULL terminator.  *  * Implicit Parameters: stderr  where the "token too long" message goes  *  * External Procedures: fgetc  *  * Side Effects:                None  *  * Return Value:                A token classification value, as  *				defined in kparse.h. Note that the  *				classification for end of file is  *				always zero.  */
end_comment

begin_function
name|int
name|fGetToken
parameter_list|(
name|fp
parameter_list|,
name|dest
parameter_list|,
name|maxlen
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
block|{
name|int
name|ch
init|=
literal|'\0'
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|dest
decl_stmt|;
name|int
name|digits
decl_stmt|;
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/*      * check for a quoted string.  If found, take all characters      * that fit until a closing quote is found.  Note that this      * algorithm will not behave well for a string which is too long.      */
if|if
condition|(
name|ISQUOTE
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|int
name|done
init|=
name|FALSE
decl_stmt|;
do|do
block|{
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|done
operator|=
operator|(
operator|(
name|maxlen
operator|<
operator|++
name|len
operator|)
operator|||
name|ISLINEFEED
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
name|EOF
operator|)
operator|||
name|ISQUOTE
argument_list|(
name|ch
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
name|ch
operator|=
name|fGetLiteral
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|!=
name|EOF
operator|)
operator|&&
operator|!
name|ISQUOTE
argument_list|(
name|ch
argument_list|)
condition|)
name|fUngetChar
argument_list|(
name|ch
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
condition|)
do|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ISLINEFEED
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|GTOK_BAD_QSTRING
operator|)
return|;
return|return
operator|(
name|GTOK_QSTRING
operator|)
return|;
block|}
comment|/*      * Not a quoted string.  If its a token character (rules are      * defined via the ISTOKENCHAR macro, in kparse.h) take it and all      * token chars following it until we run out of space.      */
name|digits
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ISTOKENCHAR
argument_list|(
name|ch
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|ISTOKENCHAR
argument_list|(
name|ch
argument_list|)
operator|)
operator|&&
name|len
operator|<
name|maxlen
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
name|digits
operator|=
name|FALSE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
block|{
name|fUngetChar
argument_list|(
name|ch
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|digits
condition|)
block|{
return|return
operator|(
name|GTOK_NUMBER
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|GTOK_STRING
operator|)
return|;
block|}
block|}
comment|/*      * Neither a quoted string nor a token character.  Return a string      * with just that one character in it.      */
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
return|return
operator|(
name|GTOK_EOF
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ISWHITESPACE
argument_list|(
name|ch
argument_list|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|ch
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* white space is always the 				 * blank character */
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/*          * The character is a white space. Flush all additional white          * space.          */
while|while
condition|(
name|ISWHITESPACE
argument_list|(
name|ch
argument_list|)
operator|&&
operator|(
operator|(
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
block|{
name|fUngetChar
argument_list|(
name|ch
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|GTOK_WHITE
operator|)
return|;
block|}
return|return
operator|(
name|GTOK_PUNK
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * fGetLiteral is called after we find a '\' in the input stream.  A  * string of numbers following the backslash are converted to the  * appropriate value; hex (0xn), octal (0n), and decimal (otherwise)  * are all supported.  If the char after the \ is not a number, we  * special case certain values (\n, \f, \r, \b) or return a literal  * otherwise (useful for \", for example).  */
end_comment

begin_macro
name|fGetLiteral
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ch
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|base
decl_stmt|;
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'n'
case|:
return|return
operator|(
literal|'\n'
operator|)
return|;
case|case
literal|'f'
case|:
return|return
operator|(
literal|'\f'
operator|)
return|;
case|case
literal|'r'
case|:
return|return
operator|(
literal|'\r'
operator|)
return|;
case|case
literal|'b'
case|:
return|return
operator|(
literal|'\b'
operator|)
return|;
default|default:
return|return
operator|(
name|ch
operator|)
return|;
block|}
block|}
comment|/*      * got a number.  might be decimal (no prefix), octal (prefix 0),      * or hexadecimal (prefix 0x).  Set the base appropriately.      */
if|if
condition|(
name|ch
operator|!=
literal|'0'
condition|)
block|{
name|base
operator|=
literal|10
expr_stmt|;
comment|/* its a decimal number */
block|}
else|else
block|{
comment|/*          * found a zero, its either hex or octal          */
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|!=
literal|'x'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'X'
operator|)
condition|)
block|{
name|base
operator|=
literal|010
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|base
operator|=
literal|0x10
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|010
case|:
comment|/* octal */
while|while
condition|(
name|ISOCTAL
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|n
operator|=
operator|(
name|n
operator|*
name|base
operator|)
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|10
case|:
comment|/* decimal */
while|while
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|n
operator|=
operator|(
name|n
operator|*
name|base
operator|)
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|0x10
case|:
comment|/* hexadecimal */
while|while
condition|(
name|isxdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|n
operator|=
operator|(
name|n
operator|*
name|base
operator|)
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
operator|(
name|n
operator|*
name|base
operator|)
operator|+
name|toupper
argument_list|(
name|ch
argument_list|)
operator|-
literal|'A'
operator|+
literal|0xA
expr_stmt|;
block|}
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"fGetLiteral() died real bad. Fix gettoken.c."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|fUngetChar
argument_list|(
name|ch
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * exactly the same as ungetc(3) except that the line number of the  * input file is maintained.  */
end_comment

begin_macro
name|fUngetChar
argument_list|(
argument|ch
argument_list|,
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|LineNbr
operator|--
expr_stmt|;
return|return
operator|(
name|ungetc
argument_list|(
name|ch
argument_list|,
name|fp
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * exactly the same as fgetc(3) except that the line number of the  * input file is maintained.  */
end_comment

begin_macro
name|fGetChar
argument_list|(
argument|fp
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ch
init|=
name|fgetc
argument_list|(
name|fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|LineNbr
operator|++
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Routine Name: strsave  *  * Function: return a pointer to a saved copy of the  * input string. the copy will be allocated  * as large as necessary.  *  * Explicit Parameters: pointer to string to save  *  * Implicit Parameters: None  *  * External Procedures: malloc,strcpy,strlen  *  * Side Effects: None  *  * Return Value: pointer to copied string  *  */
end_comment

begin_function
name|char
modifier|*
name|strsave
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
return|return
operator|(
name|strcpy
argument_list|(
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * strutol changes all characters in a string to lower case, in place.  * the pointer to the beginning of the string is returned.  */
end_comment

begin_function
name|char
modifier|*
name|strutol
parameter_list|(
name|start
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
block|{
name|char
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|start
init|;
operator|*
name|q
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|q
argument_list|)
condition|)
operator|*
name|q
operator|=
name|tolower
argument_list|(
operator|*
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|start
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|GTOK_TEST
end_ifdef

begin_comment
comment|/* mainline test routine for fGetToken() */
end_comment

begin_define
define|#
directive|define
name|MAXTOKEN
value|100
end_define

begin_decl_stmt
name|char
modifier|*
name|pgm
init|=
literal|"gettoken"
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|type
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|--
name|argc
condition|)
block|{
name|fp
operator|=
name|fopen
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"ra"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
operator|(
name|FILE
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can\'t open \"%s\"\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|fp
operator|=
name|stdin
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
name|MAXTOKEN
argument_list|)
expr_stmt|;
while|while
condition|(
name|type
operator|=
name|fGetToken
argument_list|(
name|fp
argument_list|,
name|p
argument_list|,
name|MAXTOKEN
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GTOK_BAD_QSTRING
case|:
name|printf
argument_list|(
literal|"BAD QSTRING!\t"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTOK_EOF
case|:
name|printf
argument_list|(
literal|"EOF!\t"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTOK_QSTRING
case|:
name|printf
argument_list|(
literal|"QSTRING\t"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTOK_STRING
case|:
name|printf
argument_list|(
literal|"STRING\t"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTOK_NUMBER
case|:
name|printf
argument_list|(
literal|"NUMBER\t"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTOK_PUNK
case|:
name|printf
argument_list|(
literal|"PUNK\t"
argument_list|)
expr_stmt|;
break|break;
case|case
name|GTOK_WHITE
case|:
name|printf
argument_list|(
literal|"WHITE\t"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"HUH?\t"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|printf
argument_list|(
literal|"\\n\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|KVTEST
end_ifdef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|ch
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|key
index|[
name|MAXKEY
index|]
decl_stmt|,
name|valu
index|[
name|MAXVALUE
index|]
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: test<filename>\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can\'t open input file \"%s\"\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
operator|*
name|argv
expr_stmt|;
while|while
condition|(
operator|(
name|rc
operator|=
name|fGetKeywordValue
argument_list|(
name|fp
argument_list|,
name|key
argument_list|,
name|MAXKEY
argument_list|,
name|valu
argument_list|,
name|MAXVALUE
argument_list|)
operator|)
operator|!=
name|KV_EOF
condition|)
block|{
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|KV_EOL
case|:
name|printf
argument_list|(
literal|"%s, line %d: nada mas.\n"
argument_list|,
name|filename
argument_list|,
name|LineNbr
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|KV_SYNTAX
case|:
name|printf
argument_list|(
literal|"%s, line %d: syntax error: %s\n"
argument_list|,
name|filename
argument_list|,
name|LineNbr
argument_list|,
name|ErrorMsg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
condition|)
empty_stmt|;
break|break;
case|case
name|KV_OKAY
case|:
name|printf
argument_list|(
literal|"%s, line %d: okay, %s=\"%s\"\n"
argument_list|,
name|filename
argument_list|,
name|LineNbr
argument_list|,
name|key
argument_list|,
name|valu
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"panic: bad return (%d) from fGetKeywordValue\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"EOF"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|PSTEST
end_ifdef

begin_decl_stmt
name|parmtable
name|kparm
index|[]
init|=
block|{
comment|/*  keyword, default, found value */
block|{
literal|"user"
block|,
literal|""
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
block|,
block|{
literal|"realm"
block|,
literal|"Athena"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
block|,
block|{
literal|"instance"
block|,
literal|""
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|,
name|ch
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: test<filename>\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
operator|*
operator|++
name|argv
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"can\'t open input file \"%s\"\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
operator|*
name|argv
expr_stmt|;
while|while
condition|(
operator|(
name|rc
operator|=
name|fGetParameterSet
argument_list|(
name|fp
argument_list|,
name|kparm
argument_list|,
name|PARMCOUNT
argument_list|(
name|kparm
argument_list|)
argument_list|)
operator|)
operator|!=
name|PS_EOF
condition|)
block|{
switch|switch
condition|(
name|rc
condition|)
block|{
case|case
name|PS_BAD_KEYWORD
case|:
name|printf
argument_list|(
literal|"%s, line %d: %s\n"
argument_list|,
name|filename
argument_list|,
name|LineNbr
argument_list|,
name|ErrorMsg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
condition|)
empty_stmt|;
break|break;
case|case
name|PS_SYNTAX
case|:
name|printf
argument_list|(
literal|"%s, line %d: syntax error: %s\n"
argument_list|,
name|filename
argument_list|,
name|LineNbr
argument_list|,
name|ErrorMsg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|ch
operator|=
name|fGetChar
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
condition|)
empty_stmt|;
break|break;
case|case
name|PS_OKAY
case|:
name|printf
argument_list|(
literal|"%s, line %d: valid parameter set found:\n"
argument_list|,
name|filename
argument_list|,
name|LineNbr
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PARMCOUNT
argument_list|(
name|kparm
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\t%s = \"%s\"\n"
argument_list|,
name|kparm
index|[
name|i
index|]
operator|.
name|keyword
argument_list|,
operator|(
name|kparm
index|[
name|i
index|]
operator|.
name|value
condition|?
name|kparm
index|[
name|i
index|]
operator|.
name|value
else|:
name|kparm
index|[
name|i
index|]
operator|.
name|defvalue
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"panic: bad return (%d) from fGetParameterSet\n"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
break|break;
block|}
name|FreeParameterSet
argument_list|(
name|kparm
argument_list|,
name|PARMCOUNT
argument_list|(
name|kparm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"EOF"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

