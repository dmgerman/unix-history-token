begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1987, 1988 by the Massachusetts Institute of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  *	from: recvauth.c,v 4.4 90/03/10 19:03:08 jon Exp $";  * $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char rcsid[] = "$FreeBSD$";
endif|#
directive|endif
endif|lint
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_define
define|#
directive|define
name|KRB_SENDAUTH_VERS
value|"AUTHV0.1"
end_define

begin_comment
comment|/* MUST be KRB_SENDAUTH_VLEN 					      chars */
end_comment

begin_comment
comment|/*  * If the protocol changes, you will need to change the version string  * and make appropriate changes in krb_sendauth.c  * be sure to support old versions of krb_sendauth!  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * krb_recvauth() reads (and optionally responds to) a message sent  * using krb_sendauth().  The "options" argument is a bit-field of  * selected options (see "sendauth.c" for options description).  * The only option relevant to krb_recvauth() is KOPT_DO_MUTUAL  * (mutual authentication requested).  The "fd" argument supplies  * a file descriptor to read from (and write to, if mutual authenti-  * cation is requested).  *  * Part of the received message will be a Kerberos ticket sent by the  * client; this is read into the "ticket" argument.  The "service" and  * "instance" arguments supply the server's Kerberos name.  If the  * "instance" argument is the string "*", it is treated as a wild card  * and filled in during the krb_rd_req() call (see read_service_key()).  *  * The "faddr" and "laddr" give the sending (client) and receiving  * (local server) network addresses.  ("laddr" may be left NULL unless  * mutual authentication is requested, in which case it must be set.)  *  * The authentication information extracted from the message is returned  * in "kdata".  The "filename" argument indicates the file where the  * server's key can be found.  (It is passed on to krb_rd_req().)  If  * left null, the default "/etc/srvtab" will be used.  *  * If mutual authentication is requested, the session key schedule must  * be computed in order to reply; this schedule is returned in the  * "schedule" argument.  A string containing the application version  * number from the received message is returned in "version", which  * should be large enough to hold a KRB_SENDAUTH_VLEN-character string.  *  * See krb_sendauth() for the format of the received client message.  *  * This routine supports another client format, for backward  * compatibility, consisting of:  *  * Size			Variable		Field  * ----			--------		-----  *  * string		tmp_buf, tkt_len	length of ticket, in  * 						ascii  *  * char			' ' (space char)	separator  *  * tkt_len		ticket->dat		the ticket  *  * This old-style version does not support mutual authentication.  *  * krb_recvauth() first reads the protocol version string from the  * given file descriptor.  If it doesn't match the current protocol  * version (KRB_SENDAUTH_VERS), the old-style format is assumed.  In  * that case, the string of characters up to the first space is read  * and interpreted as the ticket length, then the ticket is read.  *  * If the first string did match KRB_SENDAUTH_VERS, krb_recvauth()  * next reads the application protocol version string.  Then the  * ticket length and ticket itself are read.  *  * The ticket is decrypted and checked by the call to krb_rd_req().  * If no mutual authentication is required, the result of the  * krb_rd_req() call is retured by this routine.  If mutual authenti-  * cation is required, a message in the following format is returned  * on "fd":  *  * Size			Variable		Field  * ----			--------		-----  *  * 4 bytes		tkt_len			length of ticket or -1  *						if error occurred  *  * priv_len		tmp_buf			"private" message created  *						by krb_mk_priv() which  *						contains the incremented  *						checksum sent by the client  *						encrypted in the session  *						key.  (This field is not  *						present in case of error.)  *  * If all goes well, KSUCCESS is returned; otherwise KFAILURE or some  * other error code is returned.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|max
end_ifndef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b)) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* max */
end_comment

begin_function
name|int
name|krb_recvauth
parameter_list|(
name|options
parameter_list|,
name|fd
parameter_list|,
name|ticket
parameter_list|,
name|service
parameter_list|,
name|instance
parameter_list|,
name|faddr
parameter_list|,
name|laddr
parameter_list|,
name|kdata
parameter_list|,
name|filename
parameter_list|,
name|schedule
parameter_list|,
name|version
parameter_list|)
name|long
name|options
decl_stmt|;
comment|/* bit-pattern of options */
name|int
name|fd
decl_stmt|;
comment|/* file descr. to read from */
name|KTEXT
name|ticket
decl_stmt|;
comment|/* storage for client's ticket */
name|char
modifier|*
name|service
decl_stmt|;
comment|/* service expected */
name|char
modifier|*
name|instance
decl_stmt|;
comment|/* inst expected (may be filled in) */
name|struct
name|sockaddr_in
modifier|*
name|faddr
decl_stmt|;
comment|/* address of foreign host on fd */
name|struct
name|sockaddr_in
modifier|*
name|laddr
decl_stmt|;
comment|/* local address */
name|AUTH_DAT
modifier|*
name|kdata
decl_stmt|;
comment|/* kerberos data (returned) */
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* name of file with service keys */
name|Key_schedule
name|schedule
decl_stmt|;
comment|/* key schedule (return) */
name|char
modifier|*
name|version
decl_stmt|;
comment|/* version string (filled in) */
block|{
name|int
name|i
decl_stmt|,
name|cc
decl_stmt|,
name|old_vers
init|=
literal|0
decl_stmt|;
name|char
name|krb_vers
index|[
name|KRB_SENDAUTH_VLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* + 1 for the null terminator */
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|rem
decl_stmt|;
name|long
name|tkt_len
decl_stmt|,
name|priv_len
decl_stmt|;
name|u_long
name|cksum
decl_stmt|;
name|u_char
name|tmp_buf
index|[
name|MAX_KTXT_LEN
operator|+
name|max
argument_list|(
name|KRB_SENDAUTH_VLEN
operator|+
literal|1
argument_list|,
literal|21
argument_list|)
index|]
decl_stmt|;
comment|/* read the protocol version number */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
name|krb_vers
argument_list|,
name|KRB_SENDAUTH_VLEN
argument_list|)
operator|!=
name|KRB_SENDAUTH_VLEN
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|krb_vers
index|[
name|KRB_SENDAUTH_VLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* check version string */
if|if
condition|(
name|strcmp
argument_list|(
name|krb_vers
argument_list|,
name|KRB_SENDAUTH_VERS
argument_list|)
condition|)
block|{
comment|/* Assume the old version of sendkerberosdata: send ascii 	   length, ' ', and ticket. */
if|if
condition|(
name|options
operator|&
name|KOPT_DO_MUTUAL
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
comment|/* XXX can't do old style with mutual auth */
name|old_vers
operator|=
literal|1
expr_stmt|;
comment|/* copy what we have read into tmp_buf */
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|krb_vers
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmp_buf
argument_list|,
name|KRB_SENDAUTH_VLEN
argument_list|)
expr_stmt|;
comment|/* search for space, and make it a null */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KRB_SENDAUTH_VLEN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tmp_buf
index|[
name|i
index|]
operator|==
literal|' '
condition|)
block|{
name|tmp_buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* point cp to the beginning of the real ticket */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp_buf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|KRB_SENDAUTH_VLEN
condition|)
comment|/* didn't find the space, keep reading to find it */
for|for
control|(
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp_buf
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
return|return
operator|(
name|KFAILURE
operator|)
return|;
block|}
if|if
condition|(
name|tmp_buf
index|[
name|i
index|]
operator|==
literal|' '
condition|)
block|{
name|tmp_buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* point cp to the beginning of the real ticket */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp_buf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
break|break;
block|}
block|}
name|tkt_len
operator|=
operator|(
name|long
operator|)
name|atoi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp_buf
argument_list|)
expr_stmt|;
comment|/* sanity check the length */
if|if
condition|(
operator|(
name|i
operator|==
literal|20
operator|)
operator|||
operator|(
name|tkt_len
operator|<=
literal|0
operator|)
operator|||
operator|(
name|tkt_len
operator|>
name|MAX_KTXT_LEN
operator|)
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
if|if
condition|(
name|i
operator|<
name|KRB_SENDAUTH_VLEN
condition|)
block|{
comment|/* since we already got the space, and part of the ticket, 	       we read fewer bytes to get the rest of the ticket */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tmp_buf
operator|+
name|KRB_SENDAUTH_VLEN
operator|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tkt_len
operator|-
name|KRB_SENDAUTH_VLEN
operator|+
literal|1
operator|+
name|i
argument_list|)
argument_list|)
operator|!=
call|(
name|int
call|)
argument_list|(
name|tkt_len
operator|-
name|KRB_SENDAUTH_VLEN
operator|+
literal|1
operator|+
name|i
argument_list|)
condition|)
return|return
operator|(
name|errno
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tmp_buf
operator|+
name|i
operator|)
argument_list|,
operator|(
name|int
operator|)
name|tkt_len
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|tkt_len
condition|)
return|return
operator|(
name|errno
operator|)
return|;
block|}
name|ticket
operator|->
name|length
operator|=
name|tkt_len
expr_stmt|;
comment|/* copy the ticket into the struct */
operator|(
name|void
operator|)
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ticket
operator|->
name|dat
argument_list|,
name|ticket
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* read the application version string */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
name|version
argument_list|,
name|KRB_SENDAUTH_VLEN
argument_list|)
operator|!=
name|KRB_SENDAUTH_VLEN
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|version
index|[
name|KRB_SENDAUTH_VLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* get the length of the ticket */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tkt_len
argument_list|,
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* sanity check */
name|ticket
operator|->
name|length
operator|=
name|ntohl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|tkt_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ticket
operator|->
name|length
operator|<=
literal|0
operator|)
operator|||
operator|(
name|ticket
operator|->
name|length
operator|>
name|MAX_KTXT_LEN
operator|)
condition|)
block|{
if|if
condition|(
name|options
operator|&
name|KOPT_DO_MUTUAL
condition|)
block|{
name|rem
operator|=
name|KFAILURE
expr_stmt|;
goto|goto
name|mutual_fail
goto|;
block|}
else|else
return|return
operator|(
name|KFAILURE
operator|)
return|;
comment|/* XXX there may still be junk on the fd? */
block|}
comment|/* read the ticket */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ticket
operator|->
name|dat
argument_list|,
name|ticket
operator|->
name|length
argument_list|)
operator|!=
name|ticket
operator|->
name|length
condition|)
return|return
operator|(
name|errno
operator|)
return|;
block|}
comment|/*      * now have the ticket.  decrypt it to get the authenticated      * data.      */
name|rem
operator|=
name|krb_rd_req
argument_list|(
name|ticket
argument_list|,
name|service
argument_list|,
name|instance
argument_list|,
name|faddr
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|kdata
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_vers
condition|)
return|return
operator|(
name|rem
operator|)
return|;
comment|/* XXX can't do mutual with old client */
comment|/* if we are doing mutual auth, compose a response */
if|if
condition|(
name|options
operator|&
name|KOPT_DO_MUTUAL
condition|)
block|{
if|if
condition|(
name|rem
operator|!=
name|KSUCCESS
condition|)
comment|/* the krb_rd_req failed */
goto|goto
name|mutual_fail
goto|;
comment|/* add one to the (formerly) sealed checksum, and re-seal it 	   for return to the client */
name|cksum
operator|=
name|kdata
operator|->
name|checksum
operator|+
literal|1
expr_stmt|;
name|cksum
operator|=
name|htonl
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
name|key_sched
argument_list|(
operator|(
name|C_Block
operator|*
operator|)
name|kdata
operator|->
name|session
argument_list|,
name|schedule
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|priv_len
operator|=
name|krb_mk_priv
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|cksum
argument_list|,
name|tmp_buf
argument_list|,
operator|(
name|unsigned
name|long
operator|)
sizeof|sizeof
argument_list|(
name|cksum
argument_list|)
argument_list|,
name|schedule
argument_list|,
name|kdata
operator|->
name|session
argument_list|,
name|laddr
argument_list|,
name|faddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv_len
operator|<
literal|0
condition|)
block|{
comment|/* re-sealing failed; notify the client */
name|rem
operator|=
name|KFAILURE
expr_stmt|;
comment|/* XXX */
name|mutual_fail
label|:
name|priv_len
operator|=
operator|-
literal|1
expr_stmt|;
name|tkt_len
operator|=
name|htonl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|priv_len
argument_list|)
expr_stmt|;
comment|/* a length of -1 is interpreted as an authentication 	       failure by the client */
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_net_write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tkt_len
argument_list|,
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
argument_list|)
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
condition|)
return|return
operator|(
name|cc
operator|)
return|;
return|return
operator|(
name|rem
operator|)
return|;
block|}
else|else
block|{
comment|/* re-sealing succeeded, send the private message */
name|tkt_len
operator|=
name|htonl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|priv_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_net_write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tkt_len
argument_list|,
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
argument_list|)
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
condition|)
return|return
operator|(
name|cc
operator|)
return|;
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_net_write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmp_buf
argument_list|,
operator|(
name|int
operator|)
name|priv_len
argument_list|)
operator|)
operator|!=
operator|(
name|int
operator|)
name|priv_len
condition|)
return|return
operator|(
name|cc
operator|)
return|;
block|}
block|}
return|return
operator|(
name|rem
operator|)
return|;
block|}
end_function

end_unit

