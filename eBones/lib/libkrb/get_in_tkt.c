begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1987, 1988 by the Massachusetts Institute of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  *	from: get_in_tkt.c,v 4.12 89/07/18 16:32:56 jtkohl Exp $  * $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char rcsid[] = "$FreeBSD$";
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<prot.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This file contains two routines: passwd_to_key() converts  * a password into a DES key (prompting for the password if  * not supplied), and krb_get_pw_in_tkt() gets an initial ticket for  * a user.  */
end_comment

begin_comment
comment|/*  * passwd_to_key(): given a password, return a DES key.  * There are extra arguments here which (used to be?)  * used by srvtab_to_key().  *  * If the "passwd" argument is not null, generate a DES  * key from it, using string_to_key().  *  * If the "passwd" argument is null, call des_read_password()  * to prompt for a password and then convert it into a DES key.  *  * In either case, the resulting key is put in the "key" argument,  * and 0 is returned.  */
end_comment

begin_comment
comment|/*ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|passwd_to_key
parameter_list|(
name|user
parameter_list|,
name|instance
parameter_list|,
name|realm
parameter_list|,
name|passwd
parameter_list|,
name|key
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|,
decl|*
name|instance
decl_stmt|,
modifier|*
name|realm
decl_stmt|,
modifier|*
name|passwd
decl_stmt|;
end_function

begin_decl_stmt
name|C_Block
modifier|*
name|key
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|NOENCRYPTION
if|if
condition|(
operator|!
name|passwd
condition|)
name|placebo_read_password
argument_list|(
name|key
argument_list|,
literal|"Password: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|passwd
condition|)
name|string_to_key
argument_list|(
name|passwd
argument_list|,
name|key
argument_list|)
expr_stmt|;
else|else
name|des_read_password
argument_list|(
name|key
argument_list|,
literal|"Password: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * krb_get_pw_in_tkt() takes the name of the server for which the initial  * ticket is to be obtained, the name of the principal the ticket is  * for, the desired lifetime of the ticket, and the user's password.  * It passes its arguments on to krb_get_in_tkt(), which contacts  * Kerberos to get the ticket, decrypts it using the password provided,  * and stores it away for future use.  *  * krb_get_pw_in_tkt() passes two additional arguments to krb_get_in_tkt():  * the name of a routine (passwd_to_key()) to be used to get the  * password in case the "password" argument is null and NULL for the  * decryption procedure indicating that krb_get_in_tkt should use the  * default method of decrypting the response from the KDC.  *  * The result of the call to krb_get_in_tkt() is returned.  */
end_comment

begin_function
name|int
name|krb_get_pw_in_tkt
parameter_list|(
name|user
parameter_list|,
name|instance
parameter_list|,
name|realm
parameter_list|,
name|service
parameter_list|,
name|sinstance
parameter_list|,
name|life
parameter_list|,
name|password
parameter_list|)
name|char
modifier|*
name|user
decl_stmt|,
decl|*
name|instance
decl_stmt|,
modifier|*
name|realm
decl_stmt|,
modifier|*
name|service
decl_stmt|,
modifier|*
name|sinstance
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|life
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|password
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|krb_get_in_tkt
argument_list|(
name|user
argument_list|,
name|instance
argument_list|,
name|realm
argument_list|,
name|service
argument_list|,
name|sinstance
argument_list|,
name|life
argument_list|,
name|passwd_to_key
argument_list|,
name|NULL
argument_list|,
name|password
argument_list|)
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|NOENCRYPTION
end_ifdef

begin_comment
comment|/*  * $Source: /usr/cvs/src/eBones/krb/get_in_tkt.c,v $  * $Author: mark $  *  * Copyright 1985, 1986, 1987, 1988 by the Massachusetts Institute  * of Technology.  *  * For copying and distribution information, please see the file  *<mit-copyright.h>.  *  * This routine prints the supplied string to standard  * output as a prompt, and reads a password string without  * echoing.  */
end_comment

begin_include
include|#
directive|include
file|<des.h>
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BSDUNIX
end_ifdef

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* char     *strcpy(); int      strcmp(); */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSDUNIX
end_ifdef

begin_decl_stmt
specifier|static
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSDUNIX
end_ifdef

begin_function_decl
specifier|static
name|void
name|sig_restore
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|push_signals
argument_list|()
operator|,
name|pop_signals
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
name|placebo_read_pw_string
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*** Routines ****************************************************** */
end_comment

begin_function
name|int
name|placebo_read_password
parameter_list|(
name|k
parameter_list|,
name|prompt
parameter_list|,
name|verify
parameter_list|)
name|des_cblock
modifier|*
name|k
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|verify
decl_stmt|;
block|{
name|int
name|ok
decl_stmt|;
name|char
name|key_string
index|[
name|BUFSIZ
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|BSDUNIX
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
condition|)
block|{
name|ok
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|lose
goto|;
block|}
endif|#
directive|endif
name|ok
operator|=
name|placebo_read_pw_string
argument_list|(
name|key_string
argument_list|,
name|BUFSIZ
argument_list|,
name|prompt
argument_list|,
name|verify
argument_list|)
expr_stmt|;
if|if
condition|(
name|ok
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|k
argument_list|,
sizeof|sizeof
argument_list|(
name|C_Block
argument_list|)
argument_list|)
expr_stmt|;
name|lose
label|:
name|bzero
argument_list|(
name|key_string
argument_list|,
sizeof|sizeof
argument_list|(
name|key_string
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/*  * This version just returns the string, doesn't map to key.  *  * Returns 0 on success, non-zero on failure.  */
end_comment

begin_function
name|int
name|placebo_read_pw_string
parameter_list|(
name|s
parameter_list|,
name|max
parameter_list|,
name|prompt
parameter_list|,
name|verify
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|max
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
name|int
name|verify
decl_stmt|;
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|BSDUNIX
name|jmp_buf
name|old_env
decl_stmt|;
name|struct
name|sgttyb
name|tty_state
decl_stmt|;
endif|#
directive|endif
name|char
name|key_string
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|max
operator|>
name|BUFSIZ
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|BSDUNIX
name|bcopy
argument_list|(
name|old_env
argument_list|,
name|env
argument_list|,
sizeof|sizeof
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
condition|)
goto|goto
name|lose
goto|;
comment|/* save terminal state*/
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|tty_state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|push_signals
argument_list|()
expr_stmt|;
comment|/* Turn off echo */
name|tty_state
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|tty_state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
while|while
condition|(
operator|!
name|ok
condition|)
block|{
name|printf
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CROSSMSDOS
name|h19line
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|s
argument_list|)
condition|)
continue|continue;
else|#
directive|else
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|s
argument_list|,
name|max
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|verify
condition|)
block|{
name|printf
argument_list|(
literal|"\nVerifying, please re-enter %s"
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CROSSMSDOS
name|h19line
argument_list|(
name|key_string
argument_list|,
sizeof|sizeof
argument_list|(
name|key_string
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|key_string
argument_list|)
condition|)
continue|continue;
else|#
directive|else
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|key_string
argument_list|,
sizeof|sizeof
argument_list|(
name|key_string
argument_list|)
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ptr
operator|=
name|index
argument_list|(
name|key_string
argument_list|,
literal|'\n'
argument_list|)
operator|)
condition|)
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
name|key_string
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"\n\07\07Mismatch - try again\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|ok
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BSDUNIX
name|lose
label|:
if|if
condition|(
operator|!
name|ok
condition|)
name|bzero
argument_list|(
name|s
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* turn echo back on */
name|tty_state
operator|.
name|sg_flags
operator||=
name|ECHO
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
literal|0
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|tty_state
argument_list|)
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
name|pop_signals
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|env
argument_list|,
name|old_env
argument_list|,
sizeof|sizeof
argument_list|(
name|env
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|verify
condition|)
name|bzero
argument_list|(
name|key_string
argument_list|,
sizeof|sizeof
argument_list|(
name|key_string
argument_list|)
argument_list|)
expr_stmt|;
name|s
index|[
name|max
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* force termination */
return|return
operator|!
name|ok
return|;
comment|/* return nonzero if not okay */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BSDUNIX
end_ifdef

begin_comment
comment|/*  * this can be static since we should never have more than  * one set saved....  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|POSIX
end_ifdef

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|old_sigfunc
index|[
name|NSIG
index|]
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|old_sigfunc
index|[
name|NSIG
index|]
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|POSIX
end_endif

begin_expr_stmt
specifier|static
name|push_signals
argument_list|()
block|{
specifier|register
name|i
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
name|old_sigfunc
index|[
name|i
index|]
operator|=
name|signal
argument_list|(
name|i
argument_list|,
name|sig_restore
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|pop_signals
argument_list|()
block|{
specifier|register
name|i
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
name|signal
argument_list|(
name|i
argument_list|,
name|old_sigfunc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_function
specifier|static
name|void
name|sig_restore
parameter_list|(
name|sig
parameter_list|,
name|code
parameter_list|,
name|scp
parameter_list|)
name|int
name|sig
decl_stmt|,
name|code
decl_stmt|;
name|struct
name|sigcontext
modifier|*
name|scp
decl_stmt|;
block|{
name|longjmp
argument_list|(
name|env
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOENCRYPTION */
end_comment

end_unit

