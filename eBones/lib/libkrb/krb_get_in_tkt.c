begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1986, 1987, 1988 by the Massachusetts Institute  * of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  *	from: der: krb_get_in_tkt.c,v 4.19 89/07/18 16:31:31 jtkohl Exp $  * $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char *rcsid = "$FreeBSD$";
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<des.h>
end_include

begin_include
include|#
directive|include
file|<prot.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* use the bsd time.h struct defs for PC too! */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_decl_stmt
name|int
name|swap_bytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * decrypt_tkt(): Given user, instance, realm, passwd, key_proc  * and the cipher text sent from the KDC, decrypt the cipher text  * using the key returned by key_proc.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|decrypt_tkt
argument_list|(
name|user
argument_list|,
name|instance
argument_list|,
name|realm
argument_list|,
name|arg
argument_list|,
name|key_proc
argument_list|,
name|cipp
argument_list|)
name|char
modifier|*
name|user
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|instance
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|realm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|key_proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|KTEXT
modifier|*
name|cipp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|KTEXT
name|cip
init|=
operator|*
name|cipp
decl_stmt|;
name|C_Block
name|key
decl_stmt|;
comment|/* Key for decrypting cipher */
name|Key_schedule
name|key_s
decl_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
comment|/* Attempt to decrypt it */
endif|#
directive|endif
comment|/* generate a key */
block|{
specifier|register
name|int
name|rc
decl_stmt|;
name|rc
operator|=
call|(
modifier|*
name|key_proc
call|)
argument_list|(
name|user
argument_list|,
name|instance
argument_list|,
name|realm
argument_list|,
name|arg
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NOENCRYPTION
name|key_sched
argument_list|(
operator|&
name|key
argument_list|,
name|key_s
argument_list|)
expr_stmt|;
name|pcbc_encrypt
argument_list|(
operator|(
name|C_Block
operator|*
operator|)
name|cip
operator|->
name|dat
argument_list|,
operator|(
name|C_Block
operator|*
operator|)
name|cip
operator|->
name|dat
argument_list|,
operator|(
name|long
operator|)
name|cip
operator|->
name|length
argument_list|,
name|key_s
argument_list|,
operator|(
name|C_Block
operator|*
operator|)
name|key
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !NOENCRYPTION */
comment|/* Get rid of all traces of key */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key_s
argument_list|,
sizeof|sizeof
argument_list|(
name|key_s
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * krb_get_in_tkt() gets a ticket for a given principal to use a given  * service and stores the returned ticket and session key for future  * use.  *  * The "user", "instance", and "realm" arguments give the identity of  * the client who will use the ticket.  The "service" and "sinstance"  * arguments give the identity of the server that the client wishes  * to use.  (The realm of the server is the same as the Kerberos server  * to whom the request is sent.)  The "life" argument indicates the  * desired lifetime of the ticket; the "key_proc" argument is a pointer  * to the routine used for getting the client's private key to decrypt  * the reply from Kerberos.  The "decrypt_proc" argument is a pointer  * to the routine used to decrypt the reply from Kerberos; and "arg"  * is an argument to be passed on to the "key_proc" routine.  *  * If all goes well, krb_get_in_tkt() returns INTK_OK, otherwise it  * returns an error code:  If an AUTH_MSG_ERR_REPLY packet is returned  * by Kerberos, then the error code it contains is returned.  Other  * error codes returned by this routine include INTK_PROT to indicate  * wrong protocol version, INTK_BADPW to indicate bad password (if  * decrypted ticket didn't make sense), INTK_ERR if the ticket was for  * the wrong server or the ticket store couldn't be initialized.  *  * The format of the message sent to Kerberos is as follows:  *  * Size			Variable		Field  * ----			--------		-----  *  * 1 byte		KRB_PROT_VERSION	protocol version number  * 1 byte		AUTH_MSG_KDC_REQUEST |	message type  *			HOST_BYTE_ORDER		local byte order in lsb  * string		user			client's name  * string		instance		client's instance  * string		realm			client's realm  * 4 bytes		tlocal.tv_sec		timestamp in seconds  * 1 byte		life			desired lifetime  * string		service			service's name  * string		sinstance		service's instance  */
end_comment

begin_decl_stmt
name|int
name|krb_get_in_tkt
argument_list|(
name|user
argument_list|,
name|instance
argument_list|,
name|realm
argument_list|,
name|service
argument_list|,
name|sinstance
argument_list|,
name|life
argument_list|,
name|key_proc
argument_list|,
name|decrypt_proc
argument_list|,
name|arg
argument_list|)
name|char
modifier|*
name|user
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|instance
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|realm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|service
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|sinstance
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|life
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|key_proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|decrypt_proc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|KTEXT_ST
name|pkt_st
decl_stmt|;
name|KTEXT
name|pkt
init|=
operator|&
name|pkt_st
decl_stmt|;
comment|/* Packet to KDC */
name|KTEXT_ST
name|rpkt_st
decl_stmt|;
name|KTEXT
name|rpkt
init|=
operator|&
name|rpkt_st
decl_stmt|;
comment|/* Returned packet */
name|KTEXT_ST
name|cip_st
decl_stmt|;
name|KTEXT
name|cip
init|=
operator|&
name|cip_st
decl_stmt|;
comment|/* Returned Ciphertext */
name|KTEXT_ST
name|tkt_st
decl_stmt|;
name|KTEXT
name|tkt
init|=
operator|&
name|tkt_st
decl_stmt|;
comment|/* Current ticket */
name|C_Block
name|ses
decl_stmt|;
comment|/* Session key for tkt */
name|int
name|kvno
decl_stmt|;
comment|/* Kvno for session key */
name|unsigned
name|char
modifier|*
name|v
init|=
name|pkt
operator|->
name|dat
decl_stmt|;
comment|/* Prot vers no */
name|unsigned
name|char
modifier|*
name|t
init|=
operator|(
name|pkt
operator|->
name|dat
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* Prot msg type */
name|char
name|s_name
index|[
name|SNAME_SZ
index|]
decl_stmt|;
name|char
name|s_instance
index|[
name|INST_SZ
index|]
decl_stmt|;
name|char
name|rlm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|int
name|lifetime
decl_stmt|;
name|int
name|msg_byte_order
decl_stmt|;
name|int
name|kerror
decl_stmt|;
name|unsigned
name|long
name|exp_date
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|timeval
name|t_local
decl_stmt|;
name|unsigned
name|long
name|rep_err_code
decl_stmt|;
name|unsigned
name|long
name|kdc_time
decl_stmt|;
comment|/* KDC time */
comment|/* BUILD REQUEST PACKET */
comment|/* Set up the fixed part of the packet */
operator|*
name|v
operator|=
operator|(
name|unsigned
name|char
operator|)
name|KRB_PROT_VERSION
expr_stmt|;
operator|*
name|t
operator|=
operator|(
name|unsigned
name|char
operator|)
name|AUTH_MSG_KDC_REQUEST
expr_stmt|;
operator|*
name|t
operator||=
name|HOST_BYTE_ORDER
expr_stmt|;
comment|/* Now for the variable info */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|->
name|dat
operator|+
literal|2
operator|)
argument_list|,
name|user
argument_list|)
expr_stmt|;
comment|/* aname */
name|pkt
operator|->
name|length
operator|=
literal|3
operator|+
name|strlen
argument_list|(
name|user
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|->
name|dat
operator|+
name|pkt
operator|->
name|length
operator|)
argument_list|,
name|instance
argument_list|)
expr_stmt|;
comment|/* instance */
name|pkt
operator|->
name|length
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|instance
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|->
name|dat
operator|+
name|pkt
operator|->
name|length
operator|)
argument_list|,
name|realm
argument_list|)
expr_stmt|;
comment|/* realm */
name|pkt
operator|->
name|length
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|realm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t_local
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* timestamp */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|t_local
operator|.
name|tv_sec
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|->
name|dat
operator|+
name|pkt
operator|->
name|length
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|length
operator|+=
literal|4
expr_stmt|;
operator|*
operator|(
name|pkt
operator|->
name|dat
operator|+
operator|(
name|pkt
operator|->
name|length
operator|)
operator|++
operator|)
operator|=
operator|(
name|char
operator|)
name|life
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|->
name|dat
operator|+
name|pkt
operator|->
name|length
operator|)
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|length
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|service
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|->
name|dat
operator|+
name|pkt
operator|->
name|length
operator|)
argument_list|,
name|sinstance
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|length
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|sinstance
argument_list|)
expr_stmt|;
name|rpkt
operator|->
name|length
operator|=
literal|0
expr_stmt|;
comment|/* SEND THE REQUEST AND RECEIVE THE RETURN PACKET */
if|if
condition|(
operator|(
name|kerror
operator|=
name|send_to_kdc
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
name|realm
argument_list|)
operator|)
condition|)
return|return
operator|(
name|kerror
operator|)
return|;
comment|/* check packet version of the returned packet */
if|if
condition|(
name|pkt_version
argument_list|(
name|rpkt
argument_list|)
operator|!=
name|KRB_PROT_VERSION
condition|)
return|return
operator|(
name|INTK_PROT
operator|)
return|;
comment|/* Check byte order */
name|msg_byte_order
operator|=
name|pkt_msg_type
argument_list|(
name|rpkt
argument_list|)
operator|&
literal|1
expr_stmt|;
name|swap_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msg_byte_order
operator|!=
name|HOST_BYTE_ORDER
condition|)
block|{
name|swap_bytes
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|pkt_msg_type
argument_list|(
name|rpkt
argument_list|)
operator|&
operator|~
literal|1
condition|)
block|{
case|case
name|AUTH_MSG_KDC_REPLY
case|:
break|break;
case|case
name|AUTH_MSG_ERR_REPLY
case|:
name|bcopy
argument_list|(
name|pkt_err_code
argument_list|(
name|rpkt
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rep_err_code
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_bytes
condition|)
name|swap_u_long
argument_list|(
name|rep_err_code
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|rep_err_code
operator|)
return|;
default|default:
return|return
operator|(
name|INTK_PROT
operator|)
return|;
block|}
comment|/* EXTRACT INFORMATION FROM RETURN PACKET */
comment|/* get the principal's expiration date */
name|bcopy
argument_list|(
name|pkt_x_date
argument_list|(
name|rpkt
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|exp_date
argument_list|,
sizeof|sizeof
argument_list|(
name|exp_date
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_bytes
condition|)
name|swap_u_long
argument_list|(
name|exp_date
argument_list|)
expr_stmt|;
comment|/* Extract the ciphertext */
name|cip
operator|->
name|length
operator|=
name|pkt_clen
argument_list|(
name|rpkt
argument_list|)
expr_stmt|;
comment|/* let clen do the swap */
if|if
condition|(
operator|(
name|cip
operator|->
name|length
operator|<
literal|0
operator|)
operator|||
operator|(
name|cip
operator|->
name|length
operator|>
sizeof|sizeof
argument_list|(
name|cip
operator|->
name|dat
argument_list|)
operator|)
condition|)
return|return
operator|(
name|INTK_ERR
operator|)
return|;
comment|/* no appropriate error code 					 currently defined for INTK_ */
comment|/* copy information from return packet into "cip" */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pkt_cipher
argument_list|(
name|rpkt
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|cip
operator|->
name|dat
operator|)
argument_list|,
name|cip
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Attempt to decrypt the reply. */
if|if
condition|(
name|decrypt_proc
operator|==
name|NULL
condition|)
name|decrypt_proc
operator|=
name|decrypt_tkt
expr_stmt|;
call|(
modifier|*
name|decrypt_proc
call|)
argument_list|(
name|user
argument_list|,
name|instance
argument_list|,
name|realm
argument_list|,
name|arg
argument_list|,
name|key_proc
argument_list|,
operator|&
name|cip
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|cip
operator|->
name|dat
expr_stmt|;
comment|/* extract session key */
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ses
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|+
operator|(
name|ptr
operator|-
operator|(
name|char
operator|*
operator|)
name|cip
operator|->
name|dat
operator|)
operator|)
operator|>
name|cip
operator|->
name|length
condition|)
return|return
operator|(
name|INTK_BADPW
operator|)
return|;
comment|/* extract server's name */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s_name
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|strlen
argument_list|(
name|s_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|+
operator|(
name|ptr
operator|-
operator|(
name|char
operator|*
operator|)
name|cip
operator|->
name|dat
operator|)
operator|)
operator|>
name|cip
operator|->
name|length
condition|)
return|return
operator|(
name|INTK_BADPW
operator|)
return|;
comment|/* extract server's instance */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s_instance
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|strlen
argument_list|(
name|s_instance
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|+
operator|(
name|ptr
operator|-
operator|(
name|char
operator|*
operator|)
name|cip
operator|->
name|dat
operator|)
operator|)
operator|>
name|cip
operator|->
name|length
condition|)
return|return
operator|(
name|INTK_BADPW
operator|)
return|;
comment|/* extract server's realm */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rlm
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|strlen
argument_list|(
name|rlm
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* extract ticket lifetime, server key version, ticket length */
comment|/* be sure to avoid sign extension on lifetime! */
name|lifetime
operator|=
operator|(
name|unsigned
name|char
operator|)
name|ptr
index|[
literal|0
index|]
expr_stmt|;
name|kvno
operator|=
operator|(
name|unsigned
name|char
operator|)
name|ptr
index|[
literal|1
index|]
expr_stmt|;
name|tkt
operator|->
name|length
operator|=
operator|(
name|unsigned
name|char
operator|)
name|ptr
index|[
literal|2
index|]
expr_stmt|;
name|ptr
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|tkt
operator|->
name|length
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|tkt
operator|->
name|length
operator|+
operator|(
name|ptr
operator|-
operator|(
name|char
operator|*
operator|)
name|cip
operator|->
name|dat
operator|)
operator|)
operator|>
name|cip
operator|->
name|length
operator|)
condition|)
return|return
operator|(
name|INTK_BADPW
operator|)
return|;
comment|/* extract ticket itself */
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tkt
operator|->
name|dat
operator|)
argument_list|,
name|tkt
operator|->
name|length
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|tkt
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s_name
argument_list|,
name|service
argument_list|)
operator|||
name|strcmp
argument_list|(
name|s_instance
argument_list|,
name|sinstance
argument_list|)
operator|||
name|strcmp
argument_list|(
name|rlm
argument_list|,
name|realm
argument_list|)
condition|)
comment|/* not what we asked for */
return|return
operator|(
name|INTK_ERR
operator|)
return|;
comment|/* we need a better code here XXX */
comment|/* check KDC time stamp */
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|kdc_time
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Time (coarse) */
if|if
condition|(
name|swap_bytes
condition|)
name|swap_u_long
argument_list|(
name|kdc_time
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t_local
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|t_local
operator|.
name|tv_sec
operator|-
name|kdc_time
argument_list|)
argument_list|)
operator|>
name|CLOCK_SKEW
condition|)
block|{
return|return
operator|(
name|RD_AP_TIME
operator|)
return|;
comment|/* XXX should probably be better 					   code */
block|}
comment|/* initialize ticket cache */
if|if
condition|(
name|in_tkt
argument_list|(
name|user
argument_list|,
name|instance
argument_list|)
operator|!=
name|KSUCCESS
condition|)
return|return
operator|(
name|INTK_ERR
operator|)
return|;
comment|/* stash ticket, session key, etc. for future use */
if|if
condition|(
operator|(
name|kerror
operator|=
name|save_credentials
argument_list|(
name|s_name
argument_list|,
name|s_instance
argument_list|,
name|rlm
argument_list|,
name|ses
argument_list|,
name|lifetime
argument_list|,
name|kvno
argument_list|,
name|tkt
argument_list|,
name|t_local
operator|.
name|tv_sec
argument_list|)
operator|)
condition|)
return|return
operator|(
name|kerror
operator|)
return|;
return|return
operator|(
name|INTK_OK
operator|)
return|;
block|}
end_block

end_unit

