begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1987, 1988 by the Massachusetts Institute of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  *	from: tf_util.c,v 4.9 90/03/10 19:19:45 jon Exp $  *	$Id: tf_util.c,v 1.3 1995/07/18 16:39:50 mark Exp $  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char rcsid[] = "$Id: tf_util.c,v 1.3 1995/07/18 16:39:50 mark Exp $";
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TKT_SHMEM
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TKT_SHMEM */
end_comment

begin_define
define|#
directive|define
name|TOO_BIG
value|-1
end_define

begin_define
define|#
directive|define
name|TF_LCK_RETRY
value|((unsigned)2)
end_define

begin_comment
comment|/* seconds to sleep before 					 * retry if ticket file is 					 * locked */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|krb_debug
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TKT_SHMEM
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|krb_shm_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tmp_shm_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|krb_dummy_skey
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TKT_SHMEM */
end_comment

begin_comment
comment|/*  * fd must be initialized to something that won't ever occur as a real  * file descriptor. Since open(2) returns only non-negative numbers as  * valid file descriptors, and tf_init always stuffs the return value  * from open in here even if it is an error flag, we must  * 	a. Initialize fd to a negative number, to indicate that it is  * 	   not initially valid.  *	b. When checking for a valid fd, assume that negative values  *	   are invalid (ie. when deciding whether tf_init has been  *	   called.)  *	c. In tf_close, be sure it gets reinitialized to a negative  *	   number.  */
end_comment

begin_expr_stmt
specifier|static
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|curpos
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Position in tfbfr */
end_comment

begin_expr_stmt
specifier|static
name|lastpos
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* End of tfbfr */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tfbfr
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer for ticket data */
end_comment

begin_function_decl
specifier|static
name|int
name|tf_read
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tf_gets
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This file contains routines for manipulating the ticket cache file.  *  * The ticket file is in the following format:  *  *      principal's name        (null-terminated string)  *      principal's instance    (null-terminated string)  *      CREDENTIAL_1  *      CREDENTIAL_2  *      ...  *      CREDENTIAL_n  *      EOF  *  *      Where "CREDENTIAL_x" consists of the following fixed-length  *      fields from the CREDENTIALS structure (see "krb.h"):  *  *              char            service[ANAME_SZ]  *              char            instance[INST_SZ]  *              char            realm[REALM_SZ]  *              C_Block         session  *              int             lifetime  *              int             kvno  *              KTEXT_ST        ticket_st  *              long            issue_date  *  * Short description of routines:  *  * tf_init() opens the ticket file and locks it.  *  * tf_get_pname() returns the principal's name.  *  * tf_get_pinst() returns the principal's instance (may be null).  *  * tf_get_cred() returns the next CREDENTIALS record.  *  * tf_save_cred() appends a new CREDENTIAL record to the ticket file.  *  * tf_close() closes the ticket file and releases the lock.  *  * tf_gets() returns the next null-terminated string.  It's an internal  * routine used by tf_get_pname(), tf_get_pinst(), and tf_get_cred().  *  * tf_read() reads a given number of bytes.  It's an internal routine  * used by tf_get_cred().  */
end_comment

begin_comment
comment|/*  * tf_init() should be called before the other ticket file routines.  * It takes the name of the ticket file to use, "tf_name", and a  * read/write flag "rw" as arguments.  *  * It tries to open the ticket file, checks the mode, and if everything  * is okay, locks the file.  If it's opened for reading, the lock is  * shared.  If it's opened for writing, the lock is exclusive.  *  * Returns KSUCCESS if all went well, otherwise one of the following:  *  * NO_TKT_FIL   - file wasn't there  * TKT_FIL_ACC  - file was in wrong mode, etc.  * TKT_FIL_LCK  - couldn't lock the file, even after a retry  */
end_comment

begin_function
name|int
name|tf_init
parameter_list|(
name|tf_name
parameter_list|,
name|rw
parameter_list|)
name|char
modifier|*
name|tf_name
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
name|int
name|wflag
decl_stmt|;
name|uid_t
name|me
decl_stmt|,
name|getuid
argument_list|()
decl_stmt|;
name|struct
name|stat
name|stat_buf
decl_stmt|;
ifdef|#
directive|ifdef
name|TKT_SHMEM
name|char
name|shmidname
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|FILE
modifier|*
name|sfp
decl_stmt|;
name|int
name|shmid
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|R_TKT_FIL
case|:
name|wflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|W_TKT_FIL
case|:
name|wflag
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tf_init: illegal parameter\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_ACC
return|;
block|}
if|if
condition|(
name|lstat
argument_list|(
name|tf_name
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
return|return
name|NO_TKT_FIL
return|;
default|default:
return|return
name|TKT_FIL_ACC
return|;
block|}
name|me
operator|=
name|getuid
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|stat_buf
operator|.
name|st_uid
operator|!=
name|me
operator|&&
name|me
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
operator|)
condition|)
return|return
name|TKT_FIL_ACC
return|;
ifdef|#
directive|ifdef
name|TKT_SHMEM
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|shmidname
argument_list|,
name|tf_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|shmidname
argument_list|,
literal|".shm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|shmidname
argument_list|,
operator|&
name|stat_buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|TKT_FIL_ACC
operator|)
return|;
if|if
condition|(
operator|(
name|stat_buf
operator|.
name|st_uid
operator|!=
name|me
operator|&&
name|me
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|stat_buf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
operator|)
condition|)
return|return
name|TKT_FIL_ACC
return|;
endif|#
directive|endif
comment|/* TKT_SHMEM */
comment|/*      * If "wflag" is set, open the ticket file in append-writeonly mode      * and lock the ticket file in exclusive mode.  If unable to lock      * the file, sleep and try again.  If we fail again, return with the      * proper error message.      */
name|curpos
operator|=
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TKT_SHMEM
name|sfp
operator|=
name|fopen
argument_list|(
name|shmidname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
comment|/* only need read/write on the 					   actual tickets */
if|if
condition|(
name|sfp
operator|==
literal|0
condition|)
return|return
name|TKT_FIL_ACC
return|;
name|shmid
operator|=
operator|-
literal|1
expr_stmt|;
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|val
decl_stmt|;
comment|/* useful for debugging fscanf */
comment|/* We provide our own buffer here since some STDIO libraries 	   barf on unbuffered input with fscanf() */
name|setbuf
argument_list|(
name|sfp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|fscanf
argument_list|(
name|sfp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|shmid
argument_list|)
operator|)
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sfp
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_ACC
return|;
block|}
if|if
condition|(
name|shmid
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sfp
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_ACC
return|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|sfp
argument_list|)
expr_stmt|;
block|}
comment|/*     * global krb_shm_addr is initialized to 0.  Ultrix bombs when you try and     * attach the same segment twice so we need this check.     */
if|if
condition|(
operator|!
name|krb_shm_addr
condition|)
block|{
if|if
condition|(
operator|(
name|krb_shm_addr
operator|=
name|shmat
argument_list|(
name|shmid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot attach shared memory for segment %d\n"
argument_list|,
name|shmid
argument_list|)
expr_stmt|;
name|krb_shm_addr
operator|=
literal|0
expr_stmt|;
comment|/* reset so we catch further errors */
return|return
name|TKT_FIL_ACC
return|;
block|}
block|}
name|tmp_shm_addr
operator|=
name|krb_shm_addr
expr_stmt|;
endif|#
directive|endif
comment|/* TKT_SHMEM */
if|if
condition|(
name|wflag
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|tf_name
argument_list|,
name|O_RDWR
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
return|return
name|TKT_FIL_ACC
return|;
block|}
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sleep
argument_list|(
name|TF_LCK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|TKT_FIL_LCK
return|;
block|}
block|}
return|return
name|KSUCCESS
return|;
block|}
comment|/*      * Otherwise "wflag" is not set and the ticket file should be opened      * for read-only operations and locked for shared access.      */
name|fd
operator|=
name|open
argument_list|(
name|tf_name
argument_list|,
name|O_RDONLY
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
return|return
name|TKT_FIL_ACC
return|;
block|}
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_SH
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sleep
argument_list|(
name|TF_LCK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_SH
operator||
name|LOCK_NB
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|TKT_FIL_LCK
return|;
block|}
block|}
return|return
name|KSUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * tf_get_pname() reads the principal's name from the ticket file. It  * should only be called after tf_init() has been called.  The  * principal's name is filled into the "p" parameter.  If all goes well,  * KSUCCESS is returned.  If tf_init() wasn't called, TKT_FIL_INI is  * returned.  If the name was null, or EOF was encountered, or the name  * was longer than ANAME_SZ, TKT_FIL_FMT is returned.  */
end_comment

begin_function
name|int
name|tf_get_pname
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tf_get_pname called before tf_init.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
if|if
condition|(
name|tf_gets
argument_list|(
name|p
argument_list|,
name|ANAME_SZ
argument_list|)
operator|<
literal|2
condition|)
comment|/* can't be just a null */
return|return
name|TKT_FIL_FMT
return|;
return|return
name|KSUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * tf_get_pinst() reads the principal's instance from a ticket file.  * It should only be called after tf_init() and tf_get_pname() have been  * called.  The instance is filled into the "inst" parameter.  If all  * goes well, KSUCCESS is returned.  If tf_init() wasn't called,  * TKT_FIL_INI is returned.  If EOF was encountered, or the instance  * was longer than ANAME_SZ, TKT_FIL_FMT is returned.  Note that the  * instance may be null.  */
end_comment

begin_function
name|int
name|tf_get_pinst
parameter_list|(
name|inst
parameter_list|)
name|char
modifier|*
name|inst
decl_stmt|;
block|{
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tf_get_pinst called before tf_init.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
if|if
condition|(
name|tf_gets
argument_list|(
name|inst
argument_list|,
name|INST_SZ
argument_list|)
operator|<
literal|1
condition|)
return|return
name|TKT_FIL_FMT
return|;
return|return
name|KSUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * tf_get_cred() reads a CREDENTIALS record from a ticket file and fills  * in the given structure "c".  It should only be called after tf_init(),  * tf_get_pname(), and tf_get_pinst() have been called. If all goes well,  * KSUCCESS is returned.  Possible error codes are:  *  * TKT_FIL_INI  - tf_init wasn't called first  * TKT_FIL_FMT  - bad format  * EOF          - end of file encountered  */
end_comment

begin_function
name|int
name|tf_get_cred
parameter_list|(
name|c
parameter_list|)
name|CREDENTIALS
modifier|*
name|c
decl_stmt|;
block|{
name|KTEXT
name|ticket
init|=
operator|&
name|c
operator|->
name|ticket_st
decl_stmt|;
comment|/* pointer to ticket */
name|int
name|k_errno
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tf_get_cred called before tf_init.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
if|if
condition|(
operator|(
name|k_errno
operator|=
name|tf_gets
argument_list|(
name|c
operator|->
name|service
argument_list|,
name|SNAME_SZ
argument_list|)
operator|)
operator|<
literal|2
condition|)
switch|switch
condition|(
name|k_errno
condition|)
block|{
case|case
name|TOO_BIG
case|:
case|case
literal|1
case|:
comment|/* can't be just a null */
name|tf_close
argument_list|()
expr_stmt|;
return|return
name|TKT_FIL_FMT
return|;
case|case
literal|0
case|:
return|return
name|EOF
return|;
block|}
if|if
condition|(
operator|(
name|k_errno
operator|=
name|tf_gets
argument_list|(
name|c
operator|->
name|instance
argument_list|,
name|INST_SZ
argument_list|)
operator|)
operator|<
literal|1
condition|)
switch|switch
condition|(
name|k_errno
condition|)
block|{
case|case
name|TOO_BIG
case|:
return|return
name|TKT_FIL_FMT
return|;
case|case
literal|0
case|:
return|return
name|EOF
return|;
block|}
if|if
condition|(
operator|(
name|k_errno
operator|=
name|tf_gets
argument_list|(
name|c
operator|->
name|realm
argument_list|,
name|REALM_SZ
argument_list|)
operator|)
operator|<
literal|2
condition|)
switch|switch
condition|(
name|k_errno
condition|)
block|{
case|case
name|TOO_BIG
case|:
case|case
literal|1
case|:
comment|/* can't be just a null */
name|tf_close
argument_list|()
expr_stmt|;
return|return
name|TKT_FIL_FMT
return|;
case|case
literal|0
case|:
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|tf_read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|c
operator|->
name|session
operator|)
argument_list|,
name|KEY_SZ
argument_list|)
operator|<
literal|1
operator|||
name|tf_read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|c
operator|->
name|lifetime
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|lifetime
argument_list|)
argument_list|)
operator|<
literal|1
operator|||
name|tf_read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|c
operator|->
name|kvno
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|kvno
argument_list|)
argument_list|)
operator|<
literal|1
operator|||
name|tf_read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|ticket
operator|->
name|length
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ticket
operator|->
name|length
argument_list|)
argument_list|)
operator|<
literal|1
operator|||
comment|/* don't try to read a silly amount into ticket->dat */
name|ticket
operator|->
name|length
operator|>
name|MAX_KTXT_LEN
operator|||
name|tf_read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ticket
operator|->
name|dat
operator|)
argument_list|,
name|ticket
operator|->
name|length
argument_list|)
operator|<
literal|1
operator|||
name|tf_read
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|c
operator|->
name|issue_date
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|c
operator|->
name|issue_date
argument_list|)
argument_list|)
operator|<
literal|1
condition|)
block|{
name|tf_close
argument_list|()
expr_stmt|;
return|return
name|TKT_FIL_FMT
return|;
block|}
ifdef|#
directive|ifdef
name|TKT_SHMEM
name|bcopy
argument_list|(
name|tmp_shm_addr
argument_list|,
name|c
operator|->
name|session
argument_list|,
name|KEY_SZ
argument_list|)
expr_stmt|;
name|tmp_shm_addr
operator|+=
name|KEY_SZ
expr_stmt|;
endif|#
directive|endif
comment|/* TKT_SHMEM */
return|return
name|KSUCCESS
return|;
block|}
end_function

begin_comment
comment|/*  * tf_close() closes the ticket file and sets "fd" to -1. If "fd" is  * not a valid file descriptor, it just returns.  It also clears the  * buffer used to read tickets.  *  * The return value is not defined.  */
end_comment

begin_function
name|void
name|tf_close
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|(
name|fd
operator|<
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TKT_SHMEM
if|if
condition|(
name|shmdt
argument_list|(
name|krb_shm_addr
argument_list|)
condition|)
block|{
comment|/* what kind of error? */
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"shmdt 0x%x: errno %d"
argument_list|,
name|krb_shm_addr
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|krb_shm_addr
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
endif|TKT_SHMEM
operator|(
name|void
operator|)
name|flock
argument_list|(
name|fd
argument_list|,
name|LOCK_UN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* see declaration of fd above */
block|}
name|bzero
argument_list|(
name|tfbfr
argument_list|,
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * tf_gets() is an internal routine.  It takes a string "s" and a count  * "n", and reads from the file until either it has read "n" characters,  * or until it reads a null byte. When finished, what has been read exists  * in "s". If it encounters EOF or an error, it closes the ticket file.  *  * Possible return values are:  *  * n            the number of bytes read (including null terminator)  *              when all goes well  *  * 0            end of file or read error  *  * TOO_BIG      if "count" characters are read and no null is  *		encountered. This is an indication that the ticket  *		file is seriously ill.  */
end_comment

begin_function
specifier|static
name|int
name|tf_gets
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|count
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tf_gets called before tf_init.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
for|for
control|(
name|count
operator|=
name|n
operator|-
literal|1
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
control|)
block|{
if|if
condition|(
name|curpos
operator|>=
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
condition|)
block|{
name|lastpos
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tfbfr
argument_list|,
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
argument_list|)
expr_stmt|;
name|curpos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|curpos
operator|==
name|lastpos
condition|)
block|{
name|tf_close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|s
operator|=
name|tfbfr
index|[
name|curpos
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|++
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|n
operator|-
name|count
operator|)
return|;
block|}
name|tf_close
argument_list|()
expr_stmt|;
return|return
name|TOO_BIG
return|;
block|}
end_function

begin_comment
comment|/*  * tf_read() is an internal routine.  It takes a string "s" and a count  * "n", and reads from the file until "n" bytes have been read.  When  * finished, what has been read exists in "s".  If it encounters EOF or  * an error, it closes the ticket file.  *  * Possible return values are:  *  * n		the number of bytes read when all goes well  *  * 0		on end of file or read error  */
end_comment

begin_function
specifier|static
name|int
name|tf_read
parameter_list|(
name|s
parameter_list|,
name|n
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
block|{
specifier|register
name|count
expr_stmt|;
for|for
control|(
name|count
operator|=
name|n
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
control|)
block|{
if|if
condition|(
name|curpos
operator|>=
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
condition|)
block|{
name|lastpos
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|tfbfr
argument_list|,
sizeof|sizeof
argument_list|(
name|tfbfr
argument_list|)
argument_list|)
expr_stmt|;
name|curpos
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|curpos
operator|==
name|lastpos
condition|)
block|{
name|tf_close
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|s
operator|++
operator|=
name|tfbfr
index|[
name|curpos
operator|++
index|]
expr_stmt|;
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * tf_save_cred() appends an incoming ticket to the end of the ticket  * file.  You must call tf_init() before calling tf_save_cred().  *  * The "service", "instance", and "realm" arguments specify the  * server's name; "session" contains the session key to be used with  * the ticket; "kvno" is the server key version number in which the  * ticket is encrypted, "ticket" contains the actual ticket, and  * "issue_date" is the time the ticket was requested (local host's time).  *  * Returns KSUCCESS if all goes well, TKT_FIL_INI if tf_init() wasn't  * called previously, and KFAILURE for anything else that went wrong.  */
end_comment

begin_function
name|int
name|tf_save_cred
parameter_list|(
name|service
parameter_list|,
name|instance
parameter_list|,
name|realm
parameter_list|,
name|session
parameter_list|,
name|lifetime
parameter_list|,
name|kvno
parameter_list|,
name|ticket
parameter_list|,
name|issue_date
parameter_list|)
name|char
modifier|*
name|service
decl_stmt|;
comment|/* Service name */
name|char
modifier|*
name|instance
decl_stmt|;
comment|/* Instance */
name|char
modifier|*
name|realm
decl_stmt|;
comment|/* Auth domain */
name|C_Block
name|session
decl_stmt|;
comment|/* Session key */
name|int
name|lifetime
decl_stmt|;
comment|/* Lifetime */
name|int
name|kvno
decl_stmt|;
comment|/* Key version number */
name|KTEXT
name|ticket
decl_stmt|;
comment|/* The ticket itself */
name|long
name|issue_date
decl_stmt|;
comment|/* The issue time */
block|{
name|off_t
name|lseek
parameter_list|()
function_decl|;
name|int
name|count
decl_stmt|;
comment|/* count for write */
ifdef|#
directive|ifdef
name|TKT_SHMEM
name|int
modifier|*
name|skey_check
decl_stmt|;
endif|#
directive|endif
comment|/* TKT_SHMEM */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
comment|/* fd is ticket file as set by tf_init */
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"tf_save_cred called before tf_init.\n"
argument_list|)
expr_stmt|;
return|return
name|TKT_FIL_INI
return|;
block|}
comment|/* Find the end of the ticket file */
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|fd
argument_list|,
literal|0L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TKT_SHMEM
comment|/* scan to end of existing keys: pick first 'empty' slot.        we assume that no real keys will be completely zero (it's a weak        key under DES) */
name|skey_check
operator|=
operator|(
name|int
operator|*
operator|)
name|krb_shm_addr
expr_stmt|;
while|while
condition|(
operator|*
name|skey_check
operator|&&
operator|*
operator|(
name|skey_check
operator|+
literal|1
operator|)
condition|)
name|skey_check
operator|+=
literal|2
expr_stmt|;
name|tmp_shm_addr
operator|=
operator|(
name|char
operator|*
operator|)
name|skey_check
expr_stmt|;
endif|#
directive|endif
comment|/* TKT_SHMEM */
comment|/* Write the ticket and associated data */
comment|/* Service */
name|count
operator|=
name|strlen
argument_list|(
name|service
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|service
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
goto|goto
name|bad
goto|;
comment|/* Instance */
name|count
operator|=
name|strlen
argument_list|(
name|instance
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|instance
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
goto|goto
name|bad
goto|;
comment|/* Realm */
name|count
operator|=
name|strlen
argument_list|(
name|realm
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|realm
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
goto|goto
name|bad
goto|;
comment|/* Session key */
ifdef|#
directive|ifdef
name|TKT_SHMEM
name|bcopy
argument_list|(
name|session
argument_list|,
name|tmp_shm_addr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tmp_shm_addr
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|krb_dummy_skey
argument_list|,
literal|8
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|bad
goto|;
else|#
directive|else
comment|/* ! TKT_SHMEM */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|session
argument_list|,
literal|8
argument_list|)
operator|!=
literal|8
condition|)
goto|goto
name|bad
goto|;
endif|#
directive|endif
comment|/* TKT_SHMEM */
comment|/* Lifetime */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lifetime
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* Key vno */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|kvno
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* Tkt length */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|ticket
operator|->
name|length
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* Ticket */
name|count
operator|=
name|ticket
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|ticket
operator|->
name|dat
operator|)
argument_list|,
name|count
argument_list|)
operator|!=
name|count
condition|)
goto|goto
name|bad
goto|;
comment|/* Issue date */
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|issue_date
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
condition|)
goto|goto
name|bad
goto|;
comment|/* Actually, we should check each write for success */
return|return
operator|(
name|KSUCCESS
operator|)
return|;
name|bad
label|:
return|return
operator|(
name|KFAILURE
operator|)
return|;
block|}
end_function

end_unit

