begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1986, 1987, 1988 by the Massachusetts Institute  * of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  *	from: get_ad_tkt.c,v 4.15 89/07/07 15:18:51 jtkohl Exp $  * $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char rcsid[] = "$FreeBSD$";
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<des.h>
end_include

begin_include
include|#
directive|include
file|<prot.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* use the bsd time.h struct defs for PC too! */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|krb_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|tt_local
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swap_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|rep_err_code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * get_ad_tkt obtains a new service ticket from Kerberos, using  * the ticket-granting ticket which must be in the ticket file.  * It is typically called by krb_mk_req() when the client side  * of an application is creating authentication information to be  * sent to the server side.  *  * get_ad_tkt takes four arguments: three pointers to strings which  * contain the name, instance, and realm of the service for which the  * ticket is to be obtained; and an integer indicating the desired  * lifetime of the ticket.  *  * It returns an error status if the ticket couldn't be obtained,  * or AD_OK if all went well.  The ticket is stored in the ticket  * cache.  *  * The request sent to the Kerberos ticket-granting service looks  * like this:  *  * pkt->dat  *  * TEXT			original contents of	authenticator+ticket  *			pkt->dat		built in krb_mk_req call  *  * 4 bytes		time_ws			always 0 (?)  * char			lifetime		lifetime argument passed  * string		service			service name argument  * string		sinstance		service instance arg.  *  * See "prot.h" for the reply packet layout and definitions of the  * extraction macros like pkt_version(), pkt_msg_type(), etc.  */
end_comment

begin_function
name|int
name|get_ad_tkt
parameter_list|(
name|service
parameter_list|,
name|sinstance
parameter_list|,
name|realm
parameter_list|,
name|lifetime
parameter_list|)
name|char
modifier|*
name|service
decl_stmt|;
name|char
modifier|*
name|sinstance
decl_stmt|;
name|char
modifier|*
name|realm
decl_stmt|;
name|int
name|lifetime
decl_stmt|;
block|{
specifier|static
name|KTEXT_ST
name|pkt_st
decl_stmt|;
name|KTEXT
name|pkt
init|=
operator|&
name|pkt_st
decl_stmt|;
comment|/* Packet to KDC */
specifier|static
name|KTEXT_ST
name|rpkt_st
decl_stmt|;
name|KTEXT
name|rpkt
init|=
operator|&
name|rpkt_st
decl_stmt|;
comment|/* Returned packet */
specifier|static
name|KTEXT_ST
name|cip_st
decl_stmt|;
name|KTEXT
name|cip
init|=
operator|&
name|cip_st
decl_stmt|;
comment|/* Returned Ciphertext */
specifier|static
name|KTEXT_ST
name|tkt_st
decl_stmt|;
name|KTEXT
name|tkt
init|=
operator|&
name|tkt_st
decl_stmt|;
comment|/* Current ticket */
name|C_Block
name|ses
decl_stmt|;
comment|/* Session key for tkt */
name|CREDENTIALS
name|cr
decl_stmt|;
name|int
name|kvno
decl_stmt|;
comment|/* Kvno for session key */
name|char
name|lrealm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|C_Block
name|key
decl_stmt|;
comment|/* Key for decrypting cipher */
name|Key_schedule
name|key_s
decl_stmt|;
name|long
name|time_ws
init|=
literal|0
decl_stmt|;
name|char
name|s_name
index|[
name|SNAME_SZ
index|]
decl_stmt|;
name|char
name|s_instance
index|[
name|INST_SZ
index|]
decl_stmt|;
name|int
name|msg_byte_order
decl_stmt|;
name|int
name|kerror
decl_stmt|;
name|char
name|rlm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|long
name|kdc_time
decl_stmt|;
comment|/* KDC time */
if|if
condition|(
operator|(
name|kerror
operator|=
name|krb_get_tf_realm
argument_list|(
name|TKT_FILE
argument_list|,
name|lrealm
argument_list|)
operator|)
operator|!=
name|KSUCCESS
condition|)
return|return
operator|(
name|kerror
operator|)
return|;
comment|/* Create skeleton of packet to be sent */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tt_local
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|length
operator|=
literal|0
expr_stmt|;
comment|/*      * Look for the session key (and other stuff we don't need)      * in the ticket file for krbtgt.realm@lrealm where "realm"      * is the service's realm (passed in "realm" argument) and      * lrealm is the realm of our initial ticket.  If we don't      * have this, we will try to get it.      */
if|if
condition|(
operator|(
name|kerror
operator|=
name|krb_get_cred
argument_list|(
literal|"krbtgt"
argument_list|,
name|realm
argument_list|,
name|lrealm
argument_list|,
operator|&
name|cr
argument_list|)
operator|)
operator|!=
name|KSUCCESS
condition|)
block|{
comment|/* 	 * If realm == lrealm, we have no hope, so let's not even try. 	 */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|realm
argument_list|,
name|lrealm
argument_list|,
name|REALM_SZ
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|AD_NOTGT
operator|)
return|;
else|else
block|{
if|if
condition|(
operator|(
name|kerror
operator|=
name|get_ad_tkt
argument_list|(
literal|"krbtgt"
argument_list|,
name|realm
argument_list|,
name|lrealm
argument_list|,
name|lifetime
argument_list|)
operator|)
operator|!=
name|KSUCCESS
condition|)
return|return
operator|(
name|kerror
operator|)
return|;
if|if
condition|(
operator|(
name|kerror
operator|=
name|krb_get_cred
argument_list|(
literal|"krbtgt"
argument_list|,
name|realm
argument_list|,
name|lrealm
argument_list|,
operator|&
name|cr
argument_list|)
operator|)
operator|!=
name|KSUCCESS
condition|)
return|return
operator|(
name|kerror
operator|)
return|;
block|}
block|}
comment|/*      * Make up a request packet to the "krbtgt.realm@lrealm".      * Start by calling krb_mk_req() which puts ticket+authenticator      * into "pkt".  Then tack other stuff on the end.      */
name|kerror
operator|=
name|krb_mk_req
argument_list|(
name|pkt
argument_list|,
literal|"krbtgt"
argument_list|,
name|realm
argument_list|,
name|lrealm
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
condition|)
return|return
operator|(
name|AD_NOTGT
operator|)
return|;
comment|/* timestamp */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|time_ws
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|->
name|dat
operator|+
name|pkt
operator|->
name|length
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|length
operator|+=
literal|4
expr_stmt|;
operator|*
operator|(
name|pkt
operator|->
name|dat
operator|+
operator|(
name|pkt
operator|->
name|length
operator|)
operator|++
operator|)
operator|=
operator|(
name|char
operator|)
name|lifetime
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|->
name|dat
operator|+
name|pkt
operator|->
name|length
operator|)
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|length
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|service
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|->
name|dat
operator|+
name|pkt
operator|->
name|length
operator|)
argument_list|,
name|sinstance
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|length
operator|+=
literal|1
operator|+
name|strlen
argument_list|(
name|sinstance
argument_list|)
expr_stmt|;
name|rpkt
operator|->
name|length
operator|=
literal|0
expr_stmt|;
comment|/* Send the request to the local ticket-granting server */
if|if
condition|(
operator|(
name|kerror
operator|=
name|send_to_kdc
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
name|realm
argument_list|)
operator|)
condition|)
return|return
operator|(
name|kerror
operator|)
return|;
comment|/* check packet version of the returned packet */
if|if
condition|(
name|pkt_version
argument_list|(
name|rpkt
argument_list|)
operator|!=
name|KRB_PROT_VERSION
condition|)
return|return
operator|(
name|INTK_PROT
operator|)
return|;
comment|/* Check byte order */
name|msg_byte_order
operator|=
name|pkt_msg_type
argument_list|(
name|rpkt
argument_list|)
operator|&
literal|1
expr_stmt|;
name|swap_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msg_byte_order
operator|!=
name|HOST_BYTE_ORDER
condition|)
name|swap_bytes
operator|++
expr_stmt|;
switch|switch
condition|(
name|pkt_msg_type
argument_list|(
name|rpkt
argument_list|)
operator|&
operator|~
literal|1
condition|)
block|{
case|case
name|AUTH_MSG_KDC_REPLY
case|:
break|break;
case|case
name|AUTH_MSG_ERR_REPLY
case|:
name|bcopy
argument_list|(
name|pkt_err_code
argument_list|(
name|rpkt
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rep_err_code
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|swap_bytes
condition|)
name|swap_u_long
argument_list|(
name|rep_err_code
argument_list|)
expr_stmt|;
return|return
operator|(
name|rep_err_code
operator|)
return|;
default|default:
return|return
operator|(
name|INTK_PROT
operator|)
return|;
block|}
comment|/* Extract the ciphertext */
name|cip
operator|->
name|length
operator|=
name|pkt_clen
argument_list|(
name|rpkt
argument_list|)
expr_stmt|;
comment|/* let clen do the swap */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pkt_cipher
argument_list|(
name|rpkt
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|cip
operator|->
name|dat
operator|)
argument_list|,
name|cip
operator|->
name|length
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
name|key_sched
argument_list|(
operator|(
name|C_Block
operator|*
operator|)
name|cr
operator|.
name|session
argument_list|,
name|key_s
argument_list|)
expr_stmt|;
name|pcbc_encrypt
argument_list|(
operator|(
name|C_Block
operator|*
operator|)
name|cip
operator|->
name|dat
argument_list|,
operator|(
name|C_Block
operator|*
operator|)
name|cip
operator|->
name|dat
argument_list|,
operator|(
name|long
operator|)
name|cip
operator|->
name|length
argument_list|,
name|key_s
argument_list|,
operator|(
name|C_Block
operator|*
operator|)
name|cr
operator|.
name|session
argument_list|,
name|DECRYPT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Get rid of all traces of key */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cr
operator|.
name|session
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key_s
argument_list|,
sizeof|sizeof
argument_list|(
name|key_s
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|cip
operator|->
name|dat
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ses
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|8
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s_name
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|strlen
argument_list|(
name|s_name
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|s_instance
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|strlen
argument_list|(
name|s_instance
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|rlm
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|strlen
argument_list|(
name|rlm
argument_list|)
operator|+
literal|1
expr_stmt|;
name|lifetime
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ptr
index|[
literal|0
index|]
expr_stmt|;
name|kvno
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ptr
index|[
literal|1
index|]
expr_stmt|;
name|tkt
operator|->
name|length
operator|=
operator|(
name|int
operator|)
name|ptr
index|[
literal|2
index|]
expr_stmt|;
name|ptr
operator|+=
literal|3
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|tkt
operator|->
name|dat
operator|)
argument_list|,
name|tkt
operator|->
name|length
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|tkt
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|s_name
argument_list|,
name|service
argument_list|)
operator|||
name|strcmp
argument_list|(
name|s_instance
argument_list|,
name|sinstance
argument_list|)
operator|||
name|strcmp
argument_list|(
name|rlm
argument_list|,
name|realm
argument_list|)
condition|)
comment|/* not what we asked for */
return|return
operator|(
name|INTK_ERR
operator|)
return|;
comment|/* we need a better code here XXX */
comment|/* check KDC time stamp */
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|kdc_time
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Time (coarse) */
if|if
condition|(
name|swap_bytes
condition|)
name|swap_u_long
argument_list|(
name|kdc_time
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|tt_local
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|tt_local
operator|.
name|tv_sec
operator|-
name|kdc_time
argument_list|)
argument_list|)
operator|>
name|CLOCK_SKEW
condition|)
block|{
return|return
operator|(
name|RD_AP_TIME
operator|)
return|;
comment|/* XXX should probably be better 					   code */
block|}
if|if
condition|(
operator|(
name|kerror
operator|=
name|save_credentials
argument_list|(
name|s_name
argument_list|,
name|s_instance
argument_list|,
name|rlm
argument_list|,
name|ses
argument_list|,
name|lifetime
argument_list|,
name|kvno
argument_list|,
name|tkt
argument_list|,
name|tt_local
operator|.
name|tv_sec
argument_list|)
operator|)
condition|)
return|return
operator|(
name|kerror
operator|)
return|;
return|return
operator|(
name|AD_OK
operator|)
return|;
block|}
end_function

end_unit

