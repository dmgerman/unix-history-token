begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1987, 1988 by the Massachusetts Institute of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  *	from: send_to_kdc.c,v 4.20 90/01/02 13:40:37 jtkohl Exp $  * $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char rcsid_send_to_kdc_c[] = "$Id: send_to_kdc.c,v 1.1 1994/03/21 17:35:39 piero Exp ";
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<prot.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_comment
comment|/* struct iovec to make lint happy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_define
define|#
directive|define
name|S_AD_SZ
value|sizeof(struct sockaddr_in)
end_define

begin_comment
comment|/* Used for extracting addresses from routing messages */
end_comment

begin_define
define|#
directive|define
name|ROUNDUP
parameter_list|(
name|a
parameter_list|)
define|\
value|((a)> 0 ? (1 + (((a) - 1) | (sizeof(long) - 1))) : sizeof(long))
end_define

begin_define
define|#
directive|define
name|ADVANCE
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
value|(x += ROUNDUP((n)->sin_len))
end_define

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|krb_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|calloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|krb_udp_port
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|local_addr
init|=
block|{
name|S_AD_SZ
block|,
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CLIENT_KRB_TIMEOUT indicates the time to wait before  * retrying a server.  It's defined in "krb.h".  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|timeout
init|=
block|{
name|CLIENT_KRB_TIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prog
init|=
literal|"send_to_kdc"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|send_recv
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This file contains two routines, send_to_kdc() and send_recv().  * send_recv() is a static routine used by send_to_kdc().  */
end_comment

begin_comment
comment|/*  * send_to_kdc() sends a message to the Kerberos authentication  * server(s) in the given realm and returns the reply message.  * The "pkt" argument points to the message to be sent to Kerberos;  * the "rpkt" argument will be filled in with Kerberos' reply.  * The "realm" argument indicates the realm of the Kerberos server(s)  * to transact with.  If the realm is null, the local realm is used.  *  * If more than one Kerberos server is known for a given realm,  * different servers will be queried until one of them replies.  * Several attempts (retries) are made for each server before  * giving up entirely.  *  * If an answer was received from a Kerberos host, KSUCCESS is  * returned.  The following errors can be returned:  *  * SKDC_CANT    - can't get local realm  *              - can't find "kerberos" in /etc/services database  *              - can't open socket  *              - can't bind socket  *              - all ports in use  *              - couldn't find any Kerberos host  *  * SKDC_RETRY   - couldn't get an answer from any Kerberos server,  *		  after several retries  */
end_comment

begin_function
name|int
name|send_to_kdc
parameter_list|(
name|pkt
parameter_list|,
name|rpkt
parameter_list|,
name|realm
parameter_list|)
name|KTEXT
name|pkt
decl_stmt|;
name|KTEXT
name|rpkt
decl_stmt|;
name|char
modifier|*
name|realm
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|f
decl_stmt|;
name|int
name|no_host
decl_stmt|;
comment|/* was a kerberos host found? */
name|int
name|retry
decl_stmt|;
name|int
name|n_hosts
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|addr_count
decl_stmt|;
name|struct
name|sockaddr_in
name|to
decl_stmt|;
name|struct
name|hostent
modifier|*
name|host
decl_stmt|,
modifier|*
name|hostlist
decl_stmt|;
name|char
name|krbhst
index|[
name|MAX_HSTNM
index|]
decl_stmt|;
name|char
name|lrealm
index|[
name|REALM_SZ
index|]
decl_stmt|;
comment|/*      * If "realm" is non-null, use that, otherwise get the      * local realm.      */
if|if
condition|(
name|realm
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|lrealm
argument_list|,
name|realm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|krb_get_lrealm
argument_list|(
name|lrealm
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't get local realm\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
return|return
operator|(
name|SKDC_CANT
operator|)
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
name|printf
argument_list|(
literal|"lrealm is %s\n"
argument_list|,
name|lrealm
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_udp_port
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"kerberos"
argument_list|,
literal|"udp"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't get kerberos/udp service\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
return|return
operator|(
name|SKDC_CANT
operator|)
return|;
block|}
name|krb_udp_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
name|printf
argument_list|(
literal|"krb_udp_port is %d\n"
argument_list|,
name|krb_udp_port
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|to
argument_list|,
name|S_AD_SZ
argument_list|)
expr_stmt|;
name|hostlist
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hostlist
condition|)
return|return
operator|(
comment|/*errno */
name|SKDC_CANT
operator|)
return|;
if|if
condition|(
operator|(
name|f
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open socket\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
return|return
operator|(
name|SKDC_CANT
operator|)
return|;
block|}
comment|/* from now on, exit through rtn label for cleanup */
name|no_host
operator|=
literal|1
expr_stmt|;
comment|/* get an initial allocation */
name|n_hosts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|krb_get_krbhst
argument_list|(
name|krbhst
argument_list|,
name|lrealm
argument_list|,
name|i
argument_list|)
operator|==
name|KSUCCESS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"Getting host entry for %s..."
argument_list|,
name|krbhst
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|host
operator|=
name|gethostbyname
argument_list|(
name|krbhst
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"%s.\n"
argument_list|,
name|host
condition|?
literal|"Got it"
else|:
literal|"Didn't get it"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|host
condition|)
continue|continue;
name|no_host
operator|=
literal|0
expr_stmt|;
comment|/* found at least one */
name|n_hosts
operator|++
expr_stmt|;
comment|/* 	 * Preserve host network addresses to check against later 	 */
name|hostlist
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hostlist
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
operator|*
operator|(
name|n_hosts
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hostlist
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not grow hostlist\n"
argument_list|)
expr_stmt|;
return|return
comment|/*errno */
name|SKDC_CANT
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|host
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hostlist
index|[
name|n_hosts
operator|-
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|=
operator|&
name|hostlist
index|[
name|n_hosts
operator|-
literal|1
index|]
expr_stmt|;
comment|/* At least Sun OS version 3.2 (or worse) and Ultrix version 2.2    (or worse) only return one address ... */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|ULTRIX022
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SunOS
argument_list|)
operator|&&
name|SunOS
operator|<
literal|40
operator|)
operator|)
block|{
name|char
modifier|*
name|cp
init|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|host
operator|->
name|h_length
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|retval
operator|=
comment|/*errno */
name|SKDC_CANT
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|host
operator|->
name|h_addr
argument_list|,
name|cp
argument_list|,
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|host
operator|->
name|h_addr
operator|=
name|cp
expr_stmt|;
block|}
else|#
directive|else
comment|/* !(ULTRIX022 || (SunOS< 40)) */
comment|/* 	 * Make a copy of the entire h_addr_list. 	 */
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
modifier|*
name|old_addr_list
decl_stmt|;
name|addr_count
operator|=
literal|0
expr_stmt|;
name|old_addr_list
operator|=
name|host
operator|->
name|h_addr_list
expr_stmt|;
while|while
condition|(
name|old_addr_list
index|[
name|addr_count
operator|++
index|]
condition|)
empty_stmt|;
name|host
operator|->
name|h_addr_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|addr_count
operator|+
literal|1
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|->
name|h_addr_list
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not allocate host->h_addr_list\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|SKDC_CANT
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"h_length = %d\n"
argument_list|,
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Number of addresses = %d\n"
argument_list|,
name|addr_count
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|addr_count
operator|=
literal|0
init|;
name|old_addr_list
index|[
name|addr_count
index|]
condition|;
name|addr_count
operator|++
control|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|printf
argument_list|(
literal|"addr[%d] = %s\n"
argument_list|,
name|addr_count
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|old_addr_list
index|[
name|addr_count
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not allocate address\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
name|SKDC_CANT
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
name|bcopy
argument_list|(
name|old_addr_list
index|[
name|addr_count
index|]
argument_list|,
name|addr
argument_list|,
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|host
operator|->
name|h_addr_list
index|[
name|addr_count
index|]
operator|=
name|addr
expr_stmt|;
block|}
name|host
operator|->
name|h_addr_list
index|[
name|addr_count
index|]
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !(ULTRIX022 || (SunOS< 40)) */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hostlist
index|[
name|n_hosts
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|.
name|sin_family
operator|=
name|host
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|host
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|.
name|sin_addr
argument_list|,
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|to
operator|.
name|sin_port
operator|=
name|krb_udp_port
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|krb_bind_local_addr
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|KSUCCESS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"krb_bind_local_addr: %s"
argument_list|,
name|krb_err_txt
index|[
name|retval
index|]
argument_list|)
expr_stmt|;
name|retval
operator|=
name|SKDC_CANT
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
if|if
condition|(
name|send_recv
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
name|f
argument_list|,
operator|&
name|to
argument_list|,
name|hostlist
argument_list|)
condition|)
block|{
name|retval
operator|=
name|KSUCCESS
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"Timeout, error, or wrong descriptor\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|no_host
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't find any Kerberos host.\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|retval
operator|=
name|SKDC_CANT
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
comment|/*      * retry each host in sequence.  Some addresses may be unreachable      * from where we are, so loop through them as well.      */
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|CLIENT_KRB_RETRY
condition|;
operator|++
name|retry
control|)
block|{
for|for
control|(
name|host
operator|=
name|hostlist
init|;
name|host
operator|->
name|h_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|;
name|host
operator|++
control|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|ULTRIX022
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SunOS
argument_list|)
operator|&&
name|SunOS
operator|<
literal|40
operator|)
operator|)
name|to
operator|.
name|sin_family
operator|=
name|host
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|host
operator|->
name|h_addr_list
index|[
name|addr_count
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|.
name|sin_addr
argument_list|,
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_recv
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
name|f
argument_list|,
operator|&
name|to
argument_list|,
name|hostlist
argument_list|)
condition|)
block|{
name|retval
operator|=
name|KSUCCESS
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
else|#
directive|else
comment|/* !(ULTRIX022 || (SunOS< 40)) */
for|for
control|(
name|addr_count
operator|=
literal|0
init|;
name|host
operator|->
name|h_addr_list
index|[
name|addr_count
index|]
condition|;
name|addr_count
operator|++
control|)
block|{
name|to
operator|.
name|sin_family
operator|=
name|host
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|host
operator|->
name|h_addr_list
index|[
name|addr_count
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|.
name|sin_addr
argument_list|,
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_recv
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
name|f
argument_list|,
operator|&
name|to
argument_list|,
name|hostlist
argument_list|)
condition|)
block|{
name|retval
operator|=
name|KSUCCESS
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* !(ULTRIX022 || (SunOS< 40)) */
block|}
block|}
name|retval
operator|=
name|SKDC_RETRY
expr_stmt|;
name|rtn
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostlist
condition|)
block|{
if|if
condition|(
operator|!
name|no_host
condition|)
block|{
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|hostlist
init|;
name|hp
operator|->
name|h_name
condition|;
name|hp
operator|++
control|)
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|ULTRIX022
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SunOS
argument_list|)
operator|&&
name|SunOS
operator|<
literal|40
operator|)
operator|)
if|if
condition|(
name|hp
operator|->
name|h_addr_list
condition|)
block|{
endif|#
directive|endif
comment|/* ULTRIX022 || SunOS */
if|if
condition|(
name|hp
operator|->
name|h_addr
condition|)
name|free
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|ULTRIX022
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SunOS
argument_list|)
operator|&&
name|SunOS
operator|<
literal|40
operator|)
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ULTRIX022 || SunOS */
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hostlist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * try to send out and receive message.  * return 1 on success, 0 on failure  */
end_comment

begin_function
specifier|static
name|int
name|send_recv
parameter_list|(
name|pkt
parameter_list|,
name|rpkt
parameter_list|,
name|f
parameter_list|,
name|_to
parameter_list|,
name|addrs
parameter_list|)
name|KTEXT
name|pkt
decl_stmt|;
name|KTEXT
name|rpkt
decl_stmt|;
name|int
name|f
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|_to
decl_stmt|;
name|struct
name|hostent
modifier|*
name|addrs
decl_stmt|;
block|{
name|fd_set
name|readfds
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|int
name|sin_size
decl_stmt|;
name|int
name|numsent
decl_stmt|;
name|int
name|addr_count
decl_stmt|;
if|if
condition|(
name|krb_debug
condition|)
block|{
if|if
condition|(
name|_to
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
name|printf
argument_list|(
literal|"Sending message to %s..."
argument_list|,
name|inet_ntoa
argument_list|(
name|_to
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Sending message..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|numsent
operator|=
name|sendto
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|->
name|dat
operator|)
argument_list|,
name|pkt
operator|->
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|_to
argument_list|,
name|S_AD_SZ
argument_list|)
operator|)
operator|!=
name|pkt
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|printf
argument_list|(
literal|"sent only %d/%d\n"
argument_list|,
name|numsent
argument_list|,
name|pkt
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"Sent\nWaiting for reply..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|f
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* select - either recv is ready, or timeout */
comment|/* see if timeout or error or wrong descriptor */
if|if
condition|(
name|select
argument_list|(
name|f
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|1
operator|||
operator|!
name|FD_ISSET
argument_list|(
name|f
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"select failed: readfds=%x"
argument_list|,
name|readfds
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|sin_size
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvfrom
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|rpkt
operator|->
name|dat
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|sin_size
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|perror
argument_list|(
literal|"recvfrom"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"received packet from %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* At least Sun OS version 3.2 (or worse) and Ultrix version 2.2    (or worse) only return one address ... */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|ULTRIX022
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SunOS
argument_list|)
operator|&&
name|SunOS
operator|<
literal|40
operator|)
operator|)
for|for
control|(
name|hp
operator|=
name|addrs
init|;
name|hp
operator|->
name|h_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|;
name|hp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"Received it\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"packet not from %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !(ULTRIX022 || (SunOS< 40)) */
for|for
control|(
name|hp
operator|=
name|addrs
init|;
name|hp
operator|->
name|h_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|;
name|hp
operator|++
control|)
block|{
for|for
control|(
name|addr_count
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|addr_count
index|]
condition|;
name|addr_count
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|hp
operator|->
name|h_addr_list
index|[
name|addr_count
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"Received it\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"packet not from %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
index|[
name|addr_count
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !(ULTRIX022 || (SunOS< 40)) */
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: received packet from wrong host! (%s)\n"
argument_list|,
literal|"send_to_kdc(send_rcv)"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|setfixedaddr
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|struct
name|ifa_msghdr
modifier|*
name|ifa
decl_stmt|,
modifier|*
name|ifa0
decl_stmt|,
modifier|*
name|ifa_end
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|cur_addr
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_long
name|loopback
decl_stmt|;
name|int
name|mib
index|[
literal|6
index|]
init|=
block|{
name|CTL_NET
block|,
name|PF_ROUTE
block|,
literal|0
block|,
name|AF_INET
block|,
name|NET_RT_IFLIST
block|,
literal|0
block|}
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Get information about our interfaces */
define|#
directive|define
name|NUMTRIES
value|10
name|tries
operator|=
literal|0
expr_stmt|;
name|retry
label|:
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"setfixedaddr: Can't get size of interface table: sysctl"
argument_list|)
expr_stmt|;
return|return
name|GT_LADDR_IFLIST
return|;
block|}
name|ifa
operator|=
operator|(
expr|struct
name|ifa_msghdr
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifa
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setfixedaddr: Cannot malloc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|KFAILURE
operator|)
return|;
block|}
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|6
argument_list|,
name|ifa
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ENOMEM
operator|&&
name|tries
operator|<
name|NUMTRIES
condition|)
block|{
comment|/* Table grew between calls */
name|tries
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
else|else
block|{
name|perror
argument_list|(
literal|"setfixedaddr: Can't get interface table: sysctl"
argument_list|)
expr_stmt|;
return|return
name|GT_LADDR_IFLIST
return|;
block|}
block|}
name|loopback
operator|=
name|inet_addr
argument_list|(
literal|"127.0.0.1"
argument_list|)
expr_stmt|;
name|ifa0
operator|=
name|ifa
expr_stmt|;
for|for
control|(
name|ifa_end
operator|=
operator|(
expr|struct
name|ifa_msghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ifa
operator|+
name|len
operator|)
init|;
name|ifa
operator|<
name|ifa_end
condition|;
operator|(
name|caddr_t
operator|)
name|ifa
operator|+=
name|ifa
operator|->
name|ifam_msglen
control|)
block|{
comment|/* Ignore interface name messages and ensure we have an address */
if|if
condition|(
name|ifa
operator|->
name|ifam_type
operator|==
name|RTM_IFINFO
operator|||
operator|!
operator|(
name|ifa
operator|->
name|ifam_addrs
operator|&
name|RTAX_IFA
operator|)
condition|)
continue|continue;
name|cur_addr
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|ifa
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RTAX_IFA
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifam_addrs
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|ADVANCE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cur_addr
argument_list|,
name|cur_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cur_addr
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|loopback
condition|)
block|{
name|local_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cur_addr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|ifa0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|>=
name|ifa_end
condition|)
block|{
return|return
name|GT_LADDR_NVI
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"setfixedaddr: using local address %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|local_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|KSUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|krb_bind_local_addr
parameter_list|(
name|s
parameter_list|)
name|int
name|s
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|local_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
comment|/* 	 * We haven't determined the local interface to use 	 * for kerberos server interactions.  Do so now. 	 */
if|if
condition|(
operator|(
name|retval
operator|=
name|setfixedaddr
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|KSUCCESS
condition|)
return|return
operator|(
name|retval
operator|)
return|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|local_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|local_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"krb_bind_local_addr: bind"
argument_list|)
expr_stmt|;
return|return
name|BND_LADDR_BIND
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
name|printf
argument_list|(
literal|"local_addr = %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|local_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|KSUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|krb_get_local_addr
parameter_list|(
name|returned_addr
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|returned_addr
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|local_addr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
comment|/* 	 * We haven't determined the local interface to use 	 * for kerberos server interactions.  Do so now. 	 */
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
name|GT_LADDR_NOSOCK
return|;
block|}
if|if
condition|(
operator|(
name|retval
operator|=
name|setfixedaddr
argument_list|(
name|s
argument_list|)
operator|)
operator|!=
name|KSUCCESS
condition|)
block|{
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|returned_addr
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
operator|*
name|returned_addr
operator|=
name|local_addr
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
name|printf
argument_list|(
literal|"local_addr = %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|local_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|KSUCCESS
operator|)
return|;
block|}
end_function

end_unit

