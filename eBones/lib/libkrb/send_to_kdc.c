begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1987, 1988 by the Massachusetts Institute of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  *	from: send_to_kdc.c,v 4.20 90/01/02 13:40:37 jtkohl Exp $  *	$Id: send_to_kdc.c,v 1.2 1994/07/19 19:26:21 g89r4222 Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid_send_to_kdc_c
index|[]
init|=
literal|"$Id: send_to_kdc.c,v 1.1 1994/03/21 17:35:39 piero Exp "
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<prot.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_comment
comment|/* struct iovec to make lint happy */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_define
define|#
directive|define
name|S_AD_SZ
value|sizeof(struct sockaddr_in)
end_define

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|krb_debug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|calloc
argument_list|()
decl_stmt|,
modifier|*
name|realloc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|krb_udp_port
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CLIENT_KRB_TIMEOUT indicates the time to wait before  * retrying a server.  It's defined in "krb.h".  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|timeout
init|=
block|{
name|CLIENT_KRB_TIMEOUT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prog
init|=
literal|"send_to_kdc"
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|send_recv
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This file contains two routines, send_to_kdc() and send_recv().  * send_recv() is a static routine used by send_to_kdc().  */
end_comment

begin_comment
comment|/*  * send_to_kdc() sends a message to the Kerberos authentication  * server(s) in the given realm and returns the reply message.  * The "pkt" argument points to the message to be sent to Kerberos;  * the "rpkt" argument will be filled in with Kerberos' reply.  * The "realm" argument indicates the realm of the Kerberos server(s)  * to transact with.  If the realm is null, the local realm is used.  *  * If more than one Kerberos server is known for a given realm,  * different servers will be queried until one of them replies.  * Several attempts (retries) are made for each server before  * giving up entirely.  *  * If an answer was received from a Kerberos host, KSUCCESS is  * returned.  The following errors can be returned:  *  * SKDC_CANT    - can't get local realm  *              - can't find "kerberos" in /etc/services database  *              - can't open socket  *              - can't bind socket  *              - all ports in use  *              - couldn't find any Kerberos host  *  * SKDC_RETRY   - couldn't get an answer from any Kerberos server,  *		  after several retries  */
end_comment

begin_macro
name|send_to_kdc
argument_list|(
argument|pkt
argument_list|,
argument|rpkt
argument_list|,
argument|realm
argument_list|)
end_macro

begin_decl_stmt
name|KTEXT
name|pkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|KTEXT
name|rpkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|realm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|f
decl_stmt|;
name|int
name|no_host
decl_stmt|;
comment|/* was a kerberos host found? */
name|int
name|retry
decl_stmt|;
name|int
name|n_hosts
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|sockaddr_in
name|to
decl_stmt|;
name|struct
name|hostent
modifier|*
name|host
decl_stmt|,
modifier|*
name|hostlist
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|krbhst
index|[
name|MAX_HSTNM
index|]
decl_stmt|;
name|char
name|lrealm
index|[
name|REALM_SZ
index|]
decl_stmt|;
comment|/*      * If "realm" is non-null, use that, otherwise get the      * local realm.      */
if|if
condition|(
name|realm
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|lrealm
argument_list|,
name|realm
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|krb_get_lrealm
argument_list|(
name|lrealm
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't get local realm\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
return|return
operator|(
name|SKDC_CANT
operator|)
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
name|printf
argument_list|(
literal|"lrealm is %s\n"
argument_list|,
name|lrealm
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_udp_port
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"kerberos"
argument_list|,
literal|"udp"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't get kerberos/udp service\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
return|return
operator|(
name|SKDC_CANT
operator|)
return|;
block|}
name|krb_udp_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
name|printf
argument_list|(
literal|"krb_udp_port is %d\n"
argument_list|,
name|krb_udp_port
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|to
argument_list|,
name|S_AD_SZ
argument_list|)
expr_stmt|;
name|hostlist
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hostlist
condition|)
return|return
operator|(
comment|/*errno */
name|SKDC_CANT
operator|)
return|;
if|if
condition|(
operator|(
name|f
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open socket\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
return|return
operator|(
name|SKDC_CANT
operator|)
return|;
block|}
comment|/* from now on, exit through rtn label for cleanup */
name|no_host
operator|=
literal|1
expr_stmt|;
comment|/* get an initial allocation */
name|n_hosts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|krb_get_krbhst
argument_list|(
name|krbhst
argument_list|,
name|lrealm
argument_list|,
name|i
argument_list|)
operator|==
name|KSUCCESS
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"Getting host entry for %s..."
argument_list|,
name|krbhst
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|host
operator|=
name|gethostbyname
argument_list|(
name|krbhst
argument_list|)
expr_stmt|;
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"%s.\n"
argument_list|,
name|host
condition|?
literal|"Got it"
else|:
literal|"Didn't get it"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|host
condition|)
continue|continue;
name|no_host
operator|=
literal|0
expr_stmt|;
comment|/* found at least one */
name|n_hosts
operator|++
expr_stmt|;
comment|/* preserve host network address to check later          * (would be better to preserve *all* addresses,          * take care of that later)          */
name|hostlist
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hostlist
argument_list|,
operator|(
name|unsigned
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
operator|*
operator|(
name|n_hosts
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hostlist
condition|)
return|return
comment|/*errno */
name|SKDC_CANT
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|host
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|hostlist
index|[
name|n_hosts
operator|-
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|=
operator|&
name|hostlist
index|[
name|n_hosts
operator|-
literal|1
index|]
expr_stmt|;
name|cp
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
block|{
name|retval
operator|=
comment|/*errno */
name|SKDC_CANT
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|host
operator|->
name|h_addr
argument_list|,
name|cp
argument_list|,
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
comment|/* At least Sun OS version 3.2 (or worse) and Ultrix version 2.2    (or worse) only return one name ... */
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|ULTRIX022
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SunOS
argument_list|)
operator|&&
name|SunOS
operator|<
literal|40
operator|)
operator|)
name|host
operator|->
name|h_addr_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host
operator|->
name|h_addr_list
condition|)
block|{
name|retval
operator|=
comment|/*errno */
name|SKDC_CANT
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
endif|#
directive|endif
comment|/* ULTRIX022 || SunOS */
name|host
operator|->
name|h_addr
operator|=
name|cp
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hostlist
index|[
name|n_hosts
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|.
name|sin_family
operator|=
name|host
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|host
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|.
name|sin_addr
argument_list|,
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|to
operator|.
name|sin_port
operator|=
name|krb_udp_port
expr_stmt|;
if|if
condition|(
name|send_recv
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
name|f
argument_list|,
operator|&
name|to
argument_list|,
name|hostlist
argument_list|)
condition|)
block|{
name|retval
operator|=
name|KSUCCESS
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"Timeout, error, or wrong descriptor\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|no_host
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: can't find any Kerberos host.\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|retval
operator|=
name|SKDC_CANT
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
comment|/* retry each host in sequence */
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|CLIENT_KRB_RETRY
condition|;
operator|++
name|retry
control|)
block|{
for|for
control|(
name|host
operator|=
name|hostlist
init|;
name|host
operator|->
name|h_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|;
name|host
operator|++
control|)
block|{
name|to
operator|.
name|sin_family
operator|=
name|host
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|host
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|to
operator|.
name|sin_addr
argument_list|,
name|host
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_recv
argument_list|(
name|pkt
argument_list|,
name|rpkt
argument_list|,
name|f
argument_list|,
operator|&
name|to
argument_list|,
name|hostlist
argument_list|)
condition|)
block|{
name|retval
operator|=
name|KSUCCESS
expr_stmt|;
goto|goto
name|rtn
goto|;
block|}
block|}
block|}
name|retval
operator|=
name|SKDC_RETRY
expr_stmt|;
name|rtn
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostlist
condition|)
block|{
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|hostlist
init|;
name|hp
operator|->
name|h_name
condition|;
name|hp
operator|++
control|)
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|ULTRIX022
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SunOS
argument_list|)
operator|&&
name|SunOS
operator|<
literal|40
operator|)
operator|)
if|if
condition|(
name|hp
operator|->
name|h_addr_list
condition|)
block|{
endif|#
directive|endif
comment|/* ULTRIX022 || SunOS */
if|if
condition|(
name|hp
operator|->
name|h_addr
condition|)
name|free
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|ULTRIX022
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|SunOS
argument_list|)
operator|&&
name|SunOS
operator|<
literal|40
operator|)
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ULTRIX022 || SunOS */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hostlist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * try to send out and receive message.  * return 1 on success, 0 on failure  */
end_comment

begin_expr_stmt
specifier|static
name|send_recv
argument_list|(
argument|pkt
argument_list|,
argument|rpkt
argument_list|,
argument|f
argument_list|,
argument|_to
argument_list|,
argument|addrs
argument_list|)
name|KTEXT
name|pkt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|KTEXT
name|rpkt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|_to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|hostent
modifier|*
name|addrs
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fd_set
name|readfds
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|int
name|sin_size
decl_stmt|;
name|int
name|numsent
decl_stmt|;
if|if
condition|(
name|krb_debug
condition|)
block|{
if|if
condition|(
name|_to
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
name|printf
argument_list|(
literal|"Sending message to %s..."
argument_list|,
name|inet_ntoa
argument_list|(
name|_to
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Sending message..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|numsent
operator|=
name|sendto
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|->
name|dat
operator|)
argument_list|,
name|pkt
operator|->
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|_to
argument_list|,
name|S_AD_SZ
argument_list|)
operator|)
operator|!=
name|pkt
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|printf
argument_list|(
literal|"sent only %d/%d\n"
argument_list|,
name|numsent
argument_list|,
name|pkt
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"Sent\nWaiting for reply..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|FD_ZERO
argument_list|(
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|f
argument_list|,
operator|&
name|readfds
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* select - either recv is ready, or timeout */
comment|/* see if timeout or error or wrong descriptor */
if|if
condition|(
name|select
argument_list|(
name|f
operator|+
literal|1
argument_list|,
operator|&
name|readfds
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|fd_set
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|timeout
argument_list|)
operator|<
literal|1
operator|||
operator|!
name|FD_ISSET
argument_list|(
name|f
argument_list|,
operator|&
name|readfds
argument_list|)
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"select failed: readfds=%x"
argument_list|,
name|readfds
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|sin_size
operator|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|recvfrom
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|rpkt
operator|->
name|dat
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rpkt
operator|->
name|dat
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|sin_size
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
name|perror
argument_list|(
literal|"recvfrom"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"received packet from %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|hp
operator|=
name|addrs
init|;
name|hp
operator|->
name|h_name
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|;
name|hp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
condition|)
block|{
if|if
condition|(
name|krb_debug
condition|)
block|{
name|printf
argument_list|(
literal|"Received it\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"packet not from %x\n"
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|krb_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: received packet from wrong host! (%x)\n"
argument_list|,
literal|"send_to_kdc(send_rcv)"
argument_list|,
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

end_unit

