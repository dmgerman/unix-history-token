begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* enc_read.c */
end_comment

begin_comment
comment|/* Copyright (C) 1993 Eric Young - see README for more details */
end_comment

begin_comment
comment|/*-  *	$Id: enc_read.c,v 1.2 1994/07/19 19:21:54 g89r4222 Exp $  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"des_locl.h"
end_include

begin_comment
comment|/* This has some uglies in it but it works - even over sockets. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|des_rw_mode
init|=
name|DES_PCBC_MODE
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|des_enc_read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|sched
parameter_list|,
name|iv
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|des_key_schedule
name|sched
decl_stmt|;
name|des_cblock
modifier|*
name|iv
decl_stmt|;
block|{
comment|/* data to be unencrypted */
name|int
name|net_num
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|net
index|[
name|BSIZE
index|]
decl_stmt|;
comment|/* extra unencrypted data  	 * for when a block of 100 comes in but is des_read one byte at 	 * a time. */
specifier|static
name|char
name|unnet
index|[
name|BSIZE
index|]
decl_stmt|;
specifier|static
name|int
name|unnet_start
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|unnet_left
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|num
init|=
literal|0
decl_stmt|,
name|rnum
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* left over data from last decrypt */
if|if
condition|(
name|unnet_left
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|unnet_left
operator|<
name|len
condition|)
block|{
comment|/* we still still need more data but will return 			 * with the number of bytes we have - should always 			 * check the return value */
name|bcopy
argument_list|(
operator|&
operator|(
name|unnet
index|[
name|unnet_start
index|]
operator|)
argument_list|,
name|buf
argument_list|,
name|unnet_left
argument_list|)
expr_stmt|;
comment|/* eay 26/08/92 I had the next 2 lines 			 * reversed :-( */
name|i
operator|=
name|unnet_left
expr_stmt|;
name|unnet_start
operator|=
name|unnet_left
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|&
operator|(
name|unnet
index|[
name|unnet_start
index|]
operator|)
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|unnet_start
operator|+=
name|len
expr_stmt|;
name|unnet_left
operator|-=
name|len
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
comment|/* We need to get more data. */
if|if
condition|(
name|len
operator|>
name|MAXWRITE
condition|)
name|len
operator|=
name|MAXWRITE
expr_stmt|;
comment|/* first - get the length */
name|net_num
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|net_num
operator|<
name|HDRSIZE
condition|)
block|{
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
operator|(
name|net
index|[
name|net_num
index|]
operator|)
argument_list|,
name|HDRSIZE
operator|-
name|net_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|net_num
operator|+=
name|i
expr_stmt|;
block|}
comment|/* we now have at net_num bytes in net */
name|p
operator|=
name|net
expr_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
name|n2l
argument_list|(
name|p
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|/* num should be rounded up to the next group of eight 	 * we make sure that we have read a multiple of 8 bytes from the net. 	 */
if|if
condition|(
operator|(
name|num
operator|>
name|MAXWRITE
operator|)
operator|||
operator|(
name|num
operator|<
literal|0
operator|)
condition|)
comment|/* error */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|rnum
operator|=
operator|(
name|num
operator|<
literal|8
operator|)
condition|?
literal|8
else|:
operator|(
operator|(
name|num
operator|+
literal|7
operator|)
operator|/
literal|8
operator|*
literal|8
operator|)
expr_stmt|;
name|net_num
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|net_num
operator|<
name|rnum
condition|)
block|{
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
operator|(
name|net
index|[
name|net_num
index|]
operator|)
argument_list|,
name|rnum
operator|-
name|net_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|errno
operator|==
name|EINTR
operator|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|net_num
operator|+=
name|i
expr_stmt|;
block|}
comment|/* Check if there will be data left over. */
if|if
condition|(
name|len
operator|<
name|num
condition|)
block|{
if|if
condition|(
name|des_rw_mode
operator|&
name|DES_PCBC_MODE
condition|)
name|pcbc_encrypt
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|net
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|unnet
argument_list|,
name|num
argument_list|,
name|sched
argument_list|,
name|iv
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
else|else
name|cbc_encrypt
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|net
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|unnet
argument_list|,
name|num
argument_list|,
name|sched
argument_list|,
name|iv
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|unnet
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|unnet_start
operator|=
name|len
expr_stmt|;
name|unnet_left
operator|=
name|num
operator|-
name|len
expr_stmt|;
comment|/* The following line is done because we return num 		 * as the number of bytes read. */
name|num
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/*>output is a multiple of 8 byes, if len< rnum 		 *>we must be careful.  The user must be aware that this 		 *>routine will write more bytes than he asked for. 		 *>The length of the buffer must be correct. 		 * FIXED - Should be ok now 18-9-90 - eay */
if|if
condition|(
name|len
operator|<
name|rnum
condition|)
block|{
name|char
name|tmpbuf
index|[
name|BSIZE
index|]
decl_stmt|;
if|if
condition|(
name|des_rw_mode
operator|&
name|DES_PCBC_MODE
condition|)
name|pcbc_encrypt
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|net
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|tmpbuf
argument_list|,
name|num
argument_list|,
name|sched
argument_list|,
name|iv
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
else|else
name|cbc_encrypt
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|net
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|tmpbuf
argument_list|,
name|num
argument_list|,
name|sched
argument_list|,
name|iv
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
comment|/* eay 26/08/92 fix a bug that returned more 			 * bytes than you asked for (returned len bytes :-( */
name|bcopy
argument_list|(
name|tmpbuf
argument_list|,
name|buf
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|des_rw_mode
operator|&
name|DES_PCBC_MODE
condition|)
name|pcbc_encrypt
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|net
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|buf
argument_list|,
name|num
argument_list|,
name|sched
argument_list|,
name|iv
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
else|else
name|cbc_encrypt
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|net
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|buf
argument_list|,
name|num
argument_list|,
name|sched
argument_list|,
name|iv
argument_list|,
name|DES_DECRYPT
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|num
operator|)
return|;
block|}
end_function

end_unit

