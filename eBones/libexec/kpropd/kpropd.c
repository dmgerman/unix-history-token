begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1987 by the Massachusetts Institute of Technology.  *   * For copying and distribution information, please see the file  * MIT.Copyright.  *  * kprop/kpropd have been abandonded by Project Athena (for good reason)  * however they still form the basis for one of the better ways for  * distributing kerberos databases.  This version of kpropd has been  * adapted from the MIT distribution to work properly in a 4.4BSD  * environment.  *   * $Revision: 1.1.1.1 $ $Date: 1995/08/03 07:37:19 $ $State: Exp $  * $Source: /usr/cvs/src/eBones/kpropd/kpropd.c,v $  *   * Log: kpropd.c,v  * Revision 4.5  92/10/23  15:45:46  tytso Make it possible  * to specify the location of the kdb_util program.  *   * Revision 4.4  91/06/15  03:20:51  probe Fixed<sys/types.h> inclusion  *   * Revision 4.3  89/05/16  15:06:04  wesommer Fix operator precedence stuff.  * Programmer: John Kohl.  *   * Revision 4.2  89/03/23  10:24:00  jtkohl NOENCRYPTION changes  *   * Revision 4.1  89/01/24  20:33:48  root name change  *   * Revision 4.0  89/01/24  18:45:06  wesommer Original version; programmer:  * wesommer auditor: jon  *   * Revision 4.5  88/01/08  18:07:46  jon formatting and rcs header changes */
end_comment

begin_comment
comment|/*  * This program is run on slave servers, to catch updates "pushed" from the  * master kerberos server in a realm.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char     rcsid_kpropd_c[] = "$FreeBSD$";
endif|#
directive|endif
end_endif

begin_comment
comment|/* lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<krb_db.h>
end_include

begin_include
include|#
directive|include
file|"kprop.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|kprop_version
index|[
name|KPROP_PROT_VERSION_LEN
index|]
init|=
name|KPROP_PROT_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pause_int
init|=
literal|300
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5 minutes in seconds */
end_comment

begin_function_decl
name|unsigned
name|long
name|get_data_checksum
parameter_list|(
name|int
name|fd
parameter_list|,
name|Key_schedule
name|key_sched
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|recv_auth
parameter_list|(
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|,
name|int
name|private
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|remote
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|local
parameter_list|,
name|AUTH_DAT
modifier|*
name|ad
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|SlowDeath
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|recv_clear
parameter_list|(
name|int
name|in
parameter_list|,
name|int
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* leave room for private msg overhead */
end_comment

begin_decl_stmt
specifier|static
name|char
name|buf
index|[
name|KPROP_BUFSIZ
operator|+
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nUsage: kpropd [-r realm] [-s srvtab] [-P kdb_util] fname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|s2
decl_stmt|,
name|fd
decl_stmt|,
name|n
decl_stmt|,
name|fdlock
decl_stmt|;
name|int
name|from_len
decl_stmt|;
name|char
name|local_file
index|[
literal|256
index|]
decl_stmt|;
name|char
name|local_temp
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
name|hostname
index|[
literal|256
index|]
decl_stmt|;
name|char
name|from_str
index|[
literal|128
index|]
decl_stmt|;
name|long
name|kerror
decl_stmt|;
name|AUTH_DAT
name|auth_dat
decl_stmt|;
name|KTEXT_ST
name|ticket
decl_stmt|;
name|char
name|my_instance
index|[
name|INST_SZ
index|]
decl_stmt|;
name|char
name|my_realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|char
name|cmd
index|[
literal|1024
index|]
decl_stmt|;
name|short
name|net_transfer_mode
decl_stmt|,
name|transfer_mode
decl_stmt|;
name|Key_schedule
name|session_sched
decl_stmt|;
name|char
name|version
index|[
literal|9
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|int
name|rflag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|srvtab
init|=
literal|""
decl_stmt|;
name|char
modifier|*
name|local_db
init|=
name|DBM_FILE
decl_stmt|;
name|char
modifier|*
name|kdb_util
init|=
name|KPROP_KDB_UTIL
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'k'
operator|&&
name|isdigit
argument_list|(
name|argv
index|[
name|argc
operator|-
literal|1
index|]
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|argc
operator|--
expr_stmt|;
comment|/* ttys file hack */
block|}
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"r:s:d:P:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'r'
case|:
name|rflag
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|my_realm
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|srvtab
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|local_db
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|kdb_util
operator|=
name|optarg
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
operator|-
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|openlog
argument_list|(
literal|"kpropd"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_AUTH
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|local_file
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|strcpy
argument_list|(
name|local_temp
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|)
argument_list|,
literal|".tmp"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STANDALONE
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"krb_prop"
argument_list|,
literal|"tcp"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"tcp/krb_prop: unknown service."
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|sin
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STANDALONE */
if|if
condition|(
operator|!
name|rflag
condition|)
block|{
name|kerror
operator|=
name|krb_get_lrealm
argument_list|(
name|my_realm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
operator|!=
name|KSUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't get local realm. %s"
argument_list|,
name|krb_err_txt
index|[
name|kerror
index|]
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gethostname
argument_list|(
name|my_instance
argument_list|,
sizeof|sizeof
argument_list|(
name|my_instance
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gethostname: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STANDALONE
name|listen
argument_list|(
name|s
argument_list|,
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|from_len
operator|=
sizeof|sizeof
name|from
expr_stmt|;
if|if
condition|(
operator|(
name|s2
operator|=
name|accept
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|from_len
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"accept: %m"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|#
directive|else
comment|/* !STANDALONE */
name|s2
operator|=
literal|0
expr_stmt|;
name|from_len
operator|=
sizeof|sizeof
name|from
expr_stmt|;
if|if
condition|(
name|getpeername
argument_list|(
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|from_len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getpeername: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !STANDALONE */
name|strcpy
argument_list|(
name|from_str
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|)
argument_list|,
name|from_len
argument_list|,
name|AF_INET
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|hostname
argument_list|,
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|hostname
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"connection from %s, %s"
argument_list|,
name|hostname
argument_list|,
name|from_str
argument_list|)
expr_stmt|;
comment|/* for krb_rd_{priv, safe} */
name|n
operator|=
sizeof|sizeof
name|sin
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|s2
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't get socketname: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't get socketname (length)"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fdlock
operator|=
name|open
argument_list|(
name|local_temp
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"open: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flock
argument_list|(
name|fdlock
argument_list|,
name|LOCK_EX
operator||
name|LOCK_NB
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"flock: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|creat
argument_list|(
name|local_temp
argument_list|,
literal|0600
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"creat: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|s2
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|kprop_version
argument_list|)
argument_list|)
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|kprop_version
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't read protocol version (%d bytes)"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
name|kprop_version
argument_list|,
sizeof|sizeof
argument_list|(
name|kprop_version
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"unsupported version %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|s2
argument_list|,
operator|&
name|net_transfer_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|net_transfer_mode
argument_list|)
argument_list|)
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|net_transfer_mode
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't read transfer mode"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
name|transfer_mode
operator|=
name|ntohs
argument_list|(
name|net_transfer_mode
argument_list|)
expr_stmt|;
name|kerror
operator|=
name|krb_recvauth
argument_list|(
name|KOPT_DO_MUTUAL
argument_list|,
name|s2
argument_list|,
operator|&
name|ticket
argument_list|,
name|KPROP_SERVICE_NAME
argument_list|,
name|my_instance
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|sin
argument_list|,
operator|&
name|auth_dat
argument_list|,
name|srvtab
argument_list|,
name|session_sched
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
operator|!=
name|KSUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s calling getkdata"
argument_list|,
name|krb_err_txt
index|[
name|kerror
index|]
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"connection from %s.%s@%s"
argument_list|,
name|auth_dat
operator|.
name|pname
argument_list|,
name|auth_dat
operator|.
name|pinst
argument_list|,
name|auth_dat
operator|.
name|prealm
argument_list|)
expr_stmt|;
comment|/* 		 * AUTHORIZATION is done here.  We might want to expand this 		 * to read an acl file at some point, but allowing for now 		 * KPROP_SERVICE_NAME.KRB_MASTER@local-realm is fine ... 		 */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|KPROP_SERVICE_NAME
argument_list|,
name|auth_dat
operator|.
name|pname
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|KRB_MASTER
argument_list|,
name|auth_dat
operator|.
name|pinst
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|my_realm
argument_list|,
name|auth_dat
operator|.
name|prealm
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"authorization denied"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|transfer_mode
condition|)
block|{
case|case
name|KPROP_TRANSFER_PRIVATE
case|:
name|recv_auth
argument_list|(
name|s2
argument_list|,
name|fd
argument_list|,
literal|1
comment|/* private */
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|sin
argument_list|,
operator|&
name|auth_dat
argument_list|)
expr_stmt|;
break|break;
case|case
name|KPROP_TRANSFER_SAFE
case|:
name|recv_auth
argument_list|(
name|s2
argument_list|,
name|fd
argument_list|,
literal|0
comment|/* safe */
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|sin
argument_list|,
operator|&
name|auth_dat
argument_list|)
expr_stmt|;
break|break;
case|case
name|KPROP_TRANSFER_CLEAR
case|:
name|recv_clear
argument_list|(
name|s2
argument_list|,
name|fd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bad transfer mode %d"
argument_list|,
name|transfer_mode
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|transfer_mode
operator|!=
name|KPROP_TRANSFER_PRIVATE
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"non-private transfers not supported\n"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|doesnt_work_yet
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_dat
operator|.
name|checksum
operator|!=
name|get_data_checksum
argument_list|(
name|fd
argument_list|,
name|session_sched
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"checksum doesn't match"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_size
operator|!=
name|auth_dat
operator|.
name|checksum
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"length doesn't match"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|local_temp
argument_list|,
name|local_file
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rename: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flock
argument_list|(
name|fdlock
argument_list|,
name|LOCK_UN
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"flock (unlock): %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
name|close
argument_list|(
name|fdlock
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"%s load %s %s\n"
argument_list|,
name|kdb_util
argument_list|,
name|local_file
argument_list|,
name|local_db
argument_list|)
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|cmd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"couldn't load database"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STANDALONE
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|recv_auth
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|,
name|private
parameter_list|,
name|remote
parameter_list|,
name|local
parameter_list|,
name|ad
parameter_list|)
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
name|int
name|private
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|remote
decl_stmt|,
decl|*
name|local
decl_stmt|;
end_function

begin_decl_stmt
name|AUTH_DAT
modifier|*
name|ad
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_long
name|length
decl_stmt|;
name|long
name|kerror
decl_stmt|;
name|int
name|n
decl_stmt|;
name|MSG_DAT
name|msg_data
decl_stmt|;
name|Key_schedule
name|session_sched
decl_stmt|;
if|if
condition|(
name|private
condition|)
ifdef|#
directive|ifdef
name|NOENCRYPTION
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|session_sched
argument_list|,
sizeof|sizeof
argument_list|(
name|session_sched
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|key_sched
argument_list|(
operator|(
name|C_Block
operator|*
operator|)
name|ad
operator|->
name|session
argument_list|,
name|session_sched
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't make key schedule"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
name|n
operator|=
name|krb_net_read
argument_list|(
name|in
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|length
argument_list|,
sizeof|sizeof
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"read: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
name|length
operator|=
name|ntohl
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
sizeof|sizeof
name|buf
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"read length %d, bigger than buf %d"
argument_list|,
name|length
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
name|n
operator|=
name|krb_net_read
argument_list|(
name|in
argument_list|,
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"kpropd: read: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|private
condition|)
name|kerror
operator|=
name|krb_rd_priv
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|session_sched
argument_list|,
name|ad
operator|->
name|session
argument_list|,
name|remote
argument_list|,
name|local
argument_list|,
operator|&
name|msg_data
argument_list|)
expr_stmt|;
else|else
name|kerror
operator|=
name|krb_rd_safe
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
operator|(
name|C_Block
operator|*
operator|)
name|ad
operator|->
name|session
argument_list|,
name|remote
argument_list|,
name|local
argument_list|,
operator|&
name|msg_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
operator|!=
name|KSUCCESS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %s"
argument_list|,
name|private
condition|?
literal|"krb_rd_priv"
else|:
literal|"krb_rd_safe"
argument_list|,
name|krb_err_txt
index|[
name|kerror
index|]
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|out
argument_list|,
name|msg_data
operator|.
name|app_data
argument_list|,
name|msg_data
operator|.
name|app_length
argument_list|)
operator|!=
name|msg_data
operator|.
name|app_length
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"write: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
name|void
name|recv_clear
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|)
name|int
name|in
decl_stmt|,
name|out
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|n
operator|=
name|read
argument_list|(
name|in
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"read: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|out
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"write: %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|SlowDeath
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|STANDALONE
name|sleep
argument_list|(
name|pause_int
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|doesnt_work_yet
end_ifdef

begin_function
name|unsigned
name|long
name|get_data_checksum
parameter_list|(
name|fd
parameter_list|,
name|key_sched
parameter_list|)
name|int
name|fd
decl_stmt|;
name|Key_schedule
name|key_sched
decl_stmt|;
block|{
name|unsigned
name|long
name|cksum
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|cbc_cksum
parameter_list|()
function_decl|;
name|int
name|n
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
name|obuf
index|[
literal|8
index|]
decl_stmt|;
while|while
condition|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"read (in checksum test): %m"
argument_list|)
expr_stmt|;
name|SlowDeath
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NOENCRYPTION
name|cksum
operator|+=
name|cbc_cksum
argument_list|(
name|buf
argument_list|,
name|obuf
argument_list|,
name|n
argument_list|,
name|key_sched
argument_list|,
name|key_sched
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|cksum
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

