begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1987, 1988 by the Massachusetts Institute of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  *	from: sendauth.c,v 4.6 90/03/10 23:18:28 jon Exp $  *	$Id: sendauth.c,v 1.3 1995/07/18 16:39:44 mark Exp $  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char rcsid[] = "$Id: sendauth.c,v 1.3 1995/07/18 16:39:44 mark Exp $";
endif|#
directive|endif
endif|lint
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_define
define|#
directive|define
name|KRB_SENDAUTH_VERS
value|"AUTHV0.1"
end_define

begin_comment
comment|/* MUST be KRB_SENDAUTH_VLEN chars */
end_comment

begin_comment
comment|/*  * If the protocol changes, you will need to change the version string  * and make appropriate changes in krb_recvauth.c  */
end_comment

begin_comment
comment|/*  * This file contains two routines: krb_sendauth() and krb_sendsrv().  *  * krb_sendauth() transmits a ticket over a file descriptor for a  * desired service, instance, and realm, doing mutual authentication  * with the server if desired.  *  * krb_sendsvc() sends a service name to a remote knetd server.  */
end_comment

begin_comment
comment|/*  * The first argument to krb_sendauth() contains a bitfield of  * options (the options are defined in "krb.h"):  *  * KOPT_DONT_CANON	Don't canonicalize instance as a hostname.  *			(If this option is not chosen, krb_get_phost()  *			is called to canonicalize it.)  *  * KOPT_DONT_MK_REQ 	Don't request server ticket from Kerberos.  *			A ticket must be supplied in the "ticket"  *			argument.  *			(If this option is not chosen, and there  *			is no ticket for the given server in the  *			ticket cache, one will be fetched using  *			krb_mk_req() and returned in "ticket".)  *  * KOPT_DO_MUTUAL	Do mutual authentication, requiring that the  * 			receiving server return the checksum+1 encrypted  *			in the session key.  The mutual authentication  *			is done using krb_mk_priv() on the other side  *			(see "recvauth.c") and krb_rd_priv() on this  *			side.  *  * The "fd" argument is a file descriptor to write to the remote  * server on.  The "ticket" argument is used to store the new ticket  * from the krb_mk_req() call. If the KOPT_DONT_MK_REQ options is  * chosen, the ticket must be supplied in the "ticket" argument.  * The "service", "inst", and "realm" arguments identify the ticket.  * If "realm" is null, the local realm is used.  *  * The following arguments are only needed if the KOPT_DO_MUTUAL option  * is chosen:  *  *   The "checksum" argument is a number that the server will add 1 to  *   to authenticate itself back to the client; the "msg_data" argument  *   holds the returned mutual-authentication message from the server  *   (i.e., the checksum+1); the "cred" structure is used to hold the  *   session key of the server, extracted from the ticket file, for use  *   in decrypting the mutual authentication message from the server;  *   and "schedule" holds the key schedule for that decryption.  The  *   the local and server addresses are given in "laddr" and "faddr".  *  * The application protocol version number (of up to KRB_SENDAUTH_VLEN  * characters) is passed in "version".  *  * If all goes well, KSUCCESS is returned, otherwise some error code.  *  * The format of the message sent to the server is:  *  * Size			Variable		Field  * ----			--------		-----  *  * KRB_SENDAUTH_VLEN	KRB_SENDAUTH_VER	sendauth protocol  * bytes					version number  *  * KRB_SENDAUTH_VLEN	version			application protocol  * bytes					version number  *  * 4 bytes		ticket->length		length of ticket  *  * ticket->length	ticket->dat		ticket itself  */
end_comment

begin_comment
comment|/*  * XXX: Note that krb_rd_priv() is coded in such a way that  * "msg_data->app_data" will be pointing into "priv_buf", which  * will disappear when krb_sendauth() returns.  */
end_comment

begin_function
name|int
name|krb_sendauth
parameter_list|(
name|long
name|options
parameter_list|,
name|int
name|fd
parameter_list|,
name|KTEXT
name|ticket
parameter_list|,
name|char
modifier|*
name|service
parameter_list|,
name|char
modifier|*
name|inst
parameter_list|,
name|char
modifier|*
name|realm
parameter_list|,
name|u_long
name|checksum
parameter_list|,
name|MSG_DAT
modifier|*
name|msg_data
parameter_list|,
name|CREDENTIALS
modifier|*
name|cred
parameter_list|,
name|des_key_schedule
name|schedule
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|laddr
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|faddr
parameter_list|,
name|char
modifier|*
name|version
parameter_list|)
block|{
name|int
name|rem
decl_stmt|,
name|i
decl_stmt|,
name|cc
decl_stmt|;
name|char
name|srv_inst
index|[
name|INST_SZ
index|]
decl_stmt|;
name|char
name|krb_realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|long
name|tkt_len
decl_stmt|;
name|u_char
name|priv_buf
index|[
literal|1024
index|]
decl_stmt|;
name|u_long
name|cksum
decl_stmt|;
name|rem
operator|=
name|KSUCCESS
expr_stmt|;
comment|/* get current realm if not passed in */
if|if
condition|(
operator|!
name|realm
condition|)
block|{
name|rem
operator|=
name|krb_get_lrealm
argument_list|(
name|krb_realm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|!=
name|KSUCCESS
condition|)
return|return
operator|(
name|rem
operator|)
return|;
name|realm
operator|=
name|krb_realm
expr_stmt|;
block|}
comment|/* copy instance into local storage, canonicalizing if desired */
if|if
condition|(
name|options
operator|&
name|KOPT_DONT_CANON
condition|)
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|srv_inst
argument_list|,
name|inst
argument_list|,
name|INST_SZ
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|srv_inst
argument_list|,
name|krb_get_phost
argument_list|(
name|inst
argument_list|)
argument_list|,
name|INST_SZ
argument_list|)
expr_stmt|;
comment|/* get the ticket if desired */
if|if
condition|(
operator|!
operator|(
name|options
operator|&
name|KOPT_DONT_MK_REQ
operator|)
condition|)
block|{
name|rem
operator|=
name|krb_mk_req
argument_list|(
name|ticket
argument_list|,
name|service
argument_list|,
name|srv_inst
argument_list|,
name|realm
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|!=
name|KSUCCESS
condition|)
return|return
operator|(
name|rem
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ATHENA_COMPAT
comment|/* this is only for compatibility with old servers */
if|if
condition|(
name|options
operator|&
name|KOPT_DO_OLDSTYLE
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d "
argument_list|,
name|ticket
operator|->
name|length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ticket
operator|->
name|dat
argument_list|,
name|ticket
operator|->
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|rem
operator|)
return|;
block|}
endif|#
directive|endif
endif|ATHENA_COMPAT
comment|/* if mutual auth, get credentials so we have service session        keys for decryption below */
if|if
condition|(
name|options
operator|&
name|KOPT_DO_MUTUAL
condition|)
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_get_cred
argument_list|(
name|service
argument_list|,
name|srv_inst
argument_list|,
name|realm
argument_list|,
name|cred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|cc
operator|)
return|;
comment|/* zero the buffer */
operator|(
name|void
operator|)
name|bzero
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
comment|/* insert version strings */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|KRB_SENDAUTH_VERS
argument_list|,
name|KRB_SENDAUTH_VLEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
operator|+
name|KRB_SENDAUTH_VLEN
argument_list|,
name|version
argument_list|,
name|KRB_SENDAUTH_VLEN
argument_list|)
expr_stmt|;
comment|/* increment past vers strings */
name|i
operator|=
literal|2
operator|*
name|KRB_SENDAUTH_VLEN
expr_stmt|;
comment|/* put ticket length into buffer */
name|tkt_len
operator|=
name|htonl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|ticket
operator|->
name|length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tkt_len
argument_list|,
name|buf
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
expr_stmt|;
comment|/* put ticket into buffer */
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ticket
operator|->
name|dat
argument_list|,
name|buf
operator|+
name|i
argument_list|,
name|ticket
operator|->
name|length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|ticket
operator|->
name|length
expr_stmt|;
comment|/* write the request to the server */
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_net_write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
name|i
condition|)
return|return
operator|(
name|cc
operator|)
return|;
comment|/* mutual authentication, if desired */
if|if
condition|(
name|options
operator|&
name|KOPT_DO_MUTUAL
condition|)
block|{
comment|/* get the length of the reply */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tkt_len
argument_list|,
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|tkt_len
argument_list|)
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|tkt_len
operator|=
name|ntohl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|tkt_len
argument_list|)
expr_stmt|;
comment|/* if the length is negative, the server failed to recognize us. */
if|if
condition|(
operator|(
name|tkt_len
operator|<
literal|0
operator|)
operator|||
operator|(
name|tkt_len
operator|>
sizeof|sizeof
argument_list|(
name|priv_buf
argument_list|)
operator|)
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
comment|/* XXX */
comment|/* read the reply... */
if|if
condition|(
name|krb_net_read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|priv_buf
argument_list|,
operator|(
name|int
operator|)
name|tkt_len
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|tkt_len
condition|)
return|return
operator|(
name|errno
operator|)
return|;
comment|/* ...and decrypt it */
ifndef|#
directive|ifndef
name|NOENCRYPTION
name|key_sched
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|cred
operator|->
name|session
argument_list|,
name|schedule
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_rd_priv
argument_list|(
name|priv_buf
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tkt_len
argument_list|,
name|schedule
argument_list|,
name|cred
operator|->
name|session
argument_list|,
name|faddr
argument_list|,
name|laddr
argument_list|,
name|msg_data
argument_list|)
operator|)
condition|)
return|return
operator|(
name|cc
operator|)
return|;
comment|/* fetch the (modified) checksum */
operator|(
name|void
operator|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msg_data
operator|->
name|app_data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|cksum
argument_list|)
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|ntohl
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
comment|/* if it doesn't match, fail */
if|if
condition|(
name|cksum
operator|!=
name|checksum
operator|+
literal|1
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
comment|/* XXX */
block|}
return|return
operator|(
name|KSUCCESS
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATHENA_COMPAT
end_ifdef

begin_comment
comment|/*  * krb_sendsvc  */
end_comment

begin_function
name|int
name|krb_sendsvc
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|service
parameter_list|)
block|{
comment|/* write the service name length and then the service name to        the fd */
name|long
name|serv_length
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|serv_length
operator|=
name|htonl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|strlen
argument_list|(
name|service
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_net_write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|serv_length
argument_list|,
sizeof|sizeof
argument_list|(
name|serv_length
argument_list|)
argument_list|)
operator|)
operator|!=
sizeof|sizeof
argument_list|(
name|serv_length
argument_list|)
condition|)
return|return
operator|(
name|cc
operator|)
return|;
if|if
condition|(
operator|(
name|cc
operator|=
name|krb_net_write
argument_list|(
name|fd
argument_list|,
name|service
argument_list|,
name|strlen
argument_list|(
name|service
argument_list|)
argument_list|)
operator|)
operator|!=
name|strlen
argument_list|(
name|service
argument_list|)
condition|)
return|return
operator|(
name|cc
operator|)
return|;
return|return
operator|(
name|KSUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|ATHENA_COMPAT
end_endif

end_unit

