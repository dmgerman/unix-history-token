begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1985, 1986, 1987, 1988 by the Massachusetts Institute  * of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  *	from: kerberos.c,v 4.19 89/11/01 17:18:07 qjb Exp $  *	$Id$  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char rcsid[] = "$Id$";
endif|#
directive|endif
endif|lint
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<des.h>
end_include

begin_include
include|#
directive|include
file|<klog.h>
end_include

begin_include
include|#
directive|include
file|<prot.h>
end_include

begin_include
include|#
directive|include
file|<krb_db.h>
end_include

begin_include
include|#
directive|include
file|<kdc.h>
end_include

begin_function_decl
name|void
name|cr_err_reply
parameter_list|(
name|KTEXT
name|pkt
parameter_list|,
name|char
modifier|*
name|pname
parameter_list|,
name|char
modifier|*
name|pinst
parameter_list|,
name|char
modifier|*
name|prealm
parameter_list|,
name|u_long
name|time_ws
parameter_list|,
name|u_long
name|e
parameter_list|,
name|char
modifier|*
name|e_string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|kerb_err_reply
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|client
parameter_list|,
name|KTEXT
name|pkt
parameter_list|,
name|long
name|err
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|setup_disc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|kerberos
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|client
parameter_list|,
name|KTEXT
name|pkt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|check_princ
parameter_list|(
name|char
modifier|*
name|p_name
parameter_list|,
name|char
modifier|*
name|instance
parameter_list|,
name|unsigned
name|lifetime
parameter_list|,
name|Principal
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|set_tgtkey
parameter_list|(
name|char
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|sockaddr_in
name|s_in
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX several files in libkdb know about this */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Key_schedule
name|master_key_schedule
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|C_Block
name|master_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|kerb_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Principal
name|a_name_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for requesting user */
end_comment

begin_decl_stmt
specifier|static
name|Principal
name|s_name_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for services requested */
end_comment

begin_decl_stmt
specifier|static
name|C_Block
name|session_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|master_key_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|k_instance
index|[
name|INST_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|more
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are we invoked manually? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Have we set an alterate log file? */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|log_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of alt. log file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't check max age */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* alternate realm specified */
end_comment

begin_comment
comment|/* fields within the received request packet */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|req_msg_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|req_version
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|req_name_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|req_inst_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|req_realm_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|req_time_ws
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|req_act_vno
init|=
name|KRB_PROT_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary for version skew */
end_comment

begin_decl_stmt
specifier|static
name|char
name|local_realm
index|[
name|REALM_SZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* statistics */
end_comment

begin_decl_stmt
specifier|static
name|long
name|q_bytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current bytes remaining in queue */
end_comment

begin_decl_stmt
specifier|static
name|long
name|q_n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* how many consecutive non-zero 				 * q_bytes   */
end_comment

begin_decl_stmt
specifier|static
name|long
name|max_q_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|max_q_n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|n_auth_req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|n_appl_req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|n_packets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|max_age
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|pause_int
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|check_db_age
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hang
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Print usage message and exit.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-s] [-m] [-n] [-p pause_seconds]%s%s\n"
argument_list|,
name|progname
argument_list|,
literal|" [-a max_age] [-l log_file] [-r realm]"
argument_list|,
literal|" [database_pathname]"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|from
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
name|int
name|child
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|int
name|fromlen
decl_stmt|;
specifier|static
name|KTEXT_ST
name|pkt_st
decl_stmt|;
name|KTEXT
name|pkt
init|=
operator|&
name|pkt_st
decl_stmt|;
name|int
name|kerror
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"snmp:a:l:r:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* 	     * Set parameters to slave server defaults. 	     */
if|if
condition|(
name|max_age
operator|==
operator|-
literal|1
operator|&&
operator|!
name|nflag
condition|)
name|max_age
operator|=
name|ONE_DAY
expr_stmt|;
comment|/* 24 hours */
if|if
condition|(
name|pause_int
operator|==
operator|-
literal|1
condition|)
name|pause_int
operator|=
name|FIVE_MINUTES
expr_stmt|;
comment|/* 5 minutes */
if|if
condition|(
name|lflag
operator|==
literal|0
condition|)
block|{
name|log_file
operator|=
name|KRBSLAVELOG
expr_stmt|;
name|lflag
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'n'
case|:
name|max_age
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't check max age. */
name|nflag
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mflag
operator|++
expr_stmt|;
comment|/* running manually; prompt for master key */
break|break;
case|case
literal|'p'
case|:
comment|/* Set pause interval. */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|pause_int
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pause_int
operator|<
literal|5
operator|)
operator|||
operator|(
name|pause_int
operator|>
name|ONE_HOUR
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"pause_int must be between 5 and 3600 seconds.\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
comment|/* Set max age. */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|optarg
index|[
literal|0
index|]
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
name|max_age
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|max_age
operator|<
name|ONE_HOUR
operator|)
operator|||
operator|(
name|max_age
operator|>
name|THREE_DAYS
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"max_age must be between one hour and three days, in seconds\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* Set alternate log file */
name|lflag
operator|++
expr_stmt|;
name|log_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Set realm name */
name|rflag
operator|++
expr_stmt|;
name|strcpy
argument_list|(
name|local_realm
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|==
operator|(
name|argc
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|kerb_db_set_name
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not set alternate database name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|optind
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Kerberos server starting\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|nflag
operator|)
operator|&&
operator|(
name|max_age
operator|!=
operator|-
literal|1
operator|)
condition|)
name|printf
argument_list|(
literal|"\tMaximum database age: %ld seconds\n"
argument_list|,
name|max_age
argument_list|)
expr_stmt|;
if|if
condition|(
name|pause_int
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"\tSleep for %ld seconds on error\n"
argument_list|,
name|pause_int
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\tSleep forever on error\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mflag
condition|)
name|printf
argument_list|(
literal|"\tMaster key will be entered manually\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tLog file is %s\n"
argument_list|,
name|lflag
condition|?
name|log_file
else|:
name|KRBLOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|lflag
condition|)
name|kset_logfile
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
comment|/* find our hostname, and use it as the instance */
if|if
condition|(
name|gethostname
argument_list|(
name|k_instance
argument_list|,
name|INST_SZ
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: gethostname error\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"kerberos"
argument_list|,
literal|"udp"
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: udp/kerberos unknown service\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|s_in
operator|.
name|sin_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't open socket\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setsockopt
argument_list|(
name|f
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: setsockopt (SO_REUSEADDR)\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|f
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|s_in
argument_list|,
name|S_AD_SZ
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Can't bind socket\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* do all the database and cache inits */
if|if
condition|(
operator|(
name|n
operator|=
name|kerb_init
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|mflag
condition|)
block|{
name|printf
argument_list|(
literal|"Kerberos db and cache init "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"failed = %d ...exiting\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Kerberos db and cache init failed = %d ...exiting"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Make sure database isn't stale */
name|check_db_age
argument_list|()
expr_stmt|;
comment|/* setup master key */
if|if
condition|(
name|kdb_get_master_key
argument_list|(
name|mflag
argument_list|,
name|master_key
argument_list|,
name|master_key_schedule
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"kerberos: couldn't get master key.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|kerror
operator|=
name|kdb_verify_master_key
argument_list|(
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerror
operator|<
literal|0
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Can't verify master key."
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|master_key
argument_list|,
sizeof|sizeof
argument_list|(
name|master_key
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|master_key_schedule
argument_list|,
sizeof|sizeof
argument_list|(
name|master_key_schedule
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|des_init_random_number_generator
argument_list|(
name|master_key
argument_list|)
expr_stmt|;
name|master_key_version
operator|=
operator|(
name|u_char
operator|)
name|kerror
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\nCurrent Kerberos master key version is %d\n"
argument_list|,
name|master_key_version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rflag
condition|)
block|{
comment|/* Look up our local realm */
name|krb_get_lrealm
argument_list|(
name|local_realm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Local realm: %s\n"
argument_list|,
name|local_realm
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_tgtkey
argument_list|(
name|local_realm
argument_list|)
condition|)
block|{
comment|/* Ticket granting service unknown */
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Ticket granting ticket service unknown"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Ticket granting ticket service unknown\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mflag
condition|)
block|{
if|if
condition|(
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Kerberos started, PID=%d\n"
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|setup_disc
argument_list|()
expr_stmt|;
block|}
comment|/* receive loop */
for|for
control|(
init|;
condition|;
control|)
block|{
name|fromlen
operator|=
name|S_AD_SZ
expr_stmt|;
name|n
operator|=
name|recvfrom
argument_list|(
name|f
argument_list|,
name|pkt
operator|->
name|dat
argument_list|,
name|MAX_PKT_LEN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|pkt
operator|->
name|length
operator|=
name|n
expr_stmt|;
name|pkt
operator|->
name|mbz
operator|=
literal|0
expr_stmt|;
comment|/* force zeros to catch runaway strings */
comment|/* see what is left in the input queue */
name|ioctl
argument_list|(
name|f
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|q_bytes
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|kerb_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|q_n
operator|++
expr_stmt|;
name|max_q_n
operator|=
name|max
argument_list|(
name|max_q_n
argument_list|,
name|q_n
argument_list|)
expr_stmt|;
name|n_packets
operator|++
expr_stmt|;
name|klog
argument_list|(
name|L_NET_INFO
argument_list|,
literal|"q_byt %d, q_n %d, rd_byt %d, mx_q_b %d, mx_q_n %d, n_pkt %d"
argument_list|,
name|q_bytes
argument_list|,
name|q_n
argument_list|,
name|n
argument_list|,
name|max_q_bytes
argument_list|,
name|max_q_n
argument_list|,
name|n_packets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|max_q_bytes
operator|=
name|max
argument_list|(
name|max_q_bytes
argument_list|,
name|q_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|q_bytes
condition|)
name|q_n
operator|=
literal|0
expr_stmt|;
comment|/* reset consecutive packets */
name|kerberos
argument_list|(
operator|&
name|from
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
else|else
name|klog
argument_list|(
name|L_NET_ERR
argument_list|,
literal|"%s: bad recvfrom n = %d errno = %d"
argument_list|,
name|progname
argument_list|,
name|n
argument_list|,
name|errno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|kerberos
parameter_list|(
name|client
parameter_list|,
name|pkt
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|client
decl_stmt|;
name|KTEXT
name|pkt
decl_stmt|;
block|{
specifier|static
name|KTEXT_ST
name|rpkt_st
decl_stmt|;
name|KTEXT
name|rpkt
init|=
operator|&
name|rpkt_st
decl_stmt|;
specifier|static
name|KTEXT_ST
name|ciph_st
decl_stmt|;
name|KTEXT
name|ciph
init|=
operator|&
name|ciph_st
decl_stmt|;
specifier|static
name|KTEXT_ST
name|tk_st
decl_stmt|;
name|KTEXT
name|tk
init|=
operator|&
name|tk_st
decl_stmt|;
specifier|static
name|KTEXT_ST
name|auth_st
decl_stmt|;
name|KTEXT
name|auth
init|=
operator|&
name|auth_st
decl_stmt|;
name|AUTH_DAT
name|ad_st
decl_stmt|;
name|AUTH_DAT
modifier|*
name|ad
init|=
operator|&
name|ad_st
decl_stmt|;
specifier|static
name|struct
name|in_addr
name|client_host
decl_stmt|;
specifier|static
name|int
name|msg_byte_order
decl_stmt|;
specifier|static
name|u_char
name|k_flags
decl_stmt|;
name|u_long
name|lifetime
decl_stmt|;
name|int
name|i
decl_stmt|;
name|C_Block
name|key
decl_stmt|;
name|Key_schedule
name|key_s
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|lifetime
operator|=
name|DEFAULT_TKT_LIFE
expr_stmt|;
name|ciph
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|client_host
operator|=
name|client
operator|->
name|sin_addr
expr_stmt|;
comment|/* eval macros and correct the byte order and alignment as needed */
name|req_version
operator|=
name|pkt_version
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* 1 byte, version */
name|req_msg_type
operator|=
name|pkt_msg_type
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
comment|/* 1 byte, Kerberos msg type */
name|req_act_vno
operator|=
name|req_version
expr_stmt|;
comment|/* check packet version */
if|if
condition|(
name|req_version
operator|!=
name|KRB_PROT_VERSION
condition|)
block|{
name|lt
operator|=
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"KRB prot version mismatch: KRB =%d request = %d"
argument_list|,
name|KRB_PROT_VERSION
argument_list|,
name|req_version
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* send an error reply */
name|kerb_err_reply
argument_list|(
name|client
argument_list|,
name|pkt
argument_list|,
name|KERB_ERR_PKT_VER
argument_list|,
name|lt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* set up and correct for byte order and alignment */
name|req_name_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|pkt_a_name
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|req_inst_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|pkt_a_inst
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|req_realm_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|pkt_a_realm
argument_list|(
name|pkt
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|pkt_time_ws
argument_list|(
name|pkt
argument_list|)
argument_list|,
operator|&
name|req_time_ws
argument_list|,
sizeof|sizeof
argument_list|(
name|req_time_ws
argument_list|)
argument_list|)
expr_stmt|;
name|msg_byte_order
operator|=
name|req_msg_type
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|msg_byte_order
operator|!=
name|HOST_BYTE_ORDER
condition|)
block|{
name|swap_u_long
argument_list|(
argument|req_time_ws
argument_list|)
block|}
name|klog
argument_list|(
name|L_KRB_PINFO
argument_list|,
literal|"Prot version: %d, Byte order: %d, Message type: %d"
argument_list|,
name|req_version
argument_list|,
name|msg_byte_order
argument_list|,
name|req_msg_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|req_msg_type
operator|&
operator|~
literal|1
condition|)
block|{
case|case
name|AUTH_MSG_KDC_REQUEST
case|:
block|{
name|u_long
name|req_life
decl_stmt|;
comment|/* Requested liftime */
name|char
modifier|*
name|service
decl_stmt|;
comment|/* Service name */
name|char
modifier|*
name|instance
decl_stmt|;
comment|/* Service instance */
name|n_auth_req
operator|++
expr_stmt|;
name|tk
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|k_flags
operator|=
literal|0
expr_stmt|;
comment|/* various kerberos flags */
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|pkt_time_ws
argument_list|(
name|pkt
argument_list|)
operator|+
literal|4
expr_stmt|;
name|req_life
operator|=
call|(
name|u_long
call|)
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|service
operator|=
name|ptr
expr_stmt|;
name|instance
operator|=
name|ptr
operator|+
name|strlen
argument_list|(
name|service
argument_list|)
operator|+
literal|1
expr_stmt|;
name|rpkt
operator|=
operator|&
name|rpkt_st
expr_stmt|;
name|klog
argument_list|(
name|L_INI_REQ
argument_list|,
literal|"Initial ticket request Host: %s User: \"%s\" \"%s\""
argument_list|,
name|inet_ntoa
argument_list|(
name|client_host
argument_list|)
argument_list|,
name|req_name_ptr
argument_list|,
name|req_inst_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|check_princ
argument_list|(
name|req_name_ptr
argument_list|,
name|req_inst_ptr
argument_list|,
literal|0
argument_list|,
operator|&
name|a_name_data
argument_list|)
operator|)
condition|)
block|{
name|kerb_err_reply
argument_list|(
name|client
argument_list|,
name|pkt
argument_list|,
name|i
argument_list|,
name|lt
argument_list|)
expr_stmt|;
return|return;
block|}
name|tk
operator|->
name|length
operator|=
literal|0
expr_stmt|;
comment|/* init */
if|if
condition|(
name|strcmp
argument_list|(
name|service
argument_list|,
literal|"krbtgt"
argument_list|)
condition|)
name|klog
argument_list|(
name|L_NTGT_INTK
argument_list|,
literal|"INITIAL request from %s.%s for %s.%s"
argument_list|,
name|req_name_ptr
argument_list|,
name|req_inst_ptr
argument_list|,
name|service
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* this does all the checking */
if|if
condition|(
operator|(
name|i
operator|=
name|check_princ
argument_list|(
name|service
argument_list|,
name|instance
argument_list|,
name|lifetime
argument_list|,
operator|&
name|s_name_data
argument_list|)
operator|)
condition|)
block|{
name|kerb_err_reply
argument_list|(
name|client
argument_list|,
name|pkt
argument_list|,
name|i
argument_list|,
name|lt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Bound requested lifetime with service and user */
name|lifetime
operator|=
name|min
argument_list|(
name|req_life
argument_list|,
operator|(
operator|(
name|u_long
operator|)
name|s_name_data
operator|.
name|max_life
operator|)
argument_list|)
expr_stmt|;
name|lifetime
operator|=
name|min
argument_list|(
name|lifetime
argument_list|,
operator|(
operator|(
name|u_long
operator|)
name|a_name_data
operator|.
name|max_life
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOENCRYPTION
name|bzero
argument_list|(
name|session_key
argument_list|,
sizeof|sizeof
argument_list|(
name|C_Block
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|des_new_random_key
argument_list|(
name|session_key
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* unseal server's key from master key */
name|bcopy
argument_list|(
operator|&
name|s_name_data
operator|.
name|key_low
argument_list|,
name|key
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|s_name_data
operator|.
name|key_high
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
name|key
operator|)
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|kdb_encrypt_key
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|DECRYPT
argument_list|)
expr_stmt|;
comment|/* construct and seal the ticket */
name|krb_create_ticket
argument_list|(
name|tk
argument_list|,
name|k_flags
argument_list|,
name|a_name_data
operator|.
name|name
argument_list|,
name|a_name_data
operator|.
name|instance
argument_list|,
name|local_realm
argument_list|,
name|client_host
operator|.
name|s_addr
argument_list|,
name|session_key
argument_list|,
name|lifetime
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
name|s_name_data
operator|.
name|name
argument_list|,
name|s_name_data
operator|.
name|instance
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|key_s
argument_list|,
sizeof|sizeof
argument_list|(
name|key_s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     * get the user's key, unseal it from the server's key, and 	     * use it to seal the cipher 	     */
comment|/* a_name_data.key_low a_name_data.key_high */
name|bcopy
argument_list|(
operator|&
name|a_name_data
operator|.
name|key_low
argument_list|,
name|key
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|a_name_data
operator|.
name|key_high
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
name|key
operator|)
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* unseal the a_name key from the master key */
name|kdb_encrypt_key
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|DECRYPT
argument_list|)
expr_stmt|;
name|create_ciph
argument_list|(
name|ciph
argument_list|,
name|session_key
argument_list|,
name|s_name_data
operator|.
name|name
argument_list|,
name|s_name_data
operator|.
name|instance
argument_list|,
name|local_realm
argument_list|,
name|lifetime
argument_list|,
name|s_name_data
operator|.
name|key_version
argument_list|,
name|tk
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* clear session key */
name|bzero
argument_list|(
name|session_key
argument_list|,
sizeof|sizeof
argument_list|(
name|session_key
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
comment|/* always send a reply packet */
name|rpkt
operator|=
name|create_auth_reply
argument_list|(
name|req_name_ptr
argument_list|,
name|req_inst_ptr
argument_list|,
name|req_realm_ptr
argument_list|,
name|req_time_ws
argument_list|,
literal|0
argument_list|,
name|a_name_data
operator|.
name|exp_date
argument_list|,
name|a_name_data
operator|.
name|key_version
argument_list|,
name|ciph
argument_list|)
expr_stmt|;
name|sendto
argument_list|(
name|f
argument_list|,
name|rpkt
operator|->
name|dat
argument_list|,
name|rpkt
operator|->
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|client
argument_list|,
name|S_AD_SZ
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|a_name_data
argument_list|,
sizeof|sizeof
argument_list|(
name|a_name_data
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|s_name_data
argument_list|,
sizeof|sizeof
argument_list|(
name|s_name_data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AUTH_MSG_APPL_REQUEST
case|:
block|{
name|u_long
name|time_ws
decl_stmt|;
comment|/* Workstation time */
name|u_long
name|req_life
decl_stmt|;
comment|/* Requested liftime */
name|char
modifier|*
name|service
decl_stmt|;
comment|/* Service name */
name|char
modifier|*
name|instance
decl_stmt|;
comment|/* Service instance */
name|int
name|kerno
decl_stmt|;
comment|/* Kerberos error number */
name|char
name|tktrlm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|n_appl_req
operator|++
expr_stmt|;
name|tk
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|k_flags
operator|=
literal|0
expr_stmt|;
comment|/* various kerberos flags */
name|kerno
operator|=
name|KSUCCESS
expr_stmt|;
name|auth
operator|->
name|length
operator|=
literal|4
operator|+
name|strlen
argument_list|(
name|pkt
operator|->
name|dat
operator|+
literal|3
argument_list|)
expr_stmt|;
name|auth
operator|->
name|length
operator|+=
operator|(
name|int
operator|)
operator|*
operator|(
name|pkt
operator|->
name|dat
operator|+
name|auth
operator|->
name|length
operator|)
operator|+
operator|(
name|int
operator|)
operator|*
operator|(
name|pkt
operator|->
name|dat
operator|+
name|auth
operator|->
name|length
operator|+
literal|1
operator|)
operator|+
literal|2
expr_stmt|;
name|bcopy
argument_list|(
name|pkt
operator|->
name|dat
argument_list|,
name|auth
operator|->
name|dat
argument_list|,
name|auth
operator|->
name|length
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tktrlm
argument_list|,
name|auth
operator|->
name|dat
operator|+
literal|3
argument_list|,
name|REALM_SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_tgtkey
argument_list|(
name|tktrlm
argument_list|)
condition|)
block|{
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_UNK
argument_list|,
literal|"FAILED realm %s unknown. Host: %s "
argument_list|,
name|tktrlm
argument_list|,
name|inet_ntoa
argument_list|(
name|client_host
argument_list|)
argument_list|)
expr_stmt|;
name|kerb_err_reply
argument_list|(
name|client
argument_list|,
name|pkt
argument_list|,
name|kerno
argument_list|,
name|lt
argument_list|)
expr_stmt|;
return|return;
block|}
name|kerno
operator|=
name|krb_rd_req
argument_list|(
name|auth
argument_list|,
literal|"ktbtgt"
argument_list|,
name|tktrlm
argument_list|,
name|client_host
operator|.
name|s_addr
argument_list|,
name|ad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerno
condition|)
block|{
name|klog
argument_list|(
name|L_ERR_UNK
argument_list|,
literal|"FAILED krb_rd_req from %s: %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|client_host
argument_list|)
argument_list|,
name|krb_err_txt
index|[
name|kerno
index|]
argument_list|)
expr_stmt|;
name|kerb_err_reply
argument_list|(
name|client
argument_list|,
name|pkt
argument_list|,
name|kerno
argument_list|,
literal|"krb_rd_req failed"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|pkt
operator|->
name|dat
operator|+
name|auth
operator|->
name|length
expr_stmt|;
name|bcopy
argument_list|(
name|ptr
argument_list|,
operator|&
name|time_ws
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ptr
operator|+=
literal|4
expr_stmt|;
name|req_life
operator|=
call|(
name|u_long
call|)
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|service
operator|=
name|ptr
expr_stmt|;
name|instance
operator|=
name|ptr
operator|+
name|strlen
argument_list|(
name|service
argument_list|)
operator|+
literal|1
expr_stmt|;
name|klog
argument_list|(
name|L_APPL_REQ
argument_list|,
literal|"APPL Request %s.%s@%s on %s for %s.%s"
argument_list|,
name|ad
operator|->
name|pname
argument_list|,
name|ad
operator|->
name|pinst
argument_list|,
name|ad
operator|->
name|prealm
argument_list|,
name|inet_ntoa
argument_list|(
name|client_host
argument_list|)
argument_list|,
name|service
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ad
operator|->
name|prealm
argument_list|,
name|tktrlm
argument_list|)
condition|)
block|{
name|kerb_err_reply
argument_list|(
name|client
argument_list|,
name|pkt
argument_list|,
name|KERB_ERR_PRINCIPAL_UNKNOWN
argument_list|,
literal|"Can't hop realms"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|service
argument_list|,
literal|"changepw"
argument_list|)
condition|)
block|{
name|kerb_err_reply
argument_list|(
name|client
argument_list|,
name|pkt
argument_list|,
name|KERB_ERR_PRINCIPAL_UNKNOWN
argument_list|,
literal|"Can't authorize password changed based on TGT"
argument_list|)
expr_stmt|;
return|return;
block|}
name|kerno
operator|=
name|check_princ
argument_list|(
name|service
argument_list|,
name|instance
argument_list|,
name|req_life
argument_list|,
operator|&
name|s_name_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|kerno
condition|)
block|{
name|kerb_err_reply
argument_list|(
name|client
argument_list|,
name|pkt
argument_list|,
name|kerno
argument_list|,
name|lt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Bound requested lifetime with service and user */
name|lifetime
operator|=
name|min
argument_list|(
name|req_life
argument_list|,
operator|(
name|ad
operator|->
name|life
operator|-
operator|(
operator|(
name|kerb_time
operator|.
name|tv_sec
operator|-
name|ad
operator|->
name|time_sec
operator|)
operator|/
literal|300
operator|)
operator|)
argument_list|)
expr_stmt|;
name|lifetime
operator|=
name|min
argument_list|(
name|lifetime
argument_list|,
operator|(
operator|(
name|u_long
operator|)
name|s_name_data
operator|.
name|max_life
operator|)
argument_list|)
expr_stmt|;
comment|/* unseal server's key from master key */
name|bcopy
argument_list|(
operator|&
name|s_name_data
operator|.
name|key_low
argument_list|,
name|key
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|s_name_data
operator|.
name|key_high
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
name|key
operator|)
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|kdb_encrypt_key
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|DECRYPT
argument_list|)
expr_stmt|;
comment|/* construct and seal the ticket */
ifdef|#
directive|ifdef
name|NOENCRYPTION
name|bzero
argument_list|(
name|session_key
argument_list|,
sizeof|sizeof
argument_list|(
name|C_Block
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|des_new_random_key
argument_list|(
name|session_key
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|krb_create_ticket
argument_list|(
name|tk
argument_list|,
name|k_flags
argument_list|,
name|ad
operator|->
name|pname
argument_list|,
name|ad
operator|->
name|pinst
argument_list|,
name|ad
operator|->
name|prealm
argument_list|,
name|client_host
operator|.
name|s_addr
argument_list|,
name|session_key
argument_list|,
name|lifetime
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
name|s_name_data
operator|.
name|name
argument_list|,
name|s_name_data
operator|.
name|instance
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|key_s
argument_list|,
sizeof|sizeof
argument_list|(
name|key_s
argument_list|)
argument_list|)
expr_stmt|;
name|create_ciph
argument_list|(
name|ciph
argument_list|,
name|session_key
argument_list|,
name|service
argument_list|,
name|instance
argument_list|,
name|local_realm
argument_list|,
name|lifetime
argument_list|,
name|s_name_data
operator|.
name|key_version
argument_list|,
name|tk
argument_list|,
name|kerb_time
operator|.
name|tv_sec
argument_list|,
name|ad
operator|->
name|session
argument_list|)
expr_stmt|;
comment|/* clear session key */
name|bzero
argument_list|(
name|session_key
argument_list|,
sizeof|sizeof
argument_list|(
name|session_key
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ad
operator|->
name|session
argument_list|,
sizeof|sizeof
argument_list|(
name|ad
operator|->
name|session
argument_list|)
argument_list|)
expr_stmt|;
name|rpkt
operator|=
name|create_auth_reply
argument_list|(
name|ad
operator|->
name|pname
argument_list|,
name|ad
operator|->
name|pinst
argument_list|,
name|ad
operator|->
name|prealm
argument_list|,
name|time_ws
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ciph
argument_list|)
expr_stmt|;
name|sendto
argument_list|(
name|f
argument_list|,
name|rpkt
operator|->
name|dat
argument_list|,
name|rpkt
operator|->
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|client
argument_list|,
name|S_AD_SZ
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|s_name_data
argument_list|,
sizeof|sizeof
argument_list|(
name|s_name_data
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|notdef_DIE
case|case
name|AUTH_MSG_DIE
case|:
block|{
name|lt
operator|=
name|klog
argument_list|(
name|L_DEATH_REQ
argument_list|,
literal|"Host: %s User: \"%s\" \"%s\" Kerberos killed"
argument_list|,
name|inet_ntoa
argument_list|(
name|client_host
argument_list|)
argument_list|,
name|req_name_ptr
argument_list|,
name|req_inst_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|notdef_DIE
default|default:
block|{
name|lt
operator|=
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Unknown message type: %d from %s port %u"
argument_list|,
name|req_msg_type
argument_list|,
name|inet_ntoa
argument_list|(
name|client_host
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|client
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * setup_disc  *  * disconnect all descriptors, remove ourself from the process  * group that spawned us.  */
end_comment

begin_function
name|void
name|setup_disc
parameter_list|()
block|{
name|int
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|3
condition|;
name|s
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|s
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>=
literal|0
condition|)
block|{
name|ioctl
argument_list|(
name|s
argument_list|,
name|TIOCNOTTY
argument_list|,
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|chdir
argument_list|(
literal|"/tmp"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * kerb_er_reply creates an error reply packet and sends it to the  * client.  */
end_comment

begin_function
name|void
name|kerb_err_reply
parameter_list|(
name|client
parameter_list|,
name|pkt
parameter_list|,
name|err
parameter_list|,
name|string
parameter_list|)
name|struct
name|sockaddr_in
modifier|*
name|client
decl_stmt|;
name|KTEXT
name|pkt
decl_stmt|;
name|long
name|err
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|static
name|KTEXT_ST
name|e_pkt_st
decl_stmt|;
name|KTEXT
name|e_pkt
init|=
operator|&
name|e_pkt_st
decl_stmt|;
specifier|static
name|char
name|e_msg
index|[
literal|128
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|e_msg
argument_list|,
literal|"\nKerberos error -- "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|e_msg
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|cr_err_reply
argument_list|(
name|e_pkt
argument_list|,
name|req_name_ptr
argument_list|,
name|req_inst_ptr
argument_list|,
name|req_realm_ptr
argument_list|,
name|req_time_ws
argument_list|,
name|err
argument_list|,
name|e_msg
argument_list|)
expr_stmt|;
name|sendto
argument_list|(
name|f
argument_list|,
name|e_pkt
operator|->
name|dat
argument_list|,
name|e_pkt
operator|->
name|length
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|client
argument_list|,
name|S_AD_SZ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make sure that database isn't stale.  *  * Exit if it is; we don't want to tell lies.  */
end_comment

begin_function
specifier|static
name|void
name|check_db_age
parameter_list|()
block|{
name|long
name|age
decl_stmt|;
if|if
condition|(
name|max_age
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Requires existance of kerb_get_db_age() */
name|gettimeofday
argument_list|(
operator|&
name|kerb_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|age
operator|=
name|kerb_get_db_age
argument_list|()
expr_stmt|;
if|if
condition|(
name|age
operator|==
literal|0
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Database currently being updated!"
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|age
operator|+
name|max_age
operator|)
operator|<
name|kerb_time
operator|.
name|tv_sec
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Database out of date!"
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
block|}
end_function

begin_function
name|int
name|check_princ
parameter_list|(
name|p_name
parameter_list|,
name|instance
parameter_list|,
name|lifetime
parameter_list|,
name|p
parameter_list|)
name|char
modifier|*
name|p_name
decl_stmt|;
name|char
modifier|*
name|instance
decl_stmt|;
name|unsigned
name|lifetime
decl_stmt|;
name|Principal
modifier|*
name|p
decl_stmt|;
block|{
specifier|static
name|int
name|n
decl_stmt|;
specifier|static
name|int
name|more
decl_stmt|;
name|n
operator|=
name|kerb_get_principal
argument_list|(
name|p_name
argument_list|,
name|instance
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
name|klog
argument_list|(
name|L_ALL_REQ
argument_list|,
literal|"Principal: \"%s\", Instance: \"%s\" Lifetime = %d n = %d"
argument_list|,
name|p_name
argument_list|,
name|instance
argument_list|,
name|lifetime
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|lt
operator|=
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Database unavailable!"
argument_list|)
expr_stmt|;
name|hang
argument_list|()
expr_stmt|;
block|}
comment|/*      * if more than one p_name, pick one, randomly create a session key,      * compute maximum lifetime, lookup authorizations if applicable,      * and stuff into cipher.      */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* service unknown, log error, skip to next request */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_UNK
argument_list|,
literal|"UNKNOWN \"%s\" \"%s\""
argument_list|,
name|p_name
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PRINCIPAL_UNKNOWN
return|;
block|}
if|if
condition|(
name|more
condition|)
block|{
comment|/* not unique, log error */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_NUN
argument_list|,
literal|"Principal NOT UNIQUE \"%s\" \"%s\""
argument_list|,
name|p_name
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_PRINCIPAL_NOT_UNIQUE
return|;
block|}
comment|/* If the user's key is null, we want to return an error */
if|if
condition|(
operator|(
name|p
operator|->
name|key_low
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|key_high
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* User has a null key */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_NKY
argument_list|,
literal|"Null key \"%s\" \"%s\""
argument_list|,
name|p_name
argument_list|,
name|instance
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_NULL_KEY
return|;
block|}
if|if
condition|(
name|master_key_version
operator|!=
name|p
operator|->
name|kdc_key_ver
condition|)
block|{
comment|/* log error reply */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_MKV
argument_list|,
literal|"Key vers incorrect, KRB = %d, \"%s\" \"%s\" = %d"
argument_list|,
name|master_key_version
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|instance
argument_list|,
name|p
operator|->
name|kdc_key_ver
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_NAME_MAST_KEY_VER
return|;
block|}
comment|/* make sure the service hasn't expired */
if|if
condition|(
operator|(
name|u_long
operator|)
name|p
operator|->
name|exp_date
operator|<
operator|(
name|u_long
operator|)
name|kerb_time
operator|.
name|tv_sec
condition|)
block|{
comment|/* service did expire, log it */
name|lt
operator|=
name|klog
argument_list|(
name|L_ERR_SEXP
argument_list|,
literal|"EXPIRED \"%s\" \"%s\"  %s"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|instance
argument_list|,
name|stime
argument_list|(
operator|&
operator|(
name|p
operator|->
name|exp_date
operator|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|KERB_ERR_NAME_EXP
return|;
block|}
comment|/* ok is zero */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set the key for krb_rd_req so we can check tgt */
end_comment

begin_function
name|int
name|set_tgtkey
parameter_list|(
name|r
parameter_list|)
name|char
modifier|*
name|r
decl_stmt|;
comment|/* Realm for desired key */
block|{
name|int
name|n
decl_stmt|;
specifier|static
name|char
name|lastrealm
index|[
name|REALM_SZ
index|]
decl_stmt|;
name|Principal
name|p_st
decl_stmt|;
name|Principal
modifier|*
name|p
init|=
operator|&
name|p_st
decl_stmt|;
name|C_Block
name|key
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|lastrealm
argument_list|,
name|r
argument_list|)
condition|)
return|return
operator|(
name|KSUCCESS
operator|)
return|;
name|log
argument_list|(
literal|"Getting key for %s"
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|n
operator|=
name|kerb_get_principal
argument_list|(
literal|"krbtgt"
argument_list|,
name|r
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|KFAILURE
operator|)
return|;
comment|/* unseal tgt key from master key */
name|bcopy
argument_list|(
operator|&
name|p
operator|->
name|key_low
argument_list|,
name|key
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|p
operator|->
name|key_high
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
name|key
operator|)
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|kdb_encrypt_key
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|DECRYPT
argument_list|)
expr_stmt|;
name|krb_set_key
argument_list|(
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lastrealm
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|KSUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hang
parameter_list|()
block|{
if|if
condition|(
name|pause_int
operator|==
operator|-
literal|1
condition|)
block|{
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Kerberos will pause so as not to loop init"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
name|pause
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Kerberos will wait %ld seconds before dying so as not to loop init"
argument_list|,
name|pause_int
argument_list|)
expr_stmt|;
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
name|pause_int
argument_list|)
expr_stmt|;
name|klog
argument_list|(
name|L_KRB_PERR
argument_list|,
literal|"Do svedania....\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

