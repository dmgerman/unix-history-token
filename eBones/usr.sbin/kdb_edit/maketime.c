begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1990 by the Massachusetts Institute of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  * Convert a struct tm * to a UNIX time.  *  *	from: maketime.c,v 4.2 90/01/09 15:54:51 raeburn Exp $  * $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char rcsid[] = "$Id: maketime.c,v 1.1 1994/03/21 16:23:54 piero Exp ";
endif|#
directive|endif
endif|lint
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_define
define|#
directive|define
name|daysinyear
parameter_list|(
name|y
parameter_list|)
value|(((y) % 4) ? 365 : (((y) % 100) ? 366 : (((y) % 400) ? 365 : 366)))
end_define

begin_define
define|#
directive|define
name|SECSPERDAY
value|24*60*60
end_define

begin_define
define|#
directive|define
name|SECSPERHOUR
value|60*60
end_define

begin_define
define|#
directive|define
name|SECSPERMIN
value|60
end_define

begin_decl_stmt
specifier|static
name|int
name|cumdays
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|59
block|,
literal|90
block|,
literal|120
block|,
literal|151
block|,
literal|181
block|,
literal|212
block|,
literal|243
block|,
literal|273
block|,
literal|304
block|,
literal|334
block|,
literal|365
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|leapyear
index|[]
init|=
block|{
literal|31
block|,
literal|29
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonleapyear
index|[]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|maketime
parameter_list|(
name|tp
parameter_list|,
name|local
parameter_list|)
specifier|register
name|struct
name|tm
modifier|*
name|tp
decl_stmt|;
name|int
name|local
decl_stmt|;
block|{
specifier|register
name|long
name|retval
decl_stmt|;
name|int
name|foo
decl_stmt|;
name|int
modifier|*
name|marray
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|tm_mon
operator|<
literal|0
operator|||
name|tp
operator|->
name|tm_mon
operator|>
literal|11
operator|||
name|tp
operator|->
name|tm_hour
operator|<
literal|0
operator|||
name|tp
operator|->
name|tm_hour
operator|>
literal|23
operator|||
name|tp
operator|->
name|tm_min
operator|<
literal|0
operator|||
name|tp
operator|->
name|tm_min
operator|>
literal|59
operator|||
name|tp
operator|->
name|tm_sec
operator|<
literal|0
operator|||
name|tp
operator|->
name|tm_sec
operator|>
literal|59
condition|)
comment|/* out of range */
return|return
literal|0
return|;
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tm_year
operator|<
literal|1900
condition|)
name|foo
operator|=
name|tp
operator|->
name|tm_year
operator|+
literal|1900
expr_stmt|;
else|else
name|foo
operator|=
name|tp
operator|->
name|tm_year
expr_stmt|;
if|if
condition|(
name|foo
operator|<
literal|1901
operator|||
name|foo
operator|>
literal|2038
condition|)
comment|/* year is too small/large */
return|return
literal|0
return|;
if|if
condition|(
name|daysinyear
argument_list|(
name|foo
argument_list|)
operator|==
literal|366
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|tm_mon
operator|>
literal|1
condition|)
name|retval
operator|+=
name|SECSPERDAY
expr_stmt|;
comment|/* add leap day */
name|marray
operator|=
name|leapyear
expr_stmt|;
block|}
else|else
name|marray
operator|=
name|nonleapyear
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tm_mday
operator|<
literal|0
operator|||
name|tp
operator|->
name|tm_mday
operator|>
name|marray
index|[
name|tp
operator|->
name|tm_mon
index|]
condition|)
return|return
literal|0
return|;
comment|/* out of range */
while|while
condition|(
operator|--
name|foo
operator|>=
literal|1970
condition|)
name|retval
operator|+=
name|daysinyear
argument_list|(
name|foo
argument_list|)
operator|*
name|SECSPERDAY
expr_stmt|;
name|retval
operator|+=
name|cumdays
index|[
name|tp
operator|->
name|tm_mon
index|]
operator|*
name|SECSPERDAY
expr_stmt|;
name|retval
operator|+=
operator|(
name|tp
operator|->
name|tm_mday
operator|-
literal|1
operator|)
operator|*
name|SECSPERDAY
expr_stmt|;
name|retval
operator|+=
name|tp
operator|->
name|tm_hour
operator|*
name|SECSPERHOUR
operator|+
name|tp
operator|->
name|tm_min
operator|*
name|SECSPERMIN
operator|+
name|tp
operator|->
name|tm_sec
expr_stmt|;
if|if
condition|(
name|local
condition|)
block|{
comment|/* need to use local time, so we retrieve timezone info */
name|struct
name|timezone
name|tz
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tz
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* some error--give up? */
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|retval
operator|+=
name|tz
operator|.
name|tz_minuteswest
operator|*
name|SECSPERMIN
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

end_unit

