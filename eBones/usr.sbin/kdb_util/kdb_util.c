begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1987, 1988 by the Massachusetts Institute of Technology.  * For copying and distribution information, please see the file  *<Copyright.MIT>.  *  * Kerberos database manipulation utility. This program allows you to  * dump a kerberos database to an ascii readable file and load this  * file into the database. Read locking of the database is done during a  * dump operation. NO LOCKING is done during a load operation. Loads  * should happen with other processes shutdown.  *  * Written July 9, 1987 by Jeffrey I. Schiller  *  *	from: kdb_util.c,v 4.4 90/01/09 15:57:20 raeburn Exp $  * $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char rcsid[] = "$FreeBSD$";
endif|#
directive|endif
endif|lint
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<des.h>
end_include

begin_include
include|#
directive|include
file|<krb.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<krb_db.h>
end_include

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_decl_stmt
name|Principal
name|aprinc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|des_cblock
name|master_key
decl_stmt|,
name|new_master_key
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|des_key_schedule
name|master_key_schedule
decl_stmt|,
name|new_master_key_schedule
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|zaptime
parameter_list|(
name|foo
parameter_list|)
value|bzero((char *)(foo), sizeof(*(foo)))
end_define

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|convert_old_format_db
parameter_list|(
name|char
modifier|*
name|db_file
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|convert_new_master_key
parameter_list|(
name|char
modifier|*
name|db_file
parameter_list|,
name|FILE
modifier|*
name|out
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|update_ok_file
parameter_list|(
name|char
modifier|*
name|file_name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|print_time
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|long
name|timeval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|load_db
parameter_list|(
name|char
modifier|*
name|db_file
parameter_list|,
name|FILE
modifier|*
name|input_file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dump_db
parameter_list|(
name|char
modifier|*
name|db_file
parameter_list|,
name|FILE
modifier|*
name|output_file
parameter_list|,
name|void
function_decl|(
modifier|*
name|cv_key
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
enum|enum
block|{
name|OP_LOAD
block|,
name|OP_DUMP
block|,
name|OP_SLAVE_DUMP
block|,
name|OP_NEW_MASTER
block|,
name|OP_CONVERT_OLD_DB
block|,     }
name|op
enum|;
name|char
modifier|*
name|file_name
decl_stmt|;
name|char
modifier|*
name|prog
init|=
name|argv
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|db_name
decl_stmt|;
name|progname
operator|=
name|prog
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
operator|&&
name|argc
operator|!=
literal|4
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s operation file-name [database name].\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|3
condition|)
name|db_name
operator|=
name|DBM_FILE
expr_stmt|;
else|else
name|db_name
operator|=
name|argv
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|kerb_db_set_name
argument_list|(
name|db_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"Can't open database"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"load"
argument_list|)
condition|)
name|op
operator|=
name|OP_LOAD
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"dump"
argument_list|)
condition|)
name|op
operator|=
name|OP_DUMP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"slave_dump"
argument_list|)
condition|)
name|op
operator|=
name|OP_SLAVE_DUMP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"new_master_key"
argument_list|)
condition|)
name|op
operator|=
name|OP_NEW_MASTER
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"convert_old_db"
argument_list|)
condition|)
name|op
operator|=
name|OP_CONVERT_OLD_DB
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is an invalid operation.\n"
argument_list|,
name|prog
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Valid operations are \"dump\", \"slave_dump\","
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\"load\", \"new_master_key\", and \"convert_old_db\".\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|file_name
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
name|file
operator|=
name|fopen
argument_list|(
name|file_name
argument_list|,
name|op
operator|==
name|OP_LOAD
condition|?
literal|"r"
else|:
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Unable to open %s\n"
argument_list|,
name|prog
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_DUMP
case|:
if|if
condition|(
operator|(
name|dump_db
argument_list|(
name|db_name
argument_list|,
name|file
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|)
operator|==
name|EOF
operator|)
operator|||
operator|(
name|fclose
argument_list|(
name|file
argument_list|)
operator|==
name|EOF
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error on file %s:"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_SLAVE_DUMP
case|:
if|if
condition|(
operator|(
name|dump_db
argument_list|(
name|db_name
argument_list|,
name|file
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
argument_list|)
operator|==
name|EOF
operator|)
operator|||
operator|(
name|fclose
argument_list|(
name|file
argument_list|)
operator|==
name|EOF
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error on file %s:"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|update_ok_file
argument_list|(
name|file_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LOAD
case|:
name|load_db
argument_list|(
name|db_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_NEW_MASTER
case|:
name|convert_new_master_key
argument_list|(
name|db_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Don't forget to do a `kdb_util load %s' to reload the database!\n"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_CONVERT_OLD_DB
case|:
name|convert_old_format_db
argument_list|(
name|db_name
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Don't forget to do a `kdb_util load %s' to reload the database!\n"
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
break|break;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|clear_secrets
parameter_list|()
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|master_key
argument_list|,
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|master_key_schedule
argument_list|,
sizeof|sizeof
argument_list|(
name|Key_schedule
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_master_key
argument_list|,
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_master_key_schedule
argument_list|,
sizeof|sizeof
argument_list|(
name|Key_schedule
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* cv_key is a procedure which takes a principle and changes its key,    either for a new method of encrypting the keys, or a new master key.    if cv_key is null no transformation of key is done (other than net byte    order). */
end_comment

begin_struct
struct|struct
name|callback_args
block|{
name|void
function_decl|(
modifier|*
name|cv_key
function_decl|)
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|output_file
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dump_db_1
parameter_list|(
name|arg
parameter_list|,
name|principal
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|Principal
modifier|*
name|principal
decl_stmt|;
block|{
comment|/* replace null strings with "*" */
name|struct
name|callback_args
modifier|*
name|a
init|=
operator|(
expr|struct
name|callback_args
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|principal
operator|->
name|instance
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|principal
operator|->
name|instance
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|principal
operator|->
name|instance
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|principal
operator|->
name|mod_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|principal
operator|->
name|mod_name
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|principal
operator|->
name|mod_name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|principal
operator|->
name|mod_instance
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|principal
operator|->
name|mod_instance
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|principal
operator|->
name|mod_instance
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|->
name|cv_key
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|a
operator|->
name|cv_key
call|)
argument_list|(
name|principal
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|a
operator|->
name|output_file
argument_list|,
literal|"%s %s %d %d %d %d %lx %lx"
argument_list|,
name|principal
operator|->
name|name
argument_list|,
name|principal
operator|->
name|instance
argument_list|,
name|principal
operator|->
name|max_life
argument_list|,
name|principal
operator|->
name|kdc_key_ver
argument_list|,
name|principal
operator|->
name|key_version
argument_list|,
name|principal
operator|->
name|attributes
argument_list|,
name|htonl
argument_list|(
name|principal
operator|->
name|key_low
argument_list|)
argument_list|,
name|htonl
argument_list|(
name|principal
operator|->
name|key_high
argument_list|)
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
name|a
operator|->
name|output_file
argument_list|,
name|principal
operator|->
name|exp_date
argument_list|)
expr_stmt|;
name|print_time
argument_list|(
name|a
operator|->
name|output_file
argument_list|,
name|principal
operator|->
name|mod_date
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|a
operator|->
name|output_file
argument_list|,
literal|" %s %s\n"
argument_list|,
name|principal
operator|->
name|mod_name
argument_list|,
name|principal
operator|->
name|mod_instance
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|int
name|dump_db
argument_list|(
name|db_file
argument_list|,
name|output_file
argument_list|,
name|cv_key
argument_list|)
name|char
modifier|*
name|db_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|output_file
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|cv_key
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|callback_args
name|a
decl_stmt|;
name|a
operator|.
name|cv_key
operator|=
name|cv_key
expr_stmt|;
name|a
operator|.
name|output_file
operator|=
name|output_file
expr_stmt|;
name|kerb_db_iterate
argument_list|(
name|dump_db_1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|a
argument_list|)
expr_stmt|;
return|return
name|fflush
argument_list|(
name|output_file
argument_list|)
return|;
block|}
end_block

begin_function
name|void
name|load_db
parameter_list|(
name|db_file
parameter_list|,
name|input_file
parameter_list|)
name|char
modifier|*
name|db_file
decl_stmt|;
name|FILE
modifier|*
name|input_file
decl_stmt|;
block|{
name|char
name|exp_date_str
index|[
literal|50
index|]
decl_stmt|;
name|char
name|mod_date_str
index|[
literal|50
index|]
decl_stmt|;
name|int
name|temp1
decl_stmt|,
name|temp2
decl_stmt|,
name|temp3
decl_stmt|;
name|long
name|time_explode
parameter_list|()
function_decl|;
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|temp_db_file
decl_stmt|;
name|temp1
operator|=
name|strlen
argument_list|(
name|db_file
argument_list|)
operator|+
literal|2
expr_stmt|;
name|temp_db_file
operator|=
name|malloc
argument_list|(
name|temp1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|temp_db_file
argument_list|,
name|db_file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|temp_db_file
argument_list|,
literal|"~"
argument_list|)
expr_stmt|;
comment|/* Create the database */
if|if
condition|(
operator|(
name|code
operator|=
name|kerb_db_create
argument_list|(
name|temp_db_file
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't create temp database %s: %s\n"
argument_list|,
name|temp_db_file
argument_list|,
name|sys_errlist
index|[
name|code
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|kerb_db_set_name
argument_list|(
name|temp_db_file
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* explicit break on eof from fscanf */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|aprinc
argument_list|,
sizeof|sizeof
argument_list|(
name|aprinc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fscanf
argument_list|(
name|input_file
argument_list|,
literal|"%s %s %d %d %d %hd %lx %lx %s %s %s %s\n"
argument_list|,
name|aprinc
operator|.
name|name
argument_list|,
name|aprinc
operator|.
name|instance
argument_list|,
operator|&
name|temp1
argument_list|,
operator|&
name|temp2
argument_list|,
operator|&
name|temp3
argument_list|,
operator|&
name|aprinc
operator|.
name|attributes
argument_list|,
operator|&
name|aprinc
operator|.
name|key_low
argument_list|,
operator|&
name|aprinc
operator|.
name|key_high
argument_list|,
name|exp_date_str
argument_list|,
name|mod_date_str
argument_list|,
name|aprinc
operator|.
name|mod_name
argument_list|,
name|aprinc
operator|.
name|mod_instance
argument_list|)
operator|==
name|EOF
condition|)
break|break;
name|aprinc
operator|.
name|key_low
operator|=
name|ntohl
argument_list|(
name|aprinc
operator|.
name|key_low
argument_list|)
expr_stmt|;
name|aprinc
operator|.
name|key_high
operator|=
name|ntohl
argument_list|(
name|aprinc
operator|.
name|key_high
argument_list|)
expr_stmt|;
name|aprinc
operator|.
name|max_life
operator|=
operator|(
name|unsigned
name|char
operator|)
name|temp1
expr_stmt|;
name|aprinc
operator|.
name|kdc_key_ver
operator|=
operator|(
name|unsigned
name|char
operator|)
name|temp2
expr_stmt|;
name|aprinc
operator|.
name|key_version
operator|=
operator|(
name|unsigned
name|char
operator|)
name|temp3
expr_stmt|;
name|aprinc
operator|.
name|exp_date
operator|=
name|time_explode
argument_list|(
name|exp_date_str
argument_list|)
expr_stmt|;
name|aprinc
operator|.
name|mod_date
operator|=
name|time_explode
argument_list|(
name|mod_date_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|aprinc
operator|.
name|instance
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|aprinc
operator|.
name|instance
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|aprinc
operator|.
name|mod_name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|aprinc
operator|.
name|mod_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|aprinc
operator|.
name|mod_instance
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|aprinc
operator|.
name|mod_instance
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|kerb_db_put_principal
argument_list|(
operator|&
name|aprinc
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Couldn't store %s.%s: %s; load aborted\n"
argument_list|,
name|aprinc
operator|.
name|name
argument_list|,
name|aprinc
operator|.
name|instance
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|code
operator|=
name|kerb_db_rename
argument_list|(
name|temp_db_file
argument_list|,
name|db_file
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|perror
argument_list|(
literal|"database rename failed"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|input_file
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_db_file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_time
parameter_list|(
name|file
parameter_list|,
name|timeval
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|unsigned
name|long
name|timeval
decl_stmt|;
block|{
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|struct
name|tm
modifier|*
name|gmtime
parameter_list|()
function_decl|;
name|tm
operator|=
name|gmtime
argument_list|(
operator|(
name|long
operator|*
operator|)
operator|&
name|timeval
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %04d%02d%02d%02d%02d"
argument_list|,
name|tm
operator|->
name|tm_year
operator|<
literal|1900
condition|?
name|tm
operator|->
name|tm_year
operator|+
literal|1900
else|:
name|tm
operator|->
name|tm_year
argument_list|,
name|tm
operator|->
name|tm_mon
operator|+
literal|1
argument_list|,
name|tm
operator|->
name|tm_mday
argument_list|,
name|tm
operator|->
name|tm_hour
argument_list|,
name|tm
operator|->
name|tm_min
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|update_ok_file
parameter_list|(
name|file_name
parameter_list|)
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
comment|/* handle slave locking/failure stuff */
name|char
modifier|*
name|file_ok
decl_stmt|;
name|int
name|fd
decl_stmt|;
specifier|static
name|char
name|ok
index|[]
init|=
literal|".dump_ok"
decl_stmt|;
if|if
condition|(
operator|(
name|file_ok
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|file_name
argument_list|)
operator|+
name|strlen
argument_list|(
name|ok
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"kdb_util: out of memory.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"malloc"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|file_ok
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|file_ok
argument_list|,
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|file_ok
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0400
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error creating 'ok' file, '%s'"
argument_list|,
name|file_ok
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|file_ok
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_key_new_master
parameter_list|(
name|p
parameter_list|)
name|Principal
modifier|*
name|p
decl_stmt|;
block|{
name|des_cblock
name|key
decl_stmt|;
comment|/* leave null keys alone */
if|if
condition|(
operator|(
name|p
operator|->
name|key_low
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|key_high
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* move current key to des_cblock for encryption, special case master key      since that's changing */
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|KERB_M_NAME
argument_list|,
name|ANAME_SZ
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|p
operator|->
name|instance
argument_list|,
name|KERB_M_INST
argument_list|,
name|INST_SZ
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_master_key
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|p
operator|->
name|key_version
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|key_low
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|key_high
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|*
operator|)
name|key
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|kdb_encrypt_key
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|DECRYPT
argument_list|)
expr_stmt|;
block|}
name|kdb_encrypt_key
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
name|new_master_key
argument_list|,
name|new_master_key_schedule
argument_list|,
name|ENCRYPT
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|key_low
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|*
operator|)
name|key
operator|)
operator|+
literal|1
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|key_high
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
comment|/* a little paranoia ... */
operator|(
name|p
operator|->
name|kdc_key_ver
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_new_master_key
parameter_list|(
name|db_file
parameter_list|,
name|out
parameter_list|)
name|char
modifier|*
name|db_file
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"\n\nEnter the CURRENT master key."
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdb_get_master_key
argument_list|(
name|TRUE
argument_list|,
name|master_key
argument_list|,
name|master_key_schedule
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"get_master_key: Couldn't get master key.\n"
argument_list|)
expr_stmt|;
name|clear_secrets
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kdb_verify_master_key
argument_list|(
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|stderr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|clear_secrets
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\nNow enter the NEW master key.  Do not forget it!!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdb_get_master_key
argument_list|(
name|TRUE
argument_list|,
name|new_master_key
argument_list|,
name|new_master_key_schedule
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"get_master_key: Couldn't get new master key.\n"
argument_list|)
expr_stmt|;
name|clear_secrets
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|dump_db
argument_list|(
name|db_file
argument_list|,
name|out
argument_list|,
name|convert_key_new_master
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_key_old_db
parameter_list|(
name|p
parameter_list|)
name|Principal
modifier|*
name|p
decl_stmt|;
block|{
name|des_cblock
name|key
decl_stmt|;
comment|/* leave null keys alone */
if|if
condition|(
operator|(
name|p
operator|->
name|key_low
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|key_high
operator|==
literal|0
operator|)
condition|)
return|return;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|key_low
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|key_high
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|*
operator|)
name|key
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
name|des_pcbc_encrypt
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|key
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|key
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|des_cblock
argument_list|)
argument_list|,
name|master_key_schedule
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|master_key_schedule
argument_list|,
name|DECRYPT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* make new key, new style */
name|kdb_encrypt_key
argument_list|(
name|key
argument_list|,
name|key
argument_list|,
name|master_key
argument_list|,
name|master_key_schedule
argument_list|,
name|ENCRYPT
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|key_low
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|*
operator|)
name|key
operator|)
operator|+
literal|1
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|p
operator|->
name|key_high
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
comment|/* a little paranoia ... */
block|}
end_function

begin_function
name|void
name|convert_old_format_db
parameter_list|(
name|db_file
parameter_list|,
name|out
parameter_list|)
name|char
modifier|*
name|db_file
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
block|{
name|des_cblock
name|key_from_db
decl_stmt|;
name|Principal
name|principal_data
index|[
literal|1
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|more
decl_stmt|;
if|if
condition|(
name|kdb_get_master_key
argument_list|(
name|TRUE
argument_list|,
name|master_key
argument_list|,
name|master_key_schedule
argument_list|)
operator|!=
literal|0L
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"verify_master_key: Couldn't get master key.\n"
argument_list|)
expr_stmt|;
name|clear_secrets
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* can't call kdb_verify_master_key because this is an old style db */
comment|/* lookup the master key version */
name|n
operator|=
name|kerb_get_principal
argument_list|(
name|KERB_M_NAME
argument_list|,
name|KERB_M_INST
argument_list|,
name|principal_data
argument_list|,
literal|1
comment|/* only one please */
argument_list|,
operator|&
name|more
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|!=
literal|1
operator|)
operator|||
name|more
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"verify_master_key: "
literal|"Kerberos error on master key lookup, %d found.\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* set up the master key */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Current Kerberos master key version is %d.\n"
argument_list|,
name|principal_data
index|[
literal|0
index|]
operator|.
name|kdc_key_ver
argument_list|)
expr_stmt|;
comment|/*    * now use the master key to decrypt (old style) the key in the db, had better    * be the same!    */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|principal_data
index|[
literal|0
index|]
operator|.
name|key_low
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key_from_db
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|principal_data
index|[
literal|0
index|]
operator|.
name|key_high
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|long
operator|*
operator|)
name|key_from_db
operator|)
operator|+
literal|1
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NOENCRYPTION
name|des_pcbc_encrypt
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|key_from_db
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|key_from_db
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|key_from_db
argument_list|)
argument_list|,
name|master_key_schedule
argument_list|,
operator|(
name|des_cblock
operator|*
operator|)
name|master_key_schedule
argument_list|,
name|DECRYPT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* the decrypted database key had better equal the master key */
name|n
operator|=
name|bcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|master_key
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key_from_db
argument_list|,
sizeof|sizeof
argument_list|(
name|master_key
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|key_from_db
argument_list|,
sizeof|sizeof
argument_list|(
name|key_from_db
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n\07\07verify_master_key: Invalid master key, "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"does not match database.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Master key verified.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|dump_db
argument_list|(
name|db_file
argument_list|,
name|out
argument_list|,
name|convert_key_old_db
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
name|time_explode
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|char
name|wbuf
index|[
literal|5
index|]
decl_stmt|;
name|struct
name|tm
name|tp
decl_stmt|;
name|long
name|maketime
parameter_list|()
function_decl|;
name|int
name|local
decl_stmt|;
name|zaptime
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
comment|/* clear out the struct */
if|if
condition|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|>
literal|10
condition|)
block|{
comment|/* new format */
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|wbuf
argument_list|,
name|cp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|wbuf
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|.
name|tm_year
operator|=
name|atoi
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|4
expr_stmt|;
comment|/* step over the year */
name|local
operator|=
literal|0
expr_stmt|;
comment|/* GMT */
block|}
else|else
block|{
comment|/* old format: local time, 					   year is 2 digits, assuming 19xx */
name|wbuf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|1
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|.
name|tm_year
operator|=
literal|1900
operator|+
name|atoi
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
name|local
operator|=
literal|1
expr_stmt|;
comment|/* local */
block|}
name|wbuf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|1
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tp
operator|.
name|tm_mon
operator|=
name|atoi
argument_list|(
name|wbuf
argument_list|)
operator|-
literal|1
expr_stmt|;
name|wbuf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|1
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|tp
operator|.
name|tm_mday
operator|=
name|atoi
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
name|wbuf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|1
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|tp
operator|.
name|tm_hour
operator|=
name|atoi
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
name|wbuf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|wbuf
index|[
literal|1
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|tp
operator|.
name|tm_min
operator|=
name|atoi
argument_list|(
name|wbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|maketime
argument_list|(
operator|&
name|tp
argument_list|,
name|local
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

