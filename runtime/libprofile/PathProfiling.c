begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*===-- PathProfiling.c - Support library for path profiling --------------===*\ |* |*                     The LLVM Compiler Infrastructure |* |* This file is distributed under the University of Illinois Open Source |* License. See LICENSE.TXT for details. |* |*===----------------------------------------------------------------------===*| |* |* This file implements the call back routines for the path profiling |* instrumentation pass.  This should be used with the -insert-path-profiling |* LLVM pass. |* \*===----------------------------------------------------------------------===*/
end_comment

begin_include
include|#
directive|include
file|"Profiling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/ProfileInfoTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/DataTypes.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MINGW32__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* Must use __inline in Microsoft C */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_if

begin_define
define|#
directive|define
name|inline
value|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* note that this is used for functions with large path counts,          but it is unlikely those paths will ALL be executed */
end_comment

begin_define
define|#
directive|define
name|ARBITRARY_HASH_BIN_COUNT
value|100
end_define

begin_typedef
typedef|typedef
struct|struct
name|pathHashEntry_s
block|{
name|uint32_t
name|pathNumber
decl_stmt|;
name|uint32_t
name|pathCount
decl_stmt|;
name|struct
name|pathHashEntry_s
modifier|*
name|next
decl_stmt|;
block|}
name|pathHashEntry_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|pathHashTable_s
block|{
name|pathHashEntry_t
modifier|*
name|hashBins
index|[
name|ARBITRARY_HASH_BIN_COUNT
index|]
decl_stmt|;
name|uint32_t
name|pathCounts
decl_stmt|;
block|}
name|pathHashTable_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|enum
name|ProfilingStorageType
name|type
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|void
modifier|*
name|array
decl_stmt|;
block|}
name|ftEntry_t
typedef|;
end_typedef

begin_comment
comment|/* pointer to the function table allocated in the instrumented program */
end_comment

begin_decl_stmt
name|ftEntry_t
modifier|*
name|ft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|ftSize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* write an array table to file */
end_comment

begin_function
name|void
name|writeArrayTable
parameter_list|(
name|uint32_t
name|fNumber
parameter_list|,
name|ftEntry_t
modifier|*
name|ft
parameter_list|,
name|uint32_t
modifier|*
name|funcCount
parameter_list|)
block|{
name|int
name|outFile
init|=
name|getOutFile
argument_list|()
decl_stmt|;
name|uint32_t
name|arrayHeaderLocation
init|=
literal|0
decl_stmt|;
name|uint32_t
name|arrayCurrentLocation
init|=
literal|0
decl_stmt|;
name|uint32_t
name|arrayIterator
init|=
literal|0
decl_stmt|;
name|uint32_t
name|functionUsed
init|=
literal|0
decl_stmt|;
name|uint32_t
name|pathCounts
init|=
literal|0
decl_stmt|;
comment|/* look through each entry in the array to determine whether the function      was executed at all */
for|for
control|(
name|arrayIterator
operator|=
literal|0
init|;
name|arrayIterator
operator|<
name|ft
operator|->
name|size
condition|;
name|arrayIterator
operator|++
control|)
block|{
name|uint32_t
name|pc
init|=
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|ft
operator|->
name|array
operator|)
index|[
name|arrayIterator
index|]
decl_stmt|;
comment|/* was this path executed? */
if|if
condition|(
name|pc
condition|)
block|{
name|PathProfileTableEntry
name|pte
decl_stmt|;
name|pte
operator|.
name|pathNumber
operator|=
name|arrayIterator
expr_stmt|;
name|pte
operator|.
name|pathCounter
operator|=
name|pc
expr_stmt|;
name|pathCounts
operator|++
expr_stmt|;
comment|/* one-time initialization stuff */
if|if
condition|(
operator|!
name|functionUsed
condition|)
block|{
name|arrayHeaderLocation
operator|=
name|lseek
argument_list|(
name|outFile
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|outFile
argument_list|,
sizeof|sizeof
argument_list|(
name|PathProfileHeader
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|functionUsed
operator|=
literal|1
expr_stmt|;
operator|(
operator|*
name|funcCount
operator|)
operator|++
expr_stmt|;
block|}
comment|/* write path data */
if|if
condition|(
name|write
argument_list|(
name|outFile
argument_list|,
operator|&
name|pte
argument_list|,
sizeof|sizeof
argument_list|(
name|PathProfileTableEntry
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: unable to write path entry to output file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* If this function was executed, write the header */
if|if
condition|(
name|functionUsed
condition|)
block|{
name|PathProfileHeader
name|fHeader
decl_stmt|;
name|fHeader
operator|.
name|fnNumber
operator|=
name|fNumber
expr_stmt|;
name|fHeader
operator|.
name|numEntries
operator|=
name|pathCounts
expr_stmt|;
name|arrayCurrentLocation
operator|=
name|lseek
argument_list|(
name|outFile
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|outFile
argument_list|,
name|arrayHeaderLocation
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|outFile
argument_list|,
operator|&
name|fHeader
argument_list|,
sizeof|sizeof
argument_list|(
name|PathProfileHeader
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: unable to write function header to output file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lseek
argument_list|(
name|outFile
argument_list|,
name|arrayCurrentLocation
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|hash
parameter_list|(
name|uint32_t
name|key
parameter_list|)
block|{
comment|/* this may benefit from a proper hash function */
return|return
name|key
operator|%
name|ARBITRARY_HASH_BIN_COUNT
return|;
block|}
end_function

begin_comment
comment|/* output a specific function's hash table to the profile file */
end_comment

begin_function
name|void
name|writeHashTable
parameter_list|(
name|uint32_t
name|functionNumber
parameter_list|,
name|pathHashTable_t
modifier|*
name|hashTable
parameter_list|)
block|{
name|int
name|outFile
init|=
name|getOutFile
argument_list|()
decl_stmt|;
name|PathProfileHeader
name|header
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|header
operator|.
name|fnNumber
operator|=
name|functionNumber
expr_stmt|;
name|header
operator|.
name|numEntries
operator|=
name|hashTable
operator|->
name|pathCounts
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|outFile
argument_list|,
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|PathProfileHeader
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: unable to write function header to output file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARBITRARY_HASH_BIN_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|pathHashEntry_t
modifier|*
name|hashEntry
init|=
name|hashTable
operator|->
name|hashBins
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|hashEntry
condition|)
block|{
name|pathHashEntry_t
modifier|*
name|temp
decl_stmt|;
name|PathProfileTableEntry
name|pte
decl_stmt|;
name|pte
operator|.
name|pathNumber
operator|=
name|hashEntry
operator|->
name|pathNumber
expr_stmt|;
name|pte
operator|.
name|pathCounter
operator|=
name|hashEntry
operator|->
name|pathCount
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|outFile
argument_list|,
operator|&
name|pte
argument_list|,
sizeof|sizeof
argument_list|(
name|PathProfileTableEntry
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: unable to write path entry to output file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|temp
operator|=
name|hashEntry
expr_stmt|;
name|hashEntry
operator|=
name|hashEntry
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return a pointer to this path's specific path counter */
end_comment

begin_function
specifier|static
specifier|inline
name|uint32_t
modifier|*
name|getPathCounter
parameter_list|(
name|uint32_t
name|functionNumber
parameter_list|,
name|uint32_t
name|pathNumber
parameter_list|)
block|{
name|pathHashTable_t
modifier|*
name|hashTable
decl_stmt|;
name|pathHashEntry_t
modifier|*
name|hashEntry
decl_stmt|;
name|uint32_t
name|index
init|=
name|hash
argument_list|(
name|pathNumber
argument_list|)
decl_stmt|;
if|if
condition|(
name|ft
index|[
name|functionNumber
operator|-
literal|1
index|]
operator|.
name|array
operator|==
literal|0
condition|)
name|ft
index|[
name|functionNumber
operator|-
literal|1
index|]
operator|.
name|array
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pathHashTable_t
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hashTable
operator|=
operator|(
name|pathHashTable_t
operator|*
operator|)
operator|(
operator|(
name|ftEntry_t
operator|*
operator|)
name|ft
operator|)
index|[
name|functionNumber
operator|-
literal|1
index|]
operator|.
name|array
expr_stmt|;
name|hashEntry
operator|=
name|hashTable
operator|->
name|hashBins
index|[
name|index
index|]
expr_stmt|;
while|while
condition|(
name|hashEntry
condition|)
block|{
if|if
condition|(
name|hashEntry
operator|->
name|pathNumber
operator|==
name|pathNumber
condition|)
block|{
return|return
operator|&
name|hashEntry
operator|->
name|pathCount
return|;
block|}
name|hashEntry
operator|=
name|hashEntry
operator|->
name|next
expr_stmt|;
block|}
name|hashEntry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|pathHashEntry_t
argument_list|)
argument_list|)
expr_stmt|;
name|hashEntry
operator|->
name|pathNumber
operator|=
name|pathNumber
expr_stmt|;
name|hashEntry
operator|->
name|pathCount
operator|=
literal|0
expr_stmt|;
name|hashEntry
operator|->
name|next
operator|=
name|hashTable
operator|->
name|hashBins
index|[
name|index
index|]
expr_stmt|;
name|hashTable
operator|->
name|hashBins
index|[
name|index
index|]
operator|=
name|hashEntry
expr_stmt|;
name|hashTable
operator|->
name|pathCounts
operator|++
expr_stmt|;
return|return
operator|&
name|hashEntry
operator|->
name|pathCount
return|;
block|}
end_function

begin_comment
comment|/* Increment a specific path's count */
end_comment

begin_function
name|void
name|llvm_increment_path_count
parameter_list|(
name|uint32_t
name|functionNumber
parameter_list|,
name|uint32_t
name|pathNumber
parameter_list|)
block|{
name|uint32_t
modifier|*
name|pathCounter
init|=
name|getPathCounter
argument_list|(
name|functionNumber
argument_list|,
name|pathNumber
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|pathCounter
operator|<
literal|0xffffffff
condition|)
operator|(
operator|*
name|pathCounter
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Increment a specific path's count */
end_comment

begin_function
name|void
name|llvm_decrement_path_count
parameter_list|(
name|uint32_t
name|functionNumber
parameter_list|,
name|uint32_t
name|pathNumber
parameter_list|)
block|{
name|uint32_t
modifier|*
name|pathCounter
init|=
name|getPathCounter
argument_list|(
name|functionNumber
argument_list|,
name|pathNumber
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pathCounter
operator|)
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Writes out a path profile given a function table, in the following format.  *  *  *      |<-- 32 bits --> |  *      +-----------------+-----------------+  * 0x00 | profileType     | functionCount   |  *      +-----------------+-----------------+  * 0x08 | functionNum     | profileEntries  |  // function 1  *      +-----------------+-----------------+  * 0x10 | pathNumber      | pathCounter     |  // entry 1.1  *      +-----------------+-----------------+  * 0x18 | pathNumber      | pathCounter     |  // entry 1.2  *      +-----------------+-----------------+  *  ... |       ...       |       ...       |  // entry 1.n  *      +-----------------+-----------------+  *  ... | functionNum     | profileEntries  |  // function 2  *      +-----------------+-----------------+  *  ... | pathNumber      | pathCounter     |  // entry 2.1  *      +-----------------+-----------------+  *  ... | pathNumber      | pathCounter     |  // entry 2.2  *      +-----------------+-----------------+  *  ... |       ...       |       ...       |  // entry 2.n  *      +-----------------+-----------------+  *  */
end_comment

begin_function
specifier|static
name|void
name|pathProfAtExitHandler
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|outFile
init|=
name|getOutFile
argument_list|()
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|header
index|[
literal|2
index|]
init|=
block|{
name|PathInfo
block|,
literal|0
block|}
decl_stmt|;
name|uint32_t
name|headerLocation
decl_stmt|;
name|uint32_t
name|currentLocation
decl_stmt|;
comment|/* skip over the header for now */
name|headerLocation
operator|=
name|lseek
argument_list|(
name|outFile
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|outFile
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
comment|/* Iterate through each function */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ftSize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ft
index|[
name|i
index|]
operator|.
name|type
operator|==
name|ProfilingArray
condition|)
block|{
name|writeArrayTable
argument_list|(
name|i
operator|+
literal|1
argument_list|,
operator|&
name|ft
index|[
name|i
index|]
argument_list|,
name|header
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ft
index|[
name|i
index|]
operator|.
name|type
operator|==
name|ProfilingHash
condition|)
block|{
comment|/* If the hash exists, write it to file */
if|if
condition|(
name|ft
index|[
name|i
index|]
operator|.
name|array
condition|)
block|{
name|writeHashTable
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|ft
index|[
name|i
index|]
operator|.
name|array
argument_list|)
expr_stmt|;
name|header
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|free
argument_list|(
name|ft
index|[
name|i
index|]
operator|.
name|array
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Setup and write the path profile header */
name|currentLocation
operator|=
name|lseek
argument_list|(
name|outFile
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|outFile
argument_list|,
name|headerLocation
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|outFile
argument_list|,
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"error: unable to write path profile header to output file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|lseek
argument_list|(
name|outFile
argument_list|,
name|currentLocation
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* llvm_start_path_profiling - This is the main entry point of the path  * profiling library.  It is responsible for setting up the atexit handler.  */
end_comment

begin_function
name|int
name|llvm_start_path_profiling
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|void
modifier|*
name|functionTable
parameter_list|,
name|uint32_t
name|numElements
parameter_list|)
block|{
name|int
name|Ret
init|=
name|save_arguments
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
decl_stmt|;
name|ft
operator|=
name|functionTable
expr_stmt|;
name|ftSize
operator|=
name|numElements
expr_stmt|;
name|atexit
argument_list|(
name|pathProfAtExitHandler
argument_list|)
expr_stmt|;
return|return
name|Ret
return|;
block|}
end_function

end_unit

