begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gzread.c -- zlib functions for reading gzip files  * Copyright (C) 2004, 2005, 2010 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_include
include|#
directive|include
file|"gzguts.h"
end_include

begin_comment
comment|/* Local functions */
end_comment

begin_decl_stmt
name|local
name|int
name|gz_load
name|OF
argument_list|(
operator|(
name|gz_statep
operator|,
name|unsigned
name|char
operator|*
operator|,
name|unsigned
operator|,
name|unsigned
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_avail
name|OF
argument_list|(
operator|(
name|gz_statep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_next4
name|OF
argument_list|(
operator|(
name|gz_statep
operator|,
name|unsigned
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_head
name|OF
argument_list|(
operator|(
name|gz_statep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_decomp
name|OF
argument_list|(
operator|(
name|gz_statep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_make
name|OF
argument_list|(
operator|(
name|gz_statep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|gz_skip
name|OF
argument_list|(
operator|(
name|gz_statep
operator|,
name|z_off64_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from    state->fd, and update state->eof, state->err, and state->msg as appropriate.    This function needs to loop on read(), since read() is not guaranteed to    read the number of bytes requested, depending on the type of descriptor. */
end_comment

begin_function
name|local
name|int
name|gz_load
parameter_list|(
name|state
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|have
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
modifier|*
name|have
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
operator|*
name|have
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|read
argument_list|(
name|state
operator|->
name|fd
argument_list|,
name|buf
operator|+
operator|*
name|have
argument_list|,
name|len
operator|-
operator|*
name|have
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
break|break;
operator|*
name|have
operator|+=
name|ret
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|have
operator|<
name|len
condition|)
do|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_ERRNO
argument_list|,
name|zstrerror
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|state
operator|->
name|eof
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Load up input buffer and set eof flag if last data loaded -- return -1 on    error, 0 otherwise.  Note that the eof flag is set when the end of the input    file is reached, even though there may be unused data in the buffer.  Once    that data has been used, no more attempts will be made to read the file.    gz_avail() assumes that strm->avail_in == 0. */
end_comment

begin_function
name|local
name|int
name|gz_avail
parameter_list|(
name|state
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
block|{
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|state
operator|->
name|eof
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gz_load
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|in
argument_list|,
name|state
operator|->
name|size
argument_list|,
operator|(
name|unsigned
operator|*
operator|)
operator|&
operator|(
name|strm
operator|->
name|avail_in
operator|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|strm
operator|->
name|next_in
operator|=
name|state
operator|->
name|in
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get next byte from input, or -1 if end or error. */
end_comment

begin_define
define|#
directive|define
name|NEXT
parameter_list|()
value|((strm->avail_in == 0&& gz_avail(state) == -1) ? -1 : \                 (strm->avail_in == 0 ? -1 : \                  (strm->avail_in--, *(strm->next_in)++)))
end_define

begin_comment
comment|/* Get a four-byte little-endian integer and return 0 on success and the value    in *ret.  Otherwise -1 is returned and *ret is not modified. */
end_comment

begin_function
name|local
name|int
name|gz_next4
parameter_list|(
name|state
parameter_list|,
name|ret
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
name|unsigned
name|long
modifier|*
name|ret
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|unsigned
name|long
name|val
decl_stmt|;
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
decl_stmt|;
name|val
operator|=
name|NEXT
argument_list|()
expr_stmt|;
name|val
operator|+=
operator|(
name|unsigned
operator|)
name|NEXT
argument_list|()
operator|<<
literal|8
expr_stmt|;
name|val
operator|+=
operator|(
name|unsigned
name|long
operator|)
name|NEXT
argument_list|()
operator|<<
literal|16
expr_stmt|;
name|ch
operator|=
name|NEXT
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|val
operator|+=
operator|(
name|unsigned
name|long
operator|)
name|ch
operator|<<
literal|24
expr_stmt|;
operator|*
name|ret
operator|=
name|val
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look for gzip header, set up for inflate or copy.  state->have must be zero.    If this is the first time in, allocate required memory.  state->how will be    left unchanged if there is no more input data available, will be set to COPY    if there is no gzip header and direct copying will be performed, or it will    be set to GZIP for decompression, and the gzip header will be skipped so    that the next available input data is the raw deflate stream.  If direct    copying, then leftover input data from the input buffer will be copied to    the output buffer.  In that case, all further file reads will be directly to    either the output buffer or a user buffer.  If decompressing, the inflate    state and the check value will be initialized.  gz_head() will return 0 on    success or -1 on failure.  Failures may include read errors or gzip header    errors.  */
end_comment

begin_function
name|local
name|int
name|gz_head
parameter_list|(
name|state
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
block|{
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
comment|/* allocate read buffers and inflate memory */
if|if
condition|(
name|state
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|/* allocate buffers */
name|state
operator|->
name|in
operator|=
name|malloc
argument_list|(
name|state
operator|->
name|want
argument_list|)
expr_stmt|;
name|state
operator|->
name|out
operator|=
name|malloc
argument_list|(
name|state
operator|->
name|want
operator|<<
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|in
operator|==
name|NULL
operator|||
name|state
operator|->
name|out
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|state
operator|->
name|out
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|state
operator|->
name|out
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|in
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|state
operator|->
name|in
argument_list|)
expr_stmt|;
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_MEM_ERROR
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|state
operator|->
name|size
operator|=
name|state
operator|->
name|want
expr_stmt|;
comment|/* allocate inflate memory */
name|state
operator|->
name|strm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|strm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|strm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|state
operator|->
name|strm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|state
operator|->
name|strm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
if|if
condition|(
name|inflateInit2
argument_list|(
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
argument_list|,
operator|-
literal|15
argument_list|)
operator|!=
name|Z_OK
condition|)
block|{
comment|/* raw inflate */
name|free
argument_list|(
name|state
operator|->
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|in
argument_list|)
expr_stmt|;
name|state
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_MEM_ERROR
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* get some data in the input buffer */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gz_avail
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
comment|/* look for the gzip magic header bytes 31 and 139 */
if|if
condition|(
name|strm
operator|->
name|next_in
index|[
literal|0
index|]
operator|==
literal|31
condition|)
block|{
name|strm
operator|->
name|avail_in
operator|--
expr_stmt|;
name|strm
operator|->
name|next_in
operator|++
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
operator|&&
name|gz_avail
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|&&
name|strm
operator|->
name|next_in
index|[
literal|0
index|]
operator|==
literal|139
condition|)
block|{
comment|/* we have a gzip header, woo hoo! */
name|strm
operator|->
name|avail_in
operator|--
expr_stmt|;
name|strm
operator|->
name|next_in
operator|++
expr_stmt|;
comment|/* skip rest of header */
if|if
condition|(
name|NEXT
argument_list|()
operator|!=
literal|8
condition|)
block|{
comment|/* compression method */
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_DATA_ERROR
argument_list|,
literal|"unknown compression method"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|flags
operator|=
name|NEXT
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0xe0
condition|)
block|{
comment|/* reserved flag bits */
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_DATA_ERROR
argument_list|,
literal|"unknown header flags set"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|NEXT
argument_list|()
expr_stmt|;
comment|/* modification time */
name|NEXT
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
comment|/* extra flags */
name|NEXT
argument_list|()
expr_stmt|;
comment|/* operating system */
if|if
condition|(
name|flags
operator|&
literal|4
condition|)
block|{
comment|/* extra field */
name|len
operator|=
operator|(
name|unsigned
operator|)
name|NEXT
argument_list|()
expr_stmt|;
name|len
operator|+=
operator|(
name|unsigned
operator|)
name|NEXT
argument_list|()
operator|<<
literal|8
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
if|if
condition|(
name|NEXT
argument_list|()
operator|<
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|flags
operator|&
literal|8
condition|)
comment|/* file name */
while|while
condition|(
name|NEXT
argument_list|()
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|flags
operator|&
literal|16
condition|)
comment|/* comment */
while|while
condition|(
name|NEXT
argument_list|()
operator|>
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|flags
operator|&
literal|2
condition|)
block|{
comment|/* header crc */
name|NEXT
argument_list|()
expr_stmt|;
name|NEXT
argument_list|()
expr_stmt|;
block|}
comment|/* an unexpected end of file is not checked for here -- it will be                noticed on the first request for uncompressed data */
comment|/* set up for decompression */
name|inflateReset
argument_list|(
name|strm
argument_list|)
expr_stmt|;
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|state
operator|->
name|how
operator|=
name|GZIP
expr_stmt|;
name|state
operator|->
name|direct
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* not a gzip file -- save first byte (31) and fall to raw i/o */
name|state
operator|->
name|out
index|[
literal|0
index|]
operator|=
literal|31
expr_stmt|;
name|state
operator|->
name|have
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* doing raw i/o, save start of raw data for seeking, copy any leftover        input to output -- this assumes that the output buffer is larger than        the input buffer, which also assures space for gzungetc() */
name|state
operator|->
name|raw
operator|=
name|state
operator|->
name|pos
expr_stmt|;
name|state
operator|->
name|next
operator|=
name|state
operator|->
name|out
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_in
condition|)
block|{
name|memcpy
argument_list|(
name|state
operator|->
name|next
operator|+
name|state
operator|->
name|have
argument_list|,
name|strm
operator|->
name|next_in
argument_list|,
name|strm
operator|->
name|avail_in
argument_list|)
expr_stmt|;
name|state
operator|->
name|have
operator|+=
name|strm
operator|->
name|avail_in
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
block|}
name|state
operator|->
name|how
operator|=
name|COPY
expr_stmt|;
name|state
operator|->
name|direct
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Decompress from input to the provided next_out and avail_out in the state.    If the end of the compressed data is reached, then verify the gzip trailer    check value and length (modulo 2^32).  state->have and state->next are set    to point to the just decompressed data, and the crc is updated.  If the    trailer is verified, state->how is reset to LOOK to look for the next gzip    stream or raw data, once state->have is depleted.  Returns 0 on success, -1    on failure.  Failures may include invalid compressed data or a failed gzip    trailer verification. */
end_comment

begin_function
name|local
name|int
name|gz_decomp
parameter_list|(
name|state
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|had
decl_stmt|;
name|unsigned
name|long
name|crc
decl_stmt|,
name|len
decl_stmt|;
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
decl_stmt|;
comment|/* fill output buffer up to end of deflate stream */
name|had
operator|=
name|strm
operator|->
name|avail_out
expr_stmt|;
do|do
block|{
comment|/* get more input for inflate() */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
operator|&&
name|gz_avail
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_DATA_ERROR
argument_list|,
literal|"unexpected end of file"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* decompress and handle errors */
name|ret
operator|=
name|inflate
argument_list|(
name|strm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_ERROR
operator|||
name|ret
operator|==
name|Z_NEED_DICT
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_STREAM_ERROR
argument_list|,
literal|"internal error: inflate stream corrupt"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ret
operator|==
name|Z_MEM_ERROR
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_MEM_ERROR
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ret
operator|==
name|Z_DATA_ERROR
condition|)
block|{
comment|/* deflate stream invalid */
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_DATA_ERROR
argument_list|,
name|strm
operator|->
name|msg
operator|==
name|NULL
condition|?
literal|"compressed data error"
else|:
name|strm
operator|->
name|msg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|strm
operator|->
name|avail_out
operator|&&
name|ret
operator|!=
name|Z_STREAM_END
condition|)
do|;
comment|/* update available output and crc check value */
name|state
operator|->
name|have
operator|=
name|had
operator|-
name|strm
operator|->
name|avail_out
expr_stmt|;
name|state
operator|->
name|next
operator|=
name|strm
operator|->
name|next_out
operator|-
name|state
operator|->
name|have
expr_stmt|;
name|strm
operator|->
name|adler
operator|=
name|crc32
argument_list|(
name|strm
operator|->
name|adler
argument_list|,
name|state
operator|->
name|next
argument_list|,
name|state
operator|->
name|have
argument_list|)
expr_stmt|;
comment|/* check gzip trailer if at end of deflate stream */
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
block|{
if|if
condition|(
name|gz_next4
argument_list|(
name|state
argument_list|,
operator|&
name|crc
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|gz_next4
argument_list|(
name|state
argument_list|,
operator|&
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_DATA_ERROR
argument_list|,
literal|"unexpected end of file"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|crc
operator|!=
name|strm
operator|->
name|adler
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_DATA_ERROR
argument_list|,
literal|"incorrect data check"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|len
operator|!=
operator|(
name|strm
operator|->
name|total_out
operator|&
literal|0xffffffffL
operator|)
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_DATA_ERROR
argument_list|,
literal|"incorrect length check"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|state
operator|->
name|how
operator|=
name|LOOK
expr_stmt|;
comment|/* ready for next stream, once have is 0 (leave                                    state->direct unchanged to remember how) */
block|}
comment|/* good decompression */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Make data and put in the output buffer.  Assumes that state->have == 0.    Data is either copied from the input file or decompressed from the input    file depending on state->how.  If state->how is LOOK, then a gzip header is    looked for (and skipped if found) to determine wither to copy or decompress.    Returns -1 on error, otherwise 0.  gz_make() will leave state->have as COPY    or GZIP unless the end of the input file has been reached and all data has    been processed.  */
end_comment

begin_function
name|local
name|int
name|gz_make
parameter_list|(
name|state
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
block|{
name|z_streamp
name|strm
init|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
decl_stmt|;
if|if
condition|(
name|state
operator|->
name|how
operator|==
name|LOOK
condition|)
block|{
comment|/* look for gzip header */
if|if
condition|(
name|gz_head
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|state
operator|->
name|have
condition|)
comment|/* got some data from gz_head() */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|state
operator|->
name|how
operator|==
name|COPY
condition|)
block|{
comment|/* straight copy */
if|if
condition|(
name|gz_load
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|out
argument_list|,
name|state
operator|->
name|size
operator|<<
literal|1
argument_list|,
operator|&
operator|(
name|state
operator|->
name|have
operator|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|->
name|next
operator|=
name|state
operator|->
name|out
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|->
name|how
operator|==
name|GZIP
condition|)
block|{
comment|/* decompress */
name|strm
operator|->
name|avail_out
operator|=
name|state
operator|->
name|size
operator|<<
literal|1
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|state
operator|->
name|out
expr_stmt|;
if|if
condition|(
name|gz_decomp
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
end_comment

begin_function
name|local
name|int
name|gz_skip
parameter_list|(
name|state
parameter_list|,
name|len
parameter_list|)
name|gz_statep
name|state
decl_stmt|;
name|z_off64_t
name|len
decl_stmt|;
block|{
name|unsigned
name|n
decl_stmt|;
comment|/* skip over len bytes or reach end-of-file, whichever comes first */
while|while
condition|(
name|len
condition|)
comment|/* skip over whatever is in output buffer */
if|if
condition|(
name|state
operator|->
name|have
condition|)
block|{
name|n
operator|=
name|GT_OFF
argument_list|(
name|state
operator|->
name|have
argument_list|)
operator|||
operator|(
name|z_off64_t
operator|)
name|state
operator|->
name|have
operator|>
name|len
condition|?
operator|(
name|unsigned
operator|)
name|len
else|:
name|state
operator|->
name|have
expr_stmt|;
name|state
operator|->
name|have
operator|-=
name|n
expr_stmt|;
name|state
operator|->
name|next
operator|+=
name|n
expr_stmt|;
name|state
operator|->
name|pos
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
comment|/* output buffer empty -- return if we're at the end of the input */
elseif|else
if|if
condition|(
name|state
operator|->
name|eof
operator|&&
name|state
operator|->
name|strm
operator|.
name|avail_in
operator|==
literal|0
condition|)
break|break;
comment|/* need more data to skip -- load up output buffer */
else|else
block|{
comment|/* get more output, looking for header if required */
if|if
condition|(
name|gz_make
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzread
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|voidp
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|unsigned
name|got
decl_stmt|,
name|n
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
name|z_streamp
name|strm
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
name|strm
operator|=
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
expr_stmt|;
comment|/* check that we're reading and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|1
return|;
comment|/* since an int is returned, make sure len fits in one, otherwise return        with an error (this avoids the flaw in the interface) */
if|if
condition|(
operator|(
name|int
operator|)
name|len
operator|<
literal|0
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_BUF_ERROR
argument_list|,
literal|"requested length does not fit in int"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* if len is zero, avoid unnecessary operations */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* process a skip request */
if|if
condition|(
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_skip
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* get len bytes to buf, or less than len if at the end */
name|got
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* first just try copying data from the output buffer */
if|if
condition|(
name|state
operator|->
name|have
condition|)
block|{
name|n
operator|=
name|state
operator|->
name|have
operator|>
name|len
condition|?
name|len
else|:
name|state
operator|->
name|have
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|state
operator|->
name|next
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|state
operator|->
name|next
operator|+=
name|n
expr_stmt|;
name|state
operator|->
name|have
operator|-=
name|n
expr_stmt|;
block|}
comment|/* output buffer empty -- return if we're at the end of the input */
elseif|else
if|if
condition|(
name|state
operator|->
name|eof
operator|&&
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
break|break;
comment|/* need output data -- for small len or new stream load up our output            buffer */
elseif|else
if|if
condition|(
name|state
operator|->
name|how
operator|==
name|LOOK
operator|||
name|len
operator|<
operator|(
name|state
operator|->
name|size
operator|<<
literal|1
operator|)
condition|)
block|{
comment|/* get more output, looking for header if required */
if|if
condition|(
name|gz_make
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
continue|continue;
comment|/* no progress yet -- go back to memcpy() above */
comment|/* the copy above assures that we will leave with space in the                output buffer, allowing at least one gzungetc() to succeed */
block|}
comment|/* large len -- read directly into user buffer */
elseif|else
if|if
condition|(
name|state
operator|->
name|how
operator|==
name|COPY
condition|)
block|{
comment|/* read directly */
if|if
condition|(
name|gz_load
argument_list|(
name|state
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|n
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* large len -- decompress directly into user buffer */
else|else
block|{
comment|/* state->how == GZIP */
name|strm
operator|->
name|avail_out
operator|=
name|len
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|gz_decomp
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|n
operator|=
name|state
operator|->
name|have
expr_stmt|;
name|state
operator|->
name|have
operator|=
literal|0
expr_stmt|;
block|}
comment|/* update progress */
name|len
operator|-=
name|n
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|n
expr_stmt|;
name|got
operator|+=
name|n
expr_stmt|;
name|state
operator|->
name|pos
operator|+=
name|n
expr_stmt|;
block|}
do|while
condition|(
name|len
condition|)
do|;
comment|/* return number of bytes read into user buffer (will fit in int) */
return|return
operator|(
name|int
operator|)
name|got
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzgetc
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're reading and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|1
return|;
comment|/* try output buffer (no need to check for skip request) */
if|if
condition|(
name|state
operator|->
name|have
condition|)
block|{
name|state
operator|->
name|have
operator|--
expr_stmt|;
name|state
operator|->
name|pos
operator|++
expr_stmt|;
return|return
operator|*
operator|(
name|state
operator|->
name|next
operator|)
operator|++
return|;
block|}
comment|/* nothing there -- try gzread() */
name|ret
operator|=
name|gzread
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|ret
operator|<
literal|1
condition|?
operator|-
literal|1
else|:
name|buf
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzungetc
parameter_list|(
name|c
parameter_list|,
name|file
parameter_list|)
name|int
name|c
decl_stmt|;
name|gzFile
name|file
decl_stmt|;
block|{
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're reading and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|1
return|;
comment|/* process a skip request */
if|if
condition|(
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_skip
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* can't push EOF */
if|if
condition|(
name|c
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* if output buffer empty, put byte at end (allows more pushing) */
if|if
condition|(
name|state
operator|->
name|have
operator|==
literal|0
condition|)
block|{
name|state
operator|->
name|have
operator|=
literal|1
expr_stmt|;
name|state
operator|->
name|next
operator|=
name|state
operator|->
name|out
operator|+
operator|(
name|state
operator|->
name|size
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
name|state
operator|->
name|next
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|state
operator|->
name|pos
operator|--
expr_stmt|;
return|return
name|c
return|;
block|}
comment|/* if no room, give up (must have already done a gzungetc()) */
if|if
condition|(
name|state
operator|->
name|have
operator|==
operator|(
name|state
operator|->
name|size
operator|<<
literal|1
operator|)
condition|)
block|{
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_BUF_ERROR
argument_list|,
literal|"out of room to push characters"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* slide output data if needed and insert byte before existing data */
if|if
condition|(
name|state
operator|->
name|next
operator|==
name|state
operator|->
name|out
condition|)
block|{
name|unsigned
name|char
modifier|*
name|src
init|=
name|state
operator|->
name|out
operator|+
name|state
operator|->
name|have
decl_stmt|;
name|unsigned
name|char
modifier|*
name|dest
init|=
name|state
operator|->
name|out
operator|+
operator|(
name|state
operator|->
name|size
operator|<<
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|src
operator|>
name|state
operator|->
name|out
condition|)
operator|*
operator|--
name|dest
operator|=
operator|*
operator|--
name|src
expr_stmt|;
name|state
operator|->
name|next
operator|=
name|dest
expr_stmt|;
block|}
name|state
operator|->
name|have
operator|++
expr_stmt|;
name|state
operator|->
name|next
operator|--
expr_stmt|;
name|state
operator|->
name|next
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|state
operator|->
name|pos
operator|--
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|char
modifier|*
name|ZEXPORT
name|gzgets
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|left
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|unsigned
name|char
modifier|*
name|eol
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
comment|/* check parameters and get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
operator|||
name|buf
operator|==
name|NULL
operator|||
name|len
operator|<
literal|1
condition|)
return|return
name|NULL
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're reading and that there's no error */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
operator|||
name|state
operator|->
name|err
operator|!=
name|Z_OK
condition|)
return|return
name|NULL
return|;
comment|/* process a skip request */
if|if
condition|(
name|state
operator|->
name|seek
condition|)
block|{
name|state
operator|->
name|seek
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gz_skip
argument_list|(
name|state
argument_list|,
name|state
operator|->
name|skip
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
block|}
comment|/* copy output bytes up to new line or len - 1, whichever comes first --        append a terminating zero to the string (we don't check for a zero in        the contents, let the user worry about that) */
name|str
operator|=
name|buf
expr_stmt|;
name|left
operator|=
operator|(
name|unsigned
operator|)
name|len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|left
condition|)
do|do
block|{
comment|/* assure that something is in the output buffer */
if|if
condition|(
name|state
operator|->
name|have
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gz_make
argument_list|(
name|state
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
comment|/* error */
if|if
condition|(
name|state
operator|->
name|have
operator|==
literal|0
condition|)
block|{
comment|/* end of file */
if|if
condition|(
name|buf
operator|==
name|str
condition|)
comment|/* got bupkus */
return|return
name|NULL
return|;
break|break;
comment|/* got something -- return it */
block|}
block|}
comment|/* look for end-of-line in current output buffer */
name|n
operator|=
name|state
operator|->
name|have
operator|>
name|left
condition|?
name|left
else|:
name|state
operator|->
name|have
expr_stmt|;
name|eol
operator|=
name|memchr
argument_list|(
name|state
operator|->
name|next
argument_list|,
literal|'\n'
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol
operator|!=
name|NULL
condition|)
name|n
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|eol
operator|-
name|state
operator|->
name|next
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* copy through end-of-line, or remainder if not found */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|state
operator|->
name|next
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|state
operator|->
name|have
operator|-=
name|n
expr_stmt|;
name|state
operator|->
name|next
operator|+=
name|n
expr_stmt|;
name|state
operator|->
name|pos
operator|+=
name|n
expr_stmt|;
name|left
operator|-=
name|n
expr_stmt|;
name|buf
operator|+=
name|n
expr_stmt|;
block|}
do|while
condition|(
name|left
operator|&&
name|eol
operator|==
name|NULL
condition|)
do|;
comment|/* found end-of-line or out of space -- terminate string and return it */
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|str
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzdirect
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're reading */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
condition|)
return|return
literal|0
return|;
comment|/* if the state is not known, but we can find out, then do so (this is        mainly for right after a gzopen() or gzdopen()) */
if|if
condition|(
name|state
operator|->
name|how
operator|==
name|LOOK
operator|&&
name|state
operator|->
name|have
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|gz_head
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|/* return 1 if reading direct, 0 if decompressing a gzip stream */
return|return
name|state
operator|->
name|direct
return|;
block|}
end_function

begin_comment
comment|/* -- see zlib.h -- */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzclose_r
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|;
name|gz_statep
name|state
decl_stmt|;
comment|/* get internal structure */
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|state
operator|=
operator|(
name|gz_statep
operator|)
name|file
expr_stmt|;
comment|/* check that we're reading */
if|if
condition|(
name|state
operator|->
name|mode
operator|!=
name|GZ_READ
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/* free memory and close file */
if|if
condition|(
name|state
operator|->
name|size
condition|)
block|{
name|inflateEnd
argument_list|(
operator|&
operator|(
name|state
operator|->
name|strm
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|out
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|in
argument_list|)
expr_stmt|;
block|}
name|gz_error
argument_list|(
name|state
argument_list|,
name|Z_OK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
operator|->
name|path
argument_list|)
expr_stmt|;
name|ret
operator|=
name|close
argument_list|(
name|state
operator|->
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
argument_list|)
expr_stmt|;
return|return
name|ret
condition|?
name|Z_ERRNO
else|:
name|Z_OK
return|;
block|}
end_function

end_unit

