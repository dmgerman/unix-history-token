begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * routines to do regular expression matching  *  * Entry points:  *  *	re_comp(s)  *		char *s;  *	 ... returns 0 if the string s was compiled successfully,  *		     a pointer to an error message otherwise.  *	     If passed 0 or a null string returns without changing  *           the currently compiled re (see note 11 below).  *  *	re_exec(s)  *		char *s;  *	 ... returns 1 if the string s matches the last compiled regular  *		       expression,   *		     0 if the string s failed to match the last compiled  *		       regular expression, and  *		    -1 if the compiled regular expression was invalid   *		       (indicating an internal error).  *  * The strings passed to both re_comp and re_exec may have trailing or  * embedded newline characters; they are terminated by nulls.  *  * The identity of the author of these routines is lost in antiquity;  * this is essentially the same as the re code in the original V6 ed.  *  * The regular expressions recognized are described below. This description  * is essentially the same as that for ed.  *  *	A regular expression specifies a set of strings of characters.  *	A member of this set of strings is said to be matched by  *	the regular expression.  In the following specification for  *	regular expressions the word `character' means any character but NUL.  *  *	1.  Any character except a special character matches itself.  *	    Special characters are the regular expression delimiter plus  *	    \ [ . and sometimes ^ * $.  *	2.  A . matches any character.  *	3.  A \ followed by any character except a digit or ( )  *	    matches that character.  *	4.  A nonempty string s bracketed [s] (or [^s]) matches any  *	    character in (or not in) s. In s, \ has no special meaning,  *	    and ] may only appear as the first letter. A substring   *	    a-b, with a and b in ascending ASCII order, stands for  *	    the inclusive range of ASCII characters.  *	5.  A regular expression of form 1-4 followed by * matches a  *	    sequence of 0 or more matches of the regular expression.  *	6.  A regular expression, x, of form 1-8, bracketed \(x\)  *	    matches what x matches.  *	7.  A \ followed by a digit n matches a copy of the string that the  *	    bracketed regular expression beginning with the nth \( matched.  *	8.  A regular expression of form 1-8, x, followed by a regular  *	    expression of form 1-7, y matches a match for x followed by  *	    a match for y, with the x match being as long as possible  *	    while still permitting a y match.  *	9.  A regular expression of form 1-8 preceded by ^ (or followed  *	    by $), is constrained to matches that begin at the left  *	    (or end at the right) end of a line.  *	10. A regular expression of form 1-9 picks out the longest among  *	    the leftmost matches in a line.  *	11. An empty regular expression stands for a copy of the last  *	    regular expression encountered.  */
end_comment

begin_comment
comment|/*  * constants for re's  */
end_comment

begin_define
define|#
directive|define
name|CBRA
value|1
end_define

begin_define
define|#
directive|define
name|CCHR
value|2
end_define

begin_define
define|#
directive|define
name|CDOT
value|4
end_define

begin_define
define|#
directive|define
name|CCL
value|6
end_define

begin_define
define|#
directive|define
name|NCCL
value|8
end_define

begin_define
define|#
directive|define
name|CDOL
value|10
end_define

begin_define
define|#
directive|define
name|CEOF
value|11
end_define

begin_define
define|#
directive|define
name|CKET
value|12
end_define

begin_define
define|#
directive|define
name|CBACK
value|18
end_define

begin_define
define|#
directive|define
name|CSTAR
value|01
end_define

begin_define
define|#
directive|define
name|ESIZE
value|512
end_define

begin_define
define|#
directive|define
name|NBRA
value|9
end_define

begin_decl_stmt
specifier|static
name|char
name|expbuf
index|[
name|ESIZE
index|]
decl_stmt|,
modifier|*
name|braslist
index|[
name|NBRA
index|]
decl_stmt|,
modifier|*
name|braelist
index|[
name|NBRA
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|circf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * compile the regular expression argument into a dfa  */
end_comment

begin_function
name|char
modifier|*
name|re_comp
parameter_list|(
name|sp
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|ep
init|=
name|expbuf
decl_stmt|;
name|int
name|cclcnt
decl_stmt|,
name|numbra
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|lastep
init|=
literal|0
decl_stmt|;
name|char
name|bracket
index|[
name|NBRA
index|]
decl_stmt|;
name|char
modifier|*
name|bracketp
init|=
operator|&
name|bracket
index|[
literal|0
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|retoolong
init|=
literal|"Regular expression too long"
decl_stmt|;
define|#
directive|define
name|comerr
parameter_list|(
name|msg
parameter_list|)
value|{expbuf[0] = 0; numbra = 0; return(msg); }
if|if
condition|(
name|sp
operator|==
literal|0
operator|||
operator|*
name|sp
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|ep
operator|==
literal|0
condition|)
return|return
operator|(
literal|"No previous regular expression"
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|'^'
condition|)
block|{
name|circf
operator|=
literal|1
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
else|else
name|circf
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|ESIZE
index|]
condition|)
name|comerr
argument_list|(
name|retoolong
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|bracketp
operator|!=
name|bracket
condition|)
name|comerr
argument_list|(
literal|"unmatched \\("
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CEOF
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'*'
condition|)
name|lastep
operator|=
name|ep
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'.'
case|:
operator|*
name|ep
operator|++
operator|=
name|CDOT
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
if|if
condition|(
name|lastep
operator|==
literal|0
operator|||
operator|*
name|lastep
operator|==
name|CBRA
operator|||
operator|*
name|lastep
operator|==
name|CKET
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|lastep
operator||=
name|CSTAR
expr_stmt|;
continue|continue;
case|case
literal|'$'
case|:
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
goto|goto
name|defchar
goto|;
operator|*
name|ep
operator|++
operator|=
name|CDOL
expr_stmt|;
continue|continue;
case|case
literal|'['
case|:
operator|*
name|ep
operator|++
operator|=
name|CCL
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
literal|0
expr_stmt|;
name|cclcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|==
literal|'^'
condition|)
block|{
name|c
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
name|ep
index|[
operator|-
literal|2
index|]
operator|=
name|NCCL
expr_stmt|;
block|}
do|do
block|{
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
name|comerr
argument_list|(
literal|"missing ]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
operator|&&
name|ep
index|[
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|==
literal|']'
condition|)
block|{
operator|*
name|ep
operator|++
operator|=
literal|'-'
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|ep
index|[
operator|-
literal|1
index|]
operator|<
name|c
condition|)
block|{
operator|*
name|ep
operator|=
name|ep
index|[
operator|-
literal|1
index|]
operator|+
literal|1
expr_stmt|;
name|ep
operator|++
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|ESIZE
index|]
condition|)
name|comerr
argument_list|(
name|retoolong
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
name|cclcnt
operator|++
expr_stmt|;
if|if
condition|(
name|ep
operator|>=
operator|&
name|expbuf
index|[
name|ESIZE
index|]
condition|)
name|comerr
argument_list|(
name|retoolong
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|!=
literal|']'
condition|)
do|;
name|lastep
index|[
literal|1
index|]
operator|=
name|cclcnt
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|sp
operator|++
operator|)
operator|==
literal|'('
condition|)
block|{
if|if
condition|(
name|numbra
operator|>=
name|NBRA
condition|)
name|comerr
argument_list|(
literal|"too many \\(\\) pairs"
argument_list|)
expr_stmt|;
operator|*
name|bracketp
operator|++
operator|=
name|numbra
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CBRA
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|numbra
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|')'
condition|)
block|{
if|if
condition|(
name|bracketp
operator|<=
name|bracket
condition|)
name|comerr
argument_list|(
literal|"unmatched \\)"
argument_list|)
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|CKET
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
operator|*
operator|--
name|bracketp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|>=
literal|'1'
operator|&&
name|c
operator|<
operator|(
literal|'1'
operator|+
name|NBRA
operator|)
condition|)
block|{
operator|*
name|ep
operator|++
operator|=
name|CBACK
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
operator|-
literal|'1'
expr_stmt|;
continue|continue;
block|}
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
name|defchar
label|:
default|default:
operator|*
name|ep
operator|++
operator|=
name|CCHR
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|c
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   * match the argument string against the compiled re  */
end_comment

begin_function
name|int
name|re_exec
parameter_list|(
name|p1
parameter_list|)
specifier|register
name|char
modifier|*
name|p1
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p2
init|=
name|expbuf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|int
name|rv
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|NBRA
condition|;
name|c
operator|++
control|)
block|{
name|braslist
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
name|braelist
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|circf
condition|)
return|return
operator|(
operator|(
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
operator|)
operator|)
return|;
comment|/* 	 * fast check for first character 	 */
if|if
condition|(
operator|*
name|p2
operator|==
name|CCHR
condition|)
block|{
name|c
operator|=
name|p2
index|[
literal|1
index|]
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p1
operator|!=
name|c
condition|)
continue|continue;
if|if
condition|(
name|rv
operator|=
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * regular algorithm 	 */
do|do
if|if
condition|(
name|rv
operator|=
name|advance
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
condition|)
return|return
operator|(
name|rv
operator|)
return|;
do|while
condition|(
operator|*
name|p1
operator|++
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * try to match the next thing in the dfa  */
end_comment

begin_function
specifier|static
name|int
name|advance
parameter_list|(
name|lp
parameter_list|,
name|ep
parameter_list|)
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
decl|*
name|ep
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|curlp
decl_stmt|;
name|int
name|ct
decl_stmt|,
name|i
decl_stmt|;
name|int
name|rv
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
operator|*
name|ep
operator|++
condition|)
block|{
case|case
name|CCHR
case|:
if|if
condition|(
operator|*
name|ep
operator|++
operator|==
operator|*
name|lp
operator|++
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CDOT
case|:
if|if
condition|(
operator|*
name|lp
operator|++
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CDOL
case|:
if|if
condition|(
operator|*
name|lp
operator|==
literal|'\0'
condition|)
continue|continue;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CEOF
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|CCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|NCCL
case|:
if|if
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CBRA
case|:
name|braslist
index|[
operator|*
name|ep
operator|++
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
case|case
name|CKET
case|:
name|braelist
index|[
operator|*
name|ep
operator|++
index|]
operator|=
name|lp
expr_stmt|;
continue|continue;
case|case
name|CBACK
case|:
if|if
condition|(
name|braelist
index|[
name|i
operator|=
operator|*
name|ep
operator|++
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|backref
argument_list|(
name|i
argument_list|,
name|lp
argument_list|)
condition|)
block|{
name|lp
operator|+=
name|braelist
index|[
name|i
index|]
operator|-
name|braslist
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|CBACK
operator||
name|CSTAR
case|:
if|if
condition|(
name|braelist
index|[
name|i
operator|=
operator|*
name|ep
operator|++
index|]
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|curlp
operator|=
name|lp
expr_stmt|;
name|ct
operator|=
name|braelist
index|[
name|i
index|]
operator|-
name|braslist
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|backref
argument_list|(
name|i
argument_list|,
name|lp
argument_list|)
condition|)
name|lp
operator|+=
name|ct
expr_stmt|;
while|while
condition|(
name|lp
operator|>=
name|curlp
condition|)
block|{
if|if
condition|(
name|rv
operator|=
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|lp
operator|-=
name|ct
expr_stmt|;
block|}
continue|continue;
case|case
name|CDOT
operator||
name|CSTAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
condition|)
empty_stmt|;
goto|goto
name|star
goto|;
case|case
name|CCHR
operator||
name|CSTAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
operator|*
name|lp
operator|++
operator|==
operator|*
name|ep
condition|)
empty_stmt|;
name|ep
operator|++
expr_stmt|;
goto|goto
name|star
goto|;
case|case
name|CCL
operator||
name|CSTAR
case|:
case|case
name|NCCL
operator||
name|CSTAR
case|:
name|curlp
operator|=
name|lp
expr_stmt|;
while|while
condition|(
name|cclass
argument_list|(
name|ep
argument_list|,
operator|*
name|lp
operator|++
argument_list|,
name|ep
index|[
operator|-
literal|1
index|]
operator|==
operator|(
name|CCL
operator||
name|CSTAR
operator|)
argument_list|)
condition|)
empty_stmt|;
name|ep
operator|+=
operator|*
name|ep
expr_stmt|;
goto|goto
name|star
goto|;
name|star
label|:
do|do
block|{
name|lp
operator|--
expr_stmt|;
if|if
condition|(
name|rv
operator|=
name|advance
argument_list|(
name|lp
argument_list|,
name|ep
argument_list|)
condition|)
return|return
operator|(
name|rv
operator|)
return|;
block|}
do|while
condition|(
name|lp
operator|>
name|curlp
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_expr_stmt
name|backref
argument_list|(
name|i
argument_list|,
name|lp
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|braslist
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|++
operator|==
operator|*
name|lp
operator|++
condition|)
if|if
condition|(
name|bp
operator|>=
name|braelist
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|int
name|cclass
parameter_list|(
name|set
parameter_list|,
name|c
parameter_list|,
name|af
parameter_list|)
specifier|register
name|char
modifier|*
name|set
decl_stmt|,
name|c
decl_stmt|;
name|int
name|af
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|n
operator|=
operator|*
name|set
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
condition|)
if|if
condition|(
operator|*
name|set
operator|++
operator|==
name|c
condition|)
return|return
operator|(
name|af
operator|)
return|;
return|return
operator|(
operator|!
name|af
operator|)
return|;
block|}
end_function

end_unit

