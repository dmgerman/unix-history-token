begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
name|From
name|IngVAX
range|:
name|eric
name|Sun
name|Nov
literal|2
literal|16
operator|:
literal|10
operator|:
literal|46
literal|1980
name|To
operator|:
name|v
operator|:
name|bill
name|Subject
operator|:
name|hacked
name|up
name|lp
name|driver
name|You
name|should
name|probably
name|test
name|this
decl_stmt|,
name|I
name|haven
decl|'t had a chance....  ---- lp.c /*  *  Line printer driver  */  #include "../h/param.h" #include "../h/dir.h" #include "../h/user.h" #include "../h/tty.h" #include "../h/uba.h"  struct device *lp_addr[] = { (struct device *)(UBA0_DEV+0177514) };  #define	LPPRI	PZERO+10 #define	LPLOWAT	50 #define	LPHIWAT	100 #define LPMAX 2  struct device { 	short	lpcsr, lpbuf; }; int lp_cnt = 1;  struct lp { 	struct	clist l_outq; 	char	flag, ind; 	short	ccc, mcc, mlc; 	short	line, col; } lp_dt[LPMAX];  #define	OPEN	010 #define	CAP	020 #define	NOCR	040 #define	ASLP	0100  #define	FORM	014  lpopen(dev, flag) { 	register unit; 	register struct lp *lp;  	unit = dev&07; 	if (unit>= lp_cnt || unit>= LPMAX || 	 (lp =&lp_dt[unit])->flag || lp_addr[unit]->lpcsr<0 ) { 		u.u_error = EIO; 		return; 	} 	lp->flag = (dev&077)|OPEN; 	lp->ind = 4; 	lp->col = 80; 	lp->line = 66; 	lpoutput(unit, FORM); }  lpclose(dev) { 	register unit;  	unit = dev&07; 	lpoutput(unit, FORM); 	lp_dt[unit].flag = 0; }  lpwrite(dev) { 	register c;  	while ((c=cpass())>=0) 		lpoutput(dev&07, c); }  lpoutput(dev, c) register dev, c; { 	register struct lp *lp;  	lp =&lp_dt[dev]; 	if(lp->flag&CAP) { 		if(c>='
name|a
decl|'&& c<='
name|z
decl|') 			c += '
name|A
decl|'-'
name|a
decl|'; else 		switch(c) { 		case '
block|{
literal|': 			c = '
operator|(
literal|'; 			goto esc; 		case '
block|}
end_decl_stmt

begin_expr_stmt
literal|': 			c = '
end_expr_stmt

begin_expr_stmt
unit|)
literal|'; 			goto esc; 		case '
operator|`
literal|': 			c = '
operator|\
literal|''
expr_stmt|;
end_expr_stmt

begin_goto
goto|goto
name|esc
goto|;
end_goto

begin_case
case|case
literal|'|'
case|:
end_case

begin_expr_stmt
name|c
operator|=
literal|'!'
expr_stmt|;
end_expr_stmt

begin_goto
goto|goto
name|esc
goto|;
end_goto

begin_case
case|case
literal|'~'
case|:
end_case

begin_expr_stmt
name|c
operator|=
literal|'^'
expr_stmt|;
end_expr_stmt

begin_label
name|esc
label|:
end_label

begin_expr_stmt
name|lpoutput
argument_list|(
name|dev
argument_list|,
name|c
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|lp
operator|->
name|ccc
operator|--
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|c
operator|=
literal|'-'
expr_stmt|;
end_expr_stmt

begin_switch
unit|} 	}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
name|lp
operator|->
name|ccc
operator|=
operator|(
operator|(
name|lp
operator|->
name|ccc
operator|+
literal|8
operator|-
name|lp
operator|->
name|ind
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
name|lp
operator|->
name|ind
expr_stmt|;
return|return;
case|case
literal|'\n'
case|:
name|lp
operator|->
name|mlc
operator|++
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|mlc
operator|>=
name|lp
operator|->
name|line
condition|)
name|c
operator|=
name|FORM
expr_stmt|;
case|case
name|FORM
case|:
name|lp
operator|->
name|mcc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|mlc
condition|)
block|{
name|lpputc
argument_list|(
name|dev
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|FORM
condition|)
name|lp
operator|->
name|mlc
operator|=
literal|0
expr_stmt|;
block|}
case|case
literal|'\r'
case|:
name|lp
operator|->
name|ccc
operator|=
name|lp
operator|->
name|ind
expr_stmt|;
return|return;
case|case
literal|010
case|:
if|if
condition|(
name|lp
operator|->
name|ccc
operator|>
name|lp
operator|->
name|ind
condition|)
name|lp
operator|->
name|ccc
operator|--
expr_stmt|;
return|return;
case|case
literal|' '
case|:
name|lp
operator|->
name|ccc
operator|++
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|lp
operator|->
name|ccc
operator|<
name|lp
operator|->
name|mcc
condition|)
block|{
if|if
condition|(
name|lp
operator|->
name|flag
operator|&
name|NOCR
condition|)
block|{
name|lp
operator|->
name|ccc
operator|++
expr_stmt|;
return|return;
block|}
name|lpputc
argument_list|(
name|dev
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|lp
operator|->
name|mcc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lp
operator|->
name|ccc
operator|<
name|lp
operator|->
name|col
condition|)
block|{
while|while
condition|(
name|lp
operator|->
name|ccc
operator|>
name|lp
operator|->
name|mcc
condition|)
block|{
name|lpputc
argument_list|(
name|dev
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|lp
operator|->
name|mcc
operator|++
expr_stmt|;
block|}
name|lpputc
argument_list|(
name|dev
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|lp
operator|->
name|mcc
operator|++
expr_stmt|;
block|}
name|lp
operator|->
name|ccc
operator|++
expr_stmt|;
block|}
end_switch

begin_expr_stmt
unit|}  lpputc
operator|(
name|dev
operator|,
name|c
operator|)
specifier|register
name|dev
operator|,
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|lp
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
operator|&
name|lp_dt
index|[
name|dev
index|]
expr_stmt|;
name|spl4
argument_list|()
expr_stmt|;
while|while
condition|(
name|lp
operator|->
name|l_outq
operator|.
name|c_cc
operator|>
name|LPHIWAT
condition|)
block|{
name|lp
operator|->
name|flag
operator||=
name|ASLP
expr_stmt|;
name|sleep
argument_list|(
name|lp
argument_list|,
name|LPPRI
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|c
argument_list|,
operator|&
name|lp
operator|->
name|l_outq
argument_list|)
expr_stmt|;
name|lpintr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|lpintr
argument_list|(
name|dev
argument_list|)
specifier|register
name|dev
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|lp
modifier|*
name|lp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
name|lp_addr
index|[
name|dev
index|]
operator|->
name|lpcsr
operator|&=
operator|~
name|IENABLE
expr_stmt|;
name|lp
operator|=
operator|&
name|lp_dt
index|[
name|dev
index|]
expr_stmt|;
while|while
condition|(
name|lp_addr
index|[
name|dev
index|]
operator|->
name|lpcsr
operator|&
name|DONE
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
operator|&
name|lp
operator|->
name|l_outq
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|lp_addr
index|[
name|dev
index|]
operator|->
name|lpbuf
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|l_outq
operator|.
name|c_cc
operator|<=
name|LPLOWAT
operator|&&
name|lp
operator|->
name|flag
operator|&
name|ASLP
condition|)
block|{
name|lp
operator|->
name|flag
operator|&=
operator|~
name|ASLP
expr_stmt|;
name|wakeup
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lp
operator|->
name|l_outq
operator|.
name|c_cc
operator|>
literal|0
condition|)
name|lp_addr
index|[
name|dev
index|]
operator|->
name|lpcsr
operator||=
name|IENABLE
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|lpioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|)
specifier|register
name|caddr_t
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|m
decl_stmt|;
name|struct
name|lp
modifier|*
name|lp
decl_stmt|;
struct|struct
block|{
name|char
name|lsg_flag
decl_stmt|,
name|lsg_ind
decl_stmt|;
name|short
name|lsg_line
decl_stmt|,
name|lsg_col
decl_stmt|;
block|}
name|lpios
struct|;
name|lp
operator|=
operator|&
name|lp_dt
index|[
name|dev
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
operator|(
literal|'v'
operator|<<
literal|8
operator|)
operator|+
literal|0
case|:
name|lpios
operator|.
name|lsg_flag
operator|=
name|lp
operator|->
name|flag
expr_stmt|;
name|lpios
operator|.
name|lsg_ind
operator|=
name|lp
operator|->
name|ind
expr_stmt|;
name|lpios
operator|.
name|lsg_line
operator|=
name|lp
operator|->
name|line
expr_stmt|;
name|lpios
operator|.
name|lsg_col
operator|=
name|lp
operator|->
name|col
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|lpios
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
name|lpios
argument_list|)
expr_stmt|;
return|return;
case|case
operator|(
literal|'v'
operator|<<
literal|8
operator|)
operator|+
literal|1
case|:
name|m
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
operator|&
name|lpios
argument_list|,
sizeof|sizeof
name|lpios
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
operator|-
literal|1
condition|)
block|{
name|u
operator|.
name|u_error
operator|=
name|EFAULT
expr_stmt|;
return|return;
block|}
name|lp
operator|->
name|flag
operator|=
name|lpios
operator|.
name|lsg_flag
expr_stmt|;
name|lp
operator|->
name|ind
operator|=
name|lpios
operator|.
name|lsg_ind
expr_stmt|;
name|lp
operator|->
name|line
operator|=
name|lpios
operator|.
name|lsg_line
expr_stmt|;
name|lp
operator|->
name|col
operator|=
name|lpios
operator|.
name|lsg_col
expr_stmt|;
return|return;
default|default:
name|u
operator|.
name|u_error
operator|=
name|ENOTTY
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
operator|--
operator|--
name|END
end_expr_stmt

end_unit

