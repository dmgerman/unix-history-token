begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)evalf.c	34.1 10/3/80"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* evalframe off of the c stack.       We will set fp to point where the register fp points.     Then fp+2 = saved ap          fp+4 = saved pc          fp+3 = saved fp          ap+1 = first arg */
end_comment

begin_comment
comment|/* These will keep track of the current saved values of np and lbot as we decend the evalstack.  These must be read by decoding the registers saved by each function call. */
end_comment

begin_decl_stmt
name|struct
name|argent
modifier|*
name|fakenp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|argent
modifier|*
name|fakelbot
decl_stmt|;
end_decl_stmt

begin_function
name|lispval
name|Levalf
parameter_list|()
block|{
specifier|register
name|struct
name|frame
modifier|*
name|myfp
decl_stmt|;
name|struct
name|frame
modifier|*
name|nextevf
parameter_list|()
function_decl|;
specifier|register
name|lispval
name|handy
decl_stmt|,
name|result
decl_stmt|;
name|int
modifier|*
modifier|*
name|fp
decl_stmt|;
comment|/* this must be the first local */
name|int
name|evaltype
decl_stmt|;
name|snpand
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbot
operator|==
name|np
condition|)
block|{
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|chkarg
argument_list|(
literal|1
argument_list|,
literal|"evalf"
argument_list|)
expr_stmt|;
name|fakenp
operator|=
name|NULL
expr_stmt|;
name|fakelbot
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lbot
operator|->
name|val
operator|==
name|nil
condition|)
block|{
comment|/* Arg of nil means start at the top */
name|myfp
operator|=
name|nextevf
argument_list|(
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
operator|&
name|fp
operator|+
literal|1
operator|)
argument_list|,
operator|&
name|evaltype
argument_list|)
expr_stmt|;
comment|/* myfp  now points to evalframe of call to evalframe */
name|myfp
operator|=
name|myfp
operator|->
name|fp
expr_stmt|;
comment|/* and now to the one past evalframe */
block|}
else|else
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
comment|/* Interesting artifact: A pdl pointer will be an INT, but if 	    read in, the Franz reader produces a bignum, thus giving some 	    protection from being hacked.  */
name|error
argument_list|(
literal|"ARG TO EVALFRAME MUST BE INTEGER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|myfp
operator|=
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|myfp
operator|<
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
operator|&
name|fp
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* if purported fp is less than current fp, a fraud 		(since stack grows down, and current fp must be bottom) */
name|error
argument_list|(
literal|"ARG TO EVALFRAME NOT EVALFRAME POINTER"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
name|myfp
operator|=
name|nextevf
argument_list|(
name|myfp
argument_list|,
operator|&
name|evaltype
argument_list|)
expr_stmt|;
comment|/* get pointer to frame above */
if|if
condition|(
name|myfp
operator|>
name|myfp
operator|->
name|fp
condition|)
return|return
operator|(
name|nil
operator|)
return|;
comment|/* end of frames */
comment|/* return (<eval or apply><fp><exp being evaled><bnp>) */
name|protect
argument_list|(
name|result
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
comment|/* See maclisp manual for difference between eval frames and apply 	frames, or else see the code below. */
name|result
operator|->
name|d
operator|.
name|car
operator|=
name|matom
argument_list|(
name|evaltype
condition|?
literal|"eval"
else|:
literal|"apply"
argument_list|)
expr_stmt|;
name|result
operator|->
name|d
operator|.
name|cdr
operator|=
operator|(
name|handy
operator|=
name|newdot
argument_list|()
operator|)
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|myfp
operator|->
name|fp
argument_list|)
expr_stmt|;
comment|/* The frame pointer as a lisp int */
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|evaltype
condition|)
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|myfp
operator|->
name|ap
index|[
literal|1
index|]
expr_stmt|;
comment|/* eval type - simply the arg to eval */
else|else
block|{
comment|/*  apply type ; must build argument list. The form will look like 		  (<function> (<evaled arg1><evaled arg2> ....)) 	      i.e. the function name followed by a list of evaluated args */
name|lispval
name|form
decl_stmt|,
name|handy1
decl_stmt|,
name|arglist
decl_stmt|;
name|struct
name|argent
modifier|*
name|pntr
decl_stmt|;
comment|/* name of function will either be arg to Lfuncal or on argstack */
operator|(
name|form
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
operator|(
name|int
operator|)
name|myfp
operator|->
name|ap
index|[
literal|0
index|]
operator|&
literal|1
condition|?
name|myfp
operator|->
name|ap
index|[
literal|1
index|]
else|:
operator|(
name|fakelbot
operator|-
literal|1
operator|)
operator|->
name|val
expr_stmt|;
comment|/* Assume that Lfuncal increments lbot after getting 			  function to call. */
operator|(
name|form
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|cdr
operator|=
name|nil
expr_stmt|;
for|for
control|(
name|arglist
operator|=
name|nil
operator|,
name|pntr
operator|=
name|fakenp
init|;
name|pntr
operator|>
name|fakelbot
condition|;
control|)
block|{
operator|(
name|handy1
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|cdr
operator|=
name|arglist
expr_stmt|;
operator|(
name|arglist
operator|=
name|handy1
operator|)
operator|->
name|d
operator|.
name|car
operator|=
operator|(
operator|--
name|pntr
operator|)
operator|->
name|val
expr_stmt|;
block|}
empty_stmt|;
name|form
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
operator|=
name|arglist
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|form
expr_stmt|;
block|}
empty_stmt|;
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
comment|/* Next is index into bindstack lisp pseudo-array, for maximum 	    usefulness */
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
operator|(
operator|(
expr|struct
name|nament
operator|*
operator|)
operator|*
operator|(
operator|(
operator|(
name|long
operator|*
operator|)
name|myfp
operator|->
name|fp
operator|)
operator|-
literal|1
operator|)
operator|)
operator|-
name|orgbnp
argument_list|)
expr_stmt|;
comment|/* first part gets oldbnp, if first local */
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|fakenp
operator|-
name|orgnp
argument_list|)
expr_stmt|;
comment|/* index of np in namestack*/
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|inewint
argument_list|(
name|fakelbot
operator|-
name|orgnp
argument_list|)
expr_stmt|;
comment|/* index of lbot in namestack*/
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LBOTNPMASK
value|03<<22
end_define

begin_comment
comment|/* Octal 3 */
end_comment

begin_comment
comment|/* We assume that r6 and r7 are saved as pairs, and that no earlier registers are saved.  If the Franz snpand hack is changed, this may have to change too. */
end_comment

begin_function
name|struct
name|frame
modifier|*
name|nextevf
parameter_list|(
name|curfp
parameter_list|,
name|ftypep
parameter_list|)
name|struct
name|frame
modifier|*
name|curfp
decl_stmt|;
name|int
modifier|*
name|ftypep
decl_stmt|;
block|{
specifier|register
name|struct
name|frame
modifier|*
name|myfp
decl_stmt|;
name|lispval
name|_qfuncl
argument_list|()
decl_stmt|,
name|tynames
argument_list|()
decl_stmt|;
comment|/* locations in qfuncl */
name|lispval
name|fchack
parameter_list|()
function_decl|;
comment|/*pseudo function after Lfuncal */
for|for
control|(
name|myfp
operator|=
name|curfp
init|;
name|myfp
operator|<
name|myfp
operator|->
name|fp
condition|;
name|myfp
operator|=
name|myfp
operator|->
name|fp
control|)
block|{
comment|/* Look up stack until find a frame with the right saved pc */
if|if
condition|(
name|myfp
operator|->
name|mask
operator|&
name|LBOTNPMASK
condition|)
block|{
name|fakenp
operator|=
operator|(
expr|struct
name|argent
operator|*
operator|)
operator|(
name|myfp
operator|->
name|r6
operator|)
expr_stmt|;
name|fakelbot
operator|=
operator|(
expr|struct
name|argent
operator|*
operator|)
operator|(
name|myfp
operator|->
name|r7
operator|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|myfp
operator|->
name|pc
operator|>
name|eval
operator|&&
name|myfp
operator|->
name|pc
operator|<
name|popnames
condition|)
block|{
comment|/* interpreted code */
operator|*
name|ftypep
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
comment|/*	if (myfp->pc> _qfuncl&& myfp->pc< tynames) { /* compiled code */
comment|/* 	    *ftypep = FALSE; 	    break; 	} else   */
if|if
condition|(
name|myfp
operator|->
name|pc
operator|>
name|Lfuncal
operator|&&
name|myfp
operator|->
name|pc
operator|<
name|fchack
condition|)
block|{
comment|/* call to funcall */
operator|*
name|ftypep
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|myfp
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"catchfram.h"
end_include

begin_function
name|lispval
name|Lfretn
parameter_list|()
block|{
name|int
modifier|*
modifier|*
name|fp
decl_stmt|;
comment|/* this must be the first local */
name|struct
name|frame
modifier|*
name|myfp
decl_stmt|;
name|struct
name|nament
modifier|*
name|mybnp
decl_stmt|;
specifier|extern
name|long
name|errp
decl_stmt|;
specifier|extern
name|long
name|exitlnk
decl_stmt|;
typedef|typedef
name|struct
name|catchfr
modifier|*
name|cp
typedef|;
typedef|typedef
name|struct
name|savblock
modifier|*
name|savp
typedef|;
name|cp
name|curp
decl_stmt|;
name|savp
name|cursavp
decl_stmt|;
name|chkarg
argument_list|(
literal|2
argument_list|,
literal|"freturn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|lbot
operator|->
name|val
argument_list|)
operator|!=
name|INT
condition|)
name|error
argument_list|(
literal|"freturn: 1st arg not pdl pointer"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|myfp
operator|=
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
name|lbot
operator|->
name|val
operator|->
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|myfp
operator|<
operator|(
expr|struct
name|frame
operator|*
operator|)
operator|(
operator|&
name|fp
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* if purported fp is less than current fp, a fraud 	    (since stack grows down, and current fp must be bottom) */
name|error
argument_list|(
literal|"freturn: 1st arg not current pdl pointer"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
comment|/* Unwind name stack.  The oldbnp will be the first local variable of 	the function we are returning from, so it will be immediately below this 	stack frame (i.e. it was pushed right after the call). */
name|mybnp
operator|=
operator|(
expr|struct
name|nament
operator|*
operator|)
operator|*
operator|(
operator|(
operator|(
name|long
operator|*
operator|)
name|myfp
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|mybnp
operator|<
name|orgbnp
operator|||
name|mybnp
operator|>
name|bnp
condition|)
name|error
argument_list|(
literal|"freturn: problem with pdl pointer"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|popnames
argument_list|(
name|mybnp
argument_list|)
expr_stmt|;
comment|/* Reset pointer to next catchframe in stack appropriately. */
for|for
control|(
name|curp
operator|=
operator|(
name|cp
operator|)
name|errp
init|;
name|curp
operator|!=
operator|(
name|cp
operator|)
name|nil
condition|;
name|curp
operator|=
name|curp
operator|->
name|link
control|)
block|{
comment|/* Debugging... 	printf ("Considering catchframe at %d\n", curp); fflush(stdout); */
if|if
condition|(
operator|(
name|long
operator|*
operator|)
name|myfp
operator|<
operator|(
name|long
operator|*
operator|)
name|curp
condition|)
block|{
comment|/* printf ("Won\n"); fflush(stdout); */
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|errp
operator|=
operator|(
name|long
operator|)
name|curp
expr_stmt|;
comment|/* printf ("errp is now %d\n", errp);fflush(stdout); */
comment|/* Reset saveblock for setexit/reset appropriately. */
for|for
control|(
name|cursavp
operator|=
operator|(
name|savp
operator|)
name|exitlnk
init|;
name|cursavp
operator|!=
operator|(
name|savp
operator|)
name|NULL
condition|;
name|cursavp
operator|=
name|cursavp
operator|->
name|savlnk
control|)
block|{
comment|/* printf("Considering saveblock at %d\n", cursavp); 	fflush (stdout); */
if|if
condition|(
operator|(
name|savp
operator|)
name|myfp
operator|>
name|cursavp
operator|&&
operator|(
operator|(
name|savp
operator|)
name|myfp
operator|<
name|cursavp
operator|->
name|savlnk
operator|||
name|cursavp
operator|->
name|savlnk
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* printf("Won\n"); fflush(stdout); */
name|resexit
argument_list|(
name|cursavp
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
name|fsmash
argument_list|(
name|myfp
argument_list|,
operator|(
name|np
operator|-
literal|1
operator|)
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* Smash the fp register..(If myfp not valid fp, 			    real trouble follows)  Will really return  			    from other guy (ha ha) */
block|}
end_function

begin_macro
name|fsmash
argument_list|(
argument|framep
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|frame
modifier|*
name|framep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
asm|asm("	movl	4(ap), fp");
asm|asm("	movl	8(ap), r0");
asm|asm("	ret");
block|}
end_block

end_unit

