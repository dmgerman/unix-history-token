begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)fex1.c	34.2 11/7/80"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_comment
comment|/* Nprog ****************************************************************/
end_comment

begin_comment
comment|/* This first sets the local variables to nil while saving their old	*/
end_comment

begin_comment
comment|/* values on the name stack.  Then, pointers to various things are	*/
end_comment

begin_comment
comment|/* saved as this function may be returned to by an "Ngo" or by a	*/
end_comment

begin_comment
comment|/* "Lreturn".  At the end is the loop that cycles through the contents	*/
end_comment

begin_comment
comment|/* of the prog.								*/
end_comment

begin_function
name|lispval
name|Nprog
parameter_list|()
block|{
name|int
name|saveme
index|[
name|SAVSIZE
index|]
decl_stmt|;
specifier|register
name|struct
name|nament
modifier|*
name|mybnp
init|=
name|bnp
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|savednp
decl_stmt|;
specifier|register
name|lispval
name|where
decl_stmt|,
name|temp
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|argent
modifier|*
name|savedlbot
decl_stmt|;
name|struct
name|nament
modifier|*
name|savedbnp
decl_stmt|;
name|struct
name|nament
modifier|*
name|topbind
decl_stmt|;
name|long
name|myerrp
decl_stmt|;
specifier|extern
name|long
name|errp
decl_stmt|;
name|savednp
operator|=
name|np
expr_stmt|;
name|savedlbot
operator|=
name|lbot
expr_stmt|;
name|savedbnp
operator|=
name|bnp
expr_stmt|;
name|temp
operator|=
name|where
operator|=
operator|(
name|lbot
operator|->
name|val
operator|)
operator|->
name|d
operator|.
name|car
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|==
name|DTPR
condition|)
block|{
name|temp
operator|=
name|where
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|==
name|ATOM
condition|)
block|{
name|bnp
operator|->
name|atm
operator|=
name|temp
expr_stmt|;
name|bnp
operator|->
name|val
operator|=
operator|(
name|temp
operator|)
operator|->
name|a
operator|.
name|clb
expr_stmt|;
operator|(
name|temp
operator|)
operator|->
name|a
operator|.
name|clb
operator|=
name|nil
expr_stmt|;
name|temp
operator|=
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|bnp
operator|++
operator|>
name|bnplim
condition|)
name|binderr
argument_list|()
expr_stmt|;
block|}
else|else
return|return
operator|(
name|CNIL
operator|)
return|;
block|}
name|topbind
operator|=
name|bnp
expr_stmt|;
name|myerrp
operator|=
name|errp
expr_stmt|;
if|if
condition|(
name|where
operator|!=
name|nil
condition|)
return|return
operator|(
name|CNIL
operator|)
return|;
name|temp
operator|=
name|where
operator|=
name|savedlbot
operator|->
name|val
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|getexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
while|while
condition|(
name|retval
operator|=
name|setexit
argument_list|()
condition|)
block|{
name|errp
operator|=
name|myerrp
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|BRRETN
case|:
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
name|popnames
argument_list|(
name|savedbnp
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|savedlbot
expr_stmt|;
return|return
operator|(
name|contval
operator|)
return|;
case|case
name|BRGOTO
case|:
name|where
operator|=
operator|(
name|savedlbot
operator|->
name|val
operator|)
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
while|while
condition|(
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|==
name|DTPR
operator|)
operator|&&
operator|(
name|where
operator|->
name|d
operator|.
name|car
operator|!=
name|contval
operator|)
condition|)
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|where
operator|->
name|d
operator|.
name|car
operator|==
name|contval
condition|)
block|{
comment|/* This seems wrong - M Marcus 					resexit(saveme);	*/
name|popnames
argument_list|(
name|topbind
argument_list|)
expr_stmt|;
name|lbot
operator|=
name|savedlbot
expr_stmt|;
break|break;
block|}
default|default:
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
name|reset
argument_list|(
name|retval
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|==
name|DTPR
condition|)
block|{
name|temp
operator|=
name|where
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
name|ATOM
condition|)
name|eval
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
block|}
name|resexit
argument_list|(
name|saveme
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|where
operator|==
name|nil
operator|)
condition|?
name|nil
else|:
name|CNIL
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|lispval
name|globtag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Ncatch is now actually *catch , which has the form      (*catch tag form)     tag is evaluated and then the catch entry is set up.       then form is evaluated     finally the catch entry is removed.      (catch form [tag]) is translated to (*catch 'tag form)      by a macro.  */
end_comment

begin_function
name|lispval
name|Ncatch
parameter_list|()
block|{
name|struct
name|argent
modifier|*
name|savednp
decl_stmt|,
modifier|*
name|savedlbot
decl_stmt|;
specifier|register
name|lispval
name|where
decl_stmt|,
name|tag
decl_stmt|,
name|todo
decl_stmt|;
specifier|register
name|temp
expr_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|int
name|type
decl_stmt|;
name|where
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|)
operator|!=
name|DTPR
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|todo
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|tag
operator|=
name|eval
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|TYPE
argument_list|(
name|tag
argument_list|)
operator|!=
name|ATOM
operator|)
operator|&&
operator|(
name|TYPE
argument_list|(
name|tag
argument_list|)
operator|!=
name|DTPR
operator|)
condition|)
name|tag
operator|=
name|error
argument_list|(
literal|"Bad type of tag in *catch."
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
asm|asm("	pushab	On1");
asm|asm("	pushr	$0x2540");
asm|asm("	subl2	$44,sp");
comment|/* THIS IS A CROCK .... 					   saves current environment 					   for (return) z.B. */
asm|asm("	movc3	$44,_setsav,(sp)");
asm|asm("	pushl	_bnp");
asm|asm("	pushl	r10");
asm|asm("	pushl	$1");
asm|asm("	pushl	_errp");
asm|asm("	movl	sp,_errp");
name|where
operator|=
operator|(
name|eval
argument_list|(
name|todo
argument_list|)
operator|)
expr_stmt|;
asm|asm("	movl	(sp),_errp");
return|return
operator|(
name|where
operator|)
return|;
asm|asm("On1:ret");
block|}
end_function

begin_comment
comment|/* (errset form [flag])      if present, flag determines if the error message will be printed    if an error reaches the errset.    if no error occurs, errset returns a list of one element, the      value returned from form.    if an error occurs, nil is usually returned although it could     be non nil if err threw a non nil value   */
end_comment

begin_function
name|lispval
name|Nerrset
parameter_list|()
block|{
specifier|register
name|lispval
name|flag
decl_stmt|,
name|where
decl_stmt|,
name|todo
decl_stmt|;
comment|/* order important */
specifier|register
name|lispval
name|handy
init|=
name|Vlerall
decl_stmt|;
comment|/* to access this easily */
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|where
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|!=
name|DTPR
condition|)
return|return
operator|(
name|nil
operator|)
return|;
comment|/* no form */
name|todo
operator|=
name|where
operator|->
name|d
operator|.
name|car
expr_stmt|;
comment|/* form to eval */
name|flag
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|flag
operator|!=
name|nil
condition|)
name|flag
operator|=
name|eval
argument_list|(
name|flag
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
comment|/* tag to tell if er messg */
else|else
name|flag
operator|=
name|tatom
expr_stmt|;
comment|/* if not present , assume t */
comment|/* push on a catch frame */
asm|asm("	pushab	On2");
comment|/* where to jump if error */
asm|asm("	pushr	$0x2540");
asm|asm("	subl2	$44,sp");
comment|/* THIS IS A CROCK .... 					   saves current environment 					   for (return) z.B. */
asm|asm("	movc3	$44,_setsav,(sp)");
asm|asm("	pushl	_bnp");
asm|asm("	pushl	r8");
comment|/* tag , (ER%all) 	*/
asm|asm("	pushl	r11");
comment|/* flag    		*/
asm|asm("	pushl	_errp");
comment|/* link in 		*/
asm|asm("	movl	sp,_errp");
comment|/*  "	   		*/
comment|/* evaluate form, and if ok, listify */
name|handy
operator|=
name|eval
argument_list|(
name|todo
argument_list|)
expr_stmt|;
asm|asm("	movl	(sp),_errp");
comment|/* unlink this frame 	*/
name|protect
argument_list|(
name|handy
argument_list|)
expr_stmt|;
comment|/* may gc on nxt call  	*/
operator|(
name|flag
operator|=
name|newdot
argument_list|()
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|handy
expr_stmt|;
comment|/* listify arg */
return|return
operator|(
name|flag
operator|)
return|;
asm|asm("On2: ret");
comment|/* if error occured */
block|}
end_function

begin_comment
comment|/* this was changed from throw to *throw 21nov79    it really should be called Lthrow */
end_comment

begin_macro
name|Nthrow
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|lispval
name|todo
decl_stmt|,
name|where
decl_stmt|;
name|lispval
name|globtag
decl_stmt|,
name|contval
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* save register mask */
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|0
case|:
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
break|break;
default|default:
name|argerr
argument_list|(
literal|"throw"
argument_list|)
expr_stmt|;
block|}
name|globtag
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|contval
operator|=
operator|(
name|lbot
operator|+
literal|1
operator|)
operator|->
name|val
expr_stmt|;
name|Idothrow
argument_list|(
name|globtag
argument_list|,
name|contval
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Uncaught throw"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_include
include|#
directive|include
file|"catchfram.h"
end_include

begin_macro
name|Idothrow
argument_list|(
argument|tag
argument_list|,
argument|value
argument_list|)
end_macro

begin_decl_stmt
name|lispval
name|tag
decl_stmt|,
name|value
decl_stmt|;
end_decl_stmt

begin_block
block|{
typedef|typedef
name|struct
name|catchfr
modifier|*
name|cp
typedef|;
specifier|register
name|cp
name|curp
decl_stmt|;
comment|/* must be first register */
specifier|extern
name|long
name|errp
decl_stmt|;
specifier|extern
name|lispval
name|globtag
decl_stmt|;
name|int
name|pass1
decl_stmt|,
name|founduw
decl_stmt|;
name|lispval
name|handy
decl_stmt|,
name|handy2
decl_stmt|;
name|snpand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|globtag
operator|=
name|tag
expr_stmt|;
comment|/* 	printf("throw,value ");printr(tag,stdout); printf(" "); 	printr(value,stdout); fflush(stdout); 	*/
name|pass1
operator|=
name|TRUE
expr_stmt|;
name|ps2
label|:
name|founduw
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|curp
operator|=
operator|(
name|cp
operator|)
name|errp
init|;
name|curp
operator|!=
operator|(
name|cp
operator|)
name|nil
condition|;
name|curp
operator|=
name|curp
operator|->
name|link
control|)
block|{
comment|/*  printf(" lbl: ");printr(curp->labl,stdout);fflush(stdout); */
if|if
condition|(
name|curp
operator|->
name|labl
operator|==
name|Veruwpt
condition|)
block|{
name|founduw
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|pass1
condition|)
goto|goto
name|foundit
goto|;
block|}
if|if
condition|(
name|curp
operator|->
name|labl
operator|==
name|nil
operator|||
name|curp
operator|->
name|labl
operator|==
name|tag
condition|)
goto|goto
name|foundit
goto|;
if|if
condition|(
name|TYPE
argument_list|(
name|curp
operator|->
name|labl
argument_list|)
operator|==
name|DTPR
condition|)
block|{
for|for
control|(
name|handy
operator|=
name|curp
operator|->
name|labl
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
control|)
block|{
if|if
condition|(
name|handy
operator|->
name|d
operator|.
name|car
operator|==
name|tag
condition|)
goto|goto
name|foundit
goto|;
block|}
block|}
block|}
return|return;
name|foundit
label|:
comment|/* restore context at catch */
if|if
condition|(
name|pass1
operator|&&
name|founduw
condition|)
block|{
name|pass1
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|ps2
goto|;
block|}
if|if
condition|(
name|founduw
condition|)
comment|/* remember the state */
block|{
name|protect
argument_list|(
name|handy2
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
name|handy2
operator|->
name|d
operator|.
name|car
operator|=
name|Veruwpt
expr_stmt|;
name|handy
operator|=
name|handy2
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|tatom
expr_stmt|;
comment|/* t for throw */
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|tag
expr_stmt|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|value
expr_stmt|;
name|value
operator|=
name|handy2
expr_stmt|;
comment|/*   printf("Ret uwp: ");printr(value,stdout);fflush(stdout);*/
block|}
name|popnames
argument_list|(
name|curp
operator|->
name|svbnp
argument_list|)
expr_stmt|;
name|errp
operator|=
operator|(
name|int
operator|)
name|curp
operator|->
name|link
expr_stmt|;
comment|/*  		 * return value must go into r7 until after movc3 since 		 * a movc3 clobbers r0 		 */
asm|asm("	movl	8(ap),r7");
comment|/* return value */
asm|asm("	addl3	$16,r11,sp");
comment|/* account for current (return) */
asm|asm("	movc3	$44,(sp),_setsav");
asm|asm("	addl2	$44,sp");
asm|asm("	popr	$0x2540");
asm|asm("	movl	r7,r0");
asm|asm("	rsb");
block|}
end_block

begin_comment
comment|/* Ngo ******************************************************************/
end_comment

begin_comment
comment|/* First argument only is checked - and must be an atom or evaluate	*/
end_comment

begin_comment
comment|/* to one.								*/
end_comment

begin_macro
name|Ngo
argument_list|()
end_macro

begin_block
block|{
name|contval
operator|=
operator|(
name|lbot
operator|->
name|val
operator|)
operator|->
name|d
operator|.
name|car
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|contval
argument_list|)
operator|!=
name|ATOM
condition|)
block|{
name|contval
operator|=
name|eval
argument_list|(
name|contval
argument_list|)
expr_stmt|;
while|while
condition|(
name|TYPE
argument_list|(
name|contval
argument_list|)
operator|!=
name|ATOM
condition|)
name|contval
operator|=
name|error
argument_list|(
literal|"GO ARG NOT ATOM"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|reset
argument_list|(
name|BRGOTO
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Nreset ***************************************************************/
end_comment

begin_comment
comment|/* All arguments are ignored.  This just returns-from-break to depth 0.	*/
end_comment

begin_macro
name|Nreset
argument_list|()
end_macro

begin_block
block|{
name|contval
operator|=
literal|0
expr_stmt|;
name|reset
argument_list|(
name|BRRETB
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Nresetio *************************************************************/
end_comment

begin_function
name|lispval
name|Nresetio
parameter_list|()
block|{
specifier|register
name|FILE
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|_iob
index|[
literal|3
index|]
init|;
name|p
operator|<
name|_iob
operator|+
name|_NFILE
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|_flag
operator|&
operator|(
name|_IOWRT
operator||
name|_IOREAD
operator|)
condition|)
name|fclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nbreak ***************************************************************/
end_comment

begin_comment
comment|/* If first argument is not nil, this is evaluated and printed.  Then	*/
end_comment

begin_comment
comment|/* error is called with the "breaking" message.				*/
end_comment

begin_function
name|lispval
name|Nbreak
parameter_list|()
block|{
specifier|register
name|lispval
name|hold
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|port
decl_stmt|;
name|port
operator|=
name|okport
argument_list|(
name|Vpoport
operator|->
name|a
operator|.
name|clb
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|port
argument_list|,
literal|"Breaking:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hold
operator|=
name|lbot
operator|->
name|val
operator|)
operator|!=
name|nil
operator|&&
operator|(
operator|(
name|hold
operator|=
name|hold
operator|->
name|d
operator|.
name|car
operator|)
operator|!=
name|nil
operator|)
condition|)
block|{
name|printr
argument_list|(
name|hold
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|dmpport
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|errorh
argument_list|(
name|Verbrk
argument_list|,
literal|""
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Nexit ****************************************************************/
end_comment

begin_comment
comment|/* Just calls lispend with no message.					*/
end_comment

begin_macro
name|Nexit
argument_list|()
end_macro

begin_block
block|{
name|lispend
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Nsys *****************************************************************/
end_comment

begin_comment
comment|/* Just calls lispend with no message.					*/
end_comment

begin_function
name|lispval
name|Nsys
parameter_list|()
block|{
name|lispend
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|lispval
name|Ndef
parameter_list|()
block|{
specifier|register
name|lispval
name|arglist
decl_stmt|,
name|body
decl_stmt|,
name|name
decl_stmt|,
name|form
decl_stmt|;
name|snpand
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|form
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|name
operator|=
name|form
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|body
operator|=
name|form
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|arglist
operator|=
name|body
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|arglist
argument_list|)
operator|)
operator|!=
name|DTPR
operator|&&
name|arglist
operator|!=
name|nil
condition|)
name|error
argument_list|(
literal|"Warning: defining function with nonlist of args"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|name
operator|->
name|a
operator|.
name|fnbnd
operator|=
name|body
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nquote
parameter_list|()
block|{
name|snpand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lbot
operator|->
name|val
operator|)
operator|->
name|d
operator|.
name|car
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nsetq
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|,
name|where
decl_stmt|,
name|value
decl_stmt|;
specifier|register
name|int
name|lefttype
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|lbot
decl_stmt|,
modifier|*
name|np
decl_stmt|;
for|for
control|(
name|where
operator|=
name|lbot
operator|->
name|val
init|;
name|where
operator|!=
name|nil
condition|;
name|where
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
control|)
block|{
name|handy
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|handy
argument_list|)
operator|)
operator|!=
name|DTPR
condition|)
name|error
argument_list|(
literal|"odd number of args to setq"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lefttype
operator|=
name|TYPE
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
operator|)
operator|==
name|ATOM
condition|)
block|{
if|if
condition|(
name|where
operator|->
name|d
operator|.
name|car
operator|==
name|nil
condition|)
name|error
argument_list|(
literal|"Attempt to set nil"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|where
operator|->
name|d
operator|.
name|car
operator|->
name|a
operator|.
name|clb
operator|=
name|value
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lefttype
operator|==
name|VALUE
condition|)
name|where
operator|->
name|d
operator|.
name|car
operator|->
name|l
operator|=
name|value
operator|=
name|eval
argument_list|(
name|handy
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"CAN ONLY SETQ ATOMS OR VALUES"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Ncond
parameter_list|()
block|{
specifier|register
name|lispval
name|where
decl_stmt|,
name|last
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|where
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|last
operator|=
name|nil
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|)
operator|!=
name|DTPR
condition|)
break|break;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
operator|)
operator|!=
name|DTPR
condition|)
break|break;
if|if
condition|(
operator|(
name|last
operator|=
name|eval
argument_list|(
operator|(
name|where
operator|->
name|d
operator|.
name|car
operator|)
operator|->
name|d
operator|.
name|car
argument_list|)
operator|)
operator|!=
name|nil
condition|)
break|break;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|)
operator|!=
name|DTPR
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|where
operator|=
operator|(
name|where
operator|->
name|d
operator|.
name|car
operator|)
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
while|while
condition|(
operator|(
name|TYPE
argument_list|(
name|where
argument_list|)
operator|)
operator|==
name|DTPR
condition|)
block|{
name|last
operator|=
name|eval
argument_list|(
name|where
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
name|where
operator|=
name|where
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
block|}
return|return
operator|(
name|last
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nand
parameter_list|()
block|{
specifier|register
name|lispval
name|current
decl_stmt|,
name|temp
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|current
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|temp
operator|=
name|tatom
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|nil
condition|)
if|if
condition|(
operator|(
name|temp
operator|=
name|current
operator|->
name|d
operator|.
name|car
operator|)
operator|!=
name|nil
operator|&&
operator|(
name|temp
operator|=
name|eval
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
name|nil
condition|)
name|current
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
else|else
block|{
name|current
operator|=
name|nil
expr_stmt|;
name|temp
operator|=
name|nil
expr_stmt|;
block|}
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nor
parameter_list|()
block|{
specifier|register
name|lispval
name|current
decl_stmt|,
name|temp
decl_stmt|;
name|snpand
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|current
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
name|temp
operator|=
name|nil
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|nil
condition|)
if|if
condition|(
operator|(
name|temp
operator|=
name|eval
argument_list|(
name|current
operator|->
name|d
operator|.
name|car
argument_list|)
operator|)
operator|==
name|nil
condition|)
name|current
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
else|else
break|break;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|Nprocess
parameter_list|()
block|{
name|int
name|wflag
decl_stmt|,
name|childsi
decl_stmt|,
name|childso
decl_stmt|,
name|childnum
decl_stmt|,
name|child
decl_stmt|;
specifier|register
name|lispval
name|current
decl_stmt|,
name|temp
decl_stmt|;
name|char
modifier|*
name|sharg
decl_stmt|;
name|int
name|handler
decl_stmt|;
name|int
name|itemp
decl_stmt|;
name|FILE
modifier|*
name|bufs
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|obufs
index|[
literal|2
index|]
decl_stmt|;
name|wflag
operator|=
literal|1
expr_stmt|;
name|childsi
operator|=
literal|0
expr_stmt|;
name|childso
operator|=
literal|1
expr_stmt|;
name|current
operator|=
name|lbot
operator|->
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|current
argument_list|)
operator|)
operator|!=
name|DTPR
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|temp
operator|=
name|current
operator|->
name|d
operator|.
name|car
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE
argument_list|(
name|temp
argument_list|)
operator|)
operator|!=
name|ATOM
condition|)
return|return
operator|(
name|nil
operator|)
return|;
name|sharg
operator|=
name|temp
operator|->
name|a
operator|.
name|pname
expr_stmt|;
if|if
condition|(
operator|(
name|current
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
operator|)
operator|!=
name|nil
operator|&&
operator|(
name|TYPE
argument_list|(
operator|(
name|temp
operator|=
name|current
operator|->
name|d
operator|.
name|car
operator|)
argument_list|)
operator|)
operator|==
name|ATOM
condition|)
block|{
if|if
condition|(
name|temp
operator|==
name|tatom
condition|)
block|{
name|wflag
operator|=
literal|0
expr_stmt|;
name|childsi
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|temp
operator|!=
name|nil
condition|)
block|{
name|fpipe
argument_list|(
name|bufs
argument_list|)
expr_stmt|;
name|wflag
operator|=
literal|0
expr_stmt|;
name|temp
operator|->
name|a
operator|.
name|clb
operator|=
name|P
argument_list|(
name|bufs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|childsi
operator|=
name|fileno
argument_list|(
name|bufs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|current
operator|=
name|current
operator|->
name|d
operator|.
name|cdr
operator|)
operator|!=
name|nil
operator|&&
operator|(
name|TYPE
argument_list|(
operator|(
name|temp
operator|=
name|current
operator|->
name|d
operator|.
name|car
operator|)
argument_list|)
operator|)
operator|==
name|ATOM
condition|)
block|{
if|if
condition|(
name|temp
operator|!=
name|nil
condition|)
block|{
name|fpipe
argument_list|(
name|obufs
argument_list|)
expr_stmt|;
name|temp
operator|->
name|a
operator|.
name|clb
operator|=
name|P
argument_list|(
name|obufs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|childso
operator|=
name|fileno
argument_list|(
name|obufs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|handler
operator|=
name|signal
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|wflag
operator|!=
literal|0
operator|&&
name|handler
operator|!=
literal|1
condition|)
name|signal
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|signal
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|childsi
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|childsi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|childso
operator|!=
literal|1
condition|)
block|{
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|childso
argument_list|)
expr_stmt|;
block|}
name|execlp
argument_list|(
literal|"csh"
argument_list|,
literal|"csh"
argument_list|,
literal|"-c"
argument_list|,
name|sharg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"sh"
argument_list|,
literal|"-c"
argument_list|,
name|sharg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* if exec fails, signal problems*/
block|}
if|if
condition|(
name|childsi
operator|!=
literal|0
condition|)
name|fclose
argument_list|(
name|bufs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|childso
operator|!=
literal|1
condition|)
name|fclose
argument_list|(
name|obufs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wflag
operator|&&
name|child
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|status
init|=
literal|0
decl_stmt|;
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|itemp
operator|=
name|status
operator|>>
literal|8
expr_stmt|;
block|}
else|else
name|itemp
operator|=
name|child
expr_stmt|;
name|signal
argument_list|(
literal|2
argument_list|,
name|handler
argument_list|)
expr_stmt|;
return|return
operator|(
name|inewint
argument_list|(
name|itemp
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

