begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"defs"
end_include

begin_function
name|ptr
name|mkcomm
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|p
operator|=
name|commonlist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
if|if
condition|(
name|equals
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|datap
operator|->
name|comname
argument_list|)
condition|)
return|return
operator|(
name|p
operator|->
name|datap
operator|)
return|;
name|p
operator|=
name|ALLOC
argument_list|(
name|comentry
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|p
operator|->
name|comname
init|;
operator|*
name|t
operator|++
operator|=
operator|*
name|s
operator|++
condition|;
control|)
empty_stmt|;
name|p
operator|->
name|tag
operator|=
name|TCOMMON
expr_stmt|;
name|p
operator|->
name|blklevel
operator|=
operator|(
name|blklevel
operator|>
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|commonlist
operator|=
name|mkchain
argument_list|(
name|p
argument_list|,
name|commonlist
argument_list|)
expr_stmt|;
return|return
operator|(
name|commonlist
operator|->
name|datap
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|mkname
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|copys
parameter_list|()
function_decl|;
specifier|register
name|ptr
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|name
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|name
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TNAME
expr_stmt|;
name|p
operator|->
name|blklevel
operator|=
name|blklevel
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|ptr
name|mknode
parameter_list|(
name|t
parameter_list|,
name|o
parameter_list|,
name|l
parameter_list|,
name|r
parameter_list|)
name|int
name|t
decl_stmt|,
name|o
decl_stmt|;
specifier|register
name|ptr
name|l
decl_stmt|;
specifier|register
name|ptr
name|r
decl_stmt|;
block|{
specifier|register
name|struct
name|exprblock
modifier|*
name|p
decl_stmt|;
name|ptr
name|q
decl_stmt|;
name|int
name|lt
decl_stmt|,
name|rt
decl_stmt|;
name|int
name|ll
decl_stmt|,
name|rl
decl_stmt|;
name|ptr
name|mksub1
argument_list|()
decl_stmt|,
name|mkchcon
argument_list|()
decl_stmt|;
name|p
operator|=
name|allexpblock
argument_list|()
expr_stmt|;
name|TEST
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"mknode(%d,%d,%o,%o) = %o\n"
argument_list|,
name|t
argument_list|,
name|o
argument_list|,
name|l
argument_list|,
name|r
argument_list|,
name|p
argument_list|)
decl_stmt|;
name|top
label|:
if|if
condition|(
name|t
operator|!=
name|TLIST
operator|&&
name|t
operator|!=
name|TCONST
operator|&&
name|l
operator|!=
literal|0
operator|&&
name|l
operator|->
name|tag
operator|==
name|TERROR
condition|)
block|{
name|frexpr
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|frexpblock
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
name|r
operator|->
name|tag
operator|==
name|TERROR
condition|)
block|{
name|frexpr
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|frexpblock
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|p
operator|->
name|tag
operator|=
name|t
expr_stmt|;
name|p
operator|->
name|subtype
operator|=
name|o
expr_stmt|;
name|p
operator|->
name|leftp
operator|=
name|l
expr_stmt|;
name|p
operator|->
name|rightp
operator|=
name|r
expr_stmt|;
switch|switch
condition|(
name|t
condition|)
block|{
case|case
name|TAROP
case|:
name|ckdcl
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ckdcl
argument_list|(
name|r
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lt
operator|=
name|l
operator|->
name|vtype
condition|)
block|{
case|case
name|TYCHAR
case|:
case|case
name|TYSTRUCT
case|:
case|case
name|TYLOG
case|:
name|exprerr
argument_list|(
literal|"non-arithmetic operand of arith op"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
switch|switch
condition|(
name|rt
operator|=
name|r
operator|->
name|vtype
condition|)
block|{
case|case
name|TYCHAR
case|:
case|case
name|TYSTRUCT
case|:
case|case
name|TYLOG
case|:
name|exprerr
argument_list|(
literal|"non-arithmetic operand of arith op"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|lt
operator|==
name|rt
operator|||
operator|(
name|o
operator|==
name|OPPOWER
operator|&&
name|rt
operator|==
name|TYINT
operator|)
condition|)
name|p
operator|->
name|vtype
operator|=
name|lt
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lt
operator|==
name|TYREAL
operator|&&
name|rt
operator|==
name|TYLREAL
operator|)
operator|||
operator|(
name|lt
operator|==
name|TYLREAL
operator|&&
name|rt
operator|==
name|TYREAL
operator|)
condition|)
name|p
operator|->
name|vtype
operator|=
name|TYLREAL
expr_stmt|;
elseif|else
if|if
condition|(
name|lt
operator|==
name|TYINT
condition|)
block|{
name|l
operator|=
name|coerce
argument_list|(
name|rt
argument_list|,
name|l
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
elseif|else
if|if
condition|(
name|rt
operator|==
name|TYINT
condition|)
block|{
name|r
operator|=
name|coerce
argument_list|(
name|lt
argument_list|,
name|r
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|lt
operator|==
name|TYREAL
operator|&&
name|rt
operator|==
name|TYCOMPLEX
operator|)
operator|||
operator|(
name|lt
operator|==
name|TYCOMPLEX
operator|&&
name|rt
operator|==
name|TYREAL
operator|)
condition|)
name|p
operator|->
name|vtype
operator|=
name|TYCOMPLEX
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lt
operator|==
name|TYLREAL
operator|&&
name|rt
operator|==
name|TYCOMPLEX
operator|)
operator|||
operator|(
name|lt
operator|==
name|TYCOMPLEX
operator|&&
name|rt
operator|==
name|TYLREAL
operator|)
condition|)
name|p
operator|->
name|vtype
operator|=
name|TYLCOMPLEX
expr_stmt|;
else|else
block|{
name|exprerr
argument_list|(
literal|"mixed mode"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|(
name|o
operator|==
name|OPPLUS
operator|||
name|o
operator|==
name|OPSTAR
operator|)
operator|&&
name|l
operator|->
name|tag
operator|==
name|TCONST
operator|&&
name|r
operator|->
name|tag
operator|!=
name|TCONST
condition|)
block|{
name|p
operator|->
name|leftp
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|rightp
operator|=
name|l
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|==
name|OPPLUS
operator|&&
name|l
operator|->
name|tag
operator|==
name|TNEGOP
operator|&&
operator|(
name|r
operator|->
name|tag
operator|!=
name|TCONST
operator|||
name|l
operator|->
name|leftp
operator|->
name|tag
operator|==
name|TCONST
operator|)
condition|)
block|{
name|p
operator|->
name|subtype
operator|=
name|OPMINUS
expr_stmt|;
name|p
operator|->
name|leftp
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|rightp
operator|=
name|l
operator|->
name|leftp
expr_stmt|;
block|}
break|break;
case|case
name|TRELOP
case|:
name|ckdcl
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ckdcl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|p
operator|->
name|vtype
operator|=
name|TYLOG
expr_stmt|;
name|lt
operator|=
name|l
operator|->
name|vtype
expr_stmt|;
name|rt
operator|=
name|r
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|||
name|rt
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|vtype
operator|!=
name|r
operator|->
name|vtype
condition|)
block|{
name|exprerr
argument_list|(
literal|"comparison of character and noncharacter data"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ll
operator|=
name|conval
argument_list|(
name|l
operator|->
name|vtypep
argument_list|)
expr_stmt|;
name|rl
operator|=
name|conval
argument_list|(
name|r
operator|->
name|vtypep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|==
name|OPEQ
operator|||
name|o
operator|==
name|OPNE
operator|)
operator|&&
operator|(
operator|(
name|ll
operator|==
literal|1
operator|&&
name|rl
operator|==
literal|1
operator|&&
name|tailor
operator|.
name|charcomp
operator|==
literal|1
operator|)
operator|||
operator|(
name|ll
operator|<=
name|tailor
operator|.
name|ftnchwd
operator|&&
name|rl
operator|<=
name|tailor
operator|.
name|ftnchwd
operator|&&
name|tailor
operator|.
name|charcomp
operator|==
literal|2
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|l
operator|->
name|tag
operator|==
name|TCONST
condition|)
block|{
name|q
operator|=
name|cpexpr
argument_list|(
name|mkchcon
argument_list|(
name|l
operator|->
name|leftp
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|l
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|tag
operator|==
name|TCONST
condition|)
block|{
name|q
operator|=
name|cpexpr
argument_list|(
name|mkchcon
argument_list|(
name|r
operator|->
name|leftp
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|r
operator|=
name|q
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|->
name|vsubs
operator|==
literal|0
condition|)
name|l
operator|->
name|vsubs
operator|=
name|mksub1
argument_list|()
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|vsubs
operator|==
literal|0
condition|)
name|r
operator|->
name|vsubs
operator|=
name|mksub1
argument_list|()
expr_stmt|;
name|p
operator|->
name|leftp
operator|=
name|l
expr_stmt|;
name|p
operator|->
name|rightp
operator|=
name|r
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|leftp
operator|=
name|mkcall
argument_list|(
name|builtin
argument_list|(
name|TYINT
argument_list|,
literal|"ef1cmc"
argument_list|)
argument_list|,
name|arg4
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|rightp
operator|=
name|mkint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lt
operator|==
name|TYLOG
operator|||
name|rt
operator|==
name|TYLOG
condition|)
name|exprerr
argument_list|(
literal|"relational involving logicals"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|lt
operator|==
name|TYCOMPLEX
operator|||
name|rt
operator|==
name|TYCOMPLEX
operator|)
operator|&&
name|o
operator|!=
name|OPEQ
operator|&&
name|o
operator|!=
name|OPNE
condition|)
name|exprerr
argument_list|(
literal|"order comparison of complex numbers"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lt
operator|!=
name|rt
condition|)
block|{
if|if
condition|(
name|lt
operator|==
name|TYINT
condition|)
name|p
operator|->
name|leftp
operator|=
name|coerce
argument_list|(
name|rt
argument_list|,
name|l
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rt
operator|==
name|TYINT
condition|)
name|p
operator|->
name|rightp
operator|=
name|coerce
argument_list|(
name|lt
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TLOGOP
case|:
name|ckdcl
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ckdcl
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|vtype
operator|!=
name|TYLOG
condition|)
block|{
name|exprerr
argument_list|(
literal|"non-logical operand of logical operator"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
case|case
name|TNOTOP
case|:
name|ckdcl
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|vtype
operator|!=
name|TYLOG
condition|)
block|{
name|exprerr
argument_list|(
literal|"non-logical operand of logical operator"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|vtype
operator|=
name|TYLOG
expr_stmt|;
break|break;
case|case
name|TNEGOP
case|:
name|ckdcl
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|lt
operator|=
name|l
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|lt
operator|!=
name|TYINT
operator|&&
name|lt
operator|!=
name|TYREAL
operator|&&
name|lt
operator|!=
name|TYLREAL
operator|&&
name|lt
operator|!=
name|TYCOMPLEX
condition|)
block|{
name|exprerr
argument_list|(
literal|"impossible unary + or - operation"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|->
name|vtype
operator|=
name|lt
expr_stmt|;
break|break;
case|case
name|TCALL
case|:
name|p
operator|->
name|vtype
operator|=
name|l
operator|->
name|vtype
expr_stmt|;
name|p
operator|->
name|vtypep
operator|=
name|l
operator|->
name|vtypep
expr_stmt|;
break|break;
case|case
name|TASGNOP
case|:
name|ckdcl
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ckdcl
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|lt
operator|=
name|l
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|lt
operator|==
name|TYFIELD
condition|)
name|lt
operator|=
name|TYINT
expr_stmt|;
name|rt
operator|=
name|r
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|lt
operator|==
name|TYCHAR
operator|||
name|rt
operator|==
name|TYCHAR
operator|||
name|lt
operator|==
name|TYLOG
operator|||
name|rt
operator|==
name|TYLOG
condition|)
block|{
if|if
condition|(
name|lt
operator|!=
name|rt
condition|)
block|{
name|exprerr
argument_list|(
literal|"illegal assignment"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|lt
operator|==
name|TYSTRUCT
operator|||
name|rt
operator|==
name|TYSTRUCT
condition|)
block|{
if|if
condition|(
name|lt
operator|!=
name|rt
operator|||
name|l
operator|->
name|vtypep
operator|->
name|strsize
operator|!=
name|r
operator|->
name|vtypep
operator|->
name|strsize
operator|||
name|l
operator|->
name|vtypep
operator|->
name|stralign
operator|!=
name|r
operator|->
name|vtypep
operator|->
name|stralign
condition|)
block|{
name|exprerr
argument_list|(
literal|"illegal structure assignment"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|lt
operator|==
name|TYCOMPLEX
operator|||
name|rt
operator|==
name|TYCOMPLEX
operator|)
operator|&&
name|lt
operator|!=
name|rt
condition|)
comment|/*			p->rightp = r = coerce(lt, r) */
empty_stmt|;
name|p
operator|->
name|vtype
operator|=
name|lt
expr_stmt|;
name|p
operator|->
name|vtypep
operator|=
name|l
operator|->
name|vtypep
expr_stmt|;
break|break;
case|case
name|TCONST
case|:
case|case
name|TLIST
case|:
case|case
name|TREPOP
case|:
break|break;
default|default:
name|badtag
argument_list|(
literal|"mknode"
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
name|err
label|:
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
end_function

begin_macro
name|ckdcl
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|ptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|->
name|vtype
operator|==
name|TYUNDEFINED
operator|||
operator|(
name|p
operator|->
name|tag
operator|==
name|TNAME
operator|&&
name|p
operator|->
name|vdcldone
operator|==
literal|0
operator|&&
name|p
operator|->
name|vadjdim
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*debug*/
name|printf
argument_list|(
literal|"tag=%d, typed=%d\n"
argument_list|,
name|p
operator|->
name|tag
argument_list|,
name|p
operator|->
name|vtype
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"untyped subexpression"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TNAME
condition|)
name|setvproc
argument_list|(
name|p
argument_list|,
name|PROCNO
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_function
name|ptr
name|mkvar
parameter_list|(
name|p
parameter_list|)
specifier|register
name|ptr
name|p
decl_stmt|;
block|{
specifier|register
name|ptr
name|q
decl_stmt|;
name|TEST
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"mkvar(%s), blk %d\n"
argument_list|,
name|p
operator|->
name|namep
argument_list|,
name|blklevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|blklevel
operator|>
name|blklevel
condition|)
name|p
operator|->
name|blklevel
operator|=
name|blklevel
expr_stmt|;
if|if
condition|(
name|instruct
operator|||
name|p
operator|->
name|varp
operator|==
literal|0
operator|||
name|p
operator|->
name|varp
operator|->
name|blklevel
operator|<
name|blklevel
condition|)
block|{
name|q
operator|=
name|allexpblock
argument_list|()
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TNAME
expr_stmt|;
name|q
operator|->
name|sthead
operator|=
name|p
expr_stmt|;
name|q
operator|->
name|blklevel
operator|=
name|blklevel
expr_stmt|;
if|if
condition|(
operator|!
name|instruct
condition|)
operator|++
name|ndecl
index|[
name|blklevel
index|]
expr_stmt|;
block|}
else|else
name|q
operator|=
name|p
operator|->
name|varp
expr_stmt|;
if|if
condition|(
operator|!
name|instruct
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|varp
operator|&&
name|p
operator|->
name|varp
operator|->
name|blklevel
operator|<
name|blklevel
condition|)
name|hide
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|varp
operator|==
literal|0
condition|)
name|p
operator|->
name|varp
operator|=
name|q
expr_stmt|;
block|}
name|p
operator|->
name|tag
operator|=
name|TNAME
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|mkstruct
parameter_list|(
name|v
parameter_list|,
name|s
parameter_list|)
specifier|register
name|ptr
name|v
decl_stmt|;
name|ptr
name|s
decl_stmt|;
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|typeblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|sthead
operator|=
name|v
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TSTRUCT
expr_stmt|;
name|p
operator|->
name|blklevel
operator|=
name|blklevel
expr_stmt|;
name|p
operator|->
name|strdesc
operator|=
name|s
expr_stmt|;
name|offsets
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
block|{
name|v
operator|->
name|blklevel
operator|=
name|blklevel
expr_stmt|;
operator|++
name|ndecl
index|[
name|blklevel
index|]
expr_stmt|;
name|v
operator|->
name|varp
operator|=
name|p
expr_stmt|;
block|}
else|else
name|temptypelist
operator|=
name|mkchain
argument_list|(
name|p
argument_list|,
name|temptypelist
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|mkcall
parameter_list|(
name|fn1
parameter_list|,
name|args
parameter_list|)
name|ptr
name|fn1
decl_stmt|,
name|args
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|first
decl_stmt|;
specifier|register
name|ptr
name|funct
decl_stmt|,
name|p
decl_stmt|,
name|q
decl_stmt|;
name|ptr
name|r
decl_stmt|;
if|if
condition|(
name|fn1
operator|->
name|tag
operator|==
name|TERROR
condition|)
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
elseif|else
if|if
condition|(
name|fn1
operator|->
name|tag
operator|==
name|TNAME
condition|)
block|{
name|funct
operator|=
name|fn1
operator|->
name|sthead
operator|->
name|varp
expr_stmt|;
name|frexpblock
argument_list|(
name|fn1
argument_list|)
expr_stmt|;
block|}
else|else
name|funct
operator|=
name|fn1
expr_stmt|;
if|if
condition|(
name|funct
operator|->
name|vclass
operator|!=
literal|0
operator|&&
name|funct
operator|->
name|vclass
operator|!=
name|CLARG
condition|)
block|{
name|exprerr
argument_list|(
literal|"invalid invocation of %s"
argument_list|,
name|funct
operator|->
name|sthead
operator|->
name|namep
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
else|else
name|extname
argument_list|(
name|funct
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
for|for
control|(
name|p
operator|=
name|args
operator|->
name|leftp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
block|{
name|q
operator|=
name|p
operator|->
name|datap
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|->
name|tag
operator|==
name|TCALL
operator|&&
name|q
operator|->
name|vtype
operator|==
name|TYUNDEFINED
operator|)
operator|||
operator|(
name|q
operator|->
name|tag
operator|==
name|TNAME
operator|&&
name|q
operator|->
name|vdcldone
operator|==
literal|0
operator|)
condition|)
name|dclit
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TNAME
operator|&&
name|q
operator|->
name|vproc
operator|==
name|PROCUNKNOWN
condition|)
name|setvproc
argument_list|(
name|q
argument_list|,
name|PROCNO
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|vtype
operator|==
name|TYSTRUCT
condition|)
block|{
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFTNTYPES
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|q
operator|->
name|vbase
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|r
operator|=
name|cpexpr
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|p
operator|->
name|datap
operator|=
name|r
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|p
operator|=
name|p
operator|->
name|nextp
operator|=
name|mkchain
argument_list|(
name|r
argument_list|,
name|p
operator|->
name|nextp
argument_list|)
expr_stmt|;
name|r
operator|->
name|vtype
operator|=
name|ftnefl
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NFTNTYPES
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|i
operator|!=
name|j
condition|)
name|r
operator|->
name|vbase
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|frexpblock
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|mknode
argument_list|(
name|TCALL
argument_list|,
literal|0
argument_list|,
name|cpexpr
argument_list|(
name|funct
argument_list|)
argument_list|,
name|args
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|mkcase
argument_list|(
argument|p
argument_list|,
argument|here
argument_list|)
end_macro

begin_decl_stmt
name|ptr
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|here
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ptr
name|q
decl_stmt|,
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|thisctl
init|;
name|s
operator|!=
literal|0
operator|&&
name|s
operator|->
name|subtype
operator|!=
name|STSWITCH
condition|;
name|s
operator|=
name|s
operator|->
name|prevctl
control|)
empty_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
operator|||
operator|(
name|here
operator|&&
name|s
operator|!=
name|thisctl
operator|)
condition|)
block|{
name|laberr
argument_list|(
literal|"invalid case label location"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|q
operator|=
name|s
operator|->
name|loopctl
init|;
name|q
operator|!=
literal|0
operator|&&
operator|!
name|eqcon
argument_list|(
name|p
argument_list|,
name|q
operator|->
name|casexpr
argument_list|)
condition|;
name|q
operator|=
name|q
operator|->
name|nextcase
control|)
empty_stmt|;
if|if
condition|(
name|q
operator|==
literal|0
condition|)
block|{
name|q
operator|=
name|ALLOC
argument_list|(
name|caseblock
argument_list|)
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TCASE
expr_stmt|;
name|q
operator|->
name|casexpr
operator|=
name|p
expr_stmt|;
name|q
operator|->
name|labelno
operator|=
operator|(
name|here
condition|?
name|thislab
argument_list|()
else|:
name|nextlab
argument_list|()
operator|)
expr_stmt|;
name|q
operator|->
name|nextcase
operator|=
name|s
operator|->
name|loopctl
expr_stmt|;
name|s
operator|->
name|loopctl
operator|=
name|q
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|here
condition|)
if|if
condition|(
name|thisexec
operator|->
name|labelno
operator|==
literal|0
condition|)
name|thisexec
operator|->
name|labelno
operator|=
name|q
operator|->
name|labelno
expr_stmt|;
elseif|else
if|if
condition|(
name|thisexec
operator|->
name|labelno
operator|!=
name|q
operator|->
name|labelno
condition|)
block|{
name|exnull
argument_list|()
expr_stmt|;
name|thisexec
operator|->
name|labelno
operator|=
name|q
operator|->
name|labelno
expr_stmt|;
name|thisexec
operator|->
name|labused
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|here
condition|)
if|if
condition|(
name|q
operator|->
name|labdefined
condition|)
name|laberr
argument_list|(
literal|"multiply defined case"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
else|else
name|q
operator|->
name|labdefined
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|q
operator|->
name|labelno
operator|)
return|;
block|}
end_block

begin_function
name|ptr
name|mkilab
parameter_list|(
name|p
parameter_list|)
name|ptr
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|,
name|l
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TCONST
operator|||
name|p
operator|->
name|vtype
operator|!=
name|TYINT
condition|)
block|{
name|execerr
argument_list|(
literal|"invalid label"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|s
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|s
operator|=
name|p
operator|->
name|leftp
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
operator|++
name|s
expr_stmt|;
name|sprintf
argument_list|(
name|l
argument_list|,
literal|"#%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|TEST
name|fprintf
argument_list|(
name|diagfile
argument_list|,
literal|"numeric label = %s\n"
argument_list|,
name|l
argument_list|)
decl_stmt|;
return|return
operator|(
name|mkname
argument_list|(
name|l
argument_list|)
operator|)
return|;
block|}
end_function

begin_macro
name|mklabel
argument_list|(
argument|p
argument_list|,
argument|here
argument_list|)
end_macro

begin_decl_stmt
name|ptr
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|here
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ptr
name|q
decl_stmt|;
if|if
condition|(
name|q
operator|=
name|p
operator|->
name|varp
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|tag
operator|!=
name|TLABEL
condition|)
name|laberr
argument_list|(
literal|"%s is already a nonlabel\n"
argument_list|,
name|p
operator|->
name|namep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|labinacc
condition|)
name|warn1
argument_list|(
literal|"label %s is inaccessible"
argument_list|,
name|p
operator|->
name|namep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|here
condition|)
if|if
condition|(
name|q
operator|->
name|labdefined
condition|)
name|laberr
argument_list|(
literal|"%s is already defined\n"
argument_list|,
name|p
operator|->
name|namep
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|blklevel
operator|>
name|q
operator|->
name|blklevel
condition|)
name|laberr
argument_list|(
literal|"%s is illegally placed\n"
argument_list|,
name|p
operator|->
name|namep
argument_list|)
expr_stmt|;
else|else
block|{
name|q
operator|->
name|labdefined
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|thisexec
operator|->
name|labelno
operator|==
literal|0
condition|)
name|thisexec
operator|->
name|labelno
operator|=
name|q
operator|->
name|labelno
expr_stmt|;
elseif|else
if|if
condition|(
name|thisexec
operator|->
name|labelno
operator|!=
name|q
operator|->
name|labelno
condition|)
block|{
name|exnull
argument_list|()
expr_stmt|;
name|thisexec
operator|->
name|labelno
operator|=
name|q
operator|->
name|labelno
expr_stmt|;
name|thisexec
operator|->
name|labused
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|q
operator|=
name|ALLOC
argument_list|(
name|labelblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|varp
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TLABEL
expr_stmt|;
name|q
operator|->
name|subtype
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|blklevel
operator|=
name|blklevel
expr_stmt|;
operator|++
name|ndecl
index|[
name|blklevel
index|]
expr_stmt|;
name|q
operator|->
name|labdefined
operator|=
name|here
expr_stmt|;
name|q
operator|->
name|labelno
operator|=
operator|(
name|here
condition|?
name|thislab
argument_list|()
else|:
name|nextlab
argument_list|()
operator|)
expr_stmt|;
name|q
operator|->
name|sthead
operator|=
name|p
expr_stmt|;
block|}
return|return
operator|(
name|q
operator|->
name|labelno
operator|)
return|;
block|}
end_block

begin_macro
name|thislab
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|thisexec
operator|->
name|labelno
operator|==
literal|0
condition|)
name|thisexec
operator|->
name|labelno
operator|=
name|nextlab
argument_list|()
expr_stmt|;
return|return
operator|(
name|thisexec
operator|->
name|labelno
operator|)
return|;
block|}
end_block

begin_macro
name|nextlab
argument_list|()
end_macro

begin_block
block|{
name|stnos
index|[
operator|++
name|labno
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|labno
operator|)
return|;
block|}
end_block

begin_macro
name|nextindif
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|++
name|nxtindif
operator|<
name|MAXINDIFS
condition|)
return|return
operator|(
name|nxtindif
operator|)
return|;
name|fatal
argument_list|(
literal|"too many indifs"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mkkeywd
argument_list|(
argument|s
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
specifier|register
name|ptr
name|q
decl_stmt|;
name|p
operator|=
name|name
argument_list|(
name|s
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|keyblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TKEYWORD
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TKEYWORD
expr_stmt|;
name|p
operator|->
name|subtype
operator|=
name|n
expr_stmt|;
name|q
operator|->
name|subtype
operator|=
name|n
expr_stmt|;
name|p
operator|->
name|blklevel
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|varp
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|sthead
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_function
name|ptr
name|mkdef
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|v
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
specifier|register
name|ptr
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|=
name|name
argument_list|(
name|s
argument_list|,
literal|1
argument_list|)
condition|)
if|if
condition|(
name|p
operator|->
name|blklevel
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|blklevel
operator|>
literal|0
condition|)
name|hide
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TDEFINE
condition|)
name|dclerr
argument_list|(
literal|"attempt to DEFINE a variable name"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|v
argument_list|,
operator|(
name|q
operator|=
name|p
operator|->
name|varp
operator|)
operator|->
name|valp
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"macro value replaced"
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|q
operator|->
name|valp
argument_list|)
expr_stmt|;
name|q
operator|->
name|valp
operator|=
name|copys
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
else|else
block|{
name|dclerr
argument_list|(
literal|"type already defined"
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
else|else
name|p
operator|=
name|name
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q
operator|=
name|ALLOC
argument_list|(
name|defblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TDEFINE
expr_stmt|;
name|q
operator|->
name|tag
operator|=
name|TDEFINE
expr_stmt|;
name|p
operator|->
name|blklevel
operator|=
name|q
operator|->
name|blklevel
operator|=
operator|(
name|blklevel
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
expr_stmt|;
name|q
operator|->
name|sthead
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|varp
operator|=
name|q
expr_stmt|;
name|p
operator|->
name|varp
operator|->
name|valp
operator|=
name|copys
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_macro
name|mkknown
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
name|p
operator|=
name|ALLOC
argument_list|(
name|knownname
argument_list|)
expr_stmt|;
name|p
operator|->
name|nextfunct
operator|=
name|knownlist
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TKNOWNFUNCT
expr_stmt|;
name|knownlist
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|funcname
operator|=
name|s
expr_stmt|;
name|p
operator|->
name|functype
operator|=
name|t
expr_stmt|;
block|}
end_block

begin_function
name|ptr
name|mkint
parameter_list|(
name|k
parameter_list|)
name|int
name|k
decl_stmt|;
block|{
return|return
operator|(
name|mkconst
argument_list|(
name|TYINT
argument_list|,
name|convic
argument_list|(
name|k
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|mkconst
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|int
name|t
decl_stmt|;
name|ptr
name|p
decl_stmt|;
block|{
name|ptr
name|q
decl_stmt|;
name|q
operator|=
name|mknode
argument_list|(
name|TCONST
argument_list|,
literal|0
argument_list|,
name|copys
argument_list|(
name|p
argument_list|)
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|TYCHAR
condition|)
name|q
operator|->
name|vtypep
operator|=
name|mkint
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|mkimcon
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
name|int
name|t
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|ptr
name|q
decl_stmt|;
name|char
modifier|*
name|zero
decl_stmt|,
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|zero
operator|=
operator|(
name|t
operator|==
name|TYCOMPLEX
condition|?
literal|"0."
else|:
literal|"0d0"
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"(%s,%s)"
argument_list|,
name|zero
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
name|mknode
argument_list|(
name|TCONST
argument_list|,
literal|0
argument_list|,
name|copys
argument_list|(
name|buff
argument_list|)
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|mkarrow
parameter_list|(
name|p
parameter_list|,
name|t
parameter_list|)
specifier|register
name|ptr
name|p
decl_stmt|;
name|ptr
name|t
decl_stmt|;
block|{
specifier|register
name|ptr
name|q
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|vsubs
operator|==
literal|0
condition|)
if|if
condition|(
name|p
operator|->
name|vdim
operator|==
literal|0
operator|&&
name|p
operator|->
name|vtype
operator|!=
name|TYCHAR
operator|&&
name|p
operator|->
name|vtype
operator|!=
name|TYSTRUCT
condition|)
block|{
name|exprerr
argument_list|(
literal|"need an aggregate to the left of arrow"
argument_list|,
name|CNULL
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|vdim
condition|)
block|{
name|s
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|vdim
operator|->
name|datap
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
name|s
operator|=
name|mkchain
argument_list|(
name|mkint
argument_list|(
literal|1
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|subscript
argument_list|(
name|p
argument_list|,
name|mknode
argument_list|(
name|TLIST
argument_list|,
literal|0
argument_list|,
name|s
argument_list|,
name|PNULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|vtype
operator|=
name|TYSTRUCT
expr_stmt|;
name|p
operator|->
name|vtypep
operator|=
name|t
operator|->
name|varp
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_macro
name|mkequiv
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|ptr
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|ptr
name|q
decl_stmt|,
name|t
decl_stmt|;
name|int
name|first
decl_stmt|;
name|swii
argument_list|(
name|iefile
argument_list|)
expr_stmt|;
name|putic
argument_list|(
name|ICBEGIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putic
argument_list|(
name|ICINDENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putic
argument_list|(
name|ICKEYWORD
argument_list|,
name|FEQUIVALENCE
argument_list|)
expr_stmt|;
name|putic
argument_list|(
name|ICOP
argument_list|,
name|OPLPAR
argument_list|)
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|0
expr_stmt|;
else|else
name|putic
argument_list|(
name|ICOP
argument_list|,
name|OPCOMMA
argument_list|)
expr_stmt|;
name|prexpr
argument_list|(
name|t
operator|=
name|simple
argument_list|(
name|LVAL
argument_list|,
name|q
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|putic
argument_list|(
name|ICOP
argument_list|,
name|OPRPAR
argument_list|)
expr_stmt|;
name|swii
argument_list|(
name|icfile
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mkgeneric
argument_list|(
argument|gname
argument_list|,
argument|atype
argument_list|,
argument|fname
argument_list|,
argument|ftype
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|gname
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|atype
decl_stmt|,
name|ftype
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
name|ptr
name|generic
parameter_list|()
function_decl|;
if|if
condition|(
name|p
operator|=
name|generic
argument_list|(
name|gname
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|genfname
index|[
name|atype
index|]
condition|)
name|fatal1
argument_list|(
literal|"generic name already defined"
argument_list|,
name|gname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|ALLOC
argument_list|(
name|genblock
argument_list|)
expr_stmt|;
name|p
operator|->
name|tag
operator|=
name|TGENERIC
expr_stmt|;
name|p
operator|->
name|nextgenf
operator|=
name|generlist
expr_stmt|;
name|generlist
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|genname
operator|=
name|gname
expr_stmt|;
block|}
name|p
operator|->
name|genfname
index|[
name|atype
index|]
operator|=
name|fname
expr_stmt|;
name|p
operator|->
name|genftype
index|[
name|atype
index|]
operator|=
name|ftype
expr_stmt|;
block|}
end_block

begin_function
name|ptr
name|generic
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|generlist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextgenf
control|)
if|if
condition|(
name|equals
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|genname
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|knownfunct
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|ptr
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|knownlist
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextfunct
control|)
if|if
condition|(
name|equals
argument_list|(
name|s
argument_list|,
name|p
operator|->
name|funcname
argument_list|)
condition|)
return|return
operator|(
name|p
operator|->
name|functype
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|ptr
name|funcinv
parameter_list|(
name|p
parameter_list|)
specifier|register
name|ptr
name|p
decl_stmt|;
block|{
name|ptr
name|fp
decl_stmt|,
name|fp1
decl_stmt|;
specifier|register
name|ptr
name|g
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|t
decl_stmt|;
name|int
name|vt
decl_stmt|;
if|if
condition|(
name|g
operator|=
name|generic
argument_list|(
name|s
operator|=
name|p
operator|->
name|leftp
operator|->
name|sthead
operator|->
name|namep
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|rightp
operator|->
name|tag
operator|==
name|TLIST
operator|&&
name|p
operator|->
name|rightp
operator|->
name|leftp
operator|&&
operator|(
operator|(
name|vt
operator|=
name|typearg
argument_list|(
name|p
operator|->
name|rightp
operator|->
name|leftp
argument_list|)
operator|)
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|t
operator|=
name|g
operator|->
name|genftype
index|[
name|vt
index|]
operator|)
condition|)
block|{
name|p
operator|->
name|leftp
operator|=
name|builtin
argument_list|(
name|t
argument_list|,
name|g
operator|->
name|genfname
index|[
name|vt
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dclerr
argument_list|(
literal|"improper use of generic function"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
block|}
name|fp
operator|=
name|p
operator|->
name|leftp
expr_stmt|;
name|setvproc
argument_list|(
name|fp
argument_list|,
name|PROCYES
argument_list|)
expr_stmt|;
name|fp1
operator|=
name|fp
operator|->
name|sthead
operator|->
name|varp
expr_stmt|;
name|s
operator|=
name|fp
operator|->
name|sthead
operator|->
name|namep
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|vtype
operator|==
name|TYUNDEFINED
operator|&&
name|fp
operator|->
name|vclass
operator|!=
name|CLARG
condition|)
if|if
condition|(
name|t
operator|=
name|knownfunct
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|p
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
name|setvproc
argument_list|(
name|fp
argument_list|,
name|PROCINTRINSIC
argument_list|)
expr_stmt|;
name|setvproc
argument_list|(
name|fp1
argument_list|,
name|PROCINTRINSIC
argument_list|)
expr_stmt|;
name|fp1
operator|->
name|vtype
operator|=
name|t
expr_stmt|;
name|builtin
argument_list|(
name|t
argument_list|,
name|fp1
operator|->
name|sthead
operator|->
name|namep
argument_list|)
expr_stmt|;
name|cpblock
argument_list|(
name|fp1
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|exprblock
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dclit
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|typearg
argument_list|(
name|p0
argument_list|)
specifier|register
name|chainp
name|p0
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|chainp
name|p
decl_stmt|;
specifier|register
name|int
name|vt
decl_stmt|,
name|maxt
decl_stmt|;
if|if
condition|(
name|p0
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|maxt
operator|=
name|p0
operator|->
name|datap
operator|->
name|vtype
expr_stmt|;
for|for
control|(
name|p
operator|=
name|p0
operator|->
name|nextp
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
if|if
condition|(
operator|(
name|vt
operator|=
name|p
operator|->
name|datap
operator|->
name|vtype
operator|)
operator|>
name|maxt
condition|)
name|maxt
operator|=
name|vt
expr_stmt|;
for|for
control|(
name|p
operator|=
name|p0
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|nextp
control|)
name|p
operator|->
name|datap
operator|=
name|coerce
argument_list|(
name|maxt
argument_list|,
name|p
operator|->
name|datap
argument_list|)
expr_stmt|;
return|return
operator|(
name|maxt
operator|)
return|;
block|}
end_block

begin_function
name|ptr
name|typexpr
parameter_list|(
name|t
parameter_list|,
name|e
parameter_list|)
specifier|register
name|ptr
name|t
decl_stmt|,
name|e
decl_stmt|;
block|{
name|ptr
name|e1
decl_stmt|;
name|int
name|etag
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|atdim
operator|!=
literal|0
operator|||
operator|(
name|e
operator|->
name|tag
operator|==
name|TLIST
operator|&&
name|t
operator|->
name|attype
operator|!=
name|TYCOMPLEX
operator|)
condition|)
goto|goto
name|typerr
goto|;
switch|switch
condition|(
name|t
operator|->
name|attype
condition|)
block|{
case|case
name|TYCOMPLEX
case|:
if|if
condition|(
name|e
operator|->
name|tag
operator|==
name|TLIST
condition|)
if|if
condition|(
name|e
operator|->
name|leftp
operator|==
literal|0
operator|||
name|e
operator|->
name|leftp
operator|->
name|nextp
operator|==
literal|0
operator|||
name|e
operator|->
name|leftp
operator|->
name|nextp
operator|->
name|nextp
operator|!=
literal|0
condition|)
block|{
name|exprerr
argument_list|(
literal|"bad conversion to complex"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
else|else
block|{
name|e
operator|->
name|leftp
operator|->
name|datap
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|e
operator|->
name|leftp
operator|->
name|datap
argument_list|)
expr_stmt|;
name|e
operator|->
name|leftp
operator|->
name|nextp
operator|->
name|datap
operator|=
name|simple
argument_list|(
name|RVAL
argument_list|,
name|e
operator|->
name|leftp
operator|->
name|nextp
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|isconst
argument_list|(
name|e
operator|->
name|leftp
operator|->
name|datap
argument_list|)
operator|&&
name|isconst
argument_list|(
name|e
operator|->
name|leftp
operator|->
name|nextp
operator|->
name|datap
argument_list|)
condition|)
return|return
operator|(
name|compconst
argument_list|(
name|e
argument_list|)
operator|)
return|;
name|e1
operator|=
name|mkcall
argument_list|(
name|builtin
argument_list|(
name|TYCOMPLEX
argument_list|,
literal|"cmplx"
argument_list|)
argument_list|,
name|arg2
argument_list|(
name|coerce
argument_list|(
name|TYREAL
argument_list|,
name|e
operator|->
name|leftp
operator|->
name|datap
argument_list|)
argument_list|,
name|coerce
argument_list|(
name|TYREAL
argument_list|,
name|e
operator|->
name|leftp
operator|->
name|nextp
operator|->
name|datap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
operator|(
name|e
operator|->
name|leftp
operator|)
argument_list|)
expr_stmt|;
name|frexpblock
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|e1
operator|)
return|;
block|}
case|case
name|TYINT
case|:
case|case
name|TYREAL
case|:
case|case
name|TYLREAL
case|:
case|case
name|TYLOG
case|:
case|case
name|TYFIELD
case|:
name|e
operator|=
name|coerce
argument_list|(
name|t
operator|->
name|attype
argument_list|,
name|simple
argument_list|(
name|RVAL
argument_list|,
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|etag
operator|=
name|e
operator|->
name|tag
expr_stmt|;
if|if
condition|(
name|etag
operator|==
name|TAROP
operator|||
name|etag
operator|==
name|TLOGOP
operator|||
name|etag
operator|==
name|TRELOP
condition|)
name|e
operator|->
name|needpar
operator|=
name|YES
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
case|case
name|TYCHAR
case|:
case|case
name|TYSTRUCT
case|:
goto|goto
name|typerr
goto|;
block|}
name|typerr
label|:
name|exprerr
argument_list|(
literal|"typexpr not fully implemented"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|compconst
parameter_list|(
name|p
parameter_list|)
specifier|register
name|ptr
name|p
decl_stmt|;
block|{
specifier|register
name|ptr
name|a
decl_stmt|,
name|b
decl_stmt|;
name|int
name|as
decl_stmt|,
name|bs
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|prec
operator|=
name|TYREAL
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|leftp
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|p
operator|->
name|datap
operator|->
name|vtype
operator|==
name|TYLREAL
condition|)
name|prec
operator|=
name|TYLREAL
expr_stmt|;
name|a
operator|=
name|coerce
argument_list|(
name|TYLREAL
argument_list|,
name|p
operator|->
name|datap
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|nextp
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nextp
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|p
operator|->
name|datap
operator|->
name|vtype
operator|==
name|TYLREAL
condition|)
name|a
operator|=
name|coerce
argument_list|(
name|prec
operator|=
name|TYLREAL
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|coerce
argument_list|(
name|TYLREAL
argument_list|,
name|p
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|tag
operator|==
name|TNEGOP
condition|)
block|{
name|as
operator|=
literal|'-'
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|leftp
expr_stmt|;
block|}
else|else
name|as
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|tag
operator|==
name|TNEGOP
condition|)
block|{
name|bs
operator|=
literal|'-'
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|leftp
expr_stmt|;
block|}
else|else
name|bs
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|tag
operator|!=
name|TCONST
operator|||
name|a
operator|->
name|vtype
operator|!=
name|prec
operator|||
name|b
operator|->
name|tag
operator|!=
name|TCONST
operator|||
name|b
operator|->
name|vtype
operator|!=
name|prec
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|prec
operator|==
name|TYLREAL
operator|&&
name|tailor
operator|.
name|lngcxtype
operator|==
name|NULL
condition|)
block|{
name|ptr
name|q
decl_stmt|,
name|e1
decl_stmt|,
name|e2
decl_stmt|;
name|struct
name|dimblock
modifier|*
name|dp
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"_const%d"
argument_list|,
operator|++
name|constno
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkvar
argument_list|(
name|mkname
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|TYLREAL
expr_stmt|;
name|dclit
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ALLOC
argument_list|(
name|dimblock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|upperb
operator|=
name|mkint
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|q
operator|->
name|vdim
operator|=
name|mkchain
argument_list|(
name|dp
argument_list|,
name|CHNULL
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%c%s"
argument_list|,
name|as
argument_list|,
name|a
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|e1
operator|=
name|mkconst
argument_list|(
name|TYLREAL
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"%c%s"
argument_list|,
name|bs
argument_list|,
name|b
operator|->
name|leftp
argument_list|)
expr_stmt|;
name|e2
operator|=
name|mkconst
argument_list|(
name|TYLREAL
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|mkinit
argument_list|(
name|q
argument_list|,
name|mknode
argument_list|(
name|TLIST
argument_list|,
literal|0
argument_list|,
name|mkchain
argument_list|(
name|e1
argument_list|,
name|mkchain
argument_list|(
name|e2
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
argument_list|,
name|PNULL
argument_list|)
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|q
operator|->
name|vdim
argument_list|)
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|TYLCOMPLEX
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"(%c%s, %c%s)"
argument_list|,
name|as
argument_list|,
name|a
operator|->
name|leftp
argument_list|,
name|bs
argument_list|,
name|b
operator|->
name|leftp
argument_list|)
expr_stmt|;
return|return
operator|(
name|mkconst
argument_list|(
name|TYCOMPLEX
argument_list|,
name|msg
argument_list|)
operator|)
return|;
block|}
name|err
label|:
name|exprerr
argument_list|(
literal|"invalid complex constant"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|errnode
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|mkchcon
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|ptr
name|q
decl_stmt|;
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"_const%d"
argument_list|,
operator|++
name|constno
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkvar
argument_list|(
name|mkname
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|vtype
operator|=
name|TYCHAR
expr_stmt|;
name|q
operator|->
name|vtypep
operator|=
name|mkint
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|mkinit
argument_list|(
name|q
argument_list|,
name|mkconst
argument_list|(
name|TYCHAR
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_function
name|ptr
name|mksub1
parameter_list|()
block|{
return|return
operator|(
name|mknode
argument_list|(
name|TLIST
argument_list|,
literal|0
argument_list|,
name|mkchain
argument_list|(
name|mkint
argument_list|(
literal|1
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
argument_list|,
name|PNULL
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

