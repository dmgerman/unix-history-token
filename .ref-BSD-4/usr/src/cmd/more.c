begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|char
modifier|*
name|SCCS_ID
init|=
literal|"@(#)more.c	4.1 (Berkeley) 10/16/80"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** more.c - General purpose tty output filter and file perusal program ** **	by Eric Shienbrood, UC Berkeley */
end_comment

begin_include
include|#
directive|include
file|<whoami.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_include
include|#
directive|include
file|<retrofit.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<local/uparm.h>
end_include

begin_comment
comment|/* Help file will eventually go in libpath(more.help) on all systems */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INGRES
end_ifdef

begin_define
define|#
directive|define
name|VI
value|"/usr/bin/vi"
end_define

begin_define
define|#
directive|define
name|HELPFILE
value|"/mntp/doucette/more/more.help"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INGRES
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|HELPFILE
end_ifndef

begin_define
define|#
directive|define
name|HELPFILE
value|libpath(more.help)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VI
value|binpath(vi)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Fopen
parameter_list|(
name|s
parameter_list|,
name|m
parameter_list|)
value|(Currline = 0,file_pos=0,fopen(s,m))
end_define

begin_define
define|#
directive|define
name|Ftell
parameter_list|(
name|f
parameter_list|)
value|file_pos
end_define

begin_define
define|#
directive|define
name|Fseek
parameter_list|(
name|f
parameter_list|,
name|off
parameter_list|)
value|(file_pos=off,fseek(f,off,0))
end_define

begin_define
define|#
directive|define
name|Getc
parameter_list|(
name|f
parameter_list|)
value|(++file_pos, getc(f))
end_define

begin_define
define|#
directive|define
name|Ungetc
parameter_list|(
name|c
parameter_list|,
name|f
parameter_list|)
value|(--file_pos, ungetc(c,f))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_define
define|#
directive|define
name|MBIT
value|RAW
end_define

begin_define
define|#
directive|define
name|CBREAK
value|~RAW
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MBIT
value|CBREAK
end_define

begin_define
define|#
directive|define
name|stty
parameter_list|(
name|fd
parameter_list|,
name|argp
parameter_list|)
value|ioctl(fd,TIOCSETN,argp)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TBUFSIZ
value|1024
end_define

begin_define
define|#
directive|define
name|LINSIZ
value|256
end_define

begin_define
define|#
directive|define
name|ctrl
parameter_list|(
name|letter
parameter_list|)
value|('letter'& 077)
end_define

begin_define
define|#
directive|define
name|RUBOUT
value|'\177'
end_define

begin_define
define|#
directive|define
name|ESC
value|'\033'
end_define

begin_define
define|#
directive|define
name|QUIT
value|'\034'
end_define

begin_decl_stmt
name|struct
name|sgttyb
name|otty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|file_pos
decl_stmt|,
name|file_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fnum
decl_stmt|,
name|no_intty
decl_stmt|,
name|no_tty
decl_stmt|,
name|slow_tty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dum_opt
decl_stmt|,
name|dlines
decl_stmt|,
name|onquit
argument_list|()
decl_stmt|,
name|end_it
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_function_decl
name|int
name|onsusp
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|nscroll
init|=
literal|11
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of lines scrolled by 'd' */
end_comment

begin_decl_stmt
name|int
name|fold_opt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fold long lines */
end_comment

begin_decl_stmt
name|int
name|stop_opt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stop after form feeds */
end_comment

begin_decl_stmt
name|int
name|promptlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Currline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line we are currently at */
end_comment

begin_decl_stmt
name|int
name|startup
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|firstf
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|notell
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bad_so
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if overwriting does not turn off standout */
end_comment

begin_decl_stmt
name|int
name|inwait
decl_stmt|,
name|Pause
decl_stmt|,
name|errors
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|within
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we are within a file, 			false if we are between files */
end_comment

begin_decl_stmt
name|int
name|hard
decl_stmt|,
name|dumb
decl_stmt|,
name|noscroll
decl_stmt|,
name|hardtabs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|catch_susp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We should catch the SIGTSTP signal */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|fnames
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The list of file names */
end_comment

begin_decl_stmt
name|int
name|nfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of files left to process */
end_comment

begin_decl_stmt
name|char
modifier|*
name|shell
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name of the shell to use */
end_comment

begin_decl_stmt
name|int
name|shellp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A previous shell command exists */
end_comment

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|restore
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|obuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stdout buffer */
end_comment

begin_decl_stmt
name|char
name|Line
index|[
name|LINSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line buffer */
end_comment

begin_decl_stmt
name|int
name|Lpp
init|=
literal|24
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lines per page */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Clear
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clear screen */
end_comment

begin_decl_stmt
name|char
modifier|*
name|eraseln
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* erase line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Senter
decl_stmt|,
modifier|*
name|Sexit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enter and exit standout mode */
end_comment

begin_function_decl
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|Mcol
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of columns */
end_comment

begin_decl_stmt
name|int
name|Wrap
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if automargins */
end_comment

begin_function_decl
name|long
name|fseek
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
block|{
name|long
name|chrctr
decl_stmt|,
name|line
decl_stmt|;
block|}
name|context
struct|,
name|screen_start
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pad character */
end_comment

begin_decl_stmt
specifier|extern
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|left
decl_stmt|;
name|int
name|prnames
init|=
literal|0
decl_stmt|;
name|int
name|initopt
init|=
literal|0
decl_stmt|;
name|int
name|srchopt
init|=
literal|0
decl_stmt|;
name|int
name|clearit
init|=
literal|0
decl_stmt|;
name|int
name|initline
decl_stmt|;
name|char
name|initbuf
index|[
literal|80
index|]
decl_stmt|;
name|FILE
modifier|*
name|checkf
parameter_list|()
function_decl|;
name|nfiles
operator|=
name|argc
expr_stmt|;
name|fnames
operator|=
name|argv
expr_stmt|;
name|initterm
argument_list|()
expr_stmt|;
while|while
condition|(
operator|--
name|nfiles
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ch
operator|=
operator|(
operator|*
operator|++
name|fnames
operator|)
index|[
literal|0
index|]
operator|)
operator|==
literal|'-'
condition|)
block|{
for|for
control|(
name|s
operator|=
name|fnames
index|[
literal|0
index|]
operator|+
literal|1
operator|,
name|dlines
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|dlines
operator|=
name|dlines
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'d'
condition|)
name|dum_opt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'l'
condition|)
name|stop_opt
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'f'
condition|)
name|fold_opt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
name|s
operator|=
operator|*
name|fnames
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|s
operator|==
literal|'/'
condition|)
block|{
name|srchopt
operator|++
expr_stmt|;
for|for
control|(
operator|++
name|s
operator|,
name|p
operator|=
name|initbuf
init|;
name|p
operator|<
name|initbuf
operator|+
literal|79
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|;
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
name|initopt
operator|++
expr_stmt|;
for|for
control|(
name|initline
operator|=
literal|0
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|initline
operator|=
name|initline
operator|*
literal|10
operator|+
operator|*
name|s
operator|-
literal|'0'
expr_stmt|;
operator|--
name|initline
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|dlines
operator|==
literal|0
condition|)
name|dlines
operator|=
name|Lpp
operator|-
operator|(
name|noscroll
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
name|left
operator|=
name|dlines
expr_stmt|;
if|if
condition|(
name|nfiles
operator|>
literal|1
condition|)
name|prnames
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|no_intty
operator|&&
name|nfiles
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"Usage: "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|" [-dfln] [+linenum | +/pattern] name1 name2 ...\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|f
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|no_tty
condition|)
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|end_it
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
if|if
condition|(
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_DFL
condition|)
block|{
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|onsusp
argument_list|)
expr_stmt|;
name|catch_susp
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|no_intty
condition|)
block|{
if|if
condition|(
name|no_tty
condition|)
name|copy_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|ch
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
literal|'\f'
condition|)
name|doclear
argument_list|()
expr_stmt|;
else|else
block|{
name|Ungetc
argument_list|(
name|ch
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|noscroll
condition|)
name|doclear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|srchopt
condition|)
name|search
argument_list|(
name|initbuf
argument_list|,
name|stdin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|initopt
condition|)
name|skiplns
argument_list|(
name|initline
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|screen
argument_list|(
name|stdin
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
name|no_intty
operator|=
literal|0
expr_stmt|;
name|prnames
operator|++
expr_stmt|;
name|firstf
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|fnum
operator|<
name|nfiles
condition|)
block|{
if|if
condition|(
operator|(
name|f
operator|=
name|checkf
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|,
operator|&
name|clearit
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|context
operator|.
name|line
operator|=
name|context
operator|.
name|chrctr
operator|=
literal|0
expr_stmt|;
name|Currline
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|firstf
condition|)
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstf
condition|)
block|{
name|firstf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|srchopt
condition|)
name|search
argument_list|(
name|initbuf
argument_list|,
name|f
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|initopt
condition|)
name|skiplns
argument_list|(
name|initline
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fnum
operator|<
name|nfiles
operator|&&
operator|!
name|no_tty
condition|)
block|{
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
name|left
operator|=
name|command
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|noscroll
operator|||
name|clearit
condition|)
name|doclear
argument_list|()
expr_stmt|;
if|if
condition|(
name|prnames
condition|)
block|{
if|if
condition|(
name|bad_so
condition|)
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"::::::::::::::"
argument_list|)
expr_stmt|;
if|if
condition|(
name|promptlen
operator|>
literal|14
condition|)
name|erase
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s\n::::::::::::::\n"
argument_list|,
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|left
operator|>
name|Lpp
operator|-
literal|4
condition|)
name|left
operator|=
name|Lpp
operator|-
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|no_tty
condition|)
name|copy_file
argument_list|(
name|f
argument_list|)
expr_stmt|;
else|else
block|{
name|within
operator|++
expr_stmt|;
name|screen
argument_list|(
name|f
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|within
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|screen_start
operator|.
name|line
operator|=
name|screen_start
operator|.
name|chrctr
operator|=
literal|0L
expr_stmt|;
name|context
operator|.
name|line
operator|=
name|context
operator|.
name|chrctr
operator|=
literal|0L
expr_stmt|;
block|}
name|fnum
operator|++
expr_stmt|;
name|firstf
operator|=
literal|0
expr_stmt|;
block|}
name|reset_tty
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Check whether the file named by fs is an ASCII file which the user may ** access.  If it is, return the opened file. Otherwise return NULL. */
end_comment

begin_function
name|FILE
modifier|*
name|checkf
parameter_list|(
name|fs
parameter_list|,
name|clearfirst
parameter_list|)
specifier|register
name|char
modifier|*
name|fs
decl_stmt|;
name|int
modifier|*
name|clearfirst
decl_stmt|;
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
name|c
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|fs
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|S_IFDIR
condition|)
block|{
name|printf
argument_list|(
literal|"\n*** %s: directory ***\n\n"
argument_list|,
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|f
operator|=
name|Fopen
argument_list|(
name|fs
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
comment|/* Try to see whether it is an ASCII file */
switch|switch
condition|(
operator|(
name|c
operator||
operator|*
name|f
operator|->
name|_ptr
operator|<<
literal|8
operator|)
operator|&
literal|0177777
condition|)
block|{
case|case
literal|0405
case|:
case|case
literal|0407
case|:
case|case
literal|0410
case|:
case|case
literal|0411
case|:
case|case
literal|0413
case|:
case|case
literal|0177545
case|:
name|printf
argument_list|(
literal|"\n******** %s: Not a text file ********\n\n"
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\f'
condition|)
operator|*
name|clearfirst
operator|=
literal|1
expr_stmt|;
else|else
block|{
operator|*
name|clearfirst
operator|=
literal|0
expr_stmt|;
name|Ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|file_size
operator|=
name|stbuf
operator|.
name|st_size
operator|)
operator|==
literal|0
condition|)
name|file_size
operator|=
literal|0x7fffffffffffffffL
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ** A real function, for the tputs routine in termlib */
end_comment

begin_macro
name|putch
argument_list|(
argument|ch
argument_list|)
end_macro

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Print out the contents of the file f, one screenful at a time. */
end_comment

begin_define
define|#
directive|define
name|STOP
value|-10
end_define

begin_expr_stmt
name|screen
argument_list|(
name|f
argument_list|,
name|num_lines
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|num_lines
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|nchars
decl_stmt|;
name|int
name|length
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
name|num_lines
operator|>
literal|0
operator|&&
operator|!
name|Pause
condition|)
block|{
if|if
condition|(
operator|(
name|nchars
operator|=
name|getline
argument_list|(
name|f
argument_list|,
operator|&
name|length
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
if|if
condition|(
name|bad_so
operator|||
operator|(
name|Senter
operator|&&
operator|*
name|Senter
operator|==
literal|' '
operator|)
operator|&&
name|promptlen
operator|>
literal|0
condition|)
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|prbuf
argument_list|(
name|Line
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|<
name|promptlen
condition|)
name|erase
argument_list|(
name|nchars
argument_list|)
expr_stmt|;
comment|/* erase () sets promptlen to 0 */
else|else
name|promptlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nchars
operator|<
name|Mcol
operator|||
operator|!
name|fold_opt
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nchars
operator|==
name|STOP
condition|)
break|break;
name|num_lines
operator|--
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
operator|)
operator|==
name|EOF
condition|)
return|return;
name|Ungetc
argument_list|(
name|c
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|setjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
name|Pause
operator|=
literal|0
expr_stmt|;
name|startup
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|num_lines
operator|=
name|command
argument_list|(
name|NULL
argument_list|,
name|f
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|hard
operator|&&
name|promptlen
operator|>
literal|0
condition|)
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|noscroll
operator|&&
name|num_lines
operator|==
name|dlines
condition|)
name|doclear
argument_list|()
expr_stmt|;
name|screen_start
operator|.
name|line
operator|=
name|Currline
expr_stmt|;
name|screen_start
operator|.
name|chrctr
operator|=
name|Ftell
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ** Come here if a quit signal is received */
end_comment

begin_macro
name|onquit
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inwait
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|startup
condition|)
block|{
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|restore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|Pause
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dum_opt
operator|&&
name|notell
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"[Use q or Q to quit]"
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|promptlen
operator|+=
literal|20
expr_stmt|;
name|notell
operator|=
literal|0
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Clean up terminal state and exit. Also come here if interrupt signal received */
end_comment

begin_macro
name|end_it
argument_list|()
end_macro

begin_block
block|{
name|reset_tty
argument_list|()
expr_stmt|;
if|if
condition|(
name|promptlen
operator|>
literal|0
condition|)
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|copy_file
argument_list|(
name|f
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Simplified printf function */
end_comment

begin_expr_stmt
name|printf
argument_list|(
name|fmt
argument_list|,
name|args
argument_list|)
specifier|register
name|char
operator|*
name|fmt
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|argp
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|ccount
decl_stmt|;
name|ccount
operator|=
literal|0
expr_stmt|;
name|argp
operator|=
operator|&
name|args
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
condition|)
block|{
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'%'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ccount
operator|)
return|;
name|ccount
operator|++
expr_stmt|;
name|putchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'d'
case|:
name|ccount
operator|+=
name|printd
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|ccount
operator|+=
name|pr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|argp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|ccount
operator|++
expr_stmt|;
name|argp
operator|--
expr_stmt|;
name|putchar
argument_list|(
literal|'%'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
return|return
operator|(
name|ccount
operator|)
return|;
default|default:
break|break;
block|}
operator|++
name|argp
expr_stmt|;
block|}
return|return
operator|(
name|ccount
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** Print an integer as a string of decimal digits, ** returning the length of the print representation. */
end_comment

begin_macro
name|printd
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|a
decl_stmt|,
name|nchars
decl_stmt|;
if|if
condition|(
name|a
operator|=
name|n
operator|/
literal|10
condition|)
name|nchars
operator|=
literal|1
operator|+
name|printd
argument_list|(
name|a
argument_list|)
expr_stmt|;
else|else
name|nchars
operator|=
literal|1
expr_stmt|;
name|putchar
argument_list|(
name|n
operator|%
literal|10
operator|+
literal|'0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|nchars
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Put the print representation of an integer into a string */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sptr
decl_stmt|;
end_decl_stmt

begin_macro
name|scanstr
argument_list|(
argument|n
argument_list|,
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sptr
operator|=
name|str
expr_stmt|;
name|sprintf
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|*
name|sptr
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_macro
name|sprintf
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|int
name|a
decl_stmt|;
if|if
condition|(
name|a
operator|=
name|n
operator|/
literal|10
condition|)
name|sprintf
argument_list|(
name|a
argument_list|)
expr_stmt|;
operator|*
name|sptr
operator|++
operator|=
name|n
operator|%
literal|10
operator|+
literal|'0'
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|bell
init|=
name|ctrl
argument_list|(
name|G
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|strlen
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
condition|)
empty_stmt|;
return|return
operator|(
name|p
operator|-
name|s
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* See whether the last component of the path name "path" is equal to the ** string "string" */
end_comment

begin_macro
name|tailequ
argument_list|(
argument|path
argument_list|,
argument|string
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|path
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|tail
decl_stmt|;
name|tail
operator|=
name|path
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
while|while
condition|(
name|tail
operator|>=
name|path
condition|)
if|if
condition|(
operator|*
operator|(
operator|--
name|tail
operator|)
operator|==
literal|'/'
condition|)
break|break;
operator|++
name|tail
expr_stmt|;
while|while
condition|(
operator|*
name|tail
operator|++
operator|==
operator|*
name|string
operator|++
condition|)
if|if
condition|(
operator|*
name|tail
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|prompt
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|promptlen
operator|>
literal|0
condition|)
name|kill_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hard
condition|)
block|{
name|promptlen
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|Senter
operator|&&
name|Sexit
condition|)
name|tputs
argument_list|(
name|Senter
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"--More--"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
block|{
name|promptlen
operator|+=
name|printf
argument_list|(
literal|"(Next file: %s)"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|promptlen
operator|+=
name|printf
argument_list|(
literal|"(%d%%)"
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
name|file_pos
operator|*
literal|100
operator|)
operator|/
name|file_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dum_opt
condition|)
block|{
name|promptlen
operator|+=
name|pr
argument_list|(
literal|"[Hit space to continue, Rubout to abort]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Senter
operator|&&
name|Sexit
condition|)
name|tputs
argument_list|(
name|Sexit
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|inwait
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Get a logical line */
end_comment

begin_expr_stmt
name|getline
argument_list|(
name|f
argument_list|,
name|length
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|column
decl_stmt|;
specifier|static
name|int
name|colflg
decl_stmt|;
name|p
operator|=
name|Line
expr_stmt|;
name|column
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|colflg
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
name|Currline
operator|++
expr_stmt|;
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
operator|&
name|Line
index|[
name|LINSIZ
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|Line
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|length
operator|=
name|p
operator|-
name|Line
expr_stmt|;
return|return
operator|(
name|column
operator|)
return|;
block|}
operator|*
name|length
operator|=
name|p
operator|-
name|Line
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|Currline
operator|++
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
if|if
condition|(
name|hardtabs
operator|&&
name|column
operator|<
name|promptlen
operator|&&
operator|!
name|hard
condition|)
block|{
if|if
condition|(
name|eraseln
operator|&&
operator|!
name|dumb
condition|)
block|{
name|column
operator|=
literal|1
operator|+
operator|(
name|column
operator||
literal|7
operator|)
expr_stmt|;
name|tputs
argument_list|(
name|eraseln
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
operator|--
name|p
init|;
name|column
operator|&
literal|7
operator|&&
name|p
operator|<
operator|&
name|Line
index|[
name|LINSIZ
operator|-
literal|1
index|]
condition|;
name|column
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|>=
name|promptlen
condition|)
name|promptlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|column
operator|=
literal|1
operator|+
operator|(
name|column
operator||
literal|7
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\b'
condition|)
name|column
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|column
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\f'
operator|&&
name|stop_opt
condition|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'^'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'L'
expr_stmt|;
name|column
operator|+=
literal|2
expr_stmt|;
name|Pause
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
operator|*
name|length
operator|=
name|p
operator|-
name|Line
expr_stmt|;
return|return
operator|(
name|column
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|!=
name|RUBOUT
condition|)
name|column
operator|++
expr_stmt|;
if|if
condition|(
name|column
operator|>=
name|Mcol
operator|&&
name|fold_opt
condition|)
break|break;
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|column
operator|>=
name|Mcol
operator|&&
name|Mcol
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|Wrap
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
name|colflg
operator|=
name|column
operator|==
name|Mcol
operator|&&
name|fold_opt
expr_stmt|;
operator|*
name|length
operator|=
name|p
operator|-
name|Line
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|column
operator|)
return|;
block|}
end_block

begin_comment
comment|/* ** Erase the rest of the prompt, assuming we are starting at column col. */
end_comment

begin_expr_stmt
name|erase
argument_list|(
name|col
argument_list|)
specifier|register
name|int
name|col
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|promptlen
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|hard
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|col
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dumb
operator|&&
name|eraseln
condition|)
name|tputs
argument_list|(
name|eraseln
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|col
operator|=
name|promptlen
operator|-
name|col
init|;
name|col
operator|>
literal|0
condition|;
name|col
operator|--
control|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
name|promptlen
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Erase the current line entirely */
end_comment

begin_macro
name|kill_line
argument_list|()
end_macro

begin_block
block|{
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eraseln
operator|||
name|dumb
condition|)
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **  Print string and return number of characters */
end_comment

begin_macro
name|pr
argument_list|(
argument|s1
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
for|for
control|(
name|s
operator|=
name|s1
init|;
name|c
operator|=
operator|*
name|s
operator|++
condition|;
control|)
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|-
name|s1
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Print a buffer of n characters */
end_comment

begin_expr_stmt
name|prbuf
argument_list|(
name|s
argument_list|,
name|n
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
name|putchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* **  Clear the screen */
end_comment

begin_macro
name|doclear
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|Clear
operator|&&
operator|!
name|hard
condition|)
block|{
name|tputs
argument_list|(
name|Clear
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
comment|/* Put out carriage return so that system doesn't 	** get confused by escape sequences when expanding tabs 	*/
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|lastcmd
decl_stmt|,
name|lastarg
decl_stmt|,
name|lastp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lastcolon
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|shell_line
index|[
literal|132
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** Read a command and do it. A command consists of an optional integer ** argument followed by the command character.  Return the number of lines ** to display in the next screenful.  If there is nothing more to display ** in the current file, zero is returned. */
end_comment

begin_macro
name|command
argument_list|(
argument|filename
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|nlines
decl_stmt|;
specifier|register
name|int
name|retval
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|;
name|char
name|colonch
decl_stmt|;
name|FILE
modifier|*
name|helpf
decl_stmt|;
name|int
name|done
decl_stmt|;
name|char
name|comchar
decl_stmt|,
name|cmdbuf
index|[
literal|80
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|ret
parameter_list|(
name|val
parameter_list|)
value|retval=val;done++;break
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|errors
condition|)
name|prompt
argument_list|(
name|filename
argument_list|)
expr_stmt|;
else|else
name|errors
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|MBIT
operator|==
name|RAW
operator|&&
name|slow_tty
condition|)
block|{
name|otty
operator|.
name|sg_flags
operator||=
name|MBIT
expr_stmt|;
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|nlines
operator|=
name|number
argument_list|(
operator|&
name|comchar
argument_list|)
expr_stmt|;
name|lastp
operator|=
name|colonch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|comchar
operator|==
literal|'.'
condition|)
block|{
comment|/* Repeat last command */
name|lastp
operator|++
expr_stmt|;
name|comchar
operator|=
name|lastcmd
expr_stmt|;
name|nlines
operator|=
name|lastarg
expr_stmt|;
if|if
condition|(
name|lastcmd
operator|==
literal|':'
condition|)
name|colonch
operator|=
name|lastcolon
expr_stmt|;
block|}
name|lastcmd
operator|=
name|comchar
expr_stmt|;
name|lastarg
operator|=
name|nlines
expr_stmt|;
if|if
condition|(
name|comchar
operator|==
name|otty
operator|.
name|sg_erase
condition|)
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|prompt
argument_list|(
name|filename
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|comchar
condition|)
block|{
case|case
literal|':'
case|:
name|retval
operator|=
name|colon
argument_list|(
name|filename
argument_list|,
name|colonch
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|>=
literal|0
condition|)
name|done
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
case|case
literal|'z'
case|:
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|=
name|dlines
expr_stmt|;
elseif|else
if|if
condition|(
name|comchar
operator|==
literal|'z'
condition|)
name|dlines
operator|=
name|nlines
expr_stmt|;
name|ret
argument_list|(
name|nlines
argument_list|)
expr_stmt|;
case|case
literal|'d'
case|:
case|case
name|ctrl
argument_list|(
name|D
argument_list|)
case|:
if|if
condition|(
name|nlines
operator|!=
literal|0
condition|)
name|nscroll
operator|=
name|nlines
expr_stmt|;
name|ret
argument_list|(
name|nscroll
argument_list|)
expr_stmt|;
case|case
name|RUBOUT
case|:
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|end_it
argument_list|()
expr_stmt|;
case|case
literal|'s'
case|:
case|case
literal|'f'
case|:
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|++
expr_stmt|;
if|if
condition|(
name|comchar
operator|==
literal|'f'
condition|)
name|nlines
operator|*=
name|dlines
expr_stmt|;
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n...skipping %d line"
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|>
literal|1
condition|)
name|pr
argument_list|(
literal|"s\n\n"
argument_list|)
expr_stmt|;
else|else
name|pr
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
name|retval
operator|=
literal|0
expr_stmt|;
name|done
operator|++
expr_stmt|;
goto|goto
name|endsw
goto|;
block|}
name|Currline
operator|++
expr_stmt|;
name|nlines
operator|--
expr_stmt|;
block|}
name|ret
argument_list|(
name|dlines
argument_list|)
expr_stmt|;
case|case
literal|'\n'
case|:
if|if
condition|(
name|nlines
operator|!=
literal|0
condition|)
name|dlines
operator|=
name|nlines
expr_stmt|;
else|else
name|nlines
operator|=
literal|1
expr_stmt|;
name|ret
argument_list|(
name|nlines
argument_list|)
expr_stmt|;
case|case
literal|'\f'
case|:
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|doclear
argument_list|()
expr_stmt|;
name|Fseek
argument_list|(
name|f
argument_list|,
name|screen_start
operator|.
name|chrctr
argument_list|)
expr_stmt|;
name|Currline
operator|=
name|screen_start
operator|.
name|line
expr_stmt|;
name|ret
argument_list|(
name|dlines
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'\''
case|:
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"\n***Back***\n\n"
argument_list|)
expr_stmt|;
name|Fseek
argument_list|(
name|f
argument_list|,
name|context
operator|.
name|chrctr
argument_list|)
expr_stmt|;
name|Currline
operator|=
name|context
operator|.
name|line
expr_stmt|;
name|ret
argument_list|(
name|dlines
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'='
case|:
name|kill_line
argument_list|()
expr_stmt|;
name|promptlen
operator|=
name|printd
argument_list|(
name|Currline
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|lastp
operator|++
expr_stmt|;
case|case
literal|'/'
case|:
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|++
expr_stmt|;
name|kill_line
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|1
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastp
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|search
argument_list|(
name|NULL
argument_list|,
name|f
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
comment|/* Use previous r.e. */
block|}
else|else
block|{
name|ttyin
argument_list|(
name|cmdbuf
argument_list|,
literal|78
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|search
argument_list|(
name|cmdbuf
argument_list|,
name|f
argument_list|,
name|nlines
argument_list|)
expr_stmt|;
block|}
name|ret
argument_list|(
name|dlines
argument_list|)
expr_stmt|;
case|case
literal|'!'
case|:
name|do_shell
argument_list|(
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
operator|(
name|helpf
operator|=
name|fopen
argument_list|(
name|HELPFILE
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't open help file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|noscroll
condition|)
name|doclear
argument_list|()
expr_stmt|;
name|copy_file
argument_list|(
name|helpf
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|helpf
argument_list|)
expr_stmt|;
name|prompt
argument_list|(
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* This case should go right before default */
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|cmdbuf
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|scanstr
argument_list|(
name|Currline
argument_list|,
operator|&
name|cmdbuf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"vi "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|execute
argument_list|(
name|filename
argument_list|,
name|VI
argument_list|,
literal|"vi"
argument_list|,
name|cmdbuf
argument_list|,
name|fnames
index|[
name|fnum
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|done
condition|)
break|break;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|endsw
label|:
name|inwait
operator|=
literal|0
expr_stmt|;
name|notell
operator|++
expr_stmt|;
if|if
condition|(
name|MBIT
operator|==
name|RAW
operator|&&
name|slow_tty
condition|)
block|{
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|MBIT
expr_stmt|;
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|ch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Execute a colon-prefixed command.  * Returns<0 if not a command that should cause  * more of the file to be printed.  */
end_comment

begin_macro
name|colon
argument_list|(
argument|filename
argument_list|,
argument|cmd
argument_list|,
argument|nlines
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nlines
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cmd
operator|==
literal|0
condition|)
name|ch
operator|=
name|readch
argument_list|()
expr_stmt|;
else|else
name|ch
operator|=
name|cmd
expr_stmt|;
name|lastcolon
operator|=
name|ch
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'f'
case|:
name|kill_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|no_intty
condition|)
name|promptlen
operator|=
name|printf
argument_list|(
literal|"\"%s\" line %d"
argument_list|,
name|fnames
index|[
name|fnum
index|]
argument_list|,
name|Currline
argument_list|)
expr_stmt|;
else|else
name|promptlen
operator|=
name|printf
argument_list|(
literal|"[Not a file] line %d"
argument_list|,
name|Currline
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|'n'
case|:
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fnum
operator|>=
name|nfiles
operator|-
literal|1
condition|)
name|end_it
argument_list|()
expr_stmt|;
name|nlines
operator|++
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|skipf
argument_list|(
name|nlines
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'p'
case|:
if|if
condition|(
name|no_intty
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|erase
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
name|nlines
operator|++
expr_stmt|;
name|skipf
argument_list|(
operator|-
name|nlines
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|'!'
case|:
name|do_shell
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|end_it
argument_list|()
expr_stmt|;
default|default:
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|bell
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/* ** Read a decimal number from the terminal. Set cmd to the non-digit which ** terminates the number. */
end_comment

begin_macro
name|number
argument_list|(
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
name|otty
operator|.
name|sg_kill
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|readch
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|otty
operator|.
name|sg_kill
condition|)
name|i
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|*
name|cmd
operator|=
name|ch
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_macro
name|do_shell
argument_list|(
argument|filename
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cmdbuf
index|[
literal|80
index|]
decl_stmt|;
name|kill_line
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lastp
condition|)
name|pr
argument_list|(
name|shell_line
argument_list|)
expr_stmt|;
else|else
block|{
name|ttyin
argument_list|(
name|cmdbuf
argument_list|,
literal|78
argument_list|,
literal|'!'
argument_list|)
expr_stmt|;
if|if
condition|(
name|expand
argument_list|(
name|shell_line
argument_list|,
name|cmdbuf
argument_list|)
condition|)
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|promptlen
operator|=
name|printf
argument_list|(
literal|"!%s"
argument_list|,
name|shell_line
argument_list|)
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|0
expr_stmt|;
name|shellp
operator|=
literal|1
expr_stmt|;
name|execute
argument_list|(
name|filename
argument_list|,
name|shell
argument_list|,
name|shell
argument_list|,
literal|"-c"
argument_list|,
name|shell_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Search for nth ocurrence of regular expression contained in buf in the file */
end_comment

begin_macro
name|search
argument_list|(
argument|buf
argument_list|,
argument|file
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|startline
init|=
name|Ftell
argument_list|(
name|file
argument_list|)
decl_stmt|;
specifier|register
name|long
name|line1
init|=
name|startline
decl_stmt|;
specifier|register
name|long
name|line2
init|=
name|startline
decl_stmt|;
specifier|register
name|long
name|line3
init|=
name|startline
decl_stmt|;
specifier|register
name|int
name|lncount
decl_stmt|;
name|int
name|saveln
decl_stmt|,
name|rv
decl_stmt|,
name|re_exec
argument_list|()
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|re_comp
argument_list|()
decl_stmt|;
name|context
operator|.
name|line
operator|=
name|saveln
operator|=
name|Currline
expr_stmt|;
name|context
operator|.
name|chrctr
operator|=
name|startline
expr_stmt|;
name|lncount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|re_comp
argument_list|(
name|buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|file
argument_list|)
condition|)
block|{
name|line3
operator|=
name|line2
expr_stmt|;
name|line2
operator|=
name|line1
expr_stmt|;
name|line1
operator|=
name|Ftell
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|rdline
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|lncount
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|re_exec
argument_list|(
name|Line
argument_list|)
operator|)
operator|==
literal|1
condition|)
if|if
condition|(
operator|--
name|n
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|lncount
operator|>
literal|3
operator|||
operator|(
name|lncount
operator|>
literal|1
operator|&&
name|no_intty
operator|)
condition|)
name|pr
argument_list|(
literal|"\n...skipping\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|Currline
operator|-=
operator|(
name|lncount
operator|>=
literal|3
condition|?
literal|3
else|:
name|lncount
operator|)
expr_stmt|;
name|Fseek
argument_list|(
name|file
argument_list|,
name|line3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|pr
argument_list|(
name|Line
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Regular expression botch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|feof
argument_list|(
name|file
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
ifdef|#
directive|ifdef
name|V6
name|file
operator|->
name|_flag
operator|&=
operator|~
name|_IOEOF
expr_stmt|;
comment|/* why doesn't fseek do this ??!!??! */
endif|#
directive|endif
name|Currline
operator|=
name|saveln
expr_stmt|;
name|Fseek
argument_list|(
name|file
argument_list|,
name|startline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pr
argument_list|(
literal|"\nPattern not found\n"
argument_list|)
expr_stmt|;
name|end_it
argument_list|()
expr_stmt|;
block|}
name|error
argument_list|(
literal|"Pattern not found"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|execute
argument_list|(
argument|filename
argument_list|,
argument|cmd
argument_list|,
argument|args
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|args
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|id
decl_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|reset_tty
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|id
operator|=
name|fork
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0
condition|)
block|{
name|execv
argument_list|(
name|cmd
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"exec failed\n"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
if|if
condition|(
name|catch_susp
condition|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|end_it
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onquit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
if|if
condition|(
name|catch_susp
condition|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|onsusp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|set_tty
argument_list|()
expr_stmt|;
name|pr
argument_list|(
literal|"------------------------\n"
argument_list|)
expr_stmt|;
name|prompt
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ** Skip n lines in the file f */
end_comment

begin_expr_stmt
name|skiplns
argument_list|(
name|n
argument_list|,
name|f
argument_list|)
specifier|register
name|int
name|n
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
return|return;
name|n
operator|--
expr_stmt|;
name|Currline
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* ** Skip nskip files in the file list (from the command line). Nskip may be ** negative. */
end_comment

begin_expr_stmt
name|skipf
argument_list|(
name|nskip
argument_list|)
specifier|register
name|int
name|nskip
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|nskip
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|nskip
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fnum
operator|+
name|nskip
operator|>
name|nfiles
operator|-
literal|1
condition|)
name|nskip
operator|=
name|nfiles
operator|-
name|fnum
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|within
condition|)
operator|++
name|fnum
expr_stmt|;
name|fnum
operator|+=
name|nskip
expr_stmt|;
if|if
condition|(
name|fnum
operator|<
literal|0
condition|)
name|fnum
operator|=
literal|0
expr_stmt|;
name|pr
argument_list|(
literal|"\n...Skipping "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|nskip
operator|>
literal|0
condition|?
literal|"to file "
else|:
literal|"back to file "
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|pr
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
operator|--
name|fnum
expr_stmt|;
block|}
end_block

begin_comment
comment|/*----------------------------- Terminal I/O -------------------------------*/
end_comment

begin_macro
name|initterm
argument_list|()
end_macro

begin_block
block|{
name|char
name|buf
index|[
name|TBUFSIZ
index|]
decl_stmt|;
name|char
name|clearbuf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|clearptr
decl_stmt|,
modifier|*
name|padstr
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|int
name|ldisc
decl_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|no_tty
operator|=
name|gtty
argument_list|(
literal|1
argument_list|,
operator|&
name|otty
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|tgetent
argument_list|(
name|buf
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|dumb
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|Lpp
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|||
name|tgetflag
argument_list|(
literal|"hc"
argument_list|)
condition|)
block|{
name|hard
operator|++
expr_stmt|;
comment|/* Hard copy terminal */
name|Lpp
operator|=
literal|24
expr_stmt|;
block|}
if|if
condition|(
name|tailequ
argument_list|(
name|fnames
index|[
literal|0
index|]
argument_list|,
literal|"page"
argument_list|)
operator|||
operator|!
name|hard
operator|&&
name|tgetflag
argument_list|(
literal|"ns"
argument_list|)
condition|)
name|noscroll
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|Mcol
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|Mcol
operator|=
literal|80
expr_stmt|;
name|Wrap
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
name|bad_so
operator|=
name|tgetflag
argument_list|(
literal|"xs"
argument_list|)
expr_stmt|;
name|clearptr
operator|=
name|clearbuf
expr_stmt|;
name|eraseln
operator|=
name|tgetstr
argument_list|(
literal|"ce"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
name|Clear
operator|=
name|tgetstr
argument_list|(
literal|"cl"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
name|Senter
operator|=
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
name|Sexit
operator|=
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|clearptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|padstr
operator|=
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|clearptr
argument_list|)
condition|)
name|PC
operator|=
operator|*
name|padstr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|shell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|shell
operator|=
literal|"/bin/sh"
expr_stmt|;
block|}
name|no_intty
operator|=
name|gtty
argument_list|(
literal|0
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
name|gtty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
name|ospeed
operator|=
name|otty
operator|.
name|sg_ospeed
expr_stmt|;
name|slow_tty
operator|=
name|ospeed
operator|<
name|B1200
expr_stmt|;
name|hardtabs
operator|=
operator|!
operator|(
name|otty
operator|.
name|sg_flags
operator|&
name|XTABS
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_tty
condition|)
block|{
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|MBIT
operator|==
name|CBREAK
operator|||
operator|!
name|slow_tty
condition|)
name|otty
operator|.
name|sg_flags
operator||=
name|MBIT
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|readch
argument_list|()
end_macro

begin_block
block|{
name|char
name|ch
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|read
argument_list|(
literal|2
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|ch
operator|=
name|otty
operator|.
name|sg_kill
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|BS
init|=
literal|'\b'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|CARAT
init|=
literal|'^'
decl_stmt|;
end_decl_stmt

begin_macro
name|ttyin
argument_list|(
argument|buf
argument_list|,
argument|nmax
argument_list|,
argument|pchar
argument_list|)
end_macro

begin_decl_stmt
name|char
name|buf
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|nmax
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|pchar
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|sptr
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
specifier|register
name|int
name|slash
init|=
literal|0
decl_stmt|;
name|int
name|maxlen
decl_stmt|;
name|char
name|cbuf
decl_stmt|;
name|sptr
operator|=
name|buf
expr_stmt|;
name|maxlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sptr
operator|-
name|buf
operator|<
name|nmax
condition|)
block|{
if|if
condition|(
name|promptlen
operator|>
name|maxlen
condition|)
name|maxlen
operator|=
name|promptlen
expr_stmt|;
name|ch
operator|=
name|readch
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
name|slash
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
name|otty
operator|.
name|sg_erase
operator|)
operator|&&
operator|!
name|slash
condition|)
block|{
if|if
condition|(
name|sptr
operator|>
name|buf
condition|)
block|{
operator|--
name|promptlen
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|BS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|--
name|sptr
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sptr
operator|<
literal|' '
operator|&&
operator|*
name|sptr
operator|!=
literal|'\n'
operator|)
operator|||
operator|*
name|sptr
operator|==
name|RUBOUT
condition|)
block|{
operator|--
name|promptlen
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|BS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|eraseln
condition|)
name|promptlen
operator|=
name|maxlen
expr_stmt|;
name|longjmp
argument_list|(
name|restore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
name|otty
operator|.
name|sg_kill
operator|)
operator|&&
operator|!
name|slash
condition|)
block|{
if|if
condition|(
name|hard
condition|)
block|{
name|show
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|pchar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
name|pchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|eraseln
condition|)
name|erase
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|=
literal|1
expr_stmt|;
block|}
name|sptr
operator|=
name|buf
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|slash
operator|&&
operator|(
name|ch
operator|==
name|otty
operator|.
name|sg_kill
operator|||
name|ch
operator|==
name|otty
operator|.
name|sg_erase
operator|)
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|BS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|--
name|sptr
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|'\\'
condition|)
name|slash
operator|=
literal|0
expr_stmt|;
operator|*
name|sptr
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|<
literal|' '
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|ESC
operator|)
operator|||
name|ch
operator|==
name|RUBOUT
condition|)
block|{
name|ch
operator|+=
name|ch
operator|==
name|RUBOUT
condition|?
operator|-
literal|0100
else|:
literal|0100
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|CARAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|++
expr_stmt|;
block|}
name|cbuf
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|ESC
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|cbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
operator|*
operator|--
name|sptr
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|eraseln
condition|)
name|promptlen
operator|=
name|maxlen
expr_stmt|;
if|if
condition|(
name|sptr
operator|-
name|buf
operator|>=
name|nmax
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Line too long"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|expand
argument_list|(
argument|outbuf
argument_list|,
argument|inbuf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|outbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|inbuf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|instr
decl_stmt|;
specifier|register
name|char
modifier|*
name|outstr
decl_stmt|;
specifier|register
name|char
name|ch
decl_stmt|;
name|char
name|temp
index|[
literal|200
index|]
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
name|instr
operator|=
name|inbuf
expr_stmt|;
name|outstr
operator|=
name|temp
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|instr
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'%'
case|:
if|if
condition|(
operator|!
name|no_intty
condition|)
block|{
name|strcpy
argument_list|(
name|outstr
argument_list|,
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|outstr
operator|+=
name|strlen
argument_list|(
name|fnames
index|[
name|fnum
index|]
argument_list|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|outstr
operator|++
operator|=
name|ch
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
operator|!
name|shellp
condition|)
name|error
argument_list|(
literal|"No previous command to substitute for"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|outstr
argument_list|,
name|shell_line
argument_list|)
expr_stmt|;
name|outstr
operator|+=
name|strlen
argument_list|(
name|shell_line
argument_list|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|instr
operator|==
literal|'%'
operator|||
operator|*
name|instr
operator|==
literal|'!'
condition|)
block|{
operator|*
name|outstr
operator|++
operator|=
operator|*
name|instr
operator|++
expr_stmt|;
break|break;
block|}
default|default:
operator|*
name|outstr
operator|++
operator|=
name|ch
expr_stmt|;
block|}
operator|*
name|outstr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|outbuf
argument_list|,
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|changed
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|show
argument_list|(
name|ch
argument_list|)
specifier|register
name|char
name|ch
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|cbuf
decl_stmt|;
if|if
condition|(
operator|(
name|ch
operator|<
literal|' '
operator|&&
name|ch
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|ESC
operator|)
operator|||
name|ch
operator|==
name|RUBOUT
condition|)
block|{
name|ch
operator|+=
name|ch
operator|==
name|RUBOUT
condition|?
operator|-
literal|0100
else|:
literal|0100
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|CARAT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|++
expr_stmt|;
block|}
name|cbuf
operator|=
name|ch
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
operator|&
name|cbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|promptlen
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|error
argument_list|(
argument|mess
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mess
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|kill_line
argument_list|()
expr_stmt|;
name|promptlen
operator|+=
name|strlen
argument_list|(
name|mess
argument_list|)
expr_stmt|;
if|if
condition|(
name|Senter
operator|&&
name|Sexit
condition|)
block|{
name|tputs
argument_list|(
name|Senter
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
name|pr
argument_list|(
name|mess
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|Sexit
argument_list|,
literal|1
argument_list|,
name|putch
argument_list|)
expr_stmt|;
block|}
else|else
name|pr
argument_list|(
name|mess
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
name|longjmp
argument_list|(
name|restore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|set_tty
argument_list|()
end_macro

begin_block
block|{
name|otty
operator|.
name|sg_flags
operator||=
name|MBIT
expr_stmt|;
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|reset_tty
argument_list|()
end_macro

begin_block
block|{
name|otty
operator|.
name|sg_flags
operator||=
name|ECHO
expr_stmt|;
name|otty
operator|.
name|sg_flags
operator|&=
operator|~
name|MBIT
expr_stmt|;
name|stty
argument_list|(
literal|2
argument_list|,
operator|&
name|otty
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|rdline
argument_list|(
name|f
argument_list|)
specifier|register
name|FILE
operator|*
name|f
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|Line
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|Getc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
operator|&&
name|p
operator|-
name|Line
operator|<
name|LINSIZ
operator|-
literal|1
condition|)
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|Currline
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Come here when we get a suspend signal from the terminal */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_macro
name|onsusp
argument_list|()
end_macro

begin_block
block|{
name|reset_tty
argument_list|()
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Send the TSTP signal to suspend our process group */
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
comment|/* Pause for station break */
comment|/* We're back */
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|onsusp
argument_list|)
expr_stmt|;
name|set_tty
argument_list|()
expr_stmt|;
if|if
condition|(
name|inwait
condition|)
name|longjmp
argument_list|(
name|restore
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

