begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*  * The hash table must be at least twice as big as the number  * of patterns, preferably bigger. It must also be a prime number  */
end_comment

begin_define
define|#
directive|define
name|HSHSIZ
value|101
end_define

begin_struct
struct|struct
name|pats
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|replace
decl_stmt|;
block|}
name|ptab
index|[]
init|=
block|{
block|{
literal|"ACTFILE\n"
block|,
literal|"	movl	(sp)+,r1\n\ 	movl	12(r1),r0\n"
block|}
block|,
block|{
literal|"fgetc\n"
block|,
literal|"	decl	*(sp)\n\ 	jgeq	1f\n\ 	calls	$1,__filbuf\n\ 	jbr     2f\n\ 1:\n\ 	addl3	$4,(sp)+,r1\n\ 	movzbl	*(r1),r0\n\ 	incl	(r1)\n\ 2:\n"
block|}
block|,
block|{
literal|"fputc\n"
block|,
literal|"	decl	*4(sp)\n\ 	jgeq	1f\n\ 	calls	$2,__flsbuf\n\ 	jbr	2f\n\ 1:\n\ 	movl	(sp)+,r0\n\ 	addl3	$4,(sp)+,r1\n\ 	movb	r0,*(r1)\n\ 	incl	(r1)\n\ 2:\n"
block|}
block|,
block|{
literal|"MOVC3\n"
block|,
literal|"	movl	(sp)+,r5\n\ 	movc3	r5,*(sp)+,*(sp)+\n"
block|}
block|,
block|{
literal|"LOCC\n"
block|,
literal|"	movl	(sp)+,r5\n\ 	movl	(sp)+,r4\n\ 	locc	r5,r4,*(sp)+\n"
block|}
block|,
block|{
literal|"ROUND\n"
block|,
literal|"	cvtrdl	(sp)+,r0\n"
block|}
block|,
block|{
literal|"TRUNC\n"
block|,
literal|"	cvtdl	(sp)+,r0\n"
block|}
block|,
block|{
literal|"FCALL\n"
block|,
literal|"	movl	(sp),r0\n\ 	ashl	$3,4(r0),r1\n\ 	movc3	r1,__disply+8,8(r0)[r1]\n\ 	movl	(sp),r0\n\ 	ashl	$3,4(r0),r1\n\ 	movc3	r1,8(r0),__disply+8\n\ 	movl	*(sp)+,r0\n"
block|}
block|,
block|{
literal|"FRTN\n"
block|,
literal|"	movl	(sp)+,r0\n\ 	ashl	$3,4(r0),r1\n\ 	movc3	r1,8(r0)[r1],__disply+8\n\ 	movl	(sp)+,r0\n"
block|}
block|,
block|{
literal|"FSAV\n"
block|,
literal|"	movl	8(sp),r0\n\ 	movl	(sp)+,(r0)\n\ 	movl	(sp)+,4(r0)\n\ 	ashl	$3,4(r0),r1\n\ 	movc3	r1,__disply+8,8(r0)\n\ 	movl	(sp)+,r0\n"
block|}
block|,
block|{
literal|"RELEQ\n"
block|,
literal|"	movl	(sp)+,r1\n\ 	cmpc3	r1,*(sp)+,*(sp)+\n\ 	beql	1f\n\ 	clrl	r0\n\ 	brb	2f\n\ 1:\n\ 	movl	$1,r0\n\ 2:\n"
block|}
block|,
block|{
literal|"RELNE\n"
block|,
literal|"	movl	(sp)+,r1\n\ 	cmpc3	r1,*(sp)+,*(sp)+\n\ 	bneq	1f\n\ 	clrl	r0\n\ 	brb	2f\n\ 1:\n\ 	movl	$1,r0\n\ 2:\n"
block|}
block|,
block|{
literal|"RELSLT\n"
block|,
literal|"	movl	(sp)+,r1\n\ 	cmpc3	r1,*(sp)+,*(sp)+\n\ 	blss	1f\n\ 	clrl	r0\n\ 	brb	2f\n\ 1:\n\ 	movl	$1,r0\n\ 2:\n"
block|}
block|,
block|{
literal|"RELSLE\n"
block|,
literal|"	movl	(sp)+,r1\n\ 	cmpc3	r1,*(sp)+,*(sp)+\n\ 	bleq	1f\n\ 	clrl	r0\n\ 	brb	2f\n\ 1:\n\ 	movl	$1,r0\n\ 2:\n"
block|}
block|,
block|{
literal|"RELSGT\n"
block|,
literal|"	movl	(sp)+,r1\n\ 	cmpc3	r1,*(sp)+,*(sp)+\n\ 	bgtr	1f\n\ 	clrl	r0\n\ 	brb	2f\n\ 1:\n\ 	movl	$1,r0\n\ 2:\n"
block|}
block|,
block|{
literal|"RELSGE\n"
block|,
literal|"	movl	(sp)+,r1\n\ 	cmpc3	r1,*(sp)+,*(sp)+\n\ 	bgeq	1f\n\ 	clrl	r0\n\ 	brb	2f\n\ 1:\n\ 	movl	$1,r0\n\ 2:\n"
block|}
block|,
block|{
literal|"ADDT\n"
block|,
literal|"	movl	(sp)+,r0\n\ 	movl	(sp)+,r1\n\ 	movl	(sp)+,r2\n\ 	movl	r0,r3\n\ 	movl	(sp)+,r4\n\ 1:\n\ 	bisl3	(r1)+,(r2)+,(r3)+\n\ 	sobgtr	r4,1b\n"
block|}
block|,
block|{
literal|"SUBT\n"
block|,
literal|"	movl	(sp)+,r0\n\ 	movl	(sp)+,r1\n\ 	movl	(sp)+,r2\n\ 	movl	r0,r3\n\ 	movl	(sp)+,r4\n\ 1:\n\ 	bicl3	(r2)+,(r1)+,(r3)+\n\ 	sobgtr	r4,1b\n"
block|}
block|,
block|{
literal|"MULT\n"
block|,
literal|"	movl	(sp)+,r0\n\ 	movl	(sp)+,r1\n\ 	movl	(sp)+,r2\n\ 	movl	r0,r3\n\ 	movl	(sp)+,r4\n\ 1:\n\ 	mcoml	(r1)+,r5\n\ 	bicl3	r5,(r2)+,(r3)+\n\ 	sobgtr	r4,1b\n"
block|}
block|,
block|{
literal|"IN\n"
block|,
literal|"	clrl	r0\n\ 	movl	(sp)+,r1\n\ 	subl2	(sp)+,r1\n\ 	cmpl	r1,(sp)+\n\ 	bgtru	1f\n\ 	bbc	r1,*(sp)+,1f\n\ 	movl	$1,r0\n\ 1:\n"
block|}
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|pats
modifier|*
name|htbl
index|[
name|HSHSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHK
parameter_list|(
name|c
parameter_list|)
value|if (*cp++ != c) goto copy;
end_define

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|cp
parameter_list|,
name|hp
parameter_list|)
value|{\ 	hash = 0; rehash = 1; ccp = cp; \ 	do	{ \ 		hash *= (int)*ccp++; \ 	} while (*ccp&& *ccp != '\n'); \ 	hash>>= 7; hash %= HSHSIZ; hp =&htbl[hash]; size = ccp - cp + 1; \ 	}
end_define

begin_define
define|#
directive|define
name|REHASH
parameter_list|(
name|hp
parameter_list|)
value|{\ 	hp += rehash; rehash += 2; \ 	if (hp>=&htbl[HSHSIZ]) \ 		hp -= HSHSIZ; \ 	}
end_define

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|struct
name|pats
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|pats
modifier|*
modifier|*
name|hp
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|ccp
decl_stmt|;
specifier|register
name|int
name|hash
decl_stmt|,
name|rehash
decl_stmt|,
name|size
decl_stmt|;
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|freopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|freopen
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* 	 * set up the hash table 	 */
for|for
control|(
name|pp
operator|=
name|ptab
init|;
name|pp
operator|<
operator|&
name|ptab
index|[
sizeof|sizeof
name|ptab
operator|/
sizeof|sizeof
name|ptab
index|[
literal|0
index|]
index|]
condition|;
name|pp
operator|++
control|)
block|{
name|HASH
argument_list|(
name|pp
operator|->
name|name
argument_list|,
name|hp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|hp
condition|)
name|REHASH
argument_list|(
name|hp
argument_list|)
expr_stmt|;
operator|*
name|hp
operator|=
name|pp
expr_stmt|;
block|}
comment|/* 	 * check each line and replace as appropriate 	 */
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
for|for
control|(
name|cp
operator|=
name|line
init|;
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|==
literal|'\t'
condition|;
control|)
name|cp
operator|++
expr_stmt|;
name|CHK
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|'a'
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|'s'
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
operator|++
argument_list|)
condition|)
goto|goto
name|copy
goto|;
name|CHK
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|CHK
argument_list|(
literal|'_'
argument_list|)
expr_stmt|;
name|HASH
argument_list|(
name|cp
argument_list|,
name|hp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|hp
condition|)
block|{
if|if
condition|(
name|RELEQ
argument_list|(
name|size
argument_list|,
operator|(
operator|*
name|hp
operator|)
operator|->
name|name
argument_list|,
name|cp
argument_list|)
condition|)
block|{
name|fputs
argument_list|(
operator|(
operator|*
name|hp
operator|)
operator|->
name|replace
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
goto|goto
name|nextline
goto|;
block|}
name|REHASH
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
name|copy
label|:
name|fputs
argument_list|(
name|line
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|nextline
label|:
empty_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

