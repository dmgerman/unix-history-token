begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1980 Regents of the University of California */
end_comment

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pc3.c 1.6 9/9/80"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      *	     Pc3 is a pass in the Berkeley Pascal compilation      *	process that is performed just prior to linking Pascal      *	object files.  Its purpose is to enforce the rules of      *	separate compilation for Berkeley Pascal.  Pc3 is called      *	with the same argument list of object files that is sent to      *	the loader.  These checks are performed by pc3 by examining      *	the symbol tables of the object files:      *	(1)  All source and included files must be "up-to-date" with      *	     the object files of which they are components.      *	(2)  Each global Pascal symbol (label, constant, type,      *	     variable, procedure, or function name) must be uniquely      *	     declared, i.e. declared in only one included file or      *	     source file.      *	(3)  Each external function (or procedure) may be resolved      *	     at most once in a source file which included the      *	     external declaration of the function.      *	      *	     The symbol table of each object file is scanned and      *	each global Pascal symbol is placed in a hashed symbol      *	table.  The Pascal compiler has been modified to emit all      *	Pascal global symbols to the object file symbol table.  The      *	information stored in the symbol table for each such symbol      *	is:      *	      *	   - the name of the symbol;      *	   - a subtype descriptor;      *	   - for file symbols, their last modify time;      *	   - the file which logically contains the declaration of      *	     the symbol (not an include file);      *	   - the file which textually contains the declaration of      *	     the symbol (possibly an include file);      *	   - the line number at which the symbol is declared;      *	   - the file which contains the resolution of the symbol.      *	   - the line number at which the symbol is resolved;      *	      *	     If a symbol has been previously entered into the symbol      *	table, a check is made that the current declaration is of      *	the same type and from the same include file as the previous      *	one.  Except for files and functions and procedures, it is      *	an error for a symbol declaration to be encountered more      *	than once, unless the re-declarations come from the same      *	included file as the original.      *	      *	     As an include file symbol is encountered in a source      *	file, the symbol table entry of each symbol declared in that      *	include file is modified to reflect its new logical      *	inclusion in the source file.  File symbols are also      *	encountered as an included file ends, signaling the      *	continuation of the enclosing file.      *	      *	     Functions and procedures which have been declared      *	external may be resolved by declarations from source files      *	which included the external declaration of the function.      *	Functions and procedures may be resolved at most once across      *	a set of object files.  The loader will complain if a      *	function is not resolved at least once.      */
end_comment

begin_escape
end_escape

begin_decl_stmt
name|char
name|program
index|[]
init|=
literal|"pc"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ar.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_include
include|#
directive|include
file|<pagsiz.h>
end_include

begin_include
include|#
directive|include
file|<stat.h>
end_include

begin_include
include|#
directive|include
file|"pstab.h"
end_include

begin_include
include|#
directive|include
file|"pc3.h"
end_include

begin_decl_stmt
name|int
name|errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*      *	check each of the argument .o files (or archives of .o files).      */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|fileinfo
name|ofile
decl_stmt|;
while|while
condition|(
operator|++
name|argv
operator|,
operator|--
name|argc
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[main] *argv = %s\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|ofile
operator|.
name|name
operator|=
operator|*
name|argv
expr_stmt|;
name|checkfile
argument_list|(
operator|&
name|ofile
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*      *	check the namelist of a file, or all namelists of an archive.      */
end_comment

begin_macro
name|checkfile
argument_list|(
argument|ofilep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|fileinfo
modifier|*
name|ofilep
decl_stmt|;
end_decl_stmt

begin_block
block|{
union|union
block|{
name|char
name|mag_armag
index|[
name|SARMAG
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|exec
name|mag_exec
decl_stmt|;
block|}
name|mag_un
union|;
name|int
name|red
decl_stmt|;
name|struct
name|stat
name|filestat
decl_stmt|;
name|ofilep
operator|->
name|file
operator|=
name|fopen
argument_list|(
name|ofilep
operator|->
name|name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofilep
operator|->
name|file
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"cannot open: %s"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|fstat
argument_list|(
name|fileno
argument_list|(
name|ofilep
operator|->
name|file
argument_list|)
argument_list|,
operator|&
name|filestat
argument_list|)
expr_stmt|;
name|ofilep
operator|->
name|modtime
operator|=
name|filestat
operator|.
name|st_mtime
expr_stmt|;
name|red
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mag_un
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|mag_un
argument_list|,
name|ofilep
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|!=
sizeof|sizeof
name|mag_un
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"cannot read header: %s"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mag_un
operator|.
name|mag_exec
operator|.
name|a_magic
operator|==
name|OARMAG
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"old archive: %s"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|mag_un
operator|.
name|mag_armag
argument_list|,
name|ARMAG
argument_list|,
name|SARMAG
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* archive, iterate through elements */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[checkfile] archive %s\n"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|ofilep
operator|->
name|nextoffset
operator|=
name|SARMAG
expr_stmt|;
while|while
condition|(
name|nextelement
argument_list|(
name|ofilep
argument_list|)
condition|)
block|{
name|checknl
argument_list|(
name|ofilep
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|N_BADMAG
argument_list|(
name|mag_un
operator|.
name|mag_exec
argument_list|)
condition|)
block|{
comment|/* not a file.o */
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"bad format: %s"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* a file.o */
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[checkfile] .o file %s\n"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|fseek
argument_list|(
name|ofilep
operator|->
name|file
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ofilep
operator|->
name|nextoffset
operator|=
name|filestat
operator|.
name|st_size
expr_stmt|;
name|checknl
argument_list|(
name|ofilep
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|ofilep
operator|->
name|file
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	check the namelist of this file for conflicts with      *	previously entered symbols.      */
end_comment

begin_expr_stmt
name|checknl
argument_list|(
name|ofilep
argument_list|)
specifier|register
expr|struct
name|fileinfo
operator|*
name|ofilep
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|long
name|red
decl_stmt|;
name|struct
name|exec
name|oexec
decl_stmt|;
name|off_t
name|symoff
decl_stmt|;
name|long
name|numsyms
decl_stmt|;
specifier|register
name|struct
name|nlist
modifier|*
name|nlp
decl_stmt|;
specifier|register
name|char
modifier|*
name|stringp
decl_stmt|;
name|long
name|strsize
decl_stmt|;
name|long
name|sym
decl_stmt|;
name|red
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|oexec
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|oexec
argument_list|,
name|ofilep
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|!=
sizeof|sizeof
name|oexec
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"error reading struct exec: %s"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|N_BADMAG
argument_list|(
name|oexec
argument_list|)
condition|)
block|{
return|return;
block|}
name|symoff
operator|=
name|N_SYMOFF
argument_list|(
name|oexec
argument_list|)
operator|-
sizeof|sizeof
name|oexec
expr_stmt|;
name|fseek
argument_list|(
name|ofilep
operator|->
name|file
argument_list|,
name|symoff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|numsyms
operator|=
name|oexec
operator|.
name|a_syms
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|numsyms
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"no name list: %s"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|nlp
operator|=
operator|(
expr|struct
name|nlist
operator|*
operator|)
name|calloc
argument_list|(
name|numsyms
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlp
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"no room for %d nlists"
argument_list|,
name|numsyms
argument_list|)
expr_stmt|;
block|}
name|red
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
name|nlp
argument_list|,
name|numsyms
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nlist
argument_list|)
argument_list|,
name|ofilep
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftell
argument_list|(
name|ofilep
operator|->
name|file
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
operator|>=
name|ofilep
operator|->
name|nextoffset
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"no string table (old format .o?)"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|red
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|strsize
argument_list|,
sizeof|sizeof
name|strsize
argument_list|,
literal|1
argument_list|,
name|ofilep
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"no string table (old format .o?)"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|stringp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|stringp
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"no room for %d bytes of strings"
argument_list|,
name|strsize
argument_list|)
expr_stmt|;
block|}
name|red
operator|=
name|fread
argument_list|(
name|stringp
operator|+
sizeof|sizeof
name|strsize
argument_list|,
name|strsize
operator|-
sizeof|sizeof
argument_list|(
name|strsize
argument_list|)
argument_list|,
literal|1
argument_list|,
name|ofilep
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|!=
literal|1
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"error reading string table: %s"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[checknl] %s: %d symbols\n"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|,
name|numsyms
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
for|for
control|(
name|sym
operator|=
literal|0
init|;
name|sym
operator|<
name|numsyms
condition|;
name|sym
operator|++
control|)
block|{
if|if
condition|(
name|nlp
index|[
name|sym
index|]
operator|.
name|n_un
operator|.
name|n_strx
condition|)
block|{
name|nlp
index|[
name|sym
index|]
operator|.
name|n_un
operator|.
name|n_name
operator|=
name|stringp
operator|+
name|nlp
index|[
name|sym
index|]
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
block|}
else|else
block|{
name|nlp
index|[
name|sym
index|]
operator|.
name|n_un
operator|.
name|n_name
operator|=
literal|""
expr_stmt|;
block|}
name|checksymbol
argument_list|(
operator|&
name|nlp
index|[
name|sym
index|]
argument_list|,
name|ofilep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nlp
condition|)
block|{
name|free
argument_list|(
name|nlp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stringp
condition|)
block|{
name|free
argument_list|(
name|stringp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	check a symbol.      *	look it up in the hashed symbol table,      *	entering it if necessary.      *	this maintains a state of which .p and .i files      *	it is currently in the midst from the nlist entries      *	for source and included files.      *	if we are inside a .p but not a .i, pfilep == ifilep.      */
end_comment

begin_macro
name|checksymbol
argument_list|(
argument|nlp
argument_list|,
argument|ofilep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nlist
modifier|*
name|nlp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fileinfo
modifier|*
name|ofilep
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|struct
name|symbol
modifier|*
name|pfilep
init|=
name|NIL
decl_stmt|;
specifier|static
name|struct
name|symbol
modifier|*
name|ifilep
init|=
name|NIL
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
name|symbolp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pfilep
operator|&&
name|ifilep
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[checksymbol] pfile %s ifile %s\n"
argument_list|,
name|pfilep
operator|->
name|name
argument_list|,
name|ifilep
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[checksymbol] ->name %s ->n_desc %x (%s)\n"
argument_list|,
name|nlp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|nlp
operator|->
name|n_desc
argument_list|,
name|classify
argument_list|(
name|nlp
operator|->
name|n_desc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|nlp
operator|->
name|n_type
operator|!=
name|N_PC
condition|)
block|{
comment|/* don't care about the others */
return|return;
block|}
name|symbolp
operator|=
name|entersymbol
argument_list|(
name|nlp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolp
operator|->
name|lookup
operator|==
name|NEW
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[checksymbol] ->name %s is NEW\n"
argument_list|,
name|symbolp
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|symbolp
operator|->
name|desc
operator|=
name|nlp
operator|->
name|n_desc
expr_stmt|;
switch|switch
condition|(
name|symbolp
operator|->
name|desc
condition|)
block|{
case|case
name|N_PGLABEL
case|:
case|case
name|N_PGCONST
case|:
case|case
name|N_PGTYPE
case|:
case|case
name|N_PGVAR
case|:
case|case
name|N_PGFUNC
case|:
case|case
name|N_PGPROC
case|:
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|rfilep
operator|=
name|ifilep
expr_stmt|;
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|rline
operator|=
name|nlp
operator|->
name|n_value
expr_stmt|;
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|fromp
operator|=
name|pfilep
expr_stmt|;
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|fromi
operator|=
name|ifilep
expr_stmt|;
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|iline
operator|=
name|nlp
operator|->
name|n_value
expr_stmt|;
return|return;
case|case
name|N_PEFUNC
case|:
case|case
name|N_PEPROC
case|:
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|rfilep
operator|=
name|NIL
expr_stmt|;
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|rline
operator|=
literal|0
expr_stmt|;
comment|/* 			     *	functions can only be declared external 			     *	in included files. 			     */
if|if
condition|(
name|pfilep
operator|==
name|ifilep
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"%s, line %d: %s %s must be declared in included file"
argument_list|,
name|pfilep
operator|->
name|name
argument_list|,
name|nlp
operator|->
name|n_value
argument_list|,
name|classify
argument_list|(
name|symbolp
operator|->
name|desc
argument_list|)
argument_list|,
name|symbolp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|fromp
operator|=
name|pfilep
expr_stmt|;
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|fromi
operator|=
name|ifilep
expr_stmt|;
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|iline
operator|=
name|nlp
operator|->
name|n_value
expr_stmt|;
return|return;
case|case
name|N_PSO
case|:
name|pfilep
operator|=
name|symbolp
expr_stmt|;
comment|/* and fall through */
case|case
name|N_PSOL
case|:
name|ifilep
operator|=
name|symbolp
expr_stmt|;
name|symbolp
operator|->
name|sym_un
operator|.
name|modtime
operator|=
name|mtime
argument_list|(
name|symbolp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbolp
operator|->
name|sym_un
operator|.
name|modtime
operator|>
name|ofilep
operator|->
name|modtime
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"%s is out of date with %s"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|,
name|symbolp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[checksymbol] ->name %s is OLD\n"
argument_list|,
name|symbolp
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
switch|switch
condition|(
name|symbolp
operator|->
name|desc
condition|)
block|{
case|case
name|N_PSO
case|:
comment|/* 			     *	finding a file again means you are back 			     *	in it after finishing an include file. 			     */
name|pfilep
operator|=
name|symbolp
expr_stmt|;
comment|/* and fall through */
case|case
name|N_PSOL
case|:
comment|/* 			     *	include files can be seen more than once, 			     *	but they still have to be timechecked. 			     *	(this will complain twice for out of date 			     *	include files which include other files. 			     *	sigh.) 			     */
name|ifilep
operator|=
name|symbolp
expr_stmt|;
if|if
condition|(
name|symbolp
operator|->
name|sym_un
operator|.
name|modtime
operator|>
name|ofilep
operator|->
name|modtime
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"%s is out of date with %s"
argument_list|,
name|ofilep
operator|->
name|name
argument_list|,
name|symbolp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|N_PEFUNC
case|:
case|case
name|N_PEPROC
case|:
comment|/* 			     *	we may see any number of external declarations, 			     *	but they all have to come 			     *	from the same include file. 			     */
if|if
condition|(
name|nlp
operator|->
name|n_desc
operator|==
name|N_PEFUNC
operator|||
name|nlp
operator|->
name|n_desc
operator|==
name|N_PEPROC
condition|)
block|{
goto|goto
name|included
goto|;
block|}
comment|/* 			     *	an external function can be resolved by 			     *	the resolution of the function 			     *	if the resolving file 			     *	included the external declaration. 			     */
if|if
condition|(
operator|(
name|symbolp
operator|->
name|desc
operator|==
name|N_PEFUNC
operator|&&
name|nlp
operator|->
name|n_desc
operator|!=
name|N_PGFUNC
operator|)
operator|||
operator|(
name|symbolp
operator|->
name|desc
operator|==
name|N_PEPROC
operator|&&
name|nlp
operator|->
name|n_desc
operator|!=
name|N_PGPROC
operator|)
operator|||
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|fromp
operator|!=
name|pfilep
condition|)
block|{
break|break;
block|}
comment|/* 			     *	an external function can only be resolved once. 			     */
if|if
condition|(
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|rfilep
operator|!=
name|NIL
condition|)
block|{
break|break;
block|}
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|rfilep
operator|=
name|ifilep
expr_stmt|;
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|rline
operator|=
name|nlp
operator|->
name|n_value
expr_stmt|;
return|return;
case|case
name|N_PGFUNC
case|:
case|case
name|N_PGPROC
case|:
comment|/* 			     *	functions may not be seen more than once. 			     *	the loader will complain about 			     *	`multiply defined', but we can, too. 			     */
break|break;
case|case
name|N_PGLABEL
case|:
case|case
name|N_PGCONST
case|:
case|case
name|N_PGTYPE
case|:
case|case
name|N_PGVAR
case|:
comment|/* 			     *	labels, constants, types, variables 			     *	and external declarations 			     *	may be seen as many times as they want, 			     *	as long as they come from the same include file. 			     *	make it look like they come from this .p file. 			     */
name|included
label|:
if|if
condition|(
name|nlp
operator|->
name|n_desc
operator|!=
name|symbolp
operator|->
name|desc
operator|||
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|fromi
operator|!=
name|ifilep
condition|)
block|{
break|break;
block|}
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|fromp
operator|=
name|pfilep
expr_stmt|;
return|return;
block|}
comment|/* 		 *	this is the breaks 		 */
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"%s, line %d: %s already defined (%s, line %d)."
argument_list|,
name|ifilep
operator|->
name|name
argument_list|,
name|nlp
operator|->
name|n_value
argument_list|,
name|nlp
operator|->
name|n_un
operator|.
name|n_name
argument_list|,
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|rfilep
operator|->
name|name
argument_list|,
name|symbolp
operator|->
name|sym_un
operator|.
name|sym_str
operator|.
name|rline
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	quadratically hashed symbol table.      *	things are never deleted from the hash symbol table.      *	as more hash table is needed,      *	a new one is alloc'ed and chained to the end.      *	search is by rehashing within each table,      *	traversing chains to next table if unsuccessful.      */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|entersymbol
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|static
name|struct
name|symboltableinfo
modifier|*
name|symboltable
init|=
name|NIL
decl_stmt|;
name|char
modifier|*
name|enteredname
decl_stmt|;
name|long
name|hashindex
decl_stmt|;
specifier|register
name|struct
name|symboltableinfo
modifier|*
name|tablep
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
modifier|*
name|herep
decl_stmt|;
specifier|register
name|struct
name|symbol
modifier|*
modifier|*
name|limitp
decl_stmt|;
specifier|register
name|long
name|increment
decl_stmt|;
name|enteredname
operator|=
name|enterstring
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|hashindex
operator|=
name|SHORT_ABS
argument_list|(
operator|(
name|long
operator|)
name|enteredname
argument_list|)
operator|%
name|SYMBOLPRIME
expr_stmt|;
for|for
control|(
name|tablep
operator|=
name|symboltable
init|;
comment|/*return*/
condition|;
name|tablep
operator|=
name|tablep
operator|->
name|chain
control|)
block|{
if|if
condition|(
name|tablep
operator|==
name|NIL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[entersymbol] calloc\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|tablep
operator|=
operator|(
expr|struct
name|symboltableinfo
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symboltableinfo
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tablep
operator|==
name|NIL
condition|)
block|{
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"ran out of memory (entersymbol)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symboltable
operator|==
name|NIL
condition|)
block|{
name|symboltable
operator|=
name|tablep
expr_stmt|;
block|}
block|}
name|herep
operator|=
operator|&
operator|(
name|tablep
operator|->
name|entry
index|[
name|hashindex
index|]
operator|)
expr_stmt|;
name|limitp
operator|=
operator|&
operator|(
name|tablep
operator|->
name|entry
index|[
name|SYMBOLPRIME
index|]
operator|)
expr_stmt|;
name|increment
operator|=
literal|1
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[entersymbol] increment %d\n"
argument_list|,
name|increment
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
operator|*
name|herep
operator|==
name|NIL
condition|)
block|{
comment|/* empty */
if|if
condition|(
name|tablep
operator|->
name|used
operator|>
operator|(
operator|(
name|SYMBOLPRIME
operator|/
literal|3
operator|)
operator|*
literal|4
operator|)
condition|)
block|{
comment|/* too full, break for next table */
break|break;
block|}
name|tablep
operator|->
name|used
operator|++
expr_stmt|;
operator|*
name|herep
operator|=
name|symbolalloc
argument_list|()
expr_stmt|;
operator|(
operator|*
name|herep
operator|)
operator|->
name|name
operator|=
name|enteredname
expr_stmt|;
operator|(
operator|*
name|herep
operator|)
operator|->
name|lookup
operator|=
name|NEW
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[entersymbol] name %s NEW\n"
argument_list|,
name|enteredname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|*
name|herep
return|;
block|}
comment|/* a find? */
if|if
condition|(
operator|(
operator|*
name|herep
operator|)
operator|->
name|name
operator|==
name|enteredname
condition|)
block|{
operator|(
operator|*
name|herep
operator|)
operator|->
name|lookup
operator|=
name|OLD
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[entersymbol] name %s OLD\n"
argument_list|,
name|enteredname
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|*
name|herep
return|;
block|}
name|herep
operator|+=
name|increment
expr_stmt|;
if|if
condition|(
name|herep
operator|>=
name|limitp
condition|)
block|{
name|herep
operator|-=
name|SYMBOLPRIME
expr_stmt|;
block|}
name|increment
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|increment
operator|<
name|SYMBOLPRIME
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/*      *	allocate a symbol from the dynamically allocated symbol table.      */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|symbolalloc
parameter_list|()
block|{
specifier|static
name|struct
name|symbol
modifier|*
name|nextsymbol
init|=
name|NIL
decl_stmt|;
specifier|static
name|long
name|symbolsleft
init|=
literal|0
decl_stmt|;
name|struct
name|symbol
modifier|*
name|newsymbol
decl_stmt|;
if|if
condition|(
name|symbolsleft
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[symbolalloc] malloc\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|nextsymbol
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|malloc
argument_list|(
name|SYMBOLALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextsymbol
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"ran out of memory (symbolalloc)"
argument_list|)
expr_stmt|;
block|}
name|symbolsleft
operator|=
name|SYMBOLALLOC
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
expr_stmt|;
block|}
name|newsymbol
operator|=
name|nextsymbol
expr_stmt|;
name|nextsymbol
operator|++
expr_stmt|;
name|symbolsleft
operator|--
expr_stmt|;
return|return
name|newsymbol
return|;
block|}
end_function

begin_comment
comment|/*      *	hash a string based on all of its characters.      */
end_comment

begin_function
name|long
name|hashstring
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|long
name|value
decl_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|string
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
name|value
operator|=
operator|(
name|value
operator|*
literal|2
operator|)
operator|+
operator|*
name|cp
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/*      *	quadratically hashed string table.      *	things are never deleted from the hash string table.      *	as more hash table is needed,      *	a new one is alloc'ed and chained to the end.      *	search is by rehashing within each table,      *	traversing chains to next table if unsuccessful.      */
end_comment

begin_function
name|char
modifier|*
name|enterstring
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
specifier|static
name|struct
name|stringtableinfo
modifier|*
name|stringtable
init|=
name|NIL
decl_stmt|;
name|long
name|hashindex
decl_stmt|;
specifier|register
name|struct
name|stringtableinfo
modifier|*
name|tablep
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|herep
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|limitp
decl_stmt|;
specifier|register
name|long
name|increment
decl_stmt|;
name|hashindex
operator|=
name|SHORT_ABS
argument_list|(
name|hashstring
argument_list|(
name|string
argument_list|)
argument_list|)
operator|%
name|STRINGPRIME
expr_stmt|;
for|for
control|(
name|tablep
operator|=
name|stringtable
init|;
comment|/*return*/
condition|;
name|tablep
operator|=
name|tablep
operator|->
name|chain
control|)
block|{
if|if
condition|(
name|tablep
operator|==
name|NIL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[enterstring] calloc\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|tablep
operator|=
operator|(
expr|struct
name|stringtableinfo
operator|*
operator|)
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stringtableinfo
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tablep
operator|==
name|NIL
condition|)
block|{
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"ran out of memory (enterstring)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stringtable
operator|==
name|NIL
condition|)
block|{
name|stringtable
operator|=
name|tablep
expr_stmt|;
block|}
block|}
name|herep
operator|=
operator|&
operator|(
name|tablep
operator|->
name|entry
index|[
name|hashindex
index|]
operator|)
expr_stmt|;
name|limitp
operator|=
operator|&
operator|(
name|tablep
operator|->
name|entry
index|[
name|STRINGPRIME
index|]
operator|)
expr_stmt|;
name|increment
operator|=
literal|1
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[enterstring] increment %d\n"
argument_list|,
name|increment
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
operator|*
name|herep
operator|==
name|NIL
condition|)
block|{
comment|/* empty */
if|if
condition|(
name|tablep
operator|->
name|used
operator|>
operator|(
operator|(
name|STRINGPRIME
operator|/
literal|3
operator|)
operator|*
literal|4
operator|)
condition|)
block|{
comment|/* too full, break for next table */
break|break;
block|}
name|tablep
operator|->
name|used
operator|++
expr_stmt|;
operator|*
name|herep
operator|=
name|charalloc
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|*
name|herep
argument_list|,
name|string
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[enterstring] string %s copied\n"
argument_list|,
operator|*
name|herep
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|*
name|herep
return|;
block|}
comment|/* quick, check the first chars and then the rest */
if|if
condition|(
operator|*
operator|*
name|herep
operator|==
operator|*
name|string
operator|&&
name|strcmp
argument_list|(
operator|*
name|herep
argument_list|,
name|string
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[enterstring] string %s found\n"
argument_list|,
operator|*
name|herep
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
operator|*
name|herep
return|;
block|}
name|herep
operator|+=
name|increment
expr_stmt|;
if|if
condition|(
name|herep
operator|>=
name|limitp
condition|)
block|{
name|herep
operator|-=
name|STRINGPRIME
expr_stmt|;
block|}
name|increment
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|increment
operator|<
name|STRINGPRIME
condition|)
do|;
block|}
block|}
end_function

begin_comment
comment|/*      *	copy a string to the dynamically allocated character table.      */
end_comment

begin_function
name|char
modifier|*
name|charalloc
parameter_list|(
name|length
parameter_list|)
specifier|register
name|long
name|length
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|nextchar
init|=
name|NIL
decl_stmt|;
specifier|static
name|long
name|charsleft
init|=
literal|0
decl_stmt|;
specifier|register
name|long
name|lengthplus1
init|=
name|length
operator|+
literal|1
decl_stmt|;
specifier|register
name|long
name|askfor
decl_stmt|;
name|char
modifier|*
name|newstring
decl_stmt|;
if|if
condition|(
name|charsleft
operator|<
name|lengthplus1
condition|)
block|{
name|askfor
operator|=
name|lengthplus1
operator|>
name|CHARALLOC
condition|?
name|lengthplus1
else|:
name|CHARALLOC
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[charalloc] malloc( %d )\n"
argument_list|,
name|askfor
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|nextchar
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|askfor
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextchar
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
name|FATAL
argument_list|,
literal|"no room for %d characters"
argument_list|,
name|askfor
argument_list|)
expr_stmt|;
block|}
name|charsleft
operator|=
name|askfor
expr_stmt|;
block|}
name|newstring
operator|=
name|nextchar
expr_stmt|;
name|nextchar
operator|+=
name|lengthplus1
expr_stmt|;
name|charsleft
operator|-=
name|lengthplus1
expr_stmt|;
return|return
name|newstring
return|;
block|}
end_function

begin_comment
comment|/*      *	read an archive header for the next element      *	and find the offset of the one after this.       */
end_comment

begin_function
name|BOOL
name|nextelement
parameter_list|(
name|ofilep
parameter_list|)
name|struct
name|fileinfo
modifier|*
name|ofilep
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|long
name|red
decl_stmt|;
specifier|register
name|off_t
name|arsize
decl_stmt|;
name|struct
name|ar_hdr
name|archdr
decl_stmt|;
name|fseek
argument_list|(
name|ofilep
operator|->
name|file
argument_list|,
name|ofilep
operator|->
name|nextoffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|red
operator|=
name|fread
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|archdr
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
name|archdr
argument_list|,
name|ofilep
operator|->
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|red
operator|!=
sizeof|sizeof
name|archdr
condition|)
block|{
return|return
name|FALSE
return|;
block|}
comment|/* null terminate the blank-padded name */
name|cp
operator|=
operator|&
name|archdr
operator|.
name|ar_name
index|[
operator|(
sizeof|sizeof
name|archdr
operator|.
name|ar_name
operator|)
operator|-
literal|1
index|]
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
operator|--
name|cp
operator|==
literal|' '
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* set up the address of the beginning of next element */
name|arsize
operator|=
name|atol
argument_list|(
name|archdr
operator|.
name|ar_size
argument_list|)
expr_stmt|;
comment|/* archive elements are aligned on 0 mod 2 boundaries */
if|if
condition|(
name|arsize
operator|&
literal|1
condition|)
block|{
name|arsize
operator|+=
literal|1
expr_stmt|;
block|}
name|ofilep
operator|->
name|nextoffset
operator|=
name|ftell
argument_list|(
name|ofilep
operator|->
name|file
argument_list|)
operator|+
name|arsize
expr_stmt|;
comment|/* say we had one */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*      *	variable number of arguments to error, like printf.      */
end_comment

begin_macro
name|error
argument_list|(
argument|fatal
argument_list|,
argument|message
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|,
argument|arg4
argument_list|,
argument|arg5
argument_list|,
argument|arg6
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fatal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|message
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|,
name|arg6
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fatal
operator|==
name|FATAL
condition|)
block|{
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
name|errors
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	find the last modify time of a file.      *	on error, return the current time.      */
end_comment

begin_function
name|time_t
name|mtime
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|struct
name|stat
name|filestat
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[mtime] filename %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|filestat
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
name|WARNING
argument_list|,
literal|"%s: cannot open"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|time_t
operator|)
name|time
argument_list|(
literal|0
argument_list|)
operator|)
return|;
block|}
return|return
name|filestat
operator|.
name|st_mtime
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|classify
parameter_list|(
name|type
parameter_list|)
name|unsigned
name|char
name|type
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|N_PSO
case|:
return|return
literal|"source file"
return|;
case|case
name|N_PSOL
case|:
return|return
literal|"include file"
return|;
case|case
name|N_PGLABEL
case|:
return|return
literal|"label"
return|;
case|case
name|N_PGCONST
case|:
return|return
literal|"constant"
return|;
case|case
name|N_PGTYPE
case|:
return|return
literal|"type"
return|;
case|case
name|N_PGVAR
case|:
return|return
literal|"variable"
return|;
case|case
name|N_PGFUNC
case|:
return|return
literal|"function"
return|;
case|case
name|N_PGPROC
case|:
return|return
literal|"procedure"
return|;
case|case
name|N_PEFUNC
case|:
return|return
literal|"external function"
return|;
case|case
name|N_PEPROC
case|:
return|return
literal|"external procedure"
return|;
default|default:
return|return
literal|"unknown symbol"
return|;
block|}
block|}
end_function

end_unit

