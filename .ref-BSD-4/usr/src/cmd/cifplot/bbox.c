begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* *                                                                  * *    File: CIFPLOT/bbox.c                                          * *    Written by Dan Fitzpatrick                                    * *    copyright 1980 -- Regents of the University of California     * *                                                                  * ********************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"parser_defs.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_function_decl
name|IMPORT
name|transform
modifier|*
name|MakeTransform
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|transform
modifier|*
name|Rotate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|transform
modifier|*
name|Translate
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|point
modifier|*
name|MakePoint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|point
modifier|*
name|TransPt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|double
name|cos
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|ZeroBBox
argument_list|(
argument|bbox
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|BBox
modifier|*
name|bbox
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set bbox to the smallest possible value */
end_comment

begin_block
block|{
name|bbox
operator|->
name|xmin
operator|=
name|bbox
operator|->
name|ymin
operator|=
name|INFINITY
expr_stmt|;
name|bbox
operator|->
name|xmax
operator|=
name|bbox
operator|->
name|ymax
operator|=
operator|-
name|INFINITY
expr_stmt|;
block|}
end_block

begin_macro
name|ClearBBox
argument_list|(
argument|bbox
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|BBox
modifier|*
name|bbox
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set all values to 0  */
end_comment

begin_block
block|{
name|bbox
operator|->
name|xmin
operator|=
name|bbox
operator|->
name|ymin
operator|=
literal|0
expr_stmt|;
name|bbox
operator|->
name|xmax
operator|=
name|bbox
operator|->
name|ymax
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|MakeBBox
argument_list|(
argument|bbox
argument_list|,
argument|com
argument_list|)
end_macro

begin_decl_stmt
name|Command
modifier|*
name|com
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|BBox
modifier|*
name|bbox
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The bounding box for the Command 'com' is computed and  * stored in the location pointed to by 'bbox'	*/
end_comment

begin_block
block|{
name|Command
modifier|*
name|q
decl_stmt|;
name|PointList
modifier|*
name|p
decl_stmt|;
name|point
name|pt
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|transform
modifier|*
name|t
decl_stmt|,
modifier|*
name|t1
decl_stmt|;
name|struct
name|BBox
name|bb
decl_stmt|;
name|ZeroBBox
argument_list|(
name|bbox
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|com
operator|->
name|type
condition|)
block|{
case|case
name|POINTNAME
case|:
name|CompPtBBox
argument_list|(
name|bbox
argument_list|,
operator|&
operator|(
name|com
operator|->
name|Ctype
operator|.
name|PointName
operator|.
name|loc
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TEXT
case|:
break|break;
case|case
name|BOX
case|:
name|bb
operator|.
name|xmin
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bcenter
operator|.
name|x
operator|-
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|blength
operator|/
literal|2.0
expr_stmt|;
name|bb
operator|.
name|xmax
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bcenter
operator|.
name|x
operator|+
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|blength
operator|/
literal|2.0
expr_stmt|;
name|bb
operator|.
name|ymin
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bcenter
operator|.
name|y
operator|-
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bwidth
operator|/
literal|2.0
expr_stmt|;
name|bb
operator|.
name|ymax
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bcenter
operator|.
name|y
operator|+
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bwidth
operator|/
literal|2.0
expr_stmt|;
name|t
operator|=
name|MakeTransform
argument_list|()
expr_stmt|;
name|t1
operator|=
name|Translate
argument_list|(
operator|&
operator|(
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bcenter
operator|)
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|FreeTransform
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|Rotate
argument_list|(
operator|&
operator|(
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bdirect
operator|)
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|FreeTransform
argument_list|(
name|t1
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|MakePoint
argument_list|(
operator|-
operator|(
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bcenter
operator|.
name|x
operator|)
argument_list|,
operator|-
operator|(
name|com
operator|->
name|Ctype
operator|.
name|Box
operator|.
name|bcenter
operator|.
name|y
operator|)
argument_list|)
expr_stmt|;
name|t1
operator|=
name|Translate
argument_list|(
name|ptr
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|FreeTransform
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|BBoxTransform
argument_list|(
name|bbox
argument_list|,
operator|&
name|bb
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|FreeTransform
argument_list|(
name|t1
argument_list|)
expr_stmt|;
break|break;
case|case
name|FLASH
case|:
block|{
name|real
name|radius
decl_stmt|;
name|radius
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Flash
operator|.
name|fdia
operator|/
literal|2.0
expr_stmt|;
if|if
condition|(
name|circle
operator|!=
literal|0
condition|)
name|radius
operator|=
name|radius
operator|/
name|cos
argument_list|(
literal|3.1415926535
operator|/
operator|(
name|real
operator|)
name|circle
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|xmin
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Flash
operator|.
name|fcenter
operator|.
name|x
operator|-
name|radius
expr_stmt|;
name|bbox
operator|->
name|xmax
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Flash
operator|.
name|fcenter
operator|.
name|x
operator|+
name|radius
expr_stmt|;
name|bbox
operator|->
name|ymin
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Flash
operator|.
name|fcenter
operator|.
name|y
operator|-
name|radius
expr_stmt|;
name|bbox
operator|->
name|ymax
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Flash
operator|.
name|fcenter
operator|.
name|y
operator|+
name|radius
expr_stmt|;
block|}
break|break;
case|case
name|POLYGON
case|:
comment|/* The bounding box must surround every point in the polygon */
for|for
control|(
name|p
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Path
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|PLink
control|)
name|CompPtBBox
argument_list|(
name|bbox
argument_list|,
operator|&
operator|(
name|p
operator|->
name|pt
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|WIRE
case|:
block|{
name|real
name|scale
decl_stmt|;
if|if
condition|(
name|circle
operator|==
literal|0
condition|)
name|scale
operator|=
literal|1.0
expr_stmt|;
else|else
name|scale
operator|=
literal|1.0
operator|/
name|cos
argument_list|(
literal|3.1415926535
operator|/
operator|(
name|real
operator|)
name|circle
argument_list|)
expr_stmt|;
comment|/* The bounding box surrounds the wire */
for|for
control|(
name|p
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Wire
operator|.
name|WPath
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|p
operator|->
name|PLink
control|)
name|CompPtBBox
argument_list|(
name|bbox
argument_list|,
operator|&
operator|(
name|p
operator|->
name|pt
operator|)
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|xmin
operator|-=
name|scale
operator|*
name|com
operator|->
name|Ctype
operator|.
name|Wire
operator|.
name|WWidth
operator|/
literal|2.0
expr_stmt|;
name|bbox
operator|->
name|ymin
operator|-=
name|scale
operator|*
name|com
operator|->
name|Ctype
operator|.
name|Wire
operator|.
name|WWidth
operator|/
literal|2.0
expr_stmt|;
name|bbox
operator|->
name|xmax
operator|+=
name|scale
operator|*
name|com
operator|->
name|Ctype
operator|.
name|Wire
operator|.
name|WWidth
operator|/
literal|2.0
expr_stmt|;
name|bbox
operator|->
name|ymax
operator|+=
name|scale
operator|*
name|com
operator|->
name|Ctype
operator|.
name|Wire
operator|.
name|WWidth
operator|/
literal|2.0
expr_stmt|;
block|}
break|break;
case|case
name|SYMBOL
case|:
comment|/* The bounding box must surround every command in the symbol */
for|for
control|(
name|q
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|CStart
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|q
operator|->
name|CLink
control|)
block|{
name|CompBBox
argument_list|(
name|bbox
argument_list|,
operator|&
operator|(
name|q
operator|->
name|CBBox
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CALL
case|:
if|if
condition|(
name|com
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|CSymb
operator|==
name|NIL
condition|)
break|break;
comment|/* The bounding box must contain all the corners of the 		 * symbol's bounding box after it has been transformed */
name|BBoxTransform
argument_list|(
name|bbox
argument_list|,
operator|&
operator|(
name|com
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|CSymb
operator|->
name|CBBox
operator|)
argument_list|,
name|com
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|trans
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|q
operator|=
name|com
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|ACom
expr_stmt|;
name|MakeBBox
argument_list|(
operator|&
operator|(
name|q
operator|->
name|CBBox
operator|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|MakeBBox
argument_list|(
operator|&
operator|(
name|com
operator|->
name|CBBox
operator|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|pt
operator|.
name|x
operator|=
operator|(
name|com
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|Adx
operator|<
literal|0
operator|)
condition|?
name|com
operator|->
name|CBBox
operator|.
name|xmin
operator|+
name|com
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|Adx
operator|*
operator|(
name|com
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|Am
operator|-
literal|1
operator|)
else|:
name|com
operator|->
name|CBBox
operator|.
name|xmax
operator|+
name|com
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|Adx
operator|*
operator|(
name|com
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|Am
operator|-
literal|1
operator|)
expr_stmt|;
name|pt
operator|.
name|y
operator|=
operator|(
name|com
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|Ady
operator|<
literal|0
operator|)
condition|?
name|com
operator|->
name|CBBox
operator|.
name|ymin
operator|+
name|com
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|Ady
operator|*
operator|(
name|com
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|An
operator|-
literal|1
operator|)
else|:
name|com
operator|->
name|CBBox
operator|.
name|ymax
operator|+
name|com
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|Ady
operator|*
operator|(
name|com
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|An
operator|-
literal|1
operator|)
expr_stmt|;
name|CompPtBBox
argument_list|(
operator|&
operator|(
name|com
operator|->
name|CBBox
operator|)
argument_list|,
operator|&
name|pt
argument_list|)
expr_stmt|;
name|bbox
operator|->
name|xmin
operator|=
name|com
operator|->
name|CBBox
operator|.
name|xmin
expr_stmt|;
name|bbox
operator|->
name|xmax
operator|=
name|com
operator|->
name|CBBox
operator|.
name|xmax
expr_stmt|;
name|bbox
operator|->
name|ymin
operator|=
name|com
operator|->
name|CBBox
operator|.
name|ymin
expr_stmt|;
name|bbox
operator|->
name|ymax
operator|=
name|com
operator|->
name|CBBox
operator|.
name|ymax
expr_stmt|;
break|break;
default|default:
name|Error
argument_list|(
literal|"Attempted to make bounding box for inappropriate command"
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|BBoxTransform
argument_list|(
argument|bb
argument_list|,
argument|sbb
argument_list|,
argument|trans
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|BBox
modifier|*
name|bb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|BBox
modifier|*
name|sbb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|transform
modifier|*
name|trans
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Transform the bounding box 'sbb' by transform 'trans' and expand  * 'bb' till it contains the transformed 'sbb' bounding box.  */
end_comment

begin_block
block|{
name|real
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* For every corner of bounding box 'sbb', transform it and      * make 'bb' contain that transformed corner	*/
name|x
operator|=
name|sbb
operator|->
name|xmin
expr_stmt|;
name|y
operator|=
name|sbb
operator|->
name|ymin
expr_stmt|;
name|Trans
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|trans
argument_list|)
expr_stmt|;
name|CompNumBBox
argument_list|(
name|bb
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|sbb
operator|->
name|xmax
expr_stmt|;
name|y
operator|=
name|sbb
operator|->
name|ymin
expr_stmt|;
name|Trans
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|trans
argument_list|)
expr_stmt|;
name|CompNumBBox
argument_list|(
name|bb
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|sbb
operator|->
name|xmax
expr_stmt|;
name|y
operator|=
name|sbb
operator|->
name|ymax
expr_stmt|;
name|Trans
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|trans
argument_list|)
expr_stmt|;
name|CompNumBBox
argument_list|(
name|bb
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|x
operator|=
name|sbb
operator|->
name|xmin
expr_stmt|;
name|y
operator|=
name|sbb
operator|->
name|ymax
expr_stmt|;
name|Trans
argument_list|(
operator|&
name|x
argument_list|,
operator|&
name|y
argument_list|,
name|trans
argument_list|)
expr_stmt|;
name|CompNumBBox
argument_list|(
name|bb
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|CompBBox
argument_list|(
argument|bb1
argument_list|,
argument|bb2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|BBox
modifier|*
name|bb1
decl_stmt|,
modifier|*
name|bb2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand bb1 so that it encloses bb2 */
end_comment

begin_block
block|{
if|if
condition|(
name|bb1
operator|->
name|xmin
operator|>
name|bb2
operator|->
name|xmin
condition|)
name|bb1
operator|->
name|xmin
operator|=
name|bb2
operator|->
name|xmin
expr_stmt|;
if|if
condition|(
name|bb1
operator|->
name|ymin
operator|>
name|bb2
operator|->
name|ymin
condition|)
name|bb1
operator|->
name|ymin
operator|=
name|bb2
operator|->
name|ymin
expr_stmt|;
if|if
condition|(
name|bb1
operator|->
name|xmax
operator|<
name|bb2
operator|->
name|xmax
condition|)
name|bb1
operator|->
name|xmax
operator|=
name|bb2
operator|->
name|xmax
expr_stmt|;
if|if
condition|(
name|bb1
operator|->
name|ymax
operator|<
name|bb2
operator|->
name|ymax
condition|)
name|bb1
operator|->
name|ymax
operator|=
name|bb2
operator|->
name|ymax
expr_stmt|;
block|}
end_block

begin_macro
name|CompPtBBox
argument_list|(
argument|bb
argument_list|,
argument|pt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|BBox
modifier|*
name|bb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|point
modifier|*
name|pt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand bb so that it encloses pt */
end_comment

begin_block
block|{
if|if
condition|(
name|bb
operator|->
name|xmin
operator|>
name|pt
operator|->
name|x
condition|)
name|bb
operator|->
name|xmin
operator|=
name|pt
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|ymin
operator|>
name|pt
operator|->
name|y
condition|)
name|bb
operator|->
name|ymin
operator|=
name|pt
operator|->
name|y
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|xmax
operator|<
name|pt
operator|->
name|x
condition|)
name|bb
operator|->
name|xmax
operator|=
name|pt
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|ymax
operator|<
name|pt
operator|->
name|y
condition|)
name|bb
operator|->
name|ymax
operator|=
name|pt
operator|->
name|y
expr_stmt|;
block|}
end_block

begin_macro
name|CompNumBBox
argument_list|(
argument|bb
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|BBox
modifier|*
name|bb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|real
name|x
decl_stmt|,
name|y
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Expand bb so that in encloses (x,y) */
end_comment

begin_block
block|{
if|if
condition|(
name|bb
operator|->
name|xmin
operator|>
name|x
condition|)
name|bb
operator|->
name|xmin
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|ymin
operator|>
name|y
condition|)
name|bb
operator|->
name|ymin
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|xmax
operator|<
name|x
condition|)
name|bb
operator|->
name|xmax
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|bb
operator|->
name|ymax
operator|<
name|y
condition|)
name|bb
operator|->
name|ymax
operator|=
name|y
expr_stmt|;
block|}
end_block

end_unit

