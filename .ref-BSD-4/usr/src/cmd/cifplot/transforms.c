begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* *                                                                  * *    File: CIFPLOT/transforms.c                                    * *    Written by Dan Fitzpatrick                                    * *    copyright 1980 -- Regents of the University of California     * *                                                                  * ********************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"parser_defs.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_function_decl
name|IMPORT
name|alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|point
modifier|*
name|MakePoint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|char
modifier|*
name|Concat
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|transform
modifier|*
name|CurTransform
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|TCell
modifier|*
name|TransStack
decl_stmt|;
end_decl_stmt

begin_function
name|transform
modifier|*
name|MatrixMult
parameter_list|(
name|t1
parameter_list|,
name|t2
parameter_list|)
specifier|register
name|transform
modifier|*
name|t1
decl_stmt|,
decl|*
name|t2
decl_stmt|;
end_function

begin_comment
comment|/* Return a pointer to a transform that is the product of 't1'& 't2' */
end_comment

begin_block
block|{
specifier|register
name|transform
modifier|*
name|out
decl_stmt|;
comment|/*     int i,j,k;     */
name|out
operator|=
name|GetTransform
argument_list|()
expr_stmt|;
name|out
operator|->
name|refs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
name|out
operator|->
name|TransString
operator|=
name|Concat
argument_list|(
name|t1
operator|->
name|TransString
argument_list|,
name|t2
operator|->
name|TransString
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*     for(i=0; i<3; i++) 	for(j=0; j<3; j++) 	    out->t[i][j] = 0;      for(i=0; i<3; i++) 	for(j=0; j<3; j++) 	    for(k=0; k<3; k++) 		out->t[i][j] = out->t[i][j] + t1->t[i][k]*t2->t[k][j]; 		*/
name|out
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
name|t1
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|t1
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|out
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
name|t1
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
name|t1
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|out
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
name|t1
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|t1
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
name|out
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
name|t1
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
name|t1
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|out
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|t1
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|t1
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|t2
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|out
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|t1
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
name|t1
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|*
name|t2
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+
name|t2
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
end_block

begin_function
name|transform
modifier|*
name|MakeTransform
parameter_list|()
comment|/* Return a pointer to an identity transform */
block|{
name|transform
modifier|*
name|trans
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|trans
operator|=
name|GetTransform
argument_list|()
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
name|trans
operator|->
name|TransString
operator|=
name|Concat
argument_list|(
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trans
operator|->
name|refs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|==
name|j
condition|)
name|trans
operator|->
name|t
index|[
name|i
index|]
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
else|else
name|trans
operator|->
name|t
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|trans
operator|)
return|;
block|}
end_function

begin_function
name|transform
modifier|*
name|CopyTransform
parameter_list|(
name|t
parameter_list|)
name|transform
modifier|*
name|t
decl_stmt|;
block|{
name|transform
modifier|*
name|temp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|temp
operator|=
name|MakeTransform
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|temp
operator|->
name|t
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|t
operator|->
name|t
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
return|return
operator|(
name|temp
operator|)
return|;
block|}
end_function

begin_function
name|transform
modifier|*
name|Mirror
parameter_list|(
name|ch
parameter_list|,
name|trans
parameter_list|)
name|char
name|ch
decl_stmt|;
name|transform
modifier|*
name|trans
decl_stmt|;
comment|/* Return a pointer to a transform that does a mirroring about the  * axis specified in 'ch' combined with the effect of 'trans' */
block|{
name|transform
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temp2
decl_stmt|;
name|temp
operator|=
name|MakeTransform
argument_list|()
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
name|Free
argument_list|(
name|temp
operator|->
name|TransString
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'y'
operator|||
name|ch
operator|==
literal|'Y'
condition|)
block|{
name|temp
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
name|temp
operator|->
name|TransString
operator|=
name|Concat
argument_list|(
literal|" MY"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'x'
operator|||
name|ch
operator|==
literal|'X'
condition|)
block|{
name|temp
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
name|temp
operator|->
name|TransString
operator|=
name|Concat
argument_list|(
literal|" MX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Error
argument_list|(
literal|"Mirror call about unknown axis"
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
name|temp
operator|->
name|TransString
operator|=
name|Concat
argument_list|(
literal|" XX"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|temp2
operator|=
name|MatrixMult
argument_list|(
name|temp
argument_list|,
name|trans
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
name|Free
argument_list|(
name|temp
operator|->
name|TransString
argument_list|)
expr_stmt|;
name|FreeTransform
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp2
operator|)
return|;
block|}
end_function

begin_function
name|transform
modifier|*
name|Rotate
parameter_list|(
name|pt
parameter_list|,
name|trans
parameter_list|)
name|point
modifier|*
name|pt
decl_stmt|;
name|transform
modifier|*
name|trans
decl_stmt|;
comment|/* Return a pointer to a transform that does a rotation to a vector  * specified by 'pt' combined with the effect of trans. */
block|{
name|transform
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temp2
decl_stmt|;
name|real
name|c
decl_stmt|;
name|char
name|s
index|[
literal|128
index|]
decl_stmt|;
name|temp
operator|=
name|MakeTransform
argument_list|()
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
block|{
name|Free
argument_list|(
name|temp
operator|->
name|TransString
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|" R %d %d"
argument_list|,
name|TRUNC
argument_list|(
name|pt
operator|->
name|x
argument_list|)
argument_list|,
name|TRUNC
argument_list|(
name|pt
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|TransString
operator|=
name|Concat
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
operator|(
name|real
operator|)
name|sqrt
argument_list|(
call|(
name|double
call|)
argument_list|(
operator|(
name|pt
operator|->
name|x
operator|)
operator|*
operator|(
name|pt
operator|->
name|x
operator|)
operator|+
operator|(
name|pt
operator|->
name|y
operator|)
operator|*
operator|(
name|pt
operator|->
name|y
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Watch out for divide by 0 */
if|if
condition|(
operator|-
literal|0.00001
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|0.00001
condition|)
name|Error
argument_list|(
literal|"Attempted to divide by zero"
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
name|temp
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|(
name|pt
operator|->
name|x
operator|)
operator|/
name|c
expr_stmt|;
name|temp
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|pt
operator|->
name|y
operator|)
operator|/
name|c
expr_stmt|;
name|temp
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|=
operator|-
operator|(
name|pt
operator|->
name|y
operator|)
operator|/
name|c
expr_stmt|;
name|temp
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
operator|(
name|pt
operator|->
name|x
operator|)
operator|/
name|c
expr_stmt|;
name|temp2
operator|=
name|MatrixMult
argument_list|(
name|temp
argument_list|,
name|trans
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
name|Free
argument_list|(
name|temp
operator|->
name|TransString
argument_list|)
expr_stmt|;
name|FreeTransform
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp2
operator|)
return|;
block|}
end_function

begin_function
name|transform
modifier|*
name|Translate
parameter_list|(
name|pt
parameter_list|,
name|trans
parameter_list|)
name|point
modifier|*
name|pt
decl_stmt|;
name|transform
modifier|*
name|trans
decl_stmt|;
comment|/* Return a pointer to a transform that translates points by the vector  * 'pt' combined with the effects of 'trans'. */
block|{
name|transform
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temp2
decl_stmt|;
name|char
name|s
index|[
literal|128
index|]
decl_stmt|;
name|temp
operator|=
name|MakeTransform
argument_list|()
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
block|{
name|Free
argument_list|(
name|temp
operator|->
name|TransString
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|" T %d %d"
argument_list|,
name|TRUNC
argument_list|(
name|pt
operator|->
name|x
argument_list|)
argument_list|,
name|TRUNC
argument_list|(
name|pt
operator|->
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|TransString
operator|=
name|Concat
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|temp
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|0
index|]
operator|=
name|pt
operator|->
name|x
expr_stmt|;
name|temp
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|1
index|]
operator|=
name|pt
operator|->
name|y
expr_stmt|;
name|temp2
operator|=
name|MatrixMult
argument_list|(
name|temp
argument_list|,
name|trans
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
name|Free
argument_list|(
name|temp
operator|->
name|TransString
argument_list|)
expr_stmt|;
name|FreeTransform
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp2
operator|)
return|;
block|}
end_function

begin_function
name|transform
modifier|*
name|Scale
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|trans
parameter_list|)
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|transform
modifier|*
name|trans
decl_stmt|;
comment|/* Return a pointer to a transform that scales points by a/b  * combined with the effects of 'trans'. */
block|{
name|transform
modifier|*
name|temp
decl_stmt|,
modifier|*
name|temp2
decl_stmt|;
name|char
name|s
index|[
literal|128
index|]
decl_stmt|;
name|temp
operator|=
name|MakeTransform
argument_list|()
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
block|{
name|Free
argument_list|(
name|temp
operator|->
name|TransString
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|" S %d %d"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|temp
operator|->
name|TransString
operator|=
name|Concat
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|temp
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|real
operator|)
name|a
operator|)
operator|/
operator|(
operator|(
name|real
operator|)
name|b
operator|)
expr_stmt|;
name|temp
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|real
operator|)
name|a
operator|)
operator|/
operator|(
operator|(
name|real
operator|)
name|b
operator|)
expr_stmt|;
name|temp2
operator|=
name|MatrixMult
argument_list|(
name|temp
argument_list|,
name|trans
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NOPLOT
condition|)
name|Free
argument_list|(
name|temp
operator|->
name|TransString
argument_list|)
expr_stmt|;
name|FreeTransform
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
operator|(
name|temp2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* real MakeFloat(a,b) int a,b; {     real f,d;     int rem;     f = 0.0;     d = 1.0;      while(b>0) { 	rem = b%10; 	d = d*0.1; 	f = f + ((real) rem)*d; 	b = TRUNC(b/10); 	}     return(a>=0 ? ((real) a) + f: ((real) a) - f);     }     */
end_comment

begin_comment
comment|/* transform * ReadTransform(a,b,c,d,e,f,g,h,i,j,k,l,t) int a,b,c,d,e,f; int g,h,i,j,k,l; transform *t; {     transform *temp,*temp2;     temp = MakeTransform();     temp->t[0][0] = MakeFloat(a,b);     temp->t[0][1] = MakeFloat(c,d);     temp->t[1][0] = MakeFloat(e,f);     temp->t[1][1] = MakeFloat(g,h);     temp->t[2][0] = MakeFloat(i,j);     temp->t[2][1] = MakeFloat(k,l);     temp2 = MatrixMult(temp,t);     FreeTransform(temp);     return(temp2);     }     */
end_comment

begin_comment
comment|/* float MakeFlt(i,d) int i; float d; {     float f;      f = (i< 0) ? i - d : i + d;     return(f);     }  float Float(ch,f) char ch; float f; {     float d;      d = 0.1*((float) ((ch -'0') + f));     return(d);     }     */
end_comment

begin_function
name|point
modifier|*
name|TransPt
parameter_list|(
name|pt
parameter_list|,
name|trans
parameter_list|)
name|point
modifier|*
name|pt
decl_stmt|;
name|transform
modifier|*
name|trans
decl_stmt|;
comment|/* Transform point */
block|{
name|real
name|x
decl_stmt|,
name|y
decl_stmt|;
name|x
operator|=
name|pt
operator|->
name|x
operator|*
name|trans
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
name|pt
operator|->
name|y
operator|*
name|trans
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|trans
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
name|y
operator|=
name|pt
operator|->
name|x
operator|*
name|trans
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
name|pt
operator|->
name|y
operator|*
name|trans
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+
name|trans
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|MakePoint
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|Trans
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|trans
argument_list|)
specifier|register
name|real
operator|*
name|x
operator|,
operator|*
name|y
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|transform
modifier|*
name|trans
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|real
name|z
decl_stmt|;
name|z
operator|=
operator|*
name|x
expr_stmt|;
operator|*
name|x
operator|=
name|z
operator|*
name|trans
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|+
operator|(
operator|*
name|y
operator|)
operator|*
name|trans
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|+
name|trans
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|y
operator|=
name|z
operator|*
name|trans
operator|->
name|t
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|+
operator|(
operator|*
name|y
operator|)
operator|*
name|trans
operator|->
name|t
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|+
name|trans
operator|->
name|t
index|[
literal|2
index|]
index|[
literal|1
index|]
expr_stmt|;
block|}
end_block

begin_comment
comment|/* InitTransform() {     TransStack = NIL;     CurTransform = MakeTransform();     }  PushTransform(trans) transform *trans; /* Push the Current Transform on the transform stack. Multiply  * 'trans' by old Current Transform and make the product the  * Current Traansform.	*/
end_comment

begin_comment
comment|/* {     struct TCell *p;      p = (struct TCell *) alloc(sizeof(struct TCell));     p->TPtr = CurTransform;     p->TLink = TransStack;     TransStack = p;     CurTransform = MatrixMult(CurTransform,trans);     return;     }  transform * PopTransform() /* Replace the Current Transform by the top of the transform stack  * and pop the transform stack */
end_comment

begin_comment
comment|/* {     struct TCell *t;      if(TransStack == NIL) 	Error("Attempted to Pop empty Transform Stack",INTERNAL);     CurTransform = TransStack->TPtr;     t = TransStack;     TransStack = TransStack->TLink;     FreeTransform(t);     return(CurTransform);     }     */
end_comment

end_unit

