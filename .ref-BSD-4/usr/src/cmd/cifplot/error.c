begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* *                                                                  * *    File: CIFPLOT/error.c                                         * *    Written by Dan Fitzpatrick                                    * *    copyright 1980 -- Regents of the University of California     * *                                                                  * ********************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"scanner.h"
end_include

begin_function_decl
name|IMPORT
name|string
name|Concat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|alloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The struct 'ErrorType' is used to create a linked listed which  * contains error messages. The error messages are held till the  * entire line has been read, then are printed out with an arrow  * marking the spot where the error occured. */
end_comment

begin_struct
struct|struct
name|ErrorType
block|{
name|struct
name|ErrorType
modifier|*
name|ELink
decl_stmt|;
name|int
name|LineNo
decl_stmt|,
name|CharNo
decl_stmt|;
name|string
name|EString
decl_stmt|;
block|}
modifier|*
name|ErrorList
struct|,
modifier|*
name|ErrorEnd
struct|;
end_struct

begin_decl_stmt
name|int
name|FatalError
decl_stmt|;
end_decl_stmt

begin_macro
name|yyerror
argument_list|()
end_macro

begin_comment
comment|/* YACC wants this */
end_comment

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|Error
argument_list|(
argument|s
argument_list|,
argument|type
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'Error' is the general error reporting facility */
end_comment

begin_block
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|INTERNAL
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal Error: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|RUNTIME
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Run Time Error: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
case|case
name|WARNING
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"warning: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|DispError
argument_list|(
name|TokenLine
argument_list|,
name|TokenChar
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECOVERABLE
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"error: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|DispError
argument_list|(
name|TokenLine
argument_list|,
name|TokenChar
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|FATAL
case|:
name|FatalError
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Error: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|DispError
argument_list|(
name|TokenLine
argument_list|,
name|TokenChar
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown Error Type: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|DispError
argument_list|(
argument|ln
argument_list|,
argument|cn
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|int
name|ln
decl_stmt|,
name|cn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|string
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'DispError' places an error message,'s', on the error list */
end_comment

begin_block
block|{
name|struct
name|ErrorType
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|ErrorType
operator|*
operator|)
name|alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ErrorType
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|LineNo
operator|=
name|ln
expr_stmt|;
name|p
operator|->
name|CharNo
operator|=
name|cn
expr_stmt|;
name|p
operator|->
name|EString
operator|=
name|Concat
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ErrorList
operator|==
name|NIL
condition|)
block|{
name|ErrorEnd
operator|=
name|ErrorList
operator|=
name|p
expr_stmt|;
block|}
else|else
name|ErrorEnd
operator|->
name|ELink
operator|=
name|p
expr_stmt|;
name|ErrorEnd
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|ELink
operator|=
name|NIL
expr_stmt|;
name|PrintError
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|PrintError
argument_list|()
end_macro

begin_comment
comment|/* 'PrintError' prints the error messages on 'ErrorList' if the  * line which the error occured on has been completely read in. */
end_comment

begin_block
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
name|ErrorList
operator|!=
name|NIL
condition|)
block|{
name|PrintLine
argument_list|(
name|ErrorList
operator|->
name|LineNo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ErrorList
operator|->
name|LineNo
operator|<=
name|maxlines
condition|)
block|{
if|if
condition|(
name|ErrorList
operator|->
name|LineNo
operator|<
name|maxlines
condition|)
block|{
comment|/* The line which the error occured on has been passed. 		 * Print the line number and the message	*/
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d  %s\n"
argument_list|,
name|ErrorList
operator|->
name|LineNo
argument_list|,
name|ErrorList
operator|->
name|EString
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A negitive CharNo indicates the error was on 		 * the previous line	*/
if|if
condition|(
name|ErrorList
operator|->
name|CharNo
operator|<
literal|0
condition|)
name|ErrorList
operator|->
name|CharNo
operator|=
name|OldLength
operator|-
name|ErrorList
operator|->
name|CharNo
operator|-
literal|2
expr_stmt|;
comment|/* Print the line number */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%6d----"
argument_list|,
name|ErrorList
operator|->
name|LineNo
argument_list|)
expr_stmt|;
comment|/* Step out the proper number of places and put an up- 		 * arrow under the offender.	*/
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ErrorList
operator|->
name|CharNo
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"^----"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ErrorList
operator|->
name|CharNo
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
comment|/* Print the error message */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|ErrorList
operator|->
name|EString
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|ErrorList
operator|->
name|EString
argument_list|)
expr_stmt|;
block|}
name|ErrorList
operator|=
name|ErrorList
operator|->
name|ELink
expr_stmt|;
block|}
else|else
comment|/* If we have not reached the offending line just return */
return|return;
block|}
block|}
end_block

begin_macro
name|ErrorSummary
argument_list|()
end_macro

begin_block
block|{
name|PrintError
argument_list|()
expr_stmt|;
while|while
condition|(
name|ErrorList
operator|!=
name|NIL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Line %d  %s\n"
argument_list|,
name|ErrorList
operator|->
name|LineNo
argument_list|,
name|ErrorList
operator|->
name|EString
argument_list|)
expr_stmt|;
name|ErrorList
operator|=
name|ErrorList
operator|->
name|ELink
expr_stmt|;
block|}
if|if
condition|(
name|FatalError
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Plotting Supressed\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_extern
extern|extern Abort(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Forward reference Abort	*/
end_comment

begin_extern
extern|extern Trap(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* Forward reference Trap	*/
end_comment

begin_macro
name|InitError
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|ErrorList
operator|=
name|NIL
expr_stmt|;
name|ErrorEnd
operator|=
name|NIL
expr_stmt|;
name|FatalError
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|==
name|SIG_IGN
condition|)
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|background
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|Trap
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|Trap
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|Trap
argument_list|)
expr_stmt|;
name|background
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Catch traps */
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|signal
argument_list|(
name|i
argument_list|,
name|Trap
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* background() {     signal(SIGHUP,SIG_IGN);     signal(SIGQUIT,SIG_IGN);     signal(SIGINT,SIG_IGN);     }     */
end_comment

begin_macro
name|Trap
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|SIGHUP
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hangup - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGINT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"interrupt - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGQUIT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"quit - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGILL
case|:
break|break;
case|case
name|SIGTRAP
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"trap - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGIOT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"IOT instruction - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGEMT
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"EMT instruction - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGFPE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"floating point exception - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGBUS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bus error - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGSEGV
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"segmentation violation - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGSYS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"bad argument to system call - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGPIPE
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"write on a pipe with no one to read it - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGALRM
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"alarm clock - "
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGTERM
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cifplot killed - "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown error - "
argument_list|)
expr_stmt|;
break|break;
block|}
name|Abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|Abort
argument_list|()
end_macro

begin_comment
comment|/* Abort does a semi-graceful closing of the program */
end_comment

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"abort\n"
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/*     Summary();     */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileopen
condition|)
block|{
name|DumpBuf
argument_list|(
operator|-
name|INFINITY
argument_list|)
expr_stmt|;
name|vclose
argument_list|()
expr_stmt|;
block|}
name|unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|AllocSummary
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

