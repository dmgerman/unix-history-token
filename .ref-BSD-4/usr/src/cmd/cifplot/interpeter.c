begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* *                                                                  * *    File: CIFPLOT/interpeter.c                                    * *    Written by Dan Fitzpatrick                                    * *    copyright 1980 -- Regents of the University of California     * *                                                                  * ********************************************************************/
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"globals.h"
end_include

begin_include
include|#
directive|include
file|"parser_defs.h"
end_include

begin_include
include|#
directive|include
file|"structs.h"
end_include

begin_include
include|#
directive|include
file|"alloc.h"
end_include

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|FindSymbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|State
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|PrintCommand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|AddCmd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Command
modifier|*
name|MakeSymbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|StoreSymbol
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Error
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|Free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|MakeBBox
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|IMPORT
name|transform
modifier|*
name|MakeTransform
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|Execute
argument_list|(
argument|command
argument_list|)
end_macro

begin_decl_stmt
name|Command
modifier|*
name|command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Execute is called by the parser to interpet all the top  * level commands.		*/
end_comment

begin_block
block|{
name|Command
modifier|*
name|q
decl_stmt|;
name|int
name|n
decl_stmt|;
switch|switch
condition|(
name|command
operator|->
name|type
condition|)
block|{
case|case
name|COMMENT
case|:
comment|/* Ignore comments */
name|FreeCommand
argument_list|(
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL
case|:
comment|/* Store symbols in the symbol table */
name|n
operator|=
name|State
argument_list|(
name|command
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|SymNo
argument_list|)
expr_stmt|;
comment|/* Only Store if it is not already stored */
if|if
condition|(
operator|(
name|n
operator|==
name|NONEXIST
operator|)
operator|||
operator|(
name|n
operator|==
name|DELETED
operator|)
condition|)
name|StoreSymbol
argument_list|(
name|command
argument_list|)
expr_stmt|;
comment|/* If the symbol was previously called it's status 		 * becomes USED so we 'Examine' all it's commands */
if|if
condition|(
name|command
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|status
operator|==
name|UNEXAMINED
condition|)
block|{
name|command
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|status
operator|=
name|ACTIVE
expr_stmt|;
for|for
control|(
name|q
operator|=
name|command
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|CStart
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|q
operator|->
name|CLink
control|)
name|Examine
argument_list|(
name|q
argument_list|,
name|command
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|SymNo
argument_list|)
expr_stmt|;
name|command
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|status
operator|=
name|USED
expr_stmt|;
block|}
break|break;
case|case
name|ARRAY
case|:
case|case
name|CALL
case|:
comment|/* The call may use a new symbol so we call 'Examine' 		 * to compute bounding boxes and dependencies.   */
name|Examine
argument_list|(
name|command
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Fall through */
default|default:
comment|/* Add the command to the pseudo-symbol 'prog' */
name|prog
operator|=
name|AddCmd
argument_list|(
name|prog
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_escape
end_escape

begin_macro
name|Examine
argument_list|(
argument|sym
argument_list|,
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|Command
modifier|*
name|sym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 'Examine' sets up the data structures used to handle forward references  * and symbol renaming. It is invoked any time a symbol becomes 'USED' or a  * call is made on a symbol at the top level. (i.e. the call is not part of a   * symbol). It is called with a command and an integer n which is the symbol  * the call is contained in. (If the call is at the top level n = -1)  *  * If the command is a call, the state of the symbol which is called is checked  * to see if is UNUSED. Since this call changes the state of the symbol to  * used this is recorded. Examine is called on all the commands of the symbol.  * (This is necessary since 'Examine' must be called any time a symbol becomes  * used.)  *  * The called symbol may be non-existent at the time of the call. (This is  * an error condition since CIF requires all symbols definitions to be defined  * before they are needed.) In this case a symbol header is created with the  * status of 'UNDEFINED'.  *  * There are two other valid states the called symbol can be in, these are  * 'USED' and 'UNDEFINED'. If the symbol is in some other state we know there  * exists some inconsistancy in the data and the program is aborted.  *  * Thus far it appears that all examine does is call itself on other commands  * whenever a symbol becomes used. The real work of this function, however,  * is to record which symbol calls which. The number of the symbol that called  * the symbol we are examining is passed as the parameter 'n'. If n is -1 we  * are not interested in it. Any other value means this symbol was called by  * symbol n. We then add symbol n to the symbol's 'backTrace' list. If the   * symbol is the redefined or deleted we know of all the dangling references  * to this symbol.  *  * Further 'Examine' computes the bounding boxes for each command and checks  * for recursion  */
end_comment

begin_block
block|{
name|Command
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|struct
name|CCell
modifier|*
name|cell
decl_stmt|;
name|char
name|s
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|sym
operator|->
name|type
operator|==
name|ARRAY
condition|)
name|Examine
argument_list|(
name|sym
operator|->
name|Ctype
operator|.
name|Array
operator|.
name|ACom
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|type
operator|==
name|CALL
condition|)
block|{
switch|switch
condition|(
name|State
argument_list|(
name|sym
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|CallNo
argument_list|)
condition|)
block|{
case|case
name|NONEXIST
case|:
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"Symbol %d Undefined"
argument_list|,
name|sym
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|CallNo
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|s
argument_list|,
name|FATAL
argument_list|)
expr_stmt|;
name|p
operator|=
name|MakeSymbol
argument_list|(
name|sym
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|CallNo
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|status
operator|=
name|UNDEFINED
expr_stmt|;
name|StoreSymbol
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ClearBBox
argument_list|(
operator|&
operator|(
name|p
operator|->
name|CBBox
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNUSED
case|:
name|p
operator|=
name|FindSymbol
argument_list|(
name|sym
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|CallNo
argument_list|)
expr_stmt|;
name|p
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|status
operator|=
name|ACTIVE
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|CStart
init|;
name|q
operator|!=
name|NIL
condition|;
name|q
operator|=
name|q
operator|->
name|CLink
control|)
name|Examine
argument_list|(
name|q
argument_list|,
name|p
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|SymNo
argument_list|)
expr_stmt|;
name|p
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|status
operator|=
name|USED
expr_stmt|;
name|MakeBBox
argument_list|(
operator|&
operator|(
name|p
operator|->
name|CBBox
operator|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|USED
case|:
case|case
name|UNDEFINED
case|:
name|p
operator|=
name|FindSymbol
argument_list|(
name|sym
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|CallNo
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTIVE
case|:
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"Symbol %d Called Recursively"
argument_list|,
name|sym
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|CallNo
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|s
argument_list|,
name|FATAL
argument_list|)
expr_stmt|;
name|ClearBBox
argument_list|(
operator|&
operator|(
name|sym
operator|->
name|CBBox
operator|)
argument_list|)
expr_stmt|;
return|return;
default|default:
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"Symbol %d is in an illegal state\n"
argument_list|,
name|sym
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|CallNo
argument_list|)
expr_stmt|;
name|Error
argument_list|(
name|s
argument_list|,
name|INTERNAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If symbol 'n' is not on the backtrace list for 		     * 'p' put it there. */
if|if
condition|(
name|p
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|backTrace
operator|->
name|CCNo
operator|!=
name|n
condition|)
block|{
name|ptr
operator|=
name|FindSymbol
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|cell
operator|=
operator|(
expr|struct
name|CCell
operator|*
operator|)
name|palloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|CCell
argument_list|)
argument_list|)
expr_stmt|;
name|cell
operator|->
name|CCCom
operator|=
name|ptr
expr_stmt|;
name|cell
operator|->
name|CCNo
operator|=
name|n
expr_stmt|;
name|cell
operator|->
name|CCLink
operator|=
name|p
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|backTrace
expr_stmt|;
name|p
operator|->
name|Ctype
operator|.
name|Symbl
operator|.
name|backTrace
operator|=
name|cell
expr_stmt|;
block|}
block|}
comment|/* Set the call commands Symbol pointer to symbol 'p' */
name|sym
operator|->
name|Ctype
operator|.
name|Call
operator|.
name|CSymb
operator|=
name|p
expr_stmt|;
block|}
comment|/* Compute the bounding box for command 'sym' */
name|MakeBBox
argument_list|(
operator|&
operator|(
name|sym
operator|->
name|CBBox
operator|)
argument_list|,
name|sym
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_macro
name|InitInter
argument_list|()
end_macro

begin_block
block|{
name|int
modifier|*
name|i
decl_stmt|;
name|InitLayers
argument_list|()
expr_stmt|;
name|InitSymbol
argument_list|()
expr_stmt|;
name|ident
operator|=
name|MakeTransform
argument_list|()
expr_stmt|;
name|ident
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
name|i
operator|=
operator|(
name|int
operator|*
operator|)
name|ident
expr_stmt|;
operator|*
operator|(
name|i
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* cannot be freed */
name|ZeroBBox
argument_list|(
operator|&
name|GWindow
argument_list|)
expr_stmt|;
name|prog
operator|=
name|MakeSymbol
argument_list|(
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|InterSummary
argument_list|()
end_macro

begin_block
block|{
comment|/* Compute bounding box for prog */
name|struct
name|BBox
name|bb
decl_stmt|;
name|Examine
argument_list|(
name|prog
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GWindow
operator|.
name|xmin
operator|>
name|GWindow
operator|.
name|xmax
condition|)
block|{
name|BBoxTransform
argument_list|(
operator|&
name|GWindow
argument_list|,
operator|&
operator|(
name|prog
operator|->
name|CBBox
operator|)
argument_list|,
name|GlobalTransform
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
name|PrintCommand
argument_list|(
name|prog
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"***Interpeter Summary***\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Window xmin %d, xmax %d, ymin %d, ymax %d\n"
argument_list|,
operator|(
name|int
operator|)
name|prog
operator|->
name|CBBox
operator|.
name|xmin
argument_list|,
operator|(
name|int
operator|)
name|prog
operator|->
name|CBBox
operator|.
name|xmax
argument_list|,
operator|(
name|int
operator|)
name|prog
operator|->
name|CBBox
operator|.
name|ymin
argument_list|,
operator|(
name|int
operator|)
name|prog
operator|->
name|CBBox
operator|.
name|ymax
argument_list|)
expr_stmt|;
if|if
condition|(
name|GWindow
operator|.
name|xmax
operator|<
name|GWindow
operator|.
name|xmin
operator|||
name|GWindow
operator|.
name|ymax
operator|<
name|GWindow
operator|.
name|ymin
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Nothing to plot\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

end_unit

