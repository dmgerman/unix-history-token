begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|UCB
end_define

begin_comment
comment|/* Controls output format for -F */
end_comment

begin_comment
comment|/* #define	UCB_PWHASH	/* If have hashed password file */
end_comment

begin_comment
comment|/*  * ls - list file or directory  *  * Modified by Bill Joy UCB May/August 1977  * Modified by Dave Presotto BTL Feb/80  * Modified by Bill Joy and Mark Horton Summer 1980  *  * this version of ls is designed for graphic terminals and to  * list directories with lots of files in them compactly.  * It supports three variants for listings:  *  *	1) Columnar output.  *	2) Stream output.  *	3) Old one per line format.  *  * Columnar output is the default.  * If, however, the standard output is not a teletype, the default  * is one-per-line.  *  * With columnar output, the items are sorted down the columns.  * We use columns only for a directory we are interpreting.  * Thus, in particular, we do not use columns for  *  *	ls /usr/bin/p*  *  * This version of ls also prints non-printing characters as '?' if  * the standard output is a teletype.  *  * Flags relating to these and other new features are:  *  *	-m	force stream output.  *  *	-1	force one entry per line, e.g. to a teletype  *  *	-q	force non-printings to be '?'s, e.g. to a file  *  *	-C	force columnar output, e.g. into a file  *  *	-n	like -l, but user/group id's in decimal rather than  *		looking in /etc/passwd to save time  *  *	-F	turns on the "flagging" of executables and directories  *  *	-R	causes ls to recurse through the branches of the subtree  *		ala find  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_decl_stmt
name|struct
name|utmp
name|utmp
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMAX
value|(sizeof utmp.ut_name)
end_define

begin_define
define|#
directive|define
name|MAXFILEWIDTH
value|14
end_define

begin_define
define|#
directive|define
name|NFILES
value|1024
end_define

begin_decl_stmt
name|FILE
modifier|*
name|pwdf
decl_stmt|,
modifier|*
name|dirf
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|lbuf
block|{
union|union
block|{
name|char
name|lname
index|[
literal|15
index|]
decl_stmt|;
name|char
modifier|*
name|namep
decl_stmt|;
block|}
name|ln
union|;
name|char
name|ltype
decl_stmt|;
name|ino_t
name|lnum
decl_stmt|;
name|short
name|lflags
decl_stmt|;
name|short
name|lnl
decl_stmt|;
name|short
name|luid
decl_stmt|;
name|short
name|lgid
decl_stmt|;
name|long
name|lsize
decl_stmt|;
name|long
name|lmtime
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dchain
block|{
name|char
modifier|*
name|dc_name
decl_stmt|;
comment|/* the path name */
name|struct
name|dchain
modifier|*
name|dc_next
decl_stmt|;
comment|/* the next directory on the chain */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|dchain
modifier|*
name|dfirst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the start of the directory chain */
end_comment

begin_decl_stmt
name|struct
name|dchain
modifier|*
name|cdfirst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the start of the current directory chain */
end_comment

begin_decl_stmt
name|struct
name|dchain
modifier|*
name|dtemp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* temporary used when linking */
end_comment

begin_decl_stmt
name|char
modifier|*
name|curdir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the current directory */
end_comment

begin_decl_stmt
name|int
name|aflg
decl_stmt|,
name|bflg
decl_stmt|,
name|dflg
decl_stmt|,
name|lflg
decl_stmt|,
name|sflg
decl_stmt|,
name|tflg
decl_stmt|,
name|uflg
decl_stmt|,
name|iflg
decl_stmt|,
name|fflg
decl_stmt|,
name|gflg
decl_stmt|,
name|cflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Aflg
decl_stmt|,
name|nflg
decl_stmt|,
name|qflg
decl_stmt|,
name|Fflg
decl_stmt|,
name|Rflg
decl_stmt|,
name|across
decl_stmt|,
name|Cflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nopad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tabflg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rflg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|year
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|tblocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|statreq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xtraent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for those switches which print out a total */
end_comment

begin_decl_stmt
name|struct
name|lbuf
modifier|*
name|flist
index|[
name|NFILES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lbuf
modifier|*
modifier|*
name|lastp
init|=
name|flist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lbuf
modifier|*
modifier|*
name|firstp
init|=
name|flist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dotp
init|=
literal|"."
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|makename
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|lbuf
modifier|*
name|gstat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|ctime
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|nblock
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getname
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ISARG
value|0100000
end_define

begin_decl_stmt
name|int
name|colwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|filewidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fixedwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|outcol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|obuf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
include|#
directive|include
file|<sgtty.h>
name|int
name|i
decl_stmt|,
name|width
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|ep
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
modifier|*
name|slastp
decl_stmt|;
name|struct
name|lbuf
modifier|*
modifier|*
name|epp
decl_stmt|;
name|struct
name|lbuf
name|lb
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|compar
parameter_list|()
function_decl|;
name|struct
name|sgttyb
name|sgbuf
decl_stmt|;
name|Fflg
operator|=
literal|0
expr_stmt|;
name|tabflg
operator|=
literal|0
expr_stmt|;
name|Aflg
operator|=
name|getuid
argument_list|()
operator|==
literal|0
expr_stmt|;
name|setbuf
argument_list|(
name|stdout
argument_list|,
name|obuf
argument_list|)
expr_stmt|;
name|lb
operator|.
name|lmtime
operator|=
name|time
argument_list|(
operator|(
name|long
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|year
operator|=
name|lb
operator|.
name|lmtime
operator|-
literal|6L
operator|*
literal|30L
operator|*
literal|24L
operator|*
literal|60L
operator|*
literal|60L
expr_stmt|;
comment|/* 6 months ago */
name|qflg
operator|=
name|gtty
argument_list|(
literal|1
argument_list|,
operator|&
name|sgbuf
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* guarantee at least on column width */
name|fixedwidth
operator|=
literal|2
expr_stmt|;
comment|/* 	 * If the standard output is not a teletype, 	 * then we default to one-per-line format 	 * otherwise decide between stream and 	 * columnar based on our name. 	 */
if|if
condition|(
name|qflg
condition|)
block|{
name|Cflg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|sgbuf
operator|.
name|sg_flags
operator|&
name|XTABS
operator|)
operator|==
literal|0
condition|)
name|tabflg
operator|++
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|argv
index|[
literal|0
index|]
init|;
name|cp
index|[
literal|0
index|]
operator|&&
name|cp
index|[
literal|1
index|]
condition|;
name|cp
operator|++
control|)
continue|continue;
comment|/* 		 * Certain kinds of links (l, ll, lr, lf, lx) cause some 		 * various options to be turned on. 		 */
switch|switch
condition|(
name|cp
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'l'
case|:
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'l'
condition|)
block|{
comment|/* ll => -l */
name|lflg
operator|=
literal|1
expr_stmt|;
name|statreq
operator|++
expr_stmt|;
name|xtraent
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* l => -m */
name|nopad
operator|=
literal|1
expr_stmt|;
name|Cflg
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
comment|/* lx => -x */
name|across
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* lf => -F */
name|Fflg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* lr => -R */
name|Rflg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|tabflg
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
operator|&&
operator|*
name|argv
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|argv
operator|++
expr_stmt|;
while|while
condition|(
operator|*
operator|++
operator|*
name|argv
condition|)
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
comment|/* 		 * C - force columnar output 		 */
case|case
literal|'C'
case|:
name|Cflg
operator|=
literal|1
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* 		 * m - force stream output 		 */
case|case
literal|'m'
case|:
name|Cflg
operator|=
literal|0
expr_stmt|;
name|nopad
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* 		 * x - force sort across 		 */
case|case
literal|'x'
case|:
name|across
operator|=
literal|1
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
name|Cflg
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* 		 * q - force ?'s in output 		 */
case|case
literal|'q'
case|:
name|qflg
operator|=
literal|1
expr_stmt|;
name|bflg
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* 		 * b - force octal value in output 		 */
case|case
literal|'b'
case|:
name|bflg
operator|=
literal|1
expr_stmt|;
name|qflg
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* 		 * 1 - force 1/line in output 		 */
case|case
literal|'1'
case|:
name|Cflg
operator|=
literal|0
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* STANDARD FLAGS */
case|case
literal|'a'
case|:
name|aflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'A'
case|:
name|Aflg
operator|=
operator|!
name|Aflg
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
name|cflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|fixedwidth
operator|+=
literal|5
expr_stmt|;
name|sflg
operator|++
expr_stmt|;
name|statreq
operator|++
expr_stmt|;
name|xtraent
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|dflg
operator|++
expr_stmt|;
continue|continue;
comment|/* 		 * n - don't look in password file 		 */
case|case
literal|'n'
case|:
name|nflg
operator|++
expr_stmt|;
case|case
literal|'l'
case|:
name|lflg
operator|++
expr_stmt|;
name|statreq
operator|++
expr_stmt|;
name|xtraent
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
name|rflg
operator|=
operator|-
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
name|tflg
operator|++
expr_stmt|;
name|statreq
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
name|uflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'i'
case|:
name|fixedwidth
operator|+=
literal|6
expr_stmt|;
name|iflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|fflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'g'
case|:
name|gflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'F'
case|:
name|Fflg
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'R'
case|:
name|Rflg
operator|++
expr_stmt|;
continue|continue;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: ls [-1ACFRabcdfgilmnqrstux] [files]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Fflg
condition|)
ifdef|#
directive|ifdef
name|UCB
name|fixedwidth
operator|++
expr_stmt|;
else|#
directive|else
name|fixedwidth
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fflg
condition|)
block|{
name|aflg
operator|++
expr_stmt|;
name|lflg
operator|=
literal|0
expr_stmt|;
name|sflg
operator|=
literal|0
expr_stmt|;
name|tflg
operator|=
literal|0
expr_stmt|;
name|statreq
operator|=
literal|0
expr_stmt|;
name|xtraent
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lflg
condition|)
block|{
name|Cflg
operator|=
literal|0
expr_stmt|;
name|t
operator|=
literal|"/etc/passwd"
expr_stmt|;
if|if
condition|(
name|gflg
condition|)
name|t
operator|=
literal|"/etc/group"
expr_stmt|;
name|nopad
operator|=
literal|0
expr_stmt|;
name|fixedwidth
operator|=
literal|70
expr_stmt|;
name|pwdf
operator|=
name|fopen
argument_list|(
name|t
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|argc
operator|++
expr_stmt|;
name|argv
operator|=
operator|&
name|dotp
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|Cflg
condition|)
block|{
name|width
operator|=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|filewidth
condition|)
name|filewidth
operator|=
name|width
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ep
operator|=
name|gstat
argument_list|(
operator|*
name|argv
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|ep
operator|->
name|ln
operator|.
name|namep
operator|=
operator|*
name|argv
expr_stmt|;
name|ep
operator|->
name|lflags
operator||=
name|ISARG
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|Cflg
condition|)
name|filewidth
operator|=
name|MAXFILEWIDTH
expr_stmt|;
else|else
name|colwidth
operator|=
name|fixedwidth
operator|+
name|filewidth
expr_stmt|;
name|qsort
argument_list|(
name|firstp
argument_list|,
name|lastp
operator|-
name|firstp
argument_list|,
sizeof|sizeof
expr|*
name|lastp
argument_list|,
name|compar
argument_list|)
expr_stmt|;
name|slastp
operator|=
name|lastp
expr_stmt|;
comment|/* For each argument user typed */
for|for
control|(
name|epp
operator|=
name|firstp
init|;
name|epp
operator|<
name|slastp
condition|;
name|epp
operator|++
control|)
block|{
name|ep
operator|=
operator|*
name|epp
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|ltype
operator|==
literal|'d'
operator|&&
name|dflg
operator|==
literal|0
operator|||
name|fflg
condition|)
name|pdirectory
argument_list|(
name|ep
operator|->
name|ln
operator|.
name|namep
argument_list|,
operator|(
name|argc
operator|>
literal|1
operator|)
argument_list|,
name|slastp
argument_list|)
expr_stmt|;
else|else
name|pentry
argument_list|(
name|ep
argument_list|)
expr_stmt|;
comment|/* -R: print subdirectories found */
while|while
condition|(
name|dfirst
operator|||
name|cdfirst
condition|)
block|{
comment|/* Place direct subdirs on front in right order */
while|while
condition|(
name|cdfirst
condition|)
block|{
comment|/* reverse cdfirst onto front of dfirst */
name|dtemp
operator|=
name|cdfirst
expr_stmt|;
name|cdfirst
operator|=
name|cdfirst
operator|->
name|dc_next
expr_stmt|;
name|dtemp
operator|->
name|dc_next
operator|=
name|dfirst
expr_stmt|;
name|dfirst
operator|=
name|dtemp
expr_stmt|;
block|}
comment|/* take off first dir on dfirst& print it */
name|dtemp
operator|=
name|dfirst
expr_stmt|;
name|dfirst
operator|=
name|dfirst
operator|->
name|dc_next
expr_stmt|;
name|pdirectory
argument_list|(
name|dtemp
operator|->
name|dc_name
argument_list|,
literal|1
argument_list|,
name|firstp
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|dtemp
operator|->
name|dc_name
argument_list|)
expr_stmt|;
name|cfree
argument_list|(
name|dtemp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|outcol
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pdirectory: print the directory name, labelling it if title is  * nonzero, using lp as the place to start reading in the dir.  */
end_comment

begin_macro
name|pdirectory
argument_list|(
argument|name
argument_list|,
argument|title
argument_list|,
argument|lp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|title
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lbuf
modifier|*
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|dchain
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
name|pname
decl_stmt|;
name|struct
name|lbuf
modifier|*
modifier|*
name|app
decl_stmt|;
name|filewidth
operator|=
literal|0
expr_stmt|;
name|curdir
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|title
condition|)
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|lastp
operator|=
name|lp
expr_stmt|;
name|readdir
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Cflg
condition|)
name|filewidth
operator|=
name|MAXFILEWIDTH
expr_stmt|;
name|colwidth
operator|=
name|fixedwidth
operator|+
name|filewidth
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* Taken out because it appears this is done below in pem. */
if|if
condition|(
name|tabflg
condition|)
block|{
if|if
condition|(
name|colwidth
operator|<=
literal|8
condition|)
name|colwidth
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|colwidth
operator|<=
literal|16
condition|)
name|colwidth
operator|=
literal|16
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fflg
operator|==
literal|0
condition|)
name|qsort
argument_list|(
name|lp
argument_list|,
name|lastp
operator|-
name|lp
argument_list|,
sizeof|sizeof
expr|*
name|lastp
argument_list|,
name|compar
argument_list|)
expr_stmt|;
if|if
condition|(
name|Rflg
condition|)
for|for
control|(
name|app
operator|=
name|lastp
operator|-
literal|1
init|;
name|app
operator|>=
name|lp
condition|;
name|app
operator|--
control|)
block|{
name|ap
operator|=
operator|*
name|app
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|ltype
operator|==
literal|'d'
operator|&&
name|strcmp
argument_list|(
name|ap
operator|->
name|ln
operator|.
name|lname
argument_list|,
literal|"."
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|ap
operator|->
name|ln
operator|.
name|lname
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dchain
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dchain
argument_list|)
argument_list|)
expr_stmt|;
name|pname
operator|=
name|makename
argument_list|(
name|curdir
argument_list|,
name|ap
operator|->
name|ln
operator|.
name|lname
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dc_name
operator|=
operator|(
name|char
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
name|strlen
argument_list|(
name|pname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dp
operator|->
name|dc_name
argument_list|,
name|pname
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dc_next
operator|=
name|dfirst
expr_stmt|;
name|dfirst
operator|=
name|dp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lflg
operator|||
name|sflg
condition|)
name|printf
argument_list|(
literal|"total %D"
argument_list|,
name|tblocks
argument_list|)
expr_stmt|;
name|pem
argument_list|(
name|lp
argument_list|,
name|lastp
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pem: print 'em.  Print a list of files (e.g. a directory) bounded  * by slp and lp.  */
end_comment

begin_expr_stmt
name|pem
argument_list|(
name|slp
argument_list|,
name|lp
argument_list|)
specifier|register
expr|struct
name|lbuf
operator|*
operator|*
name|slp
operator|,
operator|*
operator|*
name|lp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|ncols
decl_stmt|,
name|nrows
decl_stmt|,
name|row
decl_stmt|,
name|col
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|tabflg
condition|)
block|{
if|if
condition|(
name|colwidth
operator|<=
literal|9
condition|)
name|colwidth
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|colwidth
operator|<=
literal|17
condition|)
name|colwidth
operator|=
literal|16
expr_stmt|;
block|}
name|ncols
operator|=
literal|80
operator|/
name|colwidth
expr_stmt|;
if|if
condition|(
name|ncols
operator|==
literal|1
operator|||
name|Cflg
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|slp
init|;
name|ep
operator|<
name|lp
condition|;
name|ep
operator|++
control|)
name|pentry
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|across
condition|)
block|{
for|for
control|(
name|ep
operator|=
name|slp
init|;
name|ep
operator|<
name|lp
condition|;
name|ep
operator|++
control|)
name|pentry
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xtraent
condition|)
name|slp
operator|--
expr_stmt|;
name|nrows
operator|=
operator|(
name|lp
operator|-
name|slp
operator|-
literal|1
operator|)
operator|/
name|ncols
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|row
operator|=
literal|0
init|;
name|row
operator|<
name|nrows
condition|;
name|row
operator|++
control|)
block|{
name|col
operator|=
name|row
operator|==
literal|0
operator|&&
name|xtraent
expr_stmt|;
for|for
control|(
init|;
name|col
operator|<
name|ncols
condition|;
name|col
operator|++
control|)
block|{
name|ep
operator|=
name|slp
operator|+
operator|(
name|nrows
operator|*
name|col
operator|)
operator|+
name|row
expr_stmt|;
if|if
condition|(
name|ep
operator|<
name|lp
condition|)
name|pentry
argument_list|(
operator|*
name|ep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|outcol
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * pputchar: like putchar but knows how to handle control chars.  * CAUTION: if you make ctrl chars print in ^x notation, or any  * other notation which is wider than one character, the column  * nature of things (such as files with 14 letter names) will be  * messed up.  Weigh this carefully!  */
end_comment

begin_macro
name|pputchar
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cc
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\t'
case|:
name|outcol
operator|=
operator|(
name|outcol
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|outcol
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|>=
literal|0177
condition|)
block|{
if|if
condition|(
name|qflg
condition|)
name|c
operator|=
literal|'?'
expr_stmt|;
elseif|else
if|if
condition|(
name|bflg
condition|)
block|{
name|outcol
operator|+=
literal|3
expr_stmt|;
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|cc
operator|=
literal|'0'
operator|+
operator|(
name|c
operator|>>
literal|6
operator|&
literal|07
operator|)
expr_stmt|;
name|putc
argument_list|(
name|cc
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|cc
operator|=
literal|'0'
operator|+
operator|(
name|c
operator|>>
literal|3
operator|&
literal|07
operator|)
expr_stmt|;
name|putc
argument_list|(
name|cc
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|c
operator|=
literal|'0'
operator|+
operator|(
name|c
operator|&
literal|07
operator|)
expr_stmt|;
block|}
block|}
name|outcol
operator|++
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
name|c
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|newline
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|outcol
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * column: get to the beginning of the next column.  */
end_comment

begin_macro
name|column
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|outcol
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|nopad
condition|)
block|{
name|putc
argument_list|(
literal|','
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|outcol
operator|++
expr_stmt|;
if|if
condition|(
name|outcol
operator|+
name|colwidth
operator|+
literal|2
operator|>
literal|80
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|putc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|outcol
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|Cflg
operator|==
literal|0
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|outcol
operator|/
name|colwidth
operator|+
literal|2
operator|)
operator|*
name|colwidth
operator|>
literal|80
condition|)
block|{
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|outcol
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tabflg
operator|&&
operator|(
name|colwidth
operator|<=
literal|16
operator|)
condition|)
block|{
if|if
condition|(
name|colwidth
operator|>
literal|8
condition|)
if|if
condition|(
operator|(
name|outcol
operator|%
literal|16
operator|)
operator|<
literal|8
condition|)
block|{
name|outcol
operator|+=
literal|8
operator|-
operator|(
name|outcol
operator|%
literal|8
operator|)
expr_stmt|;
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
name|outcol
operator|+=
literal|8
operator|-
operator|(
name|outcol
operator|%
literal|8
operator|)
expr_stmt|;
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|outcol
operator|++
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|outcol
operator|%
name|colwidth
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  * nblock: the number of 512 byte blocks a size byte file takes up.  * (Note: the number stays 512 no matter what BUFSIZ or the filesystem uses.)  */
end_comment

begin_function
name|long
name|nblock
parameter_list|(
name|size
parameter_list|)
name|long
name|size
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|size
operator|+
literal|511
operator|)
operator|>>
literal|9
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This code handles the rwx- business.  * You figure it out.  */
end_comment

begin_decl_stmt
name|int
name|m1
index|[]
init|=
block|{
literal|1
block|,
name|S_IREAD
operator|>>
literal|0
block|,
literal|'r'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m2
index|[]
init|=
block|{
literal|1
block|,
name|S_IWRITE
operator|>>
literal|0
block|,
literal|'w'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m3
index|[]
init|=
block|{
literal|2
block|,
name|S_ISUID
block|,
literal|'s'
block|,
name|S_IEXEC
operator|>>
literal|0
block|,
literal|'x'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m4
index|[]
init|=
block|{
literal|1
block|,
name|S_IREAD
operator|>>
literal|3
block|,
literal|'r'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m5
index|[]
init|=
block|{
literal|1
block|,
name|S_IWRITE
operator|>>
literal|3
block|,
literal|'w'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m6
index|[]
init|=
block|{
literal|2
block|,
name|S_ISGID
block|,
literal|'s'
block|,
name|S_IEXEC
operator|>>
literal|3
block|,
literal|'x'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m7
index|[]
init|=
block|{
literal|1
block|,
name|S_IREAD
operator|>>
literal|6
block|,
literal|'r'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m8
index|[]
init|=
block|{
literal|1
block|,
name|S_IWRITE
operator|>>
literal|6
block|,
literal|'w'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|m9
index|[]
init|=
block|{
literal|2
block|,
name|S_ISVTX
block|,
literal|'t'
block|,
name|S_IEXEC
operator|>>
literal|6
block|,
literal|'x'
block|,
literal|'-'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|m
index|[]
init|=
block|{
name|m1
block|,
name|m2
block|,
name|m3
block|,
name|m4
block|,
name|m5
block|,
name|m6
block|,
name|m7
block|,
name|m8
block|,
name|m9
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|pmode
argument_list|(
argument|aflag
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
modifier|*
name|mp
decl_stmt|;
name|flags
operator|=
name|aflag
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|m
index|[
literal|0
index|]
init|;
name|mp
operator|<
operator|&
name|m
index|[
sizeof|sizeof
argument_list|(
name|m
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
index|]
condition|;
control|)
name|select
argument_list|(
operator|*
name|mp
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|select
argument_list|(
name|pairp
argument_list|)
specifier|register
name|int
operator|*
name|pairp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
name|n
operator|=
operator|*
name|pairp
operator|++
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
operator|&&
operator|(
name|flags
operator|&
operator|*
name|pairp
operator|++
operator|)
operator|==
literal|0
condition|)
name|pairp
operator|++
expr_stmt|;
name|pputchar
argument_list|(
operator|*
name|pairp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * returns cat(dir, "/", file), unless dir ends in /, when it doesn't //  */
end_comment

begin_function
name|char
modifier|*
name|makename
parameter_list|(
name|dir
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|,
decl|*
name|file
decl_stmt|;
end_function

begin_block
block|{
specifier|static
name|char
name|dfile
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|dp
operator|=
name|dfile
expr_stmt|;
name|fp
operator|=
name|dir
expr_stmt|;
while|while
condition|(
operator|*
name|fp
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|dp
operator|-
literal|1
operator|)
operator|!=
literal|'/'
condition|)
operator|*
name|dp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|fp
operator|=
name|file
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DIRSIZ
condition|;
name|i
operator|++
control|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|fp
operator|++
expr_stmt|;
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|dfile
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * readdir: read in the directory whose name is dir,  * starting at lastp.  */
end_comment

begin_macro
name|readdir
argument_list|(
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|struct
name|direct
name|dentry
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|,
name|width
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|(
name|dirf
operator|=
name|fopen
argument_list|(
name|dir
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s unreadable\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
return|return;
block|}
name|tblocks
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
operator|&
name|dentry
argument_list|,
sizeof|sizeof
argument_list|(
name|dentry
argument_list|)
argument_list|,
literal|1
argument_list|,
name|dirf
argument_list|)
operator|!=
literal|1
condition|)
break|break;
if|if
condition|(
name|dentry
operator|.
name|d_ino
operator|==
literal|0
operator|||
name|aflg
operator|==
literal|0
operator|&&
name|dentry
operator|.
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
operator|!
name|Aflg
operator|||
name|dentry
operator|.
name|d_name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|dentry
operator|.
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|dentry
operator|.
name|d_name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|Cflg
condition|)
block|{
name|width
operator|=
name|strlen
argument_list|(
name|dentry
operator|.
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|filewidth
condition|)
name|filewidth
operator|=
name|width
expr_stmt|;
block|}
name|ep
operator|=
name|gstat
argument_list|(
name|makename
argument_list|(
name|dir
argument_list|,
name|dentry
operator|.
name|d_name
argument_list|)
argument_list|,
name|Fflg
operator|||
name|Rflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|ep
operator|->
name|lnum
operator|!=
operator|-
literal|1
condition|)
name|ep
operator|->
name|lnum
operator|=
name|dentry
operator|.
name|d_ino
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|DIRSIZ
condition|;
name|j
operator|++
control|)
name|ep
operator|->
name|ln
operator|.
name|lname
index|[
name|j
index|]
operator|=
name|dentry
operator|.
name|d_name
index|[
name|j
index|]
expr_stmt|;
block|}
name|fclose
argument_list|(
name|dirf
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * stat the given file and return an lbuf containing it.  * argfl is nonzero if a stat is required because the file is  * an argument, rather than having been found in a directory.  */
end_comment

begin_function
name|struct
name|lbuf
modifier|*
name|gstat
parameter_list|(
name|file
parameter_list|,
name|argfl
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|struct
name|stat
name|statb
decl_stmt|;
specifier|register
name|struct
name|lbuf
modifier|*
name|rep
decl_stmt|;
specifier|static
name|int
name|nomocore
decl_stmt|;
if|if
condition|(
name|nomocore
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rep
operator|=
operator|(
expr|struct
name|lbuf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ls: out of memory\n"
argument_list|)
expr_stmt|;
name|nomocore
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|lastp
operator|>=
operator|&
name|flist
index|[
name|NFILES
index|]
condition|)
block|{
specifier|static
name|int
name|msg
decl_stmt|;
name|lastp
operator|--
expr_stmt|;
if|if
condition|(
name|msg
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ls: too many files\n"
argument_list|)
expr_stmt|;
name|msg
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|lastp
operator|++
operator|=
name|rep
expr_stmt|;
name|rep
operator|->
name|lflags
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|lnum
operator|=
literal|0
expr_stmt|;
name|rep
operator|->
name|ltype
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|argfl
operator|||
name|statreq
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|statb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s not found\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|statb
operator|.
name|st_ino
operator|=
operator|-
literal|1
expr_stmt|;
name|statb
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
name|statb
operator|.
name|st_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argfl
condition|)
block|{
name|lastp
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|rep
operator|->
name|lnum
operator|=
name|statb
operator|.
name|st_ino
expr_stmt|;
name|rep
operator|->
name|lsize
operator|=
name|statb
operator|.
name|st_size
expr_stmt|;
switch|switch
condition|(
name|statb
operator|.
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFDIR
case|:
name|rep
operator|->
name|ltype
operator|=
literal|'d'
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|rep
operator|->
name|ltype
operator|=
literal|'b'
expr_stmt|;
name|rep
operator|->
name|lsize
operator|=
name|statb
operator|.
name|st_rdev
expr_stmt|;
break|break;
case|case
name|S_IFCHR
case|:
name|rep
operator|->
name|ltype
operator|=
literal|'c'
expr_stmt|;
name|rep
operator|->
name|lsize
operator|=
name|statb
operator|.
name|st_rdev
expr_stmt|;
break|break;
case|case
name|S_IFMPB
case|:
name|rep
operator|->
name|ltype
operator|=
literal|'M'
expr_stmt|;
name|rep
operator|->
name|lsize
operator|=
name|statb
operator|.
name|st_rdev
expr_stmt|;
break|break;
case|case
name|S_IFMPC
case|:
name|rep
operator|->
name|ltype
operator|=
literal|'m'
expr_stmt|;
name|rep
operator|->
name|lsize
operator|=
name|statb
operator|.
name|st_rdev
expr_stmt|;
break|break;
block|}
name|rep
operator|->
name|lflags
operator|=
name|statb
operator|.
name|st_mode
operator|&
operator|~
name|S_IFMT
expr_stmt|;
name|rep
operator|->
name|luid
operator|=
name|statb
operator|.
name|st_uid
expr_stmt|;
name|rep
operator|->
name|lgid
operator|=
name|statb
operator|.
name|st_gid
expr_stmt|;
name|rep
operator|->
name|lnl
operator|=
name|statb
operator|.
name|st_nlink
expr_stmt|;
if|if
condition|(
name|uflg
condition|)
name|rep
operator|->
name|lmtime
operator|=
name|statb
operator|.
name|st_atime
expr_stmt|;
elseif|else
if|if
condition|(
name|cflg
condition|)
name|rep
operator|->
name|lmtime
operator|=
name|statb
operator|.
name|st_ctime
expr_stmt|;
else|else
name|rep
operator|->
name|lmtime
operator|=
name|statb
operator|.
name|st_mtime
expr_stmt|;
name|tblocks
operator|+=
name|nblock
argument_list|(
name|statb
operator|.
name|st_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * decide whether to print pp1 before or after pp2, based on their  * names, various times, and the r flag.  */
end_comment

begin_macro
name|compar
argument_list|(
argument|pp1
argument_list|,
argument|pp2
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|lbuf
modifier|*
modifier|*
name|pp1
decl_stmt|,
modifier|*
modifier|*
name|pp2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|lbuf
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|p1
operator|=
operator|*
name|pp1
expr_stmt|;
name|p2
operator|=
operator|*
name|pp2
expr_stmt|;
if|if
condition|(
name|dflg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|lflags
operator|&
name|ISARG
operator|&&
name|p1
operator|->
name|ltype
operator|==
literal|'d'
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|p2
operator|->
name|lflags
operator|&
name|ISARG
operator|&&
name|p2
operator|->
name|ltype
operator|==
literal|'d'
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|p2
operator|->
name|lflags
operator|&
name|ISARG
operator|&&
name|p2
operator|->
name|ltype
operator|==
literal|'d'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tflg
condition|)
block|{
if|if
condition|(
name|p2
operator|->
name|lmtime
operator|==
name|p1
operator|->
name|lmtime
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p2
operator|->
name|lmtime
operator|>
name|p1
operator|->
name|lmtime
condition|)
return|return
operator|(
name|rflg
operator|)
return|;
return|return
operator|(
operator|-
name|rflg
operator|)
return|;
block|}
return|return
operator|(
name|rflg
operator|*
name|strcmp
argument_list|(
name|p1
operator|->
name|lflags
operator|&
name|ISARG
condition|?
name|p1
operator|->
name|ln
operator|.
name|namep
else|:
name|p1
operator|->
name|ln
operator|.
name|lname
argument_list|,
name|p2
operator|->
name|lflags
operator|&
name|ISARG
condition|?
name|p2
operator|->
name|ln
operator|.
name|namep
else|:
name|p2
operator|->
name|ln
operator|.
name|lname
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * print the entry pointed at by ap  */
end_comment

begin_macro
name|pentry
argument_list|(
argument|ap
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|lbuf
modifier|*
name|ap
decl_stmt|;
end_decl_stmt

begin_block
block|{
struct|struct
block|{
name|char
name|dminor
decl_stmt|,
name|dmajor
decl_stmt|;
block|}
struct|;
specifier|register
name|struct
name|lbuf
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|fname
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|struct
name|passwd
modifier|*
name|getpwuid
parameter_list|()
function_decl|;
name|struct
name|passwd
modifier|*
name|pwptr
decl_stmt|;
name|struct
name|group
modifier|*
name|getgrgid
parameter_list|()
function_decl|;
name|struct
name|group
modifier|*
name|grptr
decl_stmt|;
name|fname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|ap
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lnum
operator|==
operator|-
literal|1
condition|)
return|return;
name|column
argument_list|()
expr_stmt|;
if|if
condition|(
name|iflg
condition|)
if|if
condition|(
name|nopad
operator|&&
operator|!
name|lflg
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|p
operator|->
name|lnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%5d "
argument_list|,
name|p
operator|->
name|lnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|sflg
condition|)
if|if
condition|(
name|nopad
operator|&&
operator|!
name|lflg
condition|)
name|printf
argument_list|(
literal|"%D "
argument_list|,
name|nblock
argument_list|(
name|p
operator|->
name|lsize
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%4D "
argument_list|,
name|nblock
argument_list|(
name|p
operator|->
name|lsize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lflg
condition|)
block|{
name|pputchar
argument_list|(
name|p
operator|->
name|ltype
argument_list|)
expr_stmt|;
name|pmode
argument_list|(
name|p
operator|->
name|lflags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2d "
argument_list|,
name|p
operator|->
name|lnl
argument_list|)
expr_stmt|;
if|if
condition|(
name|gflg
condition|)
block|{
name|grptr
operator|=
name|getgrgid
argument_list|(
name|p
operator|->
name|lgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflg
operator|==
literal|0
operator|&&
name|grptr
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%-8.8s"
argument_list|,
name|grptr
operator|->
name|gr_name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%-8d"
argument_list|,
name|p
operator|->
name|lgid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|UCB_PWHASH
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|nflg
operator|==
literal|0
operator|&&
operator|(
name|name
operator|=
name|getname
argument_list|(
name|p
operator|->
name|luid
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%-8.8s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|pwptr
operator|=
name|getpwuid
argument_list|(
name|p
operator|->
name|luid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nflg
operator|==
literal|0
operator|&&
name|pwptr
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%-8.8s"
argument_list|,
name|pwptr
operator|->
name|pw_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|else
name|printf
argument_list|(
literal|"%-8d"
argument_list|,
name|p
operator|->
name|luid
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|ltype
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'m'
case|:
case|case
literal|'M'
case|:
name|printf
argument_list|(
literal|"%3d,%3d"
argument_list|,
name|major
argument_list|(
operator|(
name|int
operator|)
name|p
operator|->
name|lsize
argument_list|)
argument_list|,
name|minor
argument_list|(
operator|(
name|int
operator|)
name|p
operator|->
name|lsize
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%7ld"
argument_list|,
name|p
operator|->
name|lsize
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|p
operator|->
name|lmtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|lmtime
operator|<
name|year
condition|)
name|printf
argument_list|(
literal|" %-7.7s %-4.4s "
argument_list|,
name|cp
operator|+
literal|4
argument_list|,
name|cp
operator|+
literal|20
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %-12.12s "
argument_list|,
name|cp
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|UCB
if|if
condition|(
name|Fflg
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ltype
operator|==
literal|'d'
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|lflags
operator|&
literal|0111
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|nopad
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|lflags
operator|&
name|ISARG
condition|)
name|strncat
argument_list|(
name|fname
argument_list|,
name|p
operator|->
name|ln
operator|.
name|namep
argument_list|,
literal|98
argument_list|)
expr_stmt|;
else|else
name|strncat
argument_list|(
name|fname
argument_list|,
name|p
operator|->
name|ln
operator|.
name|lname
argument_list|,
literal|14
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UCB
if|if
condition|(
name|Fflg
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ltype
operator|==
literal|'d'
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|nopad
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|Fflg
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|ltype
operator|==
literal|'d'
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|lflags
operator|&
literal|0111
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|nopad
condition|)
name|strcat
argument_list|(
name|fname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* char printf_id[] = "@(#) printf.c:2.2 6/5/79";*/
end_comment

begin_include
include|#
directive|include
file|"varargs.h"
end_include

begin_comment
comment|/*  * This version of printf is compatible with the Version 7 C  * printf. The differences are only minor except that this  * printf assumes it is to print through pputchar. Version 7  * printf is more general (and is much larger) and includes  * provisions for floating point.  */
end_comment

begin_define
define|#
directive|define
name|MAXOCT
value|11
end_define

begin_comment
comment|/* Maximum octal digits in a long */
end_comment

begin_define
define|#
directive|define
name|MAXINT
value|32767
end_define

begin_comment
comment|/* largest normal length positive integer */
end_comment

begin_define
define|#
directive|define
name|BIG
value|1000000000
end_define

begin_comment
comment|/* largest power of 10 less than an unsigned long */
end_comment

begin_define
define|#
directive|define
name|MAXDIGS
value|10
end_define

begin_comment
comment|/* number of digits in BIG */
end_comment

begin_decl_stmt
specifier|static
name|int
name|width
decl_stmt|,
name|sign
decl_stmt|,
name|fill
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|b_dconv
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|printf
argument_list|(
argument|va_alist
argument_list|)
end_macro

begin_macro
name|va_dcl
end_macro

begin_block
block|{
name|va_list
name|ap
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
name|char
name|fcode
decl_stmt|;
name|int
name|prec
decl_stmt|;
name|int
name|length
decl_stmt|,
name|mask1
decl_stmt|,
name|nbits
decl_stmt|,
name|n
decl_stmt|;
name|long
name|int
name|mask2
decl_stmt|,
name|num
decl_stmt|;
specifier|register
name|char
modifier|*
name|bptr
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
name|buf
index|[
literal|134
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|fmt
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* process format string first */
while|while
condition|(
operator|(
name|fcode
operator|=
operator|*
name|fmt
operator|++
operator|)
operator|!=
literal|'%'
condition|)
block|{
comment|/* ordinary (non-%) character */
if|if
condition|(
name|fcode
operator|==
literal|'\0'
condition|)
return|return;
name|pputchar
argument_list|(
name|fcode
argument_list|)
expr_stmt|;
block|}
comment|/* length modifier: -1 for h, 1 for l, 0 for none */
name|length
operator|=
literal|0
expr_stmt|;
comment|/* check for a leading - sign */
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|++
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
comment|/* a '0' may follow the - sign */
comment|/* this is the requested fill character */
name|fill
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'0'
condition|)
block|{
name|fill
operator|--
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
comment|/* Now comes a digit string which may be a '*' */
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'*'
condition|)
block|{
name|width
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|width
operator|=
operator|-
name|width
expr_stmt|;
name|sign
operator|=
operator|!
name|sign
expr_stmt|;
block|}
name|fmt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|width
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|>=
literal|'0'
operator|&&
operator|*
name|fmt
operator|<=
literal|'9'
condition|)
name|width
operator|=
name|width
operator|*
literal|10
operator|+
operator|(
operator|*
name|fmt
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
comment|/* maybe a decimal point followed by more digits (or '*') */
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|fmt
operator|==
literal|'*'
condition|)
block|{
name|prec
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|prec
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|>=
literal|'0'
operator|&&
operator|*
name|fmt
operator|<=
literal|'9'
condition|)
name|prec
operator|=
name|prec
operator|*
literal|10
operator|+
operator|(
operator|*
name|fmt
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
block|}
else|else
name|prec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 		 * At this point, "sign" is nonzero if there was 		 * a sign, "fill" is 0 if there was a leading 		 * zero and 1 otherwise, "width" and "prec" 		 * contain numbers corresponding to the digit 		 * strings before and after the decimal point, 		 * respectively, and "fmt" addresses the next 		 * character after the whole mess. If there was 		 * no decimal point, "prec" will be -1. 		 */
switch|switch
condition|(
operator|*
name|fmt
condition|)
block|{
case|case
literal|'L'
case|:
case|case
literal|'l'
case|:
name|length
operator|=
literal|2
expr_stmt|;
comment|/* no break!! */
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|length
operator|--
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 		 * At exit from the following switch, we will 		 * emit the characters starting at "bptr" and 		 * ending at "ptr"-1, unless fcode is '\0'. 		 */
switch|switch
condition|(
name|fcode
operator|=
operator|*
name|fmt
operator|++
condition|)
block|{
comment|/* process characters and strings first */
case|case
literal|'c'
case|:
name|buf
index|[
literal|0
index|]
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|bptr
operator|=
operator|&
name|buf
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|ptr
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|bptr
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|bptr
operator|==
literal|0
condition|)
name|bptr
operator|=
literal|"(null pointer)"
expr_stmt|;
if|if
condition|(
name|prec
operator|<
literal|0
condition|)
name|prec
operator|=
name|MAXINT
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|*
name|bptr
operator|++
operator|&&
name|n
operator|<
name|prec
condition|;
name|n
operator|++
control|)
empty_stmt|;
name|ptr
operator|=
operator|--
name|bptr
expr_stmt|;
name|bptr
operator|-=
name|n
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|length
operator|=
literal|1
expr_stmt|;
name|fcode
operator|=
literal|'o'
expr_stmt|;
comment|/* no break */
case|case
literal|'o'
case|:
case|case
literal|'X'
case|:
case|case
literal|'x'
case|:
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|num
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
argument_list|)
expr_stmt|;
else|else
name|num
operator|=
operator|(
name|unsigned
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
literal|'o'
condition|)
block|{
name|mask1
operator|=
literal|0x7
expr_stmt|;
name|mask2
operator|=
literal|0x1fffffffL
expr_stmt|;
name|nbits
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|mask1
operator|=
literal|0xf
expr_stmt|;
name|mask2
operator|=
literal|0x0fffffffL
expr_stmt|;
name|nbits
operator|=
literal|4
expr_stmt|;
block|}
name|n
operator|=
operator|(
name|num
operator|!=
literal|0
operator|)
expr_stmt|;
name|bptr
operator|=
name|buf
operator|+
name|MAXOCT
operator|+
literal|3
expr_stmt|;
comment|/* shift and mask for speed */
do|do
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|num
operator|&
name|mask1
operator|)
operator|<
literal|10
condition|)
operator|*
operator|--
name|bptr
operator|=
operator|(
operator|(
name|int
operator|)
name|num
operator|&
name|mask1
operator|)
operator|+
literal|060
expr_stmt|;
else|else
operator|*
operator|--
name|bptr
operator|=
operator|(
operator|(
name|int
operator|)
name|num
operator|&
name|mask1
operator|)
operator|+
literal|0127
expr_stmt|;
do|while
condition|(
name|num
operator|=
operator|(
name|num
operator|>>
name|nbits
operator|)
operator|&
name|mask2
condition|)
do|;
if|if
condition|(
name|fcode
operator|==
literal|'o'
condition|)
block|{
if|if
condition|(
name|n
condition|)
operator|*
operator|--
name|bptr
operator|=
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|sign
operator|&&
name|fill
operator|<=
literal|0
condition|)
block|{
name|pputchar
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|pputchar
argument_list|(
name|fcode
argument_list|)
expr_stmt|;
name|width
operator|-=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|--
name|bptr
operator|=
name|fcode
expr_stmt|;
operator|*
operator|--
name|bptr
operator|=
literal|'0'
expr_stmt|;
block|}
name|ptr
operator|=
name|buf
operator|+
name|MAXOCT
operator|+
literal|3
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
case|case
literal|'U'
case|:
case|case
literal|'I'
case|:
name|length
operator|=
literal|1
expr_stmt|;
name|fcode
operator|=
name|fcode
operator|+
literal|'a'
operator|-
literal|'A'
expr_stmt|;
comment|/* no break */
case|case
literal|'d'
case|:
case|case
literal|'i'
case|:
case|case
literal|'u'
case|:
if|if
condition|(
name|length
operator|>
literal|0
condition|)
name|num
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcode
operator|==
literal|'u'
condition|)
name|num
operator|=
operator|(
name|unsigned
operator|)
name|n
expr_stmt|;
else|else
name|num
operator|=
operator|(
name|long
operator|)
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|=
operator|(
name|fcode
operator|!=
literal|'u'
operator|&&
name|num
operator|<
literal|0
operator|)
condition|)
name|num
operator|=
operator|-
name|num
expr_stmt|;
comment|/* now convert to digits */
name|bptr
operator|=
name|b_dconv
argument_list|(
name|num
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
operator|*
operator|--
name|bptr
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|fill
operator|==
literal|0
condition|)
name|fill
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr
operator|=
name|buf
operator|+
name|MAXDIGS
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* not a control character,  				 * print it. 				 */
name|ptr
operator|=
name|bptr
operator|=
operator|&
name|fcode
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fcode
operator|!=
literal|'\0'
condition|)
name|b_emit
argument_list|(
name|bptr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* b_dconv converts the unsigned long integer "value" to  * printable decimal and places it in "buffer", right-justified.  * The value returned is the address of the first non-zero character,  * or the address of the last character if all are zero.  * The result is NOT null terminated, and is MAXDIGS characters long,  * starting at buffer[1] (to allow for insertion of a sign).  *  * This program assumes it is running on 2's complement machine  * with reasonable overflow treatment.  */
end_comment

begin_function
name|char
modifier|*
name|b_dconv
parameter_list|(
name|value
parameter_list|,
name|buffer
parameter_list|)
name|long
name|value
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|svalue
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|lval
decl_stmt|;
name|bp
operator|=
name|buffer
expr_stmt|;
comment|/* zero is a special case */
if|if
condition|(
name|value
operator|==
literal|0
condition|)
block|{
name|bp
operator|+=
name|MAXDIGS
expr_stmt|;
operator|*
name|bp
operator|=
literal|'0'
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
comment|/* develop the leading digit of the value in "n" */
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|value
operator|-=
name|BIG
expr_stmt|;
comment|/* will eventually underflow */
name|n
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|lval
operator|=
name|value
operator|-
name|BIG
operator|)
operator|>=
literal|0
condition|)
block|{
name|value
operator|=
name|lval
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
comment|/* stash it in buffer[1] to allow for a sign */
name|bp
index|[
literal|1
index|]
operator|=
name|n
operator|+
literal|'0'
expr_stmt|;
comment|/* 	 * Now develop the rest of the digits. Since speed counts here, 	 * we do it in two loops. The first gets "value" down until it 	 * is no larger than MAXINT. The second one uses integer divides 	 * rather than long divides to speed it up. 	 */
name|bp
operator|+=
name|MAXDIGS
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|value
operator|>
name|MAXINT
condition|)
block|{
operator|*
operator|--
name|bp
operator|=
call|(
name|int
call|)
argument_list|(
name|value
operator|%
literal|10
argument_list|)
operator|+
literal|'0'
expr_stmt|;
name|value
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* cannot lose precision */
name|svalue
operator|=
name|value
expr_stmt|;
while|while
condition|(
name|svalue
operator|>
literal|0
condition|)
block|{
operator|*
operator|--
name|bp
operator|=
operator|(
name|svalue
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|svalue
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* fill in intermediate zeroes if needed */
if|if
condition|(
name|buffer
index|[
literal|1
index|]
operator|!=
literal|'0'
condition|)
block|{
while|while
condition|(
name|bp
operator|>
name|buffer
operator|+
literal|2
condition|)
operator|*
operator|--
name|bp
operator|=
literal|'0'
expr_stmt|;
operator|--
name|bp
expr_stmt|;
block|}
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This program sends string "s" to pputchar. The character after  * the end of "s" is given by "send". This allows the size of the  * field to be computed; it is stored in "alen". "width" contains the  * user specified length. If width<alen, the width will be taken to  * be alen. "sign" is zero if the string is to be right-justified  * in the field, nonzero if it is to be left-justified. "fill" is  * 0 if the string is to be padded with '0', positive if it is to be  * padded with ' ', and negative if an initial '-' should appear before  * any padding in right-justification (to avoid printing "-3" as  * "000-3" where "-0003" was intended).  */
end_comment

begin_expr_stmt
name|b_emit
argument_list|(
name|s
argument_list|,
name|send
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|send
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|cfill
decl_stmt|;
specifier|register
name|int
name|alen
decl_stmt|;
name|int
name|npad
decl_stmt|;
name|alen
operator|=
name|send
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|alen
operator|>
name|width
condition|)
name|width
operator|=
name|alen
expr_stmt|;
name|cfill
operator|=
name|fill
operator|>
literal|0
condition|?
literal|' '
else|:
literal|'0'
expr_stmt|;
comment|/* we may want to print a leading '-' before anything */
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
operator|&&
name|fill
operator|<
literal|0
condition|)
block|{
name|pputchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
name|alen
operator|--
expr_stmt|;
name|width
operator|--
expr_stmt|;
block|}
name|npad
operator|=
name|width
operator|-
name|alen
expr_stmt|;
comment|/* emit any leading pad characters */
if|if
condition|(
operator|!
name|sign
condition|)
while|while
condition|(
operator|--
name|npad
operator|>=
literal|0
condition|)
name|pputchar
argument_list|(
name|cfill
argument_list|)
expr_stmt|;
comment|/* emit the string itself */
while|while
condition|(
operator|--
name|alen
operator|>=
literal|0
condition|)
name|pputchar
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
comment|/* emit trailing pad characters */
if|if
condition|(
name|sign
condition|)
while|while
condition|(
operator|--
name|npad
operator|>=
literal|0
condition|)
name|pputchar
argument_list|(
name|cfill
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|UCB_PWHASH
end_ifndef

begin_define
define|#
directive|define
name|NUID
value|2048
end_define

begin_decl_stmt
name|char
name|names
index|[
name|NUID
index|]
index|[
name|NMAX
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|getname
parameter_list|(
name|uid
parameter_list|)
block|{
specifier|register
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
specifier|static
name|init
expr_stmt|;
name|struct
name|passwd
modifier|*
name|getpwent
parameter_list|()
function_decl|;
if|if
condition|(
name|uid
operator|>=
literal|0
operator|&&
name|uid
operator|<
name|NUID
operator|&&
name|names
index|[
name|uid
index|]
index|[
literal|0
index|]
condition|)
return|return
operator|(
operator|&
name|names
index|[
name|uid
index|]
index|[
literal|0
index|]
operator|)
return|;
if|if
condition|(
name|init
operator|==
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|init
operator|==
literal|0
condition|)
name|setpwent
argument_list|()
operator|,
name|init
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|pw
operator|=
name|getpwent
argument_list|()
condition|)
block|{
if|if
condition|(
name|pw
operator|->
name|pw_uid
operator|<
literal|0
operator|||
name|pw
operator|->
name|pw_uid
operator|>=
name|NUID
condition|)
continue|continue;
if|if
condition|(
name|names
index|[
name|pw
operator|->
name|pw_uid
index|]
index|[
literal|0
index|]
condition|)
continue|continue;
name|strncpy
argument_list|(
name|names
index|[
name|pw
operator|->
name|pw_uid
index|]
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|,
name|NMAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|->
name|pw_uid
operator|==
name|uid
condition|)
return|return
operator|(
operator|&
name|names
index|[
name|uid
index|]
index|[
literal|0
index|]
operator|)
return|;
block|}
name|init
operator|=
literal|2
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

