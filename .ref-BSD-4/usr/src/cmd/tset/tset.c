begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* # define DEB /* **  TSET -- set terminal modes ** **	This program does sophisticated terminal initialization. **	I recommend that you include it in your .start_up or .login **	file to initialize whatever terminal you are on. ** **	There are several features: ** **	A special file or sequence (as controlled by the ttycap file) **	is sent to the terminal. ** **	Mode bits are set on a per-terminal_type basis (much better **	than UNIX itself).  This allows special delays, automatic **	tabs, etc. ** **	Erase and Kill characters can be set to whatever you want. **	Default is to change erase to control-H on a terminal which **	can overstrike, and leave it alone on anything else.  Kill **	is always left alone unless specifically requested.  These **	characters can be represented as "^X" meaning control-X; **	X is any character. ** **	Terminals which are dialups or plugboard types can be aliased **	to whatever type you may have in your home or office.  Thus, **	if you know that when you dial up you will always be on a **	TI 733, you can specify that fact to tset.  You can represent **	a type as "?type".  This will ask you what type you want it **	to be -- if you reply with just a newline, it will default **	to the type given. ** **	The htmp file, used by ex, etc., can be updated. ** **	The current terminal type can be queried. ** **	Usage: **		tset [-] [-EC] [-eC] [-kC] [-s] [-h] [-u] [-r] **			[-m [ident] [test baudrate] :type] **			[-Q] [-I] [-S] [type] ** **		In systems with environments, use: **			`tset -s ...` **		Actually, this doesn't work because of a shell bug. **		Instead, use: **			tset -s ...> tset.tmp **			source tset.tmp **			rm tset.tmp **		or: **			set noglob **			set term=(`tset -S ....`) **			setenv TERM $term[1] **			setenv TERMCAP "$term[2]" **			unset term **			unset noglob ** **	Positional Parameters: **		type -- the terminal type to force.  If this is **			specified, initialization is for this **			terminal type. ** **	Flags: **		- -- report terminal type.  Whatever type is **			decided on is reported.  If no other flags **			are stated, the only affect is to write **			the terminal type on the standard output. **		-r -- report to user in addition to other flags. **		-EC -- set the erase character to C on all terminals **			except those which cannot backspace (e.g., **			a TTY 33).  C defaults to control-H. **		-eC -- set the erase character to C on all terminals. **			C defaults to control-H.  If neither -E or -e **			are specified, the erase character is set to **			control-H if the terminal can both backspace **			and not overstrike (e.g., a CRT).  If the erase **			character is NULL (zero byte), it will be reset **			to '#' if nothing else is specified. **		-kC -- set the kill character to C on all terminals. **			Default for C is control-X.  If not specified, **			the kill character is untouched; however, if **			not specified and the kill character is NULL **			(zero byte), the kill character is set to '@'. **		-iC -- reserved for setable interrupt character. **		-qC -- reserved for setable quit character. **		-m -- map the system identified type to some user **			specified type. The mapping can be baud rate **			dependent. This replaces the old -d, -p flags. **			(-d type  ->  -m dialup:type) **			(-p type  ->  -m plug:type) **			Syntax:	-m identifier [test baudrate] :type **			where: ``identifier'' is whatever is found in **			/etc/ttytype for this port, (abscence of an identifier **			matches any identifier); ``test'' may be any combination **			of>  =<  !  @; ``baudrate'' is as with stty(1); **			``type'' is the actual terminal type to use if the **			mapping condition is met. Multiple maps are scanned **			in order and the first match prevails. **		-h -- don't read htmp file.  Normally the terminal type **			is determined by reading the htmp file or the **			environment (unless some mapping is specified). **			This forces a read of the ttytype file -- useful **			when htmp is somehow wrong. **		-u -- don't update htmp.  It seemed like this should **			be put in.  Note that htmp is never actually **			written if there are no changes, so don't bother **			bother using this for efficiency reasons alone. **		-s -- output setenv commands for TERM.  This can be **			used with **				`tset -s ...` **			and is to be prefered to: **				setenv TERM `tset - ...` **			because -s sets the TERMCAP variable also. **		-S -- Similar to -s but outputs 2 strings suitable for **			use in csh .login files as follows: **				set noglob **				set term=(`tset -S .....`) **				setenv TERM $term[1] **				setenv TERMCAP "$term[2]" **				unset term **				unset noglob **		-Q -- be quiet.  don't output 'Erase set to' etc. **		-I -- don't do terminal initialization (is& if **			strings). ** **	Files: **		/etc/ttytype **			contains a terminal id -> terminal type **			mapping; used when any user mapping is specified, **			or the environment doesn't have TERM set. **		/etc/termcap **			a terminal_type -> terminal_capabilities **			mapping. ** **	Return Codes: **		-1 -- couldn't open ttycap. **		1 -- bad terminal type, or standard output not tty. **		0 -- ok. ** **	Defined Constants: **		DIALUP -- the type code for a dialup port **		PLUGBOARD -- the code for a plugboard port. **		ARPANET -- the code for an arpanet port. **		BACKSPACE -- control-H, the default for -e. **		CONTROLX -- control-X, the default for -k. **		OLDERASE -- the system default erase character. **		OLDKILL -- the system default kill character. **		FILEDES -- the file descriptor to do the operation **			on, nominally 1 or 2. **		STDOUT -- the standard output file descriptor. **		UIDMASK -- the bit pattern to mask with the getuid() **			call to get just the user id. **		GTTYN -- defines file containing generalized ttynames **			and compiles code to look there. ** **	Requires: **		Routines to handle htmp, ttytype, and ttycap. ** **	Compilation Flags: **		OLDDIALUP -- accept the -d flag. Map "sd" to "dialup". **		OLDPLUGBOARD -- accept the -p flag. Map "sp" to "plugboard". **		OLDARPANET -- accept the -a flag. Map "sa" to "arpanet". **		OLDFLAGS -- must be defined to compile code for any of **			the -d, -p, or -a flags. **		FULLLOGIN -- if defined, login sets the ttytype from **			/etc/ttytype file. **		V6 -- if clear, use environments, not htmp. **			also use TIOCSETN rather than stty to avoid flushing **		GTTYN -- if set, compiles code to look at /etc/ttytype. ** **	Trace Flags: **		none ** **	Diagnostics: **		Bad flag **			An incorrect option was specified. **		Too few args **			more command line arguments are required. **		Unexpected arg **			wrong type of argument was encountered. **		Cannot open ... **			The specified file could not be openned. **		Type ... unknown **			An unknown terminal type was specified. **		Cannot update htmp **			Cannot update htmp file when the standard **			output is not a terminal. **		Erase set to ... **			Telling that the erase character has been **			set to the specified character. **		Kill set to ... **			Ditto for kill **		Erase is ...    Kill is ... **			Tells that the erase/kill characters were **			wierd before, but they are being left as-is. **		Not a terminal **			Set if FILEDES is not a terminal. ** **	Compilation Instructions: **		cc -n -O tset.c -ltermlib **		mv a.out tset **		chown bin tset **		chmod 4755 tset ** **		where 'bin' should be whoever owns the 'htmp' file. **		If 'htmp' is 666, then tset need not be setuid. ** **	Author: **		Eric Allman **		Electronics Research Labs **		U.C. Berkeley ** **	History: **		7/80 -- '-S' added. -m mapping added. TERMCAP string **			cleaned up. **		3/80 -- Changed to use tputs.  Prc& flush added. **		10/79 -- '-s' option extended to handle TERMCAP **			variable, set noglob, quote the entry, **			and know about the Bourne shell.  Terminal **			initialization moved to before any information **			output so screen clears would not screw you. **			'-Q' option added. **		8/79 -- '-' option alone changed to only output **			type.  '-s' option added.  'VERSION7' **			changed to 'V6' for compatibility. **		12/78 -- modified for eventual migration to VAX/UNIX, **			so the '-' option is changed to output only **			the terminal type to STDOUT instead of **			FILEDES.  FULLLOGIN flag added. **		9/78 -- '-' and '-p' options added (now fully **			compatible with ttytype!), and spaces are **			permitted between the -d and the type. **		8/78 -- The sense of -h and -u were reversed, and the **			-f flag is dropped -- same effect is available **			by just stating the terminal type. **		10/77 -- Written. */
end_comment

begin_comment
comment|/* # define	FULLLOGIN	1 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|V6
end_ifndef

begin_define
define|#
directive|define
name|GTTYN
value|"/etc/ttytype"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|BACKSPACE
value|('H'& 037)
end_define

begin_define
define|#
directive|define
name|CONTROLX
value|('X'& 037)
end_define

begin_define
define|#
directive|define
name|OLDERASE
value|'#'
end_define

begin_define
define|#
directive|define
name|OLDKILL
value|'@'
end_define

begin_define
define|#
directive|define
name|FILEDES
value|2
end_define

begin_define
define|#
directive|define
name|STDOUT
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_define
define|#
directive|define
name|UIDMASK
value|0377
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UIDMASK
value|-1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEFTYPE
value|"unknown"
end_define

begin_define
define|#
directive|define
name|USAGE
define|\
value|"usage: tset [-] [-hrsuIQS] [-eC] [-kC] [-m [ident][test speed]:type] [type]\n"
end_define

begin_define
define|#
directive|define
name|DIALUP
value|"dialup"
end_define

begin_define
define|#
directive|define
name|OLDDIALUP
value|"sd"
end_define

begin_define
define|#
directive|define
name|PLUGBOARD
value|"plugboard"
end_define

begin_define
define|#
directive|define
name|OLDPLUGBOARD
value|"sp"
end_define

begin_comment
comment|/*** # define	ARPANET		"arpanet" # define	OLDARPANET	"sa" ***/
end_comment

begin_define
define|#
directive|define
name|OLDFLAGS
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|GTTYN
end_ifdef

begin_typedef
typedef|typedef
name|char
modifier|*
name|ttyid_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NOTTY
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|char
name|ttyid_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NOTTY
value|'x'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Baud Rate Conditionals  */
end_comment

begin_define
define|#
directive|define
name|ANY
value|0
end_define

begin_define
define|#
directive|define
name|GT
value|1
end_define

begin_define
define|#
directive|define
name|EQ
value|2
end_define

begin_define
define|#
directive|define
name|LT
value|4
end_define

begin_define
define|#
directive|define
name|GE
value|(GT|EQ)
end_define

begin_define
define|#
directive|define
name|LE
value|(LT|EQ)
end_define

begin_define
define|#
directive|define
name|NE
value|(GT|LT)
end_define

begin_define
define|#
directive|define
name|ALL
value|(GT|EQ|LT)
end_define

begin_define
define|#
directive|define
name|NMAP
value|10
end_define

begin_struct
struct|struct
name|map
block|{
name|char
modifier|*
name|Ident
decl_stmt|;
name|char
name|Test
decl_stmt|;
name|char
name|Speed
decl_stmt|;
name|char
modifier|*
name|Type
decl_stmt|;
block|}
name|map
index|[
name|NMAP
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|map
modifier|*
name|Map
init|=
name|map
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|speed
decl_stmt|;
block|}
name|speeds
index|[]
init|=
block|{
literal|"0"
block|,
name|B0
block|,
literal|"50"
block|,
name|B50
block|,
literal|"75"
block|,
name|B75
block|,
literal|"110"
block|,
name|B110
block|,
literal|"134"
block|,
name|B134
block|,
literal|"134.5"
block|,
name|B134
block|,
literal|"150"
block|,
name|B150
block|,
literal|"200"
block|,
name|B200
block|,
literal|"300"
block|,
name|B300
block|,
literal|"600"
block|,
name|B600
block|,
literal|"1200"
block|,
name|B1200
block|,
literal|"1800"
block|,
name|B1800
block|,
literal|"2400"
block|,
name|B2400
block|,
literal|"4800"
block|,
name|B4800
block|,
literal|"9600"
block|,
name|B9600
block|,
literal|"exta"
block|,
name|EXTA
block|,
literal|"extb"
block|,
name|EXTB
block|,
literal|0
block|, }
struct|;
end_struct

begin_decl_stmt
name|char
name|Erase_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new erase character */
end_comment

begin_decl_stmt
name|char
name|Kill_char
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* new kill character */
end_comment

begin_decl_stmt
name|char
name|Specialerase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set => Erase_char only on terminals with backspace */
end_comment

begin_decl_stmt
name|ttyid_t
name|Ttyid
init|=
name|NOTTY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal identifier */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TtyType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of terminal */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DefType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default type if none other computed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|NewType
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mapping identifier based on old flags */
end_comment

begin_decl_stmt
name|int
name|Dash_u
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't update htmp */
end_comment

begin_decl_stmt
name|int
name|Dash_h
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't read htmp */
end_comment

begin_decl_stmt
name|int
name|DoSetenv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output setenv commands */
end_comment

begin_decl_stmt
name|int
name|BeQuiet
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* be quiet */
end_comment

begin_decl_stmt
name|int
name|NoInit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't output initialization string */
end_comment

begin_decl_stmt
name|int
name|Report
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report current type */
end_comment

begin_decl_stmt
name|int
name|Ureport
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report to user */
end_comment

begin_decl_stmt
name|int
name|RepOnly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* report only */
end_comment

begin_decl_stmt
name|int
name|CmndLine
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output full command lines (-s option) */
end_comment

begin_decl_stmt
name|int
name|Ask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ask user for termtype */
end_comment

begin_define
define|#
directive|define
name|CAPBUFSIZ
value|1024
end_define

begin_decl_stmt
name|char
name|Capbuf
index|[
name|CAPBUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line from /etc/termcap for this TtyType */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Ttycap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* termcap line from termcap or environ */
end_comment

begin_struct
struct|struct
name|delay
block|{
name|int
name|d_delay
decl_stmt|;
name|int
name|d_bits
decl_stmt|;
block|}
struct|;
end_struct

begin_include
include|#
directive|include
file|"tset.delays.h"
end_include

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|struct
name|sgttyb
name|mode
decl_stmt|;
name|struct
name|sgttyb
name|oldmode
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
specifier|auto
name|char
modifier|*
name|bufp
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|command
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|Break
decl_stmt|;
name|int
name|Not
decl_stmt|;
name|int
name|Mapped
decl_stmt|;
specifier|extern
name|char
modifier|*
name|nextarg
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|mapped
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|V6
specifier|extern
name|char
modifier|*
name|hsgettype
parameter_list|()
function_decl|;
else|#
directive|else
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GTTYN
specifier|extern
name|char
modifier|*
name|stypeof
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|ttyname
parameter_list|()
function_decl|;
specifier|extern
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
endif|#
directive|endif
name|char
name|bs_char
decl_stmt|;
name|int
name|csh
decl_stmt|;
extern|extern		prc(
block|)
function|;
end_function

begin_decl_stmt
specifier|extern
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|gtty
argument_list|(
name|FILEDES
argument_list|,
operator|&
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|prs
argument_list|(
literal|"Not a terminal\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|bmove
argument_list|(
operator|&
name|mode
argument_list|,
operator|&
name|oldmode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ospeed
operator|=
name|mode
operator|.
name|sg_ospeed
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* scan argument list and collect flags */
end_comment

begin_expr_stmt
name|command
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|argc
operator|==
literal|2
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|RepOnly
operator|++
expr_stmt|;
name|Dash_u
operator|++
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|argc
operator|--
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
operator|--
name|argc
operator|>=
literal|0
condition|)
block|{
name|p
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|p
operator|==
name|NULL
condition|)
name|Report
operator|++
expr_stmt|;
comment|/* report current terminal type */
else|else
while|while
condition|(
operator|*
name|p
condition|)
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|'r'
case|:
comment|/* report to user */
name|Ureport
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'E'
case|:
comment|/* special erase: operate on all but TTY33 */
name|Specialerase
operator|++
expr_stmt|;
comment|/* explicit fall-through to -e case */
case|case
literal|'e'
case|:
comment|/* erase character */
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
name|Erase_char
operator|=
operator|-
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|Erase_char
operator|=
operator|*
operator|++
name|p
operator|&
literal|037
expr_stmt|;
else|else
name|Erase_char
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
continue|continue;
case|case
literal|'k'
case|:
comment|/* kill character */
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
name|Kill_char
operator|=
name|CONTROLX
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'^'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|Kill_char
operator|=
operator|*
operator|++
name|p
operator|&
literal|037
expr_stmt|;
else|else
name|Kill_char
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
continue|continue;
ifdef|#
directive|ifdef
name|OLDFLAGS
ifdef|#
directive|ifdef
name|OLDDIALUP
case|case
literal|'d'
case|:
comment|/* dialup type */
name|NewType
operator|=
name|DIALUP
expr_stmt|;
goto|goto
name|mapold
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OLDPLUGBOARD
case|case
literal|'p'
case|:
comment|/* plugboard type */
name|NewType
operator|=
name|PLUGBOARD
expr_stmt|;
goto|goto
name|mapold
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OLDARPANET
case|case
literal|'a'
case|:
comment|/* arpanet type */
name|Newtype
operator|=
name|ARPANET
expr_stmt|;
goto|goto
name|mapold
goto|;
endif|#
directive|endif
name|mapold
label|:
name|Map
operator|->
name|Ident
operator|=
name|NewType
expr_stmt|;
name|Map
operator|->
name|Test
operator|=
name|ALL
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|nextarg
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
operator|++
argument_list|)
expr_stmt|;
block|}
name|Map
operator|->
name|Type
operator|=
name|p
expr_stmt|;
name|Map
operator|++
expr_stmt|;
name|Mapped
operator|++
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
continue|continue;
endif|#
directive|endif
case|case
literal|'m'
case|:
comment|/* map identifier to type */
comment|/* This code is very loose. Almost no 				** syntax checking is done!! However, 				** illegal syntax will only produce 				** weird results. 				*/
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|nextarg
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|Map
operator|->
name|Ident
operator|=
name|p
expr_stmt|;
comment|/* identifier */
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
else|else
name|Map
operator|->
name|Ident
operator|=
literal|""
expr_stmt|;
name|Break
operator|=
literal|0
expr_stmt|;
name|Not
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|Break
condition|)
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
name|NULL
case|:
name|p
operator|=
name|nextarg
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
operator|++
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|':'
case|:
comment|/* mapped type */
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
name|Break
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'>'
case|:
comment|/* conditional */
name|Map
operator|->
name|Test
operator||=
name|GT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
literal|'<'
case|:
comment|/* conditional */
name|Map
operator|->
name|Test
operator||=
name|LT
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
literal|'='
case|:
comment|/* conditional */
case|case
literal|'@'
case|:
name|Map
operator|->
name|Test
operator||=
name|EQ
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
literal|'!'
case|:
comment|/* invert conditions */
name|Not
operator|=
operator|~
name|Not
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
literal|'B'
case|:
comment|/* Baud rate */
name|p
operator|++
expr_stmt|;
comment|/* intentional fallthru */
default|default:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'e'
condition|)
block|{
name|Map
operator|->
name|Speed
operator|=
name|baudrate
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'.'
condition|)
name|p
operator|++
expr_stmt|;
block|}
else|else
name|Break
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|Not
condition|)
comment|/* invert sense of test */
block|{
name|Map
operator|->
name|Test
operator|=
operator|(
operator|~
operator|(
name|Map
operator|->
name|Test
operator|)
operator|)
operator|&
name|ALL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|nextarg
argument_list|(
name|argc
operator|--
argument_list|,
name|argv
operator|++
argument_list|)
expr_stmt|;
block|}
name|Map
operator|->
name|Type
operator|=
name|p
expr_stmt|;
name|p
operator|=
literal|""
expr_stmt|;
name|Map
operator|++
expr_stmt|;
name|Mapped
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'h'
case|:
comment|/* don't get type from htmp or env */
name|Dash_h
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'u'
case|:
comment|/* don't update htmp */
name|Dash_u
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
comment|/* output setenv commands */
name|DoSetenv
operator|++
expr_stmt|;
name|CmndLine
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'S'
case|:
comment|/* output setenv strings */
name|DoSetenv
operator|++
expr_stmt|;
name|CmndLine
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
literal|'Q'
case|:
comment|/* be quiet */
name|BeQuiet
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'I'
case|:
comment|/* no initialization */
name|NoInit
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'A'
case|:
comment|/* Ask user */
name|Ask
operator|++
expr_stmt|;
continue|continue;
default|default:
operator|*
name|p
operator|--
operator|=
name|NULL
expr_stmt|;
name|fatal
argument_list|(
literal|"Bad flag -"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* terminal type */
name|DefType
operator|=
name|p
expr_stmt|;
block|}
block|}
end_while

begin_if
if|if
condition|(
name|DefType
condition|)
block|{
if|if
condition|(
name|Mapped
condition|)
block|{
name|Map
operator|->
name|Ident
operator|=
literal|""
expr_stmt|;
comment|/* means "map any type" */
name|Map
operator|->
name|Test
operator|=
name|ALL
expr_stmt|;
comment|/* at all baud rates */
name|Map
operator|->
name|Type
operator|=
name|DefType
expr_stmt|;
comment|/* to the default type */
block|}
else|else
name|TtyType
operator|=
name|DefType
expr_stmt|;
block|}
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|V6
end_ifndef

begin_comment
comment|/* get current idea of terminal type from environment */
end_comment

begin_if
if|if
condition|(
operator|!
name|Dash_h
operator|&&
operator|!
name|Mapped
operator|&&
name|TtyType
operator|==
literal|0
condition|)
name|TtyType
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* determine terminal id if needed */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_if
if|if
condition|(
name|Ttyid
operator|==
name|NOTTY
operator|&&
operator|(
name|TtyType
operator|==
literal|0
operator|||
operator|!
name|Dash_h
operator|||
operator|!
name|Dash_u
operator|)
condition|)
name|Ttyid
operator|=
name|ttyn
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
end_if

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
operator|!
name|RepOnly
operator|&&
name|Ttyid
operator|==
name|NOTTY
operator|&&
operator|(
name|TtyType
operator|==
literal|0
operator|||
operator|!
name|Dash_h
operator|)
condition|)
name|Ttyid
operator|=
name|ttyname
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_comment
comment|/* get htmp if ever used */
end_comment

begin_if
if|if
condition|(
operator|!
name|Dash_u
operator|||
operator|(
name|TtyType
operator|==
literal|0
operator|&&
operator|!
name|Dash_h
operator|)
condition|)
block|{
comment|/* get htmp entry -- if error or wrong user use ttytype */
if|if
condition|(
name|Ttyid
operator|==
name|NOTTY
operator|||
name|hget
argument_list|(
name|Ttyid
argument_list|)
operator|<
literal|0
operator|||
name|hgettype
argument_list|()
operator|==
literal|0
operator|||
name|hgetuid
argument_list|()
operator|!=
operator|(
name|getuid
argument_list|()
operator|&
name|UIDMASK
operator|)
condition|)
name|Dash_h
operator|++
expr_stmt|;
block|}
end_if

begin_comment
comment|/* find terminal type (if not already known) */
end_comment

begin_if
if|if
condition|(
name|TtyType
operator|==
literal|0
operator|&&
operator|!
name|Dash_h
condition|)
block|{
comment|/* get type from /etc/htmp */
name|TtyType
operator|=
name|hsgettype
argument_list|()
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GTTYN
end_ifdef

begin_comment
comment|/* If still undefined, look at /etc/ttytype */
end_comment

begin_if
if|if
condition|(
name|TtyType
operator|==
literal|0
condition|)
block|{
name|TtyType
operator|=
name|stypeof
argument_list|(
name|Ttyid
argument_list|)
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* If still undefined, use DEFTYPE */
end_comment

begin_if
if|if
condition|(
name|TtyType
operator|==
literal|0
condition|)
block|{
name|TtyType
operator|=
name|DEFTYPE
expr_stmt|;
block|}
end_if

begin_comment
comment|/* check for dialup or other mapping */
end_comment

begin_if
if|if
condition|(
name|Mapped
condition|)
name|TtyType
operator|=
name|mapped
argument_list|(
name|TtyType
argument_list|,
name|ospeed
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* TtyType now contains a pointer to the type of the terminal */
end_comment

begin_comment
comment|/* If the first character is '?', ask the user */
end_comment

begin_if
if|if
condition|(
name|TtyType
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
name|Ask
operator|++
expr_stmt|;
name|TtyType
operator|++
expr_stmt|;
if|if
condition|(
name|TtyType
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|TtyType
operator|=
name|DEFTYPE
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|Ask
condition|)
block|{
name|prs
argument_list|(
literal|"TERM = ("
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|") "
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
comment|/* read the terminal.  If not empty, set type */
name|i
operator|=
name|read
argument_list|(
literal|2
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|buf
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|i
operator|--
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|TtyType
operator|=
name|buf
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|Ttycap
operator|==
literal|0
condition|)
block|{
comment|/* get terminal capabilities */
switch|switch
condition|(
name|tgetent
argument_list|(
name|Capbuf
argument_list|,
name|TtyType
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|prs
argument_list|(
literal|"Cannot open termcap file\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|prs
argument_list|(
literal|"Type "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|TtyType
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|" unknown\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|Ttycap
operator|=
name|Capbuf
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|RepOnly
condition|)
block|{
comment|/* determine erase and kill characters */
if|if
condition|(
name|Specialerase
operator|&&
operator|!
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
name|Erase_char
operator|=
literal|0
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
name|p
operator|=
name|tgetstr
argument_list|(
literal|"kb"
argument_list|,
operator|&
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|p
operator|=
name|tgetstr
argument_list|(
literal|"bc"
argument_list|,
operator|&
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|bs_char
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
name|bs_char
operator|=
name|BACKSPACE
expr_stmt|;
else|else
name|bs_char
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Erase_char
operator|==
literal|0
operator|&&
operator|!
name|tgetflag
argument_list|(
literal|"os"
argument_list|)
operator|&&
name|mode
operator|.
name|sg_erase
operator|==
name|OLDERASE
condition|)
block|{
if|if
condition|(
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
operator|||
name|bs_char
operator|!=
literal|0
condition|)
name|Erase_char
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|Erase_char
operator|<
literal|0
condition|)
name|Erase_char
operator|=
operator|(
name|bs_char
operator|!=
literal|0
operator|)
condition|?
name|bs_char
else|:
name|BACKSPACE
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|sg_erase
operator|==
literal|0
condition|)
name|mode
operator|.
name|sg_erase
operator|=
name|OLDERASE
expr_stmt|;
if|if
condition|(
name|Erase_char
operator|!=
literal|0
condition|)
name|mode
operator|.
name|sg_erase
operator|=
name|Erase_char
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|sg_kill
operator|==
literal|0
condition|)
name|mode
operator|.
name|sg_kill
operator|=
name|OLDKILL
expr_stmt|;
if|if
condition|(
name|Kill_char
operator|!=
literal|0
condition|)
name|mode
operator|.
name|sg_kill
operator|=
name|Kill_char
expr_stmt|;
comment|/* set modes */
name|setdelay
argument_list|(
literal|"dC"
argument_list|,
name|CRdelay
argument_list|,
name|CRbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dN"
argument_list|,
name|NLdelay
argument_list|,
name|NLbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dB"
argument_list|,
name|BSdelay
argument_list|,
name|BSbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dF"
argument_list|,
name|FFdelay
argument_list|,
name|FFbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
name|setdelay
argument_list|(
literal|"dT"
argument_list|,
name|TBdelay
argument_list|,
name|TBbits
argument_list|,
operator|&
name|mode
operator|.
name|sg_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"UC"
argument_list|)
operator|||
name|command
index|[
literal|0
index|]
operator|==
literal|'T'
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|LCASE
expr_stmt|;
elseif|else
if|if
condition|(
name|tgetflag
argument_list|(
literal|"LC"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|LCASE
expr_stmt|;
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|EVENP
operator||
name|ODDP
operator||
name|RAW
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|V6
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|CBREAK
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tgetflag
argument_list|(
literal|"EP"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|EVENP
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"OP"
argument_list|)
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|ODDP
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|.
name|sg_flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
literal|0
condition|)
name|mode
operator|.
name|sg_flags
operator||=
name|EVENP
operator||
name|ODDP
expr_stmt|;
name|mode
operator|.
name|sg_flags
operator||=
name|CRMOD
operator||
name|ECHO
operator||
name|XTABS
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"NL"
argument_list|)
condition|)
comment|/* new line, not line feed */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|CRMOD
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"HD"
argument_list|)
condition|)
comment|/* half duplex */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|ECHO
expr_stmt|;
if|if
condition|(
name|tgetflag
argument_list|(
literal|"pt"
argument_list|)
condition|)
comment|/* print tabs */
name|mode
operator|.
name|sg_flags
operator|&=
operator|~
name|XTABS
expr_stmt|;
if|if
condition|(
operator|!
name|bequal
argument_list|(
operator|&
name|mode
argument_list|,
operator|&
name|oldmode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
condition|)
ifndef|#
directive|ifndef
name|V6
name|ioctl
argument_list|(
name|FILEDES
argument_list|,
name|TIOCSETN
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
else|#
directive|else
name|stty
argument_list|(
name|FILEDES
argument_list|,
operator|&
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* get pad character */
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
name|PC
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
comment|/* output startup string */
if|if
condition|(
operator|!
name|NoInit
condition|)
block|{
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"is"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
name|tputs
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|prc
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tgetstr
argument_list|(
literal|"if"
argument_list|,
operator|&
name|bufp
argument_list|)
operator|!=
literal|0
condition|)
name|cat
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* let terminal settle down */
block|}
comment|/* set up environment for the shell we are using */
comment|/* (this code is rather heuristic) */
name|csh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|DoSetenv
condition|)
block|{
ifndef|#
directive|ifndef
name|V6
name|char
modifier|*
name|sh
decl_stmt|;
if|if
condition|(
operator|(
name|sh
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|&&
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|sh
argument_list|)
operator|)
operator|>=
literal|3
condition|)
block|{
name|p
operator|=
operator|&
name|sh
index|[
name|i
operator|-
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|csh
operator|=
name|sequal
argument_list|(
name|p
argument_list|,
literal|"csh"
argument_list|)
operator|)
operator|&&
name|CmndLine
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"set noglob;\n"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|csh
condition|)
endif|#
directive|endif
comment|/* running system shell */
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"export TERMCAP TERM;\n"
argument_list|,
literal|21
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* report type if appropriate */
end_comment

begin_if
if|if
condition|(
name|DoSetenv
operator|||
name|Report
operator|||
name|Ureport
condition|)
block|{
comment|/* find first alias (if any) */
for|for
control|(
name|p
operator|=
name|Ttycap
init|;
operator|*
name|p
operator|!=
literal|0
operator|&&
operator|*
name|p
operator|!=
literal|'|'
operator|&&
operator|*
name|p
operator|!=
literal|':'
condition|;
name|p
operator|++
control|)
continue|continue;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
operator|||
operator|*
name|p
operator|==
literal|':'
condition|)
name|p
operator|=
name|Ttycap
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
name|bufp
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'|'
operator|&&
operator|*
name|p
operator|!=
literal|':'
operator|&&
operator|*
name|p
operator|!=
literal|0
condition|)
name|p
operator|++
expr_stmt|;
name|i
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|DoSetenv
condition|)
block|{
if|if
condition|(
name|csh
condition|)
block|{
if|if
condition|(
name|CmndLine
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"setenv TERM "
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
name|bufp
argument_list|,
name|p
operator|-
name|bufp
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|CmndLine
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|";\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"TERM="
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
name|bufp
argument_list|,
name|p
operator|-
name|bufp
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|";\n"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Report
operator|&&
operator|!
name|DoSetenv
condition|)
block|{
name|write
argument_list|(
name|STDOUT
argument_list|,
name|bufp
argument_list|,
name|p
operator|-
name|bufp
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Ureport
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|prs
argument_list|(
literal|"Terminal type is "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|DoSetenv
condition|)
block|{
if|if
condition|(
name|csh
condition|)
block|{
if|if
condition|(
name|CmndLine
condition|)
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"setenv TERMCAP '"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"TERMCAP='"
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|wrtermcap
argument_list|(
name|Ttycap
argument_list|)
expr_stmt|;
if|if
condition|(
name|csh
condition|)
block|{
if|if
condition|(
name|CmndLine
condition|)
block|{
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"';\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"unset noglob;\n"
argument_list|,
literal|14
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|write
argument_list|(
name|STDOUT
argument_list|,
literal|"';\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|RepOnly
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* tell about changing erase and kill characters */
end_comment

begin_expr_stmt
name|reportek
argument_list|(
literal|"Erase"
argument_list|,
name|mode
operator|.
name|sg_erase
argument_list|,
name|oldmode
operator|.
name|sg_erase
argument_list|,
name|OLDERASE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|reportek
argument_list|(
literal|"Kill"
argument_list|,
name|mode
operator|.
name|sg_kill
argument_list|,
name|oldmode
operator|.
name|sg_kill
argument_list|,
name|OLDKILL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|V6
end_ifdef

begin_comment
comment|/* update htmp */
end_comment

begin_if
if|if
condition|(
operator|!
name|Dash_u
condition|)
block|{
if|if
condition|(
name|Ttyid
operator|==
literal|0
condition|)
name|Ttyid
operator|=
name|ttyn
argument_list|(
name|FILEDES
argument_list|)
expr_stmt|;
if|if
condition|(
name|Ttyid
operator|==
literal|'x'
condition|)
block|{
name|prs
argument_list|(
literal|"Cannot update htmp\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* update htmp file only if changed */
if|if
condition|(
operator|!
name|bequal
argument_list|(
name|Capbuf
argument_list|,
name|hsgettype
argument_list|()
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|hsettype
argument_list|(
name|Capbuf
index|[
literal|0
index|]
operator||
operator|(
name|Capbuf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|hput
argument_list|(
name|Ttyid
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  reportek
operator|(
name|name
operator|,
name|new
operator|,
name|old
operator|,
name|def
operator|)
name|char
operator|*
name|name
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|old
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|new
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|def
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
name|o
decl_stmt|;
specifier|register
name|char
name|n
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|BeQuiet
condition|)
return|return;
name|o
operator|=
name|old
expr_stmt|;
name|n
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|n
operator|&&
name|n
operator|==
name|def
condition|)
return|return;
name|prs
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|n
condition|)
name|prs
argument_list|(
literal|" is "
argument_list|)
expr_stmt|;
else|else
name|prs
argument_list|(
literal|" set to "
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|040
condition|)
block|{
name|prs
argument_list|(
literal|"control-"
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|&
literal|037
operator|)
operator||
literal|0100
expr_stmt|;
block|}
name|p
operator|=
literal|"x\n"
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|prs
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|setdelay
argument_list|(
argument|cap
argument_list|,
argument|dtab
argument_list|,
argument|bits
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|delay
name|dtab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|delay
modifier|*
name|p
decl_stmt|;
comment|/* see if this capability exists at all */
name|i
operator|=
name|tgetnum
argument_list|(
name|cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* clear out the bits, replace with new ones */
operator|*
name|flags
operator|&=
operator|~
name|bits
expr_stmt|;
comment|/* scan dtab for first entry with adequate delay */
for|for
control|(
name|p
operator|=
name|dtab
init|;
name|p
operator|->
name|d_delay
operator|>=
literal|0
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|d_delay
operator|>=
name|i
condition|)
block|{
name|p
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* use last entry if none will do */
operator|*
name|flags
operator||=
operator|(
operator|--
name|p
operator|)
operator|->
name|d_bits
expr_stmt|;
block|}
end_block

begin_macro
name|prs
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|prc
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
name|OutBuf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|OutPtr
decl_stmt|;
end_decl_stmt

begin_macro
name|prc
argument_list|(
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|OutBuf
index|[
name|OutPtr
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|OutPtr
operator|>=
sizeof|sizeof
name|OutBuf
condition|)
name|flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|flush
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|OutPtr
operator|>
literal|0
condition|)
name|write
argument_list|(
literal|2
argument_list|,
name|OutBuf
argument_list|,
name|OutPtr
argument_list|)
expr_stmt|;
name|OutPtr
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|cat
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|fd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|prs
argument_list|(
literal|"Cannot open "
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|prs
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|flush
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|FILEDES
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|bmove
argument_list|(
argument|from
argument_list|,
argument|to
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|length
expr_stmt|;
name|p
operator|=
name|from
expr_stmt|;
name|q
operator|=
name|to
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|bequal
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|a
expr_stmt|;
name|q
operator|=
name|b
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|q
operator|&&
operator|(
operator|*
name|p
operator|==
operator|*
name|q
operator|)
operator|&&
operator|--
name|i
operator|>
literal|0
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|*
name|p
operator|==
operator|*
name|q
operator|)
operator|&&
name|i
operator|>=
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|sequal
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|a
decl_stmt|,
modifier|*
name|q
init|=
name|b
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|q
operator|&&
operator|(
operator|*
name|p
operator|==
operator|*
name|q
operator|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|q
operator|++
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|p
operator|==
operator|*
name|q
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|GTTYN
end_ifdef

begin_function
name|char
modifier|*
name|stypeof
parameter_list|(
name|ttyid
parameter_list|)
name|char
modifier|*
name|ttyid
decl_stmt|;
block|{
specifier|static
name|char
name|typebuf
index|[
literal|50
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|PortType
decl_stmt|;
specifier|register
name|char
modifier|*
name|PortName
decl_stmt|;
specifier|register
name|char
modifier|*
name|TtyId
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|f
decl_stmt|;
if|if
condition|(
name|ttyid
operator|==
name|NOTTY
condition|)
return|return
operator|(
name|DEFTYPE
operator|)
return|;
name|f
operator|=
name|fopen
argument_list|(
name|GTTYN
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
return|return
operator|(
name|DEFTYPE
operator|)
return|;
comment|/* split off end of name */
name|TtyId
operator|=
name|ttyid
expr_stmt|;
while|while
condition|(
operator|*
name|ttyid
condition|)
if|if
condition|(
operator|*
name|ttyid
operator|++
operator|==
literal|'/'
condition|)
name|TtyId
operator|=
name|ttyid
expr_stmt|;
comment|/* scan the file */
while|while
condition|(
name|fgets
argument_list|(
name|typebuf
argument_list|,
sizeof|sizeof
name|typebuf
argument_list|,
name|f
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|PortType
operator|=
name|typebuf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|NULL
expr_stmt|;
comment|/* skip separator */
while|while
condition|(
operator|*
name|p
operator|&&
operator|!
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|PortName
operator|=
name|p
expr_stmt|;
comment|/* put NULL at end of name */
while|while
condition|(
operator|*
name|p
operator|&&
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* check match on port name */
if|if
condition|(
name|sequal
argument_list|(
name|PortName
argument_list|,
name|TtyId
argument_list|)
condition|)
comment|/* found it */
block|{
ifdef|#
directive|ifdef
name|OLDDIALUP
if|if
condition|(
name|sequal
argument_list|(
name|PortType
argument_list|,
name|OLDDIALUP
argument_list|)
condition|)
name|PortType
operator|=
name|DIALUP
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OLDPLUGBOARD
if|if
condition|(
name|sequal
argument_list|(
name|PortType
argument_list|,
name|OLDPLUGBOARD
argument_list|)
condition|)
name|PortType
operator|=
name|PLUGBOARD
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|OLDARPANET
if|if
condition|(
name|sequal
argument_list|(
name|PortType
argument_list|,
name|OLDARPANET
argument_list|)
condition|)
name|PortType
operator|=
name|ARPANET
expr_stmt|;
endif|#
directive|endif
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|PortType
operator|)
return|;
block|}
block|}
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
operator|(
name|DEFTYPE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_comment
comment|/*  * routine to output the string for the environment TERMCAP variable  */
end_comment

begin_define
define|#
directive|define
name|WHITE
parameter_list|(
name|c
parameter_list|)
value|(c == ' ' || c == '\t')
end_define

begin_decl_stmt
name|char
name|delcap
index|[
literal|128
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ncap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|wrtermcap
argument_list|(
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
name|CAPBUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|putbuf
parameter_list|()
function_decl|;
name|int
name|space
decl_stmt|,
name|empty
decl_stmt|;
comment|/* discard names with blanks */
comment|/** May not be desireable ? **/
while|while
condition|(
operator|*
name|bp
operator|&&
operator|*
name|bp
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'|'
condition|)
block|{
name|tp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|space
operator|=
name|NO
expr_stmt|;
while|while
condition|(
operator|*
name|tp
operator|&&
operator|*
name|tp
operator|!=
literal|'|'
operator|&&
operator|*
name|tp
operator|!=
literal|':'
condition|)
block|{
name|space
operator|=
operator|(
name|space
operator|||
name|WHITE
argument_list|(
operator|*
name|tp
argument_list|)
operator|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|space
condition|)
block|{
name|bp
operator|=
name|tp
expr_stmt|;
continue|continue;
block|}
block|}
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
block|}
comment|/**/
while|while
condition|(
operator|*
name|bp
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
literal|':'
case|:
comment|/* discard empty, cancelled  or dupl fields */
name|tp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|empty
operator|=
name|YES
expr_stmt|;
while|while
condition|(
operator|*
name|tp
operator|&&
operator|*
name|tp
operator|!=
literal|':'
condition|)
block|{
name|empty
operator|=
operator|(
name|empty
operator|&&
name|WHITE
argument_list|(
operator|*
name|tp
argument_list|)
operator|)
expr_stmt|;
name|tp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|empty
operator|||
name|cancelled
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
condition|)
block|{
name|bp
operator|=
name|tp
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|' '
case|:
comment|/* no spaces in output */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\040"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'"'
case|:
comment|/* no quotes in output */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\042"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\''
case|:
comment|/* no quotes in output */
name|p
operator|=
name|putbuf
argument_list|(
name|p
argument_list|,
literal|"\\047"
argument_list|)
expr_stmt|;
name|bp
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\\'
case|:
case|case
literal|'^'
case|:
comment|/* anything following is OK */
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
block|}
name|write
argument_list|(
name|STDOUT
argument_list|,
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cancelled
argument_list|(
argument|cap
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cap
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncap
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cap
index|[
literal|0
index|]
operator|==
name|delcap
index|[
name|i
index|]
index|[
literal|0
index|]
operator|&&
name|cap
index|[
literal|1
index|]
operator|==
name|delcap
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|YES
operator|)
return|;
block|}
comment|/* delete a second occurrance of the same capability */
name|delcap
index|[
name|ncap
index|]
index|[
literal|0
index|]
operator|=
name|cap
index|[
literal|0
index|]
expr_stmt|;
name|delcap
index|[
name|ncap
index|]
index|[
literal|1
index|]
operator|=
name|cap
index|[
literal|1
index|]
expr_stmt|;
name|ncap
operator|++
expr_stmt|;
return|return
operator|(
name|cap
index|[
literal|2
index|]
operator|==
literal|'@'
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|putbuf
parameter_list|(
name|ptr
parameter_list|,
name|str
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|str
condition|)
operator|*
name|ptr
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_macro
name|baudrate
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
literal|7
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|)
condition|)
name|buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|speeds
index|[
name|i
index|]
operator|.
name|string
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sequal
argument_list|(
name|speeds
index|[
name|i
index|]
operator|.
name|string
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|(
name|speeds
index|[
name|i
index|]
operator|.
name|speed
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|mapped
parameter_list|(
name|type
parameter_list|,
name|speed
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
name|short
name|speed
decl_stmt|;
block|{
name|int
name|match
decl_stmt|;
ifdef|#
directive|ifdef
name|DEB
name|printf
argument_list|(
literal|"spd:%d\n"
argument_list|,
name|speed
argument_list|)
expr_stmt|;
name|prmap
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|Map
operator|=
name|map
expr_stmt|;
while|while
condition|(
name|Map
operator|->
name|Ident
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|Map
operator|->
name|Ident
operator|)
operator|==
name|NULL
operator|||
name|bequal
argument_list|(
name|Map
operator|->
name|Ident
argument_list|,
name|type
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|match
operator|=
name|NO
expr_stmt|;
switch|switch
condition|(
name|Map
operator|->
name|Test
condition|)
block|{
case|case
name|ANY
case|:
comment|/* no test specified */
case|case
name|ALL
case|:
name|match
operator|=
name|YES
expr_stmt|;
break|break;
case|case
name|GT
case|:
name|match
operator|=
operator|(
name|speed
operator|>
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|GE
case|:
name|match
operator|=
operator|(
name|speed
operator|>=
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
name|match
operator|=
operator|(
name|speed
operator|==
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|LE
case|:
name|match
operator|=
operator|(
name|speed
operator|<=
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|LT
case|:
name|match
operator|=
operator|(
name|speed
operator|<
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
case|case
name|NE
case|:
name|match
operator|=
operator|(
name|speed
operator|!=
name|Map
operator|->
name|Speed
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|match
condition|)
return|return
operator|(
name|Map
operator|->
name|Type
operator|)
return|;
block|}
name|Map
operator|++
expr_stmt|;
block|}
comment|/* no match found; return given type */
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEB
end_ifdef

begin_macro
name|prmap
argument_list|()
end_macro

begin_block
block|{
name|Map
operator|=
name|map
expr_stmt|;
while|while
condition|(
name|Map
operator|->
name|Ident
condition|)
block|{
name|printf
argument_list|(
literal|"%s t:%d s:%d %s\n"
argument_list|,
name|Map
operator|->
name|Ident
argument_list|,
name|Map
operator|->
name|Test
argument_list|,
name|Map
operator|->
name|Speed
argument_list|,
name|Map
operator|->
name|Type
argument_list|)
expr_stmt|;
name|Map
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|char
modifier|*
name|nextarg
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|<=
literal|0
condition|)
name|fatal
argument_list|(
literal|"Too few args: "
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|*
operator|++
name|argv
operator|)
operator|==
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"Unexpected arg: "
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|argv
operator|)
return|;
block|}
end_function

begin_macro
name|fatal
argument_list|(
argument|mesg
argument_list|,
argument|obj
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|obj
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|prs
argument_list|(
name|mesg
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|prc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|prs
argument_list|(
name|USAGE
argument_list|)
expr_stmt|;
name|flush
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

