begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* To do:   * Don't store drive configuration on the config DB: read each drive's header  * to decide where it is.  *  * Accept any old crap in the config_<foo> functions, and complain when  * we try to bring it up.  *  * When trying to bring volumes up, check that the complete address range  * is covered.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997, 1998  *	Nan Yang Computer Services Limited.  All rights reserved.  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  * $FreeBSD$  */
end_comment

begin_define
define|#
directive|define
name|STATIC
end_define

begin_comment
comment|/* nothing while we're testing XXX */
end_comment

begin_define
define|#
directive|define
name|REALLYKERNEL
end_define

begin_include
include|#
directive|include
file|"opt_vinum.h"
end_include

begin_include
include|#
directive|include
file|"vinumhdr.h"
end_include

begin_decl_stmt
specifier|extern
name|jmp_buf
name|command_fail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return on a failed command */
end_comment

begin_define
define|#
directive|define
name|MAXTOKEN
value|64
end_define

begin_comment
comment|/* maximum number of tokens in a line */
end_comment

begin_comment
comment|/* We can afford the luxury of global variables here,  * since start_config ensures that these functions  * are single-threaded. */
end_comment

begin_comment
comment|/* These are indices in vinum_conf of the last-mentioned of each kind of object */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_drive
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* note the last drive we mention, for 							    * some defaults */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_plex
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and the same for the last plex */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_volume
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and the last volme */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|_ioctl_reply
modifier|*
name|ioctl_reply
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* struct to return via ioctl */
end_comment

begin_comment
comment|/* These values are used by most of these routines, so set them as globals */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|token
index|[
name|MAXTOKEN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointers to individual tokens */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tokens
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of tokens */
end_comment

begin_define
define|#
directive|define
name|TOCONS
value|0x01
end_define

begin_define
define|#
directive|define
name|TOTTY
value|0x02
end_define

begin_define
define|#
directive|define
name|TOLOG
value|0x04
end_define

begin_struct
struct|struct
name|putchar_arg
block|{
name|int
name|flags
decl_stmt|;
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MSG_MAX
value|1024
end_define

begin_comment
comment|/* maximum length of a formatted message */
end_comment

begin_comment
comment|/* Format an error message and return to the user in the reply.  * CARE: This routine is designed to be called only from the  * configuration routines, so it assumes it's the owner of  * the configuration lock, and unlocks it on exit */
end_comment

begin_function
name|void
name|throw_rude_remark
parameter_list|(
name|int
name|error
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
specifier|static
name|int
name|finishing
decl_stmt|;
comment|/* don't recurse */
name|int
name|was_finishing
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl_reply
operator|!=
name|NULL
operator|)
comment|/* we're called from the user */
operator|&&
operator|(
operator|!
operator|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_KERNELOP
operator|)
operator|)
condition|)
block|{
comment|/* and we're not doing kernel things: return msg */
comment|/* XXX We can't just format to ioctl_reply, since it 	 * may contain our input parameters */
name|text
operator|=
name|Malloc
argument_list|(
name|MSG_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"vinum: can't allocate error message buffer"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vinum: "
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* print to the console */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|kvprintf
argument_list|(
name|msg
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|text
argument_list|,
literal|10
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|text
index|[
name|retval
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* delimit */
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
name|text
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|->
name|error
operator|=
name|error
expr_stmt|;
comment|/* first byte is the error number */
name|Free
argument_list|(
name|text
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"vinum: "
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* print to the console */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_READING_CONFIG
condition|)
comment|/* go through to the bitter end, */
return|return;
comment|/* We have a problem here: we want to unlock the      * configuration, which implies tidying up, but      * if we find an error while tidying up, we could      * recurse for ever.  Use this kludge to only try      * once */
name|was_finishing
operator|=
name|finishing
expr_stmt|;
name|finishing
operator|=
literal|1
expr_stmt|;
name|finish_config
argument_list|(
name|was_finishing
argument_list|)
expr_stmt|;
comment|/* unlock anything we may be holding */
name|finishing
operator|=
name|was_finishing
expr_stmt|;
name|longjmp
argument_list|(
name|command_fail
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function declarations */
end_comment

begin_function_decl
name|int
name|atoi
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* no atoi in the kernel */
end_comment

begin_comment
comment|/* Minimal version of atoi */
end_comment

begin_function
name|int
name|atoi
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
comment|/* no atoi in the kernel */
name|int
name|r
init|=
literal|0
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
while|while
condition|(
operator|(
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|<=
literal|'9'
operator|)
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
name|sign
operator|=
operator|-
name|sign
expr_stmt|;
else|else
name|r
operator|=
name|r
operator|*
literal|10
operator|+
operator|(
operator|*
name|s
operator|-
literal|'0'
operator|)
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Find index of volume in vinum_conf.  Return the index  * if found, or -1 if not */
end_comment

begin_function
name|int
name|volume_index
parameter_list|(
name|struct
name|volume
modifier|*
name|vol
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|volumes_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|&
name|VOL
index|[
name|i
index|]
operator|==
name|vol
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Find index of plex in vinum_conf.  Return the index  * if found, or -1 if not */
end_comment

begin_function
name|int
name|plex_index
parameter_list|(
name|struct
name|plex
modifier|*
name|plex
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|plexes_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|&
name|PLEX
index|[
name|i
index|]
operator|==
name|plex
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Find index of subdisk in vinum_conf.  Return the index  * if found, or -1 if not */
end_comment

begin_function
name|int
name|sd_index
parameter_list|(
name|struct
name|sd
modifier|*
name|sd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|subdisks_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|&
name|SD
index|[
name|i
index|]
operator|==
name|sd
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Find index of drive in vinum_conf.  Return the index  * if found, or -1 if not */
end_comment

begin_function
name|int
name|drive_index
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vinum_conf
operator|.
name|drives_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|&
name|DRIVE
index|[
name|i
index|]
operator|==
name|drive
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Check a volume to see if the plex is already assigned to it.  * Return index in volume->plex, or -1 if not assigned */
end_comment

begin_function
name|int
name|my_plex
parameter_list|(
name|int
name|volno
parameter_list|,
name|int
name|plexno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
comment|/* point to volno */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|plexes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vol
operator|->
name|plex
index|[
name|i
index|]
operator|==
name|plexno
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
comment|/* not found */
block|}
end_function

begin_comment
comment|/* Check a plex to see if the subdisk is already assigned to it.  * Return index in plex->sd, or -1 if not assigned */
end_comment

begin_function
name|int
name|my_sd
parameter_list|(
name|int
name|plexno
parameter_list|,
name|int
name|sdno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|plex
operator|->
name|sdnos
index|[
name|i
index|]
operator|==
name|sdno
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
comment|/* not found */
block|}
end_function

begin_comment
comment|/* Check that this operation is being done in the kernel.  * longjmp out if not.  op the name of the operation. */
end_comment

begin_function
name|void
name|checkkernel
parameter_list|(
name|char
modifier|*
name|op
parameter_list|)
block|{
if|if
condition|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_KERNELOP
operator|==
literal|0
condition|)
name|throw_rude_remark
argument_list|(
name|EPERM
argument_list|,
literal|"Can't perform '%s' from user space"
argument_list|,
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add plex to the volume if possible */
end_comment

begin_function
name|int
name|give_plex_to_volume
parameter_list|(
name|int
name|volno
parameter_list|,
name|int
name|plexno
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
comment|/* XXX It's not an error for the plex to already      * belong to the volume, but we need to check a      * number of things to make sure it's done right.      * Some day. */
if|if
condition|(
name|my_plex
argument_list|(
name|volno
argument_list|,
name|plexno
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|plexno
return|;
comment|/* that's it */
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
comment|/* point to volume */
if|if
condition|(
name|vol
operator|->
name|plexes
operator|==
name|MAXPLEX
condition|)
comment|/* all plexes allocated */
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
literal|"Too many plexes for volume %s"
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|vol
operator|->
name|plexes
operator|>
literal|0
operator|)
comment|/* we have other plexes */
operator|&&
operator|(
name|vol
operator|->
name|flags
operator|&
name|VF_CONFIG_SETUPSTATE
operator|==
literal|0
operator|)
condition|)
comment|/* and we're not setting up state */
name|invalidate_subdisks
argument_list|(
operator|&
name|PLEX
index|[
name|plexno
index|]
argument_list|,
name|sd_stale
argument_list|)
expr_stmt|;
comment|/* make the subdisks invalid */
name|vol
operator|->
name|plex
index|[
name|vol
operator|->
name|plexes
index|]
operator|=
name|plexno
expr_stmt|;
comment|/* this one */
name|vol
operator|->
name|plexes
operator|++
expr_stmt|;
comment|/* add another plex */
name|PLEX
index|[
name|plexno
index|]
operator|.
name|volno
operator|=
name|volno
expr_stmt|;
comment|/* note the number of our volume */
return|return
name|vol
operator|->
name|plexes
operator|-
literal|1
return|;
comment|/* and return its index */
block|}
end_function

begin_comment
comment|/* Add subdisk to a plex if possible */
end_comment

begin_function
name|int
name|give_sd_to_plex
parameter_list|(
name|int
name|plexno
parameter_list|,
name|int
name|sdno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
comment|/* XXX It's not an error for the sd to already      * belong to the plex, but we need to check a      * number of things to make sure it's done right.      * Some day. */
name|i
operator|=
name|my_sd
argument_list|(
name|plexno
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
comment|/* does it already belong to us? */
return|return
name|i
return|;
comment|/* that's it */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* point to the plex */
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
comment|/* and the subdisk */
comment|/* Do we have an offset?  Otherwise put it after the last one */
if|if
condition|(
name|sd
operator|->
name|plexoffset
operator|<
literal|0
condition|)
block|{
comment|/* no offset specified */
if|if
condition|(
name|plex
operator|->
name|subdisks
operator|>
literal|0
condition|)
block|{
name|struct
name|sd
modifier|*
name|lastsd
init|=
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|plex
operator|->
name|subdisks
operator|-
literal|1
index|]
index|]
decl_stmt|;
comment|/* last subdisk */
if|if
condition|(
name|plex
operator|->
name|organization
operator|==
name|plex_concat
condition|)
comment|/* concat, */
name|sd
operator|->
name|plexoffset
operator|=
name|lastsd
operator|->
name|sectors
operator|+
name|lastsd
operator|->
name|plexoffset
expr_stmt|;
comment|/* starts here */
else|else
comment|/* striped or RAID-5, */
name|sd
operator|->
name|plexoffset
operator|=
name|plex
operator|->
name|stripesize
operator|*
name|plex
operator|->
name|subdisks
expr_stmt|;
comment|/* starts here */
block|}
else|else
comment|/* first subdisk */
name|sd
operator|->
name|plexoffset
operator|=
literal|0
expr_stmt|;
comment|/* start at the beginning */
block|}
if|if
condition|(
name|plex
operator|->
name|subdisks
operator|==
name|MAXSD
condition|)
comment|/* we already have our maximum */
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
comment|/* crap out */
literal|"Can't add %s to %s: plex full\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|plex
operator|->
name|name
argument_list|)
expr_stmt|;
name|plex
operator|->
name|subdisks
operator|++
expr_stmt|;
comment|/* another entry */
if|if
condition|(
name|plex
operator|->
name|subdisks
operator|>=
name|plex
operator|->
name|subdisks_allocated
condition|)
comment|/* need more space */
name|EXPAND
argument_list|(
name|plex
operator|->
name|sdnos
argument_list|,
name|int
argument_list|,
name|plex
operator|->
name|subdisks_allocated
argument_list|,
name|INITIAL_SUBDISKS_IN_PLEX
argument_list|)
expr_stmt|;
comment|/* Adjust size of plex and volume. */
name|plex
operator|->
name|length
operator|+=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* plex gets this much bigger */
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* we have a volume */
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
operator|.
name|size
operator|=
name|max
argument_list|(
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
operator|.
name|size
argument_list|,
name|plex
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* adjust its size */
comment|/* We need to check that the subdisks don't overlap,      * but we can't do that until a point where we *must*      * know the size of all the subdisks.  That's not      * here.  But we need to sort them by offset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|plex
operator|->
name|subdisks
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sd
operator|->
name|plexoffset
operator|<
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|i
index|]
index|]
operator|.
name|plexoffset
condition|)
block|{
comment|/* it fits before this one */
comment|/* First move any remaining subdisks by one */
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|plex
operator|->
name|subdisks
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
comment|/* move up one at a time */
name|plex
operator|->
name|sdnos
index|[
name|j
index|]
operator|=
name|plex
operator|->
name|sdnos
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|plex
operator|->
name|sdnos
index|[
name|i
index|]
operator|=
name|sdno
expr_stmt|;
name|sd
operator|->
name|plexsdno
operator|=
name|i
expr_stmt|;
comment|/* note where we are in the subdisk */
return|return
name|i
return|;
block|}
block|}
comment|/* The plex doesn't have any subdisk with a larger      * offset.  Insert it */
name|plex
operator|->
name|sdnos
index|[
name|i
index|]
operator|=
name|sdno
expr_stmt|;
name|sd
operator|->
name|plexsdno
operator|=
name|i
expr_stmt|;
comment|/* note where we are in the subdisk */
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Add a subdisk to drive if possible.  The pointer to the drive  * must already be stored in the sd structure, but the drive  * doesn't know about the subdisk yet.  */
end_comment

begin_function
specifier|static
name|void
name|give_sd_to_drive
parameter_list|(
name|int
name|sdno
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
comment|/* pointer to subdisk */
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
comment|/* and drive */
name|int
name|fe
decl_stmt|;
comment|/* index in free list */
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
comment|/* point to sd */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
expr_stmt|;
comment|/* and drive */
if|if
condition|(
name|drive
operator|->
name|state
operator|!=
name|drive_up
condition|)
name|update_sd_state
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
comment|/* that crashes the subdisk */
if|if
condition|(
name|sd
operator|->
name|sectors
operator|>
name|drive
operator|->
name|sectors_available
condition|)
block|{
comment|/* too big, */
name|sd
operator|->
name|driveoffset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't be confusing */
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
literal|"No space for %s on %s"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
name|drive
operator|->
name|subdisks_used
operator|++
expr_stmt|;
comment|/* one more subdisk */
comment|/* no offset specified, find one */
if|if
condition|(
name|sd
operator|->
name|driveoffset
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|fe
operator|=
literal|0
init|;
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
condition|;
name|fe
operator|++
control|)
block|{
if|if
condition|(
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|>=
name|sd
operator|->
name|sectors
condition|)
block|{
comment|/* it'll fit here */
name|sd
operator|->
name|driveoffset
operator|=
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sectors
operator|==
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
condition|)
block|{
comment|/* used up the entire entry */
if|if
condition|(
name|fe
operator|<
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
literal|1
operator|)
condition|)
comment|/* not the last one, */
name|bcopy
argument_list|(
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
argument_list|,
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
argument_list|,
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
name|fe
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|freelist_entries
operator|--
expr_stmt|;
comment|/* one less entry */
block|}
else|else
block|{
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|-=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* this much less space */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|+=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* this much further on */
block|}
name|drive
operator|->
name|sectors_available
operator|-=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* and note how much less space we have */
break|break;
block|}
block|}
if|if
condition|(
name|fe
operator|==
name|drive
operator|->
name|freelist_entries
condition|)
comment|/* Didn't find anything.  Although the drive has 	     * enough space, it's too fragmented */
block|{
name|sd
operator|->
name|driveoffset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* don't be confusing */
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
literal|"No space for %s on %s"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* specific offset */
comment|/* For a specific offset to work, the space must be 	 * entirely in a single freelist entry.  Look for it. */
name|u_int64_t
name|sdend
init|=
name|sd
operator|->
name|driveoffset
operator|+
name|sd
operator|->
name|sectors
decl_stmt|;
comment|/* end of our subdisk */
for|for
control|(
name|fe
operator|=
literal|0
init|;
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
condition|;
name|fe
operator|++
control|)
block|{
name|u_int64_t
name|dend
init|=
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|+
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
decl_stmt|;
comment|/* end of entry */
if|if
condition|(
name|dend
operator|>=
name|sdend
condition|)
block|{
comment|/* fits before here */
if|if
condition|(
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|>
name|sd
operator|->
name|driveoffset
condition|)
comment|/* starts after the beginning of sd area */
name|throw_rude_remark
argument_list|(
name|ENOSPC
argument_list|,
literal|"No space for subdisk %s on drive %s at offset %qd\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* We've found the space, and we can allocate it. 		 * We don't need to say that to the subdisk, which 		 * already knows about it.  We need to tell it to 		 * the free list, though.  We have four possibilities: 		 * 		 * 1.  The subdisk exactly eats up the entry.  That's the 		 *     same as above. 		 * 2.  The subdisk starts at the beginning and leaves space 		 *     at the end. 		 * 3.  The subdisk starts after the beginning and leaves 		 *     space at the end as well: we end up with another 		 *     fragment. 		 * 4.  The subdisk leaves space at the beginning and finishes 		 *     at the end. 		 */
name|drive
operator|->
name|sectors_available
operator|-=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* note how much less space we have */
if|if
condition|(
name|sd
operator|->
name|driveoffset
operator|==
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
condition|)
block|{
comment|/* 1 or 2 */
if|if
condition|(
name|sd
operator|->
name|sectors
operator|==
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
condition|)
block|{
comment|/* 1: used up the entire entry */
if|if
condition|(
name|fe
operator|<
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
literal|1
operator|)
condition|)
comment|/* not the last one, */
name|bcopy
argument_list|(
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
argument_list|,
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
argument_list|,
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
name|fe
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|freelist_entries
operator|--
expr_stmt|;
comment|/* one less entry */
block|}
else|else
block|{
comment|/* 2: space at the end */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|-=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* this much less space */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|+=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* this much further on */
block|}
block|}
else|else
block|{
comment|/* 3 or 4 */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|=
name|sd
operator|->
name|driveoffset
operator|-
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
expr_stmt|;
if|if
condition|(
name|dend
operator|>
name|sdend
condition|)
block|{
comment|/* 3: space at the end as well */
if|if
condition|(
name|fe
operator|<
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
literal|1
operator|)
condition|)
comment|/* not the last one */
name|bcopy
argument_list|(
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
argument_list|,
comment|/* move the rest down */
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
argument_list|,
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
name|fe
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|freelist_entries
operator|++
expr_stmt|;
comment|/* one less entry */
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
operator|.
name|offset
operator|=
name|sdend
expr_stmt|;
comment|/* second entry starts after sd */
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
operator|.
name|sectors
operator|=
name|dend
operator|-
name|sdend
expr_stmt|;
comment|/* and is this long */
block|}
block|}
break|break;
block|}
block|}
block|}
name|drive
operator|->
name|opencount
operator|++
expr_stmt|;
comment|/* one more subdisk attached */
block|}
end_function

begin_comment
comment|/* Get an empty drive entry from the drive table */
end_comment

begin_function
name|int
name|get_empty_drive
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|driveno
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
comment|/* first see if we have one which has been deallocated */
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_used
condition|;
name|driveno
operator|++
control|)
block|{
if|if
condition|(
name|DRIVE
index|[
name|driveno
index|]
operator|.
name|state
operator|==
name|drive_unallocated
condition|)
comment|/* bingo */
break|break;
block|}
if|if
condition|(
name|driveno
operator|>=
name|vinum_conf
operator|.
name|drives_used
condition|)
comment|/* Couldn't find a deallocated drive.  Allocate a new one */
block|{
name|vinum_conf
operator|.
name|drives_used
operator|++
expr_stmt|;
if|if
condition|(
name|vinum_conf
operator|.
name|drives_used
operator|>
name|vinum_conf
operator|.
name|drives_allocated
condition|)
comment|/* we've used all our allocation */
name|EXPAND
argument_list|(
name|DRIVE
argument_list|,
expr|struct
name|drive
argument_list|,
name|vinum_conf
operator|.
name|drives_allocated
argument_list|,
name|INITIAL_DRIVES
argument_list|)
expr_stmt|;
block|}
comment|/* got a drive entry.  Make it pretty */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
name|bzero
argument_list|(
name|drive
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drive
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|driveno
operator|=
name|driveno
expr_stmt|;
comment|/* put number in structure */
return|return
name|driveno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/* Find the named drive in vinum_conf.drive, return a pointer  * return the index in vinum_conf.drive.  * Don't mark the drive as allocated (XXX SMP)  * If create != 0, create an entry if it doesn't exist  */
end_comment

begin_comment
comment|/* XXX check if we have it open from attach */
end_comment

begin_function
name|int
name|find_drive
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|driveno
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_used
condition|;
name|driveno
operator|++
control|)
block|{
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
comment|/* point to drive */
if|if
condition|(
operator|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
comment|/* it has a name */
operator|&&
operator|(
name|strcmp
argument_list|(
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
comment|/* and it's this one: found */
return|return
name|driveno
return|;
block|}
block|}
comment|/* the drive isn't in the list.  Add it if he wants */
if|if
condition|(
name|create
operator|==
literal|0
condition|)
comment|/* don't want to create */
return|return
operator|-
literal|1
return|;
comment|/* give up */
name|driveno
operator|=
name|get_empty_drive
argument_list|()
expr_stmt|;
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|name
argument_list|,
comment|/* put in its name */
name|drive
operator|->
name|label
operator|.
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|state
operator|=
name|drive_uninit
expr_stmt|;
comment|/* in use, nothing worthwhile there */
name|drive
operator|->
name|flags
operator||=
name|VF_NEWBORN
expr_stmt|;
comment|/* newly born drive */
return|return
name|driveno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/* Find a drive given its device name.  * devname must be valid.  * Otherwise the same as find_drive above */
end_comment

begin_function
name|int
name|find_drive_by_dev
parameter_list|(
specifier|const
name|char
modifier|*
name|devname
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|driveno
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
for|for
control|(
name|driveno
operator|=
literal|0
init|;
name|driveno
operator|<
name|vinum_conf
operator|.
name|drives_used
condition|;
name|driveno
operator|++
control|)
block|{
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
comment|/* point to drive */
if|if
condition|(
operator|(
name|drive
operator|->
name|label
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
comment|/* it has a name */
operator|&&
operator|(
name|strcmp
argument_list|(
name|drive
operator|->
name|devicename
argument_list|,
name|devname
argument_list|)
operator|==
literal|0
operator|)
condition|)
comment|/* and it's this one: found */
return|return
name|driveno
return|;
block|}
comment|/* the drive isn't in the list.  Add it if he wants */
if|if
condition|(
name|create
operator|==
literal|0
condition|)
comment|/* don't want to create */
return|return
operator|-
literal|1
return|;
comment|/* give up */
name|driveno
operator|=
name|get_empty_drive
argument_list|()
expr_stmt|;
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|devname
argument_list|,
comment|/* put in its name */
name|drive
operator|->
name|devicename
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|drive
operator|->
name|devicename
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|devname
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|state
operator|=
name|drive_uninit
expr_stmt|;
comment|/* in use, nothing worthwhile there */
name|drive
operator|->
name|flags
operator||=
name|VF_NEWBORN
expr_stmt|;
comment|/* newly born drive */
return|return
name|driveno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/* Find an empty subdisk in the subdisk table */
end_comment

begin_function
name|int
name|get_empty_sd
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
comment|/* first see if we have one which has been deallocated */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_used
condition|;
name|sdno
operator|++
control|)
block|{
if|if
condition|(
name|SD
index|[
name|sdno
index|]
operator|.
name|state
operator|==
name|sd_unallocated
condition|)
comment|/* bingo */
break|break;
block|}
if|if
condition|(
name|sdno
operator|>=
name|vinum_conf
operator|.
name|subdisks_used
condition|)
block|{
comment|/* No unused sd found.  Allocate a new one */
name|vinum_conf
operator|.
name|subdisks_used
operator|++
expr_stmt|;
if|if
condition|(
name|vinum_conf
operator|.
name|subdisks_used
operator|>
name|vinum_conf
operator|.
name|subdisks_allocated
condition|)
name|EXPAND
argument_list|(
name|SD
argument_list|,
expr|struct
name|sd
argument_list|,
name|vinum_conf
operator|.
name|subdisks_allocated
argument_list|,
name|INITIAL_SUBDISKS
argument_list|)
expr_stmt|;
block|}
comment|/* initialize some things */
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
comment|/* point to it */
name|bzero
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize */
name|sd
operator|->
name|plexno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no plex */
name|sd
operator|->
name|driveno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* and no drive */
name|sd
operator|->
name|plexoffset
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* and no offsets */
name|sd
operator|->
name|driveoffset
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|sdno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/* return a drive to the free pool */
end_comment

begin_function
name|void
name|free_drive
parameter_list|(
name|struct
name|drive
modifier|*
name|drive
parameter_list|)
block|{
name|lockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|vp
operator|!=
name|NULL
condition|)
comment|/* device open */
name|vn_close
argument_list|(
name|drive
operator|->
name|vp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|,
name|FSCRED
argument_list|,
name|drive
operator|->
name|p
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|drive
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|drive
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this also sets drive_unallocated */
name|vinum_conf
operator|.
name|drives_used
operator|--
expr_stmt|;
comment|/* one less drive */
name|unlockdrive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the named subdisk in vinum_conf.sd.   * If create != 0, create an entry if it doesn't exist  *  * Return index in vinum_conf.sd  */
end_comment

begin_function
name|int
name|find_subdisk
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|sdno
decl_stmt|;
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_allocated
condition|;
name|sdno
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|SD
index|[
name|sdno
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
comment|/* found it */
return|return
name|sdno
return|;
block|}
comment|/* the subdisk isn't in the list.  Add it if he wants */
if|if
condition|(
name|create
operator|==
literal|0
condition|)
comment|/* don't want to create */
return|return
operator|-
literal|1
return|;
comment|/* give up */
comment|/* Allocate one and insert the name */
name|sdno
operator|=
name|get_empty_sd
argument_list|()
expr_stmt|;
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|sd
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put in its name */
name|sd
operator|->
name|flags
operator||=
name|VF_NEWBORN
expr_stmt|;
comment|/* newly born subdisk */
return|return
name|sdno
return|;
comment|/* return the pointer */
block|}
end_function

begin_comment
comment|/* Free an allocated sd entry  * This performs memory management only.  remove()  * is responsible for checking relationships.  */
end_comment

begin_function
name|void
name|free_sd
parameter_list|(
name|int
name|sdno
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
name|int
name|fe
decl_stmt|;
comment|/* free list entry */
name|u_int64_t
name|sdend
decl_stmt|;
comment|/* end of our subdisk */
name|u_int64_t
name|dend
decl_stmt|;
comment|/* end of our freelist entry */
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|->
name|driveno
operator|>=
literal|0
operator|)
comment|/* we have a drive, */
operator|&&
operator|(
name|sd
operator|->
name|sectors
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* and some space on it */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|sd
operator|->
name|driveno
index|]
expr_stmt|;
name|sdend
operator|=
name|sd
operator|->
name|driveoffset
operator|+
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* end of our subdisk */
comment|/* Look for where to return the sd address space */
for|for
control|(
name|fe
operator|=
literal|0
init|;
operator|(
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
operator|)
operator|&&
operator|(
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|<
name|sd
operator|->
name|driveoffset
operator|)
condition|;
name|fe
operator|++
control|)
empty_stmt|;
comment|/* Now we are pointing to the last entry, the first 	 * with a higher offset than the subdisk, or both. */
if|if
condition|(
operator|(
name|fe
operator|>
literal|1
operator|)
comment|/* not the first entry */
operator|&&
operator|(
operator|(
name|fe
operator|==
name|drive
operator|->
name|freelist_entries
operator|)
comment|/* gone past the end */
operator|||
operator|(
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|>
name|sd
operator|->
name|driveoffset
operator|)
operator|)
condition|)
comment|/* or past the block were looking for */
name|fe
operator|--
expr_stmt|;
comment|/* point to the block before */
name|dend
operator|=
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|+
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
expr_stmt|;
comment|/* end of the entry */
comment|/* At this point, we are pointing to the correct 	 * place in the free list.  A number of possibilities 	 * exist: 	 * 	 * 1.  The block to be freed immediately follows 	 *     the block to which we are pointing.  Just 	 *     enlarge it. 	 * 2.  The block to be freed starts at the end of 	 *     the current block and ends at the beginning 	 *     of the following block.  Merge the three 	 *     areas into a single block. 	 * 3.  The block to be freed starts after the end 	 *     of the block and ends before the start of 	 *     the following block.  Create a new free block. 	 * 4.  The block to be freed starts after the end 	 *     of the block, but ends at the start of the 	 *     following block.  Enlarge the following block 	 *     downwards. 	 * 	 */
if|if
condition|(
name|sd
operator|->
name|driveoffset
operator|==
name|dend
condition|)
block|{
comment|/* it starts after the end of this block */
if|if
condition|(
operator|(
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
operator|-
literal|1
operator|)
comment|/* we're not the last block in the free list */
operator|&&
operator|(
name|sdend
operator|==
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
operator|.
name|offset
operator|)
condition|)
block|{
comment|/* and the subdisk ends at the start of the 																			   * next block */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|=
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
operator|.
name|sectors
expr_stmt|;
comment|/* 2: merge all three blocks */
if|if
condition|(
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
operator|-
literal|2
condition|)
comment|/* still more blocks after next */
name|bcopy
argument_list|(
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|2
index|]
argument_list|,
comment|/* move down one */
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
argument_list|,
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
literal|2
operator|-
name|fe
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|freelist_entries
operator|--
expr_stmt|;
comment|/* one less entry in the free list */
block|}
else|else
comment|/* 1: just enlarge this block */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|+=
name|sd
operator|->
name|sectors
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sd
operator|->
name|driveoffset
operator|>
name|dend
condition|)
comment|/* it starts after this block */
name|fe
operator|++
expr_stmt|;
comment|/* so look at the next block */
if|if
condition|(
operator|(
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
operator|)
comment|/* we're not the last block in the free list */
operator|&&
operator|(
name|sdend
operator|==
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|)
condition|)
block|{
comment|/* and the subdisk ends at the start of 																		   * this block: case 4 */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|=
name|sd
operator|->
name|driveoffset
expr_stmt|;
comment|/* it starts where the sd was */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|+=
name|sd
operator|->
name|sectors
expr_stmt|;
comment|/* and it's this much bigger */
block|}
else|else
block|{
comment|/* case 3: non-contiguous */
if|if
condition|(
name|fe
operator|<
name|drive
operator|->
name|freelist_entries
condition|)
comment|/* not after the last block, */
name|bcopy
argument_list|(
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
argument_list|,
comment|/* move the rest up one entry */
operator|&
name|drive
operator|->
name|freelist
index|[
name|fe
operator|+
literal|1
index|]
argument_list|,
operator|(
name|drive
operator|->
name|freelist_entries
operator|-
name|fe
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|drive_freelist
argument_list|)
argument_list|)
expr_stmt|;
name|drive
operator|->
name|freelist_entries
operator|++
expr_stmt|;
comment|/* one less entry */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|offset
operator|=
name|sd
operator|->
name|driveoffset
expr_stmt|;
comment|/* this entry represents the sd */
name|drive
operator|->
name|freelist
index|[
name|fe
index|]
operator|.
name|sectors
operator|=
name|sd
operator|->
name|sectors
expr_stmt|;
block|}
block|}
name|drive
operator|->
name|opencount
operator|--
expr_stmt|;
comment|/* one less subdisk attached */
block|}
name|bzero
argument_list|(
name|sd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and clear it out */
name|sd
operator|->
name|state
operator|=
name|sd_unallocated
expr_stmt|;
name|vinum_conf
operator|.
name|subdisks_used
operator|--
expr_stmt|;
comment|/* one less sd */
block|}
end_function

begin_comment
comment|/* Find an empty plex in the plex table */
end_comment

begin_function
name|int
name|get_empty_plex
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|plexno
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
comment|/* if we allocate one */
comment|/* first see if we have one which has been deallocated */
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vinum_conf
operator|.
name|plexes_used
condition|;
name|plexno
operator|++
control|)
block|{
if|if
condition|(
name|PLEX
index|[
name|plexno
index|]
operator|.
name|state
operator|==
name|plex_unallocated
condition|)
comment|/* bingo */
break|break;
comment|/* and get out of here */
block|}
if|if
condition|(
name|plexno
operator|>=
name|vinum_conf
operator|.
name|plexes_used
condition|)
block|{
comment|/* Couldn't find a deallocated plex.  Allocate a new one */
name|vinum_conf
operator|.
name|plexes_used
operator|++
expr_stmt|;
if|if
condition|(
name|vinum_conf
operator|.
name|plexes_used
operator|>
name|vinum_conf
operator|.
name|plexes_allocated
condition|)
name|EXPAND
argument_list|(
name|PLEX
argument_list|,
expr|struct
name|plex
argument_list|,
name|vinum_conf
operator|.
name|plexes_allocated
argument_list|,
name|INITIAL_PLEXES
argument_list|)
expr_stmt|;
block|}
comment|/* Found a plex.  Give it an sd structure */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* this one is ours */
name|bzero
argument_list|(
name|plex
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|plex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* polish it up */
name|plex
operator|->
name|sdnos
operator|=
operator|(
name|int
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|INITIAL_SUBDISKS_IN_PLEX
argument_list|)
expr_stmt|;
comment|/* allocate sd table */
name|CHECKALLOC
argument_list|(
name|plex
operator|->
name|sdnos
argument_list|,
literal|"vinum: Can't allocate plex subdisk table"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|plex
operator|->
name|sdnos
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|INITIAL_SUBDISKS_IN_PLEX
operator|)
argument_list|)
expr_stmt|;
comment|/* do we need this? */
name|plex
operator|->
name|subdisks
operator|=
literal|0
expr_stmt|;
comment|/* no subdisks in use */
name|plex
operator|->
name|subdisks_allocated
operator|=
name|INITIAL_SUBDISKS_IN_PLEX
expr_stmt|;
comment|/* and we have space for this many */
name|plex
operator|->
name|organization
operator|=
name|plex_disorg
expr_stmt|;
comment|/* and it's not organized */
name|plex
operator|->
name|volno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no volume yet */
return|return
name|plexno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/* Find the named plex in vinum_conf.plex   * If create != 0, create an entry if it doesn't exist  * return index in vinum_conf.plex  */
end_comment

begin_function
name|int
name|find_plex
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|plexno
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vinum_conf
operator|.
name|plexes_allocated
condition|;
name|plexno
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|PLEX
index|[
name|plexno
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
comment|/* found it */
return|return
name|plexno
return|;
block|}
comment|/* the plex isn't in the list.  Add it if he wants */
if|if
condition|(
name|create
operator|==
literal|0
condition|)
comment|/* don't want to create */
return|return
operator|-
literal|1
return|;
comment|/* give up */
comment|/* Allocate one and insert the name */
name|plexno
operator|=
name|get_empty_plex
argument_list|()
expr_stmt|;
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* point to it */
name|bcopy
argument_list|(
name|name
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|plex
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put in its name */
name|plex
operator|->
name|flags
operator||=
name|VF_NEWBORN
expr_stmt|;
comment|/* newly born plex */
return|return
name|plexno
return|;
comment|/* return the pointer */
block|}
end_function

begin_comment
comment|/* Free an allocated plex entry  * and its associated memory areas */
end_comment

begin_function
name|void
name|free_plex
parameter_list|(
name|int
name|plexno
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|sdnos
condition|)
name|Free
argument_list|(
name|plex
operator|->
name|sdnos
argument_list|)
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|lock
condition|)
name|Free
argument_list|(
name|plex
operator|->
name|lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|plex
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|plex
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and clear it out */
name|plex
operator|->
name|state
operator|=
name|plex_unallocated
expr_stmt|;
name|vinum_conf
operator|.
name|plexes_used
operator|--
expr_stmt|;
comment|/* one less plex */
block|}
end_function

begin_comment
comment|/* Find an empty volume in the volume table */
end_comment

begin_function
name|int
name|get_empty_volume
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|volno
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
comment|/* first see if we have one which has been deallocated */
for|for
control|(
name|volno
operator|=
literal|0
init|;
name|volno
operator|<
name|vinum_conf
operator|.
name|volumes_used
condition|;
name|volno
operator|++
control|)
block|{
if|if
condition|(
name|VOL
index|[
name|volno
index|]
operator|.
name|state
operator|==
name|volume_unallocated
condition|)
comment|/* bingo */
break|break;
block|}
if|if
condition|(
name|volno
operator|>=
name|vinum_conf
operator|.
name|volumes_used
condition|)
comment|/* Couldn't find a deallocated volume.  Allocate a new one */
block|{
name|vinum_conf
operator|.
name|volumes_used
operator|++
expr_stmt|;
if|if
condition|(
name|vinum_conf
operator|.
name|volumes_used
operator|>
name|vinum_conf
operator|.
name|volumes_allocated
condition|)
name|EXPAND
argument_list|(
name|VOL
argument_list|,
expr|struct
name|volume
argument_list|,
name|vinum_conf
operator|.
name|volumes_allocated
argument_list|,
name|INITIAL_VOLUMES
argument_list|)
expr_stmt|;
block|}
comment|/* Now initialize fields */
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
name|bzero
argument_list|(
name|vol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|volume
argument_list|)
argument_list|)
expr_stmt|;
name|vol
operator|->
name|preferred_plex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* default to round robin */
name|vol
operator|->
name|preferred_plex
operator|=
name|ROUND_ROBIN_READPOL
expr_stmt|;
comment|/* round robin */
return|return
name|volno
return|;
comment|/* return the index */
block|}
end_function

begin_comment
comment|/* Find the named volume in vinum_conf.volume.   * If create != 0, create an entry if it doesn't exist  * return the index in vinum_conf  */
end_comment

begin_function
name|int
name|find_volume
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|create
parameter_list|)
block|{
name|int
name|volno
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
for|for
control|(
name|volno
operator|=
literal|0
init|;
name|volno
operator|<
name|vinum_conf
operator|.
name|volumes_used
condition|;
name|volno
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|VOL
index|[
name|volno
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
comment|/* found it */
return|return
name|volno
return|;
block|}
comment|/* the volume isn't in the list.  Add it if he wants */
if|if
condition|(
name|create
operator|==
literal|0
condition|)
comment|/* don't want to create */
return|return
operator|-
literal|1
return|;
comment|/* give up */
comment|/* Allocate one and insert the name */
name|volno
operator|=
name|get_empty_volume
argument_list|()
expr_stmt|;
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|vol
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put in its name */
name|vol
operator|->
name|blocksize
operator|=
name|DEV_BSIZE
expr_stmt|;
comment|/* block size of this volume */
name|vol
operator|->
name|flags
operator||=
name|VF_NEWBORN
expr_stmt|;
comment|/* newly born volume */
return|return
name|volno
return|;
comment|/* return the pointer */
block|}
end_function

begin_comment
comment|/* Free an allocated volume entry  * and its associated memory areas */
end_comment

begin_function
name|void
name|free_volume
parameter_list|(
name|int
name|volno
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
name|bzero
argument_list|(
name|vol
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|volume
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and clear it out */
name|vol
operator|->
name|state
operator|=
name|volume_unallocated
expr_stmt|;
name|vinum_conf
operator|.
name|volumes_used
operator|--
expr_stmt|;
comment|/* one less volume */
block|}
end_function

begin_comment
comment|/* Handle a drive definition.  We store the information in the global variable  * drive, so we don't need to allocate.  *  * If we find an error, print a message and return  */
end_comment

begin_function
name|void
name|config_drive
parameter_list|(
name|int
name|update
parameter_list|)
block|{
name|enum
name|drive_label_info
name|partition_status
decl_stmt|;
comment|/* info about the partition */
name|int
name|parameter
decl_stmt|;
name|int
name|driveno
decl_stmt|;
comment|/* index of drive in vinum_conf */
name|struct
name|drive
modifier|*
name|drive
decl_stmt|;
comment|/* and pointer to it */
if|if
condition|(
name|tokens
operator|<
literal|2
condition|)
comment|/* not enough tokens */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Drive has no name"
argument_list|)
expr_stmt|;
name|driveno
operator|=
name|find_drive
argument_list|(
name|token
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* allocate a drive to initialize */
name|drive
operator|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
expr_stmt|;
comment|/* and get a pointer */
if|if
condition|(
name|update
operator|&&
operator|(
operator|(
name|drive
operator|->
name|flags
operator|&
name|VF_NEWBORN
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* this drive exists already */
return|return;
comment|/* don't do anything */
name|drive
operator|->
name|flags
operator|&=
operator|~
name|VF_NEWBORN
expr_stmt|;
comment|/* no longer newly born */
if|if
condition|(
name|drive
operator|->
name|state
operator|!=
name|drive_uninit
condition|)
block|{
comment|/* we already know this drive */
comment|/* XXX Check which definition is more up-to-date.  Give 	 * preference for the definition on its own drive */
return|return;
comment|/* XXX */
block|}
for|for
control|(
name|parameter
operator|=
literal|2
init|;
name|parameter
operator|<
name|tokens
condition|;
name|parameter
operator|++
control|)
block|{
comment|/* look at the other tokens */
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
case|case
name|kw_device
case|:
name|parameter
operator|++
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|devicename
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* we know this drive... */
if|if
condition|(
name|strcmp
argument_list|(
name|drive
operator|->
name|devicename
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
condition|)
comment|/* different name */
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
comment|/* close it if it's open */
else|else
comment|/* no change */
break|break;
block|}
comment|/* open the device and get the configuration */
name|bcopy
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
comment|/* insert device information */
name|drive
operator|->
name|devicename
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|drive
operator|->
name|devicename
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|partition_status
operator|=
name|read_drive_label
argument_list|(
name|drive
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|partition_status
condition|)
block|{
case|case
name|DL_CANT_OPEN
case|:
comment|/* not our kind */
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
if|if
condition|(
name|drive
operator|->
name|lasterror
operator|==
name|EFTYPE
condition|)
comment|/* wrong kind of partition */
name|throw_rude_remark
argument_list|(
name|drive
operator|->
name|lasterror
argument_list|,
literal|"Drive %s has invalid partition type"
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* I/O error of some kind */
name|throw_rude_remark
argument_list|(
name|drive
operator|->
name|lasterror
argument_list|,
literal|"Can't initialize drive %s"
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DL_WRONG_DRIVE
case|:
comment|/* valid drive, not the name we expected */
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|throw_rude_remark
argument_list|(
name|drive
operator|->
name|lasterror
argument_list|,
literal|"Incorrect drive name %s specified for drive %s"
argument_list|,
name|token
index|[
literal|1
index|]
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|DL_DELETED_LABEL
case|:
comment|/* it was a drive, but we deleted it */
break|break;
case|case
name|DL_NOT_OURS
case|:
comment|/* nothing to do with the rest */
case|case
name|DL_OURS
case|:
break|break;
block|}
comment|/* read_drive_label overwrites the device name. 	     * If we get here, we can have the drive, 	     * so put it back again */
name|bcopy
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
name|drive
operator|->
name|devicename
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|drive
operator|->
name|devicename
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_state
case|:
name|checkkernel
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* must be a kernel user */
name|drive
operator|->
name|state
operator|=
name|DriveState
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* set the state */
break|break;
default|default:
name|close_drive
argument_list|(
name|drive
argument_list|)
expr_stmt|;
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Drive %s, invalid keyword: %s"
argument_list|,
name|token
index|[
literal|1
index|]
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|drive
operator|->
name|devicename
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|drive
operator|->
name|state
operator|=
name|drive_unallocated
expr_stmt|;
comment|/* deallocate the drive */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"No device name for %s"
argument_list|,
name|drive
operator|->
name|label
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a subdisk definition.  We store the information in the global variable  * sd, so we don't need to allocate.  *  * If we find an error, print a message and return  */
end_comment

begin_function
name|void
name|config_subdisk
parameter_list|(
name|int
name|update
parameter_list|)
block|{
name|int
name|parameter
decl_stmt|;
name|int
name|sdno
decl_stmt|;
comment|/* index of sd in vinum_conf */
name|struct
name|sd
modifier|*
name|sd
decl_stmt|;
comment|/* and pointer to it */
name|u_int64_t
name|size
decl_stmt|;
name|int
name|detached
init|=
literal|0
decl_stmt|;
comment|/* set to 1 if this is a detached subdisk */
name|int
name|sdindex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* index in plexes subdisk table */
name|int
name|namedsdno
decl_stmt|;
name|enum
name|sdstate
name|state
init|=
name|sd_unallocated
decl_stmt|;
comment|/* state to set, if specified */
name|sdno
operator|=
name|get_empty_sd
argument_list|()
expr_stmt|;
comment|/* allocate an SD to initialize */
name|sd
operator|=
operator|&
name|SD
index|[
name|sdno
index|]
expr_stmt|;
comment|/* and get a pointer */
for|for
control|(
name|parameter
operator|=
literal|1
init|;
name|parameter
operator|<
name|tokens
condition|;
name|parameter
operator|++
control|)
block|{
comment|/* look at the other tokens */
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
case|case
name|kw_detached
case|:
name|detached
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|kw_plexoffset
case|:
name|size
operator|=
name|sizespec
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|%
name|DEV_BSIZE
operator|)
operator|!=
literal|0
condition|)
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"sd %s, bad plex offset alignment: %qd"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|sd
operator|->
name|plexoffset
operator|=
name|size
operator|/
name|DEV_BSIZE
expr_stmt|;
break|break;
case|case
name|kw_driveoffset
case|:
name|size
operator|=
name|sizespec
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|%
name|DEV_BSIZE
operator|)
operator|!=
literal|0
condition|)
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"sd %s, bad drive offset alignment: %qd"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|sd
operator|->
name|driveoffset
operator|=
name|size
operator|/
name|DEV_BSIZE
expr_stmt|;
break|break;
case|case
name|kw_name
case|:
name|namedsdno
operator|=
name|find_subdisk
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* find an existing sd with this name */
if|if
condition|(
name|namedsdno
operator|>=
literal|0
condition|)
block|{
comment|/* got one */
if|if
condition|(
name|update
condition|)
comment|/* are we updating? */
return|return;
comment|/* that's OK, nothing more to do */
else|else
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Duplicate subdisk %s"
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|sd
operator|->
name|name
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_len
case|:
name|size
operator|=
name|sizespec
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|%
name|DEV_BSIZE
operator|)
operator|!=
literal|0
condition|)
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"sd %s, length %d not multiple of sector size"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|sd
operator|->
name|sectors
operator|=
name|size
operator|/
name|DEV_BSIZE
expr_stmt|;
break|break;
case|case
name|kw_drive
case|:
name|sd
operator|->
name|driveno
operator|=
name|find_drive
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* insert drive information */
break|break;
case|case
name|kw_plex
case|:
name|sd
operator|->
name|plexno
operator|=
name|find_plex
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* insert plex information */
break|break;
comment|/* Set the state.  We can't do this directly, 	     * because give_sd_to_plex may change it */
case|case
name|kw_state
case|:
name|checkkernel
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* must be a kernel user */
name|state
operator|=
name|SdState
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* set the state */
break|break;
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"sd %s, invalid keyword: %s"
argument_list|,
name|sd
operator|->
name|name
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check we have a drive name */
if|if
condition|(
name|sd
operator|->
name|driveno
operator|<
literal|0
condition|)
block|{
comment|/* didn't specify a drive */
name|sd
operator|->
name|driveno
operator|=
name|current_drive
expr_stmt|;
comment|/* set to the current drive */
if|if
condition|(
name|sd
operator|->
name|driveno
operator|<
literal|0
condition|)
comment|/* no current drive? */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Subdisk %s is not associated with a drive"
argument_list|,
name|sd
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
comment|/*  Check for a plex name */
if|if
condition|(
operator|(
name|sd
operator|->
name|plexno
operator|<
literal|0
operator|)
comment|/* didn't specify a plex */
operator|&&
operator|(
operator|!
name|detached
operator|)
condition|)
comment|/* and didn't say not to, */
name|sd
operator|->
name|plexno
operator|=
name|current_plex
expr_stmt|;
comment|/* set to the current plex */
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
name|sdindex
operator|=
name|give_sd_to_plex
argument_list|(
name|sd
operator|->
name|plexno
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
comment|/* now tell the plex that it has this sd */
name|sd
operator|->
name|sdno
operator|=
name|sdno
expr_stmt|;
comment|/* point to our entry in the table */
comment|/* Does the subdisk have a name?  If not, give it one */
if|if
condition|(
name|sd
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* no name */
name|char
name|sdsuffix
index|[
literal|8
index|]
decl_stmt|;
comment|/* form sd name suffix here */
comment|/* Do we have a plex name? */
if|if
condition|(
name|sdindex
operator|>=
literal|0
condition|)
comment|/* we have a plex */
name|strcpy
argument_list|(
name|sd
operator|->
name|name
argument_list|,
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* take it from there */
else|else
comment|/* no way */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Unnamed sd is not associated with a plex"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|sdsuffix
argument_list|,
literal|".s%d"
argument_list|,
name|sdindex
argument_list|)
expr_stmt|;
comment|/* form the suffix */
name|strcat
argument_list|(
name|sd
operator|->
name|name
argument_list|,
name|sdsuffix
argument_list|)
expr_stmt|;
comment|/* and add it to the name */
block|}
comment|/* do we have complete info for this subdisk? */
if|if
condition|(
name|sd
operator|->
name|sectors
operator|==
literal|0
condition|)
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"sd %s has no length spec"
argument_list|,
name|sd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|sd_unallocated
condition|)
comment|/* we had a specific state to set */
name|sd
operator|->
name|state
operator|=
name|state
expr_stmt|;
comment|/* do it now */
elseif|else
if|if
condition|(
name|sd
operator|->
name|state
operator|==
name|sd_unallocated
condition|)
comment|/* no, nothing set yet, */
name|sd
operator|->
name|state
operator|=
name|sd_up
expr_stmt|;
comment|/* must be up */
comment|/* register the subdisk with the drive.  This action      * will have the side effect of setting the offset if      * we haven't specified one, and causing an error      * message if it overlaps with another subdisk. */
name|give_sd_to_drive
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a plex definition.  */
end_comment

begin_function
name|void
name|config_plex
parameter_list|(
name|int
name|update
parameter_list|)
block|{
name|int
name|parameter
decl_stmt|;
name|int
name|plexno
decl_stmt|;
comment|/* index of plex in vinum_conf */
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
comment|/* and pointer to it */
name|int
name|pindex
init|=
name|MAXPLEX
decl_stmt|;
comment|/* index in volume's plex list */
name|int
name|detached
init|=
literal|0
decl_stmt|;
comment|/* don't give it to a volume */
name|int
name|namedplexno
decl_stmt|;
name|current_plex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* forget the previous plex */
name|plexno
operator|=
name|get_empty_plex
argument_list|()
expr_stmt|;
comment|/* allocate a plex */
name|plex
operator|=
operator|&
name|PLEX
index|[
name|plexno
index|]
expr_stmt|;
comment|/* and point to it */
name|plex
operator|->
name|plexno
operator|=
name|plexno
expr_stmt|;
comment|/* and back to the config */
for|for
control|(
name|parameter
operator|=
literal|1
init|;
name|parameter
operator|<
name|tokens
condition|;
name|parameter
operator|++
control|)
block|{
comment|/* look at the other tokens */
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
case|case
name|kw_detached
case|:
name|detached
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|kw_name
case|:
name|namedplexno
operator|=
name|find_plex
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* find an existing plex with this name */
if|if
condition|(
name|namedplexno
operator|>=
literal|0
condition|)
block|{
comment|/* plex exists already, */
if|if
condition|(
name|update
condition|)
comment|/* are we updating? */
return|return;
comment|/* yes: that's OK, just return */
else|else
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Duplicate plex %s"
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
comment|/* put in the name */
name|plex
operator|->
name|name
argument_list|,
name|min
argument_list|(
name|MAXPLEXNAME
argument_list|,
name|strlen
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_org
case|:
comment|/* plex organization */
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
case|case
name|kw_concat
case|:
name|plex
operator|->
name|organization
operator|=
name|plex_concat
expr_stmt|;
break|break;
case|case
name|kw_striped
case|:
block|{
name|int
name|stripesize
init|=
name|sizespec
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
decl_stmt|;
name|plex
operator|->
name|organization
operator|=
name|plex_striped
expr_stmt|;
if|if
condition|(
name|stripesize
operator|%
name|DEV_BSIZE
operator|!=
literal|0
condition|)
comment|/* not a multiple of block size, */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"plex %s: stripe size %d not a multiple of sector size"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|stripesize
argument_list|)
expr_stmt|;
else|else
name|plex
operator|->
name|stripesize
operator|=
name|stripesize
operator|/
name|DEV_BSIZE
expr_stmt|;
break|break;
block|}
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Invalid plex organization"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|plex
operator|->
name|organization
operator|==
name|plex_striped
operator|)
operator|)
operator|&&
operator|(
name|plex
operator|->
name|stripesize
operator|==
literal|0
operator|)
condition|)
comment|/* didn't specify a valid stripe size */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Need a stripe size parameter"
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_volume
case|:
name|plex
operator|->
name|volno
operator|=
name|find_volume
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* insert a pointer to the volume */
break|break;
case|case
name|kw_sd
case|:
comment|/* add a subdisk */
block|{
name|int
name|sdno
decl_stmt|;
name|sdno
operator|=
name|find_subdisk
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* find a subdisk */
name|SD
index|[
name|sdno
index|]
operator|.
name|plexoffset
operator|=
name|sizespec
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* get the offset */
name|give_sd_to_plex
argument_list|(
name|plexno
argument_list|,
name|sdno
argument_list|)
expr_stmt|;
comment|/* and insert it there */
break|break;
block|}
case|case
name|kw_state
case|:
name|checkkernel
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* only for kernel use */
name|plex
operator|->
name|state
operator|=
name|PlexState
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* set the state */
break|break;
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"plex %s, invalid keyword: %s"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|plex
operator|->
name|volno
operator|<
literal|0
operator|)
comment|/* we don't have a volume */
operator|&&
operator|(
operator|!
name|detached
operator|)
condition|)
comment|/* and we wouldn't object */
name|plex
operator|->
name|volno
operator|=
name|current_volume
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
name|pindex
operator|=
name|give_plex_to_volume
argument_list|(
name|plex
operator|->
name|volno
argument_list|,
name|plexno
argument_list|)
expr_stmt|;
comment|/* Now tell the volume that it has this plex */
comment|/* Does the plex have a name?  If not, give it one */
if|if
condition|(
name|plex
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* no name */
name|char
name|plexsuffix
index|[
literal|8
index|]
decl_stmt|;
comment|/* form plex name suffix here */
comment|/* Do we have a volume name? */
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
comment|/* we have a volume */
name|strcpy
argument_list|(
name|plex
operator|->
name|name
argument_list|,
comment|/* take it from there */
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
comment|/* no way */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Unnamed plex is not associated with a volume"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|plexsuffix
argument_list|,
literal|".p%d"
argument_list|,
name|pindex
argument_list|)
expr_stmt|;
comment|/* form the suffix */
name|strcat
argument_list|(
name|plex
operator|->
name|name
argument_list|,
name|plexsuffix
argument_list|)
expr_stmt|;
comment|/* and add it to the name */
block|}
comment|/* Note the last plex we configured */
name|current_plex
operator|=
name|plexno
expr_stmt|;
if|if
condition|(
name|plex
operator|->
name|state
operator|==
name|plex_unallocated
condition|)
comment|/* we haven't changed the state, */
name|plex
operator|->
name|state
operator|=
name|plex_init
expr_stmt|;
comment|/* we're initialized now */
block|}
end_function

begin_comment
comment|/* Handle a volume definition.  * If we find an error, print a message, deallocate the nascent volume, and return  */
end_comment

begin_function
name|void
name|config_volume
parameter_list|(
name|int
name|update
parameter_list|)
block|{
name|int
name|parameter
decl_stmt|;
name|int
name|volno
decl_stmt|;
name|struct
name|volume
modifier|*
name|vol
decl_stmt|;
comment|/* collect volume info here */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tokens
operator|<
literal|2
condition|)
comment|/* not enough tokens */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Volume has no name"
argument_list|)
expr_stmt|;
name|current_volume
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* forget the previous volume */
name|volno
operator|=
name|find_volume
argument_list|(
name|token
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* allocate a volume to initialize */
name|vol
operator|=
operator|&
name|VOL
index|[
name|volno
index|]
expr_stmt|;
comment|/* and get a pointer */
if|if
condition|(
name|update
operator|&&
operator|(
operator|(
name|vol
operator|->
name|flags
operator|&
name|VF_NEWBORN
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* this volume exists already */
return|return;
comment|/* don't do anything */
name|vol
operator|->
name|flags
operator|&=
operator|~
name|VF_NEWBORN
expr_stmt|;
comment|/* no longer newly born */
for|for
control|(
name|parameter
operator|=
literal|2
init|;
name|parameter
operator|<
name|tokens
condition|;
name|parameter
operator|++
control|)
block|{
comment|/* look at all tokens */
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
case|case
name|kw_plex
case|:
block|{
name|int
name|plexno
decl_stmt|;
comment|/* index of this plex */
name|plexno
operator|=
name|find_plex
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* find a plex */
if|if
condition|(
name|plexno
operator|<
literal|0
condition|)
comment|/* couldn't */
break|break;
comment|/* we've already had an error message */
name|plexno
operator|=
name|my_plex
argument_list|(
name|volno
argument_list|,
name|plexno
argument_list|)
expr_stmt|;
comment|/* does it already belong to us? */
if|if
condition|(
name|plexno
operator|>
literal|0
condition|)
comment|/* yes, shouldn't get it again */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Plex %s already belongs to volume %s"
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|vol
operator|->
name|plexes
operator|>
literal|8
condition|)
comment|/* another entry */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Too many plexes for volume %s"
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
name|vol
operator|->
name|plex
index|[
name|vol
operator|->
name|plexes
operator|-
literal|1
index|]
operator|=
name|plexno
expr_stmt|;
block|}
break|break;
case|case
name|kw_readpol
case|:
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
operator|&
name|keyword_set
argument_list|)
condition|)
block|{
comment|/* decide what to do */
case|case
name|kw_round
case|:
name|vol
operator|->
name|preferred_plex
operator|=
name|ROUND_ROBIN_READPOL
expr_stmt|;
comment|/* default */
break|break;
case|case
name|kw_prefer
case|:
block|{
name|int
name|myplexno
decl_stmt|;
comment|/* index of this plex */
name|myplexno
operator|=
name|find_plex
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* find a plex */
if|if
condition|(
name|myplexno
operator|<
literal|0
condition|)
comment|/* couldn't */
break|break;
comment|/* we've already had an error message */
name|myplexno
operator|=
name|my_plex
argument_list|(
name|volno
argument_list|,
name|myplexno
argument_list|)
expr_stmt|;
comment|/* does it already belong to us? */
if|if
condition|(
name|myplexno
operator|>
literal|0
condition|)
comment|/* yes */
name|vol
operator|->
name|preferred_plex
operator|=
name|myplexno
expr_stmt|;
comment|/* just note the index */
elseif|else
if|if
condition|(
operator|++
name|vol
operator|->
name|plexes
operator|>
literal|8
condition|)
comment|/* another entry */
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Too many plexes"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* space for the new plex */
name|vol
operator|->
name|plex
index|[
name|vol
operator|->
name|plexes
operator|-
literal|1
index|]
operator|=
name|myplexno
expr_stmt|;
comment|/* add it to our list */
name|vol
operator|->
name|preferred_plex
operator|=
name|vol
operator|->
name|plexes
operator|-
literal|1
expr_stmt|;
comment|/* and note the index */
block|}
block|}
break|break;
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"Invalid read policy"
argument_list|)
expr_stmt|;
block|}
case|case
name|kw_setupstate
case|:
name|vol
operator|->
name|flags
operator||=
name|VF_CONFIG_SETUPSTATE
expr_stmt|;
comment|/* set the volume up later on */
break|break;
case|case
name|kw_state
case|:
name|checkkernel
argument_list|(
name|token
index|[
operator|++
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* must be a kernel user */
name|vol
operator|->
name|state
operator|=
name|VolState
argument_list|(
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
comment|/* set the state */
break|break;
comment|/* XXX experimental ideas.  These are not 	     * documented, and will not be until I 	     * decide they're worth keeping */
case|case
name|kw_writethrough
case|:
comment|/* set writethrough mode */
name|vol
operator|->
name|flags
operator||=
name|VF_WRITETHROUGH
expr_stmt|;
break|break;
case|case
name|kw_writeback
case|:
comment|/* set writeback mode */
name|vol
operator|->
name|flags
operator|&=
operator|~
name|VF_WRITETHROUGH
expr_stmt|;
break|break;
case|case
name|kw_raw
case|:
name|vol
operator|->
name|flags
operator||=
name|VF_RAW
expr_stmt|;
comment|/* raw volume (no label) */
break|break;
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
literal|"volume %s, invalid keyword: %s"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|token
index|[
name|parameter
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|current_volume
operator|=
name|volno
expr_stmt|;
comment|/* note last referred volume */
name|vol
operator|->
name|devno
operator|=
name|VINUMBDEV
argument_list|(
name|volno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|VINUM_VOLUME_TYPE
argument_list|)
expr_stmt|;
comment|/* also note device number */
comment|/* Before we can actually use the volume, we need      * a volume label.  We could start to fake one here,      * but it will be a lot easier when we have some      * to copy from the drives, so defer it until we      * set up the configuration. XXX */
if|if
condition|(
name|vol
operator|->
name|state
operator|==
name|volume_unallocated
condition|)
name|vol
operator|->
name|state
operator|=
name|volume_down
expr_stmt|;
comment|/* now ready to bring up at the end */
comment|/* Find out how big our volume is */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|plexes
condition|;
name|i
operator|++
control|)
name|vol
operator|->
name|size
operator|=
name|max
argument_list|(
name|vol
operator|->
name|size
argument_list|,
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|i
index|]
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse a config entry.  CARE!  This destroys the original contents of the  * config entry, which we don't really need after this.  More specifically, it  * places \0 characters at the end of each token.  *  * Return 0 if all is well, otherwise EINVAL */
end_comment

begin_function
name|int
name|parse_config
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|,
name|struct
name|keywordset
modifier|*
name|keyset
parameter_list|,
name|int
name|update
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
comment|/* until proven otherwise */
name|tokens
operator|=
name|tokenize
argument_list|(
name|cptr
argument_list|,
name|token
argument_list|)
expr_stmt|;
comment|/* chop up into tokens */
if|if
condition|(
name|tokens
operator|<=
literal|0
condition|)
comment|/* screwed up or empty line */
return|return
name|tokens
return|;
comment|/* give up */
if|if
condition|(
name|token
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
comment|/* comment line */
return|return
literal|0
return|;
switch|switch
condition|(
name|get_keyword
argument_list|(
name|token
index|[
literal|0
index|]
argument_list|,
name|keyset
argument_list|)
condition|)
block|{
comment|/* decide what to do */
case|case
name|kw_read
case|:
comment|/* read config from a specified drive */
name|vinum_scandisk
argument_list|(
operator|&
name|token
index|[
literal|1
index|]
argument_list|,
name|tokens
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* read the config from disk */
break|break;
case|case
name|kw_drive
case|:
name|config_drive
argument_list|(
name|update
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_subdisk
case|:
name|config_subdisk
argument_list|(
name|update
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_plex
case|:
name|config_plex
argument_list|(
name|update
argument_list|)
expr_stmt|;
break|break;
case|case
name|kw_volume
case|:
name|config_volume
argument_list|(
name|update
argument_list|)
expr_stmt|;
break|break;
comment|/* Anything else is invalid in this context */
default|default:
name|throw_rude_remark
argument_list|(
name|EINVAL
argument_list|,
comment|/* should we die? */
literal|"Invalid configuration information: %s"
argument_list|,
name|token
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* parse a line handed in from userland via ioctl.  * This differs only by the error reporting mechanism:  * we return the error indication in the reply to the  * ioctl, so we need to set a global static pointer in  * this file.  This technique works because we have  * ensured that configuration is performed in a single-  * threaded manner */
end_comment

begin_function
name|int
name|parse_user_config
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|,
name|struct
name|keywordset
modifier|*
name|keyset
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|ioctl_reply
operator|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|cptr
expr_stmt|;
name|status
operator|=
name|parse_config
argument_list|(
name|cptr
argument_list|,
name|keyset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ioctl_reply
operator|=
name|NULL
expr_stmt|;
comment|/* don't do this again */
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* Remove an object */
end_comment

begin_function
name|void
name|remove
parameter_list|(
name|struct
name|vinum_ioctl_msg
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|vinum_ioctl_msg
name|message
init|=
operator|*
name|msg
decl_stmt|;
comment|/* make a copy to hand on */
name|ioctl_reply
operator|=
operator|(
expr|struct
name|_ioctl_reply
operator|*
operator|)
name|msg
expr_stmt|;
comment|/* reinstate the address to reply to */
name|ioctl_reply
operator|->
name|error
operator|=
literal|0
expr_stmt|;
comment|/* no error, */
name|ioctl_reply
operator|->
name|msg
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* no message */
switch|switch
condition|(
name|message
operator|.
name|type
condition|)
block|{
case|case
name|drive_object
case|:
name|remove_drive_entry
argument_list|(
name|message
operator|.
name|index
argument_list|,
name|message
operator|.
name|force
argument_list|,
name|message
operator|.
name|recurse
argument_list|)
expr_stmt|;
name|updateconfig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|sd_object
case|:
name|remove_sd_entry
argument_list|(
name|message
operator|.
name|index
argument_list|,
name|message
operator|.
name|force
argument_list|,
name|message
operator|.
name|recurse
argument_list|)
expr_stmt|;
name|updateconfig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|plex_object
case|:
name|remove_plex_entry
argument_list|(
name|message
operator|.
name|index
argument_list|,
name|message
operator|.
name|force
argument_list|,
name|message
operator|.
name|recurse
argument_list|)
expr_stmt|;
name|updateconfig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|volume_object
case|:
name|remove_volume_entry
argument_list|(
name|message
operator|.
name|index
argument_list|,
name|message
operator|.
name|force
argument_list|,
name|message
operator|.
name|recurse
argument_list|)
expr_stmt|;
name|updateconfig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
default|default:
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"Invalid object type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Remove a drive.  */
end_comment

begin_function
name|void
name|remove_drive_entry
parameter_list|(
name|int
name|driveno
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
name|struct
name|drive
modifier|*
name|drive
init|=
operator|&
name|DRIVE
index|[
name|driveno
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|driveno
operator|>
name|vinum_conf
operator|.
name|drives_used
operator|)
comment|/* not a valid drive */
operator|||
operator|(
name|drive
operator|->
name|state
operator|==
name|drive_unallocated
operator|)
condition|)
block|{
comment|/* or nothing there */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"No such drive"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|drive
operator|->
name|opencount
operator|>
literal|0
condition|)
block|{
comment|/* we have subdisks */
if|if
condition|(
name|force
condition|)
block|{
comment|/* do it at any cost */
name|int
name|sdno
decl_stmt|;
name|struct
name|vinum_ioctl_msg
name|sdmsg
decl_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|vinum_conf
operator|.
name|subdisks_used
condition|;
name|sdno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|state
operator|!=
name|sd_unallocated
operator|)
comment|/* subdisk is allocated */
operator|&&
operator|(
name|SD
index|[
name|sdno
index|]
operator|.
name|driveno
operator|==
name|driveno
operator|)
condition|)
block|{
comment|/* and it belongs to this drive */
name|sdmsg
operator|.
name|index
operator|=
name|sdno
expr_stmt|;
name|sdmsg
operator|.
name|type
operator|=
name|sd_object
expr_stmt|;
name|sdmsg
operator|.
name|recurse
operator|=
literal|1
expr_stmt|;
name|sdmsg
operator|.
name|force
operator|=
name|force
expr_stmt|;
name|remove
argument_list|(
operator|&
name|sdmsg
argument_list|)
expr_stmt|;
comment|/* remove the subdisk by force */
block|}
block|}
name|remove_drive
argument_list|(
name|driveno
argument_list|)
expr_stmt|;
comment|/* now remove it */
block|}
else|else
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* can't do that */
block|}
else|else
name|remove_drive
argument_list|(
name|driveno
argument_list|)
expr_stmt|;
comment|/* just remove it */
block|}
end_function

begin_comment
comment|/* remove a subdisk */
end_comment

begin_function
name|void
name|remove_sd_entry
parameter_list|(
name|int
name|sdno
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
name|struct
name|sd
modifier|*
name|sd
init|=
operator|&
name|SD
index|[
name|sdno
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|sdno
operator|>
name|vinum_conf
operator|.
name|subdisks_used
operator|)
comment|/* not a valid sd */
operator|||
operator|(
name|sd
operator|->
name|state
operator|==
name|sd_unallocated
operator|)
condition|)
block|{
comment|/* or nothing there */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"No such subdisk"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sd
operator|->
name|plexno
operator|>=
literal|0
condition|)
block|{
comment|/* we have a plex */
if|if
condition|(
name|force
condition|)
block|{
comment|/* do it at any cost */
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|sd
operator|->
name|plexno
index|]
decl_stmt|;
comment|/* point to our plex */
name|int
name|mysdno
decl_stmt|;
for|for
control|(
name|mysdno
operator|=
literal|0
init|;
comment|/* look for ourselves */
name|mysdno
operator|<
name|plex
operator|->
name|subdisks
operator|&&
operator|&
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|mysdno
index|]
index|]
operator|!=
name|sd
condition|;
name|mysdno
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|mysdno
operator|==
name|plex
operator|->
name|subdisks
condition|)
comment|/* didn't find it */
name|throw_rude_remark
argument_list|(
name|ENOENT
argument_list|,
literal|"plex %s does not contain subdisk %s"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|sd
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mysdno
operator|<
operator|(
name|plex
operator|->
name|subdisks
operator|-
literal|1
operator|)
condition|)
comment|/* not the last subdisk */
name|bcopy
argument_list|(
operator|&
name|plex
operator|->
name|sdnos
index|[
name|mysdno
operator|+
literal|1
index|]
argument_list|,
operator|&
name|plex
operator|->
name|sdnos
index|[
name|mysdno
index|]
argument_list|,
operator|(
name|plex
operator|->
name|subdisks
operator|-
literal|1
operator|-
name|mysdno
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|plex
operator|->
name|subdisks
operator|--
expr_stmt|;
comment|/* removing a subdisk from a striped or 	     * RAID-5 plex really tears the hell out 	     * of the structure, and it needs to be 	     * reinitialized */
comment|/* XXX Think about this.  Maybe we should just 	     * leave a hole */
if|if
condition|(
name|plex
operator|->
name|organization
operator|!=
name|plex_concat
condition|)
comment|/* not concatenated, */
name|set_plex_state
argument_list|(
name|plex
operator|->
name|plexno
argument_list|,
name|plex_faulty
argument_list|,
name|setstate_force
argument_list|)
expr_stmt|;
comment|/* need to reinitialize */
name|printf
argument_list|(
literal|"vinum: removing %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_sd
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
block|}
else|else
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* can't do that */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"vinum: removing %s\n"
argument_list|,
name|sd
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_sd
argument_list|(
name|sdno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* remove a plex */
end_comment

begin_function
name|void
name|remove_plex_entry
parameter_list|(
name|int
name|plexno
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|plexno
index|]
decl_stmt|;
name|int
name|sdno
decl_stmt|;
if|if
condition|(
operator|(
name|plexno
operator|>
name|vinum_conf
operator|.
name|plexes_used
operator|)
comment|/* not a valid plex */
operator|||
operator|(
name|plex
operator|->
name|state
operator|==
name|plex_unallocated
operator|)
condition|)
block|{
comment|/* or nothing there */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"No such plex"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plex
operator|->
name|pid
condition|)
block|{
comment|/* we're open */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* no getting around that */
return|return;
block|}
if|if
condition|(
name|plex
operator|->
name|subdisks
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
comment|/* do it anyway */
if|if
condition|(
name|recurse
condition|)
block|{
comment|/* remove all below */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
name|free_sd
argument_list|(
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
argument_list|)
expr_stmt|;
comment|/* free all subdisks */
block|}
else|else
block|{
comment|/* just tear them out */
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
operator|.
name|plexno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no plex any more */
block|}
block|}
else|else
block|{
comment|/* can't do it without force */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* can't do that */
return|return;
block|}
block|}
if|if
condition|(
name|plex
operator|->
name|volno
operator|>=
literal|0
condition|)
block|{
comment|/* we are part of a volume */
comment|/* XXX This should be more intelligent.  We should 	 * be able to remove a plex as long as the volume 	 * does not lose any data, which is normally the 	 * case when it has more than one plex.  To do it 	 * right we must compare the completeness of the 	 * mapping of all the plexes in the volume */
if|if
condition|(
name|force
condition|)
block|{
comment|/* do it at any cost */
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|plex
operator|->
name|volno
index|]
decl_stmt|;
name|int
name|myplexno
decl_stmt|;
for|for
control|(
name|myplexno
operator|=
literal|0
init|;
name|myplexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|myplexno
operator|++
control|)
if|if
condition|(
name|vol
operator|->
name|plex
index|[
name|myplexno
index|]
operator|==
name|plexno
condition|)
comment|/* found it */
break|break;
if|if
condition|(
name|myplexno
operator|==
name|vol
operator|->
name|plexes
condition|)
comment|/* didn't find it.  Huh? */
name|throw_rude_remark
argument_list|(
name|ENOENT
argument_list|,
literal|"volume %s does not contain plex %s"
argument_list|,
name|vol
operator|->
name|name
argument_list|,
name|plex
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|myplexno
operator|<
operator|(
name|vol
operator|->
name|plexes
operator|-
literal|1
operator|)
condition|)
comment|/* not the last plex in the list */
name|bcopy
argument_list|(
operator|&
name|vol
operator|->
name|plex
index|[
name|myplexno
operator|+
literal|1
index|]
argument_list|,
operator|&
name|vol
operator|->
name|plex
index|[
name|myplexno
index|]
argument_list|,
name|vol
operator|->
name|plexes
operator|-
literal|1
operator|-
name|myplexno
argument_list|)
expr_stmt|;
name|vol
operator|->
name|plexes
operator|--
expr_stmt|;
block|}
else|else
block|{
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* can't do that */
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"vinum: removing %s\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_plex
argument_list|(
name|plexno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* remove a volume */
end_comment

begin_function
name|void
name|remove_volume_entry
parameter_list|(
name|int
name|volno
parameter_list|,
name|int
name|force
parameter_list|,
name|int
name|recurse
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|volno
index|]
decl_stmt|;
name|int
name|plexno
decl_stmt|;
if|if
condition|(
operator|(
name|volno
operator|>
name|vinum_conf
operator|.
name|volumes_used
operator|)
comment|/* not a valid volume */
operator|||
operator|(
name|vol
operator|->
name|state
operator|==
name|volume_unallocated
operator|)
condition|)
block|{
comment|/* or nothing there */
name|ioctl_reply
operator|->
name|error
operator|=
name|EINVAL
expr_stmt|;
name|strcpy
argument_list|(
name|ioctl_reply
operator|->
name|msg
argument_list|,
literal|"No such volume"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vol
operator|->
name|opencount
condition|)
comment|/* we're open */
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* no getting around that */
elseif|else
if|if
condition|(
name|vol
operator|->
name|plexes
condition|)
block|{
if|if
condition|(
name|recurse
operator|&&
name|force
condition|)
block|{
comment|/* remove all below */
name|struct
name|vinum_ioctl_msg
name|plexmsg
decl_stmt|;
name|plexmsg
operator|.
name|type
operator|=
name|plex_object
expr_stmt|;
name|plexmsg
operator|.
name|recurse
operator|=
literal|1
expr_stmt|;
name|plexmsg
operator|.
name|force
operator|=
name|force
expr_stmt|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
name|plexmsg
operator|.
name|index
operator|=
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
expr_stmt|;
comment|/* plex number */
name|remove
argument_list|(
operator|&
name|plexmsg
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"vinum: removing %s\n"
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_volume
argument_list|(
name|volno
argument_list|)
expr_stmt|;
block|}
else|else
name|ioctl_reply
operator|->
name|error
operator|=
name|EBUSY
expr_stmt|;
comment|/* can't do that */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"vinum: removing %s\n"
argument_list|,
name|vol
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_volume
argument_list|(
name|volno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|update_sd_config
parameter_list|(
name|int
name|sdno
parameter_list|,
name|int
name|kernelstate
parameter_list|)
block|{
if|if
condition|(
operator|!
name|kernelstate
condition|)
name|set_sd_state
argument_list|(
name|sdno
argument_list|,
name|sd_up
argument_list|,
name|setstate_configuring
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|update_plex_config
parameter_list|(
name|int
name|plexno
parameter_list|,
name|int
name|kernelstate
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|size
decl_stmt|;
name|int
name|sdno
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
init|=
operator|&
name|PLEX
index|[
name|plexno
index|]
decl_stmt|;
name|enum
name|plexstate
name|state
init|=
name|plex_up
decl_stmt|;
comment|/* state we want the plex in */
comment|/* XXX Insert checks here for sparse plexes and volumes */
comment|/* Check that our subdisks make sense.  For      * striped and RAID5 plexes, we need at least      * two subdisks, and they must all be the same      * size */
if|if
condition|(
operator|(
operator|(
name|plex
operator|->
name|organization
operator|==
name|plex_striped
operator|)
operator|)
operator|&&
operator|(
name|plex
operator|->
name|subdisks
operator|<
literal|2
operator|)
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"vinum: plex %s does not have at least 2 subdisks\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kernelstate
condition|)
name|set_plex_state
argument_list|(
name|plexno
argument_list|,
name|plex_down
argument_list|,
name|setstate_force
operator||
name|setstate_configuring
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sdno
operator|=
literal|0
init|;
name|sdno
operator|<
name|plex
operator|->
name|subdisks
condition|;
name|sdno
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|plex
operator|->
name|organization
operator|==
name|plex_striped
operator|)
operator|)
operator|&&
operator|(
name|sdno
operator|>
literal|0
operator|)
operator|&&
operator|(
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
operator|.
name|sectors
operator|!=
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
operator|-
literal|1
index|]
index|]
operator|.
name|sectors
operator|)
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"vinum: %s must have equal sized subdisks\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|)
expr_stmt|;
name|set_plex_state
argument_list|(
name|plexno
argument_list|,
name|plex_down
argument_list|,
name|setstate_force
operator||
name|setstate_configuring
argument_list|)
expr_stmt|;
block|}
name|size
operator|+=
name|SD
index|[
name|plex
operator|->
name|sdnos
index|[
name|sdno
index|]
index|]
operator|.
name|sectors
expr_stmt|;
block|}
if|if
condition|(
name|plex
operator|->
name|subdisks
condition|)
block|{
comment|/* plex has subdisks, calculate size */
comment|/* XXX We shouldn't need to calculate the size any 	 * more.  Check this some time */
if|if
condition|(
name|plex
operator|->
name|length
operator|!=
name|size
condition|)
name|printf
argument_list|(
literal|"Correcting length of %s: was %qd, is %qd\n"
argument_list|,
name|plex
operator|->
name|name
argument_list|,
name|plex
operator|->
name|length
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|plex
operator|->
name|length
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* no subdisks, */
name|plex
operator|->
name|length
operator|=
literal|0
expr_stmt|;
comment|/* no size */
name|state
operator|=
name|plex_down
expr_stmt|;
comment|/* take it down */
block|}
if|if
condition|(
operator|!
operator|(
name|kernelstate
operator|||
name|error
operator|)
condition|)
name|set_plex_state
argument_list|(
name|plexno
argument_list|,
name|state
argument_list|,
name|setstate_none
operator||
name|setstate_configuring
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|update_volume_config
parameter_list|(
name|int
name|volno
parameter_list|,
name|int
name|kernelstate
parameter_list|)
block|{
name|struct
name|volume
modifier|*
name|vol
init|=
operator|&
name|VOL
index|[
name|volno
index|]
decl_stmt|;
name|struct
name|plex
modifier|*
name|plex
decl_stmt|;
name|int
name|plexno
decl_stmt|;
if|if
condition|(
name|vol
operator|->
name|state
operator|!=
name|volume_unallocated
condition|)
comment|/* Recalculate the size of the volume */
block|{
name|vol
operator|->
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vol
operator|->
name|plexes
condition|;
name|plexno
operator|++
control|)
block|{
name|plex
operator|=
operator|&
name|PLEX
index|[
name|vol
operator|->
name|plex
index|[
name|plexno
index|]
index|]
expr_stmt|;
name|vol
operator|->
name|size
operator|=
name|max
argument_list|(
name|plex
operator|->
name|length
argument_list|,
name|vol
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* maximum size */
name|plex
operator|->
name|volplexno
operator|=
name|plexno
expr_stmt|;
comment|/* note it in the plex */
block|}
block|}
if|if
condition|(
operator|!
name|kernelstate
condition|)
comment|/* try to bring it up */
name|set_volume_state
argument_list|(
name|volno
argument_list|,
name|volume_up
argument_list|,
name|setstate_configuring
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update the global configuration.  * kernelstate is != 0 if we're reading in a config  * from disk.  In this case, we don't try to  * bring the devices up, though we will bring  * them down if there's some error which got  * missed when writing to disk.  */
end_comment

begin_function
name|void
name|updateconfig
parameter_list|(
name|int
name|kernelstate
parameter_list|)
block|{
name|int
name|plexno
decl_stmt|;
name|int
name|volno
decl_stmt|;
for|for
control|(
name|plexno
operator|=
literal|0
init|;
name|plexno
operator|<
name|vinum_conf
operator|.
name|plexes_used
condition|;
name|plexno
operator|++
control|)
name|update_plex_config
argument_list|(
name|plexno
argument_list|,
name|kernelstate
argument_list|)
expr_stmt|;
for|for
control|(
name|volno
operator|=
literal|0
init|;
name|volno
operator|<
name|vinum_conf
operator|.
name|volumes_used
condition|;
name|volno
operator|++
control|)
block|{
name|VOL
index|[
name|volno
index|]
operator|.
name|flags
operator|&=
operator|~
name|VF_CONFIG_SETUPSTATE
expr_stmt|;
comment|/* no more setupstate */
name|set_volume_state
argument_list|(
name|volno
argument_list|,
name|volume_up
argument_list|,
name|setstate_configuring
argument_list|)
expr_stmt|;
block|}
name|save_config
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start manual changes to the configuration and lock out  * others who may wish to do so.  * XXX why do we need this and lock_config too? */
end_comment

begin_function
name|int
name|start_config
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
while|while
condition|(
operator|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_CONFIGURING
operator|)
operator|!=
literal|0
condition|)
block|{
name|vinum_conf
operator|.
name|flags
operator||=
name|VF_WILL_CONFIGURE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|vinum_conf
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"vincfg"
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
block|}
comment|/* We need two flags here: VF_CONFIGURING      * tells other processes to hold off (this      * function), and VF_CONFIG_INCOMPLETE      * tells the state change routines not to      * propagate incrememntal state changes */
name|vinum_conf
operator|.
name|flags
operator||=
name|VF_CONFIGURING
operator||
name|VF_CONFIG_INCOMPLETE
expr_stmt|;
name|current_drive
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* reset the defaults */
name|current_plex
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* and the same for the last plex */
name|current_volume
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* and the last volme */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Update the config if update is 1, and unlock  * it.  We won't update the configuration if we  * are called in a recursive loop via throw_rude_remark.  */
end_comment

begin_function
name|void
name|finish_config
parameter_list|(
name|int
name|update
parameter_list|)
block|{
name|vinum_conf
operator|.
name|flags
operator|&=
operator|~
name|VF_CONFIG_INCOMPLETE
expr_stmt|;
comment|/* we've finished our config */
if|if
condition|(
name|update
condition|)
name|updateconfig
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* so update things */
else|else
name|updateconfig
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* do some updates only */
name|vinum_conf
operator|.
name|flags
operator|&=
operator|~
name|VF_CONFIGURING
expr_stmt|;
comment|/* and now other people can take a turn */
if|if
condition|(
operator|(
name|vinum_conf
operator|.
name|flags
operator|&
name|VF_WILL_CONFIGURE
operator|)
operator|!=
literal|0
condition|)
block|{
name|vinum_conf
operator|.
name|flags
operator|&=
operator|~
name|VF_WILL_CONFIGURE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|vinum_conf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

